var bundle = (function (exports) {
    'use strict';

    var n,l$1,u$1,t,o$2,r$2,f$1={},e$1=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$1(n,l){for(var u in l)n[u]=l[u];return n}function a$1(n){var l=n.parentNode;l&&l.removeChild(n);}function h$1(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return v$1(l,f,t,o,null)}function v$1(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u$1:r};return null==r&&null!=l$1.vnode&&l$1.vnode(f),f}function p$1(n){return n.children}function d$1(n,l){this.props=n,this.context=l;}function _$2(n,l){if(null==l)return n.__?_$2(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?_$2(n):null}function k$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k$1(n)}}function b(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2);}function g$2(){for(var n;g$2.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=s$1({},t)).__v=t.__v+1,j$2(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?_$2(t):o,t.__h),z$2(u,t),t.__e!=o&&k$1(t)));});}function w$2(n,l,u,i,t,o,r,c,s,a){var h,y,d,k,b,g,w,x=i&&i.__k||e$1,C=x.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v$1(null,k,null,null,k):Array.isArray(k)?v$1(p$1,{children:k},null,null,null):k.__b>0?v$1(k.type,k.props,k.key,k.ref?k.ref:null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=x[h])||d&&k.key==d.key&&k.type===d.type)x[h]=void 0;else for(y=0;y<C;y++){if((d=x[y])&&k.key==d.key&&k.type===d.type){x[y]=void 0;break}d=null;}j$2(n,k,d=d||f$1,t,o,r,c,s,a),b=k.__e,(y=k.ref)&&d.ref!=y&&(w||(w=[]),d.ref&&w.push(d.ref,null,k),w.push(y,k.__c||b,k)),null!=b?(null==g&&(g=b),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=m$1(k,s,n):s=A$1(n,k,d,x,b,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_$2(d));}for(u.__e=g,h=C;h--;)null!=x[h]&&N(x[h],x[h]);if(w)for(h=0;h<w.length;h++)M$1(w[h],w[++h],w[++h]);}function m$1(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l="function"==typeof i.type?m$1(i,l,u):A$1(u,i,i,t,i.__e,l));return l}function x$1(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){x$1(n,l);}):l.push(n)),l}function A$1(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function C$2(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H$1(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H$1(n,o,l[o],u[o],i);}function $(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c$1.test(l)?u:u+"px";}function H$1(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T$2:I$1,o):n.removeEventListener(l,o?T$2:I$1,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&-1==l.indexOf("-")?n.removeAttribute(l):n.setAttribute(l,u));}}function I$1(n){this.l[n.type+!1](l$1.event?l$1.event(n):n);}function T$2(n){this.l[n.type+!0](l$1.event?l$1.event(n):n);}function j$2(n,u,i,t,o,r,f,e,c){var a,h,v,y,_,k,b,g,m,x,A,C,$,H=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=l$1.__b)&&a(u);try{n:if("function"==typeof H){g=u.props,m=(a=H.contextType)&&t[a.__c],x=a?m?m.props.value:a.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in H&&H.prototype.render?u.__c=h=new H(g,x):(u.__c=h=new d$1(g,x),h.constructor=H,h.render=O$1),m&&m.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[],h._sb=[]),null==h.__s&&(h.__s=h.state),null!=H.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s$1({},h.__s)),s$1(h.__s,H.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state;for(a=0;a<h._sb.length;a++)h.__h.push(h._sb[a]),h._sb=[];if(v)null==H.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==H.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,k);});}if(h.context=x,h.props=g,h.__v=u,h.__P=n,A=l$1.__r,C=0,"prototype"in H&&H.prototype.render)h.state=h.__s,h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context);else do{h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++C<25);h.state=h.__s,null!=h.getChildContext&&(t=s$1(s$1({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,_)),$=null!=a&&a.type===p$1&&null==a.key?a.props.children:a,w$2(n,Array.isArray($)?$:[$],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L$1(i.__e,u,i,t,o,r,f,c);(a=l$1.diffed)&&a(u);}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l$1.__e(n,u,i);}}function z$2(n,u){l$1.__c&&l$1.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$1.__e(n,u.__v);}});}function L$1(l,u,i,t,o,r,e,c){var s,h,v,y=i.props,p=u.props,d=u.type,k=0;if("svg"===d&&(o=!0),null!=r)for(;k<r.length;k++)if((s=r[k])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[k]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(r=r&&n.call(l.childNodes),h=(y=i.props||f$1).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},k=0;k<l.attributes.length;k++)y[l.attributes[k].name]=l.attributes[k].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C$2(l,p,y,o,c),v)u.__k=[];else if(k=u.props.children,w$2(l,Array.isArray(k)?k:[k],u,i,t,o&&"foreignObject"!==d,r,e,r?r[0]:i.__k&&_$2(i,0),c),null!=r)for(k=r.length;k--;)null!=r[k]&&a$1(r[k]);c||("value"in p&&void 0!==(k=p.value)&&(k!==l.value||"progress"===d&&!k||"option"===d&&k!==y.value)&&H$1(l,"value",k,y.value,!1),"checked"in p&&void 0!==(k=p.checked)&&k!==l.checked&&H$1(l,"checked",k,y.checked,!1));}return l}function M$1(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$1.__e(n,i);}}function N(n,u,i){var t,o;if(l$1.unmount&&l$1.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M$1(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$1.__e(n,u);}t.base=t.__P=null,n.__c=void 0;}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,i||"function"!=typeof n.type);i||null==n.__e||a$1(n.__e),n.__=n.__e=n.__d=void 0;}function O$1(n,l,u){return this.constructor(n,u)}function P(u,i,t){var o,r,e;l$1.__&&l$1.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,e=[],j$2(i,u=(!o&&t||i).__k=h$1(p$1,null,[u]),r||f$1,f$1,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,e,!o&&t?t:r?r.__e:i.firstChild,o),z$2(e,u);}function B$2(n,l){var u={__c:l="__cC"+r$2++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(b);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=e$1.slice,l$1={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l;}throw n}},u$1=0,d$1.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s$1({},this.state),"function"==typeof n&&(n=n(s$1({},u),this.props)),n&&s$1(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),b(this));},d$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),b(this));},d$1.prototype.render=p$1,t=[],g$2.__r=0,r$2=0;

    var _$1=0;function o$1(o,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:o,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_$1,__source:f,__self:t};if("function"==typeof o&&(l=o.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return l$1.vnode&&l$1.vnode(a),a}

    var r$1,u,i,o,f=0,c=[],e=[],a=l$1.__b,v=l$1.__r,l=l$1.diffed,m=l$1.__c,d=l$1.unmount;function p(t,r){l$1.__h&&l$1.__h(u,t,f||r),f=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({__V:e}),i.__[t]}function y(n){return f=1,h(C$1,n)}function h(n,t,i){var o=p(r$1++,2);if(o.t=n,!o.__c&&(o.__=[i?i(t):C$1(void 0,t),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}));}],o.__c=u,!u.u)){u.u=!0;var f=u.shouldComponentUpdate;u.shouldComponentUpdate=function(n,t,r){if(!o.__c.__H)return !0;var u=o.__c.__H.__.filter(function(n){return n.__c});if(u.every(function(n){return !n.__N}))return !f||f.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0);}}),!(!i&&o.__c.props===n)&&(!f||f.call(this,n,t,r))};}return o.__N||o.__}function s(t,i){var o=p(r$1++,3);!l$1.__s&&B$1(o.__H,i)&&(o.__=t,o.i=i,u.__H.__h.push(o));}function _(t,i){var o=p(r$1++,4);!l$1.__s&&B$1(o.__H,i)&&(o.__=t,o.i=i,u.__h.push(o));}function A(n){return f=5,T$1(function(){return {current:n}},[])}function T$1(n,t){var u=p(r$1++,7);return B$1(u.__H,t)?(u.__V=n(),u.i=t,u.__h=n,u.__V):u.__}function q$1(n,t){return f=8,T$1(function(){return n},t)}function x(n){var t=u.context[n.__c],i=p(r$1++,9);return i.c=n,t?(null==i.__&&(i.__=!0,t.sub(u)),t.props.value):n.__}function g$1(){for(var t;t=c.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(w$1),t.__H.__h.forEach(z$1),t.__H.__h=[];}catch(r){t.__H.__h=[],l$1.__e(r,t.__v);}}l$1.__b=function(n){"function"!=typeof n.type||n.__m||n.type===p$1?n.__m||(n.__m=n.__&&n.__.__m?n.__.__m:""):n.__m=(n.__&&n.__.__m?n.__.__m:"")+(n.__&&n.__.__k?n.__.__k.indexOf(n):0),u=null,a&&a(n);},l$1.__r=function(n){v&&v(n),r$1=0;var t=(u=n.__c).__H;t&&(i===u?(t.__h=[],u.__h=[],t.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=e,n.__N=n.i=void 0;})):(t.__h.forEach(w$1),t.__h.forEach(z$1),t.__h=[])),i=u;},l$1.diffed=function(t){l&&l(t);var r=t.__c;r&&r.__H&&(r.__H.__h.length&&(1!==c.push(r)&&o===l$1.requestAnimationFrame||((o=l$1.requestAnimationFrame)||k)(g$1)),r.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==e&&(n.__=n.__V),n.i=void 0,n.__V=e;})),i=u=null;},l$1.__c=function(t,r){r.some(function(t){try{t.__h.forEach(w$1),t.__h=t.__h.filter(function(n){return !n.__||z$1(n)});}catch(u){r.some(function(n){n.__h&&(n.__h=[]);}),r=[],l$1.__e(u,t.__v);}}),m&&m(t,r);},l$1.unmount=function(t){d&&d(t);var r,u=t.__c;u&&u.__H&&(u.__H.__.forEach(function(n){try{w$1(n);}catch(n){r=n;}}),u.__H=void 0,r&&l$1.__e(r,u.__v));};var j$1="function"==typeof requestAnimationFrame;function k(n){var t,r=function(){clearTimeout(u),j$1&&cancelAnimationFrame(t),setTimeout(n);},u=setTimeout(r,100);j$1&&(t=requestAnimationFrame(r));}function w$1(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function z$1(n){var t=u;n.__c=n.__(),u=t;}function B$1(n,t){return !n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function C$1(n,t){return "function"==typeof t?t(n):t}

    function g(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function w(n,e){function r(n){var t=this.props.ref,r=t==n.ref;return !r&&t&&(t.call?t(null):t.current=null),e?!e(this.props,n)||!r:C(this.props,n)}function u(e){return this.shouldComponentUpdate=r,h$1(n,e)}return u.displayName="Memo("+(n.displayName||n.name)+")",u.prototype.isReactComponent=!0,u.__f=!0,u}(E.prototype=new d$1).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var R=l$1.__b;l$1.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),R&&R(n);};var O=l$1.__e;l$1.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);O(n,t,e,r);};var T=l$1.unmount;function I(n,t,e){return n&&(n.__c&&n.__c.__H&&(n.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),n.__c.__H=null),null!=(n=g({},n)).__c&&(n.__c.__P===e&&(n.__c.__P=t),n.__c=null),n.__k=n.__k&&n.__k.map(function(n){return I(n,t,e)})),n}function L(n,t,e){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(function(n){return L(n,t,e)}),n.__c&&n.__c.__P===t&&(n.__e&&e.insertBefore(n.__e,n.__d),n.__c.__e=!0,n.__c.__P=e)),n}function U(){this.__u=0,this.t=null,this.__b=null;}function D(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function M(){this.u=null,this.o=null;}l$1.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),T&&T(n);},(U.prototype=new d$1).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=D(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=L(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i);},U.prototype.componentWillUnmount=function(){this.t=[];},U.prototype.render=function(n,e){if(this.__b){if(this.__v.__k){var r=document.createElement("div"),o=this.__v.__k[0].__c;this.__v.__k[0]=I(this.__b,r,o.__O=o.__P);}this.__b=null;}var i=e.__a&&h$1(p$1,null,n.fallback);return i&&(i.__h=null),[h$1(p$1,null,e.__a?null:n.children),i]};var V=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};(M.prototype=new d$1).__a=function(n){var t=this,e=D(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),V(t,n,r)):u();};e?e(o):o();}},M.prototype.render=function(n){this.u=null,this.o=new Map;var t=x$1(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){V(n,e,t);});};var j="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,z=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,B="undefined"!=typeof document,H=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(t){Object.defineProperty(d$1.prototype,t,{configurable:!0,get:function(){return this["UNSAFE_"+t]},set:function(n){Object.defineProperty(this,t,{configurable:!0,writable:!0,value:n});}});});var q=l$1.event;function G(){}function J(){return this.cancelBubble}function K(){return this.defaultPrevented}l$1.event=function(n){return q&&(n=q(n)),n.persist=G,n.isPropagationStopped=J,n.isDefaultPrevented=K,n.nativeEvent=n};var X={configurable:!0,get:function(){return this.class}},nn=l$1.vnode;l$1.vnode=function(n){var t=n.type,e=n.props,u=e;if("string"==typeof t){var o=-1===t.indexOf("-");for(var i in u={},e){var l=e[i];B&&"children"===i&&"noscript"===t||"value"===i&&"defaultValue"in e&&null==l||("defaultValue"===i&&"value"in e&&null==e.value?i="value":"download"===i&&!0===l?l="":/ondoubleclick/i.test(i)?i="ondblclick":/^onchange(textarea|input)/i.test(i+t)&&!H(e.type)?i="oninput":/^onfocus$/i.test(i)?i="onfocusin":/^onblur$/i.test(i)?i="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i)?i=i.toLowerCase():o&&z.test(i)?i=i.replace(/[A-Z0-9]/g,"-$&").toLowerCase():null===l&&(l=void 0),/^oninput$/i.test(i)&&(i=i.toLowerCase(),u[i]&&(i="oninputCapture")),u[i]=l);}"select"==t&&u.multiple&&Array.isArray(u.value)&&(u.value=x$1(e.children).forEach(function(n){n.props.selected=-1!=u.value.indexOf(n.props.value);})),"select"==t&&null!=u.defaultValue&&(u.value=x$1(e.children).forEach(function(n){n.props.selected=u.multiple?-1!=u.defaultValue.indexOf(n.props.value):u.defaultValue==n.props.value;})),n.props=u,e.class!=e.className&&(X.enumerable="className"in e,null!=e.className&&(u.class=e.className),Object.defineProperty(u,"className",X));}n.$$typeof=j,nn&&nn(n);};var tn=l$1.__r;l$1.__r=function(n){tn&&tn(n),n.__c;};

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */
    function useEnsureStability(parentHookName, ...values) {
        useHelper(values.length, 0);
        values.forEach(useHelper);
        return;
        function useHelper(value, index) {
            // Make sure that the provided functions are perfectly stable across renders
            const helperToEnsureStability = A(value);
            const shownError = A(false);
            if (helperToEnsureStability.current != value) {
                if (!shownError.current) {
                    /* eslint-disable no-debugger */
                    debugger;
                    console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
                    shownError.current = true;
                }
            }
        }
    }
    function debounceRendering(f) {
        (l$1.debounceRendering ?? setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
     * @returns
     */
    function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
        const valueRef = A(Unset$1);
        const warningRef = A(false);
        const cleanupCallbackRef = A(undefined);
        // Make sure that the provided functions are perfectly stable across renders
        useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
        // Shared between "dependency changed" and "component unmounted".
        const onShouldCleanUp = q$1(() => {
            const cleanupCallback = cleanupCallbackRef.current;
            if (cleanupCallback)
                cleanupCallback();
        }, []);
        // There are a couple places where we'd like to use our initial
        // value in place of having no value at all yet.
        // This is the shared code for that, used on mount and whenever
        // getValue is called.
        const tryEnsureValue = q$1(() => {
            if (valueRef.current === Unset$1 && getInitialValue != undefined) {
                try {
                    const initialValue = getInitialValue();
                    valueRef.current = initialValue;
                    cleanupCallbackRef.current = (onChange?.(initialValue, undefined) ?? undefined);
                }
                catch (ex) {
                    // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
                }
            }
        }, [ /* getInitialValue and onChange intentionally omitted */]);
        const getValue = q$1(() => {
            if (warningRef.current)
                console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
            // The first time we call getValue, if we haven't been given a value yet,
            // (and we were given an initial value to use)
            // return the initial value instead of nothing.
            if (valueRef.current === Unset$1)
                tryEnsureValue();
            return (valueRef.current === Unset$1 ? undefined : valueRef.current);
        }, []);
        _(() => {
            // Make sure we've run our effect at least once on mount.
            // (If we have an initial value, of course)
            tryEnsureValue();
        }, []);
        // The actual code the user calls to (possibly) run a new effect.
        const r = A({ prevDep: Unset$1 });
        const setValue = q$1((arg) => {
            // Regardless of anything else, figure out what our next value is about to be.
            const nextValue = (arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg);
            if (r.current.prevDep === Unset$1 && nextValue !== valueRef.current) {
                // This is the first request to change this value.
                // Evaluate the request immediately, then queue up the onChange function
                // Save our current value so that we can compare against it later
                // (if we flip back to this state, then we won't send the onChange function)
                r.current.prevDep = valueRef.current;
                // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
                valueRef.current = nextValue;
                // Schedule the actual check and invocation of onChange later to let effects settle
                (customDebounceRendering ?? debounceRendering)(() => {
                    const nextDep = valueRef.current;
                    const prevDep = r.current.prevDep;
                    if (r.current.prevDep != valueRef.current) {
                        warningRef.current = true;
                        try {
                            // Call any registered cleanup function
                            onShouldCleanUp();
                            cleanupCallbackRef.current = (onChange?.(nextDep, prevDep === Unset$1 ? undefined : prevDep) ?? undefined);
                            valueRef.current = nextDep;
                        }
                        finally {
                            // Allow the user to normally call getValue again
                            warningRef.current = false;
                        }
                    }
                    // We've finished with everything, so mark us as being on a clean slate again.
                    r.current.prevDep = Unset$1;
                });
            }
            // Update the value immediately.
            // This will be checked against prevDep to see if we should actually call onChange
            valueRef.current = nextValue;
        }, []);
        return [getValue, setValue];
    }
    const Unset$1 = Symbol();
    // Easy constants for getInitialValue
    function returnTrue() { return true; }
    function returnFalse() { return false; }
    function returnNull() { return null; }

    /*
    const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
    const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
    const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
    const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/
    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    //const microtasks = new Map<Set<any>, any>();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.
    function forEachUpdater(window, map, value) {
        const updaters = map.get(window);
        if (updaters) {
            //if (!microtasks.has(updatersKey)) {
            //debounceRendering(() => {
            //const updatersKey = map.get(window)!;
            //const value = microtasks.get(updatersKey);
            //microtasks.delete(updatersKey);
            if (updaters) {
                for (const updater of updaters) {
                    const { lastSent, send } = updater;
                    if (value !== lastSent) {
                        send(value);
                        updater.lastSent = value;
                    }
                }
            }
            //});
            //}
            //microtasks.set(updatersKey, value);
        }
    }
    function focusout(e) {
        const window = e.target.ownerDocument.defaultView;
        if (e.relatedTarget == null) {
            forEachUpdater(window, activeElementUpdaters, null);
        }
    }
    function focusin(e) {
        const window = e.target.ownerDocument.defaultView;
        const currentlyFocusedElement = e.target;
        forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
        forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }
    function windowFocus(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, true);
        forEachUpdater(window, windowFocusedUpdaters, true);
    }
    function windowBlur(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, false);
        forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */
    function useActiveElement({ activeElementParameters: { onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow } }) {
        useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
        s(() => {
            const document = getDocument();
            const window = (getWindow?.(document) ?? document?.defaultView);
            if ((activeElementUpdaters.get(window)?.size ?? 0) === 0) {
                document?.addEventListener("focusin", focusin, { passive: true });
                document?.addEventListener("focusout", focusout, { passive: true });
                window?.addEventListener("focus", windowFocus, { passive: true });
                window?.addEventListener("blur", windowBlur, { passive: true });
            }
            // Add them even if they're undefined to more easily
            // manage the ">0 means don't add handlers" logic.
            const localActiveElementUpdaters = activeElementUpdaters.get(window) ?? new Set();
            const localLastActiveElementUpdaters = lastActiveElementUpdaters.get(window) ?? new Set();
            const localWindowFocusedUpdaters = windowFocusedUpdaters.get(window) ?? new Set();
            const laeu = { send: setActiveElement, lastSent: undefined };
            const llaeu = { send: setLastActiveElement, lastSent: undefined };
            const lwfu = { send: setWindowFocused, lastSent: undefined };
            localActiveElementUpdaters.add(laeu);
            localLastActiveElementUpdaters.add(llaeu);
            localWindowFocusedUpdaters.add(lwfu);
            activeElementUpdaters.set(window, localActiveElementUpdaters);
            lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
            windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
            return () => {
                activeElementUpdaters.get(window).delete(laeu);
                lastActiveElementUpdaters.get(window).delete(laeu);
                windowFocusedUpdaters.get(window).delete(lwfu);
                if (activeElementUpdaters.size === 0) {
                    document?.removeEventListener("focusin", focusin);
                    document?.removeEventListener("focusout", focusout);
                    window?.removeEventListener("focus", windowFocus);
                    window?.removeEventListener("blur", windowBlur);
                }
            };
        }, []);
        const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
        const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
        const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
        return { activeElementReturn: { getActiveElement, getLastActiveElement, getWindowFocused } };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
    function base64(value) {
        return Table[value];
    }
    function random6Bits() {
        return Math.floor(Math.random() * 0b1000000);
    }
    function random64Bits() {
        return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */
    function generateRandomId(prefix) {
        return `${prefix ?? "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map();
    // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.
    const commitName = "diffed";
    const originalCommit = l$1[commitName];
    const newCommit = (...args) => {
        for (const [id, effectInfo] of toRun) {
            const oldInputs = previousInputs.get(id);
            if (argsChanged(oldInputs, effectInfo.inputs)) {
                effectInfo.cleanup?.();
                effectInfo.cleanup = effectInfo.effect();
                previousInputs.set(id, effectInfo.inputs);
            }
        }
        toRun.clear();
        originalCommit?.(...args);
    };
    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */
    function useBeforeLayoutEffect(effect, inputs) {
        /*(() => {
            const cleanup = useRef<void | (() => void) | null>(null);
            const prevArgsRef = useRef<Inputs>(null!);
            if (argsChanged(inputs, prevArgsRef.current)) {
                prevArgsRef.current = inputs!;
                if (cleanup.current)
                    cleanup.current();
                cleanup.current = effect();
            }
        })();*/
        const [id] = y(() => generateRandomId());
        toRun.set(id, { effect, inputs, cleanup: null });
        s(() => {
            return () => {
                toRun.delete(id);
                previousInputs.delete(id);
            };
        }, [id]);
    }
    function argsChanged(oldArgs, newArgs) {
        return !!(!oldArgs ||
            oldArgs.length !== newArgs?.length ||
            newArgs?.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */
    function useStableGetter(value) {
        const ref = A(Unset);
        useBeforeLayoutEffect(() => { ref.current = value; }, [value]);
        return q$1(() => {
            if (ref.current === Unset) {
                throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
            }
            return ref.current;
        }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */
    function useStableCallback(fn) {
        const currentCallbackGetter = useStableGetter(fn);
        return q$1((...args) => {
            return currentCallbackGetter()(...args);
        }, []);
    }

    const SharedAnimationFrameContext = B$2(null);
    /**
     * The (optionally non-stable) `callback` you provide will start running every frame after the component mounts.
     *
     * Passing `null` is fine and simply stops the effect until you restart it by providing a non-null callback.
     *
     * **This hook does not return anything at all, including no prop-modifying hooks**
     */
    function useAnimationFrame({ callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback ?? noop);
        const hasCallback = (callback != null);
        const sharedAnimationFrameContext = x(SharedAnimationFrameContext);
        s(() => {
            if (sharedAnimationFrameContext) {
                if (hasCallback) {
                    sharedAnimationFrameContext.addCallback(stableCallback);
                }
                else {
                    sharedAnimationFrameContext.removeCallback(stableCallback);
                }
            }
            else {
                if (hasCallback) {
                    // Get a wrapper around the wrapper around the callback
                    // that also calls `requestAnimationFrame` again.
                    const rafCallback = (ms) => {
                        handle = requestAnimationFrame(rafCallback);
                        stableCallback(ms);
                    };
                    let handle = requestAnimationFrame(rafCallback);
                    return () => cancelAnimationFrame(handle);
                }
            }
        }, [sharedAnimationFrameContext, hasCallback]);
    }
    // eslint-disable @typescript-eslint/no-empty-function
    function noop() { }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$5.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$4.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */
    function useState(initialState) {
        // We keep both, but overrride the `setState` functionality
        const [state, setStateP] = y(initialState);
        const ref = A(state);
        // Hijack the normal setter function 
        // to also set our ref to the new value
        const setState = q$1(value => {
            if (typeof value === "function") {
                const callback = value;
                setStateP(prevValue => {
                    const nextValue = callback(prevValue);
                    ref.current = nextValue;
                    return nextValue;
                });
            }
            else {
                ref.current = value;
                setStateP(value);
            }
        }, []);
        const getState = () => { return ref.current; };
        console.assert(ref.current === state || (typeof state === "number" && isNaN(state)));
        return [state, setState, getState];
    }

    function identity$1(...t) { return t; }
    function useThrottled(callback, wait, options) {
        const throttled = T$1(() => {
            return callback ? throttle(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.trailing]);
        s(() => {
            return () => throttled?.cancel();
        }, [throttled]);
        return throttled;
    }
    function useDebounced(callback, wait, options) {
        const debounced = T$1(() => {
            return callback ? debounce(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.maxWait, options?.trailing]);
        s(() => {
            return () => debounced?.cancel();
        }, [debounced]);
        return debounced;
    }
    /**
     * Given an async function, returns a function that's suitable for non-async APIs,
     * along with other information about the current run's status.
     *
     * See also `useAsyncHandler` for a version that's specialized for DOM event handlers.
     *
     * When called multiple times in quick succession, (i.e. before the handler has finished),
     * this works like Lodash's `throttle` function with the `wait` option always
     * set to however long the handler takes to complete. A second call to the sync function will be
     * throttled until the first call has finished. The return value of the function is the result
     * of the previous invocation, or `undefined` on the first call.
     *
     * The handler is only ever delayed if one is currently running, so, e.g. for iOS touch events the
     * first call happens in the same event handler (which means things like calls to `element.focus()`
     * will work as intended, since that fails when the event is "split up")
     *
     * Finally, because the sync handler may be invoked on a delay, any property references on the arguments
     * provided might be stale by the time it's actually invoked (e.g. accessing `event.currentTarget.checked`
     * is not stable across time because it's a "live" value -- you almost always want the value that it
     * had at the original time the handler was called). The `capture` option allows you to save that kind of
     * dynamic data at the time it runs; the `AP` and `SP` type parameters likewise control
     * the parameters the async handler and sync handler expect respectively.
     *
     */
    function useAsync(asyncHandler, options) {
        /* eslint-disable prefer-const */
        let { throttle, debounce, capture } = (options ?? {});
        capture ??= identity$1;
        // We keep, like, a lot of render-state, but it only ever triggers a re-render
        // when we start/stop an async action.
        // Keep track of this for the caller's sake -- we don't really care.
        const [currentType, setCurrentType] = useState(null);
        const [runCount, setRunCount] = useState(0);
        const [settleCount, setSettleCount] = useState(0);
        const [resolveCount, setResolveCount] = useState(0);
        const [rejectCount, setRejectCount] = useState(0);
        // Things related to current execution
        // Because we can both return and throw undefined, 
        // we need separate state to track their existance too.
        const [pending, setPending, getPending] = useState(false);
        const [result, setResult, getResult] = useState(undefined);
        const [error, setError, _getError] = useState(undefined);
        const [hasError, setHasError, _getHasError] = useState(false);
        const [hasResult, setHasResult, _getHasResult] = useState(false);
        // We implement our own throttling behavior in regards to waiting until the async handler finishes.
        // These two passive state variables keep track of that, automatically queueing/dequeuing the next handler.
        const [getQueued, setQueued] = usePassiveState(null, returnNull);
        // The actual sync handler.
        // Capture/transform the given parameters if applicable,
        // then run further logic that's debounced/throttled
        const captureArgsAndExecuteDebouncedHandler = useStableCallback(function onNewExecuteRequest(...newArgs2) {
            // Capture the arguments we were given.
            // We might use them immediately, or we might store them to `queued`,
            // but in either case we do need the captured value.
            const captured = capture(...newArgs2);
            // This is all logic that deals with the captured value instead of the raw arguments.
            // It's called in two separate circumstances,
            // and has the debounce/throttle logic already applied
            return executeHandlerWithDebounce(getPending(), ...captured);
        });
        // This is the logic that runs when the handler is *just* about to start.
        // This function itself is further transformed to be throttled/debounced if requested,
        // so this might not be called immediately after 
        const executeHandlerWithoutDebounce = useStableCallback(function onNewExecuteRequest2(enqueue, ...newArgs) {
            const onThen = (value) => { setResult(value); setHasResult(true); setHasError(false); setResolveCount(r => ++r); };
            const onCatch = (ex) => { setError(ex); setHasError(true); setHasResult(false); setRejectCount(r => ++r); };
            const onFinally = () => {
                const queued = getQueued();
                setSettleCount(s => ++s);
                if (queued) {
                    setQueued(null);
                    executeHandlerWithDebounce(false, ...queued);
                }
                else {
                    setPending(false);
                }
            };
            if (!enqueue) {
                // Nothing is pending at the moment, so we can run our function immediately.
                setRunCount(r => ++r);
                setPending(true);
                const result = asyncHandler?.(...newArgs);
                const isPromise = (result != null && typeof result == "object" && "then" in result);
                if (result == null || !isPromise) {
                    // It's synchronous and returned successfully.
                    // Bail out early.
                    onThen(result);
                    onFinally();
                    setCurrentType("sync");
                }
                else {
                    result.then(onThen).catch(onCatch).finally(onFinally);
                    setCurrentType("async");
                }
            }
            else {
                // When we're still running a previous handler,
                // just set ourselves as the next one to run and quit early.
                // Nothing more to do.
                setQueued(newArgs);
            }
            return getResult();
        });
        const executeHandlerWithT = useThrottled(!throttle ? null : executeHandlerWithoutDebounce, throttle ?? 0);
        const executeHandlerWithD = useDebounced(!debounce ? null : (executeHandlerWithT ?? executeHandlerWithoutDebounce), debounce ?? 0);
        const executeHandlerWithDebounce = (executeHandlerWithD ?? executeHandlerWithT ?? executeHandlerWithoutDebounce);
        const flushDebouncedPromise = useStableCallback(() => {
            if (executeHandlerWithDebounce && "flush" in executeHandlerWithDebounce)
                executeHandlerWithDebounce.flush();
        });
        return {
            syncHandler: captureArgsAndExecuteDebouncedHandler,
            currentType,
            pending,
            result,
            error,
            hasError,
            hasResult,
            resolveCount,
            rejectCount,
            settleCount,
            callCount: runCount,
            flushDebouncedPromise
        };
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * Note that because the handler you provide may be called with a delay, and
     * because the value of, e.g., an `<input>` element will likely be stale by the
     * time the delay is over, a `capture` function is necessary in order to
     * capture the relevant information from the DOM. Any other simple event data,
     * like `mouseX` or `shiftKey` can stay on the event itself and don't
     * need to be captured &ndash; it's never stale.
     *
     * ```tsx
     * const asyncOnInput = async (value: number, e: Event) => {
     *     [...] // Ex. send to a server and setState when done
     * };
     * const {
     *     // A sync version of asyncOnInput
     *     syncHandler,
     *     // True while the handler is running
     *     pending,
     *     // The error thrown, if any
     *     error,
     *     // Show this value while the operation's pending
     *     currentCapture,
     *     // And others, see `UseAsyncHandlerReturnType`
     *     ...rest
     * } = useAsyncHandler<HTMLInputElement>()(asyncOnInput, {
     *     // Pass in the capture function that saves event data
     *     // from being stale.
     *     capture: e => {
     *         // `capture` can have side-effects because
     *         // it's called exactly once per invocation
     *         e.preventDefault();
     *
     *         // Save this value so that it's never stale
     *         return e.currentTarget.valueAsNumber;
     *     }
     * });
     *
     * const onInput = pending? null : syncHandler;
     * ```
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     *
     * You may optionally *also* specify debounce and throttle parameters that wait until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * @see useAsync A more general version of this hook that can work with any type of handler, not just DOM event handlers.
     */
    function useAsyncHandler({ asyncHandler, capture: originalCapture, ...restAsyncOptions }) {
        // We need to differentiate between "nothing captured yet" and "`undefined` was captured"
        const [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        const [hasCapture, setHasCapture] = useState(false);
        // Wrap around the normal `useAsync` `capture` function to also
        // keep track of the last value the user actually input.
        // 
        // Without this there's no way to re-render the control with
        // it being both controlled and also having the "correct" value,
        // and at any rate also protects against sudden exceptions reverting
        // your change out from under you.
        const capture = useStableCallback((e) => {
            const captured = originalCapture(e);
            setCurrentCapture(captured);
            setHasCapture(true);
            return [captured, e];
        });
        return {
            getCurrentCapture,
            currentCapture,
            hasCapture,
            ...useAsync(asyncHandler, { capture, ...restAsyncOptions })
        };
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */
    function useManagedChildren(parentParameters) {
        const { managedChildrenParameters: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
        const getHighestIndex = q$1(() => {
            return managedChildrenArray.current.highestIndex;
        }, []);
        // All the information we have about our children is stored in this **stable** array.
        // Any mutations to this array **DO NOT** trigger any sort of a re-render.
        const managedChildrenArray = A({ arr: [], rec: {}, highestIndex: 0, lowestIndex: 0 });
        // For indirect access to each child
        // Compare getManagedChildInfo
        // TODO: The primary use for this is flaggable closest fits
        // which needs to search all children for that closest fit.
        // It would be nice if there was something better for that.
        const forEachChild = q$1((f) => {
            for (const child of managedChildrenArray.current.arr) {
                if (child)
                    f(child);
            }
            for (const field in managedChildrenArray.current.rec) {
                const child = managedChildrenArray.current.rec[field];
                if (child)
                    f(child);
            }
        }, []);
        // Retrieves the information associated with the child with the given index.
        // `undefined` if not child there, or it's unmounted.
        const getManagedChildInfo = q$1((index) => {
            if (typeof index == "number")
                return managedChildrenArray.current.arr[index];
            else
                return managedChildrenArray.current.rec[index];
        }, []);
        // tl;dr this is a way to have run useLayoutEffect once after all N children
        // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
        // ourselves because of having a `childCount` state or anything similar.
        //
        // When the child count ref updates, we want the parent to also run an effect
        // to maybe do something with all these children that just mounted.
        // The easiest way would be useEffect(..., [childCount]) but
        // that would require us having a childCount state, then calling
        // setChildCount and re-rendering every time children mount
        // (only one re-render at a time unless children are staggered, but still)
        // 
        // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
        // to emulate running ULE on the parent. Only the first child will actually queue
        // the microtask (by checking hasRemoteULE first) so that the "effect" only
        // runs once. When it's done, hasRemoteULE is reset so it can run again if
        // more children mount/unmount.
        const hasRemoteULEChildMounted = A(null);
        const remoteULEChildChangedCausers = A(new Set());
        const remoteULEChildChanged = q$1((index) => {
            if (remoteULEChildChangedCausers.current.size == 0) {
                debounceRendering(() => {
                    onAfterChildLayoutEffect?.(remoteULEChildChangedCausers.current);
                    remoteULEChildChangedCausers.current.clear();
                });
            }
            remoteULEChildChangedCausers.current.add(index);
            return () => { };
        }, [ /* Must remain stable */]);
        const remoteULEChildMounted = q$1((index, mounted) => {
            if (!hasRemoteULEChildMounted.current) {
                hasRemoteULEChildMounted.current = {
                    mounts: new Set(),
                    unmounts: new Set(),
                };
                debounceRendering(() => {
                    onChildrenMountChange?.(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
                    hasRemoteULEChildMounted.current = null;
                });
            }
            if (mounted) {
                managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
            }
            else {
                if (typeof index == "number") {
                    delete managedChildrenArray.current.arr[index];
                    let shave = 0;
                    while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
                        ++shave;
                    }
                    managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
                }
                else
                    delete managedChildrenArray.current.rec[index];
            }
            hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
        }, [ /* Must remain stable */]);
        const useManagedChild = q$1((info) => {
            const { managedChildParameters: { index, flags }, subInfo } = info;
            // Any time our child props change, make that information available
            // the parent if they need it.
            // The parent can listen for all updates and only act on the ones it cares about,
            // and multiple children updating in the same tick will all be sent at once.
            _(() => {
                // Insert this information in-place
                if (typeof index == "number") {
                    managedChildrenArray.current.arr[index] = { index, flags: flags ?? {}, subInfo };
                }
                else {
                    managedChildrenArray.current.rec[index] = { index, flags: flags ?? {}, subInfo };
                }
                return remoteULEChildChanged(index);
            }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
            // When we mount, notify the parent via queueMicrotask
            // (every child does this, so everything's coordinated to only queue a single microtask per tick)
            // Do the same on unmount.
            // Note: It's important that this comes AFTER remoteULEChildChanged
            // so that remoteULEChildMounted has access to all the info on mount.
            _(() => {
                remoteULEChildMounted?.(index, true);
                return () => remoteULEChildMounted?.(index, false);
            }, [index]);
        }, [ /* Must remain stable */]);
        const managedChildren = A({
            ...{ _: managedChildrenArray.current },
            forEach: forEachChild,
            getAt: getManagedChildInfo,
            getHighestIndex: getHighestIndex,
            arraySlice: () => {
                return managedChildrenArray.current.arr.slice();
            }
        });
        return {
            useManagedChild,
            managedChildrenReturn: { children: managedChildren.current }
        };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */
    function useChildrenFlag({ children, initialIndex, closestFit, onIndexChange, key }) {
        useEnsureStability("useChildrenFlag", onIndexChange, key);
        const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => (initialIndex ?? (null)), []));
        const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => (initialIndex ?? (null)), []));
        //    const getFitNullToZero = useStableGetter(fitNullToZero);
        // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
        const getClosestFit = q$1((requestedIndex) => {
            let closestDistance = Infinity;
            let closestIndex = null;
            children.forEach(child => {
                if (child.flags?.[key]?.isValid()) {
                    const newDistance = Math.abs(child.index - requestedIndex);
                    if (newDistance < closestDistance || (newDistance == closestDistance && child.index < requestedIndex)) {
                        closestDistance = newDistance;
                        closestIndex = child.index;
                    }
                }
            });
            return closestIndex;
        }, [ /* Must remain stable! */]);
        // Any time a child mounts/unmounts, we need to double-check to see if that affects 
        // the "currently selected" (or whatever) index.  The two cases we're looking for:
        // 1. The currently selected child unmounted
        // 2. A child mounted, and it mounts with the index we're looking for
        const reevaluateClosestFit = useStableCallback(() => {
            const requestedIndex = getRequestedIndex();
            const currentIndex = getCurrentIndex();
            const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
            if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !currentChild.flags?.[key]?.isValid())) {
                currentChild?.flags?.[key].set(false);
                const closestFitIndex = getClosestFit(requestedIndex);
                setCurrentIndex(closestFitIndex);
                if (closestFitIndex != null) {
                    const closestFitChild = children.getAt(closestFitIndex);
                    console.assert(closestFitChild != null, "Internal logic???");
                    closestFitChild.flags?.[key].set(true);
                }
            }
        });
        const changeIndex = q$1((arg) => {
            const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
            //if (requestedIndex == null && getFitNullToZero())
            //    requestedIndex = 0;
            setRequestedIndex(requestedIndex);
            const currentIndex = getCurrentIndex();
            if (currentIndex == requestedIndex)
                return requestedIndex;
            let newMatchingChild = (requestedIndex == null ? null : children.getAt(requestedIndex));
            const oldMatchingChild = (currentIndex == null ? null : children.getAt(currentIndex));
            if (requestedIndex == null) {
                // Easy case
                setCurrentIndex(null);
                oldMatchingChild?.flags?.[key].set(false);
                return null;
            }
            else {
                if (newMatchingChild && newMatchingChild.flags?.[key].isValid()) {
                    setCurrentIndex(requestedIndex);
                    oldMatchingChild?.flags?.[key].set(false);
                    newMatchingChild.flags?.[key].set(true);
                    return requestedIndex;
                }
                else {
                    const closestFitIndex = getClosestFit(requestedIndex);
                    setCurrentIndex(closestFitIndex);
                    if (closestFitIndex != null) {
                        newMatchingChild = children.getAt(closestFitIndex);
                        console.assert(newMatchingChild != null, "Internal logic???");
                        oldMatchingChild?.flags?.[key].set(false);
                        newMatchingChild.flags?.[key].set(true);
                        return closestFitIndex;
                    }
                    else {
                        oldMatchingChild?.flags?.[key].set(false);
                        return null;
                    }
                }
            }
        }, []);
        _(() => {
            if (initialIndex != null)
                children.getAt(initialIndex)?.flags?.[key]?.set(true);
        }, []);
        return { changeIndex, reevaluateClosestFit, getCurrentIndex };
    }

    function useChildrenHaveFocus(args) {
        const { childrenHaveFocusParameters: { onAllLostFocus, onAnyGainedFocus } } = args;
        ///const { managedChildrenReturn, useManagedChild } = useManagedChildren<number, C, K>({ managedChildrenParameters: { onAfterChildLayoutEffect, onChildrenMountChange } });
        const allElementsRef = A(new Set());
        const [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
            console.assert(anyFocused >= 0 && anyFocused <= 1);
            if (anyFocused && !anyPreviouslyFocused)
                onAnyGainedFocus?.();
            if (!anyFocused && anyPreviouslyFocused)
                onAllLostFocus?.();
        }));
        const useChildrenHaveFocusChild = q$1((args) => {
            return {
                hasCurrentFocusParameters: {
                    onCurrentFocusedInnerChanged: q$1((focused, prev) => {
                        if (focused) {
                            setFocusCount(p => (p ?? 0) + 1);
                        }
                        else if (!focused && prev) {
                            setFocusCount(p => (p ?? 0) - 1);
                        }
                    }, []),
                },
                refElementParameters: {
                    onElementChange: q$1((e, prev) => {
                        if (e) {
                            allElementsRef.current.add(e);
                            return () => {
                                allElementsRef.current.delete(e);
                            };
                        }
                    }, [])
                }
            };
        }, []);
        return {
            useChildrenHaveFocusChild
        };
    }

    function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

    function getDocument$1(element) { return (element?.ownerDocument ?? document ?? window.document ?? globalThis.document); }

    function useDraggable({ effectAllowed, data, dragImage, dragImageXOffset, dragImageYOffset }) {
        const [dragging, setDragging, getDragging] = useState(false);
        const [lastDropEffect, setLastDropEffect, getLastDropEffect] = useState(null);
        const onDragStart = (e) => {
            //e.preventDefault();
            setDragging(true);
            if (e.dataTransfer) {
                e.dataTransfer.effectAllowed = (effectAllowed ?? "all");
                if (dragImage)
                    e.dataTransfer.setDragImage(dragImage, dragImageXOffset ?? 0, dragImageYOffset ?? 0);
                const entries = Object.entries(data);
                for (const [mimeType, data] of entries) {
                    e.dataTransfer.setData(mimeType, data);
                }
            }
        };
        const onDragEnd = (e) => {
            e.preventDefault();
            setDragging(false);
            if (e.dataTransfer) {
                if (e.dataTransfer.dropEffect != "none") {
                    setLastDropEffect(e.dataTransfer.dropEffect);
                }
                else {
                    setLastDropEffect(null);
                }
            }
        };
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        const ret = {
            propsUnstable: {
                draggable: true,
                onDragStart,
                onDragEnd
            },
            dragging,
            getDragging,
            lastDropEffect,
            getLastDropEffect
        };
        return ret;
    }

    class DroppableFileError extends Error {
        fileName;
        errorType;
        constructor(fileName, base) {
            super(base?.message ?? "An unspecified error occurred reading the file.");
            this.fileName = fileName;
            this.errorType = base?.name;
        }
    }
    function useDroppable({ effect }) {
        const [filesForConsideration, setFilesForConsideration] = useState(null);
        const [stringsForConsideration, setStringsForConsideration] = useState(null);
        const [droppedFiles, setDroppedFiles] = useState(null);
        const [droppedStrings, setDroppedStrings] = useState(null);
        const [dropError, setDropError] = useState(undefined);
        // All the promises generated from the drop events.
        // Used to process multiple drop events in succession
        const dropPromisesRef = A([]);
        const [currentPromiseIndex, setCurrentPromiseIndex, getCurrentPromiseIndex] = useState(-1);
        const [promiseCount, setPromiseCount, getPromiseCount] = useState(0);
        // Any time we add a new promise, if there's no current promise running, we need to start one.
        // If there is one, then we don't need to do anything, since it runs the same check.
        s(() => {
            const currentPromiseIndex = getCurrentPromiseIndex();
            const promiseCount = getPromiseCount();
            if (promiseCount > 0) {
                if ((currentPromiseIndex + 1) < promiseCount) {
                    setCurrentPromiseIndex(i => ++i);
                }
            }
        }, [promiseCount]);
        // Anytime our current promise changes,
        // wait for it to finish, then set our state to its result.
        // Finally, check to see if there are anymore promises.
        // If there are, then increase currentPromiseCount,
        // which will trigger this again.
        //
        // This shouldn't happen *often*, but maybe in the case of
        // individually dropping a bunch of large files or something.
        s(() => {
            if (currentPromiseIndex >= 0) {
                const currentPromise = dropPromisesRef.current[currentPromiseIndex];
                currentPromise.then((info) => {
                    if (info !== null) {
                        const { files, strings } = info;
                        setDroppedFiles(files);
                        setDroppedStrings(strings);
                    }
                    // Now that we're done, are there more promises in the queue?
                    const currentPromiseIndex = getCurrentPromiseIndex();
                    const promiseCount = getPromiseCount();
                    if ((currentPromiseIndex + 1) < promiseCount) {
                        // Since this promise has started, more have been added.
                        // Run this effect again.
                        setCurrentPromiseIndex(i => ++i);
                    }
                });
            }
        }, [currentPromiseIndex]);
        // Handle collecting the current file metadata or MIME types.
        const onDragEnter = useStableCallback((e) => {
            e.preventDefault();
            if (e.dataTransfer) {
                // Is there a default? I can't find one anywhere.
                e.dataTransfer.dropEffect = (effect ?? "move");
                const newMimeTypes = new Set();
                const newFiles = new Array();
                for (const item of e.dataTransfer?.items ?? []) {
                    const { kind, type } = item;
                    if (kind === "string") {
                        newMimeTypes.add(type);
                    }
                    else if (kind === "file") {
                        newFiles.push({ type: item.type });
                    }
                }
                setFilesForConsideration(newFiles);
                setStringsForConsideration(newMimeTypes);
            }
        });
        // Handle resetting the current file metadata or MIME types
        const onDragLeave = useStableCallback((e) => {
            e.preventDefault();
            setFilesForConsideration(null);
            setStringsForConsideration(null);
        });
        // Boilerplate, I guess
        const onDragOver = useStableCallback((e) => {
            e.preventDefault();
        });
        // Handle getting the drop data asynchronously
        const onDrop = useStableCallback((e) => {
            e.preventDefault();
            setFilesForConsideration(null);
            setStringsForConsideration(null);
            const allPromises = new Array();
            const dropData = {};
            const dropFile = [];
            for (const item of e.dataTransfer?.items ?? []) {
                const { kind, type } = item;
                if (kind === "string") {
                    allPromises.push((new Promise((resolve, _reject) => item.getAsString(resolve))).then(str => dropData[type] = str));
                }
                else if (kind === "file") {
                    const file = item.getAsFile();
                    if (file) {
                        allPromises.push(new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = (_) => {
                                resolve();
                                const data = reader.result;
                                dropFile.push({ data, name: file.name, type: file.type, size: data.byteLength, lastModified: file.lastModified });
                            };
                            reader.onerror = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                            reader.onabort = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                            reader.readAsArrayBuffer(file);
                        }));
                        dropFile.push();
                    }
                }
            }
            dropPromisesRef.current.push(Promise.all(allPromises).then(() => {
                setPromiseCount(i => ++i);
                setDropError(null);
                return {
                    strings: dropData,
                    files: dropFile
                };
            }).catch(ex => {
                /* eslint-disable no-debugger */
                debugger;
                setPromiseCount(i => ++i);
                setDropError(ex);
                return null;
            }));
        });
        const propsStable = A({ onDragEnter, onDragLeave, onDragOver, onDrop });
        return {
            propsStable: propsStable.current,
            filesForConsideration,
            stringsForConsideration,
            droppedFiles,
            droppedStrings,
            dropError
        };
    }

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */
    function useRefElement(args) {
        const { refElementParameters: { onElementChange, onMount, onUnmount } } = args;
        useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
        // Called (indirectly) by the ref that the element receives.
        const handler = q$1((e, prevValue) => {
            const cleanup = onElementChange?.(e, prevValue);
            if (prevValue)
                onUnmount?.(prevValue);
            if (e)
                onMount?.(e);
            return cleanup;
        }, []);
        // Let us store the actual (reference to) the element we capture
        const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
        const propsStable = A({ ref: setElement });
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        return {
            refElementReturn: {
                getElement,
                propsStable: propsStable.current
            }
        };
    }
    function runImmediately(f) {
        f();
    }

    function useElementSize({ elementSizeParameters: { getObserveBox, onSizeChange }, refElementParameters: { onElementChange, onMount, onUnmount } }) {
        useEnsureStability("useElementSize", getObserveBox, onSizeChange, onElementChange, onMount, onUnmount);
        const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
        const currentObserveBox = A(undefined);
        const needANewObserver = q$1((element, observeBox) => {
            if (element) {
                const document = getDocument$1(element);
                const window = document.defaultView;
                const handleUpdate = () => {
                    if (element.isConnected) {
                        const { clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop } = element;
                        setSize({ clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop });
                    }
                };
                if (window && ("ResizeObserver" in window)) {
                    const observer = new ResizeObserver((_entries) => { handleUpdate(); });
                    observer.observe(element, { box: observeBox });
                    return () => observer.disconnect();
                }
                else {
                    document.addEventListener("resize", handleUpdate, { passive: true });
                    return () => document.removeEventListener("resize", handleUpdate);
                }
            }
        }, []);
        const { refElementReturn } = useRefElement({
            refElementParameters: {
                onElementChange: q$1((e, p) => { needANewObserver(e, getObserveBox?.()); onElementChange?.(e, p); }, []),
                onMount,
                onUnmount
            }
        });
        const { getElement } = refElementReturn;
        s(() => {
            if (getObserveBox) {
                if (currentObserveBox.current !== getObserveBox())
                    needANewObserver(getElement(), getObserveBox());
            }
        });
        return {
            elementSizeReturn: { getSize },
            refElementReturn
        };
    }

    function useMergedChildren({ children: lhs }, { children: rhs }) {
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return h$1(p$1, {}, lhs, rhs);
        }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */
    function useMergedClasses({ class: lhsClass, className: lhsClassName }, { class: rhsClass, className: rhsClassName }) {
        // Note: For the sake of forward compatibility, this function is labelled as
        // a hook, but as it uses no other hooks it technically isn't one.
        if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
            const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
            const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
            const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
            return Array.from(allClasses).join(" ");
        }
        else {
            return undefined;
        }
    }

    function processRef(instance, ref) {
        if (typeof ref === "function") {
            ref(instance);
        }
        else if (ref != null) {
            ref.current = instance;
        }
        else {
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
        }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */
    function useMergedRefs({ ref: rhs }, { ref: lhs }) {
        const combined = q$1((current) => {
            processRef(current, lhs);
            processRef(current, rhs);
        }, [lhs, rhs]);
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return combined;
        }
    }

    function styleStringToObject(style) {
        // TODO: This sucks D:
        return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
        // Easy case, when there are no styles to merge return nothing.
        if (!lhs?.style && !rhs?.style)
            return undefined;
        if (typeof lhs != typeof rhs) {
            // Easy cases, when one is null and the other isn't.
            if (lhs?.style && !rhs?.style)
                return lhs.style;
            if (!lhs?.style && rhs?.style)
                return rhs.style;
            // They're both non-null but different types.
            // Convert the string type to an object bag type and run it again.
            if (lhs?.style && rhs?.style) {
                // (useMergedStyles isn't a true hook -- this isn't a violation)
                if (typeof lhs?.style == "string")
                    return useMergedStyles({ style: styleStringToObject(lhs?.style) }, rhs);
                if (typeof rhs?.style == "string")
                    return useMergedStyles(lhs, { style: styleStringToObject(rhs?.style) });
            }
            // Logic???
            return undefined;
        }
        // They're both strings, just concatenate them.
        if (typeof lhs?.style == "string") {
            return `${lhs.style};${rhs?.style ?? ""}`;
        }
        // They're both objects, just merge them.
        return {
            ...(lhs?.style ?? {}),
            ...(rhs?.style ?? {})
        };
    }

    let log = console.warn;
    function useMergedProps(...allProps) {
        useEnsureStability("useMergedProps", allProps.length);
        let ret = {};
        for (let nextProps of allProps) {
            ret = useMergedProps2(ret, nextProps);
        }
        return ret;
    }
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */
    function useMergedProps2(lhsAll, rhsAll) {
        // First, separate the props we were given into two groups:
        // lhsAll and rhsAll contain all the props we were given, and
        // lhsMisc and rhsMisc contain all props *except* for the easy ones
        // like className and style that we already know how to merge.
        const { children: _lhsChildren, class: _lhsClass, className: _lhsClassName, style: _lhsStyle, ref: _lhsRef, ...lhsMisc } = lhsAll;
        const { children: _rhsChildren, class: _rhsClass, className: _rhsClassName, style: _rhsStyle, ref: _rhsRef, ...rhsMisc } = rhsAll;
        const ret = {
            ...lhsMisc,
            ref: useMergedRefs(lhsAll, rhsAll),
            style: useMergedStyles(lhsAll, rhsAll),
            className: useMergedClasses(lhsAll, rhsAll),
            children: useMergedChildren(lhsAll, rhsAll),
        };
        if (ret.ref === undefined)
            delete ret.ref;
        if (ret.style === undefined)
            delete ret.style;
        if (ret.className === undefined)
            delete ret.className;
        if (ret.children === undefined)
            delete ret.children;
        // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];
        const rhsEntries = Object.entries(rhsMisc);
        for (const [rhsKeyU, rhsValue] of rhsEntries) {
            const rhsKey = rhsKeyU;
            const lhsValue = lhsMisc[rhsKey];
            if (typeof lhsValue === "function" || typeof rhsValue === "function") {
                // They're both functions that can be merged (or one's a function and the other's null).
                // Not an *easy* case, but a well-defined one.
                const merged = mergeFunctions(lhsValue, rhsValue);
                ret[rhsKey] = merged;
            }
            else {
                // Uh...we're here because one of them's null, right?
                if (lhsValue == null && rhsValue == null) {
                    if (rhsValue === null && lhsValue === undefined)
                        ret[rhsKey] = rhsValue;
                    else
                        ret[rhsKey] = lhsValue;
                }
                if (lhsValue == null)
                    ret[rhsKey] = rhsValue;
                else if (rhsValue == null)
                    ret[rhsKey] = lhsValue;
                else if (rhsValue == lhsValue) ;
                else {
                    // Ugh.
                    // No good strategies here, just log it if requested
                    log?.(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
                    ret[rhsKey] = rhsValue;
                }
            }
        }
        return ret;
    }
    function mergeFunctions(lhs, rhs) {
        if (!lhs)
            return rhs;
        if (!rhs)
            return lhs;
        return (...args) => {
            const lv = lhs(...args);
            const rv = rhs(...args);
            if (lv instanceof Promise || rv instanceof Promise)
                return Promise.all([lv, rv]);
        };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */
    function useGlobalHandler(target, type, handler, options) {
        // Note to self: The typing doesn't improve even if this is split up into a sub-function.
        // No matter what, it seems impossible to get the handler's event object typed perfectly.
        // It seems like it's guaranteed to always be a union of all available tupes.
        // Again, no matter what combination of sub- or sub-sub-functions used.
        let stableHandler = useStableCallback(handler ?? (() => { }));
        if (handler == null)
            stableHandler = null;
        s(() => {
            if (stableHandler) {
                target.addEventListener(type, stableHandler, options);
                return () => target.removeEventListener(type, stableHandler, options);
            }
        }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 6.0.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };


    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRootHost;

      // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.
      var nodeRootHost = getRootNode(node).host;
      var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));

      while (!attached && nodeRootHost) {
        var _nodeRootHost2;

        // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
        //  which means we need to get the host's host and check if that parent host is contained
        //  in (i.e. attached to) the document
        nodeRootHost = getRootNode(nodeRootHost).host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
      }

      return attached;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot;

      // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__


        if (displayCheck !== 'legacy-full') {
          return true; // hidden
        } // else, fallback to 'none' mode and consider the node visible

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
    	(function (global, factory) {
    	  factory() ;
    	}(commonjsGlobal, (function () {
    	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	  /**
    	   * This work is licensed under the W3C Software and Document License
    	   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
    	   */

    	  (function () {
    	    // Return early if we're not running inside of the browser.
    	    if (typeof window === 'undefined') {
    	      return;
    	    }

    	    // Convenience function for converting NodeLists.
    	    /** @type {typeof Array.prototype.slice} */
    	    var slice = Array.prototype.slice;

    	    /**
    	     * IE has a non-standard name for "matches".
    	     * @type {typeof Element.prototype.matches}
    	     */
    	    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    	    /** @type {string} */
    	    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    	    /**
    	     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
    	     * attribute.
    	     *
    	     * Its main functions are:
    	     *
    	     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
    	     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
    	     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
    	     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
    	     *   instance exists for each focusable node which has at least one inert root as an ancestor.
    	     *
    	     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
    	     *   attribute is removed from the root node). This is handled in the destructor, which calls the
    	     *   `deregister` method on `InertManager` for each managed inert node.
    	     */

    	    var InertRoot = function () {
    	      /**
    	       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
    	       * @param {!InertManager} inertManager The global singleton InertManager object.
    	       */
    	      function InertRoot(rootElement, inertManager) {
    	        _classCallCheck(this, InertRoot);

    	        /** @type {!InertManager} */
    	        this._inertManager = inertManager;

    	        /** @type {!HTMLElement} */
    	        this._rootElement = rootElement;

    	        /**
    	         * @type {!Set<!InertNode>}
    	         * All managed focusable nodes in this InertRoot's subtree.
    	         */
    	        this._managedNodes = new Set();

    	        // Make the subtree hidden from assistive technology
    	        if (this._rootElement.hasAttribute('aria-hidden')) {
    	          /** @type {?string} */
    	          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
    	        } else {
    	          this._savedAriaHidden = null;
    	        }
    	        this._rootElement.setAttribute('aria-hidden', 'true');

    	        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
    	        this._makeSubtreeUnfocusable(this._rootElement);

    	        // Watch for:
    	        // - any additions in the subtree: make them unfocusable too
    	        // - any removals from the subtree: remove them from this inert root's managed nodes
    	        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
    	        //   element, make that node a managed node.
    	        this._observer = new MutationObserver(this._onMutation.bind(this));
    	        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
    	       * stored in this object and updates the state of all of the managed nodes.
    	       */


    	      _createClass(InertRoot, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._observer.disconnect();

    	          if (this._rootElement) {
    	            if (this._savedAriaHidden !== null) {
    	              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
    	            } else {
    	              this._rootElement.removeAttribute('aria-hidden');
    	            }
    	          }

    	          this._managedNodes.forEach(function (inertNode) {
    	            this._unmanageNode(inertNode.node);
    	          }, this);

    	          // Note we cast the nulls to the ANY type here because:
    	          // 1) We want the class properties to be declared as non-null, or else we
    	          //    need even more casts throughout this code. All bets are off if an
    	          //    instance has been destroyed and a method is called.
    	          // 2) We don't want to cast "this", because we want type-aware optimizations
    	          //    to know which properties we're setting.
    	          this._observer = /** @type {?} */null;
    	          this._rootElement = /** @type {?} */null;
    	          this._managedNodes = /** @type {?} */null;
    	          this._inertManager = /** @type {?} */null;
    	        }

    	        /**
    	         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
    	         */

    	      }, {
    	        key: '_makeSubtreeUnfocusable',


    	        /**
    	         * @param {!Node} startNode
    	         */
    	        value: function _makeSubtreeUnfocusable(startNode) {
    	          var _this2 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this2._visitNode(node);
    	          });

    	          var activeElement = document.activeElement;

    	          if (!document.body.contains(startNode)) {
    	            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
    	            var node = startNode;
    	            /** @type {!ShadowRoot|undefined} */
    	            var root = undefined;
    	            while (node) {
    	              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    	                root = /** @type {!ShadowRoot} */node;
    	                break;
    	              }
    	              node = node.parentNode;
    	            }
    	            if (root) {
    	              activeElement = root.activeElement;
    	            }
    	          }
    	          if (startNode.contains(activeElement)) {
    	            activeElement.blur();
    	            // In IE11, if an element is already focused, and then set to tabindex=-1
    	            // calling blur() will not actually move the focus.
    	            // To work around this we call focus() on the body instead.
    	            if (activeElement === document.activeElement) {
    	              document.body.focus();
    	            }
    	          }
    	        }

    	        /**
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_visitNode',
    	        value: function _visitNode(node) {
    	          if (node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */node;

    	          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
    	          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
    	          if (element !== this._rootElement && element.hasAttribute('inert')) {
    	            this._adoptInertRoot(element);
    	          }

    	          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
    	            this._manageNode(element);
    	          }
    	        }

    	        /**
    	         * Register the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_manageNode',
    	        value: function _manageNode(node) {
    	          var inertNode = this._inertManager.register(node, this);
    	          this._managedNodes.add(inertNode);
    	        }

    	        /**
    	         * Unregister the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_unmanageNode',
    	        value: function _unmanageNode(node) {
    	          var inertNode = this._inertManager.deregister(node, this);
    	          if (inertNode) {
    	            this._managedNodes['delete'](inertNode);
    	          }
    	        }

    	        /**
    	         * Unregister the entire subtree starting at `startNode`.
    	         * @param {!Node} startNode
    	         */

    	      }, {
    	        key: '_unmanageSubtree',
    	        value: function _unmanageSubtree(startNode) {
    	          var _this3 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this3._unmanageNode(node);
    	          });
    	        }

    	        /**
    	         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
    	         * @param {!HTMLElement} node
    	         */

    	      }, {
    	        key: '_adoptInertRoot',
    	        value: function _adoptInertRoot(node) {
    	          var inertSubroot = this._inertManager.getInertRoot(node);

    	          // During initialisation this inert root may not have been registered yet,
    	          // so register it now if need be.
    	          if (!inertSubroot) {
    	            this._inertManager.setInert(node, true);
    	            inertSubroot = this._inertManager.getInertRoot(node);
    	          }

    	          inertSubroot.managedNodes.forEach(function (savedInertNode) {
    	            this._manageNode(savedInertNode.node);
    	          }, this);
    	        }

    	        /**
    	         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_onMutation',
    	        value: function _onMutation(records, self) {
    	          records.forEach(function (record) {
    	            var target = /** @type {!HTMLElement} */record.target;
    	            if (record.type === 'childList') {
    	              // Manage added nodes
    	              slice.call(record.addedNodes).forEach(function (node) {
    	                this._makeSubtreeUnfocusable(node);
    	              }, this);

    	              // Un-manage removed nodes
    	              slice.call(record.removedNodes).forEach(function (node) {
    	                this._unmanageSubtree(node);
    	              }, this);
    	            } else if (record.type === 'attributes') {
    	              if (record.attributeName === 'tabindex') {
    	                // Re-initialise inert node if tabindex changes
    	                this._manageNode(target);
    	              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
    	                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
    	                // already managed nodes from this inert subroot.
    	                this._adoptInertRoot(target);
    	                var inertSubroot = this._inertManager.getInertRoot(target);
    	                this._managedNodes.forEach(function (managedNode) {
    	                  if (target.contains(managedNode.node)) {
    	                    inertSubroot._manageNode(managedNode.node);
    	                  }
    	                });
    	              }
    	            }
    	          }, this);
    	        }
    	      }, {
    	        key: 'managedNodes',
    	        get: function get() {
    	          return new Set(this._managedNodes);
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'hasSavedAriaHidden',
    	        get: function get() {
    	          return this._savedAriaHidden !== null;
    	        }

    	        /** @param {?string} ariaHidden */

    	      }, {
    	        key: 'savedAriaHidden',
    	        set: function set(ariaHidden) {
    	          this._savedAriaHidden = ariaHidden;
    	        }

    	        /** @return {?string} */
    	        ,
    	        get: function get() {
    	          return this._savedAriaHidden;
    	        }
    	      }]);

    	      return InertRoot;
    	    }();

    	    /**
    	     * `InertNode` initialises and manages a single inert node.
    	     * A node is inert if it is a descendant of one or more inert root elements.
    	     *
    	     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
    	     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
    	     * is intrinsically focusable or not.
    	     *
    	     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
    	     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
    	     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
    	     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
    	     * or removes the `tabindex` attribute if the element is intrinsically focusable.
    	     */


    	    var InertNode = function () {
    	      /**
    	       * @param {!Node} node A focusable element to be made inert.
    	       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
    	       */
    	      function InertNode(node, inertRoot) {
    	        _classCallCheck(this, InertNode);

    	        /** @type {!Node} */
    	        this._node = node;

    	        /** @type {boolean} */
    	        this._overrodeFocusMethod = false;

    	        /**
    	         * @type {!Set<!InertRoot>} The set of descendant inert roots.
    	         *    If and only if this set becomes empty, this node is no longer inert.
    	         */
    	        this._inertRoots = new Set([inertRoot]);

    	        /** @type {?number} */
    	        this._savedTabIndex = null;

    	        /** @type {boolean} */
    	        this._destroyed = false;

    	        // Save any prior tabindex info and make this node untabbable
    	        this.ensureUntabbable();
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.
    	       * This makes the managed node focusable again and deletes all of the previously stored state.
    	       */


    	      _createClass(InertNode, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._throwIfDestroyed();

    	          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
    	            var element = /** @type {!HTMLElement} */this._node;
    	            if (this._savedTabIndex !== null) {
    	              element.setAttribute('tabindex', this._savedTabIndex);
    	            } else {
    	              element.removeAttribute('tabindex');
    	            }

    	            // Use `delete` to restore native focus method.
    	            if (this._overrodeFocusMethod) {
    	              delete element.focus;
    	            }
    	          }

    	          // See note in InertRoot.destructor for why we cast these nulls to ANY.
    	          this._node = /** @type {?} */null;
    	          this._inertRoots = /** @type {?} */null;
    	          this._destroyed = true;
    	        }

    	        /**
    	         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
    	         * If the object has been destroyed, any attempt to access it will cause an exception.
    	         */

    	      }, {
    	        key: '_throwIfDestroyed',


    	        /**
    	         * Throw if user tries to access destroyed InertNode.
    	         */
    	        value: function _throwIfDestroyed() {
    	          if (this.destroyed) {
    	            throw new Error('Trying to access destroyed InertNode');
    	          }
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'ensureUntabbable',


    	        /** Save the existing tabindex value and make the node untabbable and unfocusable */
    	        value: function ensureUntabbable() {
    	          if (this.node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */this.node;
    	          if (matches.call(element, _focusableElementsString)) {
    	            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
    	              return;
    	            }

    	            if (element.hasAttribute('tabindex')) {
    	              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            }
    	            element.setAttribute('tabindex', '-1');
    	            if (element.nodeType === Node.ELEMENT_NODE) {
    	              element.focus = function () {};
    	              this._overrodeFocusMethod = true;
    	            }
    	          } else if (element.hasAttribute('tabindex')) {
    	            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            element.removeAttribute('tabindex');
    	          }
    	        }

    	        /**
    	         * Add another inert root to this inert node's set of managing inert roots.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'addInertRoot',
    	        value: function addInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots.add(inertRoot);
    	        }

    	        /**
    	         * Remove the given inert root from this inert node's set of managing inert roots.
    	         * If the set of managing inert roots becomes empty, this node is no longer inert,
    	         * so the object should be destroyed.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'removeInertRoot',
    	        value: function removeInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots['delete'](inertRoot);
    	          if (this._inertRoots.size === 0) {
    	            this.destructor();
    	          }
    	        }
    	      }, {
    	        key: 'destroyed',
    	        get: function get() {
    	          return (/** @type {!InertNode} */this._destroyed
    	          );
    	        }
    	      }, {
    	        key: 'hasSavedTabIndex',
    	        get: function get() {
    	          return this._savedTabIndex !== null;
    	        }

    	        /** @return {!Node} */

    	      }, {
    	        key: 'node',
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._node;
    	        }

    	        /** @param {?number} tabIndex */

    	      }, {
    	        key: 'savedTabIndex',
    	        set: function set(tabIndex) {
    	          this._throwIfDestroyed();
    	          this._savedTabIndex = tabIndex;
    	        }

    	        /** @return {?number} */
    	        ,
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._savedTabIndex;
    	        }
    	      }]);

    	      return InertNode;
    	    }();

    	    /**
    	     * InertManager is a per-document singleton object which manages all inert roots and nodes.
    	     *
    	     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
    	     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
    	     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
    	     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
    	     * is created for each such node, via the `_managedNodes` map.
    	     */


    	    var InertManager = function () {
    	      /**
    	       * @param {!Document} document
    	       */
    	      function InertManager(document) {
    	        _classCallCheck(this, InertManager);

    	        if (!document) {
    	          throw new Error('Missing required argument; InertManager needs to wrap a document.');
    	        }

    	        /** @type {!Document} */
    	        this._document = document;

    	        /**
    	         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertNode>}
    	         */
    	        this._managedNodes = new Map();

    	        /**
    	         * All inert roots known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertRoot>}
    	         */
    	        this._inertRoots = new Map();

    	        /**
    	         * Observer for mutations on `document.body`.
    	         * @type {!MutationObserver}
    	         */
    	        this._observer = new MutationObserver(this._watchForInert.bind(this));

    	        // Add inert style.
    	        addInertStyle(document.head || document.body || document.documentElement);

    	        // Wait for document to be loaded.
    	        if (document.readyState === 'loading') {
    	          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
    	        } else {
    	          this._onDocumentLoaded();
    	        }
    	      }

    	      /**
    	       * Set whether the given element should be an inert root or not.
    	       * @param {!HTMLElement} root
    	       * @param {boolean} inert
    	       */


    	      _createClass(InertManager, [{
    	        key: 'setInert',
    	        value: function setInert(root, inert) {
    	          if (inert) {
    	            if (this._inertRoots.has(root)) {
    	              // element is already inert
    	              return;
    	            }

    	            var inertRoot = new InertRoot(root, this);
    	            root.setAttribute('inert', '');
    	            this._inertRoots.set(root, inertRoot);
    	            // If not contained in the document, it must be in a shadowRoot.
    	            // Ensure inert styles are added there.
    	            if (!this._document.body.contains(root)) {
    	              var parent = root.parentNode;
    	              while (parent) {
    	                if (parent.nodeType === 11) {
    	                  addInertStyle(parent);
    	                }
    	                parent = parent.parentNode;
    	              }
    	            }
    	          } else {
    	            if (!this._inertRoots.has(root)) {
    	              // element is already non-inert
    	              return;
    	            }

    	            var _inertRoot = this._inertRoots.get(root);
    	            _inertRoot.destructor();
    	            this._inertRoots['delete'](root);
    	            root.removeAttribute('inert');
    	          }
    	        }

    	        /**
    	         * Get the InertRoot object corresponding to the given inert root element, if any.
    	         * @param {!Node} element
    	         * @return {!InertRoot|undefined}
    	         */

    	      }, {
    	        key: 'getInertRoot',
    	        value: function getInertRoot(element) {
    	          return this._inertRoots.get(element);
    	        }

    	        /**
    	         * Register the given InertRoot as managing the given node.
    	         * In the case where the node has a previously existing inert root, this inert root will
    	         * be added to its set of inert roots.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {!InertNode} inertNode
    	         */

    	      }, {
    	        key: 'register',
    	        value: function register(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (inertNode !== undefined) {
    	            // node was already in an inert subtree
    	            inertNode.addInertRoot(inertRoot);
    	          } else {
    	            inertNode = new InertNode(node, inertRoot);
    	          }

    	          this._managedNodes.set(node, inertNode);

    	          return inertNode;
    	        }

    	        /**
    	         * De-register the given InertRoot as managing the given inert node.
    	         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
    	         * node from the InertManager's set of managed nodes if it is destroyed.
    	         * If the node is not currently managed, this is essentially a no-op.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
    	         */

    	      }, {
    	        key: 'deregister',
    	        value: function deregister(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (!inertNode) {
    	            return null;
    	          }

    	          inertNode.removeInertRoot(inertRoot);
    	          if (inertNode.destroyed) {
    	            this._managedNodes['delete'](node);
    	          }

    	          return inertNode;
    	        }

    	        /**
    	         * Callback used when document has finished loading.
    	         */

    	      }, {
    	        key: '_onDocumentLoaded',
    	        value: function _onDocumentLoaded() {
    	          // Find all inert roots in document and make them actually inert.
    	          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
    	          inertElements.forEach(function (inertElement) {
    	            this.setInert(inertElement, true);
    	          }, this);

    	          // Comment this out to use programmatic API only.
    	          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });
    	        }

    	        /**
    	         * Callback used when mutation observer detects attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_watchForInert',
    	        value: function _watchForInert(records, self) {
    	          var _this = this;
    	          records.forEach(function (record) {
    	            switch (record.type) {
    	              case 'childList':
    	                slice.call(record.addedNodes).forEach(function (node) {
    	                  if (node.nodeType !== Node.ELEMENT_NODE) {
    	                    return;
    	                  }
    	                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
    	                  if (matches.call(node, '[inert]')) {
    	                    inertElements.unshift(node);
    	                  }
    	                  inertElements.forEach(function (inertElement) {
    	                    this.setInert(inertElement, true);
    	                  }, _this);
    	                }, _this);
    	                break;
    	              case 'attributes':
    	                if (record.attributeName !== 'inert') {
    	                  return;
    	                }
    	                var target = /** @type {!HTMLElement} */record.target;
    	                var inert = target.hasAttribute('inert');
    	                _this.setInert(target, inert);
    	                break;
    	            }
    	          }, this);
    	        }
    	      }]);

    	      return InertManager;
    	    }();

    	    /**
    	     * Recursively walk the composed tree from |node|.
    	     * @param {!Node} node
    	     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
    	     *     before descending into child nodes.
    	     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
    	     */


    	    function composedTreeWalk(node, callback, shadowRootAncestor) {
    	      if (node.nodeType == Node.ELEMENT_NODE) {
    	        var element = /** @type {!HTMLElement} */node;
    	        if (callback) {
    	          callback(element);
    	        }

    	        // Descend into node:
    	        // If it has a ShadowRoot, ignore all child elements - these will be picked
    	        // up by the <content> or <shadow> elements. Descend straight into the
    	        // ShadowRoot.
    	        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
    	        if (shadowRoot) {
    	          composedTreeWalk(shadowRoot, callback);
    	          return;
    	        }

    	        // If it is a <content> element, descend into distributed elements - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'content') {
    	          var content = /** @type {!HTMLContentElement} */element;
    	          // Verifies if ShadowDom v0 is supported.
    	          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
    	          for (var i = 0; i < distributedNodes.length; i++) {
    	            composedTreeWalk(distributedNodes[i], callback);
    	          }
    	          return;
    	        }

    	        // If it is a <slot> element, descend into assigned nodes - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'slot') {
    	          var slot = /** @type {!HTMLSlotElement} */element;
    	          // Verify if ShadowDom v1 is supported.
    	          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];
    	          for (var _i = 0; _i < _distributedNodes.length; _i++) {
    	            composedTreeWalk(_distributedNodes[_i], callback);
    	          }
    	          return;
    	        }
    	      }

    	      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
    	      // element, nor a <shadow> element recurse normally.
    	      var child = node.firstChild;
    	      while (child != null) {
    	        composedTreeWalk(child, callback);
    	        child = child.nextSibling;
    	      }
    	    }

    	    /**
    	     * Adds a style element to the node containing the inert specific styles
    	     * @param {!Node} node
    	     */
    	    function addInertStyle(node) {
    	      if (node.querySelector('style#inert-style, link#inert-style')) {
    	        return;
    	      }
    	      var style = document.createElement('style');
    	      style.setAttribute('id', 'inert-style');
    	      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
    	      node.appendChild(style);
    	    }

    	    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
    	      /** @type {!InertManager} */
    	      var inertManager = new InertManager(document);

    	      Object.defineProperty(HTMLElement.prototype, 'inert', {
    	        enumerable: true,
    	        /** @this {!HTMLElement} */
    	        get: function get() {
    	          return this.hasAttribute('inert');
    	        },
    	        /** @this {!HTMLElement} */
    	        set: function set(inert) {
    	          inertManager.setInert(this, inert);
    	        }
    	      });
    	    }
    	  })();

    	})));
    } ());

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
        var _a, _b, _c;
        /* Symbols for private properties */
        const _blockingElements = Symbol();
        const _alreadyInertElements = Symbol();
        const _topElParents = Symbol();
        const _siblingsToRestore = Symbol();
        const _parentMO = Symbol();
        /* Symbols for private static methods */
        const _topChanged = Symbol();
        const _swapInertedSibling = Symbol();
        const _inertSiblings = Symbol();
        const _restoreInertedSiblings = Symbol();
        const _getParents = Symbol();
        const _getDistributedChildren = Symbol();
        const _isInertable = Symbol();
        const _handleMutations = Symbol();
        class BlockingElementsImpl {
            constructor() {
                /**
                 * The blocking elements.
                 */
                this[_a] = [];
                /**
                 * Used to keep track of the parents of the top element, from the element
                 * itself up to body. When top changes, the old top might have been removed
                 * from the document, so we need to memoize the inerted parents' siblings
                 * in order to restore their inerteness when top changes.
                 */
                this[_b] = [];
                /**
                 * Elements that are already inert before the first blocking element is
                 * pushed.
                 */
                this[_c] = new Set();
            }
            destructor() {
                // Restore original inertness.
                this[_restoreInertedSiblings](this[_topElParents]);
                // Note we don't want to make these properties nullable on the class,
                // since then we'd need non-null casts in many places. Calling a method on
                // a BlockingElements instance after calling destructor will result in an
                // exception.
                const nullable = this;
                nullable[_blockingElements] = null;
                nullable[_topElParents] = null;
                nullable[_alreadyInertElements] = null;
            }
            get top() {
                const elems = this[_blockingElements];
                return elems[elems.length - 1] || null;
            }
            push(element) {
                if (!element || element === this.top) {
                    return;
                }
                // Remove it from the stack, we'll bring it to the top.
                this.remove(element);
                this[_topChanged](element);
                this[_blockingElements].push(element);
            }
            remove(element) {
                const i = this[_blockingElements].indexOf(element);
                if (i === -1) {
                    return false;
                }
                this[_blockingElements].splice(i, 1);
                // Top changed only if the removed element was the top element.
                if (i === this[_blockingElements].length) {
                    this[_topChanged](this.top);
                }
                return true;
            }
            pop() {
                const top = this.top;
                top && this.remove(top);
                return top;
            }
            has(element) {
                return this[_blockingElements].indexOf(element) !== -1;
            }
            /**
             * Sets `inert` to all document elements except the new top element, its
             * parents, and its distributed content.
             */
            [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
                const toKeepInert = this[_alreadyInertElements];
                const oldParents = this[_topElParents];
                // No new top, reset old top if any.
                if (!newTop) {
                    this[_restoreInertedSiblings](oldParents);
                    toKeepInert.clear();
                    this[_topElParents] = [];
                    return;
                }
                const newParents = this[_getParents](newTop);
                // New top is not contained in the main document!
                if (newParents[newParents.length - 1].parentNode !== document.body) {
                    throw Error('Non-connected element cannot be a blocking element');
                }
                // Cast here because we know we'll call _inertSiblings on newParents
                // below.
                this[_topElParents] = newParents;
                const toSkip = this[_getDistributedChildren](newTop);
                // No previous top element.
                if (!oldParents.length) {
                    this[_inertSiblings](newParents, toSkip, toKeepInert);
                    return;
                }
                let i = oldParents.length - 1;
                let j = newParents.length - 1;
                // Find common parent. Index 0 is the element itself (so stop before it).
                while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
                    i--;
                    j--;
                }
                // If up the parents tree there are 2 elements that are siblings, swap
                // the inerted sibling.
                if (oldParents[i] !== newParents[j]) {
                    this[_swapInertedSibling](oldParents[i], newParents[j]);
                }
                // Restore old parents siblings inertness.
                i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
                // Make new parents siblings inert.
                j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
            }
            /**
             * Swaps inertness between two sibling elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_swapInertedSibling](oldInert, newInert) {
                const siblingsToRestore = oldInert[_siblingsToRestore];
                // oldInert is not contained in siblings to restore, so we have to check
                // if it's inertable and if already inert.
                if (this[_isInertable](oldInert) && !oldInert.inert) {
                    oldInert.inert = true;
                    siblingsToRestore.add(oldInert);
                }
                // If newInert was already between the siblings to restore, it means it is
                // inertable and must be restored.
                if (siblingsToRestore.has(newInert)) {
                    newInert.inert = false;
                    siblingsToRestore.delete(newInert);
                }
                newInert[_parentMO] = oldInert[_parentMO];
                newInert[_siblingsToRestore] = siblingsToRestore;
                oldInert[_parentMO] = undefined;
                oldInert[_siblingsToRestore] = undefined;
            }
            /**
             * Restores original inertness to the siblings of the elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_restoreInertedSiblings](elements) {
                for (const element of elements) {
                    const mo = element[_parentMO];
                    mo.disconnect();
                    element[_parentMO] = undefined;
                    const siblings = element[_siblingsToRestore];
                    for (const sibling of siblings) {
                        sibling.inert = false;
                    }
                    element[_siblingsToRestore] = undefined;
                }
            }
            /**
             * Inerts the siblings of the elements except the elements to skip. Stores
             * the inerted siblings into the element's symbol `_siblingsToRestore`.
             * Pass `toKeepInert` to collect the already inert elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_inertSiblings](elements, toSkip, toKeepInert) {
                for (const element of elements) {
                    // Assume element is not a Document, so it must have a parentNode.
                    const parent = element.parentNode;
                    const children = parent.children;
                    const inertedSiblings = new Set();
                    for (let j = 0; j < children.length; j++) {
                        const sibling = children[j];
                        // Skip the input element, if not inertable or to be skipped.
                        if (sibling === element || !this[_isInertable](sibling) ||
                            (toSkip && toSkip.has(sibling))) {
                            continue;
                        }
                        // Should be collected since already inerted.
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                    // Store the siblings that were inerted.
                    element[_siblingsToRestore] = inertedSiblings;
                    // Observe only immediate children mutations on the parent.
                    const mo = new MutationObserver(this[_handleMutations].bind(this));
                    element[_parentMO] = mo;
                    let parentToObserve = parent;
                    // If we're using the ShadyDOM polyfill, then our parent could be a
                    // shady root, which is an object that acts like a ShadowRoot, but isn't
                    // actually a node in the real DOM. Observe the real DOM parent instead.
                    const maybeShadyRoot = parentToObserve;
                    if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
                        parentToObserve = maybeShadyRoot.host;
                    }
                    mo.observe(parentToObserve, {
                        childList: true,
                    });
                }
            }
            /**
             * Handles newly added/removed nodes by toggling their inertness.
             * It also checks if the current top Blocking Element has been removed,
             * notifying and removing it.
             */
            [_handleMutations](mutations) {
                const parents = this[_topElParents];
                const toKeepInert = this[_alreadyInertElements];
                for (const mutation of mutations) {
                    // If the target is a shadowRoot, get its host as we skip shadowRoots when
                    // computing _topElParents.
                    const target = mutation.target.host || mutation.target;
                    const idx = target === document.body ?
                        parents.length :
                        parents.indexOf(target);
                    const inertedChild = parents[idx - 1];
                    const inertedSiblings = inertedChild[_siblingsToRestore];
                    // To restore.
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        const sibling = mutation.removedNodes[i];
                        if (sibling === inertedChild) {
                            console.info('Detected removal of the top Blocking Element.');
                            this.pop();
                            return;
                        }
                        if (inertedSiblings.has(sibling)) {
                            sibling.inert = false;
                            inertedSiblings.delete(sibling);
                        }
                    }
                    // To inert.
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        const sibling = mutation.addedNodes[i];
                        if (!this[_isInertable](sibling)) {
                            continue;
                        }
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                }
            }
            /**
             * Returns if the element is inertable.
             */
            [_isInertable](element) {
                return false === /^(style|template|script)$/.test(element.localName);
            }
            /**
             * Returns the list of newParents of an element, starting from element
             * (included) up to `document.body` (excluded).
             */
            [_getParents](element) {
                const parents = [];
                let current = element;
                // Stop to body.
                while (current && current !== document.body) {
                    // Skip shadow roots.
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        parents.push(current);
                    }
                    // ShadowDom v1
                    if (current.assignedSlot) {
                        // Collect slots from deepest slot to top.
                        while (current = current.assignedSlot) {
                            parents.push(current);
                        }
                        // Continue the search on the top slot.
                        current = parents.pop();
                        continue;
                    }
                    current = current.parentNode ||
                        current.host;
                }
                return parents;
            }
            /**
             * Returns the distributed children of the element's shadow root.
             * Returns null if the element doesn't have a shadow root.
             */
            [_getDistributedChildren](element) {
                const shadowRoot = element.shadowRoot;
                if (!shadowRoot) {
                    return null;
                }
                const result = new Set();
                let i;
                let j;
                let nodes;
                const slots = shadowRoot.querySelectorAll('slot');
                if (slots.length && slots[0].assignedNodes) {
                    for (i = 0; i < slots.length; i++) {
                        nodes = slots[i].assignedNodes({
                            flatten: true,
                        });
                        for (j = 0; j < nodes.length; j++) {
                            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                                result.add(nodes[j]);
                            }
                        }
                    }
                    // No need to search for <content>.
                }
                return result;
            }
        }
        document.$blockingElements =
            new BlockingElementsImpl();
    })();

    function blockingElements() { return getDocument$1().$blockingElements; }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */
    function useBlockingElement(enabled, getTarget) {
        const stableGetTarget = useStableCallback(getTarget);
        /**
         * Push/pop the element from the blockingElements stack.
         */
        _(() => {
            const target = stableGetTarget();
            if (enabled) {
                // Sometimes blockingElements will fail if, for example,
                // the target element isn't connected to document.body.
                // This is rare, but it's better to fail silently with weird tabbing behavior
                // than to crash the entire application.
                try {
                    blockingElements().push(target);
                    return () => {
                        blockingElements().remove(target);
                    };
                }
                catch (ex) {
                    // Well, semi-silently.
                    console.error(ex);
                }
            }
        }, [enabled]);
    }
    function getTopElement() {
        return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap({ focusTrapParameters: { trapActive }, activeElementParameters, refElementParameters: { onElementChange, ...refElementParameters } }) {
        const handleActiveChange = q$1((trapActive, element) => {
            if (trapActive && element) {
                let rafHandle = requestAnimationFrame(() => {
                    // TODO: This extra queueMicrotask is needed for
                    // ...reasons?
                    queueMicrotask(() => {
                        findFirstFocusable(element)?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
            else if (element) {
                // Restore the focus to the element
                // that has returned to the top of the stack
                let rafHandle = requestAnimationFrame(() => {
                    queueMicrotask(() => {
                        elementsToRestoreFocusTo.get(getTopElement())?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
        }, []);
        const { refElementReturn } = useRefElement({
            refElementParameters: {
                onElementChange: useStableCallback((element, p) => {
                    handleActiveChange(trapActive, element);
                    onElementChange?.(element, p);
                }),
                ...refElementParameters
            }
        });
        const { activeElementReturn } = useActiveElement({ activeElementParameters });
        const { getElement } = refElementReturn;
        const { getLastActiveElement } = activeElementReturn;
        // When the trap becomes active, before we let the blockingElements hook run,
        // keep track of whatever's currently focused and save it.
        _(() => {
            const element = getElement();
            if (trapActive && element) {
                const document = getDocument$1(element);
                // Save the currently focused element
                // to whatever's currently at the top of the stack
                elementsToRestoreFocusTo.set(getTopElement(), getLastActiveElement() ?? document.body);
            }
        }, [trapActive]);
        useBlockingElement(trapActive, getElement);
        /**
         * Any time we activate or deactivate the trap,
         * change focus to something else (something in
         * the trap if it's active, or whatever we've
         * tracked in elementsToRestoreFocusTo if not)
         */
        _(() => {
            handleActiveChange(trapActive, getElement());
        }, [trapActive]);
        return {
            activeElementReturn,
            refElementReturn,
            focusTrap: { propsUnstable: { "aria-modal": trapActive ? "true" : undefined } }
        };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */
    function findFirstFocusable(element) {
        const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => (node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP) });
        const firstFocusable = treeWalker.firstChild();
        return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */
    function useForceUpdate() {
        const [, set] = y(0);
        return A(() => set(i => ++i)).current;
    }

    function useTimeout({ timeout, callback, triggerIndex }) {
        const stableCallback = useStableCallback(() => { startTimeRef.current = null; callback(); });
        const getTimeout = useStableGetter(timeout);
        // Set any time we start timeout.
        // Unset any time the timeout completes
        const startTimeRef = A(null);
        const timeoutIsNull = (timeout == null);
        // Any time the triggerIndex changes (including on mount)
        // restart the timeout.  The timeout does NOT reset
        // when the duration or callback changes, only triggerIndex.
        s(() => {
            if (!timeoutIsNull) {
                const timeout = getTimeout();
                console.assert(timeoutIsNull == (timeout == null));
                if (timeout != null) {
                    startTimeRef.current = +(new Date());
                    const handle = setTimeout(stableCallback, timeout);
                    return () => clearTimeout(handle);
                }
            }
        }, [triggerIndex, timeoutIsNull]);
        const getElapsedTime = q$1(() => {
            return (+(new Date())) - (+(startTimeRef.current ?? new Date()));
        }, []);
        const getRemainingTime = q$1(() => {
            const timeout = getTimeout();
            return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
        }, []);
        return { getElapsedTime, getRemainingTime };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useLinearNavigation({ linearNavigationParameters: { navigateToFirst: ntf, navigateToLast: ntl, navigateToNext: ntn, navigateToPrev: ntp, navigationDirection: nd, disableArrowKeys: dak, disableHomeEndKeys: dhek } }) {
        nd ??= "either";
        //const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection<ParentOrChildElement>({});
        const navigateToFirst = useStableCallback(ntf);
        const navigateToLast = useStableCallback(ntl);
        const navigateToNext = useStableCallback(ntn);
        const navigateToPrev = useStableCallback(ntp);
        const getDisableArrowKeys = useStableGetter(dak);
        const getDisableHomeEndKeys = useStableGetter(dhek);
        const getNavigationDirection = useStableGetter(nd);
        const stableProps = A({
            onKeyDown: (e) => {
                // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                if (e.ctrlKey || e.metaKey)
                    return;
                //const info = getLogicalDirectionInfo();
                const navigationDirection = getNavigationDirection();
                const disableArrowKeys = getDisableArrowKeys();
                const disableHomeEndKeys = getDisableHomeEndKeys();
                const allowsVerticalNavigation = (navigationDirection == "vertical" || navigationDirection == "either");
                const allowsHorizontalNavigation = (navigationDirection == "horizontal" || navigationDirection == "either");
                switch (e.key) {
                    case "ArrowUp": {
                        //const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                        const directionAllowed = (!disableArrowKeys && allowsVerticalNavigation);
                        if (directionAllowed) {
                            navigateToPrev();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        break;
                    }
                    case "ArrowDown": {
                        const directionAllowed = (!disableArrowKeys && allowsVerticalNavigation);
                        if (directionAllowed) {
                            navigateToNext();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        break;
                    }
                    case "ArrowLeft": {
                        const directionAllowed = (!disableArrowKeys && allowsHorizontalNavigation);
                        if (directionAllowed) {
                            navigateToPrev();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        break;
                    }
                    case "ArrowRight": {
                        const directionAllowed = (!disableArrowKeys && allowsHorizontalNavigation);
                        if (directionAllowed) {
                            navigateToNext();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        e.preventDefault();
                        e.stopPropagation();
                        break;
                    }
                    case "Home":
                        if (!disableHomeEndKeys) {
                            navigateToFirst();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        break;
                    case "End":
                        if (!disableHomeEndKeys) {
                            navigateToLast();
                            e.preventDefault();
                            e.stopPropagation();
                        }
                        break;
                }
            }
        });
        return {
            linearNavigationReturn: {
                propsStable: stableProps.current
            }
        };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useTypeaheadNavigation({ typeaheadNavigationParameters: { collator, getIndex, typeaheadTimeout, setIndex, noTypeahead } }) {
        // For typeahead, keep track of what our current "search" string is (if we have one)
        // and also clear it every 1000 ms since the last time it changed.
        // Next, keep a mapping of typeahead values to indices for faster searching.
        // And, for the user's sake, let them know when their typeahead can't match anything anymore
        const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
        useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
        const sortedTypeaheadInfo = A([]);
        const [invalidTypeahead, setInvalidTypeahead] = useState(false);
        // Handle typeahead for input method editors as well
        // Essentially, when active, ignore further keys 
        // because we're waiting for a CompositionEnd event
        const [, setImeActive, getImeActive] = useState(false);
        // Because composition events fire *after* keydown events 
        // (but within the same task, which, TODO, could be browser-dependent),
        // we can use this to keep track of which event we're listening for on the first keydown.
        const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
        _(() => {
            if (nextTypeaheadChar !== null) {
                setCurrentTypeahead(typeahead => ((typeahead ?? "") + nextTypeaheadChar));
                setNextTypeaheadChar(null);
            }
        }, [nextTypeaheadChar]);
        const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
            let compare;
            // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
            // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
            safeLhs = safeLhs.normalize("NFD");
            safeRhs = safeRhs.normalize("NFD");
            if (collator)
                compare = collator.compare(safeLhs, safeRhs);
            else
                compare = safeLhs.toLowerCase().localeCompare(safeRhs.toLowerCase() ?? "");
            return compare;
        });
        const insertingComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                return comparatorShared(lhs, rhs.text);
            }
            return lhs - rhs;
        });
        const typeaheadComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                // During typeahead, all strings longer than ours should be truncated
                // so that they're all considered equally by that point.
                return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
            }
            return lhs - rhs;
        });
        const isDisabled = useStableGetter(noTypeahead);
        const propsStable = A({
            onKeyDown: useStableCallback((e) => {
                if (isDisabled())
                    return;
                const imeActive = getImeActive();
                const key = e.key;
                // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                if (e.ctrlKey || e.metaKey)
                    return;
                if (!imeActive && e.key === "Backspace") {
                    // Remove the last character in a way that doesn't split UTF-16 surrogates.
                    setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                // The key property represents the typed character OR the "named key attribute" of the key pressed.
                // There's no definite way to tell the difference, but for all intents and purposes
                // there are no one-character names, and there are no non-ASCII-alpha names.
                // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
                const isCharacterKey = (key.length === 1 || !/^[A-Za-z]/.test(key));
                if (isCharacterKey) {
                    if (key == " " && (getCurrentTypeahead() ?? "").trim().length == 0) ;
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        // Note: Won't be true for the first keydown
                        // but will be overwritten before useLayoutEffect is called
                        // to actually apply the change
                        if (!imeActive)
                            setNextTypeaheadChar(key);
                    }
                }
            }),
            onCompositionStart: useStableCallback((e) => {
                setNextTypeaheadChar(e.data);
                setImeActive(false);
            }),
            onCompositionEnd: useStableCallback((_e) => { setImeActive(true); }),
        });
        // Handle changes in typeahead that cause changes to the tabbable index
        s(() => {
            if (currentTypeahead && sortedTypeaheadInfo.current.length) {
                const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
                if (sortedTypeaheadIndex < 0) {
                    // The user has typed an entry that doesn't exist in the list
                    // (or more specifically "for which there is no entry that starts with that input")
                    setInvalidTypeahead(true);
                }
                else {
                    setInvalidTypeahead(false);
                    /*
                      We know roughly where, in the sorted array of strings, our next typeahead location is.
                      But roughly isn't good enough if there are multiple matches.
                      To convert our sorted index to the unsorted index we need, we have to find the first
                      element that matches us *and* (if any such exist) is *after* our current selection.

                      In other words, the only way typeahead moves backwards relative to our current
                      position is if the only other option is behind us.

                      It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
                      Though there's also a case for just going upwards to the nearest to prevent jumpiness.
                      But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
                      I dunno. Going back to the start is the simplist though.

                      Basically what this does: Starting from where we found ourselves after our binary search,
                      scan backwards and forwards through all adjacent entries that also compare equally so that
                      we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
                      (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).

                      TODO: The binary search starts this off with a solid O(log n), but one-character
                      searches are, thanks to pigeonhole principal, eventually guaranteed to become
                      O(n*log n). This is annoying but probably not easily solvable? There could be an
                      exception for one-character strings, but that's just kicking the can down
                      the road. Maybe one or two characters would be good enough though.
                    */
                    // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
                    let lowestUnsortedIndexAll = null;
                    let lowestSortedIndexAll = sortedTypeaheadIndex;
                    // These two are only set for elements that are ahead of us, but the principle's the same otherwise
                    let lowestUnsortedIndexNext = null;
                    let lowestSortedIndexNext = sortedTypeaheadIndex;
                    const updateBestFit = (u) => {
                        if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                            lowestUnsortedIndexAll = u;
                            lowestSortedIndexAll = i;
                        }
                        if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > (getIndex() ?? -Infinity)) {
                            lowestUnsortedIndexNext = u;
                            lowestSortedIndexNext = i;
                        }
                    };
                    let i = sortedTypeaheadIndex;
                    while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        --i;
                    }
                    i = sortedTypeaheadIndex;
                    while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        ++i;
                    }
                    if (lowestUnsortedIndexNext !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);
                    else if (lowestUnsortedIndexAll !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
                }
            }
        }, [currentTypeahead]);
        const useTypeaheadNavigationChild = q$1(({ index, text }) => {
            s(() => {
                if (text) {
                    // Find where to insert this item.
                    // Because all index values should be unique, the returned sortedIndex
                    // should always refer to a new location (i.e. be negative)                
                    const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                    console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                    if (sortedIndex < 0) {
                        sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, { text, unsortedIndex: index });
                    }
                    else {
                        sortedTypeaheadInfo.current.splice(sortedIndex, 0, { text, unsortedIndex: index });
                    }
                    return () => {
                        // When unmounting, find where we were and remove ourselves.
                        // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
                        const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                        console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                        if (sortedIndex >= 0) {
                            sortedTypeaheadInfo.current.splice(sortedIndex, 1);
                        }
                    };
                }
            }, [text]);
            return;
        }, []);
        return {
            useTypeaheadNavigationChild,
            typeaheadNavigationReturn: {
                currentTypeahead,
                invalidTypeahead,
                propsStable: propsStable.current
            }
        };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */
    function binarySearch(array, wanted, comparator) {
        let firstIndex = 0;
        let lastIndex = array.length - 1;
        while (firstIndex <= lastIndex) {
            const testIndex = (lastIndex + firstIndex) >> 1;
            const comparisonResult = comparator(wanted, array[testIndex]);
            if (comparisonResult > 0) {
                firstIndex = testIndex + 1;
            }
            else if (comparisonResult < 0) {
                lastIndex = testIndex - 1;
            }
            else {
                return testIndex;
            }
        }
        return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */
    function useRovingTabIndex(parentParameters) {
        let { managedChildrenParameters: { onAfterChildLayoutEffect, onChildrenMountChange }, rovingTabIndexParameters: { initialIndex, onTabbableIndexChange, onTabbableRender } } = parentParameters;
        initialIndex ??= 0;
        const stableOnTabbableRender = useStableCallback(onTabbableRender ?? (() => { }));
        /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
            if (oldCount == 0 && newCount > 0) {
                onTabbedInTo?.();
            }

            if (newCount == 0 && (oldCount ?? 0) > 0) {
                onTabbedOutOf?.();
            }
        }), returnZero);*/
        // Keep track of three things related to the currently tabbable element's index:
        // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.
        const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => { return initialIndex ?? 0; }, []));
        const setTabbableIndex = q$1((updater, fromUserInteraction) => {
            setTabbableIndex2((prevIndex) => {
                let nextIndex = prevIndex;
                if (typeof updater === "function")
                    nextIndex = updater(prevIndex ?? null);
                else
                    nextIndex = updater;
                nextIndex = changeIndex(nextIndex);
                if (prevIndex != nextIndex) {
                    const nextChild = nextIndex == null ? null : children.getAt(nextIndex);
                    //const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
                    //if (prevChild != null)
                    //    prevChild.subInfo.blurSelf();
                    if (nextChild != null && fromUserInteraction) {
                        const element = nextChild.subInfo.getElement();
                        if (element) {
                            if (document.activeElement == null || !element.contains(document.activeElement))
                                nextChild.subInfo.focusSelf();
                        }
                    }
                }
                return nextIndex;
            });
        }, []);
        // Any time the tabbable index changes,
        // notify the previous child that it's no longer tabbable,
        // and notify the next child that is allowed to be tabbed to.
        const { managedChildrenReturn, useManagedChild } = useManagedChildren({
            managedChildrenParameters: {
                onAfterChildLayoutEffect,
                onChildrenMountChange: useStableCallback((mounted, unmounted) => { onChildrenMountChange?.(mounted, unmounted); reevaluateClosestFit(); }),
            },
        });
        const { children } = managedChildrenReturn;
        const { changeIndex, reevaluateClosestFit } = useChildrenFlag({ initialIndex, children, closestFit: true, key: "tabbable" });
        const useRovingTabIndexChild = q$1((childParameters) => {
            const { managedChildParameters: { index, flags }, rovingTabIndexChildParameters: { focusSelf: focusSelfOverride, noModifyTabIndex, hidden }, refElementReturn: { getElement }, 
            //hasFocusParameters: { onFocusedInnerChanged, ...hasFocusParameters },
            subInfo } = childParameters;
            s(() => {
                reevaluateClosestFit();
            }, [!!hidden]);
            const stableFocusSelf = useStableCallback(focusSelfOverride);
            const focusSelf = q$1(() => {
                const element = getElement();
                if (element) {
                    if (document.activeElement == null || !element.contains(document.activeElement))
                        stableFocusSelf(element);
                }
            }, []);
            /*const { activeElementReturn, hasFocusReturn, refElementReturn } = useHasFocus<ChildElement>({
                activeElementParameters,
                hasFocusParameters: {
                    ,
                    ...hasFocusParameters
                },
                refElementParameters
            });*/
            //const { getElement } = refElementReturn;
            const [tabbable, setTabbable, getTabbable] = useState(false);
            const tabbableFlags = A({ get: getTabbable, set: setTabbable, isValid: useStableCallback(() => !hidden) });
            useManagedChild({
                managedChildParameters: {
                    index,
                    flags: { ...flags, tabbable: tabbableFlags.current },
                },
                subInfo: {
                    focusSelf,
                    getElement,
                    hidden: !!hidden,
                    subInfo
                }
            });
            s(() => {
                if (tabbable)
                    stableOnTabbableRender(index);
            }, [tabbable, index]);
            //const rovingTabIndexChildProps = useMergedProps(refElementProps, { tabIndex: noModifyTabIndex ? undefined : (tabbable ? 0 : -1) })
            return {
                hasCurrentFocusParameters: {
                    onCurrentFocusedInnerChanged: useStableCallback((focused, _prevFocused) => {
                        if (focused) {
                            setTabbableIndex(index, false);
                        }
                    })
                },
                rovingTabIndexChildReturn: {
                    propsUnstable: { tabIndex: noModifyTabIndex ? undefined : (tabbable ? 0 : -1) },
                    tabbable,
                    getTabbable
                }
            };
        }, [ /* Must remain stable */]);
        const focusSelf = q$1(() => {
            const index = getTabbableIndex();
            if (index != null)
                children.getAt(index)?.subInfo.focusSelf?.();
            else
                setTabbableIndex(null, true);
        }, []);
        return {
            useRovingTabIndexChild,
            managedChildrenReturn,
            rovingTabIndexReturn: {
                setTabbableIndex,
                getTabbableIndex,
                focusSelf,
            }
        };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    function identity(t) { return t; }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any text for typeahead to focus the next item that matches.
     */
    function useListNavigation({ managedChildrenParameters: { onChildrenMountChange, ...mc }, rovingTabIndexParameters, listNavigationParameters: { indexDemangler, indexMangler }, linearNavigationParameters, typeaheadNavigationParameters }) {
        indexMangler ??= identity;
        indexDemangler ??= identity;
        useEnsureStability("useListNavigation", indexMangler, indexDemangler);
        const { managedChildrenReturn, rovingTabIndexReturn, useRovingTabIndexChild } = useRovingTabIndex({
            managedChildrenParameters: {
                ...mc, onChildrenMountChange: q$1((m, u) => {
                    onChildrenMountChange?.(m, u);
                }, [])
            },
            rovingTabIndexParameters
        });
        const { children } = managedChildrenReturn;
        const { getTabbableIndex, setTabbableIndex } = rovingTabIndexReturn;
        const navigateToIndex = q$1((i, fromUserInteraction) => {
            if (i != null) {
                const nextIndex = tryNavigateToIndex({
                    children: children,
                    default: 0,
                    target: i,
                    searchDirection: 1,
                    indexMangler: indexMangler ?? identity,
                    indexDemangler: indexDemangler ?? identity
                });
                setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
            }
            else {
                setTabbableIndex(null, fromUserInteraction);
            }
        }, []);
        const { useTypeaheadNavigationChild, typeaheadNavigationReturn } = useTypeaheadNavigation({
            typeaheadNavigationParameters: {
                getIndex: getTabbableIndex,
                setIndex: q$1((index) => {
                    setTabbableIndex(index, true);
                }, []),
                ...typeaheadNavigationParameters
            }
        });
        const { linearNavigationReturn } = useLinearNavigation({
            linearNavigationParameters: {
                navigateToPrev: q$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler((c ?? 0)) - 1), searchDirection: -1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToNext: q$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler(c ?? 0) + 1), searchDirection: 1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToFirst: q$1(() => { navigateToIndex(indexDemangler(0), true); }, []),
                navigateToLast: q$1(() => { navigateToIndex(indexDemangler(children.getHighestIndex()), true); }, []),
                ...linearNavigationParameters
            }
        });
        const useListNavigationChild = q$1((args) => {
            const { managedChildParameters: { index, flags }, rovingTabIndexChildParameters: { focusSelf, hidden, noModifyTabIndex }, listNavigationChildParameters: { text }, refElementReturn, subInfo } = args;
            useTypeaheadNavigationChild({ text, index });
            const getIndex = useStableGetter(index);
            s(() => {
                return () => {
                    if (getTabbableIndex() == getIndex()) {
                        navigateToIndex(index, false);
                    }
                };
            }, []);
            const { rovingTabIndexChildReturn, hasCurrentFocusParameters } = useRovingTabIndexChild({
                managedChildParameters: { index, flags },
                refElementReturn,
                rovingTabIndexChildParameters: { focusSelf, hidden: !!hidden, noModifyTabIndex },
                subInfo: { text, subInfo }
            });
            return {
                hasCurrentFocusParameters,
                rovingTabIndexChildReturn
            };
        }, []);
        return {
            linearNavigationReturn,
            useListNavigationChild,
            listNavigationReturn: { navigateToIndex },
            managedChildrenReturn,
            rovingTabIndexReturn,
            typeaheadNavigationReturn
        };
    }
    function tryNavigateToIndex({ children, searchDirection, indexDemangler, indexMangler, target }) {
        const upper = children.getHighestIndex();
        const lower = 0;
        if (searchDirection === -1) {
            while ((target >= lower && (children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden))
                target = indexDemangler(indexMangler(target) - 1);
            return target < lower ? indexDemangler(lower) : target;
        }
        else if (searchDirection === 1) {
            while ((target <= upper && children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden)
                target = indexDemangler(indexMangler(target) + 1);
            return target > upper ? indexDemangler(upper) : target;
        }
        else {
            return lower;
        }
    }

    function useGridNavigation({ managedChildrenParameters: mc, rovingTabIndexParameters: rti, listNavigationParameters: ls, linearNavigationParameters: ln, typeaheadNavigationParameters: tn, gridNavigationParameters: { rowIndexDemangler, rowIndexMangler } }) {
        const [currentColumn, setCurrentColumn, getCurrentColumn] = useState(rti.initialIndex ?? 0);
        const { useListNavigationChild: useListNavigationChildAsGridRow, ...parentLsReturnType } = useListNavigation({
            managedChildrenParameters: mc,
            rovingTabIndexParameters: rti,
            listNavigationParameters: { indexDemangler: rowIndexDemangler, indexMangler: rowIndexMangler, ...ls },
            linearNavigationParameters: { navigationDirection: "vertical", ...ln },
            typeaheadNavigationParameters: tn,
        });
        const useGridNavigationRow = q$1(({ asChildRowOfSection: asChild, asParentRowOfCells: asParent }) => {
            // Override the focusSelf that rovingTabIndex does.
            // Instead of focusing the entire row, we ask the cell that corresponds
            // to our current column to focus itself.
            const focusSelfRow = useStableCallback(() => {
                const c2 = getCurrentColumn();
                navigateToColumn(c2 ?? 0, true);
            });
            const rowLsChildReturnType = useListNavigationChildAsGridRow({
                refElementReturn: asChild.refElementReturn,
                managedChildParameters: asChild.managedChildParameters,
                listNavigationChildParameters: asChild.listNavigationChildParameters,
                rovingTabIndexChildParameters: { ...asChild.rovingTabIndexChildParameters, focusSelf: focusSelfRow },
                subInfo: { subInfo: asChild.subInfo },
            });
            const { rovingTabIndexChildReturn: { tabbable } } = rowLsChildReturnType;
            s(() => {
                if (!tabbable) {
                    navigateToColumn(null, false);
                }
            }, [tabbable]);
            const rowLsReturnType = useListNavigation({
                managedChildrenParameters: { ...asParent.managedChildrenParameters },
                rovingTabIndexParameters: { ...asParent.rovingTabIndexParameters },
                linearNavigationParameters: {
                    ...asParent.linearNavigationParameters,
                    navigationDirection: "horizontal",
                },
                typeaheadNavigationParameters: { ...asParent.typeaheadNavigationParameters, noTypeahead: true },
                listNavigationParameters: { ...asParent.listNavigationParameters }
            });
            const { rovingTabIndexReturn: { setTabbableIndex }, useListNavigationChild: useGridNavigationColumn2, listNavigationReturn: { navigateToIndex: navigateToColumn }, } = rowLsReturnType;
            //const rowHidden = !!asChild.rovingTabIndex.hidden;
            const useGridNavigationCell = q$1(({ subInfo, managedChildParameters, listNavigationChildParameters: ls, refElementReturn, rovingTabIndexChildParameters: { focusSelf: focusSelfCell, ...rti } }) => {
                const { rovingTabIndexChildReturn: rti_cell_ret, hasCurrentFocusParameters } = useGridNavigationColumn2({
                    refElementReturn,
                    managedChildParameters: managedChildParameters,
                    listNavigationChildParameters: { ...ls },
                    rovingTabIndexChildParameters: { focusSelf: focusSelfCell, ...rti },
                    subInfo: { subInfo }
                });
                const ret = {
                    gridNavigationReturn: { getCurrentColumn },
                    rovingTabIndexChildReturn: rti_cell_ret,
                    hasCurrentFocusParameters: {
                        ...hasCurrentFocusParameters,
                        onCurrentFocusedInnerChanged: useStableCallback((focused, prev) => {
                            if (focused) {
                                if (managedChildParameters.index == 0)
                                    debugger;
                                setCurrentColumn(managedChildParameters.index);
                                setTabbableIndex(managedChildParameters.index, false);
                            }
                        })
                    },
                };
                return ret;
            }, []);
            const ret = {
                asParentOfCells: {
                    linearNavigationReturn: rowLsReturnType.linearNavigationReturn,
                    listNavigationReturn: rowLsReturnType.listNavigationReturn,
                    managedChildrenReturn: rowLsReturnType.managedChildrenReturn,
                    rovingTabIndexReturn: rowLsReturnType.rovingTabIndexReturn,
                    typeaheadNavigationReturn: rowLsReturnType.typeaheadNavigationReturn,
                },
                asChildRow: rowLsChildReturnType,
                useGridNavigationCell
            };
            return ret;
        }, []);
        return {
            gridNavigationReturn: {
                getCurrentColumn,
                currentColumn
            },
            linearNavigationReturn: parentLsReturnType.linearNavigationReturn,
            listNavigationReturn: parentLsReturnType.listNavigationReturn,
            rovingTabIndexReturn: parentLsReturnType.rovingTabIndexReturn,
            typeaheadNavigationReturn: parentLsReturnType.typeaheadNavigationReturn,
            managedChildrenReturn: parentLsReturnType.managedChildrenReturn,
            useGridNavigationRow,
        };
    }

    function useHasCurrentFocus(args) {
        const { hasCurrentFocusParameters: { onCurrentFocusedChanged: onFocusedChanged, onCurrentFocusedInnerChanged: onFocusedInnerChanged }, refElementReturn: { getElement } } = args;
        useEnsureStability("useHasCurrentFocus", onFocusedChanged, onFocusedInnerChanged, getElement);
        const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
        const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
        const onFocusIn = q$1((e) => {
            setFocusedInner(true);
            setFocused(e.target == getElement());
        }, []);
        const onFocusOut = q$1((e) => {
            if (e.target == getElement()) {
                setFocusedInner(false);
                setFocused(false);
            }
        }, []);
        const propsStable = A({
            onfocusin: onFocusIn,
            onfocusout: onFocusOut
        });
        return {
            hasCurrentFocusReturn: {
                propsStable: propsStable.current,
                getCurrentFocused: getFocused,
                getCurrentFocusedInner: getFocusedInner,
            }
        };
    }

    function useHasLastFocus(args) {
        const { refElementReturn: { getElement }, activeElementParameters: { onActiveElementChange, onLastActiveElementChange, ...activeElementParameters }, hasLastFocusParameters: { onLastFocusedChanged, onLastFocusedInnerChanged, ..._void } } = args;
        useEnsureStability("useHasFocus", onLastFocusedChanged, onLastFocusedInnerChanged);
        const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse);
        const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse);
        const { activeElementReturn } = useActiveElement({
            activeElementParameters: {
                onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
                    const selfElement = getElement();
                    const focused = (selfElement != null && (selfElement == lastActiveElement));
                    const focusedInner = (!!selfElement?.contains(lastActiveElement));
                    setLastFocused(focused);
                    setLastFocusedInner(focusedInner);
                    onLastActiveElementChange?.(lastActiveElement, prevLastActiveElement);
                }, []),
                ...activeElementParameters
            },
        });
        return {
            activeElementReturn,
            hasLastFocusReturn: {
                getLastFocused,
                getLastFocusedInner,
            }
        };
    }

    function useInterval({ interval, callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback);
        const getInterval = useStableGetter(interval);
        s(() => {
            const interval = getInterval();
            let lastDelayUsed = interval;
            if (interval == null)
                return;
            // Get a wrapper around the wrapper around the callback
            // that clears and resets the interval if it changes.
            const adjustableCallback = () => {
                stableCallback();
                const currentInterval = getInterval();
                if (currentInterval != lastDelayUsed) {
                    clearInterval(handle);
                    if (currentInterval != null)
                        handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
                }
            };
            let handle = setInterval(adjustableCallback, interval);
            return () => clearInterval(handle);
        }, []);
    }

    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * any element, whether it's a native <BUTTON> or regular <DIV>.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */
    function usePress(args) {
        const { refElementReturn: { getElement }, pressParameters: { exclude, focusSelf, onClickSync } } = args;
        // A button can be activated in multiple ways, so on the off chance
        // that multiple are triggered at once, we only *actually* register
        // a press once all of our "on" signals have turned back to "off".
        // We approximate this by just incrementing when active, and
        // decrementing when deactivated.
        //
        // As an emergency failsafe, when the element loses focus,
        // this is reset back to 0.
        const [activeDuringRender, setActive, getActive] = useState(0);
        const forceUpdate = useForceUpdate();
        //const { getElement } = refElementReturn;
        // If we the current text selection changes to include this element
        // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
        // because its only purpose was selecting text, not clicking buttons.
        //
        // To catch this, any time the text selection includes us while in the middle
        // of a click, this flag is set, which cancels the activation of a press.
        // The flag is reset any time the selection is empty or the button is
        // no longer active.
        const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
        const pseudoActive = (activeDuringRender && (textSelectedDuringActivationStartTime == null));
        useGlobalHandler(document, "selectionchange", _ => {
            setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
        });
        s(() => {
            if (activeDuringRender == 0)
                setTextSelectedDuringActivationStartTime(null);
        }, [activeDuringRender == 0]);
        const onActiveStart = useStableCallback((_) => {
            setActive(a => ++a);
        });
        const onActiveStop = useStableCallback((e) => {
            setActive(a => Math.max(0, --a));
            const currentTime = new Date();
            const timeDifference = (textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime);
            const charactersSelected = nodeSelectedTextLength(getElement());
            // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
            // then this isn't a press event.
            // TODO: This should measure glyphs instead of characters.
            if (charactersSelected > 1 || ((timeDifference ?? 0) > 250 && charactersSelected >= 1)) {
                e.preventDefault();
                return;
            }
            let active = getActive(); // We query if we're active *after* calling setState because we count a press iff we're now at 0.
            if (active <= 0) {
                handlePress(e);
                forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
            }
        });
        const handlePress = useStableCallback((e) => {
            if (onClickSync) {
                // Note: The element is focused here because of iOS Safari.
                //
                // It's always iOS Safari.
                //
                // iOS Safari (tested on 12) downright refuses to allow 
                // elements to be manually focused UNLESS it happens within
                // an event handler like this.  It also doesn't focus
                // buttons by default when clicked, tapped, etc.
                //
                // If it becomes problematic that button-likes explicitly become
                // focused when they are pressed, then an alternative solution for
                // the question of "how do menu buttons keep their menus open"
                // and other focus-related nonsense needs to be figured out.
                //
                // For iOS Safari.
                //
                const element = getElement();
                if (element && "focus" in element)
                    focusSelf(element);
                //(element as EventTarget as HTMLElement | null)?.focus();
                // Whatever the browser was going to do with this event,
                // forget it. We're turning it into a "press" event.
                e.preventDefault();
                // Also stop anyone else from listening to this event,
                // since we're explicitly handling it.
                // (Notably, this allows labels to wrap inputs, with them
                // both having press event handlers, without double-firing)
                e.stopPropagation();
                // Haptic feedback for this press event
                try {
                    // The default implementation doesn't throw,
                    // but we should guard against user implementations that could.
                    pulse();
                }
                finally {
                    // Actually call our handler.
                    onClickSync(e);
                }
            }
        });
        const onMouseDown = useStableCallback((e) => {
            if (onClickSync && !excludes("click", exclude)) {
                // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
                // but also don't prevent the user from selecting that text manually if they really want to
                // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
                if (e.detail > 1) {
                    e.preventDefault();
                }
                if (e.button === 0) {
                    onActiveStart(e);
                }
            }
        });
        const onMouseUp = useStableCallback((e) => {
            if (onClickSync && !excludes("click", exclude)) {
                if (e.button === 0 && getActive() > 0) {
                    onActiveStop(e);
                }
            }
        });
        const onMouseLeave = useStableCallback(() => {
            if (onClickSync && !excludes("click", exclude)) {
                setActive(0);
            }
        });
        const onKeyDown = useStableCallback((e) => {
            if (onClickSync) {
                if (e.key == " " && !excludes("space", exclude)) {
                    // We don't actually activate it on a space keydown
                    // but we do preventDefault to stop the page from scrolling.
                    onActiveStart(e);
                    e.preventDefault();
                }
                if (e.key == "Enter" && !excludes("enter", exclude)) {
                    e.preventDefault();
                    onActiveStart(e);
                    onActiveStop(e);
                }
            }
        });
        const onKeyUp = useStableCallback((e) => {
            if (onClickSync && e.key == " " && !excludes("space", exclude))
                onActiveStop(e);
        });
        const onClick = useStableCallback((e) => {
            if (onClickSync) {
                e.preventDefault();
                if (e.detail > 1) {
                    e.stopImmediatePropagation();
                    e.stopPropagation();
                }
            }
        });
        const onFocusOut = useStableCallback((e) => {
            setActive(0);
        });
        const propsStable2 = A({
            onKeyDown,
            onKeyUp,
            onMouseDown,
            onMouseUp,
            onMouseLeave,
            onClick,
            onfocusout: onFocusOut
        });
        return {
            pressReturn: {
                propsStable: propsStable2.current,
                propsUnstable: {
                    style: (textSelectedDuringActivationStartTime != null) ? { cursor: "text" } : undefined,
                    ...{ "data-pseudo-active": pseudoActive ? "true" : undefined }
                },
            }
        };
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */
    function nodeSelectedTextLength(element) {
        if (element && element instanceof Node) {
            const selection = window.getSelection();
            for (let i = 0; i < (selection?.rangeCount ?? 0); ++i) {
                const range = selection.getRangeAt(i);
                if (element.contains(range.endContainer) && !selection?.isCollapsed) {
                    return selection.toString().length;
                }
            }
        }
        return 0;
    }
    let pulse = (("vibrate" in navigator) && (navigator.vibrate instanceof Function)) ? (() => navigator.vibrate(10)) : (() => { });
    function excludes(target, exclude) {
        if (exclude?.[target])
            return true;
        return false;
    }

    function useSingleSelection({ singleSelectionParameters: { selectedIndex, setSelectedIndex, children, setTabbableIndex } }) {
        const { useChildrenHaveFocusChild } = useChildrenHaveFocus({
            childrenHaveFocusParameters: {
                onAllLostFocus: useStableCallback(() => {
                    //onAllLostFocus?.();
                    if (selectedIndex != null)
                        setTabbableIndex(selectedIndex, false);
                }),
                onAnyGainedFocus: null
            }
        });
        const stableOnChange = useStableCallback(setSelectedIndex);
        const { changeIndex: changeSelectedIndex, getCurrentIndex: getSelectedIndex } = useChildrenFlag({
            children: children,
            initialIndex: selectedIndex,
            key: "selected",
            closestFit: false
        });
        _(() => {
            changeSelectedIndex(selectedIndex);
        }, [selectedIndex]);
        return {
            singleSelectionReturn: {
                getSelectedIndex,
                changeSelectedIndex
            },
            useSingleSelectionChild: q$1((args) => {
                const { managedChildParameters: { flags, index }, refElementReturn, singleSelectionChildParameters: { selectionMode, unselectable, ariaPropName, focusSelf }, } = args;
                const { getElement } = refElementReturn;
                const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
                const selectedRef = A({ get: getIsSelected, set: setIsSelected, isValid: useStableCallback(() => !unselectable) });
                const { hasCurrentFocusParameters: { onCurrentFocusedInnerChanged: olfic2 }, refElementParameters: { onElementChange } } = useChildrenHaveFocusChild({});
                const getIndex = useStableGetter(index);
                const { pressReturn } = usePress({
                    refElementReturn,
                    pressParameters: {
                        onClickSync: unselectable ? null : ((e) => { stableOnChange(getIndex(), e); }),
                        exclude: {},
                        focusSelf,
                    },
                });
                return {
                    singleSelectionChildReturn: {
                        selected: isSelected,
                        getSelected: getIsSelected,
                        propsUnstable: { [ariaPropName]: (isSelected ?? false).toString() }
                    },
                    pressReturn,
                    flags: { ...flags, selected: selectedRef.current },
                    hasCurrentFocusParameters: {
                        onCurrentFocusedInnerChanged: useStableCallback((focused, prev) => {
                            olfic2?.(focused, prev);
                            if (selectionMode == 'focus' && focused) {
                                debugger;
                                stableOnChange(getIndex(), { target: getElement(), currentTarget: getElement() });
                            }
                        }),
                    },
                    refElementParameters: {
                        onElementChange
                    }
                };
            }, []),
        };
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Built-in value references. */
    var Buffer = moduleExports$1 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$1;

      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useRearrangeableChildren({ rearrangeableChildrenParameters: { getIndex } }) {
        // These are used to keep track of a mapping between unsorted index <---> sorted index.
        // These are needed for navigation with the arrow keys.
        const mangleMap = A(new Map());
        const demangleMap = A(new Map());
        const indexMangler = q$1((n) => (mangleMap.current.get(n) ?? n), []);
        const indexDemangler = q$1((n) => (demangleMap.current.get(n) ?? n), []);
        // The sort function needs to be able to update whoever has all the sortable children.
        // Because that might not be the consumer of *this* hook directly (e.g. a table uses
        // this hook, but it's tbody that actually needs updating), we need to remotely
        // get and set a forceUpdate function.
        //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
        const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
        const rearrange = q$1((sortedRows) => {
            // Update our sorted <--> unsorted indices map 
            // and rerender the whole table, basically
            for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
                const indexAsUnsorted = sortedRows[indexAsSorted].index;
                mangleMap.current.set(indexAsUnsorted, indexAsSorted);
                demangleMap.current.set(indexAsSorted, indexAsUnsorted);
            }
            getForceUpdate()?.();
        }, []);
        const useRearrangeableProps = q$1(({ children, ...props }) => {
            console.assert(Array.isArray(children));
            const forceUpdate = useForceUpdate();
            _(() => { setForceUpdate(_prev => forceUpdate); }, [forceUpdate]);
            return (useMergedProps({
                children: children
                    .slice()
                    .map(child => ({ child, mangledIndex: indexMangler(getIndex(child.props)), demangledIndex: getIndex(child.props) }))
                    .sort((lhs, rhs) => { return lhs.mangledIndex - rhs.mangledIndex; })
                    .map(({ child, mangledIndex, demangledIndex }) => {
                    return h$1(child.type, { ...child.props, key: demangledIndex, "data-mangled-index": mangledIndex, "data-unmangled-index": demangledIndex });
                })
            }, props));
        }, []);
        return { useRearrangeableProps, rearrangeableChildrenReturn: { indexMangler, indexDemangler, mangleMap, demangleMap, rearrange } };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useSortableChildren({ rearrangeableChildrenParameters: { getIndex }, sortableChildrenParameters: { compare: userCompare } }) {
        const compare = (userCompare ?? defaultCompare);
        const { useRearrangeableProps: useSortableProps, ...rearrangeableChildrenReturnType } = useRearrangeableChildren({ rearrangeableChildrenParameters: { getIndex } });
        const { rearrangeableChildrenReturn: { rearrange } } = rearrangeableChildrenReturnType;
        // The actual sort function.
        const sort = q$1((managedRows, direction) => {
            const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
                const lhsValue = lhsRow;
                const rhsValue = rhsRow;
                const result = compare(lhsValue, rhsValue);
                if (direction[0] == "d")
                    return -result;
                return result;
            });
            return rearrange(sortedRows);
        }, [ /* Must remain stable */]);
        const shuffle$1 = q$1((managedRows) => {
            const shuffledRows = shuffle(managedRows.arraySlice());
            return rearrange(shuffledRows);
        }, [ /* Must remain stable */]);
        return {
            useSortableProps,
            sortableChildrenReturn: { sort, shuffle: shuffle$1 },
            rearrangeableChildrenReturn: rearrangeableChildrenReturnType.rearrangeableChildrenReturn
        };
    }
    function defaultCompare(lhs, rhs) {
        return compare1(lhs, rhs);
        function compare3(lhs, rhs) {
            // Coerce strings to numbers if they seem to stay the same when serialized
            if (`${+lhs}` === lhs)
                lhs = +lhs;
            if (`${+rhs}` === rhs)
                rhs = +rhs;
            // At this point, if either argument is a string, turn the other one into one too
            if (typeof lhs === "string")
                rhs = `${rhs}`;
            if (typeof rhs === "string")
                lhs = `${lhs}`;
            console.assert(typeof lhs === typeof rhs);
            if (typeof lhs === "string")
                return lhs.localeCompare(rhs);
            if (typeof lhs === "number")
                return +lhs - +rhs;
            return 0;
        }
        function compare2(lhs, rhs) {
            if (typeof lhs === "boolean" || lhs instanceof Date)
                lhs = +lhs;
            if (typeof rhs === "boolean" || rhs instanceof Date)
                rhs = +rhs;
            return compare3(lhs, rhs);
        }
        function compare1(lhs, rhs) {
            if (lhs == null && rhs == null) {
                // They're both null
                return 0;
            }
            else if (lhs == null || rhs == null) {
                // One of the two is null -- easy case
                return lhs != null ? 1 : -1;
            }
            return compare2(lhs, rhs);
        }
    }

    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */
    function useListNavigationSingleSelection({ singleSelectionParameters: { selectedIndex, setSelectedIndex }, listNavigationParameters, managedChildrenParameters, rovingTabIndexParameters: { ...rovingTabIndexParameters }, linearNavigationParameters, typeaheadNavigationParameters }) {
        const { listNavigationReturn, managedChildrenReturn, linearNavigationReturn, rovingTabIndexReturn, typeaheadNavigationReturn, useListNavigationChild } = useListNavigation({
            listNavigationParameters,
            managedChildrenParameters,
            rovingTabIndexParameters: {
                initialIndex: (selectedIndex ?? undefined),
                ...rovingTabIndexParameters
            },
            linearNavigationParameters,
            typeaheadNavigationParameters,
        });
        const { children } = managedChildrenReturn;
        const { setTabbableIndex } = rovingTabIndexReturn;
        //    const getSelectionMode = useStableGetter(selectionMode);
        const { useSingleSelectionChild, singleSelectionReturn } = useSingleSelection({
            singleSelectionParameters: {
                children: children,
                selectedIndex,
                setSelectedIndex,
                setTabbableIndex
            },
            //childrenHaveFocusP: { onAllLostFocus, onAnyGainedFocus }
        });
        return {
            useListNavigationSingleSelectionChild: q$1((args) => {
                let { listNavigationChildParameters, managedChildParameters: { index, flags }, rovingTabIndexChildParameters, singleSelectionChildParameters: { unselectable, ...ss }, refElementReturn, subInfo } = args;
                let { hidden, focusSelf } = rovingTabIndexChildParameters;
                unselectable ||= (hidden ?? false);
                const { flags: ssflags, singleSelectionChildReturn, hasCurrentFocusParameters: { onCurrentFocusedInnerChanged: ofic1, onCurrentFocusedInnerChanged: ofic3 }, refElementParameters: { onElementChange }, 
                //               onElementChange,
                //             onFocusedInnerChanged: ofic1,
                //           onLastFocusedInnerChanged,
                pressReturn, } = useSingleSelectionChild({
                    refElementReturn,
                    managedChildParameters: { index, flags },
                    singleSelectionChildParameters: { ...ss, focusSelf, unselectable }
                });
                const { hasCurrentFocusParameters: { onCurrentFocusedInnerChanged: ofic2 }, rovingTabIndexChildReturn } = useListNavigationChild({
                    refElementReturn,
                    listNavigationChildParameters,
                    rovingTabIndexChildParameters,
                    managedChildParameters: {
                        index,
                        flags: {
                            ...ssflags,
                            ...flags
                        }
                    },
                    subInfo,
                });
                const onCurrentFocusedInnerChanged = useStableCallback((f, p) => {
                    ofic1?.(f, p);
                    ofic2?.(f, p);
                    ofic3?.(f, p);
                });
                return {
                    pressReturn,
                    hasCurrentFocusParameters: { onCurrentFocusedInnerChanged },
                    refElementParameters: { onElementChange },
                    rovingTabIndexChildReturn,
                    singleSelectionChildReturn,
                };
            }, []),
            listNavigationReturn,
            linearNavigationReturn,
            managedChildrenReturn,
            rovingTabIndexReturn,
            singleSelectionReturn,
            typeaheadNavigationReturn
        };
    }
    function useSortableListNavigationSingleSelection({ linearNavigationParameters, listNavigationParameters, managedChildrenParameters, rovingTabIndexParameters, singleSelectionParameters, typeaheadNavigationParameters }) {
        const { useSortableProps, rearrangeableChildrenReturn, sortableChildrenReturn } = useSortableChildren({
            rearrangeableChildrenParameters: { getIndex: q$1((row) => row.index, []) },
            sortableChildrenParameters: {
                compare: q$1((lhs, rhs) => { return lhs.index - rhs.index; }, []),
            }
        });
        const { indexDemangler, indexMangler } = rearrangeableChildrenReturn;
        const { useListNavigationSingleSelectionChild, listNavigationReturn, managedChildrenReturn, rovingTabIndexReturn, singleSelectionReturn, typeaheadNavigationReturn, linearNavigationReturn, } = useListNavigationSingleSelection({
            linearNavigationParameters: linearNavigationParameters,
            listNavigationParameters: { indexDemangler, indexMangler, ...listNavigationParameters },
            managedChildrenParameters: managedChildrenParameters,
            rovingTabIndexParameters: rovingTabIndexParameters,
            typeaheadNavigationParameters: typeaheadNavigationParameters,
            singleSelectionParameters: singleSelectionParameters
        });
        const useSortableListNavigationSingleSelectionProps = useSortableProps;
        const useSortableListNavigationSingleSelectionChild = (p) => {
            return useListNavigationSingleSelectionChild(p);
        };
        return ({
            useSortableListNavigationSingleSelectionChild,
            useProps: useSortableListNavigationSingleSelectionProps,
            listNavigationReturn,
            managedChildrenReturn,
            linearNavigationReturn,
            rearrangeableChildrenReturn,
            rovingTabIndexReturn,
            sortableChildrenReturn,
            typeaheadNavigationReturn,
            singleSelectionReturn
        });
    }

    const DemoUseInterval = () => {
        const [interval, setInterval] = y(1000);
        const [fireCount, setFireCount] = y(0);
        useInterval({ interval, callback: () => setFireCount(i => ++i) });
        return (o$1("div", { class: "demo", children: [o$1("label", { children: ["Interval duration: ", o$1("input", { type: "number", value: interval, onInput: e => setInterval(e.currentTarget.valueAsNumber) })] }), o$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const ListNavigationSingleSelectionChildContext = B$2(null);
    const DemoUseRovingTabIndex = w(() => {
        const [selectionMode, setSelectionMode] = useState("activation");
        const [count, setCount] = useState(10);
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [tabbableIndex, setLocalTabbableIndex] = useState(0);
        const { managedChildrenReturn: { children }, linearNavigationReturn: { propsStable: p1 }, listNavigationReturn: {}, rearrangeableChildrenReturn: {}, singleSelectionReturn: {}, useSortableListNavigationSingleSelectionChild, useProps, rovingTabIndexReturn: { setTabbableIndex }, typeaheadNavigationReturn: { currentTypeahead, propsStable: p2 }, sortableChildrenReturn: { shuffle }, } = useSortableListNavigationSingleSelection({
            linearNavigationParameters: {},
            listNavigationParameters: {},
            managedChildrenParameters: {},
            rovingTabIndexParameters: { onTabbableIndexChange: q$1((index) => { if (index != null)
                    setLocalTabbableIndex(index); }, []) },
            typeaheadNavigationParameters: {},
            singleSelectionParameters: { selectedIndex, setSelectedIndex: (i, _e) => setSelectedIndex(i) },
            //childrenHaveFocusP: {  }
        });
        const props = useMergedProps(p1, p2);
        return (o$1("div", { className: "demo", children: [o$1("h2", { children: "Keyboard & List Navigation" }), o$1("h3", { children: o$1("code", { children: "useRovingTabIndex" }) }), o$1("p", { children: ["Native HTML elements offer fantastic keyboard accessability, but cover a relatively limited number of use cases. There is no native HTML tree element, for example, that allows keyboard navigation of its items, nor is it possible to combine the keyboard navigation behavior of a ", o$1("code", { children: "<select>" }), " menu with the menu in a drawer component."] }), o$1("p", { children: ["When coming across a List or a Menu or a RadioGroup or a ToggleButtonGroup or any other \"one component made up of child components\", the usual expected behavior, at least natively, is that tabbing into the component is one action, and tabbing out is another.  Navigating ", o$1("em", { children: "within" }), " the component is done with the arrow keys or other methods."] }), o$1("p", { children: ["This is important both for accessability, but also just for general usability.  When tabbing back and forth, the ability to skip a long list without needing to trudge through ", o$1("em", { children: "every one" }), " of its child elements is extremely important."] }), o$1("p", { children: [o$1("code", { children: "useListNavigation" }), " wraps up the functionality of a few hooks (", o$1("code", { children: "useRovingTabIndex" }), ", ", o$1("code", { children: "useLinearNavigation" }), ", ", o$1("code", { children: "useTypeaheadNavigation" }), ") to allow for ARIA-compliant navigation of lists and other similar components.  For more advanced use cases, you can use the other hooks individually."] }), o$1("p", { children: [o$1("code", { children: "useListNavigation" }), " (and ", o$1("code", { children: "useRovingTabIndex" }), ") internally use ", o$1("code", { children: "useChildManager" }), ", which is how the child elements and the parent communicate with each other. This means there are virtually no restrictions on how the DOM is set up as long as you can provide the children with the ", o$1("code", { children: "useListNavigationChild" }), " hook that's returned, usually with a simple ", o$1("code", { children: "Context" }), ". If the child element itself has a focusable element, like a button, it can also be wired up to disable itself Feel free to nest them too, as long as you are aware of your ", o$1("code", { children: "Context" }), " management (i.e. remember that you need to create a new ", o$1("code", { children: "Context" }), " for each use case)."] }), o$1("label", { children: ["# of items", o$1("input", { type: "number", value: count, min: 0, onInput: e => { e.preventDefault(); setCount(e.currentTarget.valueAsNumber); } })] }), o$1("button", { onClick: () => shuffle(children), children: "Shuffle" }), o$1("label", { children: ["Tabbable index: ", o$1("input", { type: "number", value: tabbableIndex ?? undefined, onInput: e => { e.preventDefault(); setTabbableIndex(e.currentTarget.valueAsNumber, false); } })] }), o$1("label", { children: ["Selected index: ", o$1("input", { type: "number", value: selectedIndex ?? undefined, onInput: e => { e.preventDefault(); setSelectedIndex(e.currentTarget.valueAsNumber); } })] }), o$1("label", { children: ["Selection mode:", o$1("label", { children: [o$1("input", { name: "rti-demo-selection-mode", type: "radio", checked: selectionMode == 'focus', onInput: e => { e.preventDefault(); setSelectionMode("focus"); } }), " On focus"] }), o$1("label", { children: [o$1("input", { name: "rti-demo-selection-mode", type: "radio", checked: selectionMode == 'activation', onInput: e => { e.preventDefault(); setSelectionMode("activation"); } }), " On activation (click, tap, Enter, Space, etc.)"] })] }), o$1(SelectionModeContext.Provider, { value: selectionMode, children: o$1(ListNavigationSingleSelectionChildContext.Provider, { value: useSortableListNavigationSingleSelectionChild, children: o$1("ul", { ...(useProps(useMergedProps(props, {
                                children: Array.from((function* () {
                                    for (let i = 0; i < count; ++i) {
                                        yield o$1(DemoUseRovingTabIndexChild, { index: i }, i);
                                    }
                                })())
                            }))) }) }) }), currentTypeahead && o$1("div", { children: ["Typeahead: ", currentTypeahead] })] }));
    });
    const SelectionModeContext = B$2("focus");
    const DemoUseRovingTabIndexChild = w((({ index }) => {
        const selectionMode = x(SelectionModeContext);
        const hidden = (index == 7);
        const [randomWord] = useState(() => RandomWords$1[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useListNavigationSingleSelectionChild = x(ListNavigationSingleSelectionChildContext);
        const text = `${randomWord} This is item #${index}${hidden ? " (hidden)" : ""}`;
        const focusSelf = q$1((e) => { e.focus(); }, []);
        const oec = useStableCallback((a, b) => onElementChange(a, b));
        //const ofic = useStableCallback<NonNullable<typeof onFocusedInnerChanged>>((a, b) => onFocusedInnerChanged?.(a, b));
        //const olfic = useStableCallback<NonNullable<typeof onLastFocusedInnerChanged>>((a, b) => onLastFocusedInnerChanged?.(a, b));
        const { refElementReturn } = useRefElement({ refElementParameters: { onElementChange: oec } });
        const { getElement, propsStable: p3 } = refElementReturn;
        const { rovingTabIndexChildReturn: { tabbable, propsUnstable: p2 }, singleSelectionChildReturn: { selected, propsUnstable: p4 }, hasCurrentFocusParameters: { onCurrentFocusedInnerChanged }, refElementParameters: { onElementChange }, pressReturn: { propsStable: p5, propsUnstable: p1 }, } = useListNavigationSingleSelectionChild({
            managedChildParameters: { index, flags: {} },
            listNavigationChildParameters: { text: "" },
            refElementReturn,
            rovingTabIndexChildParameters: { focusSelf, noModifyTabIndex: false, hidden },
            singleSelectionChildParameters: { selectionMode, ariaPropName: "aria-selected", unselectable: hidden },
            subInfo: {},
        });
        const { hasCurrentFocusReturn: { propsStable: p6 } } = useHasCurrentFocus({
            refElementReturn,
            hasCurrentFocusParameters: {
                onCurrentFocusedChanged: null,
                onCurrentFocusedInnerChanged
            }
        });
        const props = useMergedProps(p1, p2, p3, p4, p5, p6);
        return (o$1("li", { ...props, children: [text, " (", tabbable ? "Tabbable" : "Not tabbable", ", ", selected ? "Selected" : "Not selected", ")", o$1("input", { ...useMergedProps(props, { type: "number" }), style: { width: "5ch" } })] }));
    }));

    const DemoUseTimeout = () => {
        const [timeout, setTimeout] = y(1000);
        const [triggerIndex, setTriggerIndex] = y("");
        const [fireCount, setFireCount] = y(0);
        useTimeout({ timeout, triggerIndex, callback: () => setFireCount(i => ++i) });
        return (o$1("div", { class: "demo", children: [o$1("label", { children: ["Timeout duration: ", o$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), o$1("label", { children: ["Refresh key: ", o$1("input", { type: "text", value: triggerIndex, onInput: e => setTriggerIndex(e.currentTarget.value) })] }), o$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const DemoUseDroppable = () => {
        const { droppedFiles, droppedStrings, filesForConsideration, stringsForConsideration, propsStable: props, dropError } = useDroppable({ effect: "copy" });
        useMergedProps({}, { ref: A(null) });
        const p = useMergedProps(props, { className: "demo droppable" });
        return (o$1("div", { ...p, children: [droppedStrings != null && o$1("div", { children: ["Data dropped: ", o$1("ul", { children: Object.entries(droppedStrings).map(([type, value]) => o$1("li", { children: [type, ": ", value] })) })] }), droppedFiles != null && o$1("div", { children: ["Files dropped: ", o$1("table", { children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Name" }), o$1("th", { children: "Size" }), o$1("th", { children: "Type" }), o$1("th", { children: "Last modified" })] }) }), o$1("tbody", { children: droppedFiles.map(f => o$1("tr", { children: [o$1("td", { children: f.name }), f.data.byteLength, o$1("td", { children: f.type }), o$1("td", { children: new Date(f.lastModified ?? 0) })] })) })] })] }), o$1("hr", {}), stringsForConsideration != null && o$1("div", { children: ["Data being considered: ", o$1("ul", { children: Array.from(stringsForConsideration).map(type => o$1("li", { children: type })) })] }), filesForConsideration != null && o$1("div", { children: ["Files being considered: ", o$1("ul", { children: filesForConsideration.map(f => o$1("li", { children: JSON.stringify(f) })) })] }), o$1("hr", {}), dropError && o$1("div", { children: dropError instanceof Error ? dropError.message : JSON.stringify(dropError) })] }));
    };
    const DemoUseDraggable = () => {
        const { propsUnstable: props } = useDraggable({ data: { "text/plain": "This is custom draggable content of type text/plain." } });
        return (o$1("div", { ...useMergedProps(props, { className: "demo" }), children: "Draggable content" }));
    };
    const DemoUseElementSizeAnimation = () => {
        const [height, setHeight] = useState(0);
        const [angle, setAngle] = useState(0);
        useAnimationFrame({
            callback: (_ms) => {
                setAngle(a => a + 0.01);
                setHeight((Math.sin(angle) + 1) / 0.5);
            }
        });
        const [elementSize, setElementSize] = useState(null);
        const { elementSizeReturn: { getSize }, refElementReturn: { propsStable } } = useElementSize({
            elementSizeParameters: { onSizeChange: setElementSize, getObserveBox: null },
            refElementParameters: { onElementChange: undefined }
        });
        return (o$1("div", { ...useMergedProps(propsStable, { ref: undefined, className: "demo", style: { height: `${(height * 100) + 100}px` } }), children: o$1("pre", { children: JSON.stringify(elementSize, null, 2) }) }));
    };
    const DemoUseFocusTrap = w(({ depth }) => {
        const [active, setActive] = useState(false);
        const { activeElementReturn: {}, focusTrap: { propsUnstable }, refElementReturn: { propsStable } } = useFocusTrap({ focusTrapParameters: { trapActive: active }, activeElementParameters: { getDocument }, refElementParameters: { onElementChange: undefined } });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        const divProps = useMergedProps(propsUnstable, propsStable, { ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return o$1("div", {});
        return (o$1("div", { className: "demo", children: [o$1("label", { children: ["Active: ", o$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), o$1("div", { ...divProps, children: o$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
    });
    const DemoUseFocusTrapChild = w(({ setActive, active }) => {
        return (o$1(p$1, { children: [o$1("button", { children: "Button 1" }), o$1("button", { children: "Button 2" }), o$1("button", { children: "Button 3" }), o$1("label", { children: ["Active: ", o$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
    });
    const DemoUseAsyncHandler1 = w(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const asyncOnClick = ((_v, _e) => new Promise((resolve, reject) => window.setTimeout(() => getShouldThrow() ? reject() : resolve(), timeout)));
        const { callCount, settleCount, hasCapture, syncHandler, pending, hasError, rejectCount, resolveCount } = useAsyncHandler({ asyncHandler: asyncOnClick, capture: () => { }, debounce: debounce == 0 ? undefined : debounce });
        const onClick = pending ? undefined : syncHandler;
        return (o$1("div", { className: "demo", children: [o$1("button", { disabled: pending && disableConsecutive, onClick: onClick, children: "Click me!" }), o$1("label", { children: ["Sleep for: ", o$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), o$1("label", { children: ["Throw an error ", o$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), o$1("label", { children: ["Disabled while pending ", o$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), o$1("label", { children: ["Debounce: ", o$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), o$1("table", { children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Field" }), o$1("th", { children: "Value" })] }) }), o$1("tbody", { children: [o$1("tr", { children: [o$1("td", { children: "callCount" }), o$1("td", { children: callCount })] }), o$1("tr", { children: [o$1("td", { children: "settleCount" }), o$1("td", { children: settleCount })] }), o$1("tr", { children: [o$1("td", { children: "resolveCount" }), o$1("td", { children: resolveCount })] }), o$1("tr", { children: [o$1("td", { children: "rejectCount" }), o$1("td", { children: rejectCount })] }), o$1("tr", { children: [o$1("td", { children: "hasError" }), o$1("td", { children: hasError.toString() })] }), o$1("tr", { children: [o$1("td", { children: "hasCapture" }), o$1("td", { children: hasCapture.toString() })] })] })] })] }));
    });
    const DemoUseAsyncHandler2 = w(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const [text, setText] = useState("");
        const onInputAsync = async (v, _e) => new Promise((resolve, reject) => window.setTimeout(() => {
            if (getShouldThrow()) {
                reject();
            }
            else {
                setText(v);
                resolve();
            }
        }, timeout));
        const { callCount, settleCount, hasCapture, syncHandler, currentCapture, pending, hasError, rejectCount, resolveCount } = useAsyncHandler({ asyncHandler: onInputAsync, capture: (e) => { e.preventDefault(); return e.currentTarget.value; }, debounce: debounce == 0 ? undefined : debounce });
        return (o$1("div", { className: "demo", children: [o$1("label", { children: ["Demo text: ", o$1("input", { value: hasCapture ? currentCapture : text, disabled: pending && disableConsecutive, onInput: syncHandler })] }), o$1("hr", {}), o$1("label", { children: ["Sleep for: ", o$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), o$1("label", { children: ["Throw an error ", o$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), o$1("label", { children: ["Disabled while pending ", o$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), o$1("label", { children: ["Debounce: ", o$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), o$1("table", { children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Field" }), o$1("th", { children: "Value" })] }) }), o$1("tbody", { children: [o$1("tr", { children: [o$1("td", { children: "callCount" }), o$1("td", { children: callCount })] }), o$1("tr", { children: [o$1("td", { children: "settleCount" }), o$1("td", { children: settleCount })] }), o$1("tr", { children: [o$1("td", { children: "resolveCount" }), o$1("td", { children: resolveCount })] }), o$1("tr", { children: [o$1("td", { children: "rejectCount" }), o$1("td", { children: rejectCount })] }), o$1("tr", { children: [o$1("td", { children: "hasError" }), o$1("td", { children: hasError.toString() })] }), o$1("tr", { children: [o$1("td", { children: "currentCapture" }), o$1("td", { children: currentCapture })] }), o$1("tr", { children: [o$1("td", { children: "\"Saved\" input" }), o$1("td", { children: text })] })] })] })] }));
    });
    function getDocument() {
        return window.document;
    }
    const DemoFocus = w(() => {
        const [lastActiveElement, setLastActiveElement] = useState(null);
        const [activeElement, setActiveElement] = useState(null);
        const [windowFocused, setWindowFocused] = useState(false);
        const [focused, setFocused] = useState(false);
        const [focusedInner, setFocusedInner] = useState(false);
        const [lastFocused, setLastFocused] = useState(false);
        const [lastFocusedInner, setLastFocusedInner] = useState(false);
        const { refElementReturn } = useRefElement({ refElementParameters: { onElementChange: undefined } });
        const { propsStable: p2 } = refElementReturn;
        const { hasCurrentFocusReturn: { propsStable: p1 } } = useHasCurrentFocus({
            refElementReturn,
            hasCurrentFocusParameters: {
                onCurrentFocusedChanged: setFocused,
                onCurrentFocusedInnerChanged: setFocusedInner,
            }
        });
        useHasLastFocus({
            refElementReturn,
            activeElementParameters: {
                getDocument,
                onActiveElementChange: setActiveElement,
                onLastActiveElementChange: setLastActiveElement,
                onWindowFocusedChange: setWindowFocused
            },
            hasLastFocusParameters: {
                onLastFocusedChanged: setLastFocused,
                onLastFocusedInnerChanged: setLastFocusedInner,
            }
        });
        return (o$1("div", { class: "demo", children: [o$1("h2", { children: "useHasFocus" }), o$1("div", { ...(useMergedProps(p2, p1, { style: { border: "1px solid black" }, tabIndex: 0 })), children: ["Outer ", o$1("div", { tabIndex: 0, style: { border: "1px solid black" }, children: "Inner element" })] }), o$1("div", { children: o$1("ul", { children: [o$1("li", { children: ["Strictly focused: ", focused.toString(), ", ", lastFocused.toString()] }), o$1("li", { children: ["Inner focused: ", focusedInner.toString(), ", ", lastFocusedInner.toString()] }), o$1("li", { children: ["Window focused: ", windowFocused.toString()] }), o$1("li", { children: ["activeElement: ", activeElement?.textContent] }), o$1("li", { children: ["lastActiveElement: ", lastActiveElement?.textContent] })] }) })] }));
    });
    const GridRowContext = B$2(null);
    const GridCellContext = B$2(null);
    const DemoUseGrid = w(() => {
        //const [, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        //const { props } = useHasFocus<HTMLTableSectionElement>({ onLastFocusedInnerChanged: setLastFocusedInner, getDocument });
        const { gridNavigationReturn: { currentColumn }, linearNavigationReturn: { propsStable: p2 }, listNavigationReturn: {}, managedChildrenReturn: {}, rovingTabIndexReturn: {}, typeaheadNavigationReturn: { propsStable: p1 }, useGridNavigationRow } = useGridNavigation({
            rovingTabIndexParameters: {},
            linearNavigationParameters: {},
            listNavigationParameters: {},
            typeaheadNavigationParameters: {},
            managedChildrenParameters: {},
            gridNavigationParameters: {}
        });
        return (o$1("div", { class: "demo", children: [o$1("div", { children: ["Current column: ", currentColumn] }), o$1("table", { ...{ border: "2" }, style: { whiteSpace: "nowrap" }, children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Row is tabbable?" }), o$1("th", { children: "Column 1" }), o$1("th", { children: "Column 2" })] }) }), o$1("tbody", { ...useMergedProps(p1, p2), children: o$1(GridRowContext.Provider, { value: useGridNavigationRow, children: Array.from((function* () {
                                    for (let i = 0; i < 10; ++i) {
                                        yield o$1(DemoUseGridRow, { index: i }, i);
                                    }
                                })()) }) })] })] }));
    });
    const DemoUseGridRow = w((({ index }) => {
        useState(() => RandomWords[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useGridRow = x(GridRowContext);
        const { refElementReturn } = useRefElement({ refElementParameters: {} });
        const { propsStable: p4 } = refElementReturn;
        const { useGridNavigationCell, asParentOfCells: { linearNavigationReturn: { propsStable: p2 }, listNavigationReturn: {}, managedChildrenReturn: {}, rovingTabIndexReturn: {}, typeaheadNavigationReturn: { propsStable: p1, } }, asChildRow: { hasCurrentFocusParameters, rovingTabIndexChildReturn: { tabbable, propsUnstable: p3 } }, } = useGridRow({
            asChildRowOfSection: {
                refElementReturn,
                managedChildParameters: { index, flags: {} },
                listNavigationChildParameters: { text: "" },
                rovingTabIndexChildParameters: { hidden: index == 3, noModifyTabIndex: false },
                subInfo: {},
            },
            asParentRowOfCells: {
                linearNavigationParameters: {},
                listNavigationParameters: {},
                rovingTabIndexParameters: {},
                typeaheadNavigationParameters: {},
                managedChildrenParameters: {}
            },
        });
        useHasCurrentFocus({
            refElementReturn,
            hasCurrentFocusParameters: {
                onCurrentFocusedChanged: null,
                ...hasCurrentFocusParameters,
            }
        });
        const props = useMergedProps(useMergedProps(useMergedProps(p1, p2), p3), p4);
        return (o$1("tr", { ...props, children: o$1(GridCellContext.Provider, { value: useGridNavigationCell, children: Array.from((function* () {
                    for (let i = 0; i < 3; ++i) {
                        yield o$1(DemoUseGridCell, { index: i, row: index, rowIsTabbable: tabbable }, i);
                    }
                })()) }) }));
    }));
    const DemoUseGridCell = (({ index, row, rowIsTabbable }) => {
        if (row >= 6 && row % 2 == 0 && index > 1)
            return null;
        let hiddenText = (row === 3) ? " (row hidden)" : "";
        const useGridCell = x(GridCellContext);
        const { refElementReturn } = useRefElement({ refElementParameters: {} });
        const { propsStable: p1 } = refElementReturn;
        const { hasCurrentFocusParameters, gridNavigationReturn: {}, rovingTabIndexChildReturn: { tabbable: cellIsTabbable, propsUnstable: p2 }, } = useGridCell({
            //hasFocusParameters: { onFocusedChanged: null, onFocusedInnerChanged: null, onLastFocusedChanged: null, onLastFocusedInnerChanged: null },
            //activeElementParameters: { getDocument },
            listNavigationChildParameters: { text: "" },
            // refElementParameters: {},
            refElementReturn,
            rovingTabIndexChildParameters: { noModifyTabIndex: false, focusSelf: e => e.focus(), hidden: false },
            managedChildParameters: { index, flags: {} },
            subInfo: {},
        });
        const { hasCurrentFocusReturn: { propsStable: p3 } } = useHasCurrentFocus({
            refElementReturn,
            hasCurrentFocusParameters: { onCurrentFocusedChanged: null, ...hasCurrentFocusParameters }
        });
        const props = useMergedProps(p1, p2, p3);
        const t = (cellIsTabbable ? "(Tabbable)" : "(Not tabbable)");
        if (index === 0)
            return o$1("td", { ...props, children: rowIsTabbable.toString() });
        else {
            if (row < 6 || row % 2 != 0) {
                if (index === 1)
                    return o$1("td", { ...props, children: ["Grid cell #", index + 1, " ", t, hiddenText] });
                else
                    return o$1("td", { children: o$1("label", { children: [o$1("input", { ...props, type: "checkbox" }), " Test input ", t, hiddenText] }) });
            }
            else {
                if (index === 1)
                    return o$1("td", { ...props, colSpan: 2, children: ["Grid cell #", index + 1, ", span 2 ", t, hiddenText] });
                else
                    return null;
            }
        }
    });
    const Component = () => {
        return o$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [o$1(DemoFocus, {}), o$1("hr", {}), o$1(DemoUseGrid, {}), o$1("hr", {}), o$1(DemoUseTimeout, {}), o$1("hr", {}), o$1(DemoUseInterval, {}), o$1("hr", {}), o$1(DemoUseRovingTabIndex, {}), o$1("hr", {}), o$1(DemoUseFocusTrap, {}), o$1("hr", {}), o$1(DemoUseAsyncHandler1, {}), o$1("hr", {}), o$1(DemoUseAsyncHandler2, {}), o$1("hr", {}), o$1(DemoUseDroppable, {}), o$1("hr", {}), o$1(DemoUseDraggable, {}), o$1("hr", {}), o$1(DemoUseElementSizeAnimation, {}), o$1("hr", {}), o$1("input", {})] });
    };
    requestAnimationFrame(() => {
        P(o$1(Component, {}), document.getElementById("root"));
    });

    exports.DemoUseGrid = DemoUseGrid;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL0NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcG9ydGFscy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9zcmMvdXNlLXBhc3NpdmUtc3RhdGUudHN4IiwiLi4vc3JjL3VzZS1hY3RpdmUtZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL3NyYy91c2Utc3RhYmxlLWdldHRlci50c3giLCIuLi9zcmMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9zcmMvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25vdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUcmltLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVib3VuY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Rocm90dGxlLmpzIiwiLi4vc3JjL3VzZS1zdGF0ZS50c3giLCIuLi9zcmMvdXNlLWFzeW5jLnRzeCIsIi4uL3NyYy91c2UtYXN5bmMtaGFuZGxlci50c3giLCIuLi9zcmMvdXNlLWNoaWxkLW1hbmFnZXIudHN4IiwiLi4vc3JjL3VzZS1jaGlsZHJlbi1oYXZlLWZvY3VzLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vc3JjL3VzZS1kb2N1bWVudC1jbGFzcy50c3giLCIuLi9zcmMvdXNlLWRyYWdnYWJsZS50c3giLCIuLi9zcmMvdXNlLWRyb3BwYWJsZS50c3giLCIuLi9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL3NyYy91c2UtZWxlbWVudC1zaXplLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4IiwiLi4vc3JjL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1zdHlsZXMudHN4IiwiLi4vc3JjL3VzZS1tZXJnZWQtcHJvcHMudHN4IiwiLi4vc3JjL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL3NyYy91c2UtYmxvY2tpbmctZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWZvY3VzLXRyYXAudHN4IiwiLi4vc3JjL3VzZS1mb3JjZS11cGRhdGUudHN4IiwiLi4vc3JjL3VzZS10aW1lb3V0LnRzeCIsIi4uL3NyYy91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLXJvdmluZy10YWJpbmRleC50c3giLCIuLi9zcmMvdXNlLWxpc3QtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLWdyaWQtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLWhhcy1jdXJyZW50LWZvY3VzLnRzeCIsIi4uL3NyYy91c2UtaGFzLWxhc3QtZm9jdXMudHN4IiwiLi4vc3JjL3VzZS1pbnRlcnZhbC50c3giLCIuLi9zcmMvdXNlLXByZXNzLnRzeCIsIi4uL3NyYy91c2Utc2luZ2xlLXNlbGVjdGlvbi50c3giLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jb3B5QXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlUmFuZG9tLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc2h1ZmZsZVNlbGYuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheU1hcC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VWYWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVGltZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zdHViRmFsc2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQnVmZmVyLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNMZW5ndGguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlSXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVVuYXJ5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbm9kZVV0aWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TGlrZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc1Byb3RvdHlwZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX292ZXJBcmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19uYXRpdmVLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzRnVuY3Rpb24uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXlMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9rZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy92YWx1ZXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc2h1ZmZsZS5qcyIsIi4uL3NyYy91c2Utc29ydGFibGUtY2hpbGRyZW4udHN4IiwiLi4vc3JjL3VzZS1saXN0LW5hdmlnYXRpb24tZGVyaXZlZC50c3giLCJkZW1vcy91c2UtaW50ZXJ2YWwudHN4IiwiZGVtb3MvdXNlLXJvdmluZy10YWItaW5kZXgudHN4IiwiZGVtb3MvdXNlLXRpbWVvdXQudHN4IiwiaW5kZXgudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVNUFRZX0FSUiB9IGZyb20gXCIuL2NvbnN0YW50c1wiO1xuXG4vKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdC8vIEB0cy1pZ25vcmUgV2UgY2hhbmdlIHRoZSB0eXBlIG9mIGBvYmpgIHRvIGJlIGBPICYgUGBcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBjaGlsZCBub2RlIGZyb20gaXRzIHBhcmVudCBpZiBhdHRhY2hlZC4gVGhpcyBpcyBhIHdvcmthcm91bmQgZm9yXG4gKiBJRTExIHdoaWNoIGRvZXNuJ3Qgc3VwcG9ydCBgRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlKClgLiBVc2luZyB0aGlzIGZ1bmN0aW9uXG4gKiBpcyBzbWFsbGVyIHRoYW4gaW5jbHVkaW5nIGEgZGVkaWNhdGVkIHBvbHlmaWxsLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHJlbW92ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTm9kZShub2RlKSB7XG5cdGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRpZiAocGFyZW50Tm9kZSkgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbn1cblxuZXhwb3J0IGNvbnN0IHNsaWNlID0gRU1QVFlfQVJSLnNsaWNlO1xuIiwiaW1wb3J0IHsgX2NhdGNoRXJyb3IgfSBmcm9tICcuL2RpZmYvY2F0Y2gtZXJyb3InO1xuXG4vKipcbiAqIFRoZSBgb3B0aW9uYCBvYmplY3QgY2FuIHBvdGVudGlhbGx5IGNvbnRhaW4gY2FsbGJhY2sgZnVuY3Rpb25zXG4gKiB0aGF0IGFyZSBjYWxsZWQgZHVyaW5nIHZhcmlvdXMgc3RhZ2VzIG9mIG91ciByZW5kZXJlci4gVGhpcyBpcyB0aGVcbiAqIGZvdW5kYXRpb24gb24gd2hpY2ggYWxsIG91ciBhZGRvbnMgbGlrZSBgcHJlYWN0L2RlYnVnYCwgYHByZWFjdC9jb21wYXRgLFxuICogYW5kIGBwcmVhY3QvaG9va3NgIGFyZSBiYXNlZCBvbi4gU2VlIHRoZSBgT3B0aW9uc2AgdHlwZSBpbiBgaW50ZXJuYWwuZC50c2BcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgb3B0aW9uIGhvb2tzIChtb3N0IGVkaXRvcnMvSURFcyBhbGxvdyB5b3UgdG9cbiAqIGN0cmwrY2xpY2sgb3IgY21kK2NsaWNrIG9uIG1hYyB0aGUgdHlwZSBkZWZpbml0aW9uIGJlbG93KS5cbiAqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5PcHRpb25zfVxuICovXG5jb25zdCBvcHRpb25zID0ge1xuXHRfY2F0Y2hFcnJvclxufTtcblxuZXhwb3J0IGRlZmF1bHQgb3B0aW9ucztcbiIsImltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBDcmVhdGUgYW4gdmlydHVhbCBub2RlICh1c2VkIGZvciBKU1gpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogY29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IFtwcm9wc10gVGhlIHByb3BlcnRpZXMgb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4nKS5Db21wb25lbnRDaGlsZHJlbj59IFtjaGlsZHJlbl0gVGhlIGNoaWxkcmVuIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdrZXknKSBrZXkgPSBwcm9wc1tpXTtcblx0XHRlbHNlIGlmIChpID09ICdyZWYnKSByZWYgPSBwcm9wc1tpXTtcblx0XHRlbHNlIG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHR9XG5cblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG5cdFx0bm9ybWFsaXplZFByb3BzLmNoaWxkcmVuID1cblx0XHRcdGFyZ3VtZW50cy5sZW5ndGggPiAzID8gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpIDogY2hpbGRyZW47XG5cdH1cblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHNcblx0Ly8gTm90ZTogdHlwZSBtYXkgYmUgdW5kZWZpbmVkIGluIGRldmVsb3BtZW50LCBtdXN0IG5ldmVyIGVycm9yIGhlcmUuXG5cdGlmICh0eXBlb2YgdHlwZSA9PSAnZnVuY3Rpb24nICYmIHR5cGUuZGVmYXVsdFByb3BzICE9IG51bGwpIHtcblx0XHRmb3IgKGkgaW4gdHlwZS5kZWZhdWx0UHJvcHMpIHtcblx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB0eXBlLmRlZmF1bHRQcm9wc1tpXTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY3JlYXRlVk5vZGUodHlwZSwgbm9ybWFsaXplZFByb3BzLCBrZXksIHJlZiwgbnVsbCk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgVk5vZGUgKHVzZWQgaW50ZXJuYWxseSBieSBQcmVhY3QpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1widHlwZVwiXX0gdHlwZSBUaGUgbm9kZSBuYW1lIG9yIENvbXBvbmVudFxuICogQ29uc3RydWN0b3IgZm9yIHRoaXMgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdCB8IHN0cmluZyB8IG51bWJlciB8IG51bGx9IHByb3BzIFRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdmlydHVhbCBub2RlLlxuICogSWYgdGhpcyB2aXJ0dWFsIG5vZGUgcmVwcmVzZW50cyBhIHRleHQgbm9kZSwgdGhpcyBpcyB0aGUgdGV4dCBvZiB0aGUgbm9kZSAoc3RyaW5nIG9yIG51bWJlcikuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlciB8IG51bGx9IGtleSBUaGUga2V5IGZvciB0aGlzIHZpcnR1YWwgbm9kZSwgdXNlZCB3aGVuXG4gKiBkaWZmaW5nIGl0IGFnYWluc3QgaXRzIGNoaWxkcmVuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlW1wicmVmXCJdfSByZWYgVGhlIHJlZiBwcm9wZXJ0eSB0aGF0IHdpbGxcbiAqIHJlY2VpdmUgYSByZWZlcmVuY2UgdG8gaXRzIGNyZWF0ZWQgY2hpbGRcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIHJlZiwgb3JpZ2luYWwpIHtcblx0Ly8gVjggc2VlbXMgdG8gYmUgYmV0dGVyIGF0IGRldGVjdGluZyB0eXBlIHNoYXBlcyBpZiB0aGUgb2JqZWN0IGlzIGFsbG9jYXRlZCBmcm9tIHRoZSBzYW1lIGNhbGwgc2l0ZVxuXHQvLyBEbyBub3QgaW5saW5lIGludG8gY3JlYXRlRWxlbWVudCBhbmQgY29lcmNlVG9WTm9kZSFcblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdC8vIF9uZXh0RG9tIG11c3QgYmUgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkIGIvYyBpdCB3aWxsIGV2ZW50dWFsbHlcblx0XHQvLyBiZSBzZXQgdG8gZG9tLm5leHRTaWJsaW5nIHdoaWNoIGNhbiByZXR1cm4gYG51bGxgIGFuZCBpdCBpcyBpbXBvcnRhbnRcblx0XHQvLyB0byBiZSBhYmxlIHRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gYW4gdW5pbml0aWFsaXplZCBfbmV4dERvbSBhbmRcblx0XHQvLyBhIF9uZXh0RG9tIHRoYXQgaGFzIGJlZW4gc2V0IHRvIGBudWxsYFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiBvcmlnaW5hbCA9PSBudWxsID8gKyt2bm9kZUlkIDogb3JpZ2luYWxcblx0fTtcblxuXHQvLyBPbmx5IGludm9rZSB0aGUgdm5vZGUgaG9vayBpZiB0aGlzIHdhcyAqbm90KiBhIGRpcmVjdCBjb3B5OlxuXHRpZiAob3JpZ2luYWwgPT0gbnVsbCAmJiBvcHRpb25zLnZub2RlICE9IG51bGwpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVJlZigpIHtcblx0cmV0dXJuIHsgY3VycmVudDogbnVsbCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gRnJhZ21lbnQocHJvcHMpIHtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdGhlIGFyZ3VtZW50IGlzIGEgdmFsaWQgUHJlYWN0IFZOb2RlLlxuICogQHBhcmFtIHsqfSB2bm9kZVxuICogQHJldHVybnMge3Zub2RlIGlzIGltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgY29uc3QgaXNWYWxpZEVsZW1lbnQgPSB2bm9kZSA9PlxuXHR2bm9kZSAhPSBudWxsICYmIHZub2RlLmNvbnN0cnVjdG9yID09PSB1bmRlZmluZWQ7XG4iLCJpbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgZGlmZiwgY29tbWl0Um9vdCB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcblxuLyoqXG4gKiBCYXNlIENvbXBvbmVudCBjbGFzcy4gUHJvdmlkZXMgYHNldFN0YXRlKClgIGFuZCBgZm9yY2VVcGRhdGUoKWAsIHdoaWNoXG4gKiB0cmlnZ2VyIHJlbmRlcmluZ1xuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFRoZSBpbml0aWFsIGNvbXBvbmVudCBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgVGhlIGluaXRpYWwgY29udGV4dCBmcm9tIHBhcmVudCBjb21wb25lbnRzJ1xuICogZ2V0Q2hpbGRDb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQpIHtcblx0dGhpcy5wcm9wcyA9IHByb3BzO1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIFVwZGF0ZSBjb21wb25lbnQgc3RhdGUgYW5kIHNjaGVkdWxlIGEgcmUtcmVuZGVyLlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgKChzOiBvYmplY3QsIHA6IG9iamVjdCkgPT4gb2JqZWN0KX0gdXBkYXRlIEEgaGFzaCBvZiBzdGF0ZVxuICogcHJvcGVydGllcyB0byB1cGRhdGUgd2l0aCBuZXcgdmFsdWVzIG9yIGEgZnVuY3Rpb24gdGhhdCBnaXZlbiB0aGUgY3VycmVudFxuICogc3RhdGUgYW5kIHByb3BzIHJldHVybnMgYSBuZXcgcGFydGlhbCBzdGF0ZVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uY2UgY29tcG9uZW50IHN0YXRlIGlzXG4gKiB1cGRhdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbih1cGRhdGUsIGNhbGxiYWNrKSB7XG5cdC8vIG9ubHkgY2xvbmUgc3RhdGUgd2hlbiBjb3B5aW5nIHRvIG5leHRTdGF0ZSB0aGUgZmlyc3QgdGltZS5cblx0bGV0IHM7XG5cdGlmICh0aGlzLl9uZXh0U3RhdGUgIT0gbnVsbCAmJiB0aGlzLl9uZXh0U3RhdGUgIT09IHRoaXMuc3RhdGUpIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlO1xuXHR9IGVsc2Uge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIHRoaXMuc3RhdGUpO1xuXHR9XG5cblx0aWYgKHR5cGVvZiB1cGRhdGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdC8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYGltbWVyYCBtYXJrIHRoZSBjdXJyZW50IHN0YXRlIGFzIHJlYWRvbmx5LFxuXHRcdC8vIHByZXZlbnRpbmcgdXMgZnJvbSBtdXRhdGluZyBpdCwgc28gd2UgbmVlZCB0byBjbG9uZSBpdC4gU2VlICMyNzE2XG5cdFx0dXBkYXRlID0gdXBkYXRlKGFzc2lnbih7fSwgcyksIHRoaXMucHJvcHMpO1xuXHR9XG5cblx0aWYgKHVwZGF0ZSkge1xuXHRcdGFzc2lnbihzLCB1cGRhdGUpO1xuXHR9XG5cblx0Ly8gU2tpcCB1cGRhdGUgaWYgdXBkYXRlciBmdW5jdGlvbiByZXR1cm5lZCBudWxsXG5cdGlmICh1cGRhdGUgPT0gbnVsbCkgcmV0dXJuO1xuXG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdGlmIChjYWxsYmFjaykge1xuXHRcdFx0dGhpcy5fc3RhdGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0fVxuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogSW1tZWRpYXRlbHkgcGVyZm9ybSBhIHN5bmNocm9ub3VzIHJlLXJlbmRlciBvZiB0aGUgY29tcG9uZW50XG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIEEgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpc1xuICogcmUtcmVuZGVyZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdGlmICh0aGlzLl92bm9kZSkge1xuXHRcdC8vIFNldCByZW5kZXIgbW9kZSBzbyB0aGF0IHdlIGNhbiBkaWZmZXJlbnRpYXRlIHdoZXJlIHRoZSByZW5kZXIgcmVxdWVzdFxuXHRcdC8vIGlzIGNvbWluZyBmcm9tLiBXZSBuZWVkIHRoaXMgYmVjYXVzZSBmb3JjZVVwZGF0ZSBzaG91bGQgbmV2ZXIgY2FsbFxuXHRcdC8vIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuXHRcdHRoaXMuX2ZvcmNlID0gdHJ1ZTtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEFjY2VwdHMgYHByb3BzYCBhbmQgYHN0YXRlYCwgYW5kIHJldHVybnMgYSBuZXcgVmlydHVhbCBET00gdHJlZSB0byBidWlsZC5cbiAqIFZpcnR1YWwgRE9NIGlzIGdlbmVyYWxseSBjb25zdHJ1Y3RlZCB2aWEgW0pTWF0oaHR0cDovL2phc29uZm9ybWF0LmNvbS93dGYtaXMtanN4KS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBQcm9wcyAoZWc6IEpTWCBhdHRyaWJ1dGVzKSByZWNlaXZlZCBmcm9tIHBhcmVudFxuICogZWxlbWVudC9jb21wb25lbnRcbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSBUaGUgY29tcG9uZW50J3MgY3VycmVudCBzdGF0ZVxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHQgQ29udGV4dCBvYmplY3QsIGFzIHJldHVybmVkIGJ5IHRoZSBuZWFyZXN0XG4gKiBhbmNlc3RvcidzIGBnZXRDaGlsZENvbnRleHQoKWBcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbiB8IHZvaWR9XG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gRnJhZ21lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW2NoaWxkSW5kZXhdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXREb21TaWJsaW5nKHZub2RlLCBjaGlsZEluZGV4KSB7XG5cdGlmIChjaGlsZEluZGV4ID09IG51bGwpIHtcblx0XHQvLyBVc2UgY2hpbGRJbmRleD09bnVsbCBhcyBhIHNpZ25hbCB0byByZXN1bWUgdGhlIHNlYXJjaCBmcm9tIHRoZSB2bm9kZSdzIHNpYmxpbmdcblx0XHRyZXR1cm4gdm5vZGUuX3BhcmVudFxuXHRcdFx0PyBnZXREb21TaWJsaW5nKHZub2RlLl9wYXJlbnQsIHZub2RlLl9wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2Yodm5vZGUpICsgMSlcblx0XHRcdDogbnVsbDtcblx0fVxuXG5cdGxldCBzaWJsaW5nO1xuXHRmb3IgKDsgY2hpbGRJbmRleCA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGNoaWxkSW5kZXgrKykge1xuXHRcdHNpYmxpbmcgPSB2bm9kZS5fY2hpbGRyZW5bY2hpbGRJbmRleF07XG5cblx0XHRpZiAoc2libGluZyAhPSBudWxsICYmIHNpYmxpbmcuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHQvLyBTaW5jZSB1cGRhdGVQYXJlbnREb21Qb2ludGVycyBrZWVwcyBfZG9tIHBvaW50ZXIgY29ycmVjdCxcblx0XHRcdC8vIHdlIGNhbiByZWx5IG9uIF9kb20gdG8gdGVsbCB1cyBpZiB0aGlzIHN1YnRyZWUgY29udGFpbnMgYVxuXHRcdFx0Ly8gcmVuZGVyZWQgRE9NIG5vZGUsIGFuZCB3aGF0IHRoZSBmaXJzdCByZW5kZXJlZCBET00gbm9kZSBpc1xuXHRcdFx0cmV0dXJuIHNpYmxpbmcuX2RvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBnZXQgaGVyZSwgd2UgaGF2ZSBub3QgZm91bmQgYSBET00gbm9kZSBpbiB0aGlzIHZub2RlJ3MgY2hpbGRyZW4uXG5cdC8vIFdlIG11c3QgcmVzdW1lIGZyb20gdGhpcyB2bm9kZSdzIHNpYmxpbmcgKGluIGl0J3MgcGFyZW50IF9jaGlsZHJlbiBhcnJheSlcblx0Ly8gT25seSBjbGltYiB1cCBhbmQgc2VhcmNoIHRoZSBwYXJlbnQgaWYgd2UgYXJlbid0IHNlYXJjaGluZyB0aHJvdWdoIGEgRE9NXG5cdC8vIFZOb2RlIChtZWFuaW5nIHdlIHJlYWNoZWQgdGhlIERPTSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHZub2RlIHRoYXQgYmVnYW5cblx0Ly8gdGhlIHNlYXJjaClcblx0cmV0dXJuIHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG51bGw7XG59XG5cbi8qKlxuICogVHJpZ2dlciBpbi1wbGFjZSByZS1yZW5kZXJpbmcgb2YgYSBjb21wb25lbnQuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gY29tcG9uZW50IFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyQ29tcG9uZW50KGNvbXBvbmVudCkge1xuXHRsZXQgdm5vZGUgPSBjb21wb25lbnQuX3Zub2RlLFxuXHRcdG9sZERvbSA9IHZub2RlLl9kb20sXG5cdFx0cGFyZW50RG9tID0gY29tcG9uZW50Ll9wYXJlbnREb207XG5cblx0aWYgKHBhcmVudERvbSkge1xuXHRcdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRcdGNvbnN0IG9sZFZOb2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0b2xkVk5vZGUuX29yaWdpbmFsID0gdm5vZGUuX29yaWdpbmFsICsgMTtcblxuXHRcdGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHR2bm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Y29tcG9uZW50Ll9nbG9iYWxDb250ZXh0LFxuXHRcdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZyAhPSBudWxsID8gW29sZERvbV0gOiBudWxsLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20gPT0gbnVsbCA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogb2xkRG9tLFxuXHRcdFx0dm5vZGUuX2h5ZHJhdGluZ1xuXHRcdCk7XG5cdFx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xuXG5cdFx0aWYgKHZub2RlLl9kb20gIT0gb2xkRG9tKSB7XG5cdFx0XHR1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZnVuY3Rpb24gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpIHtcblx0aWYgKCh2bm9kZSA9IHZub2RlLl9wYXJlbnQpICE9IG51bGwgJiYgdm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IG51bGw7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGxldCBjaGlsZCA9IHZub2RlLl9jaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZCAhPSBudWxsICYmIGNoaWxkLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gY2hpbGQuX2RvbTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFRoZSByZW5kZXIgcXVldWVcbiAqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fVxuICovXG5sZXQgcmVyZW5kZXJRdWV1ZSA9IFtdO1xuXG4vKlxuICogVGhlIHZhbHVlIG9mIGBDb21wb25lbnQuZGVib3VuY2VgIG11c3QgYXN5bmNocm9ub3VzbHkgaW52b2tlIHRoZSBwYXNzZWQgaW4gY2FsbGJhY2suIEl0IGlzXG4gKiBpbXBvcnRhbnQgdGhhdCBjb250cmlidXRvcnMgdG8gUHJlYWN0IGNhbiBjb25zaXN0ZW50bHkgcmVhc29uIGFib3V0IHdoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCwgZXRjLlxuICogZG8sIGFuZCB3aGVuIHRoZWlyIGVmZmVjdHMgd2lsbCBiZSBhcHBsaWVkLiBTZWUgdGhlIGxpbmtzIGJlbG93IGZvciBzb21lIGZ1cnRoZXIgcmVhZGluZyBvbiBkZXNpZ25pbmdcbiAqIGFzeW5jaHJvbm91cyBBUElzLlxuICogKiBbRGVzaWduaW5nIEFQSXMgZm9yIEFzeW5jaHJvbnldKGh0dHBzOi8vYmxvZy5penMubWUvMjAxMy8wOC9kZXNpZ25pbmctYXBpcy1mb3ItYXN5bmNocm9ueSlcbiAqICogW0NhbGxiYWNrcyBzeW5jaHJvbm91cyBhbmQgYXN5bmNocm9ub3VzXShodHRwczovL2Jsb2cub21ldGVyLmNvbS8yMDExLzA3LzI0L2NhbGxiYWNrcy1zeW5jaHJvbm91cy1hbmQtYXN5bmNocm9ub3VzLylcbiAqL1xuXG5sZXQgcHJldkRlYm91bmNlO1xuXG4vKipcbiAqIEVucXVldWUgYSByZXJlbmRlciBvZiBhIGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGMgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5xdWV1ZVJlbmRlcihjKSB7XG5cdGlmIChcblx0XHQoIWMuX2RpcnR5ICYmXG5cdFx0XHQoYy5fZGlydHkgPSB0cnVlKSAmJlxuXHRcdFx0cmVyZW5kZXJRdWV1ZS5wdXNoKGMpICYmXG5cdFx0XHQhcHJvY2Vzcy5fcmVyZW5kZXJDb3VudCsrKSB8fFxuXHRcdHByZXZEZWJvdW5jZSAhPT0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ1xuXHQpIHtcblx0XHRwcmV2RGVib3VuY2UgPSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nO1xuXHRcdChwcmV2RGVib3VuY2UgfHwgc2V0VGltZW91dCkocHJvY2Vzcyk7XG5cdH1cbn1cblxuLyoqIEZsdXNoIHRoZSByZW5kZXIgcXVldWUgYnkgcmVyZW5kZXJpbmcgYWxsIHF1ZXVlZCBjb21wb25lbnRzICovXG5mdW5jdGlvbiBwcm9jZXNzKCkge1xuXHRsZXQgcXVldWU7XG5cdHdoaWxlICgocHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IHJlcmVuZGVyUXVldWUubGVuZ3RoKSkge1xuXHRcdHF1ZXVlID0gcmVyZW5kZXJRdWV1ZS5zb3J0KChhLCBiKSA9PiBhLl92bm9kZS5fZGVwdGggLSBiLl92bm9kZS5fZGVwdGgpO1xuXHRcdHJlcmVuZGVyUXVldWUgPSBbXTtcblx0XHQvLyBEb24ndCB1cGRhdGUgYHJlbmRlckNvdW50YCB5ZXQuIEtlZXAgaXRzIHZhbHVlIG5vbi16ZXJvIHRvIHByZXZlbnQgdW5uZWNlc3Nhcnlcblx0XHQvLyBwcm9jZXNzKCkgY2FsbHMgZnJvbSBnZXR0aW5nIHNjaGVkdWxlZCB3aGlsZSBgcXVldWVgIGlzIHN0aWxsIGJlaW5nIGNvbnN1bWVkLlxuXHRcdHF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRpZiAoYy5fZGlydHkpIHJlbmRlckNvbXBvbmVudChjKTtcblx0XHR9KTtcblx0fVxufVxuXG5wcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY29udGV4dElkKSB7XG5cdGNvbnRleHRJZCA9ICdfX2NDJyArIGkrKztcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogY29udGV4dElkLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdENvbnN1bWVyKHByb3BzLCBjb250ZXh0VmFsdWUpIHtcblx0XHRcdC8vIHJldHVybiBwcm9wcy5jaGlsZHJlbihcblx0XHRcdC8vIFx0Y29udGV4dFtjb250ZXh0SWRdID8gY29udGV4dFtjb250ZXh0SWRdLnByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlXG5cdFx0XHQvLyApO1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHRWYWx1ZSk7XG5cdFx0fSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdFByb3ZpZGVyKHByb3BzKSB7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0Q2hpbGRDb250ZXh0KSB7XG5cdFx0XHRcdGxldCBzdWJzID0gW107XG5cdFx0XHRcdGxldCBjdHggPSB7fTtcblx0XHRcdFx0Y3R4W2NvbnRleHRJZF0gPSB0aGlzO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gY3R4O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24oX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGVucXVldWVSZW5kZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwgfHwgdHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdGNoaWxkVk5vZGUucmVmID8gY2hpbGRWTm9kZS5yZWYgOiBudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLl9vcmlnaW5hbFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNoaWxkVk5vZGU7XG5cdFx0fVxuXG5cdFx0Ly8gVGVyc2VyIHJlbW92ZXMgdGhlIGBjb250aW51ZWAgaGVyZSBhbmQgd3JhcHMgdGhlIGxvb3AgYm9keVxuXHRcdC8vIGluIGEgYGlmIChjaGlsZFZOb2RlKSB7IC4uLiB9IGNvbmRpdGlvblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNoaWxkVk5vZGUuX3BhcmVudCA9IG5ld1BhcmVudFZOb2RlO1xuXHRcdGNoaWxkVk5vZGUuX2RlcHRoID0gbmV3UGFyZW50Vk5vZGUuX2RlcHRoICsgMTtcblxuXHRcdC8vIENoZWNrIGlmIHdlIGZpbmQgYSBjb3JyZXNwb25kaW5nIGVsZW1lbnQgaW4gb2xkQ2hpbGRyZW4uXG5cdFx0Ly8gSWYgZm91bmQsIGRlbGV0ZSB0aGUgYXJyYXkgaXRlbSBieSBzZXR0aW5nIHRvIGB1bmRlZmluZWRgLlxuXHRcdC8vIFdlIHVzZSBgdW5kZWZpbmVkYCwgYXMgYG51bGxgIGlzIHJlc2VydmVkIGZvciBlbXB0eSBwbGFjZWhvbGRlcnNcblx0XHQvLyAoaG9sZXMpLlxuXHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5baV07XG5cblx0XHRpZiAoXG5cdFx0XHRvbGRWTm9kZSA9PT0gbnVsbCB8fFxuXHRcdFx0KG9sZFZOb2RlICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGUpXG5cdFx0KSB7XG5cdFx0XHRvbGRDaGlsZHJlbltpXSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gRWl0aGVyIG9sZFZOb2RlID09PSB1bmRlZmluZWQgb3Igb2xkQ2hpbGRyZW5MZW5ndGggPiAwLFxuXHRcdFx0Ly8gc28gYWZ0ZXIgdGhpcyBsb29wIG9sZFZOb2RlID09IG51bGwgb3Igb2xkVk5vZGUgaXMgYSB2YWxpZCB2YWx1ZS5cblx0XHRcdGZvciAoaiA9IDA7IGogPCBvbGRDaGlsZHJlbkxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdG9sZFZOb2RlID0gb2xkQ2hpbGRyZW5bal07XG5cdFx0XHRcdC8vIElmIGNoaWxkVk5vZGUgaXMgdW5rZXllZCwgd2Ugb25seSBtYXRjaCBzaW1pbGFybHkgdW5rZXllZCBub2Rlcywgb3RoZXJ3aXNlIHdlIG1hdGNoIGJ5IGtleS5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIG1hdGNoIGJ5IHR5cGUgKGluIGVpdGhlciBjYXNlKS5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG9sZFZOb2RlICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdG9sZENoaWxkcmVuW2pdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG9sZFZOb2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRvbGRWTm9kZSA9IG9sZFZOb2RlIHx8IEVNUFRZX09CSjtcblxuXHRcdC8vIE1vcnBoIHRoZSBvbGQgZWxlbWVudCBpbnRvIHRoZSBuZXcgb25lLCBidXQgZG9uJ3QgYXBwZW5kIGl0IHRvIHRoZSBkb20geWV0XG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRpc1N2Zyxcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRvbGREb20sXG5cdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdCk7XG5cblx0XHRuZXdEb20gPSBjaGlsZFZOb2RlLl9kb207XG5cblx0XHRpZiAoKGogPSBjaGlsZFZOb2RlLnJlZikgJiYgb2xkVk5vZGUucmVmICE9IGopIHtcblx0XHRcdGlmICghcmVmcykgcmVmcyA9IFtdO1xuXHRcdFx0aWYgKG9sZFZOb2RlLnJlZikgcmVmcy5wdXNoKG9sZFZOb2RlLnJlZiwgbnVsbCwgY2hpbGRWTm9kZSk7XG5cdFx0XHRyZWZzLnB1c2goaiwgY2hpbGRWTm9kZS5fY29tcG9uZW50IHx8IG5ld0RvbSwgY2hpbGRWTm9kZSk7XG5cdFx0fVxuXG5cdFx0aWYgKG5ld0RvbSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoZmlyc3RDaGlsZERvbSA9PSBudWxsKSB7XG5cdFx0XHRcdGZpcnN0Q2hpbGREb20gPSBuZXdEb207XG5cdFx0XHR9XG5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUuX2NoaWxkcmVuID09PSBvbGRWTm9kZS5fY2hpbGRyZW5cblx0XHRcdCkge1xuXHRcdFx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRcdHBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0XHRvbGRDaGlsZHJlbixcblx0XHRcdFx0XHRuZXdEb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8vIEJlY2F1c2UgdGhlIG5ld1BhcmVudFZOb2RlIGlzIEZyYWdtZW50LWxpa2UsIHdlIG5lZWQgdG8gc2V0IGl0J3Ncblx0XHRcdFx0Ly8gX25leHREb20gcHJvcGVydHkgdG8gdGhlIG5leHRTaWJsaW5nIG9mIGl0cyBsYXN0IGNoaWxkIERPTSBub2RlLlxuXHRcdFx0XHQvL1xuXHRcdFx0XHQvLyBgb2xkRG9tYCBjb250YWlucyB0aGUgY29ycmVjdCB2YWx1ZSBoZXJlIGJlY2F1c2UgaWYgdGhlIGxhc3QgY2hpbGRcblx0XHRcdFx0Ly8gaXMgYSBGcmFnbWVudC1saWtlLCB0aGVuIG9sZERvbSBoYXMgYWxyZWFkeSBiZWVuIHNldCB0byB0aGF0IGNoaWxkJ3MgX25leHREb20uXG5cdFx0XHRcdC8vIElmIHRoZSBsYXN0IGNoaWxkIGlzIGEgRE9NIFZOb2RlLCB0aGVuIG9sZERvbSB3aWxsIGJlIHNldCB0byB0aGF0IERPTVxuXHRcdFx0XHQvLyBub2RlJ3MgbmV4dFNpYmxpbmcuXG5cdFx0XHRcdG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tID0gb2xkRG9tO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRvbGREb20gJiZcblx0XHRcdG9sZFZOb2RlLl9kb20gPT0gb2xkRG9tICYmXG5cdFx0XHRvbGREb20ucGFyZW50Tm9kZSAhPSBwYXJlbnREb21cblx0XHQpIHtcblx0XHRcdC8vIFRoZSBhYm92ZSBjb25kaXRpb24gaXMgdG8gaGFuZGxlIG51bGwgcGxhY2Vob2xkZXJzLiBTZWUgdGVzdCBpbiBwbGFjZWhvbGRlci50ZXN0LmpzOlxuXHRcdFx0Ly8gYGVmZmljaWVudGx5IHJlcGxhY2UgbnVsbCBwbGFjZWhvbGRlcnMgaW4gcGFyZW50IHJlcmVuZGVyc2Bcblx0XHRcdG9sZERvbSA9IGdldERvbVNpYmxpbmcob2xkVk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdG5ld1BhcmVudFZOb2RlLl9kb20gPSBmaXJzdENoaWxkRG9tO1xuXG5cdC8vIFJlbW92ZSByZW1haW5pbmcgb2xkQ2hpbGRyZW4gaWYgdGhlcmUgYXJlIGFueS5cblx0Zm9yIChpID0gb2xkQ2hpbGRyZW5MZW5ndGg7IGktLTsgKSB7XG5cdFx0aWYgKG9sZENoaWxkcmVuW2ldICE9IG51bGwpIHtcblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChwYXJlbnREb20sIHZub2RlLCB2bm9kZSwgYywgdm5vZGUuX2RvbSwgb2xkRG9tKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYW5kIGxvb3AgdGhyb3VnaCB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVufSBjaGlsZHJlbiBUaGUgdW5mbGF0dGVuZWRcbiAqIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlW119XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0NoaWxkQXJyYXkoY2hpbGRyZW4sIG91dCkge1xuXHRvdXQgPSBvdXQgfHwgW107XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZHJlbiA9PSAnYm9vbGVhbicpIHtcblx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuXHRcdGNoaWxkcmVuLnNvbWUoY2hpbGQgPT4ge1xuXHRcdFx0dG9DaGlsZEFycmF5KGNoaWxkLCBvdXQpO1xuXHRcdH0pO1xuXHR9IGVsc2Uge1xuXHRcdG91dC5wdXNoKGNoaWxkcmVuKTtcblx0fVxuXHRyZXR1cm4gb3V0O1xufVxuXG5mdW5jdGlvbiBwbGFjZUNoaWxkKFxuXHRwYXJlbnREb20sXG5cdGNoaWxkVk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRvbGRDaGlsZHJlbixcblx0bmV3RG9tLFxuXHRvbGREb21cbikge1xuXHRsZXQgbmV4dERvbTtcblx0aWYgKGNoaWxkVk5vZGUuX25leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdC8vIE9ubHkgRnJhZ21lbnRzIG9yIGNvbXBvbmVudHMgdGhhdCByZXR1cm4gRnJhZ21lbnQgbGlrZSBWTm9kZXMgd2lsbFxuXHRcdC8vIGhhdmUgYSBub24tdW5kZWZpbmVkIF9uZXh0RG9tLiBDb250aW51ZSB0aGUgZGlmZiBmcm9tIHRoZSBzaWJsaW5nXG5cdFx0Ly8gb2YgbGFzdCBET00gY2hpbGQgb2YgdGhpcyBjaGlsZCBWTm9kZVxuXHRcdG5leHREb20gPSBjaGlsZFZOb2RlLl9uZXh0RG9tO1xuXG5cdFx0Ly8gRWFnZXJseSBjbGVhbnVwIF9uZXh0RG9tLiBXZSBkb24ndCBuZWVkIHRvIHBlcnNpc3QgdGhlIHZhbHVlIGJlY2F1c2Vcblx0XHQvLyBpdCBpcyBvbmx5IHVzZWQgYnkgYGRpZmZDaGlsZHJlbmAgdG8gZGV0ZXJtaW5lIHdoZXJlIHRvIHJlc3VtZSB0aGUgZGlmZiBhZnRlclxuXHRcdC8vIGRpZmZpbmcgQ29tcG9uZW50cyBhbmQgRnJhZ21lbnRzLiBPbmNlIHdlIHN0b3JlIGl0IHRoZSBuZXh0RE9NIGxvY2FsIHZhciwgd2Vcblx0XHQvLyBjYW4gY2xlYW4gdXAgdGhlIHByb3BlcnR5XG5cdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmIChcblx0XHRvbGRWTm9kZSA9PSBudWxsIHx8XG5cdFx0bmV3RG9tICE9IG9sZERvbSB8fFxuXHRcdG5ld0RvbS5wYXJlbnROb2RlID09IG51bGxcblx0KSB7XG5cdFx0b3V0ZXI6IGlmIChvbGREb20gPT0gbnVsbCB8fCBvbGREb20ucGFyZW50Tm9kZSAhPT0gcGFyZW50RG9tKSB7XG5cdFx0XHRwYXJlbnREb20uYXBwZW5kQ2hpbGQobmV3RG9tKTtcblx0XHRcdG5leHREb20gPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBgajxvbGRDaGlsZHJlbkxlbmd0aDsgais9MmAgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gYGorKzxvbGRDaGlsZHJlbkxlbmd0aC8yYFxuXHRcdFx0Zm9yIChcblx0XHRcdFx0bGV0IHNpYkRvbSA9IG9sZERvbSwgaiA9IDA7XG5cdFx0XHRcdChzaWJEb20gPSBzaWJEb20ubmV4dFNpYmxpbmcpICYmIGogPCBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cdFx0XHRcdGogKz0gMlxuXHRcdFx0KSB7XG5cdFx0XHRcdGlmIChzaWJEb20gPT0gbmV3RG9tKSB7XG5cdFx0XHRcdFx0YnJlYWsgb3V0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHBhcmVudERvbS5pbnNlcnRCZWZvcmUobmV3RG9tLCBvbGREb20pO1xuXHRcdFx0bmV4dERvbSA9IG9sZERvbTtcblx0XHR9XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIHByZS1jYWxjdWxhdGVkIHRoZSBuZXh0RE9NIG5vZGUsIHVzZSBpdC4gRWxzZSBjYWxjdWxhdGUgaXQgbm93XG5cdC8vIFN0cmljdGx5IGNoZWNrIGZvciBgdW5kZWZpbmVkYCBoZXJlIGN1eiBgbnVsbGAgaXMgYSB2YWxpZCB2YWx1ZSBvZiBgbmV4dERvbWAuXG5cdC8vIFNlZSBtb3JlIGRldGFpbCBpbiBjcmVhdGUtZWxlbWVudC5qczpjcmVhdGVWTm9kZVxuXHRpZiAobmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0b2xkRG9tID0gbmV4dERvbTtcblx0fSBlbHNlIHtcblx0XHRvbGREb20gPSBuZXdEb20ubmV4dFNpYmxpbmc7XG5cdH1cblxuXHRyZXR1cm4gb2xkRG9tO1xufVxuIiwiaW1wb3J0IHsgSVNfTk9OX0RJTUVOU0lPTkFMIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdGhlIG9sZCBhbmQgbmV3IHByb3BlcnRpZXMgb2YgYSBWTm9kZSBhbmQgYXBwbHkgY2hhbmdlcyB0byB0aGUgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gYXBwbHlcbiAqIGNoYW5nZXMgdG9cbiAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBUaGUgbmV3IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gb2xkUHJvcHMgVGhlIG9sZCBwcm9wc1xuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaHlkcmF0ZSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uIG1vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGh5ZHJhdGUpIHtcblx0bGV0IGk7XG5cblx0Zm9yIChpIGluIG9sZFByb3BzKSB7XG5cdFx0aWYgKGkgIT09ICdjaGlsZHJlbicgJiYgaSAhPT0gJ2tleScgJiYgIShpIGluIG5ld1Byb3BzKSkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBudWxsLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxuXG5cdGZvciAoaSBpbiBuZXdQcm9wcykge1xuXHRcdGlmIChcblx0XHRcdCghaHlkcmF0ZSB8fCB0eXBlb2YgbmV3UHJvcHNbaV0gPT0gJ2Z1bmN0aW9uJykgJiZcblx0XHRcdGkgIT09ICdjaGlsZHJlbicgJiZcblx0XHRcdGkgIT09ICdrZXknICYmXG5cdFx0XHRpICE9PSAndmFsdWUnICYmXG5cdFx0XHRpICE9PSAnY2hlY2tlZCcgJiZcblx0XHRcdG9sZFByb3BzW2ldICE9PSBuZXdQcm9wc1tpXVxuXHRcdCkge1xuXHRcdFx0c2V0UHJvcGVydHkoZG9tLCBpLCBuZXdQcm9wc1tpXSwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gc2V0U3R5bGUoc3R5bGUsIGtleSwgdmFsdWUpIHtcblx0aWYgKGtleVswXSA9PT0gJy0nKSB7XG5cdFx0c3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YWx1ZSk7XG5cdH0gZWxzZSBpZiAodmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0eWxlW2tleV0gPSAnJztcblx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT0gJ251bWJlcicgfHwgSVNfTk9OX0RJTUVOU0lPTkFMLnRlc3Qoa2V5KSkge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWUgKyAncHgnO1xuXHR9XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgdmFsdWUgb24gYSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBtb2RpZnlcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldCB0aGUgcHJvcGVydHkgdG9cbiAqIEBwYXJhbSB7Kn0gb2xkVmFsdWUgVGhlIG9sZCB2YWx1ZSB0aGUgcHJvcGVydHkgaGFkXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGUgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9wZXJ0eShkb20sIG5hbWUsIHZhbHVlLCBvbGRWYWx1ZSwgaXNTdmcpIHtcblx0bGV0IHVzZUNhcHR1cmU7XG5cblx0bzogaWYgKG5hbWUgPT09ICdzdHlsZScpIHtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAodHlwZW9mIG9sZFZhbHVlID09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gb2xkVmFsdWUgPSAnJztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9sZFZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiBvbGRWYWx1ZSkge1xuXHRcdFx0XHRcdGlmICghKHZhbHVlICYmIG5hbWUgaW4gdmFsdWUpKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsICcnKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRcdGZvciAobmFtZSBpbiB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICghb2xkVmFsdWUgfHwgdmFsdWVbbmFtZV0gIT09IG9sZFZhbHVlW25hbWVdKSB7XG5cdFx0XHRcdFx0XHRzZXRTdHlsZShkb20uc3R5bGUsIG5hbWUsIHZhbHVlW25hbWVdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblx0Ly8gQmVuY2htYXJrIGZvciBjb21wYXJpc29uOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzU3NGM5NTRiZGI5NjViOWEwMDk2NWFjNlxuXHRlbHNlIGlmIChuYW1lWzBdID09PSAnbycgJiYgbmFtZVsxXSA9PT0gJ24nKSB7XG5cdFx0dXNlQ2FwdHVyZSA9IG5hbWUgIT09IChuYW1lID0gbmFtZS5yZXBsYWNlKC9DYXB0dXJlJC8sICcnKSk7XG5cblx0XHQvLyBJbmZlciBjb3JyZWN0IGNhc2luZyBmb3IgRE9NIGJ1aWx0LWluIGV2ZW50czpcblx0XHRpZiAobmFtZS50b0xvd2VyQ2FzZSgpIGluIGRvbSkgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKS5zbGljZSgyKTtcblx0XHRlbHNlIG5hbWUgPSBuYW1lLnNsaWNlKDIpO1xuXG5cdFx0aWYgKCFkb20uX2xpc3RlbmVycykgZG9tLl9saXN0ZW5lcnMgPSB7fTtcblx0XHRkb20uX2xpc3RlbmVyc1tuYW1lICsgdXNlQ2FwdHVyZV0gPSB2YWx1ZTtcblxuXHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0aWYgKCFvbGRWYWx1ZSkge1xuXHRcdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdFx0ZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0ZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlciwgdXNlQ2FwdHVyZSk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKG5hbWUgIT09ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcpIHtcblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdC8vIE5vcm1hbGl6ZSBpbmNvcnJlY3QgcHJvcCB1c2FnZSBmb3IgU1ZHOlxuXHRcdFx0Ly8gLSB4bGluazpocmVmIC8geGxpbmtIcmVmIC0tPiBocmVmICh4bGluazpocmVmIHdhcyByZW1vdmVkIGZyb20gU1ZHIGFuZCBpc24ndCBuZWVkZWQpXG5cdFx0XHQvLyAtIGNsYXNzTmFtZSAtLT4gY2xhc3Ncblx0XHRcdG5hbWUgPSBuYW1lLnJlcGxhY2UoL3hsaW5rKEh8OmgpLywgJ2gnKS5yZXBsYWNlKC9zTmFtZSQvLCAncycpO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRuYW1lICE9PSAnaHJlZicgJiZcblx0XHRcdG5hbWUgIT09ICdsaXN0JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2Zvcm0nICYmXG5cdFx0XHQvLyBEZWZhdWx0IHZhbHVlIGluIGJyb3dzZXJzIGlzIGAtMWAgYW5kIGFuIGVtcHR5IHN0cmluZyBpc1xuXHRcdFx0Ly8gY2FzdCB0byBgMGAgaW5zdGVhZFxuXHRcdFx0bmFtZSAhPT0gJ3RhYkluZGV4JyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2Rvd25sb2FkJyAmJlxuXHRcdFx0bmFtZSBpbiBkb21cblx0XHQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRvbVtuYW1lXSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuXHRcdFx0XHQvLyBsYWJlbGxlZCBicmVhayBpcyAxYiBzbWFsbGVyIGhlcmUgdGhhbiBhIHJldHVybiBzdGF0ZW1lbnQgKHNvcnJ5KVxuXHRcdFx0XHRicmVhayBvO1xuXHRcdFx0fSBjYXRjaCAoZSkge31cblx0XHR9XG5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgaGF2ZSBhIGRpZmZlcmVudCBub3Rpb24gb2YgYm9vbGVhbiB2YWx1ZXMuXG5cdFx0Ly8gVGhlIHZhbHVlIGBmYWxzZWAgaXMgZGlmZmVyZW50IGZyb20gdGhlIGF0dHJpYnV0ZSBub3Rcblx0XHQvLyBleGlzdGluZyBvbiB0aGUgRE9NLCBzbyB3ZSBjYW4ndCByZW1vdmUgaXQuIEZvciBub24tYm9vbGVhblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyB3ZSBjb3VsZCB0cmVhdCBmYWxzZSBhcyBhIHJlbW92YWwsIGJ1dCB0aGVcblx0XHQvLyBhbW91bnQgb2YgZXhjZXB0aW9ucyB3b3VsZCBjb3N0IHVzIHRvbyBtYW55IGJ5dGVzLiBPbiB0b3Agb2Zcblx0XHQvLyB0aGF0IG90aGVyIFZET00gZnJhbWV3b3JrcyBhbHNvIGFsd2F5cyBzdHJpbmdpZnkgYGZhbHNlYC5cblxuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIG5ldmVyIHNlcmlhbGl6ZSBmdW5jdGlvbnMgYXMgYXR0cmlidXRlIHZhbHVlc1xuXHRcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCAmJiAodmFsdWUgIT09IGZhbHNlIHx8IG5hbWUuaW5kZXhPZignLScpICE9IC0xKSkge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXG5cdFx0XHRmb3IgKHRtcCA9IDA7IHRtcCA8IGMuX3N0YXRlQ2FsbGJhY2tzLmxlbmd0aDsgdG1wKyspIHtcblx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5fc3RhdGVDYWxsYmFja3NbdG1wXSk7XG5cdFx0XHRcdGMuX3N0YXRlQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIEludm9rZSBwcmUtcmVuZGVyIGxpZmVjeWNsZSBtZXRob2RzXG5cdFx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRNb3VudCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5jb21wb25lbnREaWRNb3VudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0bmV3UHJvcHMgIT09IG9sZFByb3BzICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoIWMuX2ZvcmNlICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPSBudWxsICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZShcblx0XHRcdFx0XHRcdFx0bmV3UHJvcHMsXG5cdFx0XHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRcdFx0Y29tcG9uZW50Q29udGV4dFxuXHRcdFx0XHRcdFx0KSA9PT0gZmFsc2UpIHx8XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0Ly8gTW9yZSBpbmZvIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSm92aURlQ3Jvb2NrL2JlYzVmMmNlOTM1NDRkMmU2MDcwZWY4ZTAwMzZlNGU4XG5cdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9vcmlnaW5hbCAhPT0gb2xkVk5vZGUuX29yaWdpbmFsKSBjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbi5mb3JFYWNoKHZub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZSkgdm5vZGUuX3BhcmVudCA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50V2lsbFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjLmNvbXBvbmVudERpZFVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblx0XHRcdGMuX3BhcmVudERvbSA9IHBhcmVudERvbTtcblxuXHRcdFx0bGV0IHJlbmRlckhvb2sgPSBvcHRpb25zLl9yZW5kZXIsXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHR9IHdoaWxlIChjLl9kaXJ0eSAmJiArK2NvdW50IDwgMjUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09PSBGcmFnbWVudCAmJiB0bXAua2V5ID09IG51bGw7XG5cdFx0XHRsZXQgcmVuZGVyUmVzdWx0ID0gaXNUb3BMZXZlbEZyYWdtZW50ID8gdG1wLnByb3BzLmNoaWxkcmVuIDogdG1wO1xuXG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShyZW5kZXJSZXN1bHQpID8gcmVuZGVyUmVzdWx0IDogW3JlbmRlclJlc3VsdF0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0Ly8gV2Ugc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHRoaXMgVk5vZGUsIHVuc2V0IGFueSBzdG9yZWQgaHlkcmF0aW9uL2JhaWxvdXQgc3RhdGU6XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0Ly8gaWYgaHlkcmF0aW5nIG9yIGNyZWF0aW5nIGluaXRpYWwgdHJlZSwgYmFpbG91dCBwcmVzZXJ2ZXMgRE9NOlxuXHRcdGlmIChpc0h5ZHJhdGluZyB8fCBleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkRG9tO1xuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9ICEhaXNIeWRyYXRpbmc7XG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbltleGNlc3NEb21DaGlsZHJlbi5pbmRleE9mKG9sZERvbSldID0gbnVsbDtcblx0XHRcdC8vIF4gY291bGQgcG9zc2libHkgYmUgc2ltcGxpZmllZCB0bzpcblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0fVxuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRSb290KGNvbW1pdFF1ZXVlLCByb290KSB7XG5cdGlmIChvcHRpb25zLl9jb21taXQpIG9wdGlvbnMuX2NvbW1pdChyb290LCBjb21taXRRdWV1ZSk7XG5cblx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBSZXVzZSB0aGUgY29tbWl0UXVldWUgdmFyaWFibGUgaGVyZSBzbyB0aGUgdHlwZSBjaGFuZ2VzXG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgU2VlIGFib3ZlIHRzLWlnbm9yZSBvbiBjb21taXRRdWV1ZVxuXHRcdFx0XHRjYi5jYWxsKGMpO1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjLl92bm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIHJlcHJlc2VudGluZyBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmdcbiAqIHRoZSB2aXJ0dWFsIG5vZGVzIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Kn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiBkaWZmRWxlbWVudE5vZGVzKFxuXHRkb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cdGxldCBub2RlVHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cdGxldCBpID0gMDtcblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aWYgKG5vZGVUeXBlID09PSAnc3ZnJykgaXNTdmcgPSB0cnVlO1xuXG5cdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0Zm9yICg7IGkgPCBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY2hpbGQgPSBleGNlc3NEb21DaGlsZHJlbltpXTtcblxuXHRcdFx0Ly8gaWYgbmV3Vk5vZGUgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuIG9yIHRoZSBgZG9tYFxuXHRcdFx0Ly8gYXJndW1lbnQgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuLCByZW1vdmUgaXQgZnJvbVxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4gc28gaXQgaXNuJ3QgbGF0ZXIgcmVtb3ZlZCBpbiBkaWZmQ2hpbGRyZW5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2hpbGQgJiZcblx0XHRcdFx0J3NldEF0dHJpYnV0ZScgaW4gY2hpbGQgPT09ICEhbm9kZVR5cGUgJiZcblx0XHRcdFx0KG5vZGVUeXBlID8gY2hpbGQubG9jYWxOYW1lID09PSBub2RlVHlwZSA6IGNoaWxkLm5vZGVUeXBlID09PSAzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGRvbSA9IGNoaWxkO1xuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbltpXSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChkb20gPT0gbnVsbCkge1xuXHRcdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBjcmVhdGVUZXh0Tm9kZSByZXR1cm5zIFRleHQsIHdlIGV4cGVjdCBQcmVhY3RFbGVtZW50XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3UHJvcHMpO1xuXHRcdH1cblxuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuXHRcdFx0XHQnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlLFxuXHRcdFx0XHRuZXdQcm9wcy5pcyAmJiBuZXdQcm9wc1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHdlIHN0aWxsIGhhdmUgdG8gc3BsaXQgbWVyZ2VkIHRleHQgZnJvbSBTU1InZCBIVE1MLlxuXHRcdGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgKCFpc0h5ZHJhdGluZyB8fCBkb20uZGF0YSAhPT0gbmV3UHJvcHMpKSB7XG5cdFx0XHRkb20uZGF0YSA9IG5ld1Byb3BzO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBJZiBleGNlc3NEb21DaGlsZHJlbiB3YXMgbm90IG51bGwsIHJlcG9wdWxhdGUgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50J3MgY2hpbGRyZW46XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBleGNlc3NEb21DaGlsZHJlbiAmJiBzbGljZS5jYWxsKGRvbS5jaGlsZE5vZGVzKTtcblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0Ly8gQnV0LCBpZiB3ZSBhcmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIHVzaW5nIGV4aXN0aW5nIERPTSAoZS5nLiByZXBsYWNlTm9kZSlcblx0XHRcdC8vIHdlIHNob3VsZCByZWFkIHRoZSBleGlzdGluZyBET00gYXR0cmlidXRlcyB0byBkaWZmIHRoZW1cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdG9sZFByb3BzID0ge307XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFuZXdIdG1sIHx8XG5cdFx0XHRcdFx0KCghb2xkSHRtbCB8fCBuZXdIdG1sLl9faHRtbCAhPSBvbGRIdG1sLl9faHRtbCkgJiZcblx0XHRcdFx0XHRcdG5ld0h0bWwuX19odG1sICE9PSBkb20uaW5uZXJIVE1MKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkb20uaW5uZXJIVE1MID0gKG5ld0h0bWwgJiYgbmV3SHRtbC5fX2h0bWwpIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaXNIeWRyYXRpbmcpO1xuXG5cdFx0Ly8gSWYgdGhlIG5ldyB2bm9kZSBkaWRuJ3QgaGF2ZSBkYW5nZXJvdXNseVNldElubmVySFRNTCwgZGlmZiBpdHMgY2hpbGRyZW5cblx0XHRpZiAobmV3SHRtbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkgPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGkpID8gaSA6IFtpXSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2ZyAmJiBub2RlVHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuXG5cdFx0XHRcdFx0PyBleGNlc3NEb21DaGlsZHJlblswXVxuXHRcdFx0XHRcdDogb2xkVk5vZGUuX2NoaWxkcmVuICYmIGdldERvbVNpYmxpbmcob2xkVk5vZGUsIDApLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW5baV0gIT0gbnVsbCkgcmVtb3ZlTm9kZShleGNlc3NEb21DaGlsZHJlbltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyAjMjc1NiBGb3IgdGhlIDxwcm9ncmVzcz4tZWxlbWVudCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyAwLFxuXHRcdFx0XHQvLyBkZXNwaXRlIHRoZSBhdHRyaWJ1dGUgbm90IGJlaW5nIHByZXNlbnQuIFdoZW4gdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBpcyBtaXNzaW5nIHRoZSBwcm9ncmVzcyBiYXIgaXMgdHJlYXRlZCBhcyBpbmRldGVybWluYXRlLlxuXHRcdFx0XHQvLyBUbyBmaXggdGhhdCB3ZSdsbCBhbHdheXMgdXBkYXRlIGl0IHdoZW4gaXQgaXMgMCBmb3IgcHJvZ3Jlc3MgZWxlbWVudHNcblx0XHRcdFx0KGkgIT09IGRvbS52YWx1ZSB8fFxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ3Byb2dyZXNzJyAmJiAhaSkgfHxcblx0XHRcdFx0XHQvLyBUaGlzIGlzIG9ubHkgZm9yIElFIDExIHRvIGZpeCA8c2VsZWN0PiB2YWx1ZSBub3QgYmVpbmcgdXBkYXRlZC5cblx0XHRcdFx0XHQvLyBUbyBhdm9pZCBhIHN0YWxlIHNlbGVjdCB2YWx1ZSB3ZSBuZWVkIHRvIHNldCB0aGUgb3B0aW9uLnZhbHVlXG5cdFx0XHRcdFx0Ly8gYWdhaW4sIHdoaWNoIHRyaWdnZXJzIElFMTEgdG8gcmUtZXZhbHVhdGUgdGhlIHNlbGVjdCB2YWx1ZVxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ29wdGlvbicgJiYgaSAhPT0gb2xkUHJvcHMudmFsdWUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ3ZhbHVlJywgaSwgb2xkUHJvcHMudmFsdWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0J2NoZWNrZWQnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMuY2hlY2tlZCkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20uY2hlY2tlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ2NoZWNrZWQnLCBpLCBvbGRQcm9wcy5jaGVja2VkLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqXG4gKiBJbnZva2Ugb3IgdXBkYXRlIGEgcmVmLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBhIGZ1bmN0aW9uIG9yIG9iamVjdCByZWYuXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcmVmXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWYocmVmLCB2YWx1ZSwgdm5vZGUpIHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSByZWYodmFsdWUpO1xuXHRcdGVsc2UgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgdm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVW5tb3VudCBhIHZpcnR1YWwgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCBhcHBseSBET00gY2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gdW5tb3VudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHBhcmVudFZOb2RlIFRoZSBwYXJlbnQgb2YgdGhlIFZOb2RlIHRoYXRcbiAqIGluaXRpYXRlZCB0aGUgdW5tb3VudFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZV0gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGEgcGFyZW50IG5vZGUgb2YgdGhlXG4gKiBjdXJyZW50IGVsZW1lbnQgaXMgYWxyZWFkeSBkZXRhY2hlZCBmcm9tIHRoZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KHZub2RlLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSkge1xuXHRsZXQgcjtcblx0aWYgKG9wdGlvbnMudW5tb3VudCkgb3B0aW9ucy51bm1vdW50KHZub2RlKTtcblxuXHRpZiAoKHIgPSB2bm9kZS5yZWYpKSB7XG5cdFx0aWYgKCFyLmN1cnJlbnQgfHwgci5jdXJyZW50ID09PSB2bm9kZS5fZG9tKSB7XG5cdFx0XHRhcHBseVJlZihyLCBudWxsLCBwYXJlbnRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdFx0dm5vZGUuX2NvbXBvbmVudCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyW2ldKSB7XG5cdFx0XHRcdHVubW91bnQocltpXSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUgfHwgdHlwZW9mIHZub2RlLnR5cGUgIT09ICdmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICghc2tpcFJlbW92ZSAmJiB2bm9kZS5fZG9tICE9IG51bGwpIHtcblx0XHRyZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXHR9XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX3BhcmVudCA9IHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG9iamVjdH0gW3JlcGxhY2VOb2RlXSBPcHRpb25hbDogQXR0ZW1wdCB0byByZS11c2UgYW5cbiAqIGV4aXN0aW5nIERPTSB0cmVlIHJvb3RlZCBhdCBgcmVwbGFjZU5vZGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudERvbSwgcmVwbGFjZU5vZGUpIHtcblx0aWYgKG9wdGlvbnMuX3Jvb3QpIG9wdGlvbnMuX3Jvb3Qodm5vZGUsIHBhcmVudERvbSk7XG5cblx0Ly8gV2UgYWJ1c2UgdGhlIGByZXBsYWNlTm9kZWAgcGFyYW1ldGVyIGluIGBoeWRyYXRlKClgIHRvIHNpZ25hbCBpZiB3ZSBhcmUgaW5cblx0Ly8gaHlkcmF0aW9uIG1vZGUgb3Igbm90IGJ5IHBhc3NpbmcgdGhlIGBoeWRyYXRlYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIGEgRE9NXG5cdC8vIGVsZW1lbnQuLlxuXHRsZXQgaXNIeWRyYXRpbmcgPSB0eXBlb2YgcmVwbGFjZU5vZGUgPT09ICdmdW5jdGlvbic7XG5cblx0Ly8gVG8gYmUgYWJsZSB0byBzdXBwb3J0IGNhbGxpbmcgYHJlbmRlcigpYCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZVxuXHQvLyBET00gbm9kZSwgd2UgbmVlZCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIHRyZWUuIFdlIGRvXG5cdC8vIHRoaXMgYnkgYXNzaWduaW5nIGEgbmV3IGBfY2hpbGRyZW5gIHByb3BlcnR5IHRvIERPTSBub2RlcyB3aGljaCBwb2ludHNcblx0Ly8gdG8gdGhlIGxhc3QgcmVuZGVyZWQgdHJlZS4gQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50LCB3aGljaFxuXHQvLyBtZWFucyB0aGF0IHdlIGFyZSBtb3VudGluZyBhIG5ldyB0cmVlIGZvciB0aGUgZmlyc3QgdGltZS5cblx0bGV0IG9sZFZOb2RlID0gaXNIeWRyYXRpbmdcblx0XHQ/IG51bGxcblx0XHQ6IChyZXBsYWNlTm9kZSAmJiByZXBsYWNlTm9kZS5fY2hpbGRyZW4pIHx8IHBhcmVudERvbS5fY2hpbGRyZW47XG5cblx0dm5vZGUgPSAoXG5cdFx0KCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZSkgfHxcblx0XHRwYXJlbnREb21cblx0KS5fY2hpbGRyZW4gPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHR2bm9kZSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkXG5cdFx0XHQ/IHNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IHJlcGxhY2VOb2RlXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG9sZFZOb2RlLl9kb21cblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGQsXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBoeWRyYXRlKTtcbn1cbiIsIi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gW29sZFZOb2RlXVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuRXJyb3JJbmZvfSBbZXJyb3JJbmZvXVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCwgY3RvciwgaGFuZGxlZDtcblxuXHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5fcHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcblxuXHRcdFx0XHRpZiAoY3RvciAmJiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNldFN0YXRlKGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyB8fCB7fSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIGVycm9yIGJvdW5kYXJ5LiBNYXJrIGl0IGFzIGhhdmluZyBiYWlsZWQgb3V0LCBhbmQgd2hldGhlciBpdCB3YXMgbWlkLWh5ZHJhdGlvbi5cblx0XHRcdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGNvbXBvbmVudC5fcGVuZGluZ0Vycm9yID0gY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdwcmVhY3QnKS5WTm9kZX0gVk5vZGUgKi9cblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoaXMgZmlsZSBleHBvcnRzIHZhcmlvdXMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBCYWJlbCdzIFwiYXV0b21hdGljXCIgSlNYIHJ1bnRpbWUgQVBJOlxuICogLSBqc3godHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4cyh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgX19zb3VyY2UsIF9fc2VsZilcbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgY3JlYXRlVk5vZGUgaGVyZSBpcyBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlLlxuICogQmVuY2htYXJrczogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81ZjZiNTRhMGI0NjMyMTAwYTdkY2QyYjNcbiAqL1xuXG4vKipcbiAqIEpTWC5FbGVtZW50IGZhY3RvcnkgdXNlZCBieSBCYWJlbCdzIHtydW50aW1lOlwiYXV0b21hdGljXCJ9IEpTWCB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7Vk5vZGVbJ3R5cGUnXX0gdHlwZVxuICogQHBhcmFtIHtWTm9kZVsncHJvcHMnXX0gcHJvcHNcbiAqIEBwYXJhbSB7Vk5vZGVbJ2tleSddfSBba2V5XVxuICogQHBhcmFtIHtzdHJpbmd9IFtfX3NlbGZdXG4gKiBAcGFyYW0ge3N0cmluZ30gW19fc291cmNlXVxuICovXG5mdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCBfX3NlbGYsIF9fc291cmNlKSB7XG5cdC8vIFdlJ2xsIHdhbnQgdG8gcHJlc2VydmUgYHJlZmAgaW4gcHJvcHMgdG8gZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3Jcblx0Ly8gZm9yd2FyZFJlZiBjb21wb25lbnRzIGluIHRoZSBmdXR1cmUsIGJ1dCB0aGF0IHNob3VsZCBoYXBwZW4gdmlhXG5cdC8vIGEgc2VwYXJhdGUgUFIuXG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ3JlZicpIHtcblx0XHRcdHJlZiA9IHByb3BzW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzOiBub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogLS12bm9kZUlkLFxuXHRcdF9fc291cmNlLFxuXHRcdF9fc2VsZlxuXHR9O1xuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wcy5cblx0Ly8gTm90ZTogYHR5cGVgIGlzIG9mdGVuIGEgU3RyaW5nLCBhbmQgY2FuIGJlIGB1bmRlZmluZWRgIGluIGRldmVsb3BtZW50LlxuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgKHJlZiA9IHR5cGUuZGVmYXVsdFByb3BzKSkge1xuXHRcdGZvciAoaSBpbiByZWYpXG5cdFx0XHRpZiAodHlwZW9mIG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcmVmW2ldO1xuXHRcdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCB7XG5cdGNyZWF0ZVZOb2RlIGFzIGpzeCxcblx0Y3JlYXRlVk5vZGUgYXMganN4cyxcblx0Y3JlYXRlVk5vZGUgYXMganN4REVWLFxuXHRGcmFnbWVudFxufTtcbiIsImltcG9ydCB7IEZyYWdtZW50LCBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEluZGV4O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBjdXJyZW50Q29tcG9uZW50O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cbmxldCBwcmV2aW91c0NvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtudW1iZXJ9ICovXG5sZXQgY3VycmVudEhvb2sgPSAwO1xuXG4vKiogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59ICovXG5sZXQgYWZ0ZXJQYWludEVmZmVjdHMgPSBbXTtcblxubGV0IEVNUFRZID0gW107XG5cbmxldCBvbGRCZWZvcmVEaWZmID0gb3B0aW9ucy5fZGlmZjtcbmxldCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5sZXQgb2xkQWZ0ZXJEaWZmID0gb3B0aW9ucy5kaWZmZWQ7XG5sZXQgb2xkQ29tbWl0ID0gb3B0aW9ucy5fY29tbWl0O1xubGV0IG9sZEJlZm9yZVVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5cbmNvbnN0IFJBRl9USU1FT1VUID0gMTAwO1xubGV0IHByZXZSYWY7XG5cbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmIChcblx0XHR0eXBlb2Ygdm5vZGUudHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdCF2bm9kZS5fbWFzayAmJlxuXHRcdHZub2RlLnR5cGUgIT09IEZyYWdtZW50XG5cdCkge1xuXHRcdHZub2RlLl9tYXNrID1cblx0XHRcdCh2bm9kZS5fcGFyZW50ICYmIHZub2RlLl9wYXJlbnQuX21hc2sgPyB2bm9kZS5fcGFyZW50Ll9tYXNrIDogJycpICtcblx0XHRcdCh2bm9kZS5fcGFyZW50ICYmIHZub2RlLl9wYXJlbnQuX2NoaWxkcmVuXG5cdFx0XHRcdD8gdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSlcblx0XHRcdFx0OiAwKTtcblx0fSBlbHNlIGlmICghdm5vZGUuX21hc2spIHtcblx0XHR2bm9kZS5fbWFzayA9XG5cdFx0XHR2bm9kZS5fcGFyZW50ICYmIHZub2RlLl9wYXJlbnQuX21hc2sgPyB2bm9kZS5fcGFyZW50Ll9tYXNrIDogJyc7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcblx0aWYgKG9sZEJlZm9yZURpZmYpIG9sZEJlZm9yZURpZmYodm5vZGUpO1xufTtcblxub3B0aW9ucy5fcmVuZGVyID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSBvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRjdXJyZW50SW5kZXggPSAwO1xuXG5cdGNvbnN0IGhvb2tzID0gY3VycmVudENvbXBvbmVudC5fX2hvb2tzO1xuXHRpZiAoaG9va3MpIHtcblx0XHRpZiAocHJldmlvdXNDb21wb25lbnQgPT09IGN1cnJlbnRDb21wb25lbnQpIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fbmV4dFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHRcdFx0aG9va0l0ZW0uX25leHRWYWx1ZSA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9XG5cdH1cblx0cHJldmlvdXNDb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50O1xufTtcblxub3B0aW9ucy5kaWZmZWQgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRBZnRlckRpZmYpIG9sZEFmdGVyRGlmZih2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGlmIChjLl9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmxlbmd0aCkgYWZ0ZXJQYWludChhZnRlclBhaW50RWZmZWN0cy5wdXNoKGMpKTtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdBcmdzKSB7XG5cdFx0XHRcdGhvb2tJdGVtLl9hcmdzID0gaG9va0l0ZW0uX3BlbmRpbmdBcmdzO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgIT09IEVNUFRZKSB7XG5cdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9wZW5kaW5nVmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0fSk7XG5cdH1cblx0cHJldmlvdXNDb21wb25lbnQgPSBjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcbn07XG5cbm9wdGlvbnMuX2NvbW1pdCA9ICh2bm9kZSwgY29tbWl0UXVldWUpID0+IHtcblx0Y29tbWl0UXVldWUuc29tZShjb21wb25lbnQgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MgPSBjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5maWx0ZXIoY2IgPT5cblx0XHRcdFx0Y2IuX3ZhbHVlID8gaW52b2tlRWZmZWN0KGNiKSA6IHRydWVcblx0XHRcdCk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcykgYy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9KTtcblx0XHRcdGNvbW1pdFF1ZXVlID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG5cblx0aWYgKG9sZENvbW1pdCkgb2xkQ29tbWl0KHZub2RlLCBjb21taXRRdWV1ZSk7XG59O1xuXG5vcHRpb25zLnVubW91bnQgPSB2bm9kZSA9PiB7XG5cdGlmIChvbGRCZWZvcmVVbm1vdW50KSBvbGRCZWZvcmVVbm1vdW50KHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0bGV0IGhhc0Vycm9yZWQ7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2gocyA9PiB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpbnZva2VDbGVhbnVwKHMpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRoYXNFcnJvcmVkID0gZTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRjLl9faG9va3MgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKGhhc0Vycm9yZWQpIG9wdGlvbnMuX2NhdGNoRXJyb3IoaGFzRXJyb3JlZCwgYy5fdm5vZGUpO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvb2sncyBzdGF0ZSBmcm9tIHRoZSBjdXJyZW50Q29tcG9uZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBob29rIHRvIGdldFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIGluZGV4IG9mIHRoZSBob29rIHRvIGdldFxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0SG9va1N0YXRlKGluZGV4LCB0eXBlKSB7XG5cdGlmIChvcHRpb25zLl9ob29rKSB7XG5cdFx0b3B0aW9ucy5faG9vayhjdXJyZW50Q29tcG9uZW50LCBpbmRleCwgY3VycmVudEhvb2sgfHwgdHlwZSk7XG5cdH1cblx0Y3VycmVudEhvb2sgPSAwO1xuXG5cdC8vIExhcmdlbHkgaW5zcGlyZWQgYnk6XG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi9mNmJlNzM0NjhlNmVjNDZiMGZmNWFhM2NjNGM5YmFmNzJhMjkwMjVhL3NyYy9ob29rcy9jb3JlX2hvb2tzLm1qc1xuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvNjUwYmVhYTU4YzQzYzMzYTc0ODIwYTNjOThiM2M3MDc5Y2YyZTMzMy9zcmMvcmVuZGVyZXIubWpzXG5cdC8vIE90aGVyIGltcGxlbWVudGF0aW9ucyB0byBsb29rIGF0OlxuXHQvLyAqIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9tbm94MDVxcDhcblx0Y29uc3QgaG9va3MgPVxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcyB8fFxuXHRcdChjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgPSB7XG5cdFx0XHRfbGlzdDogW10sXG5cdFx0XHRfcGVuZGluZ0VmZmVjdHM6IFtdXG5cdFx0fSk7XG5cblx0aWYgKGluZGV4ID49IGhvb2tzLl9saXN0Lmxlbmd0aCkge1xuXHRcdGhvb2tzLl9saXN0LnB1c2goeyBfcGVuZGluZ1ZhbHVlOiBFTVBUWSB9KTtcblx0fVxuXHRyZXR1cm4gaG9va3MuX2xpc3RbaW5kZXhdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IFtpbml0aWFsU3RhdGVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcblx0Y3VycmVudEhvb2sgPSAxO1xuXHRyZXR1cm4gdXNlUmVkdWNlcihpbnZva2VPclJldHVybiwgaW5pdGlhbFN0YXRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlJlZHVjZXI8YW55LCBhbnk+fSByZWR1Y2VyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBpbml0aWFsU3RhdGVcbiAqIEBwYXJhbSB7KGluaXRpYWxTdGF0ZTogYW55KSA9PiB2b2lkfSBbaW5pdF1cbiAqIEByZXR1cm5zIHtbIGFueSwgKHN0YXRlOiBhbnkpID0+IHZvaWQgXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBpbml0KSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuUmVkdWNlckhvb2tTdGF0ZX0gKi9cblx0Y29uc3QgaG9va1N0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAyKTtcblx0aG9va1N0YXRlLl9yZWR1Y2VyID0gcmVkdWNlcjtcblx0aWYgKCFob29rU3RhdGUuX2NvbXBvbmVudCkge1xuXHRcdGhvb2tTdGF0ZS5fdmFsdWUgPSBbXG5cdFx0XHQhaW5pdCA/IGludm9rZU9yUmV0dXJuKHVuZGVmaW5lZCwgaW5pdGlhbFN0YXRlKSA6IGluaXQoaW5pdGlhbFN0YXRlKSxcblxuXHRcdFx0YWN0aW9uID0+IHtcblx0XHRcdFx0Y29uc3QgY3VycmVudFZhbHVlID0gaG9va1N0YXRlLl9uZXh0VmFsdWVcblx0XHRcdFx0XHQ/IGhvb2tTdGF0ZS5fbmV4dFZhbHVlWzBdXG5cdFx0XHRcdFx0OiBob29rU3RhdGUuX3ZhbHVlWzBdO1xuXHRcdFx0XHRjb25zdCBuZXh0VmFsdWUgPSBob29rU3RhdGUuX3JlZHVjZXIoY3VycmVudFZhbHVlLCBhY3Rpb24pO1xuXG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fbmV4dFZhbHVlID0gW25leHRWYWx1ZSwgaG9va1N0YXRlLl92YWx1ZVsxXV07XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9jb21wb25lbnQuc2V0U3RhdGUoe30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XTtcblxuXHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcblxuXHRcdGlmICghY3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzKSB7XG5cdFx0XHRjdXJyZW50Q29tcG9uZW50Ll9oYXNTY3VGcm9tSG9va3MgPSB0cnVlO1xuXHRcdFx0Y29uc3QgcHJldlNjdSA9IGN1cnJlbnRDb21wb25lbnQuc2hvdWxkQ29tcG9uZW50VXBkYXRlO1xuXG5cdFx0XHQvLyBUaGlzIFNDVSBoYXMgdGhlIHB1cnBvc2Ugb2YgYmFpbGluZyBvdXQgYWZ0ZXIgcmVwZWF0ZWQgdXBkYXRlc1xuXHRcdFx0Ly8gdG8gc3RhdGVmdWwgaG9va3MuXG5cdFx0XHQvLyB3ZSBzdG9yZSB0aGUgbmV4dCB2YWx1ZSBpbiBfbmV4dFZhbHVlWzBdIGFuZCBrZWVwIGRvaW5nIHRoYXQgZm9yIGFsbFxuXHRcdFx0Ly8gc3RhdGUgc2V0dGVycywgaWYgd2UgaGF2ZSBuZXh0IHN0YXRlcyBhbmRcblx0XHRcdC8vIGFsbCBuZXh0IHN0YXRlcyB3aXRoaW4gYSBjb21wb25lbnQgZW5kIHVwIGJlaW5nIGVxdWFsIHRvIHRoZWlyIG9yaWdpbmFsIHN0YXRlXG5cdFx0XHQvLyB3ZSBhcmUgc2FmZSB0byBiYWlsIG91dCBmb3IgdGhpcyBzcGVjaWZpYyBjb21wb25lbnQuXG5cdFx0XHRjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHAsIHMsIGMpIHtcblx0XHRcdFx0aWYgKCFob29rU3RhdGUuX2NvbXBvbmVudC5fX2hvb2tzKSByZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRjb25zdCBzdGF0ZUhvb2tzID0gaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcy5fbGlzdC5maWx0ZXIoXG5cdFx0XHRcdFx0eCA9PiB4Ll9jb21wb25lbnRcblx0XHRcdFx0KTtcblx0XHRcdFx0Y29uc3QgYWxsSG9va3NFbXB0eSA9IHN0YXRlSG9va3MuZXZlcnkoeCA9PiAheC5fbmV4dFZhbHVlKTtcblx0XHRcdFx0Ly8gV2hlbiB3ZSBoYXZlIG5vIHVwZGF0ZWQgaG9va3MgaW4gdGhlIGNvbXBvbmVudCB3ZSBpbnZva2UgdGhlIHByZXZpb3VzIFNDVSBvclxuXHRcdFx0XHQvLyB0cmF2ZXJzZSB0aGUgVkRPTSB0cmVlIGZ1cnRoZXIuXG5cdFx0XHRcdGlmIChhbGxIb29rc0VtcHR5KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByZXZTY3UgPyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYykgOiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gV2UgY2hlY2sgd2hldGhlciB3ZSBoYXZlIGNvbXBvbmVudHMgd2l0aCBhIG5leHRWYWx1ZSBzZXQgdGhhdFxuXHRcdFx0XHQvLyBoYXZlIHZhbHVlcyB0aGF0IGFyZW4ndCBlcXVhbCB0byBvbmUgYW5vdGhlciB0aGlzIHB1c2hlc1xuXHRcdFx0XHQvLyB1cyB0byB1cGRhdGUgZnVydGhlciBkb3duIHRoZSB0cmVlXG5cdFx0XHRcdGxldCBzaG91bGRVcGRhdGUgPSBmYWxzZTtcblx0XHRcdFx0c3RhdGVIb29rcy5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdFx0XHRpZiAoaG9va0l0ZW0uX25leHRWYWx1ZSkge1xuXHRcdFx0XHRcdFx0Y29uc3QgY3VycmVudFZhbHVlID0gaG9va0l0ZW0uX3ZhbHVlWzBdO1xuXHRcdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBob29rSXRlbS5fdmFsdWVbMF0pIHNob3VsZFVwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRyZXR1cm4gc2hvdWxkVXBkYXRlIHx8IGhvb2tTdGF0ZS5fY29tcG9uZW50LnByb3BzICE9PSBwXG5cdFx0XHRcdFx0PyBwcmV2U2N1XG5cdFx0XHRcdFx0XHQ/IHByZXZTY3UuY2FsbCh0aGlzLCBwLCBzLCBjKVxuXHRcdFx0XHRcdFx0OiB0cnVlXG5cdFx0XHRcdFx0OiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGhvb2tTdGF0ZS5fbmV4dFZhbHVlIHx8IGhvb2tTdGF0ZS5fdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAzKTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5wdXNoKHN0YXRlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGF5b3V0RWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNCk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcy5wdXNoKHN0YXRlKTtcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmKGluaXRpYWxWYWx1ZSkge1xuXHRjdXJyZW50SG9vayA9IDU7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+ICh7IGN1cnJlbnQ6IGluaXRpYWxWYWx1ZSB9KSwgW10pO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7KCkgPT4gb2JqZWN0fSBjcmVhdGVIYW5kbGVcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGVIYW5kbGUsIGFyZ3MpIHtcblx0Y3VycmVudEhvb2sgPSA2O1xuXHR1c2VMYXlvdXRFZmZlY3QoXG5cdFx0KCkgPT4ge1xuXHRcdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRyZWYoY3JlYXRlSGFuZGxlKCkpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gcmVmKG51bGwpO1xuXHRcdFx0fSBlbHNlIGlmIChyZWYpIHtcblx0XHRcdFx0cmVmLmN1cnJlbnQgPSBjcmVhdGVIYW5kbGUoKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YXJncyA9PSBudWxsID8gYXJncyA6IGFyZ3MuY29uY2F0KHJlZilcblx0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IGFueX0gZmFjdG9yeVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVtbyhmYWN0b3J5LCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuTWVtb0hvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDcpO1xuXHRpZiAoYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3BlbmRpbmdWYWx1ZSA9IGZhY3RvcnkoKTtcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXHRcdHN0YXRlLl9mYWN0b3J5ID0gZmFjdG9yeTtcblx0XHRyZXR1cm4gc3RhdGUuX3BlbmRpbmdWYWx1ZTtcblx0fVxuXG5cdHJldHVybiBzdGF0ZS5fdmFsdWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2FsbGJhY2soY2FsbGJhY2ssIGFyZ3MpIHtcblx0Y3VycmVudEhvb2sgPSA4O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiBjYWxsYmFjaywgYXJncyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RDb250ZXh0fSBjb250ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcblx0Y29uc3QgcHJvdmlkZXIgPSBjdXJyZW50Q29tcG9uZW50LmNvbnRleHRbY29udGV4dC5faWRdO1xuXHQvLyBXZSBjb3VsZCBza2lwIHRoaXMgY2FsbCBoZXJlLCBidXQgdGhhbiB3ZSdkIG5vdCBjYWxsXG5cdC8vIGBvcHRpb25zLl9ob29rYC4gV2UgbmVlZCB0byBkbyB0aGF0IGluIG9yZGVyIHRvIG1ha2Vcblx0Ly8gdGhlIGRldnRvb2xzIGF3YXJlIG9mIHRoaXMgaG9vay5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db250ZXh0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgOSk7XG5cdC8vIFRoZSBkZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHRvXG5cdC8vIGJlIGFibGUgdG8gcHVsbCBvZiB0aGUgZGVmYXVsdCB2YWx1ZSB3aGVuIG5vIHByb3ZpZGVyXG5cdC8vIGlzIHByZXNlbnQgaW4gdGhlIHRyZWUuXG5cdHN0YXRlLl9jb250ZXh0ID0gY29udGV4dDtcblx0aWYgKCFwcm92aWRlcikgcmV0dXJuIGNvbnRleHQuX2RlZmF1bHRWYWx1ZTtcblx0Ly8gVGhpcyBpcyBwcm9iYWJseSBub3Qgc2FmZSB0byBjb252ZXJ0IHRvIFwiIVwiXG5cdGlmIChzdGF0ZS5fdmFsdWUgPT0gbnVsbCkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IHRydWU7XG5cdFx0cHJvdmlkZXIuc3ViKGN1cnJlbnRDb21wb25lbnQpO1xuXHR9XG5cdHJldHVybiBwcm92aWRlci5wcm9wcy52YWx1ZTtcbn1cblxuLyoqXG4gKiBEaXNwbGF5IGEgY3VzdG9tIGxhYmVsIGZvciBhIGN1c3RvbSBob29rIGZvciB0aGUgZGV2dG9vbHMgcGFuZWxcbiAqIEB0eXBlIHs8VD4odmFsdWU6IFQsIGNiPzogKHZhbHVlOiBUKSA9PiBzdHJpbmcgfCBudW1iZXIpID0+IHZvaWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJ1Z1ZhbHVlKHZhbHVlLCBmb3JtYXR0ZXIpIHtcblx0aWYgKG9wdGlvbnMudXNlRGVidWdWYWx1ZSkge1xuXHRcdG9wdGlvbnMudXNlRGVidWdWYWx1ZShmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIodmFsdWUpIDogdmFsdWUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHsoZXJyb3I6IGFueSwgZXJyb3JJbmZvOiBpbXBvcnQoJ3ByZWFjdCcpLkVycm9ySW5mbykgPT4gdm9pZH0gY2JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVycm9yQm91bmRhcnkoY2IpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FcnJvckJvdW5kYXJ5SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMTApO1xuXHRjb25zdCBlcnJTdGF0ZSA9IHVzZVN0YXRlKCk7XG5cdHN0YXRlLl92YWx1ZSA9IGNiO1xuXHRpZiAoIWN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2gpIHtcblx0XHRjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoID0gKGVyciwgZXJyb3JJbmZvKSA9PiB7XG5cdFx0XHRpZiAoc3RhdGUuX3ZhbHVlKSBzdGF0ZS5fdmFsdWUoZXJyLCBlcnJvckluZm8pO1xuXHRcdFx0ZXJyU3RhdGVbMV0oZXJyKTtcblx0XHR9O1xuXHR9XG5cdHJldHVybiBbXG5cdFx0ZXJyU3RhdGVbMF0sXG5cdFx0KCkgPT4ge1xuXHRcdFx0ZXJyU3RhdGVbMV0odW5kZWZpbmVkKTtcblx0XHR9XG5cdF07XG59XG5cbmZ1bmN0aW9uIGhhc2gocykge1xuXHRsZXQgaCA9IDAsXG5cdFx0aSA9IHMubGVuZ3RoO1xuXHR3aGlsZSAoaSA+IDApIHtcblx0XHRoID0gKChoIDw8IDUpIC0gaCArIHMuY2hhckNvZGVBdCgtLWkpKSB8IDA7XG5cdH1cblx0cmV0dXJuIGg7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJZCgpIHtcblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDExKTtcblx0aWYgKCFzdGF0ZS5fdmFsdWUpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSAnUCcgKyBoYXNoKGN1cnJlbnRDb21wb25lbnQuX3Zub2RlLl9tYXNrKSArIGN1cnJlbnRJbmRleDtcblx0fVxuXG5cdHJldHVybiBzdGF0ZS5fdmFsdWU7XG59XG4vKipcbiAqIEFmdGVyIHBhaW50IGVmZmVjdHMgY29uc3VtZXIuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMoKSB7XG5cdGxldCBjb21wb25lbnQ7XG5cdHdoaWxlICgoY29tcG9uZW50ID0gYWZ0ZXJQYWludEVmZmVjdHMuc2hpZnQoKSkpIHtcblx0XHRpZiAoIWNvbXBvbmVudC5fcGFyZW50RG9tIHx8ICFjb21wb25lbnQuX19ob29rcykgY29udGludWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH1cbn1cblxubGV0IEhBU19SQUYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogU2NoZWR1bGUgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBicm93c2VyIGhhcyBhIGNoYW5jZSB0byBwYWludCBhIG5ldyBmcmFtZS5cbiAqIERvIHRoaXMgYnkgY29tYmluaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSAockFGKSArIHNldFRpbWVvdXQgdG8gaW52b2tlIGEgY2FsbGJhY2sgYWZ0ZXJcbiAqIHRoZSBuZXh0IGJyb3dzZXIgZnJhbWUuXG4gKlxuICogQWxzbywgc2NoZWR1bGUgYSB0aW1lb3V0IGluIHBhcmFsbGVsIHRvIHRoZSB0aGUgckFGIHRvIGVuc3VyZSB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZFxuICogZXZlbiBpZiBSQUYgZG9lc24ndCBmaXJlIChmb3IgZXhhbXBsZSBpZiB0aGUgYnJvd3NlciB0YWIgaXMgbm90IHZpc2libGUpXG4gKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBhZnRlck5leHRGcmFtZShjYWxsYmFjaykge1xuXHRjb25zdCBkb25lID0gKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRpZiAoSEFTX1JBRikgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrKTtcblx0fTtcblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZG9uZSwgUkFGX1RJTUVPVVQpO1xuXG5cdGxldCByYWY7XG5cdGlmIChIQVNfUkFGKSB7XG5cdFx0cmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvbmUpO1xuXHR9XG59XG5cbi8vIE5vdGU6IGlmIHNvbWVvbmUgdXNlZCBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuLy8gdGhlbiBlZmZlY3RzIHdpbGwgQUxXQVlTIHJ1biBvbiB0aGUgTkVYVCBmcmFtZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZSwgaW5jdXJyaW5nIGEgfjE2bXMgZGVsYXkuXG4vLyBQZXJoYXBzIHRoaXMgaXMgbm90IHN1Y2ggYSBiaWcgZGVhbC5cbi8qKlxuICogU2NoZWR1bGUgYWZ0ZXJQYWludEVmZmVjdHMgZmx1c2ggYWZ0ZXIgdGhlIGJyb3dzZXIgcGFpbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3UXVldWVMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJQYWludChuZXdRdWV1ZUxlbmd0aCkge1xuXHRpZiAobmV3UXVldWVMZW5ndGggPT09IDEgfHwgcHJldlJhZiAhPT0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRwcmV2UmFmID0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0KHByZXZSYWYgfHwgYWZ0ZXJOZXh0RnJhbWUpKGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2xlYW51cChob29rKSB7XG5cdC8vIEEgaG9vayBjbGVhbnVwIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGxldCBjbGVhbnVwID0gaG9vay5fY2xlYW51cDtcblx0aWYgKHR5cGVvZiBjbGVhbnVwID09ICdmdW5jdGlvbicpIHtcblx0XHRob29rLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEludm9rZSBhIEhvb2sncyBlZmZlY3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUVmZmVjdChob29rKSB7XG5cdC8vIEEgaG9vayBjYWxsIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGhvb2suX2NsZWFudXAgPSBob29rLl92YWx1ZSgpO1xuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBvbGRBcmdzXG4gKiBAcGFyYW0ge2FueVtdfSBuZXdBcmdzXG4gKi9cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3MsIG5ld0FyZ3MpIHtcblx0cmV0dXJuIChcblx0XHQhb2xkQXJncyB8fFxuXHRcdG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzLmxlbmd0aCB8fFxuXHRcdG5ld0FyZ3Muc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcblx0KTtcbn1cblxuZnVuY3Rpb24gaW52b2tlT3JSZXR1cm4oYXJnLCBmKSB7XG5cdHJldHVybiB0eXBlb2YgZiA9PSAnZnVuY3Rpb24nID8gZihhcmcpIDogZjtcbn1cbiIsIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gb2JqZWN0cyBoYXZlIGEgZGlmZmVyZW50IHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKGxldCBpIGluIGEpIGlmIChpICE9PSAnX19zb3VyY2UnICYmICEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgYVtpXSAhPT0gYltpXSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbXBvbmVudCBjbGFzcyB3aXRoIGEgcHJlZGVmaW5lZCBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwKSB7XG5cdHRoaXMucHJvcHMgPSBwO1xufVxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG4vLyBTb21lIHRoaXJkLXBhcnR5IGxpYnJhcmllcyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IGlzIHByZXNlbnRcblB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwiaW1wb3J0IHsgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcblxuY29uc3QgbWFwRm4gPSAoY2hpbGRyZW4sIGZuKSA9PiB7XG5cdGlmIChjaGlsZHJlbiA9PSBudWxsKSByZXR1cm4gbnVsbDtcblx0cmV0dXJuIHRvQ2hpbGRBcnJheSh0b0NoaWxkQXJyYXkoY2hpbGRyZW4pLm1hcChmbikpO1xufTtcblxuLy8gVGhpcyBBUEkgaXMgY29tcGxldGVseSB1bm5lY2Vzc2FyeSBmb3IgUHJlYWN0LCBzbyBpdCdzIGJhc2ljYWxseSBwYXNzdGhyb3VnaC5cbmV4cG9ydCBjb25zdCBDaGlsZHJlbiA9IHtcblx0bWFwOiBtYXBGbixcblx0Zm9yRWFjaDogbWFwRm4sXG5cdGNvdW50KGNoaWxkcmVuKSB7XG5cdFx0cmV0dXJuIGNoaWxkcmVuID8gdG9DaGlsZEFycmF5KGNoaWxkcmVuKS5sZW5ndGggOiAwO1xuXHR9LFxuXHRvbmx5KGNoaWxkcmVuKSB7XG5cdFx0Y29uc3Qgbm9ybWFsaXplZCA9IHRvQ2hpbGRBcnJheShjaGlsZHJlbik7XG5cdFx0aWYgKG5vcm1hbGl6ZWQubGVuZ3RoICE9PSAxKSB0aHJvdyAnQ2hpbGRyZW4ub25seSc7XG5cdFx0cmV0dXJuIG5vcm1hbGl6ZWRbMF07XG5cdH0sXG5cdHRvQXJyYXk6IHRvQ2hpbGRBcnJheVxufTtcbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgcmVuZGVyIH0gZnJvbSAncHJlYWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vLi4vc3JjL2luZGV4JykuUmVuZGVyYWJsZVByb3BzPHsgY29udGV4dDogYW55IH0+fSBwcm9wc1xuICovXG5mdW5jdGlvbiBDb250ZXh0UHJvdmlkZXIocHJvcHMpIHtcblx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBwcm9wcy5jb250ZXh0O1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogUG9ydGFsIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gcHJvcHNcbiAqXG4gKiBUT0RPOiB1c2UgY3JlYXRlUm9vdCgpIGluc3RlYWQgb2YgZmFrZSByb290XG4gKi9cbmZ1bmN0aW9uIFBvcnRhbChwcm9wcykge1xuXHRjb25zdCBfdGhpcyA9IHRoaXM7XG5cdGxldCBjb250YWluZXIgPSBwcm9wcy5fY29udGFpbmVyO1xuXG5cdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmVuZGVyKG51bGwsIF90aGlzLl90ZW1wKTtcblx0XHRfdGhpcy5fdGVtcCA9IG51bGw7XG5cdFx0X3RoaXMuX2NvbnRhaW5lciA9IG51bGw7XG5cdH07XG5cblx0Ly8gV2hlbiB3ZSBjaGFuZ2UgY29udGFpbmVyIHdlIHNob3VsZCBjbGVhciBvdXIgb2xkIGNvbnRhaW5lciBhbmRcblx0Ly8gaW5kaWNhdGUgYSBuZXcgbW91bnQuXG5cdGlmIChfdGhpcy5fY29udGFpbmVyICYmIF90aGlzLl9jb250YWluZXIgIT09IGNvbnRhaW5lcikge1xuXHRcdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdH1cblxuXHQvLyBXaGVuIHByb3BzLnZub2RlIGlzIHVuZGVmaW5lZC9mYWxzZS9udWxsIHdlIGFyZSBkZWFsaW5nIHdpdGggc29tZSBraW5kIG9mXG5cdC8vIGNvbmRpdGlvbmFsIHZub2RlLiBUaGlzIHNob3VsZCBub3QgdHJpZ2dlciBhIHJlbmRlci5cblx0aWYgKHByb3BzLl92bm9kZSkge1xuXHRcdGlmICghX3RoaXMuX3RlbXApIHtcblx0XHRcdF90aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG5cblx0XHRcdC8vIENyZWF0ZSBhIGZha2UgRE9NIHBhcmVudCBub2RlIHRoYXQgbWFuYWdlcyBhIHN1YnNldCBvZiBgY29udGFpbmVyYCdzIGNoaWxkcmVuOlxuXHRcdFx0X3RoaXMuX3RlbXAgPSB7XG5cdFx0XHRcdG5vZGVUeXBlOiAxLFxuXHRcdFx0XHRwYXJlbnROb2RlOiBjb250YWluZXIsXG5cdFx0XHRcdGNoaWxkTm9kZXM6IFtdLFxuXHRcdFx0XHRhcHBlbmRDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0aW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmUpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZUNoaWxkKGNoaWxkKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnNwbGljZSh0aGlzLmNoaWxkTm9kZXMuaW5kZXhPZihjaGlsZCkgPj4+IDEsIDEpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIFJlbmRlciBvdXIgd3JhcHBpbmcgZWxlbWVudCBpbnRvIHRlbXAuXG5cdFx0cmVuZGVyKFxuXHRcdFx0Y3JlYXRlRWxlbWVudChDb250ZXh0UHJvdmlkZXIsIHsgY29udGV4dDogX3RoaXMuY29udGV4dCB9LCBwcm9wcy5fdm5vZGUpLFxuXHRcdFx0X3RoaXMuX3RlbXBcblx0XHQpO1xuXHR9XG5cdC8vIFdoZW4gd2UgY29tZSBmcm9tIGEgY29uZGl0aW9uYWwgcmVuZGVyLCBvbiBhIG1vdW50ZWRcblx0Ly8gcG9ydGFsIHdlIHNob3VsZCBjbGVhciB0aGUgRE9NLlxuXHRlbHNlIGlmIChfdGhpcy5fdGVtcCkge1xuXHRcdF90aGlzLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgUG9ydGFsYCB0byBjb250aW51ZSByZW5kZXJpbmcgdGhlIHZub2RlIHRyZWUgYXQgYSBkaWZmZXJlbnQgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gY29udGFpbmVyIFRoZSBET00gbm9kZSB0byBjb250aW51ZSByZW5kZXJpbmcgaW4gdG8uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQb3J0YWwodm5vZGUsIGNvbnRhaW5lcikge1xuXHRjb25zdCBlbCA9IGNyZWF0ZUVsZW1lbnQoUG9ydGFsLCB7IF92bm9kZTogdm5vZGUsIF9jb250YWluZXI6IGNvbnRhaW5lciB9KTtcblx0ZWwuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lcjtcblx0cmV0dXJuIGVsO1xufVxuIiwiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fGltYWdlfGxldHRlcnxsaWdodGluZ3xtYXJrZXIoPyFIfFd8VSl8b3ZlcmxpbmV8cGFpbnR8cG9pbnRlcnxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx0cmFuc2Zvcm18dW5kZXJsaW5lfHVuaWNvZGV8dW5pdHN8dnx2ZWN0b3J8dmVydHx3b3JkfHdyaXRpbmd8eCg/IUMpKVtBLVpdLztcblxuY29uc3QgSVNfRE9NID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLy8gSW5wdXQgdHlwZXMgZm9yIHdoaWNoIG9uY2hhbmdlIHNob3VsZCBub3QgYmUgY29udmVydGVkIHRvIG9uaW5wdXQuXG4vLyB0eXBlPVwiZmlsZXxjaGVja2JveHxyYWRpb1wiLCBwbHVzIFwicmFuZ2VcIiBpbiBJRTExLlxuLy8gKElFMTEgZG9lc24ndCBzdXBwb3J0IFN5bWJvbCwgd2hpY2ggd2UgdXNlIGhlcmUgdG8gdHVybiBgcmFkYCBpbnRvIGByYWAgd2hpY2ggbWF0Y2hlcyBcInJhbmdlXCIpXG5jb25zdCBvbkNoYW5nZUlucHV0VHlwZSA9IHR5cGUgPT5cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbCgpID09ICdzeW1ib2wnXG5cdFx0PyAvZmlsfGNoZXxyYWQvaVxuXHRcdDogL2ZpbHxjaGV8cmEvaVxuXHQpLnRlc3QodHlwZSk7XG5cbi8vIFNvbWUgbGlicmFyaWVzIGxpa2UgYHJlYWN0LXZpcnR1YWxpemVkYCBleHBsaWNpdGx5IGNoZWNrIGZvciB0aGlzLlxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8vIGBVTlNBRkVfKmAgbGlmZWN5Y2xlIGhvb2tzXG4vLyBQcmVhY3Qgb25seSBldmVyIGludm9rZXMgdGhlIHVucHJlZml4ZWQgbWV0aG9kcy5cbi8vIEhlcmUgd2UgcHJvdmlkZSBhIGJhc2UgXCJmYWxsYmFja1wiIGltcGxlbWVudGF0aW9uIHRoYXQgY2FsbHMgYW55IGRlZmluZWQgVU5TQUZFXyBwcmVmaXhlZCBtZXRob2QuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgaXRzIG93biBgY29tcG9uZW50RGlkTW91bnQoKWAgKGluY2x1ZGluZyB2aWEgZGVmaW5lUHJvcGVydHkpLCB1c2UgdGhhdC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBgVU5TQUZFX2NvbXBvbmVudERpZE1vdW50KClgLCBgY29tcG9uZW50RGlkTW91bnRgIGlzIHRoZSBhbGlhcyBnZXR0ZXIvc2V0dGVyLlxuLy8gLSBJZiBhbnl0aGluZyBhc3NpZ25zIHRvIGFuIGBVTlNBRkVfKmAgcHJvcGVydHksIHRoZSBhc3NpZ25tZW50IGlzIGZvcndhcmRlZCB0byB0aGUgdW5wcmVmaXhlZCBwcm9wZXJ0eS5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8xOTQxXG5bXG5cdCdjb21wb25lbnRXaWxsTW91bnQnLFxuXHQnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXG5cdCdjb21wb25lbnRXaWxsVXBkYXRlJ1xuXS5mb3JFYWNoKGtleSA9PiB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBrZXksIHtcblx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0Z2V0KCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbJ1VOU0FGRV8nICsga2V5XTtcblx0XHR9LFxuXHRcdHNldCh2KSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB2XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0pO1xufSk7XG5cbi8qKlxuICogUHJveHkgcmVuZGVyKCkgc2luY2UgUmVhY3QgcmV0dXJucyBhIENvbXBvbmVudCByZWZlcmVuY2UuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBWTm9kZSB0cmVlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnQgRE9NIG5vZGUgdG8gcmVuZGVyIHZub2RlIHRyZWUgaW50b1xuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBbY2FsbGJhY2tdIE9wdGlvbmFsIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgcmVuZGVyaW5nXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50IHwgbnVsbH0gVGhlIHJvb3QgY29tcG9uZW50IHJlZmVyZW5jZSBvciBudWxsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0Ly8gUmVhY3QgZGVzdHJveXMgYW55IGV4aXN0aW5nIERPTSBub2Rlcywgc2VlICMxNzI3XG5cdC8vIC4uLmJ1dCBvbmx5IG9uIHRoZSBmaXJzdCByZW5kZXIsIHNlZSAjMTgyOFxuXHRpZiAocGFyZW50Ll9jaGlsZHJlbiA9PSBudWxsKSB7XG5cdFx0cGFyZW50LnRleHRDb250ZW50ID0gJyc7XG5cdH1cblxuXHRwcmVhY3RSZW5kZXIodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudCwgY2FsbGJhY2spIHtcblx0cHJlYWN0SHlkcmF0ZSh2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5sZXQgb2xkRXZlbnRIb29rID0gb3B0aW9ucy5ldmVudDtcbm9wdGlvbnMuZXZlbnQgPSBlID0+IHtcblx0aWYgKG9sZEV2ZW50SG9vaykgZSA9IG9sZEV2ZW50SG9vayhlKTtcblx0ZS5wZXJzaXN0ID0gZW1wdHk7XG5cdGUuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBpc1Byb3BhZ2F0aW9uU3RvcHBlZDtcblx0ZS5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBpc0RlZmF1bHRQcmV2ZW50ZWQ7XG5cdHJldHVybiAoZS5uYXRpdmVFdmVudCA9IGUpO1xufTtcblxuZnVuY3Rpb24gZW1wdHkoKSB7fVxuXG5mdW5jdGlvbiBpc1Byb3BhZ2F0aW9uU3RvcHBlZCgpIHtcblx0cmV0dXJuIHRoaXMuY2FuY2VsQnViYmxlO1xufVxuXG5mdW5jdGlvbiBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG5cdHJldHVybiB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ7XG59XG5cbmxldCBjbGFzc05hbWVEZXNjcmlwdG9yID0ge1xuXHRjb25maWd1cmFibGU6IHRydWUsXG5cdGdldCgpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGFzcztcblx0fVxufTtcblxubGV0IG9sZFZOb2RlSG9vayA9IG9wdGlvbnMudm5vZGU7XG5vcHRpb25zLnZub2RlID0gdm5vZGUgPT4ge1xuXHRsZXQgdHlwZSA9IHZub2RlLnR5cGU7XG5cdGxldCBwcm9wcyA9IHZub2RlLnByb3BzO1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0gcHJvcHM7XG5cblx0Ly8gb25seSBub3JtYWxpemUgcHJvcHMgb24gRWxlbWVudCBub2Rlc1xuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG5cdFx0Y29uc3Qgbm9uQ3VzdG9tRWxlbWVudCA9IHR5cGUuaW5kZXhPZignLScpID09PSAtMTtcblx0XHRub3JtYWxpemVkUHJvcHMgPSB7fTtcblxuXHRcdGZvciAobGV0IGkgaW4gcHJvcHMpIHtcblx0XHRcdGxldCB2YWx1ZSA9IHByb3BzW2ldO1xuXG5cdFx0XHRpZiAoSVNfRE9NICYmIGkgPT09ICdjaGlsZHJlbicgJiYgdHlwZSA9PT0gJ25vc2NyaXB0Jykge1xuXHRcdFx0XHQvLyBFbXVsYXRlIFJlYWN0J3MgYmVoYXZpb3Igb2Ygbm90IHJlbmRlcmluZyB0aGUgY29udGVudHMgb2Ygbm9zY3JpcHQgdGFncyBvbiB0aGUgY2xpZW50LlxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ3ZhbHVlJyAmJiAnZGVmYXVsdFZhbHVlJyBpbiBwcm9wcyAmJiB2YWx1ZSA9PSBudWxsKSB7XG5cdFx0XHRcdC8vIFNraXAgYXBwbHlpbmcgdmFsdWUgaWYgaXQgaXMgbnVsbC91bmRlZmluZWQgYW5kIHdlIGFscmVhZHkgc2V0XG5cdFx0XHRcdC8vIGEgZGVmYXVsdCB2YWx1ZVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdGkgPT09ICdkZWZhdWx0VmFsdWUnICYmXG5cdFx0XHRcdCd2YWx1ZScgaW4gcHJvcHMgJiZcblx0XHRcdFx0cHJvcHMudmFsdWUgPT0gbnVsbFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGlzIHRyZWF0ZWQgYXMgYSBmYWxsYmFjayBgdmFsdWVgIHdoZW4gYSB2YWx1ZSBwcm9wIGlzIHByZXNlbnQgYnV0IG51bGwvdW5kZWZpbmVkLlxuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBmb3IgRWxlbWVudHMgd2l0aCBubyB2YWx1ZSBwcm9wIGlzIHRoZSBzYW1lIGFzIHRoZSBET00gZGVmYXVsdFZhbHVlIHByb3BlcnR5LlxuXHRcdFx0XHRpID0gJ3ZhbHVlJztcblx0XHRcdH0gZWxzZSBpZiAoaSA9PT0gJ2Rvd25sb2FkJyAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuXHRcdFx0XHQvLyBDYWxsaW5nIGBzZXRBdHRyaWJ1dGVgIHdpdGggYSB0cnV0aHkgdmFsdWUgd2lsbCBsZWFkIHRvIGl0IGJlaW5nXG5cdFx0XHRcdC8vIHBhc3NlZCBhcyBhIHN0cmluZ2lmaWVkIHZhbHVlLCBlLmcuIGBkb3dubG9hZD1cInRydWVcImAuIFJlYWN0XG5cdFx0XHRcdC8vIGNvbnZlcnRzIGl0IHRvIGFuIGVtcHR5IHN0cmluZyBpbnN0ZWFkLCBvdGhlcndpc2UgdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIGZpbGUgbmFtZSBhbmQgdGhlIGZpbGUgd2lsbCBiZSBjYWxsZWRcblx0XHRcdFx0Ly8gXCJ0cnVlXCIgdXBvbiBkb3dubG9hZGluZyBpdC5cblx0XHRcdFx0dmFsdWUgPSAnJztcblx0XHRcdH0gZWxzZSBpZiAoL29uZG91YmxlY2xpY2svaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25kYmxjbGljayc7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHQvXm9uY2hhbmdlKHRleHRhcmVhfGlucHV0KS9pLnRlc3QoaSArIHR5cGUpICYmXG5cdFx0XHRcdCFvbkNoYW5nZUlucHV0VHlwZShwcm9wcy50eXBlKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGkgPSAnb25pbnB1dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25mb2N1cyQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c2luJztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmJsdXIkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNvdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uKEFuaXxUcmF8VG91fEJlZm9yZUlucHxDb21wbykvLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAobm9uQ3VzdG9tRWxlbWVudCAmJiBDQU1FTF9QUk9QUy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnJlcGxhY2UoL1tBLVowLTldL2csICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAoL15vbmlucHV0JC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRcdGkgPSAnb25pbnB1dENhcHR1cmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0XHRpZiAoXG5cdFx0XHR0eXBlID09ICdzZWxlY3QnICYmXG5cdFx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRcdEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFByb3BzLnZhbHVlKVxuXHRcdCkge1xuXHRcdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0XHRpZiAodHlwZSA9PSAnc2VsZWN0JyAmJiBub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZub2RlLnByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IHByb3BzLmNsYXNzTmFtZTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxpemVkUHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIHtcblx0XHRvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xufTtcblxuLy8gVGhpcyBpcyBhIHZlcnkgdmVyeSBwcml2YXRlIGludGVybmFsIGZ1bmN0aW9uIGZvciBSZWFjdCBpdFxuLy8gaXMgdXNlZCB0byBzb3J0LW9mIGRvIHJ1bnRpbWUgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvIGZhclxuLy8gb25seSBgcmVhY3QtcmVsYXlgIG1ha2VzIHVzZSBvZiBpdC4gSXQgdXNlcyBpdCB0byByZWFkIHRoZVxuLy8gY29udGV4dCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHtcblx0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjoge1xuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHJlYWRDb250ZXh0KGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRDb21wb25lbnQuX2dsb2JhbENvbnRleHRbY29udGV4dC5faWRdLnByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IG9wdGlvbnMgfSBmcm9tIFwicHJlYWN0XCJcblxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcbmV4cG9ydCB0eXBlIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+ID0gKCh2YWx1ZTogVCwgcHJldlZhbHVlOiBUIHwgdW5kZWZpbmVkKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSkpO1xuXG4vKipcbiAqIERlYnVnIGhvb2suXG4gKiBcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXG4gKiBcbiAqIEV2ZW50dWFsbHksIHdoZW4gdXNlRXZlbnQgbGFuZHMsIHdlIGhvcGVmdWxseSB3b24ndCBuZWVkIHRoaXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbnN1cmVTdGFiaWxpdHk8VCBleHRlbmRzIGFueVtdPihwYXJlbnRIb29rTmFtZTogc3RyaW5nLCAuLi52YWx1ZXM6IFQpIHtcbiAgICB1c2VIZWxwZXIodmFsdWVzLmxlbmd0aCwgMCk7XG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcbiAgICByZXR1cm47XG5cblxuICAgIGZ1bmN0aW9uIHVzZUhlbHBlcjxVPih2YWx1ZTogVSwgaW5kZXg6IG51bWJlcikge1xuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICAgICAgY29uc3QgaGVscGVyVG9FbnN1cmVTdGFiaWxpdHkgPSB1c2VSZWYodmFsdWUpO1xuICAgICAgICBjb25zdCBzaG93bkVycm9yID0gdXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICghc2hvd25FcnJvci5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBUaGUgaG9vayAke3BhcmVudEhvb2tOYW1lfSByZXF1aXJlcyBzb21lIG9yIGFsbCBvZiBpdHMgYXJndW1lbnRzIHJlbWFpbiBzdGFibGUgYWNyb3NzIGVhY2ggcmVuZGVyOyBwbGVhc2UgY2hlY2sgdGhlICR7aW5kZXh9LWluZGV4ZWQgYXJndW1lbnQuYCk7XG4gICAgICAgICAgICAgICAgc2hvd25FcnJvci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlUmVuZGVyaW5nKGY6ICgpID0+IHZvaWQpIHtcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcbn1cblxuLyoqXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxuICogXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cbiAqIFxuICogVG8gc3VtbWFyaXplLCBpdCdzIGxpa2UgYSBgdXNlU3RhdGVgLWB1c2VFZmZlY3RgIG1hc2h1cDpcbiAqIFxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XG4gKiAyLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHlvdSBjYW4gcnVuIGEgZnVuY3Rpb24gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyB0aGF0IG9wdGlvbmFsbHkgcmV0dXJucyBhIGNsZWFudXAgZnVuY3Rpb25cbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXG4gKiBcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxuICogXG4gKiBAcGFyYW0gb25DaGFuZ2UgVGhlIFwiZWZmZWN0XCIgZnVuY3Rpb24gdG8gcnVuIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMuIEVmZmVjdGl2ZWx5IHRoZSBzYW1lIGFzIGB1c2VFZmZlY3RgJ3MgXCJlZmZlY3RcIiBmdW5jdGlvbi4gIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cbiAqIEBwYXJhbSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBCeSBkZWZhdWx0LCBjaGFuZ2VzIHRvIHBhc3NpdmUgc3RhdGUgYXJlIGRlbGF5ZWQgYnkgb25lIHRpY2sgc28gdGhhdCB3ZSBvbmx5IGNoZWNrIGZvciBjaGFuZ2VzIGluIGEgc2ltaWxhciB3YXkgdG8gUHJlYWN0LiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgdG8sIGZvciBleGFtcGxlLCBhbHdheXMgcnVuIGltbWVkaWF0ZWx5IGluc3RlYWQuXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBULCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZz86IHR5cGVvZiBkZWJvdW5jZVJlbmRlcmluZyk6IHJlYWRvbmx5IFtnZXRTdGF0ZVN0YWJsZTogKCkgPT4gVCwgc2V0U3RhdGVTdGFibGU6IFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD5dIHtcblxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcbiAgICBjb25zdCB3YXJuaW5nUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2tSZWYgPSB1c2VSZWY8dW5kZWZpbmVkIHwgKCgpID0+IHZvaWQpPih1bmRlZmluZWQpO1xuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVkIGZ1bmN0aW9ucyBhcmUgcGVyZmVjdGx5IHN0YWJsZSBhY3Jvc3MgcmVuZGVyc1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVBhc3NpdmVTdGF0ZVwiLCBvbkNoYW5nZSwgZ2V0SW5pdGlhbFZhbHVlLCBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyk7XG5cbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBcImRlcGVuZGVuY3kgY2hhbmdlZFwiIGFuZCBcImNvbXBvbmVudCB1bm1vdW50ZWRcIi5cbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xuICAgICAgICBpZiAoY2xlYW51cENhbGxiYWNrKVxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXG4gICAgLy8gVGhpcyBpcyB0aGUgc2hhcmVkIGNvZGUgZm9yIHRoYXQsIHVzZWQgb24gbW91bnQgYW5kIHdoZW5ldmVyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgJiYgZ2V0SW5pdGlhbFZhbHVlICE9IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gaW5pdGlhbFZhbHVlO1xuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcblxuXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJEdXJpbmcgb25DaGFuZ2UsIHByZWZlciB1c2luZyB0aGUgKHZhbHVlLCBwcmV2VmFsdWUpIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGdldFZhbHVlIC0tIGl0J3MgYW1iaWd1b3VzIGFzIHRvIGlmIHlvdSdyZSBhc2tpbmcgZm9yIHRoZSBvbGQgb3IgbmV3IHZhbHVlIGF0IHRoaXMgcG9pbnQgaW4gdGltZSBmb3IgdGhpcyBjb21wb25lbnQuXCIpO1xuXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcbiAgICAgICAgLy8gKGFuZCB3ZSB3ZXJlIGdpdmVuIGFuIGluaXRpYWwgdmFsdWUgdG8gdXNlKVxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXG4gICAgICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xuXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XG4gICAgfSwgW10pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3ZlIHJ1biBvdXIgZWZmZWN0IGF0IGxlYXN0IG9uY2Ugb24gbW91bnQuXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cbiAgICBjb25zdCByID0gdXNlUmVmKHsgcHJldkRlcDogVW5zZXQgYXMgVCB8ICh0eXBlb2YgVW5zZXQpIH0pO1xuICAgIGNvbnN0IHNldFZhbHVlID0gdXNlQ2FsbGJhY2s8UGFzc2l2ZVN0YXRlVXBkYXRlcjxUPj4oKGFyZykgPT4ge1xuXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxuICAgICAgICBjb25zdCBuZXh0VmFsdWUgPSAoYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQgOiB2YWx1ZVJlZi5jdXJyZW50KSA6IGFyZyk7XG5cblxuICAgICAgICBpZiAoci5jdXJyZW50LnByZXZEZXAgPT09IFVuc2V0ICYmIG5leHRWYWx1ZSAhPT0gdmFsdWVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcmVxdWVzdCB0byBjaGFuZ2UgdGhpcyB2YWx1ZS5cbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxuXG4gICAgICAgICAgICAvLyBTYXZlIG91ciBjdXJyZW50IHZhbHVlIHNvIHRoYXQgd2UgY2FuIGNvbXBhcmUgYWdhaW5zdCBpdCBsYXRlclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxuICAgICAgICAgICAgci5jdXJyZW50LnByZXZEZXAgPSB2YWx1ZVJlZi5jdXJyZW50O1xuXG4gICAgICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byB1cGRhdGUgdGhpcyBoZXJlIChhcyB3ZWxsIGFzIGJlbG93KSBpbiBjYXNlIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIGludm9rZXMgdGhpcyBpbW1lZGlhdGVseVxuICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIGFjdHVhbCBjaGVjayBhbmQgaW52b2NhdGlvbiBvZiBvbkNoYW5nZSBsYXRlciB0byBsZXQgZWZmZWN0cyBzZXR0bGVcbiAgICAgICAgICAgIChjdXN0b21EZWJvdW5jZVJlbmRlcmluZyA/PyBkZWJvdW5jZVJlbmRlcmluZykoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREZXAgPSB2YWx1ZVJlZi5jdXJyZW50ISBhcyBUO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZEZXAgPSByLmN1cnJlbnQucHJldkRlcCA7XG4gICAgICAgICAgICAgICAgaWYgKHIuY3VycmVudC5wcmV2RGVwICE9IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJlZCBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4obmV4dERlcCwgcHJldkRlcCA9PT0gVW5zZXQ/IHVuZGVmaW5lZCA6IHByZXZEZXApID8/IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cbiAgICAgICAgICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IFVuc2V0O1xuXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgcHJldkRlcCB0byBzZWUgaWYgd2Ugc2hvdWxkIGFjdHVhbGx5IGNhbGwgb25DaGFuZ2VcbiAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcbn1cblxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcblxuLy8gRWFzeSBjb25zdGFudHMgZm9yIGdldEluaXRpYWxWYWx1ZVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybk51bGwoKSB7IHJldHVybiBudWxsOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH0iLCJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcblxuXG4vKipcbiAqIFxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxuICogXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cbiAqICAgICogTm90aGluZyBpcyBmb2N1c2VkLCBidXQgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGBib2R5YC4gXG4gKiAgICAqIE5vIGZvY3VzIGV2ZW50cyBhcmUgZmlyZWQuXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxuICogICAgKiBBIGBmb2N1c2AvYGZvY3VzaW5gIGV2ZW50ICpNSUdIVCogYmUgZmlyZWQgZm9yIGBib2R5YC4gRGVwZW5kaW5nIG9uXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxuICogMy4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxuICogICAgKiBgZm9jdXNgIGFuZCBgZm9jdXNpbmAgYXJlIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cbiAqIDUuIEFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cbiAqICAgICogYGZvY3VzaW5gIGlzICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqIFxuICogXG4gKiBJbiBzdW1tYXJ5OlxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxuICogMi4gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgICppcyBub3QqIGFsd2F5cyB0aGUgc2FtZSBhcyB3aGF0J3MgYmVpbmcgcmVmZXJlbmNlZCBieSBhIGZvY3VzIGV2ZW50LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXkgYmVjb21lIGBib2R5YCBhdCBhbnkgYXJiaXRyYXJ5IHRpbWUuXG4gKiAzLiBBIGBibHVyYCB3aXRob3V0IGEgYGZvY3VzYCBjYW4gYW5kIHdpbGwgb2NjdXIuIFRoaXMgbWVhbnMgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHNvbGVseSB1c2UgYGZvY3VzYCB0byBkZXRlY3QgYWxsIGNoYW5nZXMuXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxuICogXG4gKi9cbmNvbnN0IF9kdW1teSA9IDA7XG5cbmludGVyZmFjZSBGb288VD4ge1xuICAgIGxhc3RTZW50OiBUIHwgdW5kZWZpbmVkO1xuICAgIHNlbmQ6IChlOiBUKSA9PiB2b2lkO1xufVxuLypcbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSB8IG51bGwpID0+IHZvaWQpPj4oKTtcbmNvbnN0IGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUpID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTsqL1xuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGUgfCBudWxsPj4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPE5vZGU+Pj4oKTtcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxib29sZWFuPj4+KCk7XG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xuXG4vL2NvbnN0IG1pY3JvdGFza3MgPSBuZXcgTWFwPFNldDxhbnk+LCBhbnk+KCk7XG5cbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxuLy8gRm9yIHRoZSBwdXJwb3NlIG9mIGltcHJvdmluZyBzdGFiaWxpdHksIHdlIGRlYm91bmNlIGFsbCBmb2N1cyBldmVudHMgdG8gdGhlIG5leHQgbWljcm90YXNrLlxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8Rm9vPFQ+Pj4sIHZhbHVlOiBUKSB7XG4gICAgY29uc3QgdXBkYXRlcnMgPSBtYXAuZ2V0KHdpbmRvdyk7XG4gICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgIC8vaWYgKCFtaWNyb3Rhc2tzLmhhcyh1cGRhdGVyc0tleSkpIHtcbiAgICAgICAgLy9kZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgIC8vY29uc3QgdXBkYXRlcnNLZXkgPSBtYXAuZ2V0KHdpbmRvdykhO1xuICAgICAgICAvL2NvbnN0IHZhbHVlID0gbWljcm90YXNrcy5nZXQodXBkYXRlcnNLZXkpO1xuICAgICAgICAvL21pY3JvdGFza3MuZGVsZXRlKHVwZGF0ZXJzS2V5KTtcblxuICAgICAgICBpZiAodXBkYXRlcnMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgbGFzdFNlbnQsIHNlbmQgfSA9IHVwZGF0ZXI7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBsYXN0U2VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZW5kKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlci5sYXN0U2VudCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vfSk7XG4gICAgICAgIC8vfVxuXG4gICAgICAgIC8vbWljcm90YXNrcy5zZXQodXBkYXRlcnNLZXksIHZhbHVlKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xuICAgICAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgbnVsbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBKdXN0IHdhaXQgZm9yIHRoZSBmb2N1c2luIGV2ZW50LlxuICAgIH1cblxufVxuXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gd2luZG93Rm9jdXMoZTogRm9jdXNFdmVudCkge1xuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIHRydWUpO1xufVxuXG5mdW5jdGlvbiB3aW5kb3dCbHVyKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgZmFsc2UpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIHtcblxuICAgIGFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7IFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzIGFuZCBpcyBub3QgbnVsbC4gXG4gICAgICAgICAqIE11c3QgYmUgc3RhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQ+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuPjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggd2hhdGV2ZXIgZWxlbWVudHMgd2UncmUgbGlzdGVuaW5nIHRvLlxuICAgICAgICAgKiBcbiAgICAgICAgICogRS5HLiBzb21lRGl2RWxlbWVudC5vd25lckRvY3VtZW50XG4gICAgICAgICAqIFxuICAgICAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGVcbiAgICAgICAgICovXG4gICAgICAgIGdldERvY3VtZW50KCk6IERvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBCeSBkZWZhdWx0LCBldmVudCBoYW5kbGVycyBhcmUgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50J3MgZGVmYXVsdFZpZXcgV2luZG93LlxuICAgICAgICAgKiBJZiB5b3UgbmVlZCBzb21ldGhpbmcgZGlmZmVyZW50LCBvdmVycmlkZSBpdCBoZXJlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogKipNVVNUKiogYmUgc3RhYmxlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRXaW5kb3c/KGRvY3VtZW50OiBEb2N1bWVudCk6IFdpbmRvdztcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuICAgIGFjdGl2ZUVsZW1lbnRSZXR1cm46IHtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIGBudWxsYCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIHdoYXRldmVyIGVsZW1lbnQgd2FzIG1vc3QgcmVjZW50bHkgZm9jdXNlZCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqL1xuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudDtcbiAgICAgICAgLyoqIFxuICAgICAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcbiAgICB9XG59XG5cbi8qKlxuICogQWxsb3dzIHlvdSB0byBpbnNwZWN0IHdoaWNoIGVsZW1lbnQgaW4gdGhlIGBkb2N1bWVudGAgY3VycmVudGx5IGhhcyBmb2N1cywgd2hpY2ggd2FzIG1vc3QgcmVjZW50bHkgZm9jdXNlZCBpZiBub25lIGFyZSBjdXJyZW50bHksIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgd2luZG93IGhhcyBmb2N1cyBieSByZXR1cm5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gKiAqIGBnZXRBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRMYXN0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0V2luZG93Rm9jdXNlZCgpYFxuICogXG4gKiAoVGhlIGRvY3VtZW50J3MgYm9keSByZWNlaXZpbmcgZm9jdXMsIGxpa2UgaXQgZG9lcyB3aGVuIHlvdSBjbGljayBvbiBhbiBlbXB0eSBhcmVhLCBpcyBjb3VudGVkIGFzIG5vIGVsZW1lbnQgaGF2aW5nIGZvY3VzIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMpXG4gKiBcbiAqIFRoaXMgaXMgYSBwYXNzaXZlIGhvb2ssIHNvIGJ5IGRlZmF1bHQgaXQgcmV0dXJucyBnZXR0ZXIgZnVuY3Rpb25zIHRoYXQgcmVwb3J0IHRoaXMgaW5mb3JtYXRpb24gYnV0IHRoZSBjb21wb25lbnQgd2lsbCBub3QgcmUtcmVuZGVyIGJ5IGRlZmF1bHQgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy5cbiAqIFxuICogSWYgeW91IG5lZWQgdGhlIGNvbXBvbmVudCB0byByZS1yZW5kZXIgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcywgdXNlIHRoZSBgb24qQ2hhbmdlYCBhcmd1bWVudHMgdG8gc2V0IHNvbWUgc3RhdGUgb24geW91ciBlbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KHsgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cgfSB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyk6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUFjdGl2ZUVsZW1lbnRcIiwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudCgpO1xuICAgICAgICBjb25zdCB3aW5kb3cgPSAoZ2V0V2luZG93Py4oZG9jdW1lbnQpID8/IGRvY3VtZW50Py5kZWZhdWx0Vmlldyk7XG5cbiAgICAgICAgaWYgKChhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdyk/LnNpemUgPz8gMCkgPT09IDApIHtcbiAgICAgICAgICAgIGRvY3VtZW50Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cywgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XG4gICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cbiAgICAgICAgY29uc3QgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xuXG4gICAgICAgIGNvbnN0IGxhZXUgPSB7IHNlbmQ6IHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPiwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9XG4gICAgICAgIGNvbnN0IGxsYWV1ID0geyBzZW5kOiBzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4sIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcbiAgICAgICAgY29uc3QgbHdmdSA9IHsgc2VuZDogc2V0V2luZG93Rm9jdXNlZCwgbGFzdFNlbnQ6IHVuZGVmaW5lZCB9O1xuXG4gICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsYWV1KTtcbiAgICAgICAgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsbGFldSk7XG4gICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChsd2Z1KTtcblxuICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XG4gICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xuICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobHdmdSk7XG5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCBmb2N1c2luKTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB3aW5kb3dCbHVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgW2dldEFjdGl2ZUVsZW1lbnQsIHNldEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQgfCBudWxsPihvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xuXG4gICAgcmV0dXJuIHsgYWN0aXZlRWxlbWVudFJldHVybjogeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9IH07XG59XG4iLCJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiB3aXRob3V0IGFsc28gbWFraW5nIGEgdXRpbGl0aWVzIGZpbGUuXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xuY29uc3QgdG9SdW4gPSBuZXcgTWFwPHN0cmluZywgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gb3B0aW9uc1tjb21taXROYW1lXSBhcyAodm5vZGU6IFZOb2RlLCBjb21taXRRdWV1ZTogQ29tcG9uZW50W10pID0+IHZvaWQ7XG5jb25zdCBuZXdDb21taXQ6IHR5cGVvZiBvcmlnaW5hbENvbW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IHByZXZpb3VzSW5wdXRzLmdldChpZCk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChvbGRJbnB1dHMsIGVmZmVjdEluZm8uaW5wdXRzKSkge1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cCA9IGVmZmVjdEluZm8uZWZmZWN0KCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5zZXQoaWQsIGVmZmVjdEluZm8uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1J1bi5jbGVhcigpO1xuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XG59XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cykge1xuXG4gICAgLyooKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gdXNlUmVmPHZvaWQgfCAoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcbiAgICAgICAgY29uc3QgcHJldkFyZ3NSZWYgPSB1c2VSZWY8SW5wdXRzPihudWxsISk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBwcmV2QXJnc1JlZi5jdXJyZW50ID0gaW5wdXRzITtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XG4gICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQgPSBlZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pKCk7Ki9cblxuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKCkpO1xuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3RcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCk6ICgpID0+IFQge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0sIFt2YWx1ZV0pO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIERvIG5vdCB1c2UgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UhICBgdXNlTGF5b3V0RWZmZWN0YCBpcyBmaW5lIHRob3VnaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KGZuOiBUKTogVCB7XG4gICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFQ+KGZuKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJnczogUGFyYW1ldGVyczxUPik6IFJldHVyblR5cGU8VD4gPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgfSwgW10pIGFzIFQ7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBub3c7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbnZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICByZXR1cm4gaW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRyaW1tZWRFbmRJbmRleDtcbiIsImltcG9ydCB0cmltbWVkRW5kSW5kZXggZnJvbSAnLi9fdHJpbW1lZEVuZEluZGV4LmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVHJpbTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG4iLCJpbXBvcnQgYmFzZVRyaW0gZnJvbSAnLi9fYmFzZVRyaW0uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9OdW1iZXI7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgbm93IGZyb20gJy4vbm93LmpzJztcbmltcG9ydCB0b051bWJlciBmcm9tICcuL3RvTnVtYmVyLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlYm91bmNlO1xuIiwiaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0aHJvdHRsZTtcbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogU2xpZ2h0bHkgZW5oYW5jZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgIHRoYXQgaW5jbHVkZXMgYSBnZXR0ZXIgdGhhdCByZW1haW5zIGNvbnN0YW50XG4gKiAoaS5lLiB5b3UgY2FuIHVzZSBpdCBpbiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGl0IGJlaW5nIGEgZGVwZW5kZW5jeSkuXG4gKiBcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlPFQ+KGluaXRpYWxTdGF0ZTogVCB8ICgoKSA9PiBUKSk6IHJlYWRvbmx5IFt2YWx1ZTogVCwgc2V0VmFsdWU6IFN0YXRlVXBkYXRlcjxUPiwgZ2V0VmFsdWU6ICgpID0+IFRdIHtcblxuICAgIC8vIFdlIGtlZXAgYm90aCwgYnV0IG92ZXJycmlkZSB0aGUgYHNldFN0YXRlYCBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZVBdID0gdXNlU3RhdGVQKGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHN0YXRlKTtcblxuICAgIC8vIEhpamFjayB0aGUgbm9ybWFsIHNldHRlciBmdW5jdGlvbiBcbiAgICAvLyB0byBhbHNvIHNldCBvdXIgcmVmIHRvIHRoZSBuZXcgdmFsdWVcbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFN0YXRlVXBkYXRlcjxUPj4odmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsdWUgYXMgKChfcHJldlZhbHVlOiBUKSA9PiBUKTtcbiAgICAgICAgICAgIHNldFN0YXRlUChwcmV2VmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IGNhbGxiYWNrKHByZXZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldFN0YXRlUCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xuXG5cbiAgICBjb25zb2xlLmFzc2VydChyZWYuY3VycmVudCA9PT0gc3RhdGUgfHwgKHR5cGVvZiBzdGF0ZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihzdGF0ZSkpKTtcbiAgICByZXR1cm4gW3N0YXRlLCBzZXRTdGF0ZSwgZ2V0U3RhdGVdIGFzIGNvbnN0O1xufSIsIlxuaW1wb3J0IGRlYm91bmNlLCB7IERlYm91bmNlZEZ1bmMsIHR5cGUgRGVib3VuY2VTZXR0aW5ncyB9IGZyb20gXCJsb2Rhc2gtZXMvZGVib3VuY2VcIjtcbmltcG9ydCB0aHJvdHRsZSwgeyB0eXBlIFRocm90dGxlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL3Rocm90dGxlXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG50eXBlIEZ1bmMgPSAoLi4uYXJnczogYW55KSA9PiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93bjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY1BhcmFtZXRlcnM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+IHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWRkcyBhIGRlYm91bmNlIGJlaGF2aW9yICppbiBhZGRpdGlvbiogdG9cbiAgICAgKiB0aGUgZGVmYXVsdCBcIndhaXQgdW50aWwgcmVzb2x2ZWRcIiB0aHJvdHRsaW5nIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGRlYm91bmNlPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgYHVzZUFzeW5jYCB3aXRoIGF1dG8tdGhyb3R0bGUgYmFzZWQgb24gaG93IGxvbmcgaXQgdGFrZXNcbiAgICAgKiBmb3IgdGhlIG9wZXJhdGlvbiB0byBjb21wbGV0ZS4gIElmIHlvdSB3b3VsZCBsaWtlIHRoZXJlIHRvIGJlIGFcbiAgICAgKiBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGFsbG93aW5nIGEgc2Vjb25kIG9wZXJhdGlvbixcbiAgICAgKiB0aGUgYHRocm90dGxlYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gYWRkaXRpb24gdG8gdGhhdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICB0aHJvdHRsZT86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYW4gYXN5bmMgZnVuY3Rpb24gaXMgZGVib3VuY2VkIGR1ZSB0byBvbmUgYWxyZWFkeSBydW5uaW5nLFxuICAgICAqIGl0IHdpbGwgcnVuIG9uIGEgZGVsYXkgYW5kLCBhcyBhIHJlc3VsdCwgdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuICAgICAqIHRoYXQgd2VyZSBwYXNzZWQgdG8gaXQgbWF5IG5lZWQgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb3VudCBmb3IgdGhhdC5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgZHVyaW5nIGBvbklucHV0YCwgdGhlIGB2YWx1ZWAgb2YgdGhhdCBldmVudCBpc24ndCBzdG9yZWRcbiAgICAgKiBpbiB0aGUgZXZlbnQgaXRzZWxmLCBpdCdzIHN0b3JlZCBpbiB0aGUgYEhUTUxJbnB1dEVsZW1lbnRgIHRoYXQgcmFpc2VkIGl0LlxuICAgICAqIFNvIHdoZW4gb3VyIGhhbmRsZXIgYWN0dWFsbHkgcnVucyBhIGZldyBzZWNvbmRzIGxhdGVyLCBpdCdsbCByZWFkIHRoZSAqKm5leHQqKlxuICAgICAqIGBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlYCwgaW5zdGVhZCBvZiB0aGUgb25lIGZyb20gYSBmZXcgc2Vjb25kcyBhZ28gXG4gICAgICogdGhhdCBhY3R1YWxseSByYWlzZWQgdGhlIGV2ZW50IVxuICAgICAqIFxuICAgICAqIElmIHRoZSBhcmd1bWVudHMgdG8geW91ciBoYW5kbGVyIHJlcXVpcmUgcmVmZXJlbmNpbmcgZGF0YSBpbiB0aGUgYXJndW1lbnRzXG4gICAgICogdGhhdCBtYXkgYmVjb21lIFwic3RhbGVcIiBieSB0aGUgdGltZSB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgcnVucyAoZ2VuZXJhbGx5IGV2ZW50XG4gICAgICogaGFuZGxlcnMgYW5kIG90aGVyIHRoaW5ncyB0aGF0IHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiBleGlzdGluZyBvYmplY3RzKSxcbiAgICAgKiB0aGUgYGNhcHR1cmVgIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSB0aGUgcGFyYW1ldGVycyB5b3Ugd2VyZSBnaXZlblxuICAgICAqIHdoZW4gdGhlIHJlcXVlc3QgdG8gcnVuIHdhcyBpbml0aWFsbHkgbWFkZSBpbnRvIHBhcmFtZXRlcnMgdGhhdCB5b3UgaGF2ZVxuICAgICAqIGd1YXJhbnRlZWQgd2lsbCBzdGlsbCBiZSBnb29kIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGFjdHVhbGx5IHJ1bnMuXG4gICAgICovXG4gICAgY2FwdHVyZT86IENhcHR1cmVGdW5jdGlvblR5cGU8QVAsIFNQPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY1JldHVyblR5cGU8U1AgZXh0ZW5kcyB1bmtub3duW10sIFI+IHtcblxuICAgIC8vcHJvbWlzZTogUHJvbWlzZTxBd2FpdGVkPFJldHVyblR5cGU8Rj4+PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGEgaGFuZGxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nLCB0aGlzIGlzIHRydWUuXG4gICAgICogXG4gICAgICogSXQgaXMgZmFsc2UgYmVmb3JlIHRoZSBmaXJzdCBleGVjdXRpb24sIHRydWUgZHVyaW5nIHRoZVxuICAgICAqIGZpcnN0IGV4ZWN1dGlvbiwgcmVtYWlucyB0cnVlIGlmIGNvbnRpbnVpbmcgaW1tZWRpYXRlbHlcbiAgICAgKiBpbnRvIGEgc2Vjb25kLCBhbmQgb25seSByZXR1cm5zIHRvIGZhbHNlIHdoZW4gYSBoYW5kbGVyXG4gICAgICogY29tcGxldGVzIHdpdGggbm8gaGFuZGxlciBpbiB3YWl0aW5nLlxuICAgICAqL1xuICAgIHBlbmRpbmc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBoYW5kbGVyIGhhcyBydW4uXG4gICAgICogRG9lcyBub3QgaW5jbHVkZSB0aW1lcyB3aGVyZSBpdCB3YXMgdGhyb3R0bGVkIG9yIGRlYm91bmNlZCBhd2F5LlxuICAgICAqIFxuICAgICAqIFVzZWZ1bCBmb3Iga25vd2luZyBpZiB0aGUgaGFuZGxlciBoYXMgYmVlbiBjYWxsZWQgeWV0LCBvciBmb3JcbiAgICAgKiBzZXR0aW5nIGEgbmV3IHRpbWVvdXQgdG8gc2hvdyBhIHNwaW5uZXIuXG4gICAgICovXG4gICAgY2FsbENvdW50OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBoYW5kbGVyIGhhcyBzZXR0bGVkXG4gICAgICogKHJlc29sdmVkIG9yIHJlamVjdGVkKSwgc2ltaWxhcmx5IHRvIGBjYWxsQ291bnRgLlxuICAgICAqIFxuICAgICAqIFVzZWZ1bCBmb3Iga25vd2luZyBpZiB0aGUgaGFuZGxlciBoYXMgY29tcGxldGVkIGV2ZW4gb25jZSB5ZXQsXG4gICAgICogb3IganVzdCBmb3Igd2hlbiB0aGUgaGFuZGxlciBoYXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBzZXR0bGVDb3VudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgXG4gICAgICogc2ltaWxhcmx5IHRvIGBzZXR0bGVDb3VudGAuXG4gICAgICovXG4gICAgcmVzb2x2ZUNvdW50OiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGZhaWxlZCB0byBjb21wbGV0ZSwgXG4gICAgICogc2ltaWxhcmx5IHRvIGByZXNvbHZlQ291bnRgLlxuICAgICAqL1xuICAgIHJlamVjdENvdW50OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IHJldHVybmVkIGZyb20gYSBzdWNjZXNzZnVsIGhhbmRsZXIgaW52b2NhdGlvbixcbiAgICAgKiBvciB1bmRlZmluZWQgaWYgbm8gaGFuZGxlciBoYXMgc3VjY2Vzc2Z1bGx5IHJldHVybmVkIHlldC5cbiAgICAgKiBcbiAgICAgKiBJZiB0aGUgaGFuZGxlciByZWplY3RzIGFmdGVyIGhhdmluZyBzdWNjZWVkZWQgcHJldmlvdXNseSwgdGhlblxuICAgICAqIGByZXN1bHRgIHdpbGwgc3RpbGwga2VlcCBpdHMgdmFsdWU7IGl0IHdvbid0IGJlIFwiZXJhc2VkXCIgZHVlIHRvIHRoZSBlcnJvci5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgYHJlc3VsdGAgYW5kIGBlcnJvcmAgY2FuIGJvdGggYmUgcG9wdWxhdGVkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICogXG4gICAgICogQHNlZSBoYXNSZXN1bHQgZm9yIGlmIGByZXN1bHRgIGJlaW5nIGB1bmRlZmluZWRgIG1lYW5zIGl0J3MgdW5maW5pc2hlZCBvciB0aGUgZnVuY3Rpb24gaXRzZWxmIHJldHVybmVkIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIHJlc3VsdDogUiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiB0aGUgbW9zdCByZWNlbnRseS1ydW4gaGFuZGxlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LFxuICAgICAqIGFsc28gbWVhbmluZyB0aGF0IHRoYXQgaXQncyByZXR1cm5lZCBhIHZhbHVlIHRoYXQgd2UgY3VycmVudGx5IGhhdmUuXG4gICAgICogXG4gICAgICogV2hpbGUgYHBlbmRpbmdgIGlzIHRydWUsICoqYGhhc1Jlc3VsdGAgYW5kIGBoYXNFcnJvcmAgbWF5IGJlIHNpbXVsdGFuZW91c2x5IHRydWUqKixcbiAgICAgKiBidXQgaW4gYWxsIG90aGVyIGNhc2VzIHRoZXkncmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAqL1xuICAgIGhhc1Jlc3VsdDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciB0aGUgaGFuZGxlciB0aHJldy4gYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB0aG91Z2ggbm90ZVxuICAgICAqIHRoYXQgYHVuZGVmaW5lZGAgaXMgYSB2YWxpZCB0aGluZyB0byB0aHJvdywgc28gY2hlY2sgYGhhc0Vycm9yYCB0b28uXG4gICAgICogXG4gICAgICogQHNlZSBoYXNFcnJvclxuICAgICAqL1xuICAgIGVycm9yOiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vc3QgcmVjZW50IGhhbmRsZXIgZmluaXNoZWQgd2l0aCBhbiBlcnJvci5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlLCB0ZWNobmljYWxseSwgYGVycm9yYCBjYW4gYmUgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgaGFzRXJyb3I6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSBhbnkgY3VycmVudGx5IGRlYm91bmNlZC1idXQtZXZlbnR1YWxseS1wZW5kaW5nIHByb21pc2VzIHRvIGltbWVkaWF0ZWx5IGJlIGNvbnNpZGVyZWQgYnkgY2FuY2VsbGluZyB0aGVpciBkZWJvdW5jZSB0aW1lb3V0LFxuICAgICAqIHlvdSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uLiAgTm9ybWFsIHByb2NlZHVyZSBhcHBsaWVzIGFzIGlmIHRoZSBkZWJvdW5jZWQgZW5kZWQgbm9ybWFsbHkgLS0gaWYgdGhlcmUncyBubyBwcm9taXNlIHdhaXRpbmcgaW4gdGhlIHF1ZXVlLFxuICAgICAqIHRoZSBkZWJvdW5jZWQgcHJvbWlzZSBydW5zIG5vcm1hbGx5LCBvdGhlcndpc2UsIGl0IHdhaXRzIGl0cyB0dXJuIHVudGlsIHRoZSBjdXJyZW50IG9uZSBlbmRzLCBwb3RlbnRpYWxseSBiZWluZyBvdmVyd3JpdHRlbiBsYXRlciBvblxuICAgICAqIGlmIGEgbmV3IHByb21pc2UgcnVucyBvdXQgKml0cyogZGVib3VuY2UgdGltZXIgYmVmb3JlIHRoaXMgb25lIGdvdCBhIGNoYW5jZSB0byBydW4uXG4gICAgICogXG4gICAgICogKipRdWFzaS1zdGFibGUqKiAoZG9uJ3QgdXNlIGR1cmluZyByZW5kZXIpXG4gICAgICovXG4gICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlOiAoKSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIHR5cGUgb2YgaGFuZGxlciBwYXNzZWQgaW4sIHRoaXMgcmV0dXJuZWQgdmFsdWUgd2lsbFxuICAgICAqIHJlcHJlc2VudCB3aGF0IHR5cGUgb2YgaGFuZGxlciBpdCB3YXMsIGp1c3QgaW4gY2FzZSB5b3VcbiAgICAgKiB5b3Vyc2VsZiBuZWVkIHRvIGtub3cgdGhhdCBhbmQgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsXG4gICAgICogdG8gZmluZCBvdXQgd2l0aG91dCBpdCBhY3R1YWxseSBiZWluZyBydW4uXG4gICAgICogXG4gICAgICogVW50aWwgYSBoYW5kbGVyIGlzIGNhbGxlZCwgdGhpcyB3aWxsIGJlIG51bGwuICBOYXR1cmFsbHksIGlmIFxuICAgICAqIGRpZmZlcmVudCBoYW5kbGVycyBhcmUgcGFzc2VkIGluLCBpdCBjYW4gZmxpcCBiYWNrIGFuZFxuICAgICAqIGZvcnRoIGJldHdlZW4gXCJhc3luY1wiIGFuZCBcInN5bmNcIiBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGN1cnJlbnRUeXBlOiBudWxsIHwgXCJzeW5jXCIgfCBcImFzeW5jXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiB0aGUgYXN5bmMgaGFuZGxlciBwcm92aWRlZCxcbiAgICAgKiBub3cgc3luY2hyb25vdXMgYW5kL29yIHRocm90dGxlZCBhbmQvb3IgZGVib3VuY2VkXG4gICAgICogXG4gICAgICogKipRdWFzaS1zdGFibGUqKiAoZG9uJ3QgdXNlIGR1cmluZyByZW5kZXIpXG4gICAgICovXG4gICAgc3luY0hhbmRsZXI6IFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eTxBUCBleHRlbmRzIHVua25vd25bXSwgU1AgZXh0ZW5kcyB1bmtub3duW10+KC4uLnQ6IFNQKSB7IHJldHVybiB0IGFzIHVua25vd25bXSBhcyBBUDsgfVxuXG4vKipcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbi5cbiAqIFxuICogSWYgdGhlIGNhbGxiYWNrIGlzIGBudWxsYCwgdGhlbiBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlIGBjYWxsYmFja2AgbXVzdCBiZSBzdGFibGUgZm9yIHRoaXMgdG8gd29yayBhcyBpbnRlbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VUaHJvdHRsZWQ8RiBleHRlbmRzIEZ1bmM+KGNhbGxiYWNrOiBGIHwgbnVsbCwgd2FpdDogbnVtYmVyLCBvcHRpb25zPzogVGhyb3R0bGVTZXR0aW5ncyk6IERlYm91bmNlZEZ1bmM8Rj4gfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xuICAgIGNvbnN0IHRocm90dGxlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB0aHJvdHRsZShjYWxsYmFjaywgd2FpdCwgb3B0aW9ucykgOiBudWxsO1xuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8udHJhaWxpbmddKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aHJvdHRsZWQ/LmNhbmNlbCgpO1xuICAgIH0sIFt0aHJvdHRsZWRdKVxuXG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgdGhlIGdpdmVuIChzdGFibGUpIGNhbGxiYWNrIHVzaW5nIExvZGFzaCdzIGBkZWJvdW5jZWRgIGZ1bmN0aW9uLlxuICogXG4gKiBJZiB0aGUgY2FsbGJhY2sgaXMgYG51bGxgLCB0aGVuIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgYGNhbGxiYWNrYCBtdXN0IGJlIHN0YWJsZSBmb3IgdGhpcyB0byB3b3JrIGFzIGludGVudGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiwgd2FpdDogbnVtYmVyLCBvcHRpb25zPzogRGVib3VuY2VTZXR0aW5ncyk6IERlYm91bmNlZEZ1bmM8Rj47XG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJvdW5jZWQ8RiBleHRlbmRzIEZ1bmM+KGNhbGxiYWNrOiBGIHwgbnVsbCwgd2FpdDogbnVtYmVyLCBvcHRpb25zPzogRGVib3VuY2VTZXR0aW5ncyk6IERlYm91bmNlZEZ1bmM8Rj4gfCBudWxsIHtcbiAgICBjb25zdCBkZWJvdW5jZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gZGVib3VuY2UoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcbiAgICB9LCBbY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnM/LmxlYWRpbmcsIG9wdGlvbnM/Lm1heFdhaXQsIG9wdGlvbnM/LnRyYWlsaW5nXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4gZGVib3VuY2VkPy5jYW5jZWwoKTtcbiAgICB9LCBbZGVib3VuY2VkXSlcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbnR5cGUgU3luY0Z1bmN0aW9uVHlwZTxTUCBleHRlbmRzIHVua25vd25bXSwgUj4gPSAoLi4uYXJnczogU1ApID0+IChSIHwgdW5kZWZpbmVkKTtcbnR5cGUgQXN5bmNGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKCguLi5hcmdzOiBBUCkgPT4gKFIgfCBQcm9taXNlPFI+KSk7XG50eXBlIEdsdWVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKGVucXVldWU6IGJvb2xlYW4sIC4uLmFyZ3M6IEFQKSA9PiBSIHwgdW5kZWZpbmVkO1xudHlwZSBDYXB0dXJlRnVuY3Rpb25UeXBlPEFQIGV4dGVuZHMgdW5rbm93bltdLCBTUCBleHRlbmRzIHVua25vd25bXSA9IEFQPiA9ICguLi5hcmdzOiBTUCkgPT4gQVA7XG5cbi8qKlxuICogR2l2ZW4gYW4gYXN5bmMgZnVuY3Rpb24sIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0J3Mgc3VpdGFibGUgZm9yIG5vbi1hc3luYyBBUElzLCBcbiAqIGFsb25nIHdpdGggb3RoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcnVuJ3Mgc3RhdHVzLlxuICogXG4gKiBTZWUgYWxzbyBgdXNlQXN5bmNIYW5kbGVyYCBmb3IgYSB2ZXJzaW9uIHRoYXQncyBzcGVjaWFsaXplZCBmb3IgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBXaGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBxdWljayBzdWNjZXNzaW9uLCAoaS5lLiBiZWZvcmUgdGhlIGhhbmRsZXIgaGFzIGZpbmlzaGVkKSwgXG4gKiB0aGlzIHdvcmtzIGxpa2UgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbiB3aXRoIHRoZSBgd2FpdGAgb3B0aW9uIGFsd2F5c1xuICogc2V0IHRvIGhvd2V2ZXIgbG9uZyB0aGUgaGFuZGxlciB0YWtlcyB0byBjb21wbGV0ZS4gQSBzZWNvbmQgY2FsbCB0byB0aGUgc3luYyBmdW5jdGlvbiB3aWxsIGJlIFxuICogdGhyb3R0bGVkIHVudGlsIHRoZSBmaXJzdCBjYWxsIGhhcyBmaW5pc2hlZC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBcbiAqIG9mIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uLCBvciBgdW5kZWZpbmVkYCBvbiB0aGUgZmlyc3QgY2FsbC5cbiAqIFxuICogVGhlIGhhbmRsZXIgaXMgb25seSBldmVyIGRlbGF5ZWQgaWYgb25lIGlzIGN1cnJlbnRseSBydW5uaW5nLCBzbywgZS5nLiBmb3IgaU9TIHRvdWNoIGV2ZW50cyB0aGVcbiAqIGZpcnN0IGNhbGwgaGFwcGVucyBpbiB0aGUgc2FtZSBldmVudCBoYW5kbGVyICh3aGljaCBtZWFucyB0aGluZ3MgbGlrZSBjYWxscyB0byBgZWxlbWVudC5mb2N1cygpYFxuICogd2lsbCB3b3JrIGFzIGludGVuZGVkLCBzaW5jZSB0aGF0IGZhaWxzIHdoZW4gdGhlIGV2ZW50IGlzIFwic3BsaXQgdXBcIilcbiAqIFxuICogRmluYWxseSwgYmVjYXVzZSB0aGUgc3luYyBoYW5kbGVyIG1heSBiZSBpbnZva2VkIG9uIGEgZGVsYXksIGFueSBwcm9wZXJ0eSByZWZlcmVuY2VzIG9uIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIG1pZ2h0IGJlIHN0YWxlIGJ5IHRoZSB0aW1lIGl0J3MgYWN0dWFsbHkgaW52b2tlZCAoZS5nLiBhY2Nlc3NpbmcgYGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZGBcbiAqIGlzIG5vdCBzdGFibGUgYWNyb3NzIHRpbWUgYmVjYXVzZSBpdCdzIGEgXCJsaXZlXCIgdmFsdWUgLS0geW91IGFsbW9zdCBhbHdheXMgd2FudCB0aGUgdmFsdWUgdGhhdCBpdFxuICogaGFkIGF0IHRoZSBvcmlnaW5hbCB0aW1lIHRoZSBoYW5kbGVyIHdhcyBjYWxsZWQpLiBUaGUgYGNhcHR1cmVgIG9wdGlvbiBhbGxvd3MgeW91IHRvIHNhdmUgdGhhdCBraW5kIG9mXG4gKiBkeW5hbWljIGRhdGEgYXQgdGhlIHRpbWUgaXQgcnVuczsgdGhlIGBBUGAgYW5kIGBTUGAgdHlwZSBwYXJhbWV0ZXJzIGxpa2V3aXNlIGNvbnRyb2xcbiAqIHRoZSBwYXJhbWV0ZXJzIHRoZSBhc3luYyBoYW5kbGVyIGFuZCBzeW5jIGhhbmRsZXIgZXhwZWN0IHJlc3BlY3RpdmVseS5cbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFIsIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+KGFzeW5jSGFuZGxlcjogQXN5bmNGdW5jdGlvblR5cGU8QVAsIFI+IHwgbnVsbCwgb3B0aW9ucz86IFVzZUFzeW5jUGFyYW1ldGVyczxBUCwgU1A+KTogVXNlQXN5bmNSZXR1cm5UeXBlPFNQLCBSPiB7XG5cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xuICAgIGxldCB7IHRocm90dGxlLCBkZWJvdW5jZSwgY2FwdHVyZSB9ID0gKG9wdGlvbnMgPz8ge30pO1xuICAgIGNhcHR1cmUgPz89IGlkZW50aXR5O1xuXG4gICAgLy8gV2Uga2VlcCwgbGlrZSwgYSBsb3Qgb2YgcmVuZGVyLXN0YXRlLCBidXQgaXQgb25seSBldmVyIHRyaWdnZXJzIGEgcmUtcmVuZGVyXG4gICAgLy8gd2hlbiB3ZSBzdGFydC9zdG9wIGFuIGFzeW5jIGFjdGlvbi5cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBmb3IgdGhlIGNhbGxlcidzIHNha2UgLS0gd2UgZG9uJ3QgcmVhbGx5IGNhcmUuXG4gICAgY29uc3QgW2N1cnJlbnRUeXBlLCBzZXRDdXJyZW50VHlwZV0gPSB1c2VTdGF0ZTxudWxsIHwgXCJzeW5jXCIgfCBcImFzeW5jXCI+KG51bGwpO1xuICAgIGNvbnN0IFtydW5Db3VudCwgc2V0UnVuQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3NldHRsZUNvdW50LCBzZXRTZXR0bGVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBbcmVzb2x2ZUNvdW50LCBzZXRSZXNvbHZlQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3JlamVjdENvdW50LCBzZXRSZWplY3RDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIC8vIFRoaW5ncyByZWxhdGVkIHRvIGN1cnJlbnQgZXhlY3V0aW9uXG4gICAgLy8gQmVjYXVzZSB3ZSBjYW4gYm90aCByZXR1cm4gYW5kIHRocm93IHVuZGVmaW5lZCwgXG4gICAgLy8gd2UgbmVlZCBzZXBhcmF0ZSBzdGF0ZSB0byB0cmFjayB0aGVpciBleGlzdGFuY2UgdG9vLlxuICAgIGNvbnN0IFtwZW5kaW5nLCBzZXRQZW5kaW5nLCBnZXRQZW5kaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHQsIGdldFJlc3VsdF0gPSB1c2VTdGF0ZTxSPih1bmRlZmluZWQhKTtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yLCBfZ2V0RXJyb3JdID0gdXNlU3RhdGU8dW5rbm93bj4odW5kZWZpbmVkISk7XG4gICAgY29uc3QgW2hhc0Vycm9yLCBzZXRIYXNFcnJvciwgX2dldEhhc0Vycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaGFzUmVzdWx0LCBzZXRIYXNSZXN1bHQsIF9nZXRIYXNSZXN1bHRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gV2UgaW1wbGVtZW50IG91ciBvd24gdGhyb3R0bGluZyBiZWhhdmlvciBpbiByZWdhcmRzIHRvIHdhaXRpbmcgdW50aWwgdGhlIGFzeW5jIGhhbmRsZXIgZmluaXNoZXMuXG4gICAgLy8gVGhlc2UgdHdvIHBhc3NpdmUgc3RhdGUgdmFyaWFibGVzIGtlZXAgdHJhY2sgb2YgdGhhdCwgYXV0b21hdGljYWxseSBxdWV1ZWluZy9kZXF1ZXVpbmcgdGhlIG5leHQgaGFuZGxlci5cbiAgICBjb25zdCBbZ2V0UXVldWVkLCBzZXRRdWV1ZWRdID0gdXNlUGFzc2l2ZVN0YXRlPEFQIHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XG5cblxuICAgIC8vIFRoZSBhY3R1YWwgc3luYyBoYW5kbGVyLlxuICAgIC8vIENhcHR1cmUvdHJhbnNmb3JtIHRoZSBnaXZlbiBwYXJhbWV0ZXJzIGlmIGFwcGxpY2FibGUsXG4gICAgLy8gdGhlbiBydW4gZnVydGhlciBsb2dpYyB0aGF0J3MgZGVib3VuY2VkL3Rocm90dGxlZFxuICAgIGNvbnN0IGNhcHR1cmVBcmdzQW5kRXhlY3V0ZURlYm91bmNlZEhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjazxTeW5jRnVuY3Rpb25UeXBlPFNQLCBSPj4oZnVuY3Rpb24gb25OZXdFeGVjdXRlUmVxdWVzdCguLi5uZXdBcmdzMjogU1ApIHtcblxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBhcmd1bWVudHMgd2Ugd2VyZSBnaXZlbi5cbiAgICAgICAgLy8gV2UgbWlnaHQgdXNlIHRoZW0gaW1tZWRpYXRlbHksIG9yIHdlIG1pZ2h0IHN0b3JlIHRoZW0gdG8gYHF1ZXVlZGAsXG4gICAgICAgIC8vIGJ1dCBpbiBlaXRoZXIgY2FzZSB3ZSBkbyBuZWVkIHRoZSBjYXB0dXJlZCB2YWx1ZS5cbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlISguLi5uZXdBcmdzMik7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhbGwgbG9naWMgdGhhdCBkZWFscyB3aXRoIHRoZSBjYXB0dXJlZCB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSByYXcgYXJndW1lbnRzLlxuICAgICAgICAvLyBJdCdzIGNhbGxlZCBpbiB0d28gc2VwYXJhdGUgY2lyY3Vtc3RhbmNlcyxcbiAgICAgICAgLy8gYW5kIGhhcyB0aGUgZGVib3VuY2UvdGhyb3R0bGUgbG9naWMgYWxyZWFkeSBhcHBsaWVkXG4gICAgICAgIHJldHVybiBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZShnZXRQZW5kaW5nKCksIC4uLmNhcHR1cmVkKTtcblxuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbG9naWMgdGhhdCBydW5zIHdoZW4gdGhlIGhhbmRsZXIgaXMgKmp1c3QqIGFib3V0IHRvIHN0YXJ0LlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXRzZWxmIGlzIGZ1cnRoZXIgdHJhbnNmb3JtZWQgdG8gYmUgdGhyb3R0bGVkL2RlYm91bmNlZCBpZiByZXF1ZXN0ZWQsXG4gICAgLy8gc28gdGhpcyBtaWdodCBub3QgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIFxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlID0gdXNlU3RhYmxlQ2FsbGJhY2s8R2x1ZUZ1bmN0aW9uVHlwZTxBUCwgUj4+KGZ1bmN0aW9uIG9uTmV3RXhlY3V0ZVJlcXVlc3QyKGVucXVldWU6IGJvb2xlYW4sIC4uLm5ld0FyZ3M6IEFQKSB7XG5cbiAgICAgICAgY29uc3Qgb25UaGVuID0gKHZhbHVlOiBSKSA9PiB7IHNldFJlc3VsdCh2YWx1ZSk7IHNldEhhc1Jlc3VsdCh0cnVlKTsgc2V0SGFzRXJyb3IoZmFsc2UpOyBzZXRSZXNvbHZlQ291bnQociA9PiArK3IpOyB9O1xuICAgICAgICBjb25zdCBvbkNhdGNoID0gKGV4OiBhbnkpID0+IHsgc2V0RXJyb3IoZXgpOyBzZXRIYXNFcnJvcih0cnVlKTsgc2V0SGFzUmVzdWx0KGZhbHNlKTsgc2V0UmVqZWN0Q291bnQociA9PiArK3IpOyB9O1xuICAgICAgICBjb25zdCBvbkZpbmFsbHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZWQgPSBnZXRRdWV1ZWQoKTtcbiAgICAgICAgICAgIHNldFNldHRsZUNvdW50KHMgPT4gKytzKTtcbiAgICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRRdWV1ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZmFsc2UsIC4uLnF1ZXVlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZW5xdWV1ZSkge1xuICAgICAgICAgICAgLy8gTm90aGluZyBpcyBwZW5kaW5nIGF0IHRoZSBtb21lbnQsIHNvIHdlIGNhbiBydW4gb3VyIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgc2V0UnVuQ291bnQociA9PiArK3IpO1xuICAgICAgICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzeW5jSGFuZGxlcj8uKC4uLm5ld0FyZ3MpIGFzIFI7XG4gICAgICAgICAgICBjb25zdCBpc1Byb21pc2UgPSAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIChyZXN1bHQgYXMgdW5rbm93biBhcyBQcm9taXNlPGFueT4pKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCAhaXNQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBzeW5jaHJvbm91cyBhbmQgcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGVhcmx5LlxuICAgICAgICAgICAgICAgIG9uVGhlbihyZXN1bHQgYXMgUik7XG4gICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHJlc3VsdCBhcyB1bmtub3duIGFzIFByb21pc2U8Uj4pLnRoZW4ob25UaGVuKS5jYXRjaChvbkNhdGNoKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJhc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgc3RpbGwgcnVubmluZyBhIHByZXZpb3VzIGhhbmRsZXIsXG4gICAgICAgICAgICAvLyBqdXN0IHNldCBvdXJzZWx2ZXMgYXMgdGhlIG5leHQgb25lIHRvIHJ1biBhbmQgcXVpdCBlYXJseS5cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgbW9yZSB0byBkby5cbiAgICAgICAgICAgIHNldFF1ZXVlZChuZXdBcmdzKTtcbiAgICAgICAgfVxuXG5cblxuXG4gICAgICAgIHJldHVybiBnZXRSZXN1bHQoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPSB1c2VUaHJvdHRsZWQ8Tm9uTnVsbGFibGU8dHlwZW9mIGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlPj4oIXRocm90dGxlID8gbnVsbCA6IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlLCB0aHJvdHRsZSA/PyAwKTtcbiAgICBjb25zdCBleGVjdXRlSGFuZGxlcldpdGhEID0gdXNlRGVib3VuY2VkKCFkZWJvdW5jZSA/IG51bGwgOiAoZXhlY3V0ZUhhbmRsZXJXaXRoVCA/PyBleGVjdXRlSGFuZGxlcldpdGhvdXREZWJvdW5jZSksIGRlYm91bmNlID8/IDApO1xuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aERlYm91bmNlID0gKGV4ZWN1dGVIYW5kbGVyV2l0aEQgPz8gZXhlY3V0ZUhhbmRsZXJXaXRoVCA/PyBleGVjdXRlSGFuZGxlcldpdGhvdXREZWJvdW5jZSk7XG5cbiAgICBjb25zdCBmbHVzaERlYm91bmNlZFByb21pc2UgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZSAmJiBcImZsdXNoXCIgaW4gZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UpXG4gICAgICAgICAgICBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZS5mbHVzaCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3luY0hhbmRsZXI6IGNhcHR1cmVBcmdzQW5kRXhlY3V0ZURlYm91bmNlZEhhbmRsZXIsXG4gICAgICAgIGN1cnJlbnRUeXBlLFxuICAgICAgICBwZW5kaW5nLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBoYXNFcnJvcixcbiAgICAgICAgaGFzUmVzdWx0LFxuICAgICAgICByZXNvbHZlQ291bnQsXG4gICAgICAgIHJlamVjdENvdW50LFxuICAgICAgICBzZXR0bGVDb3VudCxcbiAgICAgICAgY2FsbENvdW50OiBydW5Db3VudCxcbiAgICAgICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlXG4gICAgfVxuXG5cbn1cbiIsImltcG9ydCB7IHVzZUFzeW5jLCBVc2VBc3luY1BhcmFtZXRlcnMsIFVzZUFzeW5jUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1hc3luY1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5leHBvcnQgdHlwZSBBc3luY0hhbmRsZXI8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQsIENhcHR1cmVUeXBlPiA9ICgoYzogQ2FwdHVyZVR5cGUsIGU6IEV2ZW50VHlwZSkgPT4gKFByb21pc2U8dm9pZD4gfCB2b2lkKSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNIYW5kbGVyUGFyYW1ldGVyczxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudCwgQ2FwdHVyZVR5cGU+IGV4dGVuZHMgT21pdDxVc2VBc3luY1BhcmFtZXRlcnM8W0NhcHR1cmVUeXBlLCBFdmVudFR5cGVdLCBbRXZlbnRUeXBlXT4sIFwiY2FwdHVyZVwiPiB7XG4gICAgLyoqXG4gICAgICogV2hhdCB0cmFuc2llbnQgaW5mb3JtYXRpb24gaXMgY2FwdHVyZWQgYnkgdGhpcyBldmVudCBcbiAgICAgKiBhbmQgcHJlc2VudGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgZXZlbnQgaGFuZGxlcj9cbiAgICAgKiBcbiAgICAgKiBUaGUgXCJjYXB0dXJlXCIgcGFyYW1ldGVyIGFuc3dlcnMgdGhpcyBxdWVzdGlvbi4gVG8gaW1wbGVtZW50IGEgY2hlY2tib3gsIGZvciBleGFtcGxlLCByZXR1cm4gYHRhcmdldC5jaGVja2VkYC5cbiAgICAgKi9cbiAgICBjYXB0dXJlOiAoZXZlbnQ6IEV2ZW50VHlwZSkgPT4gQ2FwdHVyZVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gKGVpdGhlciBhc3luYyBvciBzeW5jKSB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnQgdG8gYSByZWd1bGFyLCBzeW5jIGV2ZW50IGhhbmRsZXIuIFxuICAgICAqL1xuICAgIGFzeW5jSGFuZGxlcjogQXN5bmNIYW5kbGVyPEV2ZW50VHlwZSwgQ2FwdHVyZVR5cGU+IHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY0hhbmRsZXJSZXR1cm5UeXBlPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4gZXh0ZW5kcyBVc2VBc3luY1JldHVyblR5cGU8W0V2ZW50VHlwZV0sIHZvaWQ+IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudGx5IGNhcHR1cmVkIHZhbHVlLiBJbiBvdGhlciB3b3JkcywgcmVwcmVzZW50cyB3aGF0XG4gICAgICogdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgYmUgaWYgdGhpcyBvcGVyYXRpb24gd2VyZSBzeW5jaHJvbm91cyBhbmQgXG4gICAgICogYW5kIGNvdWxkbid0IGZhaWwuIEl0J3MgdXNlZnVsIHRvIHByZXRlbmQgdGhpcyBpcyB0aGUgYWN0dWFsIHZhbHVlXG4gICAgICogZm9yIGFuIGlucHV0IGZpZWxkLCBmb3IgZXhhbXBsZSwgc28gdGhhdCB0aGUgdmFsdWUgZG9lc24ndCBcInNuYXBcbiAgICAgKiBiYWNrXCIgd2hpbGUgeW91J3JlIHdhaXRpbmcgZm9yIHRoZSBoYW5kbGVyIHRvIGZpbmlzaC5cbiAgICAgKiBcbiAgICAgKiBTb21ldGhpbmcgbGlrZSBgdmFsdWU9e3BlbmRpbmc/IGN1cnJlbnRDYXB0dXJlIDogdmFsdWV9YCBpcyBnb29kIGZvciBjaGVja2JveGVzLFxuICAgICAqIHNvbWV0aGluZyBsaWtlIGB2YWx1ZT17KHBlbmRpbmcgfHwgaGFzRm9jdXMpPyBjdXJyZW50Q2FwdHVyZSA6IHZhbHVlfSBmb3IgdGV4dCBmaWVsZHMuXG4gICAgICogXG4gICAgICogQHNlZSBoYXNDYXB0dXJlXG4gICAgICovXG4gICAgY3VycmVudENhcHR1cmU6IENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqIFxuICAgICAqIFRoZSBhYm92ZSwgYnV0IHN0YWJsZSwgaWYgeW91IG5lZWQgdGhlIGN1cnJlbnQgY2FwdHVyZSB3aXRob3V0IGl0IGJlaW5nIGFuIGV4cGxpY2l0IGRlcGVuZGVuY3kuXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqICAqL1xuICAgIGdldEN1cnJlbnRDYXB0dXJlKCk6IChDYXB0dXJlVHlwZSB8IHVuZGVmaW5lZCk7XG5cbiAgICAvKipcbiAgICAgKiBCZWNhdXNlIHlvdSdyZSBhbGxvd2VkIHRvIGhhdmUgYENhcHR1cmVUeXBlYCBleHRlbmQgYHVuZGVmaW5lZGAsXG4gICAgICogeW91IG1pZ2h0IG5lZWQgdGhpcy5cbiAgICAgKi9cbiAgICBoYXNDYXB0dXJlOiBib29sZWFuO1xuXG4gICAgLy8gU2FtZSBhcyBpbiB1c2VBc3luYywgYnV0IHdpdGggYSBkaWZmZXJlbnQgdHlwZVxuICAgIC8vcHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGw7XG5cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhc3luY3Jvbm91cyBldmVudCBoYW5kbGVyLCByZXR1cm5zIGEgc3luY3Jvbm91cyBvbmUgdGhhdCB3b3JrcyBvbiB0aGUgRE9NLFxuICogYWxvbmcgd2l0aCBzb21lIG90aGVyIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBEb2VzIG5vdCBtb2RpZnkgYW55IHByb3BzLlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB0aGUgaGFuZGxlciB5b3UgcHJvdmlkZSBtYXkgYmUgY2FsbGVkIHdpdGggYSBkZWxheSwgYW5kIFxuICogYmVjYXVzZSB0aGUgdmFsdWUgb2YsIGUuZy4sIGFuIGA8aW5wdXQ+YCBlbGVtZW50IHdpbGwgbGlrZWx5IGJlIHN0YWxlIGJ5IHRoZSBcbiAqIHRpbWUgdGhlIGRlbGF5IGlzIG92ZXIsIGEgYGNhcHR1cmVgIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBcbiAqIGNhcHR1cmUgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gQW55IG90aGVyIHNpbXBsZSBldmVudCBkYXRhLCBcbiAqIGxpa2UgYG1vdXNlWGAgb3IgYHNoaWZ0S2V5YCBjYW4gc3RheSBvbiB0aGUgZXZlbnQgaXRzZWxmIGFuZCBkb24ndCBcbiAqIG5lZWQgdG8gYmUgY2FwdHVyZWQgJm5kYXNoOyBpdCdzIG5ldmVyIHN0YWxlLlxuICogXG4gKiBgYGB0c3hcbiAqIGNvbnN0IGFzeW5jT25JbnB1dCA9IGFzeW5jICh2YWx1ZTogbnVtYmVyLCBlOiBFdmVudCkgPT4geyBcbiAqICAgICBbLi4uXSAvLyBFeC4gc2VuZCB0byBhIHNlcnZlciBhbmQgc2V0U3RhdGUgd2hlbiBkb25lXG4gKiB9O1xuICogY29uc3Qge1xuICogICAgIC8vIEEgc3luYyB2ZXJzaW9uIG9mIGFzeW5jT25JbnB1dFxuICogICAgIHN5bmNIYW5kbGVyLFxuICogICAgIC8vIFRydWUgd2hpbGUgdGhlIGhhbmRsZXIgaXMgcnVubmluZ1xuICogICAgIHBlbmRpbmcsXG4gKiAgICAgLy8gVGhlIGVycm9yIHRocm93biwgaWYgYW55XG4gKiAgICAgZXJyb3IsXG4gKiAgICAgLy8gU2hvdyB0aGlzIHZhbHVlIHdoaWxlIHRoZSBvcGVyYXRpb24ncyBwZW5kaW5nXG4gKiAgICAgY3VycmVudENhcHR1cmUsXG4gKiAgICAgLy8gQW5kIG90aGVycywgc2VlIGBVc2VBc3luY0hhbmRsZXJSZXR1cm5UeXBlYFxuICogICAgIC4uLnJlc3RcbiAqIH0gPSB1c2VBc3luY0hhbmRsZXI8SFRNTElucHV0RWxlbWVudD4oKShhc3luY09uSW5wdXQsIHsgXG4gKiAgICAgLy8gUGFzcyBpbiB0aGUgY2FwdHVyZSBmdW5jdGlvbiB0aGF0IHNhdmVzIGV2ZW50IGRhdGFcbiAqICAgICAvLyBmcm9tIGJlaW5nIHN0YWxlLlxuICogICAgIGNhcHR1cmU6IGUgPT4geyBcbiAqICAgICAgICAgLy8gYGNhcHR1cmVgIGNhbiBoYXZlIHNpZGUtZWZmZWN0cyBiZWNhdXNlXG4gKiAgICAgICAgIC8vIGl0J3MgY2FsbGVkIGV4YWN0bHkgb25jZSBwZXIgaW52b2NhdGlvblxuICogICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IFxuICogXG4gKiAgICAgICAgIC8vIFNhdmUgdGhpcyB2YWx1ZSBzbyB0aGF0IGl0J3MgbmV2ZXIgc3RhbGVcbiAqICAgICAgICAgcmV0dXJuIGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICogICAgIH1cbiAqIH0pO1xuICogXG4gKiBjb25zdCBvbklucHV0ID0gcGVuZGluZz8gbnVsbCA6IHN5bmNIYW5kbGVyO1xuICogYGBgXG4gKiBcbiAqIFRoZSBoYW5kbGVyIGlzIGF1dG9tYXRpY2FsbHkgdGhyb3R0bGVkIHRvIG9ubHkgcnVuIG9uZSBhdCBhIHRpbWUuIFxuICogSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkLCBhbmQgdGhlbiBiZWZvcmUgaXQgZmluaXNoZXMsIGlzIGNhbGxlZCBhZ2FpbixcbiAqIGl0IHdpbGwgYmUgcHV0IG9uIGhvbGQgdW50aWwgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLCBhdCB3aGljaCBwb2ludFxuICogdGhlIHNlY29uZCBvbmUgd2lsbCBydW4uICBJZiB0aGUgaGFuZGxlciBpcyBjYWxsZWQgYSB0aGlyZCB0aW1lIGJlZm9yZVxuICogdGhlIGZpcnN0IGhhcyBmaW5pc2hlZCwgaXQgd2lsbCAqcmVwbGFjZSogdGhlIHNlY29uZCwgc28gb25seSB0aGUgbW9zdFxuICogcmVjZW50bHkgY2FsbGVkIGl0ZXJhdGlvbiBvZiB0aGUgaGFuZGxlciB3aWxsIHJ1bi5cbiAqIFxuICogXG4gKiBZb3UgbWF5IG9wdGlvbmFsbHkgKmFsc28qIHNwZWNpZnkgZGVib3VuY2UgYW5kIHRocm90dGxlIHBhcmFtZXRlcnMgdGhhdCB3YWl0IHVudGlsIHRoZVxuICogc3luY3Jvbm91cyBoYW5kbGVyIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mXG4gKiBtaWxsaXNlY29uZHMsIGF0IHdoaWNoIHBvaW50IHdlICphY3R1YWxseSogcnVuIHRoZSBhc3luY3Jvbm91cyBoYW5kbGVyXG4gKiBhY2NvcmRpbmcgdG8gdGhlIGxvZ2ljIGluIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGguIFRoaXMgaXMgaW5cbiAqICphZGRpdGlvbiogdG8gdGhyb3R0bGluZyB0aGUgaGFuZGxlciwgYW5kIGRvZXMgbm90IHJlcGxhY2UgdGhhdCBiZWhhdmlvci5cbiAqIFxuICogQHNlZSB1c2VBc3luYyBBIG1vcmUgZ2VuZXJhbCB2ZXJzaW9uIG9mIHRoaXMgaG9vayB0aGF0IGNhbiB3b3JrIHdpdGggYW55IHR5cGUgb2YgaGFuZGxlciwgbm90IGp1c3QgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNIYW5kbGVyPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4oeyBhc3luY0hhbmRsZXIsIGNhcHR1cmU6IG9yaWdpbmFsQ2FwdHVyZSwgLi4ucmVzdEFzeW5jT3B0aW9ucyB9OiBVc2VBc3luY0hhbmRsZXJQYXJhbWV0ZXJzPEV2ZW50VHlwZSwgQ2FwdHVyZVR5cGU+KTogVXNlQXN5bmNIYW5kbGVyUmV0dXJuVHlwZTxFdmVudFR5cGUsIENhcHR1cmVUeXBlPiB7XG4gICAgXG4gICAgLy8gV2UgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gXCJub3RoaW5nIGNhcHR1cmVkIHlldFwiIGFuZCBcImB1bmRlZmluZWRgIHdhcyBjYXB0dXJlZFwiXG4gICAgY29uc3QgW2N1cnJlbnRDYXB0dXJlLCBzZXRDdXJyZW50Q2FwdHVyZSwgZ2V0Q3VycmVudENhcHR1cmVdID0gdXNlU3RhdGU8Q2FwdHVyZVR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gICAgY29uc3QgW2hhc0NhcHR1cmUsIHNldEhhc0NhcHR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIFxuICAgIC8vIFdyYXAgYXJvdW5kIHRoZSBub3JtYWwgYHVzZUFzeW5jYCBgY2FwdHVyZWAgZnVuY3Rpb24gdG8gYWxzb1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdmFsdWUgdGhlIHVzZXIgYWN0dWFsbHkgaW5wdXQuXG4gICAgLy8gXG4gICAgLy8gV2l0aG91dCB0aGlzIHRoZXJlJ3Mgbm8gd2F5IHRvIHJlLXJlbmRlciB0aGUgY29udHJvbCB3aXRoXG4gICAgLy8gaXQgYmVpbmcgYm90aCBjb250cm9sbGVkIGFuZCBhbHNvIGhhdmluZyB0aGUgXCJjb3JyZWN0XCIgdmFsdWUsXG4gICAgLy8gYW5kIGF0IGFueSByYXRlIGFsc28gcHJvdGVjdHMgYWdhaW5zdCBzdWRkZW4gZXhjZXB0aW9ucyByZXZlcnRpbmdcbiAgICAvLyB5b3VyIGNoYW5nZSBvdXQgZnJvbSB1bmRlciB5b3UuXG4gICAgY29uc3QgY2FwdHVyZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBFdmVudFR5cGUpOiBbQ2FwdHVyZVR5cGUsIEV2ZW50VHlwZV0gPT4geyBcbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBvcmlnaW5hbENhcHR1cmUoZSk7IFxuICAgICAgICBzZXRDdXJyZW50Q2FwdHVyZShjYXB0dXJlZCk7XG4gICAgICAgIHNldEhhc0NhcHR1cmUodHJ1ZSk7XG4gICAgICAgIHJldHVybiBbY2FwdHVyZWQsIGVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0Q3VycmVudENhcHR1cmUsXG4gICAgICAgIGN1cnJlbnRDYXB0dXJlLFxuICAgICAgICBoYXNDYXB0dXJlLFxuICAgICAgICAuLi51c2VBc3luYyhhc3luY0hhbmRsZXIsIHsgY2FwdHVyZSwgLi4ucmVzdEFzeW5jT3B0aW9ucyB9KVxuICAgIH07XG59XG5cblxuXG5cblxuXG5cbiIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlLCBkZWJvdW5jZVJlbmRlcmluZyB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogKiBgaW5kZXhgIHJlZmVycyB0byB3aGljaCBjaGlsZCB0aGlzIGlzLlxuICogKiBgZmxhZ3NgIGFyZSBxdWljay1hbmQtZWFzeSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgeW91IGNhbiBvcHRpb25hbGx5IHVzZVxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBNQ1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBpbmRleDogVDtcbiAgICBmbGFnczogUGFydGlhbDxSZWNvcmQ8SywgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+O1xuICAgIHN1YkluZm86IE1DU3ViSW5mbztcbn1cblxuXG5cbmV4cG9ydCB0eXBlIE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyPiA9ICgobW91bnRlZDogU2V0PFQ+LCB1bm1vdW50ZWQ6IFNldDxUPikgPT4gdm9pZCk7XG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcblxuaW50ZXJmYWNlIE1DUDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cbiAgICAgKiBcbiAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XG4gICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cbiAgICAgKi9cbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQ+O1xuXG4gICAgLyoqXG4gICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXG4gICAgICovXG4gICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxUPjtcbn1cblxuZXhwb3J0IHR5cGUgTWFuYWdlZENoaWxkcmVuT21pdHMgPSBrZXlvZiBNQ1A8YW55PjtcbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZE9taXRzID0ga2V5b2YgTWFuYWdlZENoaWxkSW5mbzxhbnksIGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIE9taXRzIGV4dGVuZHMga2V5b2YgTUNQPFQ+PiB7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogT21pdDxNQ1A8VD4sIE9taXRzPjtcbn1cblxuLy8gTUNTdWJJbmZvIGNvbnRhaW5zIHRoZSBlbnRpcmV0eSBvZiB0aGUgc2F2ZWQgZGF0YSBmb3IgdGhpcyBjaGlsZC4gIEFsbCBvZiBpdC4gRXZlbiB0eXBlcyB0aGUgdXNlciB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcGFzcyBpbiBiZWNhdXNlIHRoZXkncmUgaW50ZXJuYWxseSBkZXJpdmVkLlxuLy8gU3ViYmVzdEluZm8gcmVmZXJzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVycyB0aGUgdXNlciBwYXNzZXMgaW4gdGhhdCBjb3VsZCBiZSB0b3RhbGx5IHVucmVsYXRlZC4gXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8SW5kZXhUeXBlIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBNQ1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmcsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PE1hbmFnZWRDaGlsZEluZm88SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEs+LCBNY09taXRzIHwgXCJzdWJJbmZvXCI+O1xuICAgIHN1YkluZm86IFN1YmJlc3RJbmZvO1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgTUNTdWJJbmZvLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqIChldmVuIHRob3VnaCBpdCdzIG5vdCBhIGZ1bmN0aW9uLCB0aGUgaWRlbnRpdHkgb2YgdGhpcyBvYmplY3QgbmV2ZXIgY2hhbmdlcylcbiAgICAgKi9cbiAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHtcbiAgICAgICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxULCBNQ1N1YkluZm8sIEs+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIE1DU3ViSW5mbywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxULCBNQ1N1YkluZm8sIEs+IHtcbiAgICAvKipcbiAgICAgKiBBIGhvb2sgdGhhdCBtdXN0IGJlIGNhbGxlZCBieSBldmVyeSBjaGlsZCBjb21wb25lbnQgdGhhdFxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcbiAgICAgKiBpbmNsdWRpbmcgdGhlIGNoaWxkJ3MgaW5kZXguXG4gICAgICogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIHVzZU1hbmFnZWRDaGlsZDogVXNlTWFuYWdlZENoaWxkPFQsIE1DU3ViSW5mbywgSz47XG59XG5cbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgPSB2b2lkO1xuXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGQ8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgTUNTdWJJbmZvLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQsIE1DU3ViSW5mbywgSywgbmV2ZXIsIE1DU3ViSW5mbz4pID0+IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU7XG5cblxuXG5cblxuXG4vKipcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNYW5hZ2VkQ2hpbGRyZW48SW5kZXhUeXBlIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3MgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICAvKiogU1RBQkxFICovXG4gICAgZ2V0QXQoaW5kZXg6IEluZGV4VHlwZSk6IE1hbmFnZWRDaGlsZEluZm88SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3M+IHwgdW5kZWZpbmVkO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNYW5hZ2VkQ2hpbGRJbmZvPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPikgPT4gdm9pZCkgPT4gdm9pZDtcblxuICAgIC8qKiAqKlVOU1RBQkxFKiosIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4gKi9cbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNYW5hZ2VkQ2hpbGRJbmZvPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPltdO1xufVxuXG4vKipcbiAqIEFsbG93cyBhIHBhcmVudCBjb21wb25lbnQgdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IGNlcnRhaW5cbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXG4gKiBcbiAqIFRoaXMgaG9vayBpcyBkZXNpZ25lZCB0byBiZSBsaWdodHdlaWdodCwgaW4gdGhhdCB0aGUgcGFyZW50IGtlZXBzIG5vIHN0YXRlXG4gKiBhbmQgcnVucyBubyBlZmZlY3RzLiAgRWFjaCBjaGlsZCAqZG9lcyogcnVuIGFuIGVmZmVjdCwgYnV0IHdpdGggbm8gc3RhdGVcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cbiAqIFxuICogXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNYW5hZ2VkQ2hpbGRyZW48SW5kZXhUeXBlIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3MgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8SW5kZXhUeXBlLCBuZXZlcj4pOiBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPiB7XG4gICAgdHlwZSBJbmZvID0gTWFuYWdlZENoaWxkSW5mbzxJbmRleFR5cGUsIE1DU3ViSW5mbywgRXh0cmFGbGFncz47XG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZU1hbmFnZWRDaGlsZHJlblwiLCBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSk7XG5cbiAgICBjb25zdCBnZXRIaWdoZXN0SW5kZXggPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcbiAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4O1xuICAgIH0sIFtdKTtcblxuICAgIC8vIEFsbCB0aGUgaW5mb3JtYXRpb24gd2UgaGF2ZSBhYm91dCBvdXIgY2hpbGRyZW4gaXMgc3RvcmVkIGluIHRoaXMgKipzdGFibGUqKiBhcnJheS5cbiAgICAvLyBBbnkgbXV0YXRpb25zIHRvIHRoaXMgYXJyYXkgKipETyBOT1QqKiB0cmlnZ2VyIGFueSBzb3J0IG9mIGEgcmUtcmVuZGVyLlxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbkFycmF5ID0gdXNlUmVmPHsgYXJyOiBBcnJheTxJbmZvPjsgcmVjOiBQYXJ0aWFsPFJlY29yZDxJbmRleFR5cGUsIEluZm8+PjsgaGlnaGVzdEluZGV4OiBudW1iZXIsIGxvd2VzdEluZGV4OiBudW1iZXIgfT4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xuXG4gICAgLy8gRm9yIGluZGlyZWN0IGFjY2VzcyB0byBlYWNoIGNoaWxkXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcbiAgICAvLyB3aGljaCBuZWVkcyB0byBzZWFyY2ggYWxsIGNoaWxkcmVuIGZvciB0aGF0IGNsb3Nlc3QgZml0LlxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyBiZXR0ZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgZm9yRWFjaENoaWxkID0gdXNlQ2FsbGJhY2soKGY6IChjaGlsZDogSW5mbykgPT4gdm9pZCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8SW5kZXhUeXBlLCBJbmZvPl07XG4gICAgICAgICAgICBpZiAoY2hpbGQpXG4gICAgICAgICAgICAgICAgZihjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxuICAgIGNvbnN0IGdldE1hbmFnZWRDaGlsZEluZm8gPSB1c2VDYWxsYmFjazxNYW5hZ2VkQ2hpbGRyZW48SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3M+W1wiZ2V0QXRcIl0+KChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIEluZGV4VHlwZV0hO1xuICAgIH0sIFtdKVxuXG4gICAgLy8gdGw7ZHIgdGhpcyBpcyBhIHdheSB0byBoYXZlIHJ1biB1c2VMYXlvdXRFZmZlY3Qgb25jZSBhZnRlciBhbGwgTiBjaGlsZHJlblxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXG4gICAgLy9cbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cbiAgICAvLyBUaGUgZWFzaWVzdCB3YXkgd291bGQgYmUgdXNlRWZmZWN0KC4uLiwgW2NoaWxkQ291bnRdKSBidXRcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcbiAgICAvLyAob25seSBvbmUgcmUtcmVuZGVyIGF0IGEgdGltZSB1bmxlc3MgY2hpbGRyZW4gYXJlIHN0YWdnZXJlZCwgYnV0IHN0aWxsKVxuICAgIC8vIFxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXG4gICAgLy8gdG8gZW11bGF0ZSBydW5uaW5nIFVMRSBvbiB0aGUgcGFyZW50LiBPbmx5IHRoZSBmaXJzdCBjaGlsZCB3aWxsIGFjdHVhbGx5IHF1ZXVlXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxuICAgIC8vIG1vcmUgY2hpbGRyZW4gbW91bnQvdW5tb3VudC5cbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxJbmRleFR5cGU+LCB1bm1vdW50czogU2V0PEluZGV4VHlwZT4gfSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMgPSB1c2VSZWYobmV3IFNldDxJbmRleFR5cGU+KCkpO1xuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkQ2hhbmdlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlKSA9PiB7XG5cbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcbiAgICAgICAgICAgIGRlYm91bmNlUmVuZGVyaW5nKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/LihyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcblxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xuXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBJbmRleFR5cGUsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKVxuICAgICAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4IGFzIG51bWJlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXTtcbiAgICAgICAgICAgICAgICBsZXQgc2hhdmUgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChzaGF2ZSA8PSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggJiYgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICsrc2hhdmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLnNwbGljZShtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSBzaGF2ZSwgc2hhdmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCB1c2VNYW5hZ2VkQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VNYW5hZ2VkQ2hpbGQ8SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3M+PigoaW5mbykgPT4ge1xuICAgICAgICBjb25zdCB7IG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIGZsYWdzIH0sIHN1YkluZm8gfSA9IGluZm87XG4gICAgICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAgICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgICAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSA9IHsgaW5kZXgsIGZsYWdzOiBmbGFncyA/PyB7fSwgc3ViSW5mbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSA9IHsgaW5kZXgsIGZsYWdzOiBmbGFncyA/PyB7fSwgc3ViSW5mbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgICAgICB9LCBbLi4uT2JqZWN0LmVudHJpZXMoaW5mbykuZmxhdCg5KV0pOyAgLy8gOSBpcyBpbmZpbml0eSwgcmlnaHQ/IFN1cmUuIFVucmVsYXRlZDogVE9ETy5cblxuICAgICAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgICAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICAgICAgfSwgW2luZGV4XSk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW4gPSB1c2VSZWY8TWFuYWdlZENoaWxkcmVuPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TUNTdWJJbmZvLCBFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nPiB7XG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cbiAgICAgKiBcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXG4gICAgICovXG4gICAgaW5pdGlhbEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwcm92aWRlZCwgaWYgdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4IGRvZXNuJ3QgbWFwIG9udG8gYW55XG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XG4gICAgICogd2lsbCBoYXZlIGl0cyBmbGFnIHNldCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XG4gICAgICogd2hpbGUgdGhlIHBhcmVudCB0aGlua3MgaXQgc2hvdWxkbid0IGJlIGNvdWxkIGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIE1DU3ViSW5mbywgRXh0cmFGbGFncz47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXG4gICAgICogXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBvbkluZGV4Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyIHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNoaWxkcmVuIGhhdmUgbXVsdGlwbGUgZmxhZ3MsIHRoZSBga2V5YCBwYXJhbWV0ZXIgY29udHJvbHMgd2hpY2ggZmxhZyB3ZSdyZSBjaGVja2luZy5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGNhbiBiZSBhbnl0aGluZyB5b3Ugd2FudCwgYnV0IG11c3Qgbm90IGNoYW5nZS5cbiAgICAgKi9cbiAgICBrZXk6IEV4dHJhRmxhZ3M7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBDaGlsZEZsYWdPcGVyYXRpb25zIHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2hpbGQgaXMgYWN0aXZlXG4gICAgICovXG4gICAgZ2V0OiAoKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGlsZCBtdXN0IHNldCBpdHNlbGYgYXMgYWN0aXZlL2luYWN0aXZlLCB3aGF0ZXZlciB0aGF0IGVudGFpbHMuXG4gICAgICogVGhpcyBjb3VsZCBiZSBhcyBzaW1wbGUgYXMgYSBzZXRTdGF0ZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzZXQ6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNoaWxkIGlzIGEgdmFsaWQgY2FuZGlkYXRlIHRvIGJlIGZsYWdnZWQsIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICogTW9zdCBjaGlsZHJlbiBzaG91bGQgcmV0dXJuIHRydWUuIFJldHVybmluZyBmYWxzZSBpcyBvbmx5IHVzZWZ1bCB0byBtYXJrIGEgY2hpbGQgYXMgXCJpbnZhbGlkXCIgaW4gc29tZSB3YXkuXG4gICAgICogUmVtb3ZpbmcgYSBjaGlsZCBmcm9tIHRoZSBsaXN0IGRvZXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcsIGJ1dCB0aGlzIGxldHMgeW91IGtlZXAgdGhlIGNoaWxkIGFyb3VuZC5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgY2hhbmdlSW5kZXg6IChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNQ1N1YkluZm8sIEZsYWcgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwga2V5IH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TUNTdWJJbmZvLCBGbGFnPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBrZXkpO1xuXG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihvbkluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XG5cbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XG5cbiAgICAvLyAgICBjb25zdCBnZXRGaXROdWxsVG9aZXJvID0gdXNlU3RhYmxlR2V0dGVyKGZpdE51bGxUb1plcm8pO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gb25DaGlsZHJlbk1vdW50Q2hhbmdlIGFuZCBjaGFuZ2VJbmRleCwgbm90IHB1YmxpYyAoYnV0IGNvdWxkIGJlIEkgZ3Vlc3MpXG4gICAgY29uc3QgZ2V0Q2xvc2VzdEZpdCA9IHVzZUNhbGxiYWNrKChyZXF1ZXN0ZWRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3M/LltrZXldPy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKGNoaWxkLmluZGV4IC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBjaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGdldFJlcXVlc3RlZEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSBjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCAhPSBudWxsICYmIGNsb3Nlc3RGaXQgJiYgKHJlcXVlc3RlZEluZGV4ICE9IGN1cnJlbnRJbmRleCB8fCBjdXJyZW50Q2hpbGQgPT0gbnVsbCB8fCAhY3VycmVudENoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgY3VycmVudENoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdENoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgY2xvc2VzdEZpdENoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2soKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmc7XG4gICAgICAgIC8vaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxuICAgICAgICAvLyAgICByZXF1ZXN0ZWRJbmRleCA9IDA7XG5cbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsKTtcbiAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQgJiYgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsSW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGluaXRpYWxJbmRleCk/LmZsYWdzPy5ba2V5XT8uc2V0KHRydWUpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbi8vaW1wb3J0IHsgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1jdXJyZW50LWZvY3VzXCI7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMge1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgb25BbnlHYWluZWRGb2N1czogbnVsbCB8ICgoKSA9PiB2b2lkKTtcclxuICAgICAgICBvbkFsbExvc3RGb2N1czogbnVsbCB8ICgoKSA9PiB2b2lkKTtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQYXJhbWV0ZXJzIHtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzPEU+W1wiaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyc1wiXSwgXCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PjtcclxuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPEU+W1wicmVmRWxlbWVudFBhcmFtZXRlcnNcIl0sIFwib25FbGVtZW50Q2hhbmdlXCI+PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTI8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT4ge1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZUluZm8ge1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVXaXRoSG9va3MgZXh0ZW5kcyBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVJbmZvIHtcclxuICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQ6IDxFIGV4dGVuZHMgRWxlbWVudD4ocGFyYW1ldGVyczogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnMpID0+IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlMjxFPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuSGF2ZUZvY3VzKGFyZ3M6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyk6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyB7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyczogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9IH0gPSBhcmdzO1xyXG5cclxuICAgIC8vL2NvbnN0IHsgbWFuYWdlZENoaWxkcmVuUmV0dXJuLCB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHVzZU1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0pO1xyXG5cclxuICAgIGNvbnN0IGFsbEVsZW1lbnRzUmVmID0gdXNlUmVmPFNldDxOb2RlPj4obmV3IFNldCgpKTtcclxuICAgIGNvbnN0IFtfZ2V0Rm9jdXNDb3VudCwgc2V0Rm9jdXNDb3VudF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyPih1c2VTdGFibGVDYWxsYmFjaygoYW55Rm9jdXNlZDogbnVtYmVyLCBhbnlQcmV2aW91c2x5Rm9jdXNlZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoYW55Rm9jdXNlZCA+PSAwICYmIGFueUZvY3VzZWQgPD0gMSk7XHJcblxyXG4gICAgICAgIGlmIChhbnlGb2N1c2VkICYmICFhbnlQcmV2aW91c2x5Rm9jdXNlZClcclxuICAgICAgICAgICAgb25BbnlHYWluZWRGb2N1cz8uKCk7XHJcbiAgICAgICAgaWYgKCFhbnlGb2N1c2VkICYmIGFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCA9IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oYXJnczogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnMpOiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTI8RT4gPT4ge1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICAgICAgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZvY3VzZWQgJiYgcHJldikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgLSAxKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlOiBFIHwgbnVsbCwgcHJldjogRSB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxFbGVtZW50c1JlZi5jdXJyZW50LmFkZChlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbEVsZW1lbnRzUmVmLmN1cnJlbnQuZGVsZXRlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgW10pXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFxyXG4gICAgfVxyXG59XHJcbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREb2N1bWVudChlbGVtZW50PzogTm9kZSkgeyByZXR1cm4gKGVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ID8/IGdsb2JhbFRoaXMuZG9jdW1lbnQpOyB9XG5cbnR5cGUgUCA9IFBhcmFtZXRlcnM8dHlwZW9mIGNsc3g+O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9jdW1lbnRDbGFzcyhjbGFzc05hbWU6IFBbMF0sIGFjdGl2ZT86IGJvb2xlYW4sIGVsZW1lbnQ/OiBIVE1MRWxlbWVudCkge1xuICAgIGVsZW1lbnQgPz89IGdldERvY3VtZW50KCkuZG9jdW1lbnRFbGVtZW50O1xuICAgIGNsYXNzTmFtZSA9IGNsc3goY2xhc3NOYW1lKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAoYWN0aXZlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZWxlbWVudCEuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUgYXMgc3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgfSwgW2NsYXNzTmFtZSwgYWN0aXZlLCBlbGVtZW50XSk7XG5cbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYWdnYWJsZVJldHVyblR5cGU8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZFxuICAgICAqL1xuICAgIGRyYWdnaW5nOiBib29sZWFuO1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXREcmFnZ2luZzogKCkgPT4gYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIE9uY2UgdGhlIGRyYWcgZW5kcywgaWYgaXQgd2FzIG92ZXIgYSB2YWxpZCBkcm9wcGFibGUsIHRoaXMgd2lsbCBiZVxuICAgICAqIHNldCB0byB0aGUgYGRyb3BFZmZlY3RgIHZhbHVlIGl0IGhhZC5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRldGVjdCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkcm9wcGVkLCBcbiAgICAgKiBhbmQgdGhlbiB3aGF0IHNob3VsZCBiZSBkb25lIHdpdGggaXQgKGdlbmVyYWxseSBkZWxldGVkIGlmIHRoZSBlZmZlY3Qgd2FzIFwibW92ZVwiKVxuICAgICAqL1xuICAgIGxhc3REcm9wRWZmZWN0OiBEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbDtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0TGFzdERyb3BFZmZlY3Q6ICgpID0+IChEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbCk7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmFnZ2FibGVQYXJhbWV0ZXJzIHtcblxuICAgIC8qKlxuICAgICAqIE1hcHMgdG8gdGhlIERyYWcgYW5kIERyb3AgQVBJIC0tIGFsbG93cyBsaW1pdGluZyB0aGUgYXJlYXMgdGhpcyBlbGVtZW50IGNhbiBiZSBkcm9wcGVkLlxuICAgICAqIEZvciBleGFtcGxlLCBzZXR0aW5nIHRoaXMgdG8gXCJjb3B5TGlua1wiIHdpbGwgYWxsb3cgdGhpcyB0aGlzIHRvIGJlIGRyb3BwZWQgb250b1xuICAgICAqIGEgZHJvcHBhYmxlIHdpdGggYW4gZWZmZWN0IG9mIFwiY29weVwiIG9yIFwibGlua1wiLCBidXQgbm90IFwibW92ZVwiLlxuICAgICAqIFxuICAgICAqL1xuICAgIGVmZmVjdEFsbG93ZWQ/OiBEYXRhVHJhbnNmZXJbXCJlZmZlY3RBbGxvd2VkXCJdIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGN1c3RvbSBkcmFnIGltYWdlIGluc3RlYWQgb2YgdGhlIGJyb3dzZXIgZGVmYXVsdCAoYSB0cmFuc3BhcmVudCByZW5kZXIgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQsIGdlbmVyYWxseSlcbiAgICAgKi9cbiAgICBkcmFnSW1hZ2U/OiBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50O1xuICAgIGRyYWdJbWFnZVhPZmZzZXQ/OiBudW1iZXI7XG4gICAgZHJhZ0ltYWdlWU9mZnNldD86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFJlcHJlc2VudHMgYSBkaWN0aW9uYXJ5IG1hcHBpbmcgb2YgTUlNRSB0eXBlcyB0byBkYXRhXG4gICAgICovXG4gICAgZGF0YTogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJhZ2dhYmxlPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGVmZmVjdEFsbG93ZWQsIGRhdGEsIGRyYWdJbWFnZSwgZHJhZ0ltYWdlWE9mZnNldCwgZHJhZ0ltYWdlWU9mZnNldCB9OiBVc2VEcmFnZ2FibGVQYXJhbWV0ZXJzKSB7XG5cbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nLCBnZXREcmFnZ2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2xhc3REcm9wRWZmZWN0LCBzZXRMYXN0RHJvcEVmZmVjdCwgZ2V0TGFzdERyb3BFZmZlY3RdID0gdXNlU3RhdGU8RGF0YVRyYW5zZmVyW1wiZHJvcEVmZmVjdFwiXSB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3Qgb25EcmFnU3RhcnQgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXREcmFnZ2luZyh0cnVlKTtcbiAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gKGVmZmVjdEFsbG93ZWQgPz8gXCJhbGxcIik7XG4gICAgICAgICAgICBpZiAoZHJhZ0ltYWdlKVxuICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnSW1hZ2UsIGRyYWdJbWFnZVhPZmZzZXQgPz8gMCwgZHJhZ0ltYWdlWU9mZnNldCA/PyAwKVxuXG4gICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSkgYXMgW21pbWVUeXBlOiBzdHJpbmcsIGRhdGE6IHN0cmluZ11bXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW21pbWVUeXBlLCBkYXRhXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShtaW1lVHlwZSwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGNvbnN0IG9uRHJhZ0VuZCA9IChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgIT0gXCJub25lXCIpIHtcbiAgICAgICAgICAgICAgICBzZXRMYXN0RHJvcEVmZmVjdChlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldExhc3REcm9wRWZmZWN0KG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcbiAgICBjb25zdCByZXQ6IFVzZURyYWdnYWJsZVJldHVyblR5cGU8RT4gPSB7XG4gICAgICAgIHByb3BzVW5zdGFibGU6IHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgb25EcmFnRW5kXG4gICAgICAgIH0sXG4gICAgICAgIGRyYWdnaW5nLFxuICAgICAgICBnZXREcmFnZ2luZyxcbiAgICAgICAgbGFzdERyb3BFZmZlY3QsXG4gICAgICAgIGdldExhc3REcm9wRWZmZWN0XG4gICAgfTtcblxuICAgIHJldHVybiByZXQ7XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcm9wcGFibGVSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7XG5cbiAgICAvKipcbiAgICAgKiBIb29rIGZvciBtb2RpZnlpbmcgdGhlIHByb3BzIHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8geW91ciBkcm9wIHRhcmdldCBFbGVtZW50LlxuICAgICAqIFxuICAgICAqICpVbnN0YWJsZSpcbiAgICAgKi9cbiAgICBwcm9wc1N0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG5cbiAgICAvKipcbiAgICAgKiBXaGlsZSBzb21ldGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudCwgdGhpcyB3aWxsIGNvbnRhaW4gYW55IGluZm9ybWF0aW9uIGFib3V0IGFueSBmaWxlcyBpbmNsdWRlZCBpbiB0aGF0IGRyb3AuXG4gICAgICogT3RoZXJ3aXNlLCBpdCdsbCBiZSBudWxsLCBtZWFuaW5nIG5vdGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBmaWxlc0ZvckNvbnNpZGVyYXRpb246IERyb3BGaWxlTWV0YWRhdGFbXSB8IG51bGw7XG4gICAgLyoqXG4gICAgICogV2hpbGUgc29tZXRoaW5nIGlzIGJlaW5nIGRyYWdnZWQgb3ZlciB0aGlzIGVsZW1lbnQsIGEgbGlzdCBvZiBhdmFpbGFibGUgTUlNRSB0eXBlcyBmb3IgdGhlIG5vbi1maWxlIGRhdGEgd2lsbCBiZSBsaXN0ZWQgaGVyZS5cbiAgICAgKiBPdGhlcndpc2UsIGl0J2xsIGJlIG51bGwsIG1lYW5pbmcgbm90aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIHN0cmluZ3NGb3JDb25zaWRlcmF0aW9uOiBTZXQ8c3RyaW5nPiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGZpbGVzIGFyZSBkcm9wcGVkIG92ZXIgdGhlIGVsZW1lbnQsIHRoZWlyIGRhdGEgd2lsbCBiZSBnaXZlbiBoZXJlLlxuICAgICAqIFRoaXMgd2lsbCB1cGRhdGUgYXMgbmV3IGRyb3BzIGhhcHBlbi5cbiAgICAgKi9cbiAgICBkcm9wcGVkRmlsZXM6IERyb3BGaWxlW10gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBub24tZmlsZSBkYXRhIGlzIGRyb3BwZWQgb3ZlciB0aGUgZWxlbWVudCwgdGhlaXIgZGF0YSB3aWxsIGJlIGdpdmVuIGhlcmUuXG4gICAgICogVGhpcyB3aWxsIHVwZGF0ZSBhcyBuZXcgZHJvcHMgaGFwcGVuLlxuICAgICAqL1xuICAgIGRyb3BwZWRTdHJpbmdzOiB7IFtNaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH0gfCBudWxsO1xuXG5cbiAgICBkcm9wRXJyb3I6IHVua25vd247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJvcHBhYmxlUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogTWFwcyB0byB0aGUgRHJhZyBhbmQgRHJvcCBBUEkgLS0gZWZmZWN0aXZlbHkgbWVhbnMgXCJhcyBjbG9zZSBhcyBwb3NzaWJsZSwgd2hhdCdzIGhhcHBlbmluZyB0byB0aGUgZGF0YSB3aGVuIEkgZHJvcCBpdCBoZXJlPyBcbiAgICAgKiBBbSBJIGNvcHlpbmcgaXQgYW5kIGxlYXZpbmcgdGhlIG9yaWdpbmFsLCBhbSBJIG1vdmluZyBpdCBhbmQgZGVsZXRpbmcgdGhlIG9yaWdpbmFsLCBvciBhbSBJIGxpbmtpbmcgaXQgdG8gdGhlIG9yaWdpbmFsP1wiXG4gICAgICogXG4gICAgICogV2hhdGV2ZXIgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgd2lsbCBoYXZlIGl0cyBvd24gcGVybWlzc2lvbiB0aGF0J3MgY2hlY2tlZCBhZ2FpbnN0IHRoaXMuXG4gICAgICovXG4gICAgZWZmZWN0OiBEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERyb3BGaWxlIGV4dGVuZHMgRHJvcEZpbGVNZXRhZGF0YSB7IG5hbWU6IHN0cmluZywgZGF0YTogQXJyYXlCdWZmZXIsIHNpemU6IG51bWJlciB8IHVuZGVmaW5lZCwgbGFzdE1vZGlmaWVkOiBudW1iZXIgfCB1bmRlZmluZWQgfVxuZXhwb3J0IGludGVyZmFjZSBEcm9wRmlsZU1ldGFkYXRhIHsgdHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkIH1cblxuXG50eXBlIERyb3BwYWJsZUZpbGVFcnJvclR5cGUgPSBcIkluZGV4U2l6ZUVycm9yXCIgfCBcIkhpZXJhcmNoeVJlcXVlc3RFcnJvclwiIHwgXCJXcm9uZ0RvY3VtZW50RXJyb3JcIiB8IFwiSW52YWxpZENoYXJhY3RlckVycm9yXCIgfCBcIk5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yXCIgfCBcIk5vdEZvdW5kRXJyb3JcIiB8IFwiTm90U3VwcG9ydGVkRXJyb3JcIiB8IFwiSW52YWxpZFN0YXRlRXJyb3JcIiB8IFwiSW5Vc2VBdHRyaWJ1dGVFcnJvclwiIHwgXCJTeW50YXhFcnJvclwiIHwgXCJJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3JcIiB8IFwiTmFtZXNwYWNlRXJyb3JcIiB8IFwiSW52YWxpZEFjY2Vzc0Vycm9yXCIgfCBcIlR5cGVNaXNtYXRjaEVycm9yXCIgfCBcIlNlY3VyaXR5RXJyb3JcIiB8IFwiTmV0d29ya0Vycm9yXCIgfCBcIkFib3J0RXJyb3JcIiB8IFwiVVJMTWlzbWF0Y2hFcnJvclwiIHwgXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8IFwiVGltZW91dEVycm9yXCIgfCBcIkludmFsaWROb2RlVHlwZUVycm9yXCIgfCBcIkRhdGFDbG9uZUVycm9yXCIgfCBcIkVuY29kaW5nRXJyb3JcIiB8IFwiTm90UmVhZGFibGVFcnJvclwiIHwgXCJVbmtub3duRXJyb3JcIiB8IFwiQ29uc3RyYWludEVycm9yXCIgfCBcIkRhdGFFcnJvclwiIHwgXCJUcmFuc2FjdGlvbkluYWN0aXZlRXJyb3JcIiB8IFwiUmVhZE9ubHlFcnJvclwiIHwgXCJWZXJzaW9uRXJyb3JcIiB8IFwiT3BlcmF0aW9uRXJyb3JcIiB8IFwiTm90QWxsb3dlZEVycm9yXCI7XG5cbmV4cG9ydCBjbGFzcyBEcm9wcGFibGVGaWxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZmlsZU5hbWU6IHN0cmluZztcbiAgICBlcnJvclR5cGU6IERyb3BwYWJsZUZpbGVFcnJvclR5cGU7XG5cbiAgICBjb25zdHJ1Y3RvcihmaWxlTmFtZTogc3RyaW5nLCBiYXNlOiBET01FeGNlcHRpb24gfCBudWxsKSB7XG4gICAgICAgIHN1cGVyKGJhc2U/Lm1lc3NhZ2UgPz8gXCJBbiB1bnNwZWNpZmllZCBlcnJvciBvY2N1cnJlZCByZWFkaW5nIHRoZSBmaWxlLlwiKTtcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xuICAgICAgICB0aGlzLmVycm9yVHlwZSA9IChiYXNlPy5uYW1lIGFzIERyb3BwYWJsZUZpbGVFcnJvclR5cGUpO1xuICAgIH1cblxufVxuXG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZURyb3BwYWJsZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBlZmZlY3QgfTogVXNlRHJvcHBhYmxlUGFyYW1ldGVycyk6IFVzZURyb3BwYWJsZVJldHVyblR5cGU8RT4ge1xuXG4gICAgY29uc3QgW2ZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uXSA9IHVzZVN0YXRlPG51bGwgfCBEcm9wRmlsZU1ldGFkYXRhW10+KG51bGwpO1xuICAgIGNvbnN0IFtzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb25dID0gdXNlU3RhdGU8bnVsbCB8IFNldDxzdHJpbmc+PihudWxsKTtcblxuICAgIGNvbnN0IFtkcm9wcGVkRmlsZXMsIHNldERyb3BwZWRGaWxlc10gPSB1c2VTdGF0ZTxudWxsIHwgRHJvcEZpbGVbXT4obnVsbCk7XG4gICAgY29uc3QgW2Ryb3BwZWRTdHJpbmdzLCBzZXREcm9wcGVkU3RyaW5nc10gPSB1c2VTdGF0ZTxudWxsIHwgeyBbTWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9PihudWxsKTtcblxuICAgIGNvbnN0IFtkcm9wRXJyb3IsIHNldERyb3BFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgLy8gQWxsIHRoZSBwcm9taXNlcyBnZW5lcmF0ZWQgZnJvbSB0aGUgZHJvcCBldmVudHMuXG4gICAgLy8gVXNlZCB0byBwcm9jZXNzIG11bHRpcGxlIGRyb3AgZXZlbnRzIGluIHN1Y2Nlc3Npb25cbiAgICBjb25zdCBkcm9wUHJvbWlzZXNSZWYgPSB1c2VSZWY8UHJvbWlzZTxudWxsIHwgeyBzdHJpbmdzOiB7IFttaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH0sIGZpbGVzOiBEcm9wRmlsZVtdIH0+W10+KFtdKTtcbiAgICBjb25zdCBbY3VycmVudFByb21pc2VJbmRleCwgc2V0Q3VycmVudFByb21pc2VJbmRleCwgZ2V0Q3VycmVudFByb21pc2VJbmRleF0gPSB1c2VTdGF0ZSgtMSk7XG4gICAgY29uc3QgW3Byb21pc2VDb3VudCwgc2V0UHJvbWlzZUNvdW50LCBnZXRQcm9taXNlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICAvLyBBbnkgdGltZSB3ZSBhZGQgYSBuZXcgcHJvbWlzZSwgaWYgdGhlcmUncyBubyBjdXJyZW50IHByb21pc2UgcnVubmluZywgd2UgbmVlZCB0byBzdGFydCBvbmUuXG4gICAgLy8gSWYgdGhlcmUgaXMgb25lLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcsIHNpbmNlIGl0IHJ1bnMgdGhlIHNhbWUgY2hlY2suXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgY3VycmVudFByb21pc2VJbmRleCA9IGdldEN1cnJlbnRQcm9taXNlSW5kZXgoKTtcbiAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XG5cbiAgICAgICAgaWYgKHByb21pc2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgIGlmICgoY3VycmVudFByb21pc2VJbmRleCArIDEpIDwgcHJvbWlzZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFByb21pc2VJbmRleChpID0+ICsraSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIH0sIFtwcm9taXNlQ291bnRdKTtcblxuICAgIC8vIEFueXRpbWUgb3VyIGN1cnJlbnQgcHJvbWlzZSBjaGFuZ2VzLFxuICAgIC8vIHdhaXQgZm9yIGl0IHRvIGZpbmlzaCwgdGhlbiBzZXQgb3VyIHN0YXRlIHRvIGl0cyByZXN1bHQuXG4gICAgLy8gRmluYWxseSwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnltb3JlIHByb21pc2VzLlxuICAgIC8vIElmIHRoZXJlIGFyZSwgdGhlbiBpbmNyZWFzZSBjdXJyZW50UHJvbWlzZUNvdW50LFxuICAgIC8vIHdoaWNoIHdpbGwgdHJpZ2dlciB0aGlzIGFnYWluLlxuICAgIC8vXG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuICpvZnRlbiosIGJ1dCBtYXliZSBpbiB0aGUgY2FzZSBvZlxuICAgIC8vIGluZGl2aWR1YWxseSBkcm9wcGluZyBhIGJ1bmNoIG9mIGxhcmdlIGZpbGVzIG9yIHNvbWV0aGluZy5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFByb21pc2VJbmRleCA+PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UHJvbWlzZSA9IGRyb3BQcm9taXNlc1JlZi5jdXJyZW50W2N1cnJlbnRQcm9taXNlSW5kZXhdO1xuICAgICAgICAgICAgY3VycmVudFByb21pc2UudGhlbigoaW5mbykgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKGluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlcywgc3RyaW5ncyB9ID0gaW5mbztcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcHBlZEZpbGVzKGZpbGVzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcHBlZFN0cmluZ3Moc3RyaW5ncyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTm93IHRoYXQgd2UncmUgZG9uZSwgYXJlIHRoZXJlIG1vcmUgcHJvbWlzZXMgaW4gdGhlIHF1ZXVlP1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFByb21pc2VJbmRleCA9IGdldEN1cnJlbnRQcm9taXNlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9taXNlQ291bnQgPSBnZXRQcm9taXNlQ291bnQoKTtcblxuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFByb21pc2VJbmRleCArIDEpIDwgcHJvbWlzZUNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgcHJvbWlzZSBoYXMgc3RhcnRlZCwgbW9yZSBoYXZlIGJlZW4gYWRkZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGlzIGVmZmVjdCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFByb21pc2VJbmRleChpID0+ICsraSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgIH0sIFtjdXJyZW50UHJvbWlzZUluZGV4XSk7XG5cblxuICAgIC8vIEhhbmRsZSBjb2xsZWN0aW5nIHRoZSBjdXJyZW50IGZpbGUgbWV0YWRhdGEgb3IgTUlNRSB0eXBlcy5cbiAgICBjb25zdCBvbkRyYWdFbnRlciA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcblxuICAgICAgICAgICAgLy8gSXMgdGhlcmUgYSBkZWZhdWx0PyBJIGNhbid0IGZpbmQgb25lIGFueXdoZXJlLlxuICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCA9IChlZmZlY3QgPz8gXCJtb3ZlXCIpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdNaW1lVHlwZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGVzID0gbmV3IEFycmF5PERyb3BGaWxlTWV0YWRhdGE+KCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlLmRhdGFUcmFuc2Zlcj8uaXRlbXMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtpbmQsIHR5cGUgfSA9IGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdNaW1lVHlwZXMuYWRkKHR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChraW5kID09PSBcImZpbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWxlcy5wdXNoKHsgdHlwZTogaXRlbS50eXBlIH0pO1xuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obmV3RmlsZXMpO1xuICAgICAgICAgICAgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb24obmV3TWltZVR5cGVzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSGFuZGxlIHJlc2V0dGluZyB0aGUgY3VycmVudCBmaWxlIG1ldGFkYXRhIG9yIE1JTUUgdHlwZXNcbiAgICBjb25zdCBvbkRyYWdMZWF2ZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XG4gICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xuICAgIH0pO1xuXG4gICAgLy8gQm9pbGVycGxhdGUsIEkgZ3Vlc3NcbiAgICBjb25zdCBvbkRyYWdPdmVyID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IERyYWdFdmVudCkgPT4ge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSlcblxuICAgIC8vIEhhbmRsZSBnZXR0aW5nIHRoZSBkcm9wIGRhdGEgYXN5bmNocm9ub3VzbHlcbiAgICBjb25zdCBvbkRyb3AgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XG4gICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xuXG4gICAgICAgIGNvbnN0IGFsbFByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XG5cbiAgICAgICAgY29uc3QgZHJvcERhdGE6IHsgW21pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuICAgICAgICBjb25zdCBkcm9wRmlsZTogRHJvcEZpbGVbXSA9IFtdO1xuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlLmRhdGFUcmFuc2Zlcj8uaXRlbXMgPz8gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHlwZSB9ID0gaXRlbTtcblxuICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBhbGxQcm9taXNlcy5wdXNoKChuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCBfcmVqZWN0KSA9PiBpdGVtLmdldEFzU3RyaW5nKHJlc29sdmUpKSkudGhlbihzdHIgPT4gZHJvcERhdGFbdHlwZV0gPSBzdHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IFwiZmlsZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaChcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25sb2FkID0gKF8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gcmVhZGVyLnJlc3VsdCBhcyBBcnJheUJ1ZmZlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZpbGUucHVzaCh7IGRhdGEsIG5hbWU6IGZpbGUubmFtZSwgdHlwZTogZmlsZS50eXBlLCBzaXplOiBkYXRhLmJ5dGVMZW5ndGgsIGxhc3RNb2RpZmllZDogZmlsZS5sYXN0TW9kaWZpZWQgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25lcnJvciA9IChfKSA9PiB7IHJlamVjdChuZXcgRHJvcHBhYmxlRmlsZUVycm9yKGZpbGUubmFtZSwgcmVhZGVyLmVycm9yKSk7IH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uYWJvcnQgPSAoXykgPT4geyByZWplY3QobmV3IERyb3BwYWJsZUZpbGVFcnJvcihmaWxlLm5hbWUsIHJlYWRlci5lcnJvcikpOyB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgZHJvcEZpbGUucHVzaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cbiAgICAgICAgZHJvcFByb21pc2VzUmVmLmN1cnJlbnQucHVzaChQcm9taXNlLmFsbChhbGxQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBzZXRQcm9taXNlQ291bnQoaSA9PiArK2kpO1xuICAgICAgICAgICAgc2V0RHJvcEVycm9yKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdzOiBkcm9wRGF0YSxcbiAgICAgICAgICAgICAgICBmaWxlczogZHJvcEZpbGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZXggPT4ge1xuICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgc2V0UHJvbWlzZUNvdW50KGkgPT4gKytpKTtcbiAgICAgICAgICAgIHNldERyb3BFcnJvcihleCk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSkpO1xuICAgIH0pXG5cbiAgICBjb25zdCBwcm9wc1N0YWJsZSA9IHVzZVJlZih7IG9uRHJhZ0VudGVyLCBvbkRyYWdMZWF2ZSwgb25EcmFnT3Zlciwgb25Ecm9wIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnQsXG4gICAgICAgIGZpbGVzRm9yQ29uc2lkZXJhdGlvbixcbiAgICAgICAgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sXG4gICAgICAgIGRyb3BwZWRGaWxlcyxcbiAgICAgICAgZHJvcHBlZFN0cmluZ3MsXG5cbiAgICAgICAgZHJvcEVycm9yXG4gICAgfVxufVxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGdldEVsZW1lbnQoKTogVCB8IG51bGw7XHJcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7XHJcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+O1xyXG4gICAgICAgIG9uTW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgICAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxuICAgIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXHJcbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsIFxyXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cclxuICogXHJcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxyXG4gKiBcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJnczogVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4pOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiB7XHJcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gfSA9IGFyZ3M7XHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcclxuXHJcbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cclxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD4+KChlLCBwcmV2VmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcclxuICAgICAgICBpZiAocHJldlZhbHVlKVxyXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcclxuXHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxyXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XHJcbiAgICBjb25zdCBwcm9wc1N0YWJsZSA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxUPj4oeyByZWY6IHNldEVsZW1lbnQgfSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXHJcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHtcclxuICAgICAgICAgICAgZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgcHJvcHNTdGFibGU6IHByb3BzU3RhYmxlLmN1cnJlbnRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJ1bkltbWVkaWF0ZWx5KGY6ICgpID0+IHZvaWQpIHtcclxuICAgIGYoKTtcclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UGFyYW1ldGVycywgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VFbGVtZW50U2l6ZVBhcmFtZXRlcnM8VCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xuICAgIGVsZW1lbnRTaXplUGFyYW1ldGVyczogey8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYnJvd3NlciBkZXRlY3RzIGEgc2l6ZSBjaGFuZ2VcbiAgICAgKiBvbiB0aGUgZWxlbWVudC4gRG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUsIHNvIHlvdVxuICAgICAqIGNhbiBwYXNzIGFuIGFub255bW91cyBmdW5jdGlvbiB0aGF0IG9ubHkgc2V0cyB0aGVcbiAgICAgKiB2YWx1ZXMgeW91IHVzZSBpZiB5b3UnZCBsaWtlLlxuICAgICAqIEBwYXJhbSBzaXplSW5mbyBcbiAgICAgKi9cbiAgICAgICAgb25TaXplQ2hhbmdlKHNpemVJbmZvOiBFbGVtZW50U2l6ZSk6IHZvaWQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3NlZCBhcyBhbiBhcmd1bWVudCB0byB0aGUgY3JlYXRlZCBSZXNpemVPYnNlcnZlci5cbiAgICAgICAgICogXG4gICAgICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZU9ic2VydmVyL29ic2VydmUjcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZ2V0T2JzZXJ2ZUJveDogbnVsbCB8ICgoKSA9PiBSZXNpemVPYnNlcnZlck9wdGlvbnNbXCJib3hcIl0pO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50U2l6ZSB7XG4gICAgY2xpZW50V2lkdGg6IG51bWJlcjtcbiAgICBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIG9mZnNldFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50SGVpZ2h0OiBudW1iZXI7XG4gICAgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gICAgb2Zmc2V0SGVpZ2h0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50TGVmdDogbnVtYmVyO1xuICAgIHNjcm9sbExlZnQ6IG51bWJlcjtcbiAgICBvZmZzZXRMZWZ0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50VG9wOiBudW1iZXI7XG4gICAgc2Nyb2xsVG9wOiBudW1iZXI7XG4gICAgb2Zmc2V0VG9wOiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRWxlbWVudFNpemVSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIFwicHJvcHNcIiB8IFwidXNlUHJvcHNcIj4ge1xuICAgIGVsZW1lbnRTaXplUmV0dXJuOiB7LyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgZ2V0U2l6ZSgpOiBFbGVtZW50U2l6ZSB8IG51bGw7XG4gICAgfVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VFbGVtZW50U2l6ZTxFIGV4dGVuZHMgRWxlbWVudD4oeyBlbGVtZW50U2l6ZVBhcmFtZXRlcnM6IHsgZ2V0T2JzZXJ2ZUJveCwgb25TaXplQ2hhbmdlIH0sIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50IH0gfTogVXNlRWxlbWVudFNpemVQYXJhbWV0ZXJzPEU+KTogVXNlRWxlbWVudFNpemVSZXR1cm5UeXBlPEU+IHtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUVsZW1lbnRTaXplXCIsIGdldE9ic2VydmVCb3gsIG9uU2l6ZUNoYW5nZSwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xuXG4gICAgY29uc3QgW2dldFNpemUsIHNldFNpemVdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnRTaXplIHwgbnVsbD4ob25TaXplQ2hhbmdlIGFzIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnRTaXplIHwgbnVsbD4sIHJldHVybk51bGwpO1xuXG4gICAgY29uc3QgY3VycmVudE9ic2VydmVCb3ggPSB1c2VSZWY8UmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3QgbmVlZEFOZXdPYnNlcnZlciA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCwgb2JzZXJ2ZUJveDogUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSA9IChlbGVtZW50IGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgICAgIHNldFNpemUoeyBjbGllbnRXaWR0aCwgc2Nyb2xsV2lkdGgsIG9mZnNldFdpZHRoLCBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCwgb2Zmc2V0SGVpZ2h0LCBjbGllbnRMZWZ0LCBzY3JvbGxMZWZ0LCBvZmZzZXRMZWZ0LCBjbGllbnRUb3AsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAod2luZG93ICYmIChcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChfZW50cmllcykgPT4geyBoYW5kbGVVcGRhdGUoKTsgfSk7XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBvYnNlcnZlQm94IH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgeyByZWZFbGVtZW50UmV0dXJuIH0gPSB1c2VSZWZFbGVtZW50PEU+KHtcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGU6IEUgfCBudWxsLCBwOiBFIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4geyBuZWVkQU5ld09ic2VydmVyKGUsIGdldE9ic2VydmVCb3g/LigpKTsgb25FbGVtZW50Q2hhbmdlPy4oZSwgcCk7IH0sIFtdKSxcbiAgICAgICAgICAgIG9uTW91bnQsXG4gICAgICAgICAgICBvblVubW91bnRcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50IH0gPSByZWZFbGVtZW50UmV0dXJuXG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZ2V0T2JzZXJ2ZUJveCkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRPYnNlcnZlQm94LmN1cnJlbnQgIT09IGdldE9ic2VydmVCb3goKSlcbiAgICAgICAgICAgICAgICBuZWVkQU5ld09ic2VydmVyKGdldEVsZW1lbnQoKSwgZ2V0T2JzZXJ2ZUJveCgpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZWxlbWVudFNpemVSZXR1cm46IHsgZ2V0U2l6ZSB9LFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuXG4gICAgfVxuXG5cbn1cbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkQ2hpbGRyZW4oeyBjaGlsZHJlbjogbGhzIH06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+LCB7IGNoaWxkcmVuOiByaHN9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJjaGlsZHJlblwiPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PltcImNoaWxkcmVuXCJdIHtcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHJocztcbiAgICB9XG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGxocztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxyXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cclxuICogXHJcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XHJcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyBjbGFzczogbGhzQ2xhc3MsIGNsYXNzTmFtZTogbGhzQ2xhc3NOYW1lIH06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+LCB7IGNsYXNzOiByaHNDbGFzcywgY2xhc3NOYW1lOiByaHNDbGFzc05hbWV9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBcImNsYXNzXCIgfCBcImNsYXNzTmFtZVwiPik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblxyXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xyXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXHJcblxyXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcclxuICAgICAgICBjb25zdCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWxsQ2xhc3Nlcykuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGgsIFJlZiwgUmVmQ2FsbGJhY2ssIFJlZk9iamVjdCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJlZihpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgIChyZWYgYXMgUmVmT2JqZWN0PFQgfCBudWxsPikuY3VycmVudCA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBSPEU+IHtcclxuICAgIHJlZj86IFJlZjxFPjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cclxuICogQHBhcmFtIGxocyBcclxuICogQHBhcmFtIHJocyBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHsgcmVmOiByaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHsgcmVmOiBsaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pIHtcclxuICAgIGNvbnN0IGNvbWJpbmVkOiBSZWZDYWxsYmFjazxFPiA9IHVzZUNhbGxiYWNrKChjdXJyZW50OiBFIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcclxuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIHJocyk7XHJcbiAgICB9LCBbbGhzLCByaHNdKTtcclxuXHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsaHMhO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG5mdW5jdGlvbiBzdHlsZVN0cmluZ1RvT2JqZWN0KHN0eWxlOiBzdHJpbmcpOiBoLkpTWC5DU1NQcm9wZXJ0aWVzIHtcclxuICAgIC8vIFRPRE86IFRoaXMgc3Vja3MgRDpcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0d28gc3R5bGUgb2JqZWN0cywgcmV0dXJuaW5nIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcclxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcclxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+LCByaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0ge1xyXG5cclxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxyXG4gICAgaWYgKCFsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xyXG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiAhcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5zdHlsZTtcclxuICAgICAgICBpZiAoIWxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIHJocy5zdHlsZTtcclxuXHJcbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSkge1xyXG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyh7IHN0eWxlOiBzdHlsZVN0cmluZ1RvT2JqZWN0KGxocz8uc3R5bGUgYXMgc3RyaW5nKSB9LCByaHMpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QocmhzPy5zdHlsZSBhcyBzdHJpbmcpIH0pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2dpYz8/P1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cclxuICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2xocy5zdHlsZX07JHtyaHM/LnN0eWxlID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi4obGhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgICAgICAuLi4ocmhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcmVmc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlc1wiO1xyXG5cclxubGV0IGxvZyA9IGNvbnNvbGUud2FybjtcclxuXHJcblxyXG5leHBvcnQgdHlwZSBFeHRyYWN0ZWRQcm9wczxPIGV4dGVuZHMge30+ID0geyBbSyBpbiBrZXlvZiBPXTogUGljazxPW0tdLCAoXCJwcm9wc1N0YWJsZVwiIHwgXCJwcm9wc1Vuc3RhYmxlXCIpICYga2V5b2YgT1tLXT4gfTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xyXG4gICAgbG9nID0gbG9nMlxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiguLi5hbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5bXSkge1xyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWVyZ2VkUHJvcHNcIiwgYWxsUHJvcHMubGVuZ3RoKTtcclxuICAgIGxldCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge307XHJcbiAgICBmb3IgKGxldCBuZXh0UHJvcHMgb2YgYWxsUHJvcHMpIHtcclxuICAgICAgICByZXQgPSB1c2VNZXJnZWRQcm9wczI8RT4ocmV0LCBuZXh0UHJvcHMpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlTWVyZ2VkUHJvcHMyPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXHJcbiAqIGFuZCBub3QgdGhlIGdlbmVyaWMgXCJJJ2xsIGFjY2VwdCBhbnkgc3RyaW5nIGFuZCBhbnkgaGFuZGxlclwiIG9uZS5cclxuICogXHJcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxyXG4gKiBsaWIuZG9tLnRzIGFsd2F5cyBnaXZlaW5nIHRoZSB0d28gb3ZlcmxvYWRzIGluIHRoZSBzYW1lIG9yZGVyLCB3aXRoIHRoZVxyXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xyXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxyXG4gKiBcclxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cclxuICovXHJcbnR5cGUgRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8VD4gPVxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xyXG5cclxuLy8gR2V0IGp1c3QgdGhlIHR5cGVkIHZlcnNpb24gb2YgYWRkRXZlbnRMaXN0ZW5lciwgaWYgaXQgZXhpc3RzXHJcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBcImFkZEV2ZW50TGlzdGVuZXJcIiAodGhlIGV2ZW50IHR5cGUgYXMgYSBzdHJpbmcpXHJcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XHJcblxyXG5cclxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXHJcbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cclxuLy8gSSBkb24ndCBrbm93IHdoeSBgaW5mZXIgSGAgaXMgZG9pbmcgdGhhdCB3aGVuIHRoZSB0eXBlIHNob3VsZCBiZSBuYXJyb3dlZCBieSBgVGAgdGhvdWdoLi4uXHJcbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcclxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogaW5mZXIgSCwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBOb25OdWxsYWJsZTxIPiA6IG5ldmVyO1xyXG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xyXG5cclxudHlwZSBQYXJhbWV0ZXJzMjxUIGV4dGVuZHMgKEV2ZW50TGlzdGVuZXJPYmplY3QgfCAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk+ID1cclxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xyXG5cclxuXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlciB0byBhbnkgKm5vbi1QcmVhY3QqIGVsZW1lbnQsIGFuZCByZW1vdmluZyBpdCB3aGVuIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhvb2sgdW5tb3VudHMuIFRoZSBjYWxsYmFjayBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICogXHJcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxyXG4gKiBcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKiBcclxuICogVGhlIHR5cGUgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGJ1dCBuYXJyb3dzIGRvd24gdGhlIHR5cGUgZnJvbSBcImEgdW5pb24gb2YgYWxsIGV2ZW50c1wiIHRvIHdoYXRldmVyIHlvdSBzcGVjaWZ5LCBhbmQgZXJyb3JzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAqIFxyXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqIFxyXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cclxuICogQHJldHVybnNcclxuICogKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XHJcblxyXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cclxuICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXHJcbiAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxyXG4gICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cclxuXHJcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyID8/ICgoKSA9PiB7IH0pKSBhcyBFdmVudExpc3RlbmVyO1xyXG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcclxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxyXG4gKiBcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxyXG4gKiBcclxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKiBcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xyXG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjayg8RXZlbnRUeXBlIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIHsgW0sgaW4gRXZlbnRUeXBlXTogdHlwZW9mIGhhbmRsZXIgfSwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcclxuICAgICAgICB9LCBbdHlwZV0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XHJcblxyXG4gICAgfSwgW10pO1xyXG59XHJcbiIsImNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdhW2hyZWZdJyxcbiAgJ2J1dHRvbicsXG4gICdbdGFiaW5kZXhdOm5vdChzbG90KScsXG4gICdhdWRpb1tjb250cm9sc10nLFxuICAndmlkZW9bY29udHJvbHNdJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJyxcbiAgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyxcbiAgJ2RldGFpbHMnLFxuXTtcbmNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG5cbmNvbnN0IE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcblxuY29uc3QgbWF0Y2hlcyA9IE5vRWxlbWVudFxuICA/IGZ1bmN0aW9uICgpIHt9XG4gIDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9XG4gICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGVcbiAgICA/IChlbGVtZW50KSA9PiBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICA6IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXG4gKiBAcGFyYW0geyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICBsZXQgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKVxuICApO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseSA9IGZ1bmN0aW9uIChcbiAgZWxlbWVudHMsXG4gIGluY2x1ZGVDb250YWluZXIsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gIGNvbnN0IGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1RvQ2hlY2suc2hpZnQoKTtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICBjb25zdCBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgY29uc3QgY29udGVudCA9IGFzc2lnbmVkLmxlbmd0aCA/IGFzc2lnbmVkIDogZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIGNhbmRpZGF0ZSBlbGVtZW50XG4gICAgICBjb25zdCB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbGlkQ2FuZGlkYXRlICYmXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmXG4gICAgICAgIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBzaGFkb3cgY29udGVudCBpZiBwb3NzaWJsZVxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9XG4gICAgICAgIGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgICAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpKTtcblxuICAgICAgY29uc3QgdmFsaWRTaGFkb3dSb290ID1cbiAgICAgICAgIW9wdGlvbnMuc2hhZG93Um9vdEZpbHRlciB8fCBvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIoZWxlbWVudCk7XG5cbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoXG4gICAgICAgICAgc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0KC4uLmVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGdldFRhYmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIGlzU2NvcGUpIHtcbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgLy9cbiAgICAvLyBpc1Njb3BlIGlzIHBvc2l0aXZlIGZvciBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCBieSBkZWZhdWx0XG4gICAgLy8gaGF2ZSB0YWJJbmRleCAtMSwgYnV0IG5lZWQgdG8gYmUgc29ydGVkIGJ5IGRvY3VtZW50IG9yZGVyIGluIG9yZGVyIGZvciB0aGVpclxuICAgIC8vIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICBpZiAoXG4gICAgICAoaXNTY29wZSB8fFxuICAgICAgICAvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fFxuICAgICAgICBub2RlLmlzQ29udGVudEVkaXRhYmxlKSAmJlxuICAgICAgaXNOYU4ocGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSlcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxuY29uc3Qgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleFxuICAgID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyXG4gICAgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbmNvbnN0IGlzSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcblxuY29uc3QgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHIgPVxuICAgIG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAuYXBwbHkobm9kZS5jaGlsZHJlbilcbiAgICAgIC5zb21lKChjaGlsZCkgPT4gY2hpbGQudGFnTmFtZSA9PT0gJ1NVTU1BUlknKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5jb25zdCBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiAobm9kZXMsIGZvcm0pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcbiAgY29uc3QgcXVlcnlSYWRpb3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nXG4gICAgKTtcbiAgfTtcblxuICBsZXQgcmFkaW9TZXQ7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLFxuICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG5cbmNvbnN0IGlzUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xuXG5jb25zdCBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufTtcblxuLy8gZGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgdWx0aW1hdGVseSBhdHRhY2hlZCB0byB0aGUgd2luZG93J3MgZG9jdW1lbnRcbmNvbnN0IGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBUbyBmdXJ0aGVyIGNvbXBsaWNhdGUgdGhpbmdzLCB3ZSBoYXZlIHRvIGxvb2sgYWxsIHRoZSB3YXkgdXAgdW50aWwgd2UgZmluZCBhIHNoYWRvdyBIT1NUXG4gIC8vICB0aGF0IGlzIGF0dGFjaGVkIChvciBmaW5kIG5vbmUpIGJlY2F1c2UgdGhlIG5vZGUgbWlnaHQgYmUgaW4gbmVzdGVkIHNoYWRvd3MuLi5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgbm90IGEgc2hhZG93IHJvb3QsIGl0IHdvbid0IGhhdmUgYSBob3N0LCBhbmQgc28gcm9vdE5vZGUgc2hvdWxkIGJlIHRoZVxuICAvLyAgZG9jdW1lbnQgKHBlciB0aGUgZG9jcykgYW5kIHdoaWxlIGl0J3MgYSBEb2N1bWVudC10eXBlIG9iamVjdCwgdGhhdCBkb2N1bWVudCBkb2VzIG5vdFxuICAvLyAgYXBwZWFyIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBub2RlJ3MgYG93bmVyRG9jdW1lbnRgIGZvciBzb21lIHJlYXNvbiwgc28gaXQncyBzYWZlclxuICAvLyAgdG8gaWdub3JlIHRoZSByb290Tm9kZSBhdCB0aGlzIHBvaW50LCBhbmQgdXNlIGBub2RlLm93bmVyRG9jdW1lbnRgLiBPdGhlcndpc2UsXG4gIC8vICB1c2luZyBgcm9vdE5vZGUuY29udGFpbnMobm9kZSlgIHdpbGwgX2Fsd2F5c18gYmUgdHJ1ZSB3ZSdsbCBnZXQgZmFsc2UtcG9zaXRpdmVzIHdoZW5cbiAgLy8gIG5vZGUgaXMgYWN0dWFsbHkgZGV0YWNoZWQuXG4gIGxldCBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlKS5ob3N0O1xuICBsZXQgYXR0YWNoZWQgPSAhIShcbiAgICBub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSB8fFxuICAgIG5vZGUub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKVxuICApO1xuXG4gIHdoaWxlICghYXR0YWNoZWQgJiYgbm9kZVJvb3RIb3N0KSB7XG4gICAgLy8gc2luY2UgaXQncyBub3QgYXR0YWNoZWQgYW5kIHdlIGhhdmUgYSByb290IGhvc3QsIHRoZSBub2RlIE1VU1QgYmUgaW4gYSBuZXN0ZWQgc2hhZG93IERPTSxcbiAgICAvLyAgd2hpY2ggbWVhbnMgd2UgbmVlZCB0byBnZXQgdGhlIGhvc3QncyBob3N0IGFuZCBjaGVjayBpZiB0aGF0IHBhcmVudCBob3N0IGlzIGNvbnRhaW5lZFxuICAgIC8vICBpbiAoaS5lLiBhdHRhY2hlZCB0bykgdGhlIGRvY3VtZW50XG4gICAgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZVJvb3RIb3N0KS5ob3N0O1xuICAgIGF0dGFjaGVkID0gISFub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KTtcbiAgfVxuXG4gIHJldHVybiBhdHRhY2hlZDtcbn07XG5cbmNvbnN0IGlzWmVyb0FyZWEgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xuY29uc3QgaXNIaWRkZW4gPSBmdW5jdGlvbiAobm9kZSwgeyBkaXNwbGF5Q2hlY2ssIGdldFNoYWRvd1Jvb3QgfSkge1xuICAvLyBOT1RFOiB2aXNpYmlsaXR5IHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxuICAvLyAgKHNlZSBub3RlcyBhYm91dCB0aGlzIGZ1cnRoZXIgZG93biksIHdoaWNoIG1lYW5zIHdlIHdpbGwgY29uc2lkZXIgaXQgdmlzaWJsZVxuICAvLyAgKHRoaXMgaXMgbGVnYWN5IGJlaGF2aW9yIGZyb20gYSB2ZXJ5IGxvbmcgd2F5IGJhY2spXG4gIC8vIE5PVEU6IHdlIGNoZWNrIHRoaXMgcmVnYXJkbGVzcyBvZiBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBiZWNhdXNlIHRoaXMgaXMgYVxuICAvLyAgX3Zpc2liaWxpdHlfIGNoZWNrLCBub3QgYSBfZGlzcGxheV8gY2hlY2tcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgY29uc3Qgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoXG4gICAgIWRpc3BsYXlDaGVjayB8fFxuICAgIGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnIHx8XG4gICAgZGlzcGxheUNoZWNrID09PSAnbGVnYWN5LWZ1bGwnXG4gICkge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmXG4gICAgICAgICAgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSAvLyBjaGVjayBpZiB0aGVyZSdzIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBub2RlIGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgd2hpY2ggbWVhbnMgd2UgY2FuIG9ubHkgdHJlYXQgaXQgYXMgYSBibGFjayBib3gsIHNvIHdlXG4gICAgICAgICAgLy8gIGZhbGwgYmFjayB0byBhIG5vbi16ZXJvLWFyZWEgdGVzdFxuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBzbG90XG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJlbnRFbGVtZW50ICYmIHJvb3ROb2RlICE9PSBub2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBjcm9zcyBzaGFkb3cgYm91bmRhcnlcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIG5vcm1hbCBkb21cbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gICAgLy9cbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcbiAgICAvLyAgbm9kZXMgYXMgdmlzaWJsZSB3aXRoIHRoZSAnbm9uZScgZmFsbGJhY2suX19cbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXG4gICAgfVxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcbiAgLy8gIGl0J3MgdmlzaWJsZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5jb25zdCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgLy8gY2hlY2sgaWYgYG5vZGVgIGlzIGNvbnRhaW5lZCBpbiBhIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJylcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkIHx8XG4gICAgaXNIaWRkZW5JbnB1dChub2RlKSB8fFxuICAgIGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gICAgLy8gRm9yIGEgZGV0YWlscyBlbGVtZW50IHdpdGggYSBzdW1tYXJ5LCB0aGUgc3VtbWFyeSBlbGVtZW50IGdldHMgdGhlIGZvY3VzXG4gICAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHxcbiAgICBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHxcbiAgICBnZXRUYWJpbmRleChub2RlKSA8IDAgfHxcbiAgICAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gKHNoYWRvd0hvc3ROb2RlKSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn0gY2FuZGlkYXRlc1xuICogQHJldHVybnMgRWxlbWVudFtdXG4gKi9cbmNvbnN0IHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICBjb25zdCBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGNvbnN0IGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGU7XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICBjb25zdCBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgaXNTY29wZVxuICAgICAgICA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaCguLi5lbGVtZW50cylcbiAgICAgICAgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcbiAgICAgICAgY29udGVudDogZWxlbWVudHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLnJlZHVjZSgoYWNjLCBzb3J0YWJsZSkgPT4ge1xuICAgICAgc29ydGFibGUuaXNTY29wZVxuICAgICAgICA/IGFjYy5wdXNoKC4uLnNvcnRhYmxlLmNvbnRlbnQpXG4gICAgICAgIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG5jb25zdCB0YWJiYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9yc1xuICAuY29uY2F0KCdpZnJhbWUnKVxuICAuam9pbignLCcpO1xuXG5jb25zdCBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIH0gZnJvbSBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmZ1bmN0aW9uIGJsb2NraW5nRWxlbWVudHMoKSB7IHJldHVybiAoZ2V0RG9jdW1lbnQoKSBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyB9XG4vKipcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cbiAqIFxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uIFxuICogKHNwZWNpZmljYWxseSB2aWEgYGJsb2NraW5nRWxlbWVudHNgLCB3aXRoIGEgc21hbGwgcG9seWZpbGwgYmVjYXVzZSBJJ20gbm90IHN1cmUgaG93IGxvbmdcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXG4gKiBAcGFyYW0gdGFyZ2V0IFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50PEUgZXh0ZW5kcyBFbGVtZW50PihlbmFibGVkOiBib29sZWFuLCBnZXRUYXJnZXQ6ICgpID0+IChFIHwgbnVsbCkpIHtcblxuICAgIGNvbnN0IHN0YWJsZUdldFRhcmdldCA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFRhcmdldCk7XG5cbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWJsZUdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgYmxvY2tpbmdFbGVtZW50cyB3aWxsIGZhaWwgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IGlzbid0IGNvbm5lY3RlZCB0byBkb2N1bWVudC5ib2R5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByYXJlLCBidXQgaXQncyBiZXR0ZXIgdG8gZmFpbCBzaWxlbnRseSB3aXRoIHdlaXJkIHRhYmJpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIHRoYW4gdG8gY3Jhc2ggdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnB1c2godGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5yZW1vdmUodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWxsLCBzZW1pLXNpbGVudGx5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZWRdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGJsb2NraW5nRWxlbWVudHMoKS50b3A7XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXRUb3BFbGVtZW50LCB1c2VCbG9ja2luZ0VsZW1lbnQgfSBmcm9tIFwiLi91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPEU+LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB7IGZvY3VzVHJhcFBhcmFtZXRlcnM6IHsgdHJhcEFjdGl2ZTogYm9vbGVhbjsgfSB9XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUge1xuICAgIGZvY3VzVHJhcDogeyBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB9XG59XG5cbmNvbnN0IGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUbyA9IG5ldyBNYXA8RWxlbWVudCB8IG51bGwsIChOb2RlICYgSFRNTE9yU1ZHRWxlbWVudCk+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1RyYXA8RSBleHRlbmRzIEVsZW1lbnQ+KHtcbiAgICBmb2N1c1RyYXBQYXJhbWV0ZXJzOiB7IHRyYXBBY3RpdmUgfSxcbiAgICBhY3RpdmVFbGVtZW50UGFyYW1ldGVycyxcbiAgICByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2UsIC4uLnJlZkVsZW1lbnRQYXJhbWV0ZXJzIH1cbn06IFVzZUZvY3VzVHJhcFBhcmFtZXRlcnM8RT4pOiBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEU+IHtcblxuICAgIGNvbnN0IGhhbmRsZUFjdGl2ZUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFwQWN0aXZlOiBib29sZWFuLCBlbGVtZW50OiBFIHwgbnVsbCkgPT4ge1xuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXh0cmEgcXVldWVNaWNyb3Rhc2sgaXMgbmVlZGVkIGZvclxuICAgICAgICAgICAgICAgIC8vIC4uLnJlYXNvbnM/XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudCkge1xuXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBmb2N1cyB0byB0aGUgZWxlbWVudFxuICAgICAgICAgICAgLy8gdGhhdCBoYXMgcmV0dXJuZWQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvLmdldChnZXRUb3BFbGVtZW50KCkpPy5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8RT4oe1xuICAgICAgICByZWZFbGVtZW50UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIHA6IEUgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQWN0aXZlQ2hhbmdlKHRyYXBBY3RpdmUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIG9uRWxlbWVudENoYW5nZT8uKGVsZW1lbnQsIHApO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAuLi5yZWZFbGVtZW50UGFyYW1ldGVyc1xuICAgICAgICB9XG4gICAgfSlcbiAgICBjb25zdCB7IGFjdGl2ZUVsZW1lbnRSZXR1cm4gfSA9IHVzZUFjdGl2ZUVsZW1lbnQoeyBhY3RpdmVFbGVtZW50UGFyYW1ldGVycyB9KTtcbiAgICBjb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG4gICAgY29uc3QgeyBnZXRMYXN0QWN0aXZlRWxlbWVudCB9ID0gYWN0aXZlRWxlbWVudFJldHVybjtcblxuXG4gICAgLy8gV2hlbiB0aGUgdHJhcCBiZWNvbWVzIGFjdGl2ZSwgYmVmb3JlIHdlIGxldCB0aGUgYmxvY2tpbmdFbGVtZW50cyBob29rIHJ1bixcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXRldmVyJ3MgY3VycmVudGx5IGZvY3VzZWQgYW5kIHNhdmUgaXQuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBnZXREb2N1bWVudChlbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgICAgICAgICAgLy8gdG8gd2hhdGV2ZXIncyBjdXJyZW50bHkgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2tcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5zZXQoZ2V0VG9wRWxlbWVudCgpLCAoZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpKSA/PyBkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgfVxuICAgIH0sIFt0cmFwQWN0aXZlXSk7XG5cbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCk7XG5cbiAgICAvKipcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxuICAgICAqIGNoYW5nZSBmb2N1cyB0byBzb21ldGhpbmcgZWxzZSAoc29tZXRoaW5nIGluXG4gICAgICogdGhlIHRyYXAgaWYgaXQncyBhY3RpdmUsIG9yIHdoYXRldmVyIHdlJ3ZlXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KCkpO1xuICAgIH0sIFt0cmFwQWN0aXZlXSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIGZvY3VzVHJhcDogeyBwcm9wc1Vuc3RhYmxlOiB7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB9XG4gICAgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBjb250YWluZWQgd2l0aGluIHRoZSBnaXZlbiBub2RlLCBvciBudWxsIGlmIG5vbmUgYXJlIGZvdW5kLlxuICogQHBhcmFtIGVsZW1lbnQgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50OiBOb2RlKSB7XG4gICAgY29uc3QgdHJlZVdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsIHsgYWNjZXB0Tm9kZTogKG5vZGUpID0+IChub2RlIGluc3RhbmNlb2YgRWxlbWVudCAmJiBpc0ZvY3VzYWJsZShub2RlKSA/IE5vZGVGaWx0ZXIuRklMVEVSX0FDQ0VQVCA6IE5vZGVGaWx0ZXIuRklMVEVSX1NLSVApIH0pXG4gICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSB0cmVlV2Fsa2VyLmZpcnN0Q2hpbGQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpIHwgbnVsbDtcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XG59XG5cbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCwgd2hlbiBjYWxsZWQsIGZvcmNlIHRoZSBjb21wb25lbnRcbiAqIHRoYXQgdXNlcyB0aGlzIGhvb2sgdG8gcmUtcmVuZGVyIGl0c2VsZi5cbiAqIFxuICogSXQncyBhIGJpdCBzbWVsbHksIHNvIGJlc3QgdG8gdXNlIHNwYXJpbmdseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgICByZXR1cm4gdXNlUmVmKCgpID0+IHNldChpID0+ICsraSkpLmN1cnJlbnQ7XG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRpbWVvdXRQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dFBhcmFtZXRlcnMpIHtcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgc3RhcnRUaW1lUmVmLmN1cnJlbnQgPSBudWxsOyBjYWxsYmFjaygpOyB9KTtcbiAgICBjb25zdCBnZXRUaW1lb3V0ID0gdXNlU3RhYmxlR2V0dGVyKHRpbWVvdXQpO1xuXG4gICAgLy8gU2V0IGFueSB0aW1lIHdlIHN0YXJ0IHRpbWVvdXQuXG4gICAgLy8gVW5zZXQgYW55IHRpbWUgdGhlIHRpbWVvdXQgY29tcGxldGVzXG4gICAgY29uc3Qgc3RhcnRUaW1lUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgdGltZW91dElzTnVsbCA9ICh0aW1lb3V0ID09IG51bGwpO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRyaWdnZXJJbmRleCBjaGFuZ2VzIChpbmNsdWRpbmcgb24gbW91bnQpXG4gICAgLy8gcmVzdGFydCB0aGUgdGltZW91dC4gIFRoZSB0aW1lb3V0IGRvZXMgTk9UIHJlc2V0XG4gICAgLy8gd2hlbiB0aGUgZHVyYXRpb24gb3IgY2FsbGJhY2sgY2hhbmdlcywgb25seSB0cmlnZ2VySW5kZXguXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0aW1lb3V0SXNOdWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0VGltZW91dCgpO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGltZW91dElzTnVsbCA9PSAodGltZW91dCA9PSBudWxsKSk7XG4gICAgXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lUmVmLmN1cnJlbnQgPSArKG5ldyBEYXRlKCkpO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoc3RhYmxlQ2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LCBbdHJpZ2dlckluZGV4LCB0aW1lb3V0SXNOdWxsXSlcblxuICAgIGNvbnN0IGdldEVsYXBzZWRUaW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCsobmV3IERhdGUoKSkpIC0gKCsoc3RhcnRUaW1lUmVmLmN1cnJlbnQgPz8gbmV3IERhdGUoKSkpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFJlbWFpbmluZ1RpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgIHJldHVybiB0aW1lb3V0ID09IG51bGwgPyBudWxsIDogTWF0aC5tYXgoMCwgdGltZW91dCAtIGdldEVsYXBzZWRUaW1lKCkpXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgZ2V0RWxhcHNlZFRpbWUsIGdldFJlbWFpbmluZ1RpbWUgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwiLi91c2UtdGltZW91dFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcbn1cblxuaW50ZXJmYWNlIExOUCB7XG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvUHJldigpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9GaXJzdCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggYXJyb3cga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICogTm90IHJlbGF0aXZlIHRvIHRoZSB3cml0aW5nIG1vZGUgLS0gdGhlc2UgYXJlIHRoZSBsaXRlcmFsIGtleXMgdGhhdCBuZWVkIHRvIGJlIHByZXNzZWQuXG4gICAgICogXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICAgICAqIFxuICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPzogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgfCBcImVpdGhlclwiIHwgXCJub25lXCI7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmUgXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZVxuICAgICAqIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzPzogYm9vbGVhbjtcbn1cbmV4cG9ydCB0eXBlIExpbmVhck5hdmlnYXRpb25PbWl0cyA9IGtleW9mIExOUDtcblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBhcmVudCBgdXNlTGluZWFyTmF2aWdhdGlvbmAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHM+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogT21pdDxMTlAsIE9taXRzPlxufVxuXG5cbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkYCAqL1xuLy9leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25DaGlsZEluZm8geyB9XG5cbi8qKlxuICogV2hlbiB1c2VkIGluIHRhbmRlbSB3aXRoIGB1c2VSb3ZpbmdUYWJJbmRleGAsIGFsbG93cyBjb250cm9sIG9mXG4gKiB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IG5hdmlnYXRlVG9GaXJzdDogbnRmLCBuYXZpZ2F0ZVRvTGFzdDogbnRsLCBuYXZpZ2F0ZVRvTmV4dDogbnRuLCBuYXZpZ2F0ZVRvUHJldjogbnRwLCBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuZCwgZGlzYWJsZUFycm93S2V5czogZGFrLCBkaXNhYmxlSG9tZUVuZEtleXM6IGRoZWsgfSB9OiBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlcj4pOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG4gICAgbmQgPz89IFwiZWl0aGVyXCI7XG5cbiAgICAvL2NvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyB9ID0gdXNlTG9naWNhbERpcmVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe30pO1xuXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRmKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bCk7XG4gICAgY29uc3QgbmF2aWdhdGVUb05leHQgPSB1c2VTdGFibGVDYWxsYmFjayhudG4pO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRwKTtcbiAgICBjb25zdCBnZXREaXNhYmxlQXJyb3dLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRhayk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUhvbWVFbmRLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRoZWspO1xuICAgIGNvbnN0IGdldE5hdmlnYXRpb25EaXJlY3Rpb24gPSB1c2VTdGFibGVHZXR0ZXIobmQpO1xuXG5cbiAgICBjb25zdCBzdGFibGVQcm9wcyA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4+KHtcbiAgICAgICAgb25LZXlEb3duOiAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXG4gICAgICAgICAgICBpZiAoZS5jdHJsS2V5IHx8IGUubWV0YUtleSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgIC8vY29uc3QgaW5mbyA9IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XG4gICAgICAgICAgICBjb25zdCBuYXZpZ2F0aW9uRGlyZWN0aW9uID0gZ2V0TmF2aWdhdGlvbkRpcmVjdGlvbigpO1xuICAgICAgICAgICAgY29uc3QgZGlzYWJsZUFycm93S2V5cyA9IGdldERpc2FibGVBcnJvd0tleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc2FibGVIb21lRW5kS2V5cyA9IGdldERpc2FibGVIb21lRW5kS2V5cygpO1xuXG4gICAgICAgICAgICBjb25zdCBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcInZlcnRpY2FsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcbiAgICAgICAgICAgIGNvbnN0IGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NIb3Jpem9udGFsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHtcbiAgICAgICAgICAgIHByb3BzU3RhYmxlOiBzdGFibGVQcm9wcy5jdXJyZW50XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm46IHtcbiAgICAgICAgY3VycmVudFR5cGVhaGVhZDogc3RyaW5nIHwgbnVsbDtcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZDogYm9vbGVhbiB8IG51bGw7XG4gICAgICAgIHByb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG4gICAgfVxufVxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDtcbn1cblxuaW50ZXJmYWNlIFROUCB7XG4gICAgLyoqXG4gICAgICogQSBjb2xsYXRvciB0byB1c2Ugd2hlbiBjb21wYXJpbmcuIElmIG5vdCBwcm92aWRlZCwgc2ltcGx5IHVzZXMgYGxvY2FsZUNvbXBhcmVgIGFmdGVyIHRyYW5zZm9ybWluZyBlYWNoIHRvIGxvd2VyY2FzZSwgd2hpY2ggd2lsbCwgYXQgYmVzdCwgd29yayBva2F5IGluIEVuZ2xpc2guXG4gICAgICovXG4gICAgY29sbGF0b3I/OiBJbnRsLkNvbGxhdG9yO1xuXG4gICAgbm9UeXBlYWhlYWQ/OiBib29sZWFuO1xuXG4gICAgdHlwZWFoZWFkVGltZW91dD86IG51bWJlcjtcbiAgICBnZXRJbmRleCgpOiBudW1iZXIgfCBudWxsO1xuICAgIHNldEluZGV4KHZhbHVlOiBudW1iZXIgfCBudWxsIHwgKChwcmV2aW91c1ZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKTogdm9pZDtcbn1cblxuZXhwb3J0IHR5cGUgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgVE5QO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPE9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzPiB7XG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IE9taXQ8VE5QLCBPbWl0cz5cbn1cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRgICovXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxuICAgICAqIEl0IHNob3VsZCBiZSB0aGUgc2FtZSB0ZXh0IGNvbnRlbnQgYXMgd2hhdGV2ZXIncyBkaXNwbGF5ZWQsIGlkZWFsbHkuXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcblxuICAgIGluZGV4OiBudW1iZXI7XG59XG5cbi8qKiBUeXBlIG9mIHRoZSBjaGlsZCdzIHN1Yi1ob29rICovXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSAoYXJnczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycykgPT4gdm9pZDtcblxuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXgsIG5vVHlwZWFoZWFkIH0gfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuXG4gICAgLy8gRm9yIHR5cGVhaGVhZCwga2VlcCB0cmFjayBvZiB3aGF0IG91ciBjdXJyZW50IFwic2VhcmNoXCIgc3RyaW5nIGlzIChpZiB3ZSBoYXZlIG9uZSlcbiAgICAvLyBhbmQgYWxzbyBjbGVhciBpdCBldmVyeSAxMDAwIG1zIHNpbmNlIHRoZSBsYXN0IHRpbWUgaXQgY2hhbmdlZC5cbiAgICAvLyBOZXh0LCBrZWVwIGEgbWFwcGluZyBvZiB0eXBlYWhlYWQgdmFsdWVzIHRvIGluZGljZXMgZm9yIGZhc3RlciBzZWFyY2hpbmcuXG4gICAgLy8gQW5kLCBmb3IgdGhlIHVzZXIncyBzYWtlLCBsZXQgdGhlbSBrbm93IHdoZW4gdGhlaXIgdHlwZWFoZWFkIGNhbid0IG1hdGNoIGFueXRoaW5nIGFueW1vcmVcbiAgICBjb25zdCBbY3VycmVudFR5cGVhaGVhZCwgc2V0Q3VycmVudFR5cGVhaGVhZCwgZ2V0Q3VycmVudFR5cGVhaGVhZF0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dDogdHlwZWFoZWFkVGltZW91dCA/PyAxMDAwLCBjYWxsYmFjazogKCkgPT4geyBzZXRDdXJyZW50VHlwZWFoZWFkKG51bGwpOyBzZXRJbnZhbGlkVHlwZWFoZWFkKG51bGwpOyB9LCB0cmlnZ2VySW5kZXg6IGN1cnJlbnRUeXBlYWhlYWQgfSk7XG4gICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5mbyA9IHVzZVJlZjx7IHRleHQ6IHN0cmluZywgdW5zb3J0ZWRJbmRleDogbnVtYmVyIH1bXT4oW10pO1xuICAgIGNvbnN0IFtpbnZhbGlkVHlwZWFoZWFkLCBzZXRJbnZhbGlkVHlwZWFoZWFkXSA9IHVzZVN0YXRlPGJvb2xlYW4gfCBudWxsPihmYWxzZSk7XG5cbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXG4gICAgLy8gRXNzZW50aWFsbHksIHdoZW4gYWN0aXZlLCBpZ25vcmUgZnVydGhlciBrZXlzIFxuICAgIC8vIGJlY2F1c2Ugd2UncmUgd2FpdGluZyBmb3IgYSBDb21wb3NpdGlvbkVuZCBldmVudFxuICAgIGNvbnN0IFssIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIC8vIEJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzIGZpcmUgKmFmdGVyKiBrZXlkb3duIGV2ZW50cyBcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxuICAgIC8vIHdlIGNhbiB1c2UgdGhpcyB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50IHdlJ3JlIGxpc3RlbmluZyBmb3Igb24gdGhlIGZpcnN0IGtleWRvd24uXG4gICAgY29uc3QgW25leHRUeXBlYWhlYWRDaGFyLCBzZXROZXh0VHlwZWFoZWFkQ2hhcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAobmV4dFR5cGVhaGVhZENoYXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodHlwZWFoZWFkID0+ICgodHlwZWFoZWFkID8/IFwiXCIpICsgbmV4dFR5cGVhaGVhZENoYXIpKTtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW25leHRUeXBlYWhlYWRDaGFyXSk7XG5cblxuICAgIGNvbnN0IGNvbXBhcmF0b3JTaGFyZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoc2FmZUxoczogc3RyaW5nLCBzYWZlUmhzOiBzdHJpbmcpID0+IHtcbiAgICAgICAgbGV0IGNvbXBhcmU6IG51bWJlcjtcbiAgICAgICAgLy8gRm9yIHRoZSBwdXJwb3NlcyBvZiB0eXBlYWhlYWQsIG9ubHkgY29tcGFyZSBhIHN0cmluZyBvZiB0aGUgc2FtZSBzaXplIGFzIG91ciBjdXJyZW50bHkgdHlwZWQgc3RyaW5nLlxuICAgICAgICAvLyBCeSBub3JtYWxpemluZyB0aGVtIGZpcnN0LCB3ZSBlbnN1cmUgdGhpcyBieXRlLWJ5LWJ5dGUgaGFuZGxpbmcgb2YgcmF3IGNoYXJhY3RlciBkYXRhIHdvcmtzIG91dCBva2F5LlxuICAgICAgICBzYWZlTGhzID0gc2FmZUxocy5ub3JtYWxpemUoXCJORkRcIik7XG4gICAgICAgIHNhZmVSaHMgPSBzYWZlUmhzLm5vcm1hbGl6ZShcIk5GRFwiKVxuXG4gICAgICAgIGlmIChjb2xsYXRvcilcbiAgICAgICAgICAgIGNvbXBhcmUgPSBjb2xsYXRvci5jb21wYXJlKHNhZmVMaHMsIHNhZmVSaHMpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XG5cbiAgICAgICAgcmV0dXJuIGNvbXBhcmU7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpbnNlcnRpbmdDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgcmhzLnRleHQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIER1cmluZyB0eXBlYWhlYWQsIGFsbCBzdHJpbmdzIGxvbmdlciB0aGFuIG91cnMgc2hvdWxkIGJlIHRydW5jYXRlZFxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5J3JlIGFsbCBjb25zaWRlcmVkIGVxdWFsbHkgYnkgdGhhdCBwb2ludC5cbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQuc3Vic3RyaW5nKDAsIGxocy5sZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IHVzZVN0YWJsZUdldHRlcihub1R5cGVhaGVhZCk7XG5cblxuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pj4oe1xuICAgICAgICBvbktleURvd246IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNEaXNhYmxlZCgpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgY29uc3QgaW1lQWN0aXZlID0gZ2V0SW1lQWN0aXZlKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xuXG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGxhc3QgY2hhcmFjdGVyIGluIGEgd2F5IHRoYXQgZG9lc24ndCBzcGxpdCBVVEYtMTYgc3Vycm9nYXRlcy5cbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG5vIG9uZS1jaGFyYWN0ZXIgbmFtZXMsIGFuZCB0aGVyZSBhcmUgbm8gbm9uLUFTQ0lJLWFscGhhIG5hbWVzLlxuICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyS2V5KSB7XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGJlY2F1c2UgYSBzcGFjZWJhciBjYW4ndCBldmVyIFxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhIHR5cGVhaGVhZCwgb25seSBjb250aW51ZSBvbmUuXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gKFNwZWNpZmljYWxseSwgbGV0IHRoZSBldmVudCBjb250aW51ZSBwcm9wYWdhdGlvbiBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXb24ndCBiZSB0cnVlIGZvciB0aGUgZmlyc3Qga2V5ZG93blxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBhY3R1YWxseSBhcHBseSB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1lQWN0aXZlKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSksXG4gICAgICAgIG9uQ29tcG9zaXRpb25TdGFydDogdXNlU3RhYmxlQ2FsbGJhY2soKGU6IENvbXBvc2l0aW9uRXZlbnQpID0+IHtcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGUuZGF0YSk7XG4gICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xuICAgICAgICB9KSxcbiAgICAgICAgb25Db21wb3NpdGlvbkVuZDogdXNlU3RhYmxlQ2FsbGJhY2soKF9lOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKSB9KSxcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIGluIHR5cGVhaGVhZCB0aGF0IGNhdXNlIGNoYW5nZXMgdG8gdGhlIHRhYmJhYmxlIGluZGV4XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRUeXBlYWhlYWQgJiYgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCkge1xuXG5cblxuICAgICAgICAgICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCB0eXBlYWhlYWRDb21wYXJhdG9yKTtcblxuICAgICAgICAgICAgaWYgKHNvcnRlZFR5cGVhaGVhZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGhhcyB0eXBlZCBhbiBlbnRyeSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAvLyAob3IgbW9yZSBzcGVjaWZpY2FsbHkgXCJmb3Igd2hpY2ggdGhlcmUgaXMgbm8gZW50cnkgdGhhdCBzdGFydHMgd2l0aCB0aGF0IGlucHV0XCIpXG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQoZmFsc2UpO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgIFdlIGtub3cgcm91Z2hseSB3aGVyZSwgaW4gdGhlIHNvcnRlZCBhcnJheSBvZiBzdHJpbmdzLCBvdXIgbmV4dCB0eXBlYWhlYWQgbG9jYXRpb24gaXMuXG4gICAgICAgICAgICAgICAgICBCdXQgcm91Z2hseSBpc24ndCBnb29kIGVub3VnaCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgIFRvIGNvbnZlcnQgb3VyIHNvcnRlZCBpbmRleCB0byB0aGUgdW5zb3J0ZWQgaW5kZXggd2UgbmVlZCwgd2UgaGF2ZSB0byBmaW5kIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgZWxlbWVudCB0aGF0IG1hdGNoZXMgdXMgKmFuZCogKGlmIGFueSBzdWNoIGV4aXN0KSBpcyAqYWZ0ZXIqIG91ciBjdXJyZW50IHNlbGVjdGlvbi5cblxuICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBvbmx5IHdheSB0eXBlYWhlYWQgbW92ZXMgYmFja3dhcmRzIHJlbGF0aXZlIHRvIG91ciBjdXJyZW50XG4gICAgICAgICAgICAgICAgICBwb3NpdGlvbiBpcyBpZiB0aGUgb25seSBvdGhlciBvcHRpb24gaXMgYmVoaW5kIHVzLlxuXG4gICAgICAgICAgICAgICAgICBJdCdzIG5vdCBzcGVjaWZpZWQgaW4gV0FJLUFSSUEgd2hhdCB0byBkbyBpbiB0aGF0IGNhc2UuICBJIHN1cHBvc2Ugd3JhcCBiYWNrIHRvIHRoZSBzdGFydD9cbiAgICAgICAgICAgICAgICAgIFRob3VnaCB0aGVyZSdzIGFsc28gYSBjYXNlIGZvciBqdXN0IGdvaW5nIHVwd2FyZHMgdG8gdGhlIG5lYXJlc3QgdG8gcHJldmVudCBqdW1waW5lc3MuXG4gICAgICAgICAgICAgICAgICBCdXQgaWYgeW91J3JlIGFscmVhZHkgZG9pbmcgdHlwZWFoZWFkIG9uIGFuIHVuc29ydGVkIGxpc3QsIGxpa2UsIGp1bXBpbmVzcyBjYW4ndCBiZSBhdm9pZGVkLlxuICAgICAgICAgICAgICAgICAgSSBkdW5uby4gR29pbmcgYmFjayB0byB0aGUgc3RhcnQgaXMgdGhlIHNpbXBsaXN0IHRob3VnaC5cblxuICAgICAgICAgICAgICAgICAgQmFzaWNhbGx5IHdoYXQgdGhpcyBkb2VzOiBTdGFydGluZyBmcm9tIHdoZXJlIHdlIGZvdW5kIG91cnNlbHZlcyBhZnRlciBvdXIgYmluYXJ5IHNlYXJjaCxcbiAgICAgICAgICAgICAgICAgIHNjYW4gYmFja3dhcmRzIGFuZCBmb3J3YXJkcyB0aHJvdWdoIGFsbCBhZGphY2VudCBlbnRyaWVzIHRoYXQgYWxzbyBjb21wYXJlIGVxdWFsbHkgc28gdGhhdFxuICAgICAgICAgICAgICAgICAgd2UgY2FuIGZpbmQgdGhlIG9uZSB3aG9zZSBgdW5zb3J0ZWRJbmRleGAgaXMgdGhlIGxvd2VzdCBhbW9uZ3N0IGFsbCBvdGhlciBlcXVhbCBzdHJpbmdzXG4gICAgICAgICAgICAgICAgICAoYW5kIGFsc28gdGhlIGxvd2VzdCBgdW5zb3J0ZWRJbmRleGAgeWFkZGEgeWFkZGEgZXhjZXB0IHRoYXQgaXQgY29tZXMgYWZ0ZXIgdXMpLlxuXG4gICAgICAgICAgICAgICAgICBUT0RPOiBUaGUgYmluYXJ5IHNlYXJjaCBzdGFydHMgdGhpcyBvZmYgd2l0aCBhIHNvbGlkIE8obG9nIG4pLCBidXQgb25lLWNoYXJhY3RlciBcbiAgICAgICAgICAgICAgICAgIHNlYXJjaGVzIGFyZSwgdGhhbmtzIHRvIHBpZ2VvbmhvbGUgcHJpbmNpcGFsLCBldmVudHVhbGx5IGd1YXJhbnRlZWQgdG8gYmVjb21lIFxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW4gXG4gICAgICAgICAgICAgICAgICBleGNlcHRpb24gZm9yIG9uZS1jaGFyYWN0ZXIgc3RyaW5ncywgYnV0IHRoYXQncyBqdXN0IGtpY2tpbmcgdGhlIGNhbiBkb3duIFxuICAgICAgICAgICAgICAgICAgdGhlIHJvYWQuIE1heWJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB3b3VsZCBiZSBnb29kIGVub3VnaCB0aG91Z2guXG4gICAgICAgICAgICAgICAgKi9cblxuXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSB0d28gYXJlIG9ubHkgc2V0IGZvciBlbGVtZW50cyB0aGF0IGFyZSBhaGVhZCBvZiB1cywgYnV0IHRoZSBwcmluY2lwbGUncyB0aGUgc2FtZSBvdGhlcndpc2VcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUJlc3RGaXQgPSAodTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPSB1O1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICgobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQpICYmIHUgPiAoZ2V0SW5kZXgoKSA/PyAtSW5maW5pdHkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgKytpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4TmV4dF0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4QWxsXS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjdXJyZW50VHlwZWFoZWFkXSk7XG5cbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ+KCh7IGluZGV4LCB0ZXh0IH0pID0+IHtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRleHQpIHtcblxuICAgICAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdG8gaW5zZXJ0IHRoaXMgaXRlbS5cbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGFsbCBpbmRleCB2YWx1ZXMgc2hvdWxkIGJlIHVuaXF1ZSwgdGhlIHJldHVybmVkIHNvcnRlZEluZGV4XG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGFsd2F5cyByZWZlciB0byBhIG5ldyBsb2NhdGlvbiAoaS5lLiBiZSBuZWdhdGl2ZSkgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5tb3VudGluZywgZmluZCB3aGVyZSB3ZSB3ZXJlIGFuZCByZW1vdmUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgICAvLyBBZ2Fpbiwgd2Ugc2hvdWxkIGFsd2F5cyBmaW5kIG91cnNlbHZlcyBiZWNhdXNlIHRoZXJlIHNob3VsZCBiZSBubyBkdXBsaWNhdGUgdmFsdWVzIGlmIGVhY2ggaW5kZXggaXMgdW5pcXVlLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbdGV4dF0pO1xuXG4gICAgICAgIHJldHVybjtcblxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudFxuICAgICAgICB9XG4gICAgfVxufVxuXG5cbi8qKlxuICogWW91ciB1c3VhbCBiaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uLlxuICogXG4gKiBJdCdzIHVzZWQgaGVyZSB0byBxdWlja2x5IGZpbmQgYSBnb29kIHNwb3QgdG8gc3RhcnQgc2VhcmNoaW5nIGZvciBvdXIgbmV4dCB0eXBlYWhlYWQgY2FuZGlkYXRlLlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXG4gKiBAcGFyYW0gY29tcGFyYXRvciBDb21wYXJlcyBgd2FudGVkYCB3aXRoIHRoZSBjdXJyZW50IHZhbHVlIGluIGBhcnJheWBcbiAqIEByZXR1cm5zIEEgbm9uLW5lZ2F0aXZlIHZhbHVlIGlmIGB3YW50ZWRgIHdhcyBmb3VuZCwgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIGlmIG5vdC4gXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VCwgVSwgRiBleHRlbmRzIChsaHM6IFUsIHJoczogVCkgPT4gbnVtYmVyPihhcnJheTogVFtdLCB3YW50ZWQ6IFUsIGNvbXBhcmF0b3I6IEYpOiBudW1iZXIge1xuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcbiAgICBsZXQgbGFzdEluZGV4ID0gYXJyYXkubGVuZ3RoIC0gMTtcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XG4gICAgICAgIGNvbnN0IGNvbXBhcmlzb25SZXN1bHQgPSBjb21wYXJhdG9yKHdhbnRlZCwgYXJyYXlbdGVzdEluZGV4XSk7XG5cbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XG4gICAgICAgICAgICBmaXJzdEluZGV4ID0gdGVzdEluZGV4ICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xuICAgICAgICAgICAgbGFzdEluZGV4ID0gdGVzdEluZGV4IC0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gLWZpcnN0SW5kZXggLSAxO1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCJ1c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcInVzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+ID0gUmVxdWlyZWQ8ST4gJiBGbGFnZ2FibGVDaGlsZEluZm88XCJ0YWJiYWJsZVwiPiAmIHtcbi8vfTtcblxuZXhwb3J0IHR5cGUgT25UYWJiYWJsZUluZGV4Q2hhbmdlID0gKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPEUgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvPiB7XG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgdGFiYmluZyB0aHJvdWdoIHRoaXMgY29tcG9uZW50IHdpbGwgY2F1c2UgdGhlIHJlZmVyZW5jZWQgZWxlbWVudCB0byBiZSBmb2N1c2VkLlxuICAgICAqIFxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50IGlmIHlvdSdkIGxpa2UuXG4gICAgICovXG4gICAgZm9jdXNTZWxmKCk6IHZvaWQ7XG5cbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xuXG4gICAgaGlkZGVuOiBib29sZWFuO1xuXG4gICAgc3ViSW5mbzogUnRpU3ViSW5mbztcbn1cblxuaW50ZXJmYWNlIFJUSVAge1xuICAgIC8vIENhbGxlZCBkdXJpbmcgYW4gZWZmZWN0IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIHJlbmRlcmVkIGl0c2VsZiBpbiBhIHRhYmJhYmxlIHN0YXRlXG4gICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xuXG4gICAgb25UYWJiYWJsZUluZGV4Q2hhbmdlPzogT25UYWJiYWJsZUluZGV4Q2hhbmdlO1xuXG4gICAgLy9vblRhYmJlZEluVG8/OiAoKSA9PiB2b2lkO1xuICAgIC8vb25UYWJiZWRPdXRPZj86ICgpID0+IHZvaWQ7XG5cbiAgICBpbml0aWFsSW5kZXg/OiBudW1iZXI7XG59XG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIFJUSVA7XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxudW1iZXIsIE1jT21pdHM+IHtcbiAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICByb3ZpbmdUYWJJbmRleFJldHVybjoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZUluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBmb2N1c1NlbGY6ICgpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbn1cblxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBSdGljT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIiwgU3ViYmVzdEluZm8+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj4+O1xuICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFBhcnRpYWw8T21pdDxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBhbnk+LCBcImdldEVsZW1lbnRcIiB8IFwic3ViSW5mb1wiIHwgXCJmb2N1c1NlbGZcIj4+LCBSdGljT21pdHM+ICYgT21pdDx7IG5vTW9kaWZ5VGFiSW5kZXg6IGJvb2xlYW4sIGZvY3VzU2VsZihlOiBDaGlsZEVsZW1lbnQpOiB2b2lkOyB9LCBSdGljT21pdHM+O1xufVxuXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cywgbmV2ZXIsIG5ldmVyLCBSdGlTdWJJbmZvPikgPT4gVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQ+W1wiaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyc1wiXSwgXCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PjtcbiAgICAvL29uRm9jdXNlZElubmVyQ2hhbmdlZDogKGZvY3VzZWQ6IGJvb2xlYW4sIF9wcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4gdm9pZDtcbiAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuOiB7XG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgLyoqICpVbnN0YWJsZSogKi9cbiAgICAvL3JvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pjtcbn1cblxuXG4vKipcbiAqIEltcGxlbWVudHMgYSByb3ZpbmcgdGFiaW5kZXggc3lzdGVtIHdoZXJlIG9ubHkgb25lIFwiZm9jdXNhYmxlXCJcbiAqIGNvbXBvbmVudCBpbiBhIHNldCBpcyBhYmxlIHRvIHJlY2VpdmUgYSB0YWIgZm9jdXMuICpXaGljaCpcbiAqIG9mIHRob3NlIGVsZW1lbnRzIHJlY2VpdmVzIGZvY3VzIGlzIGRldGVybWluZWQgYnkgeW91LCBidXQgaXQnc1xuICogcmVjb21tZW5kZWQgdG8gb2ZmbG9hZCB0aGF0IGxvZ2ljIHRoZW4gdG8gYW5vdGhlciBob29rLCBsaWtlXG4gKiBgdXNlTGluZWFyTmF2aWdhdGlvbmAsIHdoaWNoIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGVcbiAqIGVsZW1lbnQgd2l0aCB0aGUgYXJyb3cga2V5cywgYHVzZVR5cGVhaGVhZE5hdmlnYXRpb25gLCB3aGljaFxuICogbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHR5cGVhaGVhZCwgb3JcbiAqIGB1c2VMaXN0TmF2aWdhdGlvbmAgaWYgeW91IGp1c3Qgd2FudCBldmVyeXRoaW5nIGJ1bmRsZWQgdG9nZXRoZXIuXG4gKiBcbiAqIE5vdGUgdGhhdCB0aGUgY2hpbGQgaG9vayByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZFxuICogYnkgZXZlcnkgY2hpbGQgdGhhdCB1c2VzIHRoaXMgcm92aW5nIHRhYmluZGV4IGxvZ2ljLiAgVGhlXG4gKiBwcm9wLW1vZGlmeWluZyBob29rICp0aGF0KiBob29rIHJldHVybnMgc2hvdWxkIHRoZW4gYmUgdXNlZFxuICogb24gdGhlIGNoaWxkJ3MgZWxlbWVudCwgYXMgd2VsbCBhcyBhbnkgb3RoZXIgZWxlbWVudHMgeW91J2QgbGlrZVxuICogdG8gYmUgZXhwbGljaXRseSBtYWRlIHVudGFiYmFibGUgdG9vLlxuICogXG4gKiBgc2hvdWxkRm9jdXNPbkNoYW5nZWAgc2hvdWxkIHJldHVybiB0cnVlIGlmIGZvY3VzIGlzIFxuICogY29udGFpbmVkIHdpdGhpbiB3aGF0ZXZlciBlbGVtZW50IGNvbnRhaW5zIHRoZSByb3ZpbmcgdGFiIGluZGV4LlxuICogR2VuZXJhbGx5IGFzIHNpbXBsZSBhcyB0aGUgZm9sbG93aW5nOlxuICogYGBgXG4gKiBjb25zdCBbZm9jdXNlZElubmVyLCBzZXRGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICogY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxQYXJlbnRFbGVtZW50Pih7IHNldEZvY3VzZWRJbm5lciB9KTtcbiAqIGNvbnN0IGZvY3VzT25DaGFuZ2UgPSAoZm9jdXNlZElubmVyICE9IGZhbHNlKTtcbiAqIGBgYFxuICogSXQncyBub3QgaW5jbHVkZWQgaGVyZSBiZWNhdXNlIGB1c2VSb3ZpbmdUYWJJbmRleGAgZG9lc24ndCBrbm93IFxuICogYW55dGhpbmcgYWJvdXQgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBvbmx5IGNoaWxkcmVuIGVsZW1lbnRzLlxuICogQW5kIGp1c3QgYXMgd2VsbCEgQ2hpbGRyZW4gc2hvdWxkIGJlIGFsbG93ZWQgYXQgdGhlIHJvb3QsIFxuICogcmVnYXJkbGVzcyBvZiBpZiBpdCdzIHRoZSB3aG9sZSBhcHAgb3IganVzdCBhIGdpdmVuIGNvbXBvbmVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxuZXZlciwgbmV2ZXI+KTogVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuXG4gICAgbGV0IHsgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9LCByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIG9uVGFiYmFibGVSZW5kZXIgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XG4gICAgLypjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKG9sZENvdW50ID09IDAgJiYgbmV3Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZEluVG8/LigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuWmVybyk7Ki9cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XG4gICAgLy8gV2hhdCBpdCBpcywgYW5kIHdoZXRoZXIsIHdoZW4gd2UgcmVuZGVyIHRoaXMgY29tcG9uZW50IGFuZCBpdCdzIGNoYW5nZWQsIHRvIGFsc28gZm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgbWFkZSB0YWJiYWJsZS5cbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ID8/IDAgfSwgW10pKTtcbiAgICBjb25zdCBzZXRUYWJiYWJsZUluZGV4ID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4MigocHJldkluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyKHByZXZJbmRleCA/PyBudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyO1xuXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBjaGFuZ2VJbmRleChuZXh0SW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KG5leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgLy9jb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiAocHJldkNoaWxkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgLy8gICAgcHJldkNoaWxkLnN1YkluZm8uYmx1clNlbGYoKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXh0Q2hpbGQuc3ViSW5mby5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8ICFlbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5zdWJJbmZvLmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMsXG4gICAgLy8gbm90aWZ5IHRoZSBwcmV2aW91cyBjaGlsZCB0aGF0IGl0J3Mgbm8gbG9uZ2VyIHRhYmJhYmxlLFxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlblJldHVybiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG1vdW50ZWQsIHVubW91bnRlZCk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuO1xuXG4gICAgY29uc3QgeyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oeyBpbml0aWFsSW5kZXgsIGNoaWxkcmVuLCBjbG9zZXN0Rml0OiB0cnVlLCBrZXk6IFwidGFiYmFibGVcIiB9KTtcblxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+ID0+IHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgZm9jdXNTZWxmOiBmb2N1c1NlbGZPdmVycmlkZSwgbm9Nb2RpZnlUYWJJbmRleCwgaGlkZGVuIH0sXG4gICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSxcbiAgICAgICAgICAgIC8vaGFzRm9jdXNQYXJhbWV0ZXJzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXNQYXJhbWV0ZXJzIH0sXG4gICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgIH0gPSBjaGlsZFBhcmFtZXRlcnM7XG5cbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XG4gICAgICAgIH0sIFshIWhpZGRlbl0pXG5cblxuICAgICAgICBjb25zdCBzdGFibGVGb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjayhmb2N1c1NlbGZPdmVycmlkZSk7XG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IG51bGwgfHwgIWVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpXG4gICAgICAgICAgICAgICAgICAgIHN0YWJsZUZvY3VzU2VsZihlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIC8qY29uc3QgeyBhY3RpdmVFbGVtZW50UmV0dXJuLCBoYXNGb2N1c1JldHVybiwgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlSGFzRm9jdXM8Q2hpbGRFbGVtZW50Pih7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50UGFyYW1ldGVycyxcbiAgICAgICAgICAgIGhhc0ZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICxcbiAgICAgICAgICAgICAgICAuLi5oYXNGb2N1c1BhcmFtZXRlcnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWZFbGVtZW50UGFyYW1ldGVyc1xuICAgICAgICB9KTsqL1xuICAgICAgICAvL2NvbnN0IHsgZ2V0RWxlbWVudCB9ID0gcmVmRWxlbWVudFJldHVybjtcblxuICAgICAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlLCBnZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgICAgIGNvbnN0IHRhYmJhYmxlRmxhZ3MgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFRhYmJhYmxlLCBzZXQ6IHNldFRhYmJhYmxlLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhaGlkZGVuKSB9KTtcblxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgICAgICBmbGFnczogeyAuLi5mbGFncywgdGFiYmFibGU6IHRhYmJhYmxlRmxhZ3MuY3VycmVudCB9IGFzIFBhcnRpYWw8UmVjb3JkPEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIENoaWxkRmxhZ09wZXJhdGlvbnM+PixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7XG4gICAgICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgaGlkZGVuOiAhIWhpZGRlbixcbiAgICAgICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGFiYmFibGUpXG4gICAgICAgICAgICAgICAgc3RhYmxlT25UYWJiYWJsZVJlbmRlcihpbmRleCk7XG4gICAgICAgIH0sIFt0YWJiYWJsZSwgaW5kZXhdKTtcblxuICAgICAgICAvL2NvbnN0IHJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyA9IHVzZU1lcmdlZFByb3BzKHJlZkVsZW1lbnRQcm9wcywgeyB0YWJJbmRleDogbm9Nb2RpZnlUYWJJbmRleCA/IHVuZGVmaW5lZCA6ICh0YWJiYWJsZSA/IDAgOiAtMSkgfSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBfcHJldkZvY3VzZWQ6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuOiB7XG4gICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZTogeyB0YWJJbmRleDogbm9Nb2RpZnlUYWJJbmRleCA/IHVuZGVmaW5lZCA6ICh0YWJiYWJsZSA/IDAgOiAtMSkgfSxcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0VGFiYmFibGVJbmRleCgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGluZGV4KT8uc3ViSW5mby5mb2N1c1NlbGY/LigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IHtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLypmdW5jdGlvbiB0ZXN0KCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxEaXZFbGVtZW50LCB7IFwiZm9vXCI6IFwiYmFyXCIgfSwgXCJmbGFnMlwiPih7IG1hbmFnZWRDaGlsZHJlbjoge30sIHJvdmluZ1RhYkluZGV4OiB7fSB9KTtcbiAgICBjb25zdCB7IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4OiAwLCBmbGFnczoge30gfSwgcnRpOiB7IGluZm8zOiB7IGZvbzogXCJiYXJcIiB9IH0gfSk7XG59Ki9cbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cywgT25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCB1c2VSb3ZpbmdUYWJJbmRleCwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8gfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8qKlxuICogXG4gKiBUT0RPOiBUaGlzIHRhYmxlIHdhcyBzY3JhcHBlZCB3aGVuIHRoaXMgd2FzIGNoYW5nZWQgdG8ganVzdCBhY2NlcHQgYSBjb2xsYXRvciBkaXJlY3RseSxcbiAqIGJ1dCBpdCdzIG5vdCBiYWQgZm9yIGEgY29sbGF0aW9uIGNyYXNoIGNvdXJzZSBhbmQgSSBtaWdodCB1c2UgaXQgYWdhaW4uXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cbiAqIFxuICogfExhbmcufFRhcmdldHxVc2VyIGlucHV0fGBiYXNlYHxgYWNjZW50YHxgY2FzZWB8YHZhcmlhbnRgfFxuICogfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18XG4gKiB8RU58SGl8QnllfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnxIaXxIaXzinIV84pyFfOKchXzinIV8XG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcbiAqIHxFTnxIaXxoaXzinIV84pyFfOKdjHzinYx8XG4gKiB8RU58SGl8SMOvfOKchXzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhYXzinYx84p2MfOKdjHzinYx8XG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxuICogfERBfMOlfEFBfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YUF84p2MfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfEpQfO+qqnznnYB84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zvvbZ84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zjgYt84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zjg7V84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zji5V84pyFfOKchXzinYx84p2MfFxuICogfEpQfOOCq3zjgqx84pyFfOKdjHzinYx84p2MfFxuICogfEpQfOOCq3zlipt84p2MfOKdjHzinYx84p2MfFxuICogfFpIfOe0hXznuqJ84p2MfOKdjHzinYx84p2MfFxuICogXG4gKiBcbiAqIChOb3RlIHRvIHNlbGY6IEF0IHNvbWUgcG9pbnQsIHRoaXMgZmlsZSB3aWxsIHByb2JhYmx5IGJlIG5vcm1hbGl6ZWRcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxuICogXG4gKi9cbmNvbnN0IF9kdW1teTogYW55ID0gbnVsbDtcblxuXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XG50eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+IHtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgc3ViSW5mbzogQztcbn1cblxuLyoqXG4gKiBAcGFyYW0gZnJvbVVzZXJJbnRlcmFjdGlvbiBXaGV0aGVyIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGlzIGNoaWxkIGFzIGEgbWVhbnMgb2YgbmF2aWdhdGluZyB0byBpdC4gIEluIHRoYXQgd2FzIHRoZSBjYXNlLCB0aGUgY2hpbGQgaXMgYWxzbyBmb2N1c2VkLiBPdGhlcndpc2UsIGZvY3VzIG1vdmVzIGFzIHRoZSBicm93c2VyIGRldGVybWluZXMuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuXG5cbmludGVyZmFjZSBMU1Age1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBhbmQgaW5kZXhEZW1hbmdsZXIgYXJlIHVzZWQgdG8gYWxsb3cgY2hpbGRyZW4gdG8gYmUgbmF2aWdhdGVkIGluIGFuIG9yZGVyXG4gICAgICogdGhhdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1hdGNoIHRoZWlyIGNoaWxkIG9yZGVyLCBsaWtlIGlmIGEgbGlzdCBpcyBzb3J0ZWQuXG4gICAgICogXG4gICAgICogVXNlZCB0byB0dXJuIGFuIFwiYWJzb2x1dGVcIiBpbmRleCBpbnRvIGEgXCJzb3J0ZWQvZmlsdGVyZWQvbWFuZ2xlZFwiIG9uZS5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgbmF2aWdhdGVUb0ZpcnN0IG1hbmdsZXMgMCBhbmQgbmF2aWdhdGVzIHRvIHRoYXQgcmVzdWx0aW5nIHJvdy5cbiAgICAgKiBAcGFyYW0gcmF3SW5kZXggXG4gICAgICovXG4gICAgaW5kZXhNYW5nbGVyPyhyYXdJbmRleDogbnVtYmVyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0dXJuIGEgXCJtYW5nbGVkXCIgaW5kZXggaW50byBpdCdzIFwidW5zb3J0ZWRcIiBvciBcInVubWFuZ2xlZFwiIGluZGV4LlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleCxcbiAgICAgKiBpdCBuZWVkcyB0byBiZSBkZW1hbmdsZWQgdG8gZG8gXCJub3JtYWxcIiBtYXRoIG9uIGl0LCBhbmQgdGhlbiByZS1tYW5nbGVkIChhYm92ZSlcbiAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1lZEluZGV4IFxuICAgICAqL1xuICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzID0ga2V5b2YgTFNQO1xuXG4vLyAqKiogUGFyYW1ldGVycyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMsIE1jT21pdHM+LFxuICAgIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRuT21pdHMgfCBcImdldEluZGV4XCIgfCBcInNldEluZGV4XCI+LFxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPExuT21pdHMgfCBcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiB7XG4gICAgbGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzOiBPbWl0PExTUCwgTHNPbWl0cz47XG59XG5cblxuXG5cblxuZXhwb3J0IHR5cGUgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzID0ga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPGFueT47XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzLCBSdGlPbWl0cywgTWNPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICAvL3JvdmluZ1RhYkluZGV4OiBPbWl0PFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzLCBuZXZlcj5bXCJyb3ZpbmdUYWJJbmRleFwiXSwgXCJzdWJJbmZvXCI+O1xuICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBMc09taXRzIHwgXCJzdWJJbmZvXCI+O1xufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4+LCBcInRhYmJhYmxlXCIgfCBFeHRyYUZsYWdLZXlzPixcbiAgICBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50T3JDaGlsZEVsZW1lbnQ+LFxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuICAgIGxpc3ROYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgIG5hdmlnYXRlVG9JbmRleDogTmF2aWdhdGVUb0luZGV4XG4gICAgfTtcbn1cblxuLy8gKioqIFJldHVybiB0eXBlcyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4ge1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VIYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzPENoaWxkRWxlbWVudD5bXCJoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzXCJdLCBcIm9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWRcIj4+O1xuICAgIC8vb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiAoZm9jdXNlZDogYm9vbGVhbiwgX3ByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIC8vcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG4gICAgLy9saXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XG59XG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBMc1N1YkluZm8+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG4vKipcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXG4gKiBcbiAqIEluIHRoZSBkb2N1bWVudCBvcmRlciwgdGhlcmUgd2lsbCBiZSBvbmx5IG9uZSBcImZvY3VzZWRcIiBvciBcInRhYmJhYmxlXCIgZWxlbWVudCwgbWFraW5nIGl0IGFjdCBtb3JlIGxpa2Ugb25lIGNvbXBsZXRlIHVuaXQgaW4gY29tcGFyaXNvbiB0byBldmVyeXRoaW5nIGFyb3VuZCBpdC5cbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSB0ZXh0IGZvciB0eXBlYWhlYWQgdG8gZm9jdXMgdGhlIG5leHQgaXRlbSB0aGF0IG1hdGNoZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4oe1xuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCAuLi5tYyB9LFxuICAgIHJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyxcbiAgICBsaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM6IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBpbmRleE1hbmdsZXIgPz89IGlkZW50aXR5O1xuICAgIGluZGV4RGVtYW5nbGVyID8/PSBpZGVudGl0eTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxpc3ROYXZpZ2F0aW9uXCIsIGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIpO1xuXG5cbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlblJldHVybiwgcm92aW5nVGFiSW5kZXhSZXR1cm4sIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgfSA9IHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXM+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgLi4ubWMsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtLCB1KSA9PiB7XG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obSwgdSk7XG4gICAgICAgICAgICB9LCBbXSlcbiAgICAgICAgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCB7IGNoaWxkcmVuIH0gPSBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm47XG4gICAgY29uc3QgeyBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0gPSByb3ZpbmdUYWJJbmRleFJldHVybjtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9JbmRleCA9IHVzZUNhbGxiYWNrKChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XG4gICAgICAgIGlmIChpICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRJbmRleCA9IHRyeU5hdmlnYXRlVG9JbmRleCh7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpLFxuICAgICAgICAgICAgICAgIHNlYXJjaERpcmVjdGlvbjogMSxcbiAgICAgICAgICAgICAgICBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSxcbiAgICAgICAgICAgICAgICBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4LCBmcm9tVXNlckludGVyYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCxcbiAgICAgICAgICAgIHNldEluZGV4OiB1c2VDYWxsYmFjaygoaW5kZXg6IChudW1iZXIgfCBudWxsKSB8ICgocHJldjogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xuICAgICAgICAgICAgfSwgW10pLFxuICAgICAgICAgICAgLi4udHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHsgbGluZWFyTmF2aWdhdGlvblJldHVybiB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXY6IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KHsgY2hpbGRyZW4sIGRlZmF1bHQ6IGMgPz8gMCwgdGFyZ2V0OiBpbmRleERlbWFuZ2xlciEoaW5kZXhNYW5nbGVyISgoYyA/PyAwKSkgLSAxKSwgc2VhcmNoRGlyZWN0aW9uOiAtMSwgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSB9KVxuICAgICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dDogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKGMgPz8gMCkgKyAxKSwgc2VhcmNoRGlyZWN0aW9uOiAxLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pO1xuICAgICAgICAgICAgICAgIH0sIHRydWUpXG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyISgwKSwgdHJ1ZSk7IH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0OiB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleChpbmRleERlbWFuZ2xlciEoY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCkpLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgLi4ubGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnNcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+PigoYXJnczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIExzU3ViSW5mbz4pOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+ID0+IHtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCBmbGFncyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgZm9jdXNTZWxmLCBoaWRkZW4sIG5vTW9kaWZ5VGFiSW5kZXggfSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IHRleHQgfSxcbiAgICAgICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgICAgICBzdWJJbmZvXG4gICAgICAgIH0gPSBhcmdzO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgX3Y6IHZvaWQgPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQoeyB0ZXh0LCBpbmRleCB9KTtcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChnZXRUYWJiYWJsZUluZGV4KCkgPT0gZ2V0SW5kZXgoKSkge1xuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLCBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzIH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgZm9jdXNTZWxmLCBoaWRkZW46ICEhaGlkZGVuLCBub01vZGlmeVRhYkluZGV4IH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7IHRleHQsIHN1YkluZm8gfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUmV0dXJuOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfVxufVxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSz47XG4gICAgZGVmYXVsdDogbnVtYmVyO1xuICAgIHRhcmdldDogbnVtYmVyO1xuICAgIHNlYXJjaERpcmVjdGlvbjogMSB8IC0xO1xuICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgIGluZGV4RGVtYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cnlOYXZpZ2F0ZVRvSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbiwgc2VhcmNoRGlyZWN0aW9uLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCB0YXJnZXQgfTogVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEs+KSB7XG4gICAgY29uc3QgdXBwZXIgPSBjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKTtcbiAgICBjb25zdCBsb3dlciA9IDA7XG5cbiAgICBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAtMSkge1xuICAgICAgICB3aGlsZSAoKHRhcmdldCA+PSBsb3dlciAmJiAoY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKSlcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpIC0gMSk7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldCA8IGxvd2VyID8gaW5kZXhEZW1hbmdsZXIobG93ZXIpIDogdGFyZ2V0O1xuICAgIH1cbiAgICBlbHNlIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IDEpIHtcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPD0gdXBwZXIgJiYgY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgKyAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0ID4gdXBwZXIgPyBpbmRleERlbWFuZ2xlcih1cHBlcikgOiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbG93ZXI7XG4gICAgfVxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzIH0gZnJvbSBcIi4vdXNlLXJvdmluZy10YWJpbmRleFwiO1xuaW1wb3J0IHsgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtY3VycmVudC1mb2N1c1wiO1xuXG4vKipcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXG4gKiBcbiAqIFRoaXMgcmVzdWx0cyBpbiBhIGxvdCBvZiB0aGluZ3Mgd2l0aCB2ZXJ5IHNpbWlsYXIgbmFtZXMgYW5kIGp1c3QgY29uZnVzaW9uIGFsbCBhcm91bmQuIFBsZWFzZSB1c2UgY2F1dGlvbi5cbiAqL1xuXG4vLyBQYXJhbWV0ZXJzIChwYXJlbnQsIHJvdywgY2VsbClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cyB8IFwibmF2aWdhdGlvbkRpcmVjdGlvblwiLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge1xuICAgICAgICByb3dJbmRleE1hbmdsZXI/OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcImxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXVtcImluZGV4TWFuZ2xlclwiXTtcbiAgICAgICAgcm93SW5kZXhEZW1hbmdsZXI/OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPltcImxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1wiXVtcImluZGV4RGVtYW5nbGVyXCJdO1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxDUj4ge1xuICAgIHN1YkluZm86IENSO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFN1YkluZm88Q0M+IHtcbiAgICBzdWJJbmZvOiBDQztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ1IsXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxuICAgIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxuICAgIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyxcblxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcbiAgICBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLFxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLFxuXG4gICAgU3ViYmVzdEluZm9cbj4ge1xuICAgIGFzUGFyZW50Um93T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMgfCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiwgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+O1xuICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxDUj4sIEtSLCBMc0NoaWxkT21pdHMsIFJ0aUNoaWxkT21pdHMgfCBcImZvY3VzU2VsZlwiLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPlxuXG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmcsIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFN1YkluZm88Q0M+LCBLQywgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiB7XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxSb3dTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4ge1xuICAgIGdyaWROYXZpZ2F0aW9uUmV0dXJuOiB7XG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcbiAgICAgICAgY3VycmVudENvbHVtbjogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ1IsIEtSPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Sb3c6IFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSLCBLQz47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbzxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ2VsbFN1YkluZm8sIEtDIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgYXNDaGlsZFJvdzogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPFJvdz47XG4gICAgYXNQYXJlbnRPZkNlbGxzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFJvdywgQ2VsbCwgVXNlR3JpZE5hdmlnYXRpb25DZWxsU3ViSW5mbzxDZWxsU3ViSW5mbz4sIEtDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENlbGxTdWJJbmZvLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdywgQ2VsbCwgQ2VsbFN1YkluZm8sIEtDPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCwgQ2VsbFN1YkluZm8sIEtDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxDZWxsPltcImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZFwiIHwgXCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PjtcbiAgICBncmlkTmF2aWdhdGlvblJldHVybjoge1xuICAgICAgICAvL3Jvd0lzVGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8vZ2V0Um93SXNUYWJiYWJsZSgpOiBib29sZWFuO1xuICAgICAgICBnZXRDdXJyZW50Q29sdW1uKCk6IG51bWJlciB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xuICAgIC8vcHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xuICAgIC8vb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHZvaWQ7XG59XG5cblxuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93LCBDUiwgS1IsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQ1I+KSA9PiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93LCBDZWxsLCBDQywgS0M+O1xuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbCwgQ0MsIEtDLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDQz4pID0+IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbD47XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uPFxuICAgIFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIFJvd1N1YkluZm8sXG4gICAgQ2VsbFN1YkluZm8sXG4gICAgUm93RXh0cmFGbGFncyBleHRlbmRzIHN0cmluZyxcbiAgICBDZWxsRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZ1xuPih7XG4gICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogbWMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiBydGksXG4gICAgbGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzOiBscyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogbG4sXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHRuLFxuICAgIGdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyByb3dJbmRleERlbWFuZ2xlciwgcm93SW5kZXhNYW5nbGVyIH1cbn06IFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4ge1xuICAgIGNvbnN0IFtjdXJyZW50Q29sdW1uLCBzZXRDdXJyZW50Q29sdW1uLCBnZXRDdXJyZW50Q29sdW1uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KHJ0aS5pbml0aWFsSW5kZXggPz8gMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3csXG4gICAgICAgIC4uLnBhcmVudExzUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxSb3dTdWJJbmZvPiwgUm93RXh0cmFGbGFncz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzOiBtYyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiBydGksXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBpbmRleERlbWFuZ2xlcjogcm93SW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlcjogcm93SW5kZXhNYW5nbGVyLCAuLi5scyB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIC4uLmxuIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB0bixcbiAgICB9KTtcblxuXG4gICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25Sb3cgPSB1c2VDYWxsYmFjazxVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUm93U3ViSW5mbywgQ2VsbFN1YkluZm8sIFJvd0V4dHJhRmxhZ3MsIENlbGxFeHRyYUZsYWdzPj4oKHsgYXNDaGlsZFJvd09mU2VjdGlvbjogYXNDaGlsZCwgYXNQYXJlbnRSb3dPZkNlbGxzOiBhc1BhcmVudCB9KSA9PiB7XG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBmb2N1c1NlbGYgdGhhdCByb3ZpbmdUYWJJbmRleCBkb2VzLlxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGZvY3VzaW5nIHRoZSBlbnRpcmUgcm93LCB3ZSBhc2sgdGhlIGNlbGwgdGhhdCBjb3JyZXNwb25kc1xuICAgICAgICAvLyB0byBvdXIgY3VycmVudCBjb2x1bW4gdG8gZm9jdXMgaXRzZWxmLlxuICAgICAgICBjb25zdCBmb2N1c1NlbGZSb3cgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGdldEN1cnJlbnRDb2x1bW4oKTtcbiAgICAgICAgICAgIG5hdmlnYXRlVG9Db2x1bW4oYzIgPz8gMCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzQ2hpbGRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyh7XG4gICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuOiBhc0NoaWxkLnJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiBhc0NoaWxkLm1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogYXNDaGlsZC5saXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IC4uLmFzQ2hpbGQucm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIGZvY3VzU2VsZjogZm9jdXNTZWxmUm93IH0sXG4gICAgICAgICAgICBzdWJJbmZvOiB7IHN1YkluZm86IGFzQ2hpbGQuc3ViSW5mbyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuOiB7IHRhYmJhYmxlIH0gfSA9IHJvd0xzQ2hpbGRSZXR1cm5UeXBlO1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRhYmJhYmxlKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0NvbHVtbihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VHcmlkTmF2aWdhdGlvbkNlbGxTdWJJbmZvPENlbGxTdWJJbmZvPiwgQ2VsbEV4dHJhRmxhZ3M+KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHsgLi4uYXNQYXJlbnQubWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IC4uLmFzUGFyZW50LnJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB9LFxuICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc1BhcmVudC5saW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyAuLi5hc1BhcmVudC50eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgbm9UeXBlYWhlYWQ6IHRydWUgfSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyAuLi5hc1BhcmVudC5saXN0TmF2aWdhdGlvblBhcmFtZXRlcnMgfVxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybjogeyBzZXRUYWJiYWJsZUluZGV4IH0sXG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIsXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybjogeyBuYXZpZ2F0ZVRvSW5kZXg6IG5hdmlnYXRlVG9Db2x1bW4gfSxcbiAgICAgICAgfSA9IHJvd0xzUmV0dXJuVHlwZTtcblxuICAgICAgICAvL2NvbnN0IHJvd0hpZGRlbiA9ICEhYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5oaWRkZW47XG5cbiAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+Pigoe1xuICAgICAgICAgICAgc3ViSW5mbyxcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogbHMsXG4gICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM6IHsgZm9jdXNTZWxmOiBmb2N1c1NlbGZDZWxsLCAuLi5ydGkgfVxuICAgICAgICB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybjogcnRpX2NlbGxfcmV0LFxuICAgICAgICAgICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcbiAgICAgICAgICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIoe1xuICAgICAgICAgICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogbWFuYWdlZENoaWxkUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyAuLi5scyB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGZvY3VzU2VsZjogZm9jdXNTZWxmQ2VsbCwgLi4ucnRpIH0sXG4gICAgICAgICAgICAgICAgc3ViSW5mbzogeyBzdWJJbmZvIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+ID0ge1xuXG4gICAgICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb25SZXR1cm46IHsgZ2V0Q3VycmVudENvbHVtbiB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm46IHJ0aV9jZWxsX3JldCxcbiAgICAgICAgICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4ID09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLmluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZFBhcmFtZXRlcnMuaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+ID0ge1xuICAgICAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7XG4gICAgICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybjogcm93THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb25SZXR1cm46IHJvd0xzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvblJldHVybixcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm46IHJvd0xzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm46IHJvd0xzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuOiByb3dMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzQ2hpbGRSb3c6IHJvd0xzQ2hpbGRSZXR1cm5UeXBlLFxuXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25SZXR1cm46IHtcbiAgICAgICAgICAgIGdldEN1cnJlbnRDb2x1bW4sXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uXG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHBhcmVudExzUmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybjogcGFyZW50THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybjogcGFyZW50THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuOiBwYXJlbnRMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiBwYXJlbnRMc1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcbiAgICB9XG59XG4iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuLy9pbXBvcnQgeyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UGFyYW1ldGVycywgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IHtcclxuICAgIHJlZkVsZW1lbnRSZXR1cm46IFJlcXVpcmVkPFBpY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD5bXCJyZWZFbGVtZW50UmV0dXJuXCJdLCBcImdldEVsZW1lbnRcIj4+O1xyXG5cclxuICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBgcHJldkZvY3VzZWRgIGlzIGdlbmVyYWxseSB0aGUgb3Bwb3NpdGUgb2YgYGZvY3VzZWRgLCBidXQgb24gbW91bnQgaXQncyBgdW5kZWZpbmVkYCB3aGlsZSBgZm9jdXNlZGAgaXMgcHJvYmFibHkgZmFsc2UgKGJvdGggZmFsc3kpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwgfCAoKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB2b2lkKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlrZSBgb25Gb2N1c2VkQ2hhbmdlZGAsIGJ1dCBhbHNvICphZGRpdGlvbmFsbHkqIGlmIGFueSBjaGlsZCBlbGVtZW50cyBhcmUgZm9jdXNlZC5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG51bGwgfCAoKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB2b2lkKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNDdXJyZW50Rm9jdXNSZXR1cm5UeXBlPEUgZXh0ZW5kcyBOb2RlPiB7XHJcbiAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm46IHtcclxuICAgICAgICBwcm9wc1N0YWJsZTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RpZmllcyB0aGUgZWxlbWVudCB0byBiZSBhYmxlIHRvIHRyYWNrIGl0cyBvd24gZm9jdXMgc3RhdGVcclxuICAgICAgICAgKi9cclxuICAgICAgICAvL3Byb3BzU3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxuXHJcbiAgICAgICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgICAgIGdldEN1cnJlbnRGb2N1c2VkKCk6IGJvb2xlYW47XHJcbiAgICAgICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgICAgIGdldEN1cnJlbnRGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0N1cnJlbnRGb2N1czxUIGV4dGVuZHMgTm9kZT4oYXJnczogVXNlSGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczxUPik6IFVzZUhhc0N1cnJlbnRGb2N1c1JldHVyblR5cGU8VD4ge1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG9uRm9jdXNlZENoYW5nZWQsIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9uRm9jdXNlZElubmVyQ2hhbmdlZCB9LFxyXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm46IHsgZ2V0RWxlbWVudCB9XHJcbiAgICB9ID0gYXJncztcclxuXHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlSGFzQ3VycmVudEZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgZ2V0RWxlbWVudCk7XHJcblxyXG4gICAgY29uc3QgW2dldEZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uRm9jdXNlZENoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRGb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcblxyXG4gICAgY29uc3Qgb25Gb2N1c0luID0gdXNlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRm9jdXNFdmVudDxUPikgPT4ge1xyXG4gICAgICAgIHNldEZvY3VzZWRJbm5lcih0cnVlKTtcclxuICAgICAgICBzZXRGb2N1c2VkKGUudGFyZ2V0ID09IGdldEVsZW1lbnQoKSlcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBvbkZvY3VzT3V0ID0gdXNlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkRm9jdXNFdmVudDxUPikgPT4ge1xyXG4gICAgICAgIGlmIChlLnRhcmdldCA9PSBnZXRFbGVtZW50KCkpIHtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZElubmVyKGZhbHNlKTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHByb3BzU3RhYmxlID0gdXNlUmVmPGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+Pih7XHJcbiAgICAgICAgb25mb2N1c2luOiBvbkZvY3VzSW4sXHJcbiAgICAgICAgb25mb2N1c291dDogb25Gb2N1c091dFxyXG4gICAgfSlcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybjoge1xyXG4gICAgICAgICAgICBwcm9wc1N0YWJsZTogcHJvcHNTdGFibGUuY3VycmVudCxcclxuICAgICAgICAgICAgZ2V0Q3VycmVudEZvY3VzZWQ6IGdldEZvY3VzZWQsXHJcbiAgICAgICAgICAgIGdldEN1cnJlbnRGb2N1c2VkSW5uZXI6IGdldEZvY3VzZWRJbm5lcixcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuLy9pbXBvcnQgeyBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UGFyYW1ldGVycywgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUhhc0xhc3RGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMge1xyXG4gICAgcmVmRWxlbWVudFJldHVybjogUGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPjtcclxuICAgIGhhc0xhc3RGb2N1c1BhcmFtZXRlcnM6IHtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2ltaWxhciB0byBgb25Gb2N1c2VkQ2hhbmdlZGAsIGJ1dCBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LCBpcyBgdHJ1ZWAgaWYgdGhpcyBlbGVtZW50IHRoYXQgKmRpZCogaGF2ZSBmb2N1cyBsYXN0LlxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIFRoaXMgaXMgYWx3YXlzIGB0cnVlYCB3aGlsZSBgZm9jdXNlZGAgaXMgYHRydWVgLiBJZiBgZm9jdXNlZGAgaXMgYGZhbHNlYCwgdGhpcyBtYXkgYmUgYHRydWVgIG9yIGBmYWxzZWAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ6IG51bGwgfCAoKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB2b2lkKTtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29tYmluZXMgdGhlIGltcGxpY2F0aW9ucyBvZiBgb25Gb2N1c2VkQ2hhbmdlZGAgYW5kIGBvbkZvY3VzZWRDaGFuZ2VkYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBudWxsIHwgKChmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4gdm9pZCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlSGFzTGFzdEZvY3VzUmV0dXJuVHlwZSBleHRlbmRzIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcclxuICAgIGhhc0xhc3RGb2N1c1JldHVybjoge1xyXG4gICAgICAgIC8qKiBTVEFCTEUgKi9cclxuICAgICAgICBnZXRMYXN0Rm9jdXNlZCgpOiBib29sZWFuO1xyXG4gICAgICAgIC8qKiBTVEFCTEUgKi9cclxuICAgICAgICBnZXRMYXN0Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VIYXNMYXN0Rm9jdXM8VCBleHRlbmRzIE5vZGU+KGFyZ3M6IFVzZUhhc0xhc3RGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNMYXN0Rm9jdXNSZXR1cm5UeXBlIHtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICByZWZFbGVtZW50UmV0dXJuOiB7IGdldEVsZW1lbnQgfSxcclxuICAgICAgICBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczogeyBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIC4uLmFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzIH0sXHJcbiAgICAgICAgaGFzTGFzdEZvY3VzUGFyYW1ldGVyczogeyBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uX3ZvaWQgfVxyXG4gICAgfSA9IGFyZ3M7XHJcblxyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkKTtcclxuICAgIFxyXG4gICAgY29uc3QgW2dldExhc3RGb2N1c2VkLCBzZXRMYXN0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZENoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZElubmVyLCBzZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcblxyXG4gICAgY29uc3QgeyBhY3RpdmVFbGVtZW50UmV0dXJuIH0gPSB1c2VBY3RpdmVFbGVtZW50KHtcclxuICAgICAgICBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczoge1xyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT4+KChsYXN0QWN0aXZlRWxlbWVudCwgcHJldkxhc3RBY3RpdmVFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gbGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRJbm5lciA9ICghIXNlbGZFbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgICAgICBzZXRMYXN0Rm9jdXNlZElubmVyKGZvY3VzZWRJbm5lcik7XHJcbiAgICAgICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPy4obGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgICAgIH0sIFtdKSxcclxuICAgICAgICAgICAgLi4uYWN0aXZlRWxlbWVudFBhcmFtZXRlcnNcclxuICAgICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBhY3RpdmVFbGVtZW50UmV0dXJuLFxyXG4gICAgICAgIGhhc0xhc3RGb2N1c1JldHVybjoge1xyXG4gICAgICAgICAgICBnZXRMYXN0Rm9jdXNlZCxcclxuICAgICAgICAgICAgZ2V0TGFzdEZvY3VzZWRJbm5lcixcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbiIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlSW50ZXJ2YWxQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuXG4gICAgICovXG4gICAgaW50ZXJ2YWw6IG51bWJlciB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjayB9OiBVc2VJbnRlcnZhbFBhcmFtZXRlcnMpIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGdldEludGVydmFsID0gdXNlU3RhYmxlR2V0dGVyKGludGVydmFsKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgbGV0IGxhc3REZWxheVVzZWQgPSBpbnRlcnZhbDtcblxuICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuXG4gICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gdGhhdCBjbGVhcnMgYW5kIHJlc2V0cyB0aGUgaW50ZXJ2YWwgaWYgaXQgY2hhbmdlcy5cbiAgICAgICAgY29uc3QgYWRqdXN0YWJsZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnRlcnZhbCA9IGdldEludGVydmFsKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsICE9IGxhc3REZWxheVVzZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnRlcnZhbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRJbnRlcnZhbChhZGp1c3RhYmxlQ2FsbGJhY2ssIGxhc3REZWxheVVzZWQgPSBjdXJyZW50SW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBoYW5kbGUgPSBzZXRJbnRlcnZhbChhZGp1c3RhYmxlQ2FsbGJhY2ssIGludGVydmFsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCJ1c2UtcmVmLWVsZW1lbnRcIjtcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwiLi91c2UtZXZlbnQtaGFuZGxlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcmVzc1BhcmFtZXRlcnM8RSBleHRlbmRzIE5vZGU+IHtcbiAgICByZWZFbGVtZW50UmV0dXJuOiBSZXF1aXJlZDxQaWNrPFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+W1wicmVmRWxlbWVudFJldHVyblwiXSwgXCJnZXRFbGVtZW50XCI+PjtcbiAgICBwcmVzc1BhcmFtZXRlcnM6IHtcbiAgICAgICAgb25DbGlja1N5bmM6ICgoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZCkgfCBudWxsIHwgdW5kZWZpbmVkO1xuICAgICAgICBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfTtcbiAgICAgICAgZm9jdXNTZWxmKGVsZW1lbnQ6IEUpOiB2b2lkO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VQcmVzc1JldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICAvL2hhc0ZvY3VzUGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT5bXCJoYXNGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZFwiPj47XG4gICAgcHJlc3NSZXR1cm46IHtcbiAgICAgICAgcHJvcHNTdGFibGU6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xuICAgICAgICBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICB9XG59XG5cbmludGVyZmFjZSBVc2VQcmVzc1JldHVyblR5cGUyPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVByZXNzUmV0dXJuVHlwZTxFPiB7XG59XG5cbi8qKlxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHRvIGNyZWF0ZSBhIFwicHJlc3NcIi1saWtlIGV2ZW50IGZvclxuICogYW55IGVsZW1lbnQsIHdoZXRoZXIgaXQncyBhIG5hdGl2ZSA8QlVUVE9OPiBvciByZWd1bGFyIDxESVY+LlxuICogXG4gKiBOb3RhYmx5LCB0aGUgZm9sbG93aW5nIGNhc2VzIGFyZSBjb3ZlcmVkOlxuICogKiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgcHJvcGVybHkgZm9jdXNlZCwgZXZlbiBvbiBpT1MgU2FmYXJpICgqZXNwZWNpYWxseSogb24gaU9TIFNhZmFyaSlcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXG4gKiAqIENvbnZlcnNlbHksIG1hbnVhbGx5IHNlbGVjdGluZyB0ZXh0IHdvbid0IGludm9rZSBhIHByZXNzLlxuICogKiBLZXlib2FyZCBldmVudHMgJm1kYXNoOyBgZW50ZXJgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGhhbmRsZXIsIHdoaWxlIGBzcGFjZWAgaW52b2tlcyBpdCBvbiBrZXl1cC5cbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcbiAqIFxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcbiAqIFxuICogQHBhcmFtIG9uQ2xpY2tTeW5jIFxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkbid0IGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc3M8RSBleHRlbmRzIEVsZW1lbnQ+KGFyZ3M6IFVzZVByZXNzUGFyYW1ldGVyczxFPik6IFVzZVByZXNzUmV0dXJuVHlwZTI8RT4ge1xuICAgIGNvbnN0IHtcbiAgICAgICAgcmVmRWxlbWVudFJldHVybjogeyBnZXRFbGVtZW50IH0sXG4gICAgICAgIHByZXNzUGFyYW1ldGVyczogeyBleGNsdWRlLCBmb2N1c1NlbGYsIG9uQ2xpY2tTeW5jIH1cbiAgICB9ID0gYXJncztcblxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcbiAgICAvLyB0aGF0IG11bHRpcGxlIGFyZSB0cmlnZ2VyZWQgYXQgb25jZSwgd2Ugb25seSAqYWN0dWFsbHkqIHJlZ2lzdGVyXG4gICAgLy8gYSBwcmVzcyBvbmNlIGFsbCBvZiBvdXIgXCJvblwiIHNpZ25hbHMgaGF2ZSB0dXJuZWQgYmFjayB0byBcIm9mZlwiLlxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxuICAgIC8vIGRlY3JlbWVudGluZyB3aGVuIGRlYWN0aXZhdGVkLlxuICAgIC8vXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxuICAgIC8vIHRoaXMgaXMgcmVzZXQgYmFjayB0byAwLlxuICAgIGNvbnN0IFthY3RpdmVEdXJpbmdSZW5kZXIsIHNldEFjdGl2ZSwgZ2V0QWN0aXZlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcblxuICAgIC8vY29uc3QgeyBnZXRFbGVtZW50IH0gPSByZWZFbGVtZW50UmV0dXJuO1xuXG4gICAgLy8gSWYgd2UgdGhlIGN1cnJlbnQgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcyB0byBpbmNsdWRlIHRoaXMgZWxlbWVudFxuICAgIC8vIERVUklORyBlLmcuIGEgbW91c2Vkb3duLCB0aGVuIHdlIGRvbid0IHdhbnQgdGhlIG1vdXNldXAgdG8gXCJjb3VudFwiLCBhcyBpdCB3ZXJlLFxuICAgIC8vIGJlY2F1c2UgaXRzIG9ubHkgcHVycG9zZSB3YXMgc2VsZWN0aW5nIHRleHQsIG5vdCBjbGlja2luZyBidXR0b25zLlxuICAgIC8vXG4gICAgLy8gVG8gY2F0Y2ggdGhpcywgYW55IHRpbWUgdGhlIHRleHQgc2VsZWN0aW9uIGluY2x1ZGVzIHVzIHdoaWxlIGluIHRoZSBtaWRkbGVcbiAgICAvLyBvZiBhIGNsaWNrLCB0aGlzIGZsYWcgaXMgc2V0LCB3aGljaCBjYW5jZWxzIHRoZSBhY3RpdmF0aW9uIG9mIGEgcHJlc3MuXG4gICAgLy8gVGhlIGZsYWcgaXMgcmVzZXQgYW55IHRpbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBvciB0aGUgYnV0dG9uIGlzXG4gICAgLy8gbm8gbG9uZ2VyIGFjdGl2ZS5cbiAgICBjb25zdCBbdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSwgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbCk7XG4gICAgY29uc3QgcHNldWRvQWN0aXZlID0gKGFjdGl2ZUR1cmluZ1JlbmRlciAmJiAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsKSk7XG5cbiAgICB1c2VHbG9iYWxIYW5kbGVyKGRvY3VtZW50LCBcInNlbGVjdGlvbmNoYW5nZVwiLCBfID0+IHtcbiAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShwcmV2ID0+IG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZ2V0RWxlbWVudCgpKSA9PSAwID8gbnVsbCA6IHByZXYgIT0gbnVsbCA/IHByZXYgOiBuZXcgRGF0ZSgpKTtcbiAgICB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChhY3RpdmVEdXJpbmdSZW5kZXIgPT0gMClcbiAgICAgICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUobnVsbCk7XG5cbiAgICB9LCBbYWN0aXZlRHVyaW5nUmVuZGVyID09IDBdKTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RhcnQgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoXykgPT4ge1xuICAgICAgICBzZXRBY3RpdmUoYSA9PiArK2EpO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgb25BY3RpdmVTdG9wID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gTWF0aC5tYXgoMCwgLS1hKSk7XG5cbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lID09IG51bGwgPyBudWxsIDogK2N1cnJlbnRUaW1lIC0gK3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUpO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJzU2VsZWN0ZWQgPSBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSlcblxuICAgICAgICAvLyBJZiB3ZSdyZSBzZWxlY3RpbmcgdGV4dCAoaGV1cmlzdGljYWxseSBkZXRlcm1pbmVkIGJ5IHNlbGVjdGluZyBmb3IgbG9uZ2VyIHRoYW4gMS80IGEgc2Vjb25kLCBvciBtb3JlIHRoYW4gMiBjaGFyYWN0ZXJzKVxuICAgICAgICAvLyB0aGVuIHRoaXMgaXNuJ3QgYSBwcmVzcyBldmVudC5cbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWVhc3VyZSBnbHlwaHMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2hhcmFjdGVyc1NlbGVjdGVkID4gMSB8fCAoKHRpbWVEaWZmZXJlbmNlID8/IDApID4gMjUwICYmIGNoYXJhY3RlcnNTZWxlY3RlZCA+PSAxKSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGFjdGl2ZSA9IGdldEFjdGl2ZSgpOyAgIC8vIFdlIHF1ZXJ5IGlmIHdlJ3JlIGFjdGl2ZSAqYWZ0ZXIqIGNhbGxpbmcgc2V0U3RhdGUgYmVjYXVzZSB3ZSBjb3VudCBhIHByZXNzIGlmZiB3ZSdyZSBub3cgYXQgMC5cbiAgICAgICAgaWYgKGFjdGl2ZSA8PSAwKSB7XG4gICAgICAgICAgICBoYW5kbGVQcmVzcyhlKTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7ICAvLyBUT0RPOiBSZW1vdmUgd2hlbiBpc3N1ZSByZXNvbHZlZCBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8zNzMxXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGhhbmRsZVByZXNzID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jKSB7XG5cbiAgICAgICAgICAgIC8vIE5vdGU6IFRoZSBlbGVtZW50IGlzIGZvY3VzZWQgaGVyZSBiZWNhdXNlIG9mIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSXQncyBhbHdheXMgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBpT1MgU2FmYXJpICh0ZXN0ZWQgb24gMTIpIGRvd25yaWdodCByZWZ1c2VzIHRvIGFsbG93IFxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZCBVTkxFU1MgaXQgaGFwcGVucyB3aXRoaW5cbiAgICAgICAgICAgIC8vIGFuIGV2ZW50IGhhbmRsZXIgbGlrZSB0aGlzLiAgSXQgYWxzbyBkb2Vzbid0IGZvY3VzXG4gICAgICAgICAgICAvLyBidXR0b25zIGJ5IGRlZmF1bHQgd2hlbiBjbGlja2VkLCB0YXBwZWQsIGV0Yy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBpdCBiZWNvbWVzIHByb2JsZW1hdGljIHRoYXQgYnV0dG9uLWxpa2VzIGV4cGxpY2l0bHkgYmVjb21lXG4gICAgICAgICAgICAvLyBmb2N1c2VkIHdoZW4gdGhleSBhcmUgcHJlc3NlZCwgdGhlbiBhbiBhbHRlcm5hdGl2ZSBzb2x1dGlvbiBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBxdWVzdGlvbiBvZiBcImhvdyBkbyBtZW51IGJ1dHRvbnMga2VlcCB0aGVpciBtZW51cyBvcGVuXCJcbiAgICAgICAgICAgIC8vIGFuZCBvdGhlciBmb2N1cy1yZWxhdGVkIG5vbnNlbnNlIG5lZWRzIHRvIGJlIGZpZ3VyZWQgb3V0LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEZvciBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBcImZvY3VzXCIgaW4gKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpKVxuICAgICAgICAgICAgICAgIGZvY3VzU2VsZihlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEUpO1xuICAgICAgICAgICAgLy8oZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBIVE1MRWxlbWVudCB8IG51bGwpPy5mb2N1cygpO1xuXG4gICAgICAgICAgICAvLyBXaGF0ZXZlciB0aGUgYnJvd3NlciB3YXMgZ29pbmcgdG8gZG8gd2l0aCB0aGlzIGV2ZW50LFxuICAgICAgICAgICAgLy8gZm9yZ2V0IGl0LiBXZSdyZSB0dXJuaW5nIGl0IGludG8gYSBcInByZXNzXCIgZXZlbnQuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIC8vIEFsc28gc3RvcCBhbnlvbmUgZWxzZSBmcm9tIGxpc3RlbmluZyB0byB0aGlzIGV2ZW50LFxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgZXhwbGljaXRseSBoYW5kbGluZyBpdC5cbiAgICAgICAgICAgIC8vIChOb3RhYmx5LCB0aGlzIGFsbG93cyBsYWJlbHMgdG8gd3JhcCBpbnB1dHMsIHdpdGggdGhlbVxuICAgICAgICAgICAgLy8gYm90aCBoYXZpbmcgcHJlc3MgZXZlbnQgaGFuZGxlcnMsIHdpdGhvdXQgZG91YmxlLWZpcmluZylcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIC8vIEhhcHRpYyBmZWVkYmFjayBmb3IgdGhpcyBwcmVzcyBldmVudFxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHRocm93LFxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBzaG91bGQgZ3VhcmQgYWdhaW5zdCB1c2VyIGltcGxlbWVudGF0aW9ucyB0aGF0IGNvdWxkLlxuICAgICAgICAgICAgICAgIHB1bHNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBjYWxsIG91ciBoYW5kbGVyLlxuICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jKGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uTW91c2VEb3duID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMgJiYgIWV4Y2x1ZGVzKFwiY2xpY2tcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgZG91YmxlIGNsaWNrcyBmcm9tIHNlbGVjdGluZyB0ZXh0IGluIGFuIGNvbXBvbmVudCB0aGF0J3MgKnN1cHBvc2VkKiB0byBiZSBhY3RpbmcgbGlrZSBhIGJ1dHRvbixcbiAgICAgICAgICAgIC8vIGJ1dCBhbHNvIGRvbid0IHByZXZlbnQgdGhlIHVzZXIgZnJvbSBzZWxlY3RpbmcgdGhhdCB0ZXh0IG1hbnVhbGx5IGlmIHRoZXkgcmVhbGx5IHdhbnQgdG9cbiAgICAgICAgICAgIC8vICh3aGljaCB1c2VyLXNlbGVjdDogbm9uZSB3b3VsZCBkbywgYnV0IGNhbmNlbGxpbmcgYSBkb3VibGUgY2xpY2sgb24gbW91c2VEb3duIGRvZXNuJ3QpXG4gICAgICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuICAgIGNvbnN0IG9uTW91c2VVcCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDAgJiYgZ2V0QWN0aXZlKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cblxuICAgIGNvbnN0IG9uTW91c2VMZWF2ZSA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICBzZXRBY3RpdmUoMCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IG9uS2V5RG93biA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXkgPT0gXCIgXCIgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBhY3RpdmF0ZSBpdCBvbiBhIHNwYWNlIGtleWRvd25cbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiRW50ZXJcIiAmJiAhZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBvbktleVVwID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkS2V5Ym9hcmRFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMgJiYgZS5rZXkgPT0gXCIgXCIgJiYgIWV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkpXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgfSlcblxuICAgIGNvbnN0IG9uQ2xpY2sgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU3luYykge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgb25Gb2N1c091dCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEZvY3VzRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKDApO1xuICAgIH0pXG5cblxuICAgIGNvbnN0IHByb3BzU3RhYmxlMiA9IHVzZVJlZjxoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4oe1xuICAgICAgICBvbktleURvd24sXG4gICAgICAgIG9uS2V5VXAsXG4gICAgICAgIG9uTW91c2VEb3duLFxuICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgIG9uTW91c2VMZWF2ZSxcbiAgICAgICAgb25DbGljayxcbiAgICAgICAgb25mb2N1c291dDogb25Gb2N1c091dFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJlc3NSZXR1cm46IHtcbiAgICAgICAgICAgIHByb3BzU3RhYmxlOiBwcm9wc1N0YWJsZTIuY3VycmVudCxcbiAgICAgICAgICAgIHByb3BzVW5zdGFibGU6IHtcbiAgICAgICAgICAgICAgICBzdHlsZTogKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgIT0gbnVsbCkgPyB7IGN1cnNvcjogXCJ0ZXh0XCIgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cblxuXG4vKipcbiAqIHNlbGVjdGlvbi5jb250YWluc05vZGUgZG9lc24ndCBhY2NvdW50IGZvciBzZWxlY3Rpb24uaXNDb2xsYXBzZWQsXG4gKiBzbyBoZXJlJ3MgYSB3b3JrYXJvdW5kIGZvciB0aGF0LlxuICogXG4gKiBXZSBhbHNvIG9ubHkgbG9vayBmb3IgdGhlIHNlbGVjdGlvbiBlbmQgdG8gb25seSBjYXRjaCB0aGUgXG4gKiBlc3NlbnNlIG9mIGEgbm9uLWV4aXN0YW50IFwic2VsZWN0aW9uc3RvcFwiIGV2ZW50LlxuICogXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5mdW5jdGlvbiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGVsZW1lbnQ6IEV2ZW50VGFyZ2V0IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IChzZWxlY3Rpb24/LnJhbmdlQ291bnQgPz8gMCk7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24hLmdldFJhbmdlQXQoaSkhO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuY29udGFpbnMocmFuZ2UuZW5kQ29udGFpbmVyKSAmJiAhc2VsZWN0aW9uPy5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3Rpb24hLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG59XG5cblxubGV0IHB1bHNlID0gKChcInZpYnJhdGVcIiBpbiBuYXZpZ2F0b3IpICYmIChuYXZpZ2F0b3IudmlicmF0ZSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSkgPyAoKCkgPT4gbmF2aWdhdG9yLnZpYnJhdGUoMTApKSA6ICgoKSA9PiB7IH0pO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gZW5hYmxlL2Rpc2FibGUgYnV0dG9uIHZpYnJhdGlvbiBwdWxzZXMgb24gYW4gYXBwLXdpZGUgc2NhbGUuXG4gKiBcbiAqIFxuICogQHBhcmFtIGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIGEgYnV0dG9uIGlzIHRhcHBlZC5cbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByZXNzVmlicmF0ZShmdW5jOiAoKSA9PiB2b2lkKSB7XG4gICAgcHVsc2UgPSBmdW5jO1xufVxuXG5cblxuZnVuY3Rpb24gZXhjbHVkZXModGFyZ2V0OiBcImNsaWNrXCIgfCBcInNwYWNlXCIgfCBcImVudGVyXCIsIGV4Y2x1ZGU6IHVuZGVmaW5lZCB8IHsgY2xpY2s/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgc3BhY2U/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCwgZW50ZXI/OiBcImV4Y2x1ZGVcIiB8IHVuZGVmaW5lZCB9KSB7XG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbn1cbiIsIlxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuLCB1c2VDaGlsZHJlbkZsYWcsIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlUHJlc3MsIFVzZVByZXNzUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1wcmVzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXMsIFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWNoaWxkcmVuLWhhdmUtZm9jdXNcIjtcblxuXG5cbmludGVyZmFjZSBTU1A8RSBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBzZWxlY3RlZEluZGV4OiBudW1iZXIgfCBudWxsO1xuICAgIHNldFNlbGVjdGVkSW5kZXg6IChuZXdJbmRleDogbnVtYmVyLCBldmVudDogeyB0YXJnZXQ6IEUsIGN1cnJlbnRUYXJnZXQ6IEUgfSB8IGguSlNYLlRhcmdldGVkRXZlbnQ8RT4pID0+IHZvaWQ7XG5cbiAgICBzZXRUYWJiYWJsZUluZGV4KHRhYmJhYmxlSW5kZXg6IG51bWJlciwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbik6IHZvaWQ7XG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEsgfCBcInNlbGVjdGVkXCI+O1xufVxuaW50ZXJmYWNlIFNTQ1A8RSBleHRlbmRzIEVsZW1lbnQ+IHtcbiAgICB1bnNlbGVjdGFibGU6IGJvb2xlYW47XG4gICAgc2VsZWN0aW9uTW9kZTogXCJmb2N1c1wiIHwgXCJhY3RpdmF0aW9uXCIgfCBcImRpc2FibGVkXCI7XG4gICAgYXJpYVByb3BOYW1lOiBgYXJpYS0ke1wicHJlc3NlZFwiIHwgXCJzZWxlY3RlZFwiIHwgXCJjaGVja2VkXCJ9YCB8IG51bGw7XG4gICAgZm9jdXNTZWxmKGU6IEUpOiB2b2lkO1xuICAgIC8vZ2V0RWxlbWVudCgpOiBFIHwgbnVsbDtcbn1cblxuZXhwb3J0IHR5cGUgU2luZ2xlU2VsZWN0aW9uQ2hpbGRPbWl0cyA9IGtleW9mIFNTQ1A8YW55PjtcblxuZXhwb3J0IHR5cGUgU2luZ2xlU2VsZWN0aW9uT21pdHMgPSBrZXlvZiBTU1A8YW55LCBhbnksIGFueT47XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cz4ge1xuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IE9taXQ8U1NQPENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4sIFNTT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25DaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPlxuICAgIGV4dGVuZHNcbiAgICBPbWl0PFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCBDLCBLLCBNY09taXRzLCBTdWJiZXN0SW5mbz4sIFwic3ViSW5mb1wiPiB7XG4gICAgcmVmRWxlbWVudFJldHVybjogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPltcInJlZkVsZW1lbnRSZXR1cm5cIl0sIFwiZ2V0RWxlbWVudFwiPj47XG4gICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiBPbWl0PFNTQ1A8RT4sIE9taXRzPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVByZXNzUmV0dXJuVHlwZTxFPiwgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuOiB7XG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuLFxuICAgICAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xuICAgICAgICBwcm9wc1Vuc3RhYmxlOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbiAgICB9XG4gICAgLy9oYXNGb2N1c1BhcmFtZXRlcnM6IFJlcXVpcmVkPFBpY2s8VXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+W1wiaGFzRm9jdXNQYXJhbWV0ZXJzXCJdLCBcIm9uRm9jdXNlZElubmVyQ2hhbmdlZFwiIHwgXCJvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PjtcbiAgICByZWZFbGVtZW50UGFyYW1ldGVyczogUmVxdWlyZWQ8UGljazxVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxFPltcInJlZkVsZW1lbnRQYXJhbWV0ZXJzXCJdLCBcIm9uRWxlbWVudENoYW5nZVwiPj47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88RT4ge1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczI8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPEU+IHtcbiAgICBmbGFnczogeyBzZWxlY3RlZDogQ2hpbGRGbGFnT3BlcmF0aW9ucyB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIHNpbmdsZVNlbGVjdGlvblJldHVybjoge1xuICAgICAgICBjaGFuZ2VTZWxlY3RlZEluZGV4OiBTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD47XG4gICAgICAgIGdldFNlbGVjdGVkSW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPjtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZDxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUsIEMsIEssIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczI8RT47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTaW5nbGVTZWxlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4LCBjaGlsZHJlbiwgc2V0VGFiYmFibGVJbmRleCB9XG59OiBVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXI+KTogVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG5cbiAgICBjb25zdCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzKHtcbiAgICAgICAgY2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1czogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vb25BbGxMb3N0Rm9jdXM/LigpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZEluZGV4ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoc2VsZWN0ZWRJbmRleCwgZmFsc2UpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBvbkFueUdhaW5lZEZvY3VzOiBudWxsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soc2V0U2VsZWN0ZWRJbmRleCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNoYW5nZUluZGV4OiBjaGFuZ2VTZWxlY3RlZEluZGV4LFxuICAgICAgICBnZXRDdXJyZW50SW5kZXg6IGdldFNlbGVjdGVkSW5kZXhcbiAgICB9ID0gdXNlQ2hpbGRyZW5GbGFnPEMsIEsgfCBcInNlbGVjdGVkXCI+KHtcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBpbml0aWFsSW5kZXg6IHNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGtleTogXCJzZWxlY3RlZFwiLFxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxuICAgIH0pO1xuXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcbiAgICB9LCBbc2VsZWN0ZWRJbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB7XG4gICAgICAgICAgICBnZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleFxuICAgICAgICB9LFxuICAgICAgICB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZDogdXNlQ2FsbGJhY2s8VXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPj4oKGFyZ3MpOiBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3MyPENoaWxkRWxlbWVudD4gPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgZmxhZ3MsIGluZGV4IH0sXG4gICAgICAgICAgICAgICAgcmVmRWxlbWVudFJldHVybixcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgc2VsZWN0aW9uTW9kZSwgdW5zZWxlY3RhYmxlLCBhcmlhUHJvcE5hbWUsIGZvY3VzU2VsZiB9LFxuICAgICAgICAgICAgfSA9IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWYgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldElzU2VsZWN0ZWQsIHNldDogc2V0SXNTZWxlY3RlZCwgaXNWYWxpZDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gIXVuc2VsZWN0YWJsZSkgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZDogb2xmaWMyIH0sIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZSB9IH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkKHt9KTtcblxuICAgICAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xuXG4gICAgICAgICAgICBjb25zdCB7IHByZXNzUmV0dXJuIH0gPSB1c2VQcmVzczxDaGlsZEVsZW1lbnQ+KHtcbiAgICAgICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAgICAgICAgIHByZXNzUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrU3luYzogdW5zZWxlY3RhYmxlID8gbnVsbCA6ICgoZSkgPT4geyBzdGFibGVPbkNoYW5nZShnZXRJbmRleCgpLCBlKTsgfSksXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGU6IHt9LFxuICAgICAgICAgICAgICAgICAgICBmb2N1c1NlbGYsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuOiB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiBpc1NlbGVjdGVkLFxuICAgICAgICAgICAgICAgICAgICBnZXRTZWxlY3RlZDogZ2V0SXNTZWxlY3RlZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHNVbnN0YWJsZTogeyBbYXJpYVByb3BOYW1lIGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPGFueT5dOiAoaXNTZWxlY3RlZCA/PyBmYWxzZSkudG9TdHJpbmcoKSB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgICAgICAgICBmbGFnczogeyAuLi5mbGFncywgc2VsZWN0ZWQ6IHNlbGVjdGVkUmVmLmN1cnJlbnQgfSxcbiAgICAgICAgICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbGZpYzI/Lihmb2N1c2VkLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25Nb2RlID09ICdmb2N1cycgJiYgZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZU9uQ2hhbmdlKGdldEluZGV4KCksIHsgdGFyZ2V0OiBnZXRFbGVtZW50KCkhLCBjdXJyZW50VGFyZ2V0OiBnZXRFbGVtZW50KCkhIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIG9uRWxlbWVudENoYW5nZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtdKSxcbiAgICB9XG59XG5cbiIsIi8qKlxuICogQ29waWVzIHRoZSB2YWx1ZXMgb2YgYHNvdXJjZWAgdG8gYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5PVtdXSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgdG8uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZSwgYXJyYXkpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuXG4gIGFycmF5IHx8IChhcnJheSA9IEFycmF5KGxlbmd0aCkpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGFycmF5W2luZGV4XSA9IHNvdXJjZVtpbmRleF07XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb3B5QXJyYXk7XG4iLCIvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlRmxvb3IgPSBNYXRoLmZsb29yLFxuICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJhbmRvbWAgd2l0aG91dCBzdXBwb3J0IGZvciByZXR1cm5pbmdcbiAqIGZsb2F0aW5nLXBvaW50IG51bWJlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsb3dlciBUaGUgbG93ZXIgYm91bmQuXG4gKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAqL1xuZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgcmV0dXJuIGxvd2VyICsgbmF0aXZlRmxvb3IobmF0aXZlUmFuZG9tKCkgKiAodXBwZXIgLSBsb3dlciArIDEpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVJhbmRvbTtcbiIsImltcG9ydCBiYXNlUmFuZG9tIGZyb20gJy4vX2Jhc2VSYW5kb20uanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCB3aGljaCBtdXRhdGVzIGFuZCBzZXRzIHRoZSBzaXplIG9mIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzaXplPWFycmF5Lmxlbmd0aF0gVGhlIHNpemUgb2YgYGFycmF5YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBzaHVmZmxlU2VsZihhcnJheSwgc2l6ZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG5cbiAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gIHdoaWxlICgrK2luZGV4IDwgc2l6ZSkge1xuICAgIHZhciByYW5kID0gYmFzZVJhbmRvbShpbmRleCwgbGFzdEluZGV4KSxcbiAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgIGFycmF5W3JhbmRdID0gYXJyYXlbaW5kZXhdO1xuICAgIGFycmF5W2luZGV4XSA9IHZhbHVlO1xuICB9XG4gIGFycmF5Lmxlbmd0aCA9IHNpemU7XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZVNlbGY7XG4iLCJpbXBvcnQgY29weUFycmF5IGZyb20gJy4vX2NvcHlBcnJheS5qcyc7XG5pbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zaHVmZmxlYCBmb3IgYXJyYXlzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheVNodWZmbGUoYXJyYXkpIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheVNodWZmbGU7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICogc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlNYXAoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheU1hcDtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udmFsdWVzYCBhbmQgYF8udmFsdWVzSW5gIHdoaWNoIGNyZWF0ZXMgYW5cbiAqIGFycmF5IG9mIGBvYmplY3RgIHByb3BlcnR5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lc1xuICogb2YgYHByb3BzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IG5hbWVzIHRvIGdldCB2YWx1ZXMgZm9yLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBiYXNlVmFsdWVzKG9iamVjdCwgcHJvcHMpIHtcbiAgcmV0dXJuIGFycmF5TWFwKHByb3BzLCBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVmFsdWVzO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVRpbWVzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICovXG5mdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gYXJnc1RhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzQXJndW1lbnRzO1xuIiwiaW1wb3J0IGJhc2VJc0FyZ3VtZW50cyBmcm9tICcuL19iYXNlSXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FyZ3VtZW50cztcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhbiBgQXJyYXlgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXkoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheSgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHViRmFsc2U7XG4iLCJpbXBvcnQgcm9vdCBmcm9tICcuL19yb290LmpzJztcbmltcG9ydCBzdHViRmFsc2UgZnJvbSAnLi9zdHViRmFsc2UuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyByb290LkJ1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IEJ1ZmZlcigyKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgVWludDhBcnJheSgyKSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNCdWZmZXIgPSBuYXRpdmVJc0J1ZmZlciB8fCBzdHViRmFsc2U7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQnVmZmVyO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0luZGV4O1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0xlbmd0aDtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKiBVc2VkIHRvIGlkZW50aWZ5IGB0b1N0cmluZ1RhZ2AgdmFsdWVzIG9mIHR5cGVkIGFycmF5cy4gKi9cbnZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xudHlwZWRBcnJheVRhZ3NbZmxvYXQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1tmbG9hdDY0VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQ4VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2ludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDhDbGFtcGVkVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbdWludDMyVGFnXSA9IHRydWU7XG50eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG50eXBlZEFycmF5VGFnc1thcnJheUJ1ZmZlclRhZ10gPSB0eXBlZEFycmF5VGFnc1tib29sVGFnXSA9XG50eXBlZEFycmF5VGFnc1tkYXRhVmlld1RhZ10gPSB0eXBlZEFycmF5VGFnc1tkYXRlVGFnXSA9XG50eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG50eXBlZEFycmF5VGFnc1ttYXBUYWddID0gdHlwZWRBcnJheVRhZ3NbbnVtYmVyVGFnXSA9XG50eXBlZEFycmF5VGFnc1tvYmplY3RUYWddID0gdHlwZWRBcnJheVRhZ3NbcmVnZXhwVGFnXSA9XG50eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG50eXBlZEFycmF5VGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzVHlwZWRBcnJheWAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNUeXBlZEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhIXR5cGVkQXJyYXlUYWdzW2Jhc2VHZXRUYWcodmFsdWUpXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUlzVHlwZWRBcnJheTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVVuYXJ5O1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBwcm9jZXNzYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZVByb2Nlc3MgPSBtb2R1bGVFeHBvcnRzICYmIGZyZWVHbG9iYWwucHJvY2VzcztcblxuLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG52YXIgbm9kZVV0aWwgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgdmFyIHR5cGVzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlKCd1dGlsJykudHlwZXM7XG5cbiAgICBpZiAodHlwZXMpIHtcbiAgICAgIHJldHVybiB0eXBlcztcbiAgICB9XG5cbiAgICAvLyBMZWdhY3kgYHByb2Nlc3MuYmluZGluZygndXRpbCcpYCBmb3IgTm9kZS5qcyA8IDEwLlxuICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgfSBjYXRjaCAoZSkge31cbn0oKSk7XG5cbmV4cG9ydCBkZWZhdWx0IG5vZGVVdGlsO1xuIiwiaW1wb3J0IGJhc2VJc1R5cGVkQXJyYXkgZnJvbSAnLi9fYmFzZUlzVHlwZWRBcnJheS5qcyc7XG5pbXBvcnQgYmFzZVVuYXJ5IGZyb20gJy4vX2Jhc2VVbmFyeS5qcyc7XG5pbXBvcnQgbm9kZVV0aWwgZnJvbSAnLi9fbm9kZVV0aWwuanMnO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNUeXBlZEFycmF5O1xuIiwiaW1wb3J0IGJhc2VUaW1lcyBmcm9tICcuL19iYXNlVGltZXMuanMnO1xuaW1wb3J0IGlzQXJndW1lbnRzIGZyb20gJy4vaXNBcmd1bWVudHMuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBpc0J1ZmZlciBmcm9tICcuL2lzQnVmZmVyLmpzJztcbmltcG9ydCBpc0luZGV4IGZyb20gJy4vX2lzSW5kZXguanMnO1xuaW1wb3J0IGlzVHlwZWRBcnJheSBmcm9tICcuL2lzVHlwZWRBcnJheS5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiB0aGUgYXJyYXktbGlrZSBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKSxcbiAgICAgIGlzQXJnID0gIWlzQXJyICYmIGlzQXJndW1lbnRzKHZhbHVlKSxcbiAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgaXNUeXBlID0gIWlzQXJyICYmICFpc0FyZyAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheSh2YWx1ZSksXG4gICAgICBza2lwSW5kZXhlcyA9IGlzQXJyIHx8IGlzQXJnIHx8IGlzQnVmZiB8fCBpc1R5cGUsXG4gICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG4gICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgIShza2lwSW5kZXhlcyAmJiAoXG4gICAgICAgICAgIC8vIFNhZmFyaSA5IGhhcyBlbnVtZXJhYmxlIGBhcmd1bWVudHMubGVuZ3RoYCBpbiBzdHJpY3QgbW9kZS5cbiAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgIC8vIE5vZGUuanMgMC4xMCBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiBidWZmZXJzLlxuICAgICAgICAgICAoaXNCdWZmICYmIChrZXkgPT0gJ29mZnNldCcgfHwga2V5ID09ICdwYXJlbnQnKSkgfHxcbiAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAoaXNUeXBlICYmIChrZXkgPT0gJ2J1ZmZlcicgfHwga2V5ID09ICdieXRlTGVuZ3RoJyB8fCBrZXkgPT0gJ2J5dGVPZmZzZXQnKSkgfHxcbiAgICAgICAgICAgLy8gU2tpcCBpbmRleCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICApKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlMaWtlS2V5cztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHByb3RvdHlwZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICB2YXIgQ3RvciA9IHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yLFxuICAgICAgcHJvdG8gPSAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBDdG9yLnByb3RvdHlwZSkgfHwgb2JqZWN0UHJvdG87XG5cbiAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNQcm90b3R5cGU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgb3ZlckFyZztcbiIsImltcG9ydCBvdmVyQXJnIGZyb20gJy4vX292ZXJBcmcuanMnO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbmV4cG9ydCBkZWZhdWx0IG5hdGl2ZUtleXM7XG4iLCJpbXBvcnQgaXNQcm90b3R5cGUgZnJvbSAnLi9faXNQcm90b3R5cGUuanMnO1xuaW1wb3J0IG5hdGl2ZUtleXMgZnJvbSAnLi9fbmF0aXZlS2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ua2V5c2Agd2hpY2ggZG9lc24ndCB0cmVhdCBzcGFyc2UgYXJyYXlzIGFzIGRlbnNlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBiYXNlS2V5cyhvYmplY3QpIHtcbiAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXMob2JqZWN0KTtcbiAgfVxuICB2YXIgcmVzdWx0ID0gW107XG4gIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSAmJiBrZXkgIT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZUtleXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNGdW5jdGlvbjtcbiIsImltcG9ydCBpc0Z1bmN0aW9uIGZyb20gJy4vaXNGdW5jdGlvbi5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0FycmF5TGlrZTtcbiIsImltcG9ydCBhcnJheUxpa2VLZXlzIGZyb20gJy4vX2FycmF5TGlrZUtleXMuanMnO1xuaW1wb3J0IGJhc2VLZXlzIGZyb20gJy4vX2Jhc2VLZXlzLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy4gU2VlIHRoZVxuICogW0VTIHNwZWNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5rZXlzKVxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLmtleXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy5rZXlzKCdoaScpO1xuICogLy8gPT4gWycwJywgJzEnXVxuICovXG5mdW5jdGlvbiBrZXlzKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGtleXM7XG4iLCJpbXBvcnQgYmFzZVZhbHVlcyBmcm9tICcuL19iYXNlVmFsdWVzLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWx1ZXM7XG4iLCJpbXBvcnQgc2h1ZmZsZVNlbGYgZnJvbSAnLi9fc2h1ZmZsZVNlbGYuanMnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICcuL3ZhbHVlcy5qcyc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYodmFsdWVzKGNvbGxlY3Rpb24pKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNodWZmbGU7XG4iLCJpbXBvcnQgYXJyYXlTaHVmZmxlIGZyb20gJy4vX2FycmF5U2h1ZmZsZS5qcyc7XG5pbXBvcnQgYmFzZVNodWZmbGUgZnJvbSAnLi9fYmFzZVNodWZmbGUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIHZhbHVlcywgdXNpbmcgYSB2ZXJzaW9uIG9mIHRoZVxuICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaHVmZmxlKFsxLCAyLCAzLCA0XSk7XG4gKiAvLyA9PiBbNCwgMSwgMywgMl1cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U2h1ZmZsZSA6IGJhc2VTaHVmZmxlO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc2h1ZmZsZTtcbiIsImltcG9ydCAqIGFzIF8gZnJvbSBcImxvZGFzaFwiO1xuaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBNdXRhYmxlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRJbmZvLCBNYW5hZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcblxuZXhwb3J0IHR5cGUgR2V0SW5kZXg8QywgSyBleHRlbmRzIHN0cmluZz4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4pID0+IChudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkKTtcbmV4cG9ydCB0eXBlIENvbXBhcmU8Vj4gPSAobGhzOiBWLCByaHM6IFYpID0+IG51bWJlcjtcblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuLCBlLmcuLCB0aGUgcm93IGluZGV4IG9mIHRoaXMgY2hpbGRcbiAgICAgKiAoVXN1YWxseSBqdXN0IGFuIGBpbmRleGAgcHJvcClcbiAgICAgKi9cbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGdldEluZGV4OiBHZXRJbmRleDxDLCBLPjsgfVxufVxuXG4vKipcbiAqIEFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgKipNVVNUKiogYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPiB7XG4gICAgc29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0aGlzIGNoaWxkIHVzZXMgUkU6IHNvcnRpbmcuXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHNvcnRpbmcgKHlvdSBqdXN0IHVzZSBcbiAgICAgICAgICogeW91ciBvd25hcmJpdHJhcnkgcmVvcmRlcmluZyksIHRoaXMgd2lsbCBuZXZlclxuICAgICAgICAgKiBiZSB1c2VkLCBzbyBpdCBjYW4gcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcm93IFxuICAgICAgICAgKiBAcGFyYW0gYXJncyBcbiAgICAgICAgICovXG4gICAgICAgIC8vZ2V0VmFsdWU6IEdldFZhbHVlPEMsIEssIEcsIFY+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBob3cgdmFsdWVzIGNvbXBhcmUgYWdhaW5zdCBlYWNoIG90aGVyLlxuICAgICAgICAgKiBAcGFyYW0gbGhzIFxuICAgICAgICAgKiBAcGFyYW0gcmhzIFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZTogQ29tcGFyZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+O1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISpcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM6IHsgZ2V0SW5kZXggfSB9OiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+KTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLPiB7XG5cbiAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIGEgbWFwcGluZyBiZXR3ZWVuIHVuc29ydGVkIGluZGV4IDwtLS0+IHNvcnRlZCBpbmRleC5cbiAgICAvLyBUaGVzZSBhcmUgbmVlZGVkIGZvciBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMuXG4gICAgY29uc3QgbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xuICAgIGNvbnN0IGRlbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xuICAgIGNvbnN0IGluZGV4TWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcbiAgICBjb25zdCBpbmRleERlbWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChkZW1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuXG4gICAgLy8gVGhlIHNvcnQgZnVuY3Rpb24gbmVlZHMgdG8gYmUgYWJsZSB0byB1cGRhdGUgd2hvZXZlciBoYXMgYWxsIHRoZSBzb3J0YWJsZSBjaGlsZHJlbi5cbiAgICAvLyBCZWNhdXNlIHRoYXQgbWlnaHQgbm90IGJlIHRoZSBjb25zdW1lciBvZiAqdGhpcyogaG9vayBkaXJlY3RseSAoZS5nLiBhIHRhYmxlIHVzZXNcbiAgICAvLyB0aGlzIGhvb2ssIGJ1dCBpdCdzIHRib2R5IHRoYXQgYWN0dWFsbHkgbmVlZHMgdXBkYXRpbmcpLCB3ZSBuZWVkIHRvIHJlbW90ZWx5XG4gICAgLy8gZ2V0IGFuZCBzZXQgYSBmb3JjZVVwZGF0ZSBmdW5jdGlvbi5cbiAgICAvL2NvbnN0IFtnZXRGb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwsIHJldHVybk51bGwpO1xuICAgIGNvbnN0IFtnZXRGb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwsIHJldHVybk51bGwpO1xuXG4gICAgY29uc3QgcmVhcnJhbmdlID0gdXNlQ2FsbGJhY2soKHNvcnRlZFJvd3M6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB7XG5cbiAgICAgICAgLy8gVXBkYXRlIG91ciBzb3J0ZWQgPC0tPiB1bnNvcnRlZCBpbmRpY2VzIG1hcCBcbiAgICAgICAgLy8gYW5kIHJlcmVuZGVyIHRoZSB3aG9sZSB0YWJsZSwgYmFzaWNhbGx5XG4gICAgICAgIGZvciAobGV0IGluZGV4QXNTb3J0ZWQgPSAwOyBpbmRleEFzU29ydGVkIDwgc29ydGVkUm93cy5sZW5ndGg7ICsraW5kZXhBc1NvcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXhBc1Vuc29ydGVkID0gc29ydGVkUm93c1tpbmRleEFzU29ydGVkXS5pbmRleDtcblxuICAgICAgICAgICAgbWFuZ2xlTWFwLmN1cnJlbnQuc2V0KGluZGV4QXNVbnNvcnRlZCwgaW5kZXhBc1NvcnRlZCk7XG4gICAgICAgICAgICBkZW1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzU29ydGVkLCBpbmRleEFzVW5zb3J0ZWQpO1xuICAgICAgICB9XG5cblxuICAgICAgICBnZXRGb3JjZVVwZGF0ZSgpPy4oKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCB1c2VSZWFycmFuZ2VhYmxlUHJvcHMgPSB1c2VDYWxsYmFjaygoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4pID0+IHtcbiAgICAgICAgY29uc29sZS5hc3NlcnQoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpO1xuXG4gICAgICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0Rm9yY2VVcGRhdGUoX3ByZXYgPT4gZm9yY2VVcGRhdGUpOyB9LCBbZm9yY2VVcGRhdGVdKVxuXG4gICAgICAgIHJldHVybiAodXNlTWVyZ2VkUHJvcHM8UGFyZW50RWxlbWVudD4oe1xuICAgICAgICAgICAgY2hpbGRyZW46XG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuIGFzIFZOb2RlPE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPj5bXSlcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKClcbiAgICAgICAgICAgICAgICAgICAgLm1hcChjaGlsZCA9PiAoeyBjaGlsZCwgbWFuZ2xlZEluZGV4OiBpbmRleE1hbmdsZXIoZ2V0SW5kZXgoY2hpbGQucHJvcHMhKSEpLCBkZW1hbmdsZWRJbmRleDogZ2V0SW5kZXgoY2hpbGQucHJvcHMpIH0pKVxuICAgICAgICAgICAgICAgICAgICAuc29ydCgobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocy5tYW5nbGVkSW5kZXggLSByaHMubWFuZ2xlZEluZGV4IH0pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHsgY2hpbGQsIG1hbmdsZWRJbmRleCwgZGVtYW5nbGVkSW5kZXggfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoY2hpbGQudHlwZSBhcyBhbnksIHsgLi4uY2hpbGQucHJvcHMsIGtleTogZGVtYW5nbGVkSW5kZXgsIFwiZGF0YS1tYW5nbGVkLWluZGV4XCI6IG1hbmdsZWRJbmRleCwgXCJkYXRhLXVubWFuZ2xlZC1pbmRleFwiOiBkZW1hbmdsZWRJbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSwgcHJvcHMpKTtcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyB1c2VSZWFycmFuZ2VhYmxlUHJvcHMsIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybjogeyBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyLCBtYW5nbGVNYXAsIGRlbWFuZ2xlTWFwLCByZWFycmFuZ2UgfSB9O1xufVxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISogXG4gKiBcbiAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb25gOyBpdCB0YWtlcyB0aGUgc2FtZSBgaW5kZXhNYW5nbGVyYCBhbmQgYGluZGV4RGVtYW5nbGVyYCBcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcbiAqIHRoaXMgaG9vayBpbXBvc2VzIHNlcmlvdXMgcmVzdHJpY3Rpb25zIG9uIGNoaWxkIHN0cnVjdHVyZSwgd2hpbGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBhbGxvd3MgYW55dGhpbmcuXG4gKiBcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXG4gKiBzb3J0IGFsbCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlaXIgdmFsdWUgZnJvbSB0aGUgYGdldFZhbHVlYCBhcmd1bWVudCB5b3UgcGFzcyBpbi5cbiAqIFxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XG4gKiByZS1tYXAgZWFjaCBjaGlsZCdzIHBvc2l0aW9uIHVzaW5nIGBtYW5nbGVNYXBgIGFuZCBgZGVtYW5nbGVNYXBgLCB3aGljaCBjb252ZXJ0IGJldHdlZW5cbiAqIHNvcnRlZCBhbmQgdW5zb3J0ZWQgaW5kZXggcG9zaXRpb25zLlxuICogXG4gKiBBZ2FpbiwgdW5saWtlIHNvbWUgb3RoZXIgaG9va3MsICoqdGhlc2UgY2hpbGRyZW4gbXVzdCBiZSBkaXJlY3QgZGVzY2VuZGFudHMqKi4gVGhpcyBpcyBiZWNhdXNlXG4gKiB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayBpbnNwZWN0cyB0aGUgZ2l2ZW4gY2hpbGRyZW4sIHRoZW4gcmUtY3JlYXRlcyB0aGVtIHdpdGggbmV3IGBrZXlgcy5cbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcbiAqIHRoZXJlJ3Mgbm8gb3RoZXIgdGltZSBvciBwbGFjZSB0aGlzIGNhbiBoYXBwZW4gb3RoZXIgdGhhbiBleGFjdGx5IHdpdGhpbiB0aGUgcGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleCB9LCBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBjb21wYXJlOiB1c2VyQ29tcGFyZSB9IH06IFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+KTogVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSz4ge1xuXG4gICAgY29uc3QgY29tcGFyZSA9ICh1c2VyQ29tcGFyZSA/PyBkZWZhdWx0Q29tcGFyZSk7XG5cbiAgICBjb25zdCB7IHVzZVJlYXJyYW5nZWFibGVQcm9wczogdXNlU29ydGFibGVQcm9wcywgLi4ucmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEs+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczogeyBnZXRJbmRleCB9IH0pO1xuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuOiB7IHJlYXJyYW5nZSB9IH0gPSByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlO1xuICAgIC8vIFRoZSBhY3R1YWwgc29ydCBmdW5jdGlvbi5cbiAgICBjb25zdCBzb3J0ID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPiwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIpOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG5cbiAgICAgICAgY29uc3Qgc29ydGVkUm93cyA9IG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKS5zb3J0KChsaHNSb3csIHJoc1JvdykgPT4ge1xuXG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc1JvdztcbiAgICAgICAgICAgIGNvbnN0IHJoc1ZhbHVlID0gcmhzUm93O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZShsaHNWYWx1ZSwgcmhzVmFsdWUpO1xuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblswXSA9PSBcImRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHJlYXJyYW5nZShzb3J0ZWRSb3dzKTtcblxuICAgIH0sIFsgLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBzaHVmZmxlID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPik6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcbiAgICAgICAgY29uc3Qgc2h1ZmZsZWRSb3dzID0gbG9kYXNoU2h1ZmZsZShtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkpXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc2h1ZmZsZWRSb3dzKTtcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuOiB7IHNvcnQsIHNodWZmbGUgfSxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuOiByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblxuICAgIH07XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybjoge1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFzcyBhbiBhcnJheSBvZiBub3Qtc29ydGVkIGNoaWxkIGluZm9ybWF0aW9uIHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICogYW5kIHRoZSBjaGlsZHJlbiB3aWxsIHJlLWFycmFuZ2UgdGhlbXNlbHZlcyB0byBtYXRjaC5cbiAgICAgICAgICogIFxuICAgICAgICAgKiAqKlNUQUJMRSoqXG4gICAgICAgICAqICBcbiAgICAgICAgICogXG4gICAgICAgICAqL1xuICAgICAgICByZWFycmFuZ2U6IChyb3dzSW5PcmRlcjogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+W10pID0+IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBtYW5nbGVNYXA6IE11dGFibGVSZWY8TWFwPG51bWJlciwgbnVtYmVyPj47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGRlbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEs+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJlYXJyYW5nZWFibGVQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XG5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgc29ydGFibGVDaGlsZHJlblJldHVybjogey8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNvcnQ6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgc2h1ZmZsZTogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgfVxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VTb3J0YWJsZVByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50Pjtcbn1cblxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gY29tcGFyZTEobGhzLCByaHMpO1xuXG4gICAgZnVuY3Rpb24gY29tcGFyZTMobGhzOiBzdHJpbmcgfCBudW1iZXIsIHJoczogc3RyaW5nIHwgbnVtYmVyKSB7XG5cbiAgICAgICAgLy8gQ29lcmNlIHN0cmluZ3MgdG8gbnVtYmVycyBpZiB0aGV5IHNlZW0gdG8gc3RheSB0aGUgc2FtZSB3aGVuIHNlcmlhbGl6ZWRcbiAgICAgICAgaWYgKGAkeytsaHN9YCA9PT0gbGhzKVxuICAgICAgICAgICAgbGhzID0gK2xocztcbiAgICAgICAgaWYgKGAkeytyaHN9YCA9PT0gcmhzKVxuICAgICAgICAgICAgcmhzID0gK3JocztcblxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBpZiBlaXRoZXIgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHR1cm4gdGhlIG90aGVyIG9uZSBpbnRvIG9uZSB0b29cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByaHMgPSBgJHtyaHN9YDtcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBsaHMgPSBgJHtsaHN9YDtcblxuICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgbGhzID09PSB0eXBlb2YgcmhzKTtcblxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBsaHMubG9jYWxlQ29tcGFyZShyaHMgYXMgc3RyaW5nKTtcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gK2xocyAtICtyaHM7XG5cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUyKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwiYm9vbGVhblwiIHx8IGxocyBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJib29sZWFuXCIgfHwgcmhzIGluc3RhbmNlb2YgRGF0ZSlcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XG4gICAgICAgIHJldHVybiBjb21wYXJlMyhsaHMsIHJocyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBhcmUxKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBudWxsXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCB8fCByaHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gT25lIG9mIHRoZSB0d28gaXMgbnVsbCAtLSBlYXN5IGNhc2VcbiAgICAgICAgICAgIHJldHVybiBsaHMgIT0gbnVsbCA/IDEgOiAtMVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21wYXJlMihsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWN1cnJlbnQtZm9jdXNcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rcywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3MsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbyB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZVByZXNzIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8gfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyBTaW5nbGVTZWxlY3Rpb25DaGlsZE9taXRzLCBTaW5nbGVTZWxlY3Rpb25PbWl0cywgdXNlU2luZ2xlU2VsZWN0aW9uLCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLXNpbmdsZS1zZWxlY3Rpb25cIjtcbmltcG9ydCB7IHVzZVNvcnRhYmxlQ2hpbGRyZW4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHZhcmlhdGlvbnMgb24gdXNlTGlzdE5hdmlnYXRpb24gdGhhdCBhbHNvIGluY29ycG9yYXRlIHNvcnRpbmcsIHNlbGVjdGlvbiwgb3IgYm90aC5cbiAqIFxuICogVGhlcmUgYXJlbid0IGdyaWQtbmF2IHZlcnNpb25zIG9mIHRoZXNlIGJlY2F1c2UsIGdlZXosIGxvb2sgYXQgYWxsIHRoaXMgYm9pbGVycGxhdGUganVzdCBmb3IgbGlzdHMuXG4gKiBMaWtlIDMgc2NyZWVucyB3b3J0aCBvZiBpbnRlcmZhY2UgdHlwZXMgYW5kIDYgc2NyZWVucyBvZiBmdW5jdGlvbnMgdGhhdCBqdXN0IG1vdmUgdmFyaWFibGVzIGFyb3VuZC5cbiAqIFVoLi4ud2hlbiB5b3UgaW5ldml0YWJseSBuZWVkIHRvIGRvIGl0IHlvdXJzZWxmIGltcGxlbWVudCBpdCBoZXJlIGxhdGVyIGxvbCAoQG1lLCBteXNlbGYgaW4gdGhlIGZ1dHVyZSlcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzIHwgXCJpbml0aWFsSW5kZXhcIiwgTWNPbWl0cz4sXG4gICAgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIFNTT21pdHMgfCBcImNoaWxkcmVuXCIgfCBcInNldFRhYmJhYmxlSW5kZXhcIj5cbi8vVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzIFxue1xuICAgIC8vY2hpbGRyZW5IYXZlRm9jdXM6IFBhcnRpYWw8VXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzW1wiY2hpbGRyZW5IYXZlRm9jdXNcIl0+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+LFxuICAgIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIHtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgLy9wcm9wczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+W1wicHJvcHNcIl07XG59XG5cblxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgTHNTdWJJbmZvPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgU3NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbkNoaWxkT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgU3ViYmVzdEluZm8+LFxuICAgIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIiB8IEssIFNzT21pdHMgfCBcImZvY3VzU2VsZlwiLCBNY09taXRzLCBTdWJiZXN0SW5mbz4ge1xufVxuLy8gT21pdDxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSyB8IFwic2VsZWN0ZWRcIiB8IFwidGFiYmFibGVcIj4sIE1jT21pdHMgfCBcInN1YkluZm9cIj5cbi8vIE9taXQ8TWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEsgfCBcInNlbGVjdGVkXCIgfCBcInRhYmJhYmxlXCI+LCBNY09taXRzIHwgXCJzdWJJbmZvXCI+XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4sIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG5cbiAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiBSZXF1aXJlZDxQaWNrPFVzZUhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM8Q2hpbGRFbGVtZW50PltcImhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnNcIl0sIFwib25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZFwiIHwgXCJvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkXCI+PjtcbiAgICAvKnNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuOiB7XG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuO1xuICAgICAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xuICAgIH0qL1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQ+IHtcbiAgICAvL3Byb3BzOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+W1wicHJvcHNcIl07XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgQz47XG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+LFxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG59XG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYXJnczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4sXG4gICAgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4ge1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgdXNlUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgU1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBTU09taXRzLCBMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcblxufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+IHtcbiAgICB1c2VQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xufVxuXG5cbi8qKlxuICogSXQncyB2ZXJ5IGNvbW1vbiB0byBjb21iaW5lIGEgdGFiYmFibGUgbGlzdCBvZiB0aGluZ3MgYW5kIFwic2VsZWN0aW9uXCIgb2Ygb25lIG9mIHRob3NlIHRoaW5ncy5cbiAqIFxuICogTGlzdHMsIHJhZGlvIGJ1dHRvbnMsIHRhYnMsIGV0Yy4gZXRjLlxuICogXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgdGhhdCBjb21iaW5lcyB0aGUgdHdvIHdpdGggdGhlIGNvcnJlY3QgdHlwaW5nLlxuICogQHBhcmFtIHBhcmFtMCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogeyBzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4IH0sXG4gICAgbGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7IC4uLnJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyB9LFxuICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG59OiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgY29uc3Qge1xuICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPih7XG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBpbml0aWFsSW5kZXg6IChzZWxlY3RlZEluZGV4ID8/IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAuLi5yb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNcbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gbWFuYWdlZENoaWxkcmVuUmV0dXJuO1xuICAgIGNvbnN0IHsgc2V0VGFiYmFibGVJbmRleCB9ID0gcm92aW5nVGFiSW5kZXhSZXR1cm5cblxuICAgIC8vICAgIGNvbnN0IGdldFNlbGVjdGlvbk1vZGUgPSB1c2VTdGFibGVHZXR0ZXIoc2VsZWN0aW9uTW9kZSk7XG5cbiAgICBjb25zdCB7IHVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkLCBzaW5nbGVTZWxlY3Rpb25SZXR1cm4gfSA9IHVzZVNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBcInRhYmJhYmxlXCIgfCBcInNlbGVjdGVkXCIgfCBLPih7XG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgIHNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleFxuICAgICAgICB9LFxuICAgICAgICAvL2NoaWxkcmVuSGF2ZUZvY3VzUDogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4+KChhcmdzKTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PiA9PiB7XG4gICAgICAgICAgICBsZXQge1xuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IHVuc2VsZWN0YWJsZSwgLi4uc3MgfSxcbiAgICAgICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAgICAgICAgIHN1YkluZm9cbiAgICAgICAgICAgIH0gPSBhcmdzO1xuICAgICAgICAgICAgbGV0IHsgaGlkZGVuLCBmb2N1c1NlbGYgfSA9IHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzO1xuICAgICAgICAgICAgdW5zZWxlY3RhYmxlIHx8PSAoaGlkZGVuID8/IGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBmbGFnczogc3NmbGFncyxcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVybixcbiAgICAgICAgICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IG9maWMxLCBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiBvZmljMyB9LFxuICAgICAgICAgICAgICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZSB9LFxuIC8vICAgICAgICAgICAgICAgb25FbGVtZW50Q2hhbmdlLFxuICAgLy8gICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiBvZmljMSxcbiAgICAgLy8gICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsXG4gICAgICAgICAgICAgICAgcHJlc3NSZXR1cm4sXG4gICAgICAgICAgICB9ID0gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkUGFyYW1ldGVyczogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgLi4uc3MsIGZvY3VzU2VsZiwgdW5zZWxlY3RhYmxlIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVyczogeyBvbkN1cnJlbnRGb2N1c2VkSW5uZXJDaGFuZ2VkOiBvZmljMiB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5cbiAgICAgICAgICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHtcbiAgICAgICAgICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zc2ZsYWdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxhZ3NcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBQYXJ0aWFsPFJlY29yZDxLIHwgXCJzZWxlY3RlZFwiIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj5cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHN1YkluZm8sXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgY29uc3Qgb25DdXJyZW50Rm9jdXNlZElubmVyQ2hhbmdlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChmOiBib29sZWFuLCBwOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICAgICAgb2ZpYzE/LihmLCBwKTtcbiAgICAgICAgICAgICAgICBvZmljMj8uKGYsIHApO1xuICAgICAgICAgICAgICAgIG9maWMzPy4oZiwgcCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcmVzc1JldHVybixcbiAgICAgICAgICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQgfSxcbiAgICAgICAgICAgICAgICByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2UgfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuLFxuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW10pLFxuICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybixcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oYXJnczogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgbGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyc1xuICAgIH0gPSBhcmdzO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5cbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gPSByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm47XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgbGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycyB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzXG4gICAgfSk7XG5cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VTb3J0YWJsZVByb3BzO1xuXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPiA9IChwKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHApO1xuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgICB1c2VQcm9wczogdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzLFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVybixcbiAgICAgICAgcm92aW5nVGFiSW5kZXhSZXR1cm4sXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm5cbiAgICB9KTtcblxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgbGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLFxuICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsXG4gICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLFxuICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnNcbn06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+IHtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSz4oe1xuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzOiB7IGdldEluZGV4OiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczoge1xuICAgICAgICAgICAgY29tcGFyZTogdXNlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMuaW5kZXggLSByaHMuaW5kZXg7IH0sIFtdKSxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gPSByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm47XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm4sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm4sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm4sXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczogbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvblBhcmFtZXRlcnMgfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczogbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzOiB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczogc2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyc1xuICAgIH0pO1xuXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzID0gdXNlU29ydGFibGVQcm9wcztcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4ge1xuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gKHtcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxuICAgICAgICB1c2VQcm9wczogdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxuICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuLFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuLFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25SZXR1cm5cbiAgICB9KTtcblxufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VJbnRlcnZhbCB9IGZyb20gXCIuLi8uLlwiO1xuXG5cbmV4cG9ydCBjb25zdCBEZW1vVXNlSW50ZXJ2YWwgPSAoKSA9PiB7XG4gICAgY29uc3QgW2ludGVydmFsLCBzZXRJbnRlcnZhbF0gPSB1c2VTdGF0ZSgxMDAwKTtcblxuICAgIGNvbnN0IFtmaXJlQ291bnQsIHNldEZpcmVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIHVzZUludGVydmFsKHsgaW50ZXJ2YWwsIGNhbGxiYWNrOiAoKSA9PiBzZXRGaXJlQ291bnQoaSA9PiArK2kpIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxsYWJlbD5JbnRlcnZhbCBkdXJhdGlvbjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17aW50ZXJ2YWx9IG9uSW5wdXQ9e2UgPT4gc2V0SW50ZXJ2YWwoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlRoZSBjYWxsYmFjayBoYXMgYmVlbiBjYWxsZWQge2ZpcmVDb3VudH0gdGltZXtmaXJlQ291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9LjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgbWVtbywgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlSGFzQ3VycmVudEZvY3VzLCB1c2VNZXJnZWRQcm9wcywgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb24sIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCwgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4uLy4uL3VzZS1zdGF0ZVwiO1xuXG5cbmNvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xufVxuXG5cbmNvbnN0IExpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8SFRNTExJRWxlbWVudCwge30sIHN0cmluZz4+KG51bGwhKVxuZXhwb3J0IGNvbnN0IERlbW9Vc2VSb3ZpbmdUYWJJbmRleCA9IG1lbW8oKCkgPT4ge1xuXG4gICAgY29uc3QgW3NlbGVjdGlvbk1vZGUsIHNldFNlbGVjdGlvbk1vZGVdID0gdXNlU3RhdGUoXCJhY3RpdmF0aW9uXCIgYXMgXCJmb2N1c1wiIHwgXCJhY3RpdmF0aW9uXCIpO1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoMTApO1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFt0YWJiYWJsZUluZGV4LCBzZXRMb2NhbFRhYmJhYmxlSW5kZXhdID0gdXNlU3RhdGUoMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyBjaGlsZHJlbiB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwMSB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybjogeyB9LFxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm46IHsgfSxcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uUmV0dXJuOiB7IH0sXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgdXNlUHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4UmV0dXJuOiB7IHNldFRhYmJhYmxlSW5kZXggfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybjogeyBjdXJyZW50VHlwZWFoZWFkLCBwcm9wc1N0YWJsZTogcDIgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlblJldHVybjogeyBzaHVmZmxlIH0sXG4gICAgfSA9IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248SFRNTFVMaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwge30sIHN0cmluZz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVyczoge30sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczoge30sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlciB8IG51bGwpID0+IHsgaWYgKGluZGV4ICE9IG51bGwpIHNldExvY2FsVGFiYmFibGVJbmRleChpbmRleCk7IH0sIFtdKSB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge30sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM6IHsgc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleDogKGksIF9lKSA9PiBzZXRTZWxlY3RlZEluZGV4KGkpIH0sXG4gICAgICAgIC8vY2hpbGRyZW5IYXZlRm9jdXNQOiB7ICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzKHAxLCBwMik7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cbiAgICAgICAgICAgIDxoMj5LZXlib2FyZCAmYW1wOyBMaXN0IE5hdmlnYXRpb248L2gyPlxuICAgICAgICAgICAgPGgzPjxjb2RlPnVzZVJvdmluZ1RhYkluZGV4PC9jb2RlPjwvaDM+XG5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIE5hdGl2ZSBIVE1MIGVsZW1lbnRzIG9mZmVyIGZhbnRhc3RpYyBrZXlib2FyZCBhY2Nlc3NhYmlsaXR5LCBidXQgY292ZXIgYSByZWxhdGl2ZWx5IGxpbWl0ZWQgbnVtYmVyIG9mIHVzZSBjYXNlcy5cbiAgICAgICAgICAgICAgICBUaGVyZSBpcyBubyBuYXRpdmUgSFRNTCB0cmVlIGVsZW1lbnQsIGZvciBleGFtcGxlLCB0aGF0IGFsbG93cyBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIGl0cyBpdGVtcyxcbiAgICAgICAgICAgICAgICBub3IgaXMgaXQgcG9zc2libGUgdG8gY29tYmluZSB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiBhIDxjb2RlPntcIjxzZWxlY3Q+XCJ9PC9jb2RlPiBtZW51IHdpdGggdGhlIG1lbnUgaW4gYSBkcmF3ZXIgY29tcG9uZW50LjwvcD5cblxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgV2hlbiBjb21pbmcgYWNyb3NzIGEgTGlzdCBvciBhIE1lbnUgb3IgYSBSYWRpb0dyb3VwIG9yIGEgVG9nZ2xlQnV0dG9uR3JvdXAgb3IgYW55IG90aGVyIFwib25lIGNvbXBvbmVudCBtYWRlIHVwIG9mIGNoaWxkIGNvbXBvbmVudHNcIiwgdGhlIHVzdWFsIGV4cGVjdGVkIGJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGF0IGxlYXN0IG5hdGl2ZWx5LCBpcyB0aGF0IHRhYmJpbmcgaW50byB0aGUgY29tcG9uZW50IGlzIG9uZSBhY3Rpb24sIGFuZCB0YWJiaW5nIG91dCBpcyBhbm90aGVyLiAgTmF2aWdhdGluZyA8ZW0+d2l0aGluPC9lbT4gdGhlIGNvbXBvbmVudCBpcyBkb25lIHdpdGggdGhlIGFycm93IGtleXMgb3Igb3RoZXIgbWV0aG9kcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIFRoaXMgaXMgaW1wb3J0YW50IGJvdGggZm9yIGFjY2Vzc2FiaWxpdHksIGJ1dCBhbHNvIGp1c3QgZm9yIGdlbmVyYWwgdXNhYmlsaXR5LiAgV2hlbiB0YWJiaW5nIGJhY2sgYW5kIGZvcnRoLCB0aGUgYWJpbGl0eSB0byBza2lwIGEgbG9uZyBsaXN0IHdpdGhvdXQgbmVlZGluZyB0byB0cnVkZ2UgdGhyb3VnaCA8ZW0+ZXZlcnkgb25lPC9lbT4gb2YgaXRzIGNoaWxkIGVsZW1lbnRzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQuXG4gICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIDxjb2RlPnVzZUxpc3ROYXZpZ2F0aW9uPC9jb2RlPiB3cmFwcyB1cCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhIGZldyBob29rcyAoPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+LCA8Y29kZT51c2VMaW5lYXJOYXZpZ2F0aW9uPC9jb2RlPiwgPGNvZGU+dXNlVHlwZWFoZWFkTmF2aWdhdGlvbjwvY29kZT4pXG4gICAgICAgICAgICAgICAgdG8gYWxsb3cgZm9yIEFSSUEtY29tcGxpYW50IG5hdmlnYXRpb24gb2YgbGlzdHMgYW5kIG90aGVyIHNpbWlsYXIgY29tcG9uZW50cy4gIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiB1c2UgdGhlIG90aGVyIGhvb2tzIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgIDwvcD5cblxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb248L2NvZGU+IChhbmQgPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+KSBpbnRlcm5hbGx5IHVzZSA8Y29kZT51c2VDaGlsZE1hbmFnZXI8L2NvZGU+LCB3aGljaCBpcyBob3cgdGhlIGNoaWxkIGVsZW1lbnRzIGFuZCB0aGUgcGFyZW50IGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAgICAgICAgICAgICAgICBUaGlzIG1lYW5zIHRoZXJlIGFyZSB2aXJ0dWFsbHkgbm8gcmVzdHJpY3Rpb25zIG9uIGhvdyB0aGUgRE9NIGlzIHNldCB1cCBhcyBsb25nIGFzIHlvdSBjYW4gcHJvdmlkZSB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb25DaGlsZDwvY29kZT4gaG9vayB0aGF0J3MgcmV0dXJuZWQsIHVzdWFsbHkgd2l0aCBhIHNpbXBsZSA8Y29kZT5Db250ZXh0PC9jb2RlPi5cbiAgICAgICAgICAgICAgICBJZiB0aGUgY2hpbGQgZWxlbWVudCBpdHNlbGYgaGFzIGEgZm9jdXNhYmxlIGVsZW1lbnQsIGxpa2UgYSBidXR0b24sIGl0IGNhbiBhbHNvIGJlIHdpcmVkIHVwIHRvIGRpc2FibGUgaXRzZWxmXG4gICAgICAgICAgICAgICAgRmVlbCBmcmVlIHRvIG5lc3QgdGhlbSB0b28sIGFzIGxvbmcgYXMgeW91IGFyZSBhd2FyZSBvZiB5b3VyIDxjb2RlPkNvbnRleHQ8L2NvZGU+IG1hbmFnZW1lbnQgKGkuZS4gcmVtZW1iZXIgdGhhdCB5b3UgbmVlZCB0byBjcmVhdGUgYSBuZXcgPGNvZGU+Q29udGV4dDwvY29kZT4gZm9yIGVhY2ggdXNlIGNhc2UpLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGxhYmVsPiMgb2YgaXRlbXM8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtjb3VudH0gbWluPXswfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcikgfX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzaHVmZmxlKGNoaWxkcmVuKX0+U2h1ZmZsZTwvYnV0dG9uPlxuICAgICAgICAgICAgPGxhYmVsPlRhYmJhYmxlIGluZGV4OiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0YWJiYWJsZUluZGV4ID8/IHVuZGVmaW5lZH0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0VGFiYmFibGVJbmRleChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlciwgZmFsc2UpOyB9fSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+U2VsZWN0ZWQgaW5kZXg6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3NlbGVjdGVkSW5kZXggPz8gdW5kZWZpbmVkfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3RlZEluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKTsgfX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPlNlbGVjdGlvbiBtb2RlOlxuICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgbmFtZT1cInJ0aS1kZW1vLXNlbGVjdGlvbi1tb2RlXCIgdHlwZT1cInJhZGlvXCIgY2hlY2tlZD17c2VsZWN0aW9uTW9kZSA9PSAnZm9jdXMnfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3Rpb25Nb2RlKFwiZm9jdXNcIik7IH19IC8+IE9uIGZvY3VzPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IG5hbWU9XCJydGktZGVtby1zZWxlY3Rpb24tbW9kZVwiIHR5cGU9XCJyYWRpb1wiIGNoZWNrZWQ9e3NlbGVjdGlvbk1vZGUgPT0gJ2FjdGl2YXRpb24nfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3Rpb25Nb2RlKFwiYWN0aXZhdGlvblwiKTsgfX0gLz4gT24gYWN0aXZhdGlvbiAoY2xpY2ssIHRhcCwgRW50ZXIsIFNwYWNlLCBldGMuKTwvbGFiZWw+XG4gICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgICAgICA8U2VsZWN0aW9uTW9kZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3NlbGVjdGlvbk1vZGV9PlxuICAgICAgICAgICAgICAgIDxMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkfT5cbiAgICAgICAgICAgICAgICAgICAgPHVsIHsuLi4odXNlUHJvcHModXNlTWVyZ2VkUHJvcHMocHJvcHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZVJvdmluZ1RhYkluZGV4Q2hpbGQgaW5kZXg9e2l9IGtleT17aX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpKVxuICAgICAgICAgICAgICAgICAgICB9KSkpfSAvPlxuICAgICAgICAgICAgICAgIDwvTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZENvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICA8L1NlbGVjdGlvbk1vZGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAge2N1cnJlbnRUeXBlYWhlYWQgJiYgPGRpdj5UeXBlYWhlYWQ6IHtjdXJyZW50VHlwZWFoZWFkfTwvZGl2Pn1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0pXG5cbmNvbnN0IFNlbGVjdGlvbk1vZGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcImZvY3VzXCIgYXMgXCJmb2N1c1wiIHwgXCJhY3RpdmF0aW9uXCIpO1xuY29uc3QgX1ByZWZpeCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcbmNvbnN0IERlbW9Vc2VSb3ZpbmdUYWJJbmRleENoaWxkID0gbWVtbygoKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb25Nb2RlID0gdXNlQ29udGV4dChTZWxlY3Rpb25Nb2RlQ29udGV4dCk7XG4gICAgY29uc3QgaGlkZGVuID0gKGluZGV4ID09IDcpO1xuICAgIGNvbnN0IFtyYW5kb21Xb3JkXSA9IHVzZVN0YXRlKCgpID0+IFJhbmRvbVdvcmRzW2luZGV4LypNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoUmFuZG9tV29yZHMubGVuZ3RoIC0gMSkpKi9dKTtcbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkID0gdXNlQ29udGV4dChMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkQ29udGV4dCk7XG4gICAgY29uc3QgdGV4dCA9IGAke3JhbmRvbVdvcmR9IFRoaXMgaXMgaXRlbSAjJHtpbmRleH0ke2hpZGRlbiA/IFwiIChoaWRkZW4pXCIgOiBcIlwifWA7XG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKGU6IEhUTUxFbGVtZW50KSA9PiB7IGUuZm9jdXMoKSB9LCBbXSk7XG4gICAgY29uc3Qgb2VjID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8SFRNTExJRWxlbWVudD5bXCJyZWZFbGVtZW50UGFyYW1ldGVyc1wiXVtcIm9uRWxlbWVudENoYW5nZVwiXT4+KChhLCBiKSA9PiBvbkVsZW1lbnRDaGFuZ2UoYSwgYikpO1xuICAgIC8vY29uc3Qgb2ZpYyA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkZvY3VzZWRJbm5lckNoYW5nZWQ+PigoYSwgYikgPT4gb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oYSwgYikpO1xuICAgIC8vY29uc3Qgb2xmaWMgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD4+KChhLCBiKSA9PiBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkPy4oYSwgYikpO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxIVE1MTElFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZTogb2VjIH0gfSk7XG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCBwcm9wc1N0YWJsZTogcDMgfSA9IHJlZkVsZW1lbnRSZXR1cm47XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm46IHsgdGFiYmFibGUsIHByb3BzVW5zdGFibGU6IHAyIH0sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuOiB7IHNlbGVjdGVkLCBwcm9wc1Vuc3RhYmxlOiBwNCB9LFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7IG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQgfSxcbiAgICAgICAgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHsgb25FbGVtZW50Q2hhbmdlIH0sXG4gICAgICAgIHByZXNzUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwNSwgcHJvcHNVbnN0YWJsZTogcDEgfSxcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCh7XG4gICAgICAgIG1hbmFnZWRDaGlsZFBhcmFtZXRlcnM6IHsgaW5kZXgsIGZsYWdzOiB7fSB9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczogeyB0ZXh0OiBcIlwiIH0sXG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGZvY3VzU2VsZiwgbm9Nb2RpZnlUYWJJbmRleDogZmFsc2UsIGhpZGRlbiB9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM6IHsgc2VsZWN0aW9uTW9kZSwgYXJpYVByb3BOYW1lOiBcImFyaWEtc2VsZWN0ZWRcIiwgdW5zZWxlY3RhYmxlOiBoaWRkZW4gfSxcbiAgICAgICAgc3ViSW5mbzoge30sXG4gICAgfSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVybjogeyBwcm9wc1N0YWJsZTogcDYgfVxuICAgIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXMoe1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZDogbnVsbCxcbiAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWRcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvcHMgPSB1c2VNZXJnZWRQcm9wcyhwMSwgcDIsIHAzLCBwNCwgcDUsIHA2KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxsaSB7Li4ucHJvcHN9Pnt0ZXh0fSAoe3RhYmJhYmxlID8gXCJUYWJiYWJsZVwiIDogXCJOb3QgdGFiYmFibGVcIn0sIHtzZWxlY3RlZCA/IFwiU2VsZWN0ZWRcIiA6IFwiTm90IHNlbGVjdGVkXCJ9KTxpbnB1dCB7Li4udXNlTWVyZ2VkUHJvcHMocHJvcHMsIHsgdHlwZTogXCJudW1iZXJcIiB9KSBhcyBhbnl9IHN0eWxlPXt7IHdpZHRoOiBcIjVjaFwiIH19IC8+PC9saT5cbiAgICApXG59KSk7IiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuLi8uLlwiO1xuXG5cbmV4cG9ydCBjb25zdCBEZW1vVXNlVGltZW91dCA9ICgpID0+IHtcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbdHJpZ2dlckluZGV4LCBzZXRUcmlnZ2VySW5kZXhdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBbZmlyZUNvdW50LCBzZXRGaXJlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dCwgdHJpZ2dlckluZGV4LCBjYWxsYmFjazogKCkgPT4gc2V0RmlyZUNvdW50KGkgPT4gKytpKSB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxsYWJlbD5UaW1lb3V0IGR1cmF0aW9uOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aW1lb3V0fSBvbklucHV0PXtlID0+IHNldFRpbWVvdXQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+UmVmcmVzaCBrZXk6IDxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPXt0cmlnZ2VySW5kZXh9IG9uSW5wdXQ9e2UgPT4gc2V0VHJpZ2dlckluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZSl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+VGhlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZCB7ZmlyZUNvdW50fSB0aW1le2ZpcmVDb3VudCA9PT0gMSA/IFwiXCIgOiBcInNcIn0uPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGgsIHJlbmRlciB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IG1lbW8gfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUFuaW1hdGlvbkZyYW1lLCB1c2VBc3luY0hhbmRsZXIsIHVzZURyYWdnYWJsZSwgdXNlRHJvcHBhYmxlLCB1c2VFbGVtZW50U2l6ZSwgdXNlRm9jdXNUcmFwLCB1c2VIYXNDdXJyZW50Rm9jdXMsIHVzZUhhc0xhc3RGb2N1cywgdXNlTWVyZ2VkUHJvcHMsIHVzZVJlZkVsZW1lbnQsIHVzZVN0YXRlIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgeyBFbGVtZW50U2l6ZSB9IGZyb20gXCIuLi91c2UtZWxlbWVudC1zaXplXCI7XG5pbXBvcnQgeyB1c2VHcmlkTmF2aWdhdGlvbiwgVXNlR3JpZE5hdmlnYXRpb25DZWxsLCBVc2VHcmlkTmF2aWdhdGlvblJvdyB9IGZyb20gXCIuLi91c2UtZ3JpZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyBEZW1vVXNlSW50ZXJ2YWwgfSBmcm9tIFwiLi9kZW1vcy91c2UtaW50ZXJ2YWxcIjtcbmltcG9ydCB7IERlbW9Vc2VSb3ZpbmdUYWJJbmRleCB9IGZyb20gXCIuL2RlbW9zL3VzZS1yb3ZpbmctdGFiLWluZGV4XCI7XG5pbXBvcnQgeyBEZW1vVXNlVGltZW91dCB9IGZyb20gXCIuL2RlbW9zL3VzZS10aW1lb3V0XCI7XG5cbmNvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xuXG5cblxuY29uc3QgRGVtb1VzZURyb3BwYWJsZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRyb3BwZWRGaWxlcywgZHJvcHBlZFN0cmluZ3MsIGZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHByb3BzU3RhYmxlOiBwcm9wcywgZHJvcEVycm9yIH0gPSB1c2VEcm9wcGFibGU8SFRNTERpdkVsZW1lbnQ+KHsgZWZmZWN0OiBcImNvcHlcIiB9KTtcblxuICAgIGNvbnN0IHsgcmVmOiBfcmVmIH0gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50Pih7fSwgeyByZWY6IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsISkgfSlcblxuICAgIGNvbnN0IHAgPSB1c2VNZXJnZWRQcm9wcyhwcm9wcywgeyBjbGFzc05hbWU6IFwiZGVtbyBkcm9wcGFibGVcIiB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgey4uLnB9PlxuXG4gICAgICAgICAgICB7ZHJvcHBlZFN0cmluZ3MgIT0gbnVsbCAmJiA8ZGl2PkRhdGEgZHJvcHBlZDogPHVsPnsoT2JqZWN0LmVudHJpZXMoZHJvcHBlZFN0cmluZ3MpIGFzIFtrZXlvZiB0eXBlb2Ygc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHN0cmluZ11bXSkubWFwKChbdHlwZSwgdmFsdWVdKSA9PiA8bGk+e3R5cGV9OiB7dmFsdWV9PC9saT4pfTwvdWw+PC9kaXY+fVxuICAgICAgICAgICAge2Ryb3BwZWRGaWxlcyAhPSBudWxsICYmIDxkaXY+RmlsZXMgZHJvcHBlZDogPHRhYmxlPlxuICAgICAgICAgICAgICAgIDx0aGVhZD48dHI+PHRoPk5hbWU8L3RoPjx0aD5TaXplPC90aD48dGg+VHlwZTwvdGg+PHRoPkxhc3QgbW9kaWZpZWQ8L3RoPjwvdHI+PC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHk+e2Ryb3BwZWRGaWxlcy5tYXAoZiA9PiA8dHI+PHRkPntmLm5hbWV9PC90ZD57Zi5kYXRhLmJ5dGVMZW5ndGh9PHRkPntmLnR5cGV9PC90ZD48dGQ+e25ldyBEYXRlKGYubGFzdE1vZGlmaWVkID8/IDApfTwvdGQ+PC90cj4pfTwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPjwvZGl2Pn1cbiAgICAgICAgICAgIDxociAvPlxuXG4gICAgICAgICAgICB7c3RyaW5nc0ZvckNvbnNpZGVyYXRpb24gIT0gbnVsbCAmJiA8ZGl2PkRhdGEgYmVpbmcgY29uc2lkZXJlZDogPHVsPntBcnJheS5mcm9tKHN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKS5tYXAodHlwZSA9PiA8bGk+e3R5cGV9PC9saT4pfTwvdWw+PC9kaXY+fVxuICAgICAgICAgICAge2ZpbGVzRm9yQ29uc2lkZXJhdGlvbiAhPSBudWxsICYmIDxkaXY+RmlsZXMgYmVpbmcgY29uc2lkZXJlZDogPHVsPntmaWxlc0ZvckNvbnNpZGVyYXRpb24ubWFwKGYgPT4gPGxpPntKU09OLnN0cmluZ2lmeShmKX08L2xpPil9PC91bD48L2Rpdj59XG5cbiAgICAgICAgICAgIDxociAvPlxuICAgICAgICAgICAge2Ryb3BFcnJvciAmJiA8ZGl2Pntkcm9wRXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGRyb3BFcnJvci5tZXNzYWdlIDogSlNPTi5zdHJpbmdpZnkoZHJvcEVycm9yKX08L2Rpdj59XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cblxuY29uc3QgRGVtb1VzZURyYWdnYWJsZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IHByb3BzVW5zdGFibGU6IHByb3BzIH0gPSB1c2VEcmFnZ2FibGU8SFRNTERpdkVsZW1lbnQ+KHsgZGF0YTogeyBcInRleHQvcGxhaW5cIjogXCJUaGlzIGlzIGN1c3RvbSBkcmFnZ2FibGUgY29udGVudCBvZiB0eXBlIHRleHQvcGxhaW4uXCIgfSB9KTtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiB7Li4udXNlTWVyZ2VkUHJvcHMocHJvcHMsIHsgY2xhc3NOYW1lOiBcImRlbW9cIiB9KX0+XG4gICAgICAgICAgICBEcmFnZ2FibGUgY29udGVudFxuICAgICAgICA8L2Rpdj4pXG59XG5cbmNvbnN0IERlbW9Vc2VFbGVtZW50U2l6ZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBbaGVpZ2h0LCBzZXRIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW2FuZ2xlLCBzZXRBbmdsZV0gPSB1c2VTdGF0ZSgwKTtcbiAgICB1c2VBbmltYXRpb25GcmFtZSh7XG4gICAgICAgIGNhbGxiYWNrOiAoX21zKSA9PiB7XG4gICAgICAgICAgICBzZXRBbmdsZShhID0+IGEgKyAwLjAxKVxuICAgICAgICAgICAgc2V0SGVpZ2h0KChNYXRoLnNpbihhbmdsZSkgKyAxKSAvIDAuNSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IFtlbGVtZW50U2l6ZSwgc2V0RWxlbWVudFNpemVdID0gdXNlU3RhdGU8RWxlbWVudFNpemUgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IHsgZWxlbWVudFNpemVSZXR1cm46IHsgZ2V0U2l6ZSB9LCByZWZFbGVtZW50UmV0dXJuOiB7IHByb3BzU3RhYmxlIH0gfSA9IHVzZUVsZW1lbnRTaXplPEhUTUxEaXZFbGVtZW50Pih7XG4gICAgICAgIGVsZW1lbnRTaXplUGFyYW1ldGVyczogeyBvblNpemVDaGFuZ2U6IHNldEVsZW1lbnRTaXplLCBnZXRPYnNlcnZlQm94OiBudWxsIH0sXG4gICAgICAgIHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7IG9uRWxlbWVudENoYW5nZTogdW5kZWZpbmVkIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgey4uLnVzZU1lcmdlZFByb3BzKHByb3BzU3RhYmxlLCB7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZGVtb1wiLCBzdHlsZTogeyBoZWlnaHQ6IGAkeyhoZWlnaHQgKiAxMDApICsgMTAwfXB4YCB9IH0pfT5cbiAgICAgICAgICAgIDxwcmU+e0pTT04uc3RyaW5naWZ5KGVsZW1lbnRTaXplLCBudWxsLCAyKX08L3ByZT5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn1cblxuXG5jb25zdCBEZW1vVXNlRm9jdXNUcmFwID0gbWVtbygoeyBkZXB0aCB9OiB7IGRlcHRoPzogbnVtYmVyIH0pID0+IHtcblxuICAgIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG5cbiAgICBjb25zdCB7IGFjdGl2ZUVsZW1lbnRSZXR1cm46IHsgfSwgZm9jdXNUcmFwOiB7IHByb3BzVW5zdGFibGUgfSwgcmVmRWxlbWVudFJldHVybjogeyBwcm9wc1N0YWJsZSB9IH0gPSB1c2VGb2N1c1RyYXA8SFRNTERpdkVsZW1lbnQ+KHsgZm9jdXNUcmFwUGFyYW1ldGVyczogeyB0cmFwQWN0aXZlOiBhY3RpdmUgfSwgYWN0aXZlRWxlbWVudFBhcmFtZXRlcnM6IHsgZ2V0RG9jdW1lbnQgfSwgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHsgb25FbGVtZW50Q2hhbmdlOiB1bmRlZmluZWQgfSB9KTtcbiAgICAvL2NvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhQcm9wcyB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTFVMaXN0RWxlbWVudCwgUm92aW5nVGFiSW5kZXhDaGlsZEluZm8+KHsgdGFiYmFibGVJbmRleCwgZm9jdXNPbkNoYW5nZTogZmFsc2UgfSk7XG5cbiAgICBjb25zdCBkaXZQcm9wcyA9IHVzZU1lcmdlZFByb3BzKHByb3BzVW5zdGFibGUsIHByb3BzU3RhYmxlLCB7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZm9jdXMtdHJhcC1kZW1vXCIgfSk7XG4gICAgaWYgKGRlcHRoID09IDIpXG4gICAgICAgIHJldHVybiA8ZGl2IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IHsuLi5kaXZQcm9wc30gPlxuICAgICAgICAgICAgICAgIDxEZW1vVXNlRm9jdXNUcmFwQ2hpbGQgYWN0aXZlPXthY3RpdmV9IHNldEFjdGl2ZT17c2V0QWN0aXZlfSBkZXB0aD17ZGVwdGggPz8gMH0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG5cblxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcENoaWxkID0gbWVtbygoeyBzZXRBY3RpdmUsIGFjdGl2ZSB9OiB7IGFjdGl2ZTogYm9vbGVhbiwgc2V0QWN0aXZlOiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkLCBkZXB0aDogbnVtYmVyIH0pID0+IHtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDE8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDI8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDM8L2J1dHRvbj5cbiAgICAgICAgICAgIDxsYWJlbD5BY3RpdmU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXthY3RpdmV9IG9uSW5wdXQ9e2UgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IHNldEFjdGl2ZShlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCk7IH19IC8+PC9sYWJlbD5cblxuICAgICAgICA8Lz5cbiAgICApO1xufSk7XG5cbmNvbnN0IERlbW9Vc2VBc3luY0hhbmRsZXIxID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbZGVib3VuY2UsIHNldERlYm91bmNlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtzaG91bGRUaHJvdywgc2V0U2hvdWxkVGhyb3csIGdldFNob3VsZFRocm93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgYXN5bmNPbkNsaWNrID0gKChfdjogdm9pZCwgX2U6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGdldFNob3VsZFRocm93KCkgPyByZWplY3QoKSA6IHJlc29sdmUoKSwgdGltZW91dCkpKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGNhbGxDb3VudCxcbiAgICAgICAgc2V0dGxlQ291bnQsXG4gICAgICAgIGhhc0NhcHR1cmUsXG4gICAgICAgIHN5bmNIYW5kbGVyLFxuICAgICAgICBwZW5kaW5nLFxuICAgICAgICBoYXNFcnJvcixcbiAgICAgICAgcmVqZWN0Q291bnQsXG4gICAgICAgIHJlc29sdmVDb3VudFxuICAgIH0gPSB1c2VBc3luY0hhbmRsZXI8aC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50Piwgdm9pZD4oeyBhc3luY0hhbmRsZXI6IGFzeW5jT25DbGljaywgY2FwdHVyZTogKCkgPT4geyB9LCBkZWJvdW5jZTogZGVib3VuY2UgPT0gMCA/IHVuZGVmaW5lZCA6IGRlYm91bmNlIH0pO1xuXG4gICAgY29uc3Qgb25DbGljayA9IHBlbmRpbmcgPyB1bmRlZmluZWQgOiBzeW5jSGFuZGxlcjtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uQ2xpY2s9e29uQ2xpY2t9PkNsaWNrIG1lITwvYnV0dG9uPlxuICAgICAgICAgICAgPGxhYmVsPlNsZWVwIGZvcjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGltZW91dH0gb25JbnB1dD17ZSA9PiBzZXRUaW1lb3V0KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPlRocm93IGFuIGVycm9yIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzaG91bGRUaHJvd30gb25JbnB1dD17ZSA9PiBzZXRTaG91bGRUaHJvdyhlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5EaXNhYmxlZCB3aGlsZSBwZW5kaW5nIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e2UgPT4gc2V0RGlzYWJsZUNvbnNlY3V0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPkRlYm91bmNlOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtkZWJvdW5jZX0gb25JbnB1dD17ZSA9PiBzZXREZWJvdW5jZShlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5GaWVsZDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmNhbGxDb3VudDwvdGQ+PHRkPntjYWxsQ291bnR9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnNldHRsZUNvdW50PC90ZD48dGQ+e3NldHRsZUNvdW50fTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZXNvbHZlQ291bnQ8L3RkPjx0ZD57cmVzb2x2ZUNvdW50fTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZWplY3RDb3VudDwvdGQ+PHRkPntyZWplY3RDb3VudH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzRXJyb3I8L3RkPjx0ZD57aGFzRXJyb3IudG9TdHJpbmcoKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzQ2FwdHVyZTwvdGQ+PHRkPntoYXNDYXB0dXJlLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG5cbmNvbnN0IERlbW9Vc2VBc3luY0hhbmRsZXIyID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbZGVib3VuY2UsIHNldERlYm91bmNlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtzaG91bGRUaHJvdywgc2V0U2hvdWxkVGhyb3csIGdldFNob3VsZFRocm93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBvbklucHV0QXN5bmMgPSBhc3luYyAodjogc3RyaW5nLCBfZTogYW55KSA9PiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChnZXRTaG91bGRUaHJvdygpKSB7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRleHQodik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9LCB0aW1lb3V0KSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNhbGxDb3VudCxcbiAgICAgICAgc2V0dGxlQ291bnQsXG4gICAgICAgIGhhc0NhcHR1cmUsXG4gICAgICAgIHN5bmNIYW5kbGVyLFxuICAgICAgICBjdXJyZW50Q2FwdHVyZSxcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgaGFzRXJyb3IsXG4gICAgICAgIHJlamVjdENvdW50LFxuICAgICAgICByZXNvbHZlQ291bnRcbiAgICB9ID0gdXNlQXN5bmNIYW5kbGVyPGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sIHN0cmluZz4oeyBhc3luY0hhbmRsZXI6IG9uSW5wdXRBc3luYywgY2FwdHVyZTogKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZS5jdXJyZW50VGFyZ2V0LnZhbHVlIH0sIGRlYm91bmNlOiBkZWJvdW5jZSA9PSAwID8gdW5kZWZpbmVkIDogZGVib3VuY2UgfSk7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGxhYmVsPkRlbW8gdGV4dDogPGlucHV0IHZhbHVlPXtoYXNDYXB0dXJlID8gY3VycmVudENhcHR1cmUgOiB0ZXh0fSBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e3N5bmNIYW5kbGVyfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8aHIgLz5cbiAgICAgICAgICAgIDxsYWJlbD5TbGVlcCBmb3I6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RpbWVvdXR9IG9uSW5wdXQ9e2UgPT4gc2V0VGltZW91dChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5UaHJvdyBhbiBlcnJvciA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17c2hvdWxkVGhyb3d9IG9uSW5wdXQ9e2UgPT4gc2V0U2hvdWxkVGhyb3coZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+RGlzYWJsZWQgd2hpbGUgcGVuZGluZyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17ZGlzYWJsZUNvbnNlY3V0aXZlfSBvbklucHV0PXtlID0+IHNldERpc2FibGVDb25zZWN1dGl2ZShlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5EZWJvdW5jZTogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17ZGVib3VuY2V9IG9uSW5wdXQ9e2UgPT4gc2V0RGVib3VuY2UoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+RmllbGQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPlZhbHVlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5jYWxsQ291bnQ8L3RkPjx0ZD57Y2FsbENvdW50fTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5zZXR0bGVDb3VudDwvdGQ+PHRkPntzZXR0bGVDb3VudH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVzb2x2ZUNvdW50PC90ZD48dGQ+e3Jlc29sdmVDb3VudH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVqZWN0Q291bnQ8L3RkPjx0ZD57cmVqZWN0Q291bnR9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmhhc0Vycm9yPC90ZD48dGQ+e2hhc0Vycm9yLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmN1cnJlbnRDYXB0dXJlPC90ZD48dGQ+e2N1cnJlbnRDYXB0dXJlfTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5cIlNhdmVkXCIgaW5wdXQ8L3RkPjx0ZD57dGV4dH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KTtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn1cblxuY29uc3QgRGVtb0ZvY3VzID0gbWVtbygoKSA9PiB7XG4gICAgY29uc3QgW2xhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VTdGF0ZTwoRWxlbWVudCkgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbYWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VTdGF0ZTwoRWxlbWVudCkgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbd2luZG93Rm9jdXNlZCwgc2V0V2luZG93Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2xhc3RGb2N1c2VkLCBzZXRMYXN0Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2xhc3RGb2N1c2VkSW5uZXIsIHNldExhc3RGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxIVE1MRGl2RWxlbWVudD4oeyByZWZFbGVtZW50UGFyYW1ldGVyczogeyBvbkVsZW1lbnRDaGFuZ2U6IHVuZGVmaW5lZCB9IH0pO1xuICAgIGNvbnN0IHsgcHJvcHNTdGFibGU6IHAyIH0gPSByZWZFbGVtZW50UmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwMSB9XG4gICAgfSA9IHVzZUhhc0N1cnJlbnRGb2N1czxIVE1MRGl2RWxlbWVudD4oe1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZDogc2V0Rm9jdXNlZCxcbiAgICAgICAgICAgIG9uQ3VycmVudEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldEZvY3VzZWRJbm5lcixcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgICAgYWN0aXZlRWxlbWVudFJldHVybjogeyAgfSxcbiAgICAgICAgaGFzTGFzdEZvY3VzUmV0dXJuOiB7ICB9LFxuXG4gICAgfSA9IHVzZUhhc0xhc3RGb2N1czxIVE1MRGl2RWxlbWVudD4oe1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBhY3RpdmVFbGVtZW50UGFyYW1ldGVyczoge1xuICAgICAgICAgICAgZ2V0RG9jdW1lbnQsXG4gICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHNldEFjdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiBzZXRMYXN0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZTogc2V0V2luZG93Rm9jdXNlZFxuICAgICAgICB9LFxuICAgICAgICBoYXNMYXN0Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZDogc2V0TGFzdEZvY3VzZWQsXG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRMYXN0Rm9jdXNlZElubmVyLFxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxoMj51c2VIYXNGb2N1czwvaDI+XG4gICAgICAgICAgICA8ZGl2IHsuLi4odXNlTWVyZ2VkUHJvcHMocDIsIHAxLCB7IHN0eWxlOiB7IGJvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIiB9LCB0YWJJbmRleDogMCB9KSl9Pk91dGVyIDxkaXYgdGFiSW5kZXg9ezB9IHN0eWxlPXt7IGJvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIiB9fT5Jbm5lciBlbGVtZW50PC9kaXY+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgPGxpPlN0cmljdGx5IGZvY3VzZWQ6IHtmb2N1c2VkLnRvU3RyaW5nKCl9LCB7bGFzdEZvY3VzZWQudG9TdHJpbmcoKX08L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+SW5uZXIgZm9jdXNlZDoge2ZvY3VzZWRJbm5lci50b1N0cmluZygpfSwge2xhc3RGb2N1c2VkSW5uZXIudG9TdHJpbmcoKX08L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+V2luZG93IGZvY3VzZWQ6IHt3aW5kb3dGb2N1c2VkLnRvU3RyaW5nKCl9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpPmFjdGl2ZUVsZW1lbnQ6IHthY3RpdmVFbGVtZW50Py50ZXh0Q29udGVudH08L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+bGFzdEFjdGl2ZUVsZW1lbnQ6IHtsYXN0QWN0aXZlRWxlbWVudD8udGV4dENvbnRlbnR9PC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn0pXG5cblxuY29uc3QgR3JpZFJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWROYXZpZ2F0aW9uUm93PEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwge30sIHN0cmluZywgc3RyaW5nPj4obnVsbCEpO1xuY29uc3QgR3JpZENlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkTmF2aWdhdGlvbkNlbGw8SFRNTFRhYmxlQ2VsbEVsZW1lbnQsIHt9LCBzdHJpbmc+PihudWxsISk7XG5leHBvcnQgY29uc3QgRGVtb1VzZUdyaWQgPSBtZW1vKCgpID0+IHtcblxuICAgIC8vY29uc3QgWywgc2V0TGFzdEZvY3VzZWRJbm5lciwgX2dldExhc3RGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIC8vY29uc3QgeyBwcm9wcyB9ID0gdXNlSGFzRm9jdXM8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+KHsgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogc2V0TGFzdEZvY3VzZWRJbm5lciwgZ2V0RG9jdW1lbnQgfSk7XG4gICAgY29uc3Qge1xuICAgICAgICBncmlkTmF2aWdhdGlvblJldHVybjogeyBjdXJyZW50Q29sdW1uIH0sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHsgcHJvcHNTdGFibGU6IHAyIH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUmV0dXJuOiB7IH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblJldHVybjogeyB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybjogeyB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuOiB7IHByb3BzU3RhYmxlOiBwMSB9LFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1xuICAgIH0gPSB1c2VHcmlkTmF2aWdhdGlvbjxIVE1MVGFibGVTZWN0aW9uRWxlbWVudCwgSFRNTFRhYmxlUm93RWxlbWVudCwgSFRNTFRhYmxlQ2VsbEVsZW1lbnQsIHt9LCB7fSwgc3RyaW5nLCBzdHJpbmc+KHtcbiAgICAgICAgcm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBsaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM6IHt9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczoge30sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM6IHt9LFxuICAgICAgICBncmlkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHt9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICAgICAgezxkaXY+Q3VycmVudCBjb2x1bW46IHtjdXJyZW50Q29sdW1ufTwvZGl2Pn1cbiAgICAgICAgICAgIDx0YWJsZSB7Li4ueyBib3JkZXI6IFwiMlwiIH0gYXMge319IHN0eWxlPXt7IHdoaXRlU3BhY2U6IFwibm93cmFwXCIgfX0+XG5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5Sb3cgaXMgdGFiYmFibGU/PC90aD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5Db2x1bW4gMTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Q29sdW1uIDI8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5IHsuLi51c2VNZXJnZWRQcm9wcyhwMSwgcDIpfT5cbiAgICAgICAgICAgICAgICAgICAgPEdyaWRSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkTmF2aWdhdGlvblJvd30+XG4gICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9Vc2VHcmlkUm93IGluZGV4PXtpfSBrZXk9e2l9IC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICAgICAgICAgIDwvR3JpZFJvd0NvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KVxuXG5jb25zdCBfUHJlZml4ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xuY29uc3QgRGVtb1VzZUdyaWRSb3cgPSBtZW1vKCgoeyBpbmRleCB9OiB7IGluZGV4OiBudW1iZXIgfSkgPT4ge1xuICAgIGNvbnN0IFtfcmFuZG9tV29yZF0gPSB1c2VTdGF0ZSgoKSA9PiBSYW5kb21Xb3Jkc1tpbmRleC8qTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKFJhbmRvbVdvcmRzLmxlbmd0aCAtIDEpKSovXSk7XG4gICAgY29uc3QgdXNlR3JpZFJvdyA9IHVzZUNvbnRleHQoR3JpZFJvd0NvbnRleHQpO1xuICAgIGNvbnN0IHsgcmVmRWxlbWVudFJldHVybiB9ID0gdXNlUmVmRWxlbWVudDxIVE1MVGFibGVSb3dFbGVtZW50Pih7IHJlZkVsZW1lbnRQYXJhbWV0ZXJzOiB7fSB9KVxuICAgIGNvbnN0IHsgcHJvcHNTdGFibGU6IHA0IH0gPSByZWZFbGVtZW50UmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsLFxuICAgICAgICBhc1BhcmVudE9mQ2VsbHM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25SZXR1cm46IHsgcHJvcHNTdGFibGU6IHAyIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvblJldHVybjogeyB9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuUmV0dXJuOiB7IH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleFJldHVybjogeyB9LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblJldHVybjogeyBwcm9wc1N0YWJsZTogcDEsIH1cblxuICAgICAgICB9LFxuICAgICAgICBhc0NoaWxkUm93OiB7IGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsIHJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm46IHsgdGFiYmFibGUsIHByb3BzVW5zdGFibGU6IHAzIH0gfSxcbiAgICB9ID0gdXNlR3JpZFJvdyh7XG4gICAgICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IHtcbiAgICAgICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCBmbGFnczoge30gfSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IHRleHQ6IFwiXCIgfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzOiB7IGhpZGRlbjogaW5kZXggPT0gMywgbm9Nb2RpZnlUYWJJbmRleDogZmFsc2UgfSxcbiAgICAgICAgICAgIHN1YkluZm86IHt9LFxuICAgICAgICB9LFxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHtcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczoge30sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM6IHt9LFxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczoge31cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1JldHVyblxuICAgIH0gPSB1c2VIYXNDdXJyZW50Rm9jdXM8SFRNTFRhYmxlUm93RWxlbWVudD4oe1xuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICBoYXNDdXJyZW50Rm9jdXNQYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICBvbkN1cnJlbnRGb2N1c2VkQ2hhbmdlZDogbnVsbCxcbiAgICAgICAgICAgIC4uLmhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMsXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHByb3BzID0gdXNlTWVyZ2VkUHJvcHModXNlTWVyZ2VkUHJvcHModXNlTWVyZ2VkUHJvcHMocDEsIHAyKSwgcDMpLCBwNCk7XG4gICAgcmV0dXJuIChcbiAgICAgICAgPHRyIHsuLi5wcm9wc30+XG4gICAgICAgICAgICA8R3JpZENlbGxDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkTmF2aWdhdGlvbkNlbGx9PlxuICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9Vc2VHcmlkQ2VsbCBpbmRleD17aX0ga2V5PXtpfSByb3c9e2luZGV4fSByb3dJc1RhYmJhYmxlPXt0YWJiYWJsZX0gLz5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCkpfVxuICAgICAgICAgICAgPC9HcmlkQ2VsbENvbnRleHQuUHJvdmlkZXI+XG4gICAgICAgIDwvdHI+XG4gICAgKVxufSkpO1xuXG5jb25zdCBEZW1vVXNlR3JpZENlbGwgPSAoKHsgaW5kZXgsIHJvdywgcm93SXNUYWJiYWJsZSB9OiB7IGluZGV4OiBudW1iZXIsIHJvdzogbnVtYmVyLCByb3dJc1RhYmJhYmxlOiBib29sZWFuIH0pID0+IHtcbiAgICBpZiAocm93ID49IDYgJiYgcm93ICUgMiA9PSAwICYmIGluZGV4ID4gMSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgaGlkZGVuVGV4dCA9IChyb3cgPT09IDMpID8gXCIgKHJvdyBoaWRkZW4pXCIgOiBcIlwiXG5cbiAgICBjb25zdCB1c2VHcmlkQ2VsbCA9IHVzZUNvbnRleHQoR3JpZENlbGxDb250ZXh0KTtcbiAgICBjb25zdCB7IHJlZkVsZW1lbnRSZXR1cm4gfSA9IHVzZVJlZkVsZW1lbnQ8SFRNTFRhYmxlQ2VsbEVsZW1lbnQ+KHsgcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9IH0pO1xuICAgIGNvbnN0IHsgcHJvcHNTdGFibGU6IHAxIH0gPSByZWZFbGVtZW50UmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgICAgaGFzQ3VycmVudEZvY3VzUGFyYW1ldGVycyxcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25SZXR1cm46IHsgfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFJldHVybjogeyB0YWJiYWJsZTogY2VsbElzVGFiYmFibGUsIHByb3BzVW5zdGFibGU6IHAyIH0sXG4gICAgfSA9IHVzZUdyaWRDZWxsKHtcbiAgICAgICAgLy9oYXNGb2N1c1BhcmFtZXRlcnM6IHsgb25Gb2N1c2VkQ2hhbmdlZDogbnVsbCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiBudWxsLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZDogbnVsbCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogbnVsbCB9LFxuICAgICAgICAvL2FjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzOiB7IGdldERvY3VtZW50IH0sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzOiB7IHRleHQ6IFwiXCIgfSxcbiAgICAgICAgLy8gcmVmRWxlbWVudFBhcmFtZXRlcnM6IHt9LFxuICAgICAgICByZWZFbGVtZW50UmV0dXJuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczogeyBub01vZGlmeVRhYkluZGV4OiBmYWxzZSwgZm9jdXNTZWxmOiBlID0+IGUuZm9jdXMoKSwgaGlkZGVuOiBmYWxzZSB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzOiB7IGluZGV4LCBmbGFnczoge30gfSxcbiAgICAgICAgc3ViSW5mbzoge30sXG4gICAgfSk7XG4gICAgY29uc3Qge1xuICAgICAgICBoYXNDdXJyZW50Rm9jdXNSZXR1cm46IHsgcHJvcHNTdGFibGU6IHAzIH1cbiAgICB9ID0gdXNlSGFzQ3VycmVudEZvY3VzPEhUTUxUYWJsZUNlbGxFbGVtZW50Pih7XG4gICAgICAgIHJlZkVsZW1lbnRSZXR1cm4sXG4gICAgICAgIGhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnM6IHsgb25DdXJyZW50Rm9jdXNlZENoYW5nZWQ6IG51bGwsIC4uLmhhc0N1cnJlbnRGb2N1c1BhcmFtZXRlcnMgfVxuICAgIH0pXG5cbiAgICBjb25zdCBwcm9wcyA9IHVzZU1lcmdlZFByb3BzKHAxLCBwMiwgcDMpO1xuXG4gICAgY29uc3QgdCA9IChjZWxsSXNUYWJiYWJsZSA/IFwiKFRhYmJhYmxlKVwiIDogXCIoTm90IHRhYmJhYmxlKVwiKVxuXG4gICAgaWYgKGluZGV4ID09PSAwKVxuICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30+e3Jvd0lzVGFiYmFibGUudG9TdHJpbmcoKX08L3RkPlxuICAgIGVsc2Uge1xuICAgICAgICBpZiAocm93IDwgNiB8fCByb3cgJSAyICE9IDApIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30+R3JpZCBjZWxsICN7aW5kZXggKyAxfSB7dH17aGlkZGVuVGV4dH08L3RkPlxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiA8dGQ+PGxhYmVsPjxpbnB1dCAgey4uLihwcm9wcyBhcyBhbnkpfSB0eXBlPVwiY2hlY2tib3hcIiAvPiBUZXN0IGlucHV0IHt0fXtoaWRkZW5UZXh0fTwvbGFiZWw+PC90ZD5cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30gY29sU3Bhbj17Mn0+R3JpZCBjZWxsICN7aW5kZXggKyAxfSwgc3BhbiAyIHt0fXtoaWRkZW5UZXh0fTwvdGQ+XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgfVxuICAgIH1cbn0pXG5cbmNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cImZsZXhcIiBzdHlsZT17eyBmbGV4V3JhcDogXCJ3cmFwXCIgfX0+XG4gICAgICAgIDxEZW1vRm9jdXMgLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxEZW1vVXNlR3JpZCAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPERlbW9Vc2VUaW1lb3V0IC8+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8RGVtb1VzZUludGVydmFsIC8+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8RGVtb1VzZVJvdmluZ1RhYkluZGV4IC8+XG4gICAgICAgIDxociAvPlxuXG5cbiAgICAgICAgPERlbW9Vc2VGb2N1c1RyYXAgLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxEZW1vVXNlQXN5bmNIYW5kbGVyMSAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPERlbW9Vc2VBc3luY0hhbmRsZXIyIC8+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8RGVtb1VzZURyb3BwYWJsZSAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxEZW1vVXNlRWxlbWVudFNpemVBbmltYXRpb24gLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxpbnB1dCAvPlxuICAgIDwvZGl2PlxufVxuXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlbmRlcig8Q29tcG9uZW50IC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJvb3RcIikhKTtcbn0pXG4iXSwibmFtZXMiOlsic2xpY2UiLCJvcHRpb25zIiwidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJwcmV2RGVib3VuY2UiLCJpIiwiRU1QVFlfT0JKIiwiRU1QVFlfQVJSIiwiSVNfTk9OX0RJTUVOU0lPTkFMIiwiYXNzaWduIiwib2JqIiwicHJvcHMiLCJyZW1vdmVOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiY2hpbGRyZW4iLCJrZXkiLCJyZWYiLCJub3JtYWxpemVkUHJvcHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwiY3JlYXRlVk5vZGUiLCJvcmlnaW5hbCIsInZub2RlIiwiX19rIiwiX18iLCJfX2IiLCJfX2UiLCJfX2QiLCJfX2MiLCJfX2giLCJjb25zdHJ1Y3RvciIsIl9fdiIsIkZyYWdtZW50IiwiQ29tcG9uZW50IiwiY29udGV4dCIsInRoaXMiLCJnZXREb21TaWJsaW5nIiwiY2hpbGRJbmRleCIsImluZGV4T2YiLCJzaWJsaW5nIiwidXBkYXRlUGFyZW50RG9tUG9pbnRlcnMiLCJjaGlsZCIsImJhc2UiLCJlbnF1ZXVlUmVuZGVyIiwiYyIsInB1c2giLCJwcm9jZXNzIiwiZGVib3VuY2VSZW5kZXJpbmciLCJzZXRUaW1lb3V0IiwicXVldWUiLCJfX3IiLCJzb3J0IiwiYSIsImIiLCJzb21lIiwiY29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJvbGRWTm9kZSIsIm9sZERvbSIsInBhcmVudERvbSIsIl9fUCIsImRpZmYiLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJuZXh0RG9tIiwic2liRG9tIiwib3V0ZXIiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJsIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwicmVtb3ZlQXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsIl9fRSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJfX24iLCJfc2IiLCJfX3MiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsIl9faHRtbCIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwicmVwbGFjZU5vZGUiLCJmaXJzdENoaWxkIiwiY3JlYXRlQ29udGV4dCIsImRlZmF1bHRWYWx1ZSIsImNvbnRleHRJZCIsIkNvbnN1bWVyIiwiY29udGV4dFZhbHVlIiwiUHJvdmlkZXIiLCJzdWJzIiwiY3R4IiwiX3Byb3BzIiwib2xkIiwic3BsaWNlIiwiZXJyb3IiLCJlcnJvckluZm8iLCJjdG9yIiwiaGFuZGxlZCIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsInNldFN0YXRlIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJpc1ZhbGlkRWxlbWVudCIsInVwZGF0ZSIsImNhbGxiYWNrIiwicyIsImZvcmNlVXBkYXRlIiwiX19zZWxmIiwiX19zb3VyY2UiLCJjdXJyZW50SW5kZXgiLCJjdXJyZW50Q29tcG9uZW50IiwicHJldmlvdXNDb21wb25lbnQiLCJwcmV2UmFmIiwiY3VycmVudEhvb2siLCJhZnRlclBhaW50RWZmZWN0cyIsIkVNUFRZIiwib2xkQmVmb3JlRGlmZiIsIm9sZEJlZm9yZVJlbmRlciIsIm9sZEFmdGVyRGlmZiIsIm9sZENvbW1pdCIsIm9sZEJlZm9yZVVubW91bnQiLCJnZXRIb29rU3RhdGUiLCJpbmRleCIsImhvb2tzIiwiX19IIiwiX19WIiwidXNlU3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VSZWR1Y2VyIiwiaW52b2tlT3JSZXR1cm4iLCJyZWR1Y2VyIiwiaW5pdCIsImhvb2tTdGF0ZSIsIl9yZWR1Y2VyIiwiYWN0aW9uIiwiY3VycmVudFZhbHVlIiwiX19OIiwibmV4dFZhbHVlIiwiX2hhc1NjdUZyb21Ib29rcyIsInByZXZTY3UiLCJwIiwic3RhdGVIb29rcyIsImZpbHRlciIsIngiLCJldmVyeSIsInNob3VsZFVwZGF0ZSIsImhvb2tJdGVtIiwidXNlRWZmZWN0IiwiYXJncyIsImFyZ3NDaGFuZ2VkIiwiX3BlbmRpbmdBcmdzIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlUmVmIiwiaW5pdGlhbFZhbHVlIiwidXNlTWVtbyIsImZhY3RvcnkiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJmbHVzaEFmdGVyUGFpbnRFZmZlY3RzIiwic2hpZnQiLCJpbnZva2VDbGVhbnVwIiwiaW52b2tlRWZmZWN0IiwiX19tIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiYWZ0ZXJOZXh0RnJhbWUiLCJoYXNFcnJvcmVkIiwiSEFTX1JBRiIsInJhZiIsImRvbmUiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJob29rIiwiY29tcCIsImNsZWFudXAiLCJvbGRBcmdzIiwibmV3QXJncyIsImFyZyIsImYiLCJzaGFsbG93RGlmZmVycyIsIlB1cmVDb21wb25lbnQiLCJtZW1vIiwiY29tcGFyZXIiLCJuZXh0UHJvcHMiLCJ1cGRhdGVSZWYiLCJNZW1vZWQiLCJkaXNwbGF5TmFtZSIsImlzUmVhY3RDb21wb25lbnQiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIm9sZERpZmZIb29rIiwiX19mIiwibWFwRm4iLCJvbGRDYXRjaEVycm9yIiwidGhlbiIsIm9sZFVubW91bnQiLCJkZXRhY2hlZENsb25lIiwiZGV0YWNoZWRQYXJlbnQiLCJlZmZlY3QiLCJtYXAiLCJyZW1vdmVPcmlnaW5hbCIsIm9yaWdpbmFsUGFyZW50IiwiU3VzcGVuc2UiLCJfX3UiLCJfc3VzcGVuZGVycyIsInN1c3BlbmRlZCIsIl9fYSIsIlN1c3BlbnNlTGlzdCIsIl9uZXh0IiwiX21hcCIsIl9fUiIsInByb21pc2UiLCJzdXNwZW5kaW5nVk5vZGUiLCJzdXNwZW5kaW5nQ29tcG9uZW50IiwicmVzb2x2ZSIsInJlc29sdmVkIiwib25SZXNvbHZlZCIsIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwic3VzcGVuZGVkVk5vZGUiLCJwb3AiLCJ3YXNIeWRyYXRpbmciLCJkZXRhY2hlZENvbXBvbmVudCIsIl9fTyIsImZhbGxiYWNrIiwibGlzdCIsImRlbGV0ZSIsInJldmVhbE9yZGVyIiwic2l6ZSIsImRlbGVnYXRlZCIsImdldCIsInVuc3VzcGVuZCIsIndyYXBwZWRVbnN1c3BlbmQiLCJNYXAiLCJyZXZlcnNlIiwic2V0IiwiX3RoaXMiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJDQU1FTF9QUk9QUyIsIklTX0RPTSIsIm9uQ2hhbmdlSW5wdXRUeXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ2Iiwid3JpdGFibGUiLCJvbGRFdmVudEhvb2siLCJlbXB0eSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJuYXRpdmVFdmVudCIsImNsYXNzTmFtZURlc2NyaXB0b3IiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsIm5vbkN1c3RvbUVsZW1lbnQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwiY2xhc3NOYW1lIiwiZW51bWVyYWJsZSIsIiQkdHlwZW9mIiwiVW5zZXQiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsIkZVTkNfRVJST1JfVEVYVCIsInVzZVN0YXRlUCIsImlkZW50aXR5IiwiZ2V0RG9jdW1lbnQiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiZ2V0Um9vdE5vZGUiLCJlbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImlzSW5wdXQiLCJ0YWdOYW1lIiwiaXNIaWRkZW5JbnB1dCIsImlzRGV0YWlsc1dpdGhTdW1tYXJ5IiwiYXBwbHkiLCJpc05vZGVBdHRhY2hlZCIsIm5vZGVSb290SG9zdCIsImhvc3QiLCJhdHRhY2hlZCIsImNvbnRhaW5zIiwiaXNaZXJvQXJlYSIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsIndpZHRoIiwiaGVpZ2h0IiwiaXNIaWRkZW4iLCJkaXNwbGF5Q2hlY2siLCJnZXRTaGFkb3dSb290IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInZpc2liaWxpdHkiLCJpc0RpcmVjdFN1bW1hcnkiLCJub2RlVW5kZXJEZXRhaWxzIiwicGFyZW50RWxlbWVudCIsIm9yaWdpbmFsTm9kZSIsInJvb3ROb2RlIiwic2hhZG93Um9vdCIsImFzc2lnbmVkU2xvdCIsImdldENsaWVudFJlY3RzIiwiaXNEaXNhYmxlZEZyb21GaWVsZHNldCIsImRpc2FibGVkIiwiaXRlbSIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUiLCJmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciIsImNvbmNhdCIsImpvaW4iLCJpc0ZvY3VzYWJsZSIsIkVycm9yIiwiYXJnc1RhZyIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZnVuY1RhZyIsImgiLCJzaHVmZmxlIiwibG9kYXNoU2h1ZmZsZSIsIl9qc3hzIiwiX2pzeCIsIlJhbmRvbVdvcmRzIl0sIm1hcHBpbmdzIjoiOzs7QUEwQmFBLFFBQUFBLENBQUFBLENDZlBDLEdDUkZDLENBQUFBLEdBQUFBLENDeUtBQyxDQUFBQSxDQVdBQyxJQ3JMT0MsR0NGRUMsQ0FBQUEsR0FBQUEsQ0FBWSxFQUFsQixDQUNNQyxHQUFZLENBQUEsRUFBQSxDQUNaQyxHQUFxQixDQUFBLG9FTE9sQkMsU0FBQUEsR0FBT0MsQ0FBQUEsQ0FBQUEsQ0FBS0MsQ0FFM0Is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LENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBc0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBS0QsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFLLElBQUksRUFBSSxJQUFBLEVBQUEsS0FBSyxJQUFNLENBQUMsRUFBQSxDQUFNLElBQU0sRUFDbk0sWUFBWSxJQUFJLElBQUksSUFBSUEsMkNBQW9CQSxHQUN6QyxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFPRCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsTUFBQSxFQUFBLENBQWEsRUFBQUEsR0FBYSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxNQUFBLEVBQUEsQ0FBQSxFQUFBQSwrQkFBYSxFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGVBQUEsRUFBQSxDQUFzQixJQUFLLEVBQVEsQ0FBQSxFQUNyRkEseUJBQVEsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUlELHVCQUFJQyxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUMsQ0FBQyxJQUFJLEdBQU0sRUFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBQ0EsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxDQUFDLENBQUMsSUFBSSxHQUFNLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLENBQUMsRUFBUyxDQUFBLENBQUEsRUFBQSxDQUMxSSxJQUFNLEVBQ2RBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFNLEVBRUwsdUJBQXVCLElBQUksSUFBSSxJQUFJRCxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEseUJBQUEsRUFBNEJDLHNCQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJQSxzQkFBSyxJQUFJLEVBQUEsQ0FBTSxDQUFDLEVBQU0sQ0FBQSxDQUFBLEVBQUEsQ0FBTSxFQUNoSixxQkFBcUIsSUFBSSxJQUFJLElBQUlELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSwwQkFBQSxFQUE2QkMsc0JBQUsscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSUEsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFBLENBQU0sQ0FBQyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQU0sRUFFNUlBLEdBQU0sQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFBLEVBQ0wsU0FBUyxJQUFJQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFNLFNBQVMsWUFBWSxLQUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFPLENBQUEsQ0FBQSxFQUFBLENBQ25HLEVBQ1Q7SUFDTCxDQUFDLENBQUE7SUFFRCxNQUFNLGdCQUFnQixHQUFHLE1BQUs7SUFDMUIsSUFBQSxNQUFNLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxHQUFHLFlBQVksQ0FBaUIsRUFBRSxJQUFJLEVBQUUsRUFBRSxZQUFZLEVBQUUsc0RBQXNELEVBQUUsRUFBRSxDQUFDLENBQUM7SUFHbEosSUFBQSxRQUNJQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsR0FBUyxjQUFjLENBQUMsS0FBSyxFQUFFLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBQUEsUUFBQSxFQUFBLG1CQUFBLEVBQUEsQ0FFL0MsRUFBQztJQUNmLENBQUMsQ0FBQTtJQUVELE1BQU0sMkJBQTJCLEdBQUcsTUFBSztRQUNyQyxNQUFNLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QyxJQUFBLGlCQUFpQixDQUFDO0lBQ2QsUUFBQSxRQUFRLEVBQUUsQ0FBQyxHQUFHLEtBQUk7Z0JBQ2QsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7SUFDdkIsWUFBQSxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQzthQUMxQztJQUNKLEtBQUEsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsR0FBRyxRQUFRLENBQXFCLElBQUksQ0FBQyxDQUFDO0lBRXpFLElBQUEsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxHQUFHLGNBQWMsQ0FBaUI7WUFDekcscUJBQXFCLEVBQUUsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUU7SUFDNUUsUUFBQSxvQkFBb0IsRUFBRSxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUU7SUFDdkQsS0FBQSxDQUFDLENBQUM7UUFFSCxRQUNJQSxnQkFBUyxjQUFjLENBQUMsV0FBVyxFQUFFLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFBLEVBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBQSxFQUFBLENBQUksRUFBRSxFQUFFLENBQUMsRUFDdkgsUUFBQSxFQUFBQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBQSxDQUFPLEVBQy9DLENBQUEsRUFDUjtJQUNOLENBQUMsQ0FBQTtJQUdELE1BQU0sZ0JBQWdCLEdBQUdsSixDQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBc0IsS0FBSTtRQUU1RCxNQUFNLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUU1QyxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsRUFBRyxFQUFFLFNBQVMsRUFBRSxFQUFFLGFBQWEsRUFBRSxFQUFFLGdCQUFnQixFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsR0FBRyxZQUFZLENBQWlCLEVBQUUsbUJBQW1CLEVBQUUsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEVBQUUsdUJBQXVCLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxvQkFBb0IsRUFBRSxFQUFFLGVBQWUsRUFBRSxTQUFTLEVBQUUsRUFBRSxDQUFDLENBQUM7O0lBR3BSLElBQUEsTUFBTSxRQUFRLEdBQUcsY0FBYyxDQUFDLGFBQWEsRUFBRSxXQUFXLEVBQUUsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7UUFDOUcsSUFBSSxLQUFLLElBQUksQ0FBQztJQUNWLFFBQUEsT0FBT2tKLGNBQU8sQ0FBQztJQUVuQixJQUFBLFFBQ0lELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBSyxTQUFTLEVBQUMsTUFBTSxFQUFBLFFBQUEsRUFBQSxDQUNqQkEsR0FBZSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLFVBQUEsRUFBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFPLElBQUksRUFBQyxVQUFVLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFNLEVBQUEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFBLENBQUksQ0FBUSxFQUFBLENBQUEsRUFDNUlBLEdBQVMsQ0FBQSxLQUFBLEVBQUEsRUFBQSxHQUFBLFFBQVEsRUFDYixRQUFBLEVBQUFBLEdBQUEsQ0FBQyxxQkFBcUIsRUFBQyxFQUFBLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxJQUFJLENBQUMsRUFBQSxDQUFJLEVBQ2hGLENBQUEsQ0FBQSxFQUFBLENBQ0osRUFDUjtJQUNOLENBQUMsQ0FBQyxDQUFDO0lBR0gsTUFBTSxxQkFBcUIsR0FBR2xKLENBQUksQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBNEUsS0FBSTtRQUduSSxRQUNJaUosc0JBQ0lDLEdBQXlCLENBQUEsUUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFBLEVBQ3pCQSx1Q0FBeUIsRUFDekJBLEdBQUEsQ0FBQSxRQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsVUFBQSxFQUFBLENBQXlCLEVBQ3pCRCxHQUFlLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsVUFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQU0sRUFBQSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FBUSxDQUU3SSxFQUFBLENBQUEsRUFDTDtJQUNOLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxvQkFBb0IsR0FBR2xKLENBQUksQ0FBQyxNQUFLO1FBRW5DLE1BQU0sQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDLElBQUEsTUFBTSxDQUFDLFdBQVcsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxxQkFBcUIsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVwRSxNQUFNLFlBQVksSUFBSSxDQUFDLEVBQVEsRUFBRSxFQUErQyxLQUFLLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sY0FBYyxFQUFFLEdBQUcsTUFBTSxFQUFFLEdBQUcsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hNLE1BQU0sRUFDRixTQUFTLEVBQ1QsV0FBVyxFQUNYLFVBQVUsRUFDVixXQUFXLEVBQ1gsT0FBTyxFQUNQLFFBQVEsRUFDUixXQUFXLEVBQ1gsWUFBWSxFQUNmLEdBQUcsZUFBZSxDQUFvRCxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUUzSyxNQUFNLE9BQU8sR0FBRyxPQUFPLEdBQUcsU0FBUyxHQUFHLFdBQVcsQ0FBQztRQUVsRCxRQUNJaUosYUFBSyxTQUFTLEVBQUMsTUFBTSxFQUNqQixRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLFFBQUEsRUFBQSxFQUFRLFFBQVEsRUFBRSxPQUFPLElBQUksa0JBQWtCLEVBQUUsT0FBTyxFQUFFLE9BQU8sMEJBQW9CLEVBQ3JGRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsYUFBQSxFQUFrQkMsZUFBTyxJQUFJLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsRUFBQSxDQUFJLENBQVEsRUFBQSxDQUFBLEVBQzFIRCxHQUFzQixDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGlCQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBSSxDQUFBLENBQUEsRUFBQSxDQUFRLEVBQ3BJRCxHQUE4QixDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLHlCQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUksQ0FBUSxFQUFBLENBQUEsRUFDMUpELHdDQUFpQkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLElBQUksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxHQUFJLENBQVEsRUFBQSxDQUFBLEVBQzNIRCwwQkFDSUMsR0FDSSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQUQsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQyxnQ0FBYyxFQUNkQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLE9BQUEsRUFBQSxDQUFjLElBQ2IsRUFDRCxDQUFBLEVBQ1JELDBCQUNJQSxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBQSxFQUFBLENBQWtCLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBUyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDL0NELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBSUMsc0NBQW9CLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssV0FBVyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDbkRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxjQUFBLEVBQUEsQ0FBcUIsRUFBQUEsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxZQUFZLEdBQU0sQ0FBSyxFQUFBLENBQUEsRUFDckRELHVCQUFJQyxHQUFvQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxhQUFBLEVBQUEsQ0FBQSxFQUFBQSxzQkFBSyxXQUFXLEVBQUEsQ0FBTSxDQUFLLEVBQUEsQ0FBQSxFQUNuREQsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFpQixFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFFBQVEsQ0FBQyxRQUFRLEVBQUUsR0FBTSxDQUFLLEVBQUEsQ0FBQSxFQUN4REQsdUJBQUlDLEdBQW1CLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFlBQUEsRUFBQSxDQUFBLEVBQUFBLHNCQUFLLFVBQVUsQ0FBQyxRQUFRLEVBQUUsRUFBQSxDQUFNLElBQUssQ0FDeEQsRUFBQSxDQUFBLENBQUEsRUFBQSxDQUNKLENBQ04sRUFBQSxDQUFBLEVBQ1I7SUFDTixDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sb0JBQW9CLEdBQUdsSixDQUFJLENBQUMsTUFBSztRQUVuQyxNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxJQUFBLE1BQU0sQ0FBQyxXQUFXLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0RSxNQUFNLENBQUMsa0JBQWtCLEVBQUUscUJBQXFCLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFcEUsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFckMsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFTLEVBQUUsRUFBTyxLQUFLLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQUs7WUFDN0csSUFBSSxjQUFjLEVBQUUsRUFBRTtJQUNsQixZQUFBLE1BQU0sRUFBRSxDQUFDO0lBQ1osU0FBQTtJQUNJLGFBQUE7Z0JBQ0QsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1gsWUFBQSxPQUFPLEVBQUUsQ0FBQztJQUNiLFNBQUE7SUFDTCxLQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUViLElBQUEsTUFBTSxFQUNGLFNBQVMsRUFDVCxXQUFXLEVBQ1gsVUFBVSxFQUNWLFdBQVcsRUFDWCxjQUFjLEVBQ2QsT0FBTyxFQUNQLFFBQVEsRUFDUixXQUFXLEVBQ1gsWUFBWSxFQUNmLEdBQUcsZUFBZSxDQUFnRCxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBd0MsS0FBSSxFQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUEsRUFBRSxFQUFFLFFBQVEsRUFBRSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBR2hRLFFBQ0lpSixhQUFLLFNBQVMsRUFBQyxNQUFNLEVBQ2pCLFFBQUEsRUFBQSxDQUFBQSxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsYUFBQSxFQUFrQkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLEtBQUssRUFBRSxVQUFVLEdBQUcsY0FBYyxHQUFHLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxJQUFJLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FBUSxFQUM3SUEsR0FBTSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQUEsRUFDTkQsR0FBa0IsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxhQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUMxSEQsR0FBc0IsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxpQkFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUEsQ0FBSSxJQUFRLEVBQ3BJRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEseUJBQUEsRUFBOEJDLEdBQU8sQ0FBQSxPQUFBLEVBQUEsRUFBQSxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUEsQ0FBSSxJQUFRLEVBQzFKRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsWUFBQSxFQUFpQkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLElBQUksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxFQUFBLENBQUksSUFBUSxFQUMzSEQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQyxHQUNJLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQ0lDLEdBQWMsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsT0FBQSxFQUFBLENBQUEsRUFDZEEsZ0NBQWMsQ0FDYixFQUFBLENBQUEsRUFBQSxDQUNELEVBQ1JELEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FDSUEsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFdBQUEsRUFBQSxDQUFrQixFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFNBQVMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLEVBQy9DRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUlDLHNDQUFvQixFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLFdBQVcsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLEVBQ25ERCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsY0FBQSxFQUFBLENBQXFCLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssWUFBWSxFQUFBLENBQU0sSUFBSyxFQUNyREQsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFJQyxHQUFvQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxhQUFBLEVBQUEsQ0FBQSxFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFdBQVcsR0FBTSxDQUFLLEVBQUEsQ0FBQSxFQUNuREQsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFpQixFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBQSxDQUFNLENBQUssRUFBQSxDQUFBLEVBQ3hERCx1QkFBSUMsR0FBdUIsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsZ0JBQUEsRUFBQSxDQUFBLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsY0FBYyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDekRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxpQkFBQSxFQUFBLENBQXNCLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssSUFBSSxFQUFBLENBQU0sSUFBSyxDQUMxQyxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQ0osQ0FDTixFQUFBLENBQUEsRUFDUjtJQUNOLENBQUMsQ0FBQyxDQUFDO0lBRUgsU0FBUyxXQUFXLEdBQUE7UUFDaEIsT0FBTyxNQUFNLENBQUMsUUFBUSxDQUFDO0lBQzNCLENBQUM7SUFFRCxNQUFNLFNBQVMsR0FBR2xKLENBQUksQ0FBQyxNQUFLO1FBQ3hCLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxvQkFBb0IsQ0FBQyxHQUFHLFFBQVEsQ0FBbUIsSUFBSSxDQUFDLENBQUM7UUFDbkYsTUFBTSxDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLFFBQVEsQ0FBbUIsSUFBSSxDQUFDLENBQUM7UUFDM0UsTUFBTSxDQUFDLGFBQWEsRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUMxRCxNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUM5QyxNQUFNLENBQUMsWUFBWSxFQUFFLGVBQWUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN4RCxNQUFNLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0RCxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsbUJBQW1CLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEUsSUFBQSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxhQUFhLENBQWlCLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSxlQUFlLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3JILElBQUEsTUFBTSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQztRQUM3QyxNQUFNLEVBQ0YscUJBQXFCLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQzdDLEdBQUcsa0JBQWtCLENBQWlCO1lBQ25DLGdCQUFnQjtJQUNoQixRQUFBLHlCQUF5QixFQUFFO0lBQ3ZCLFlBQUEsdUJBQXVCLEVBQUUsVUFBVTtJQUNuQyxZQUFBLDRCQUE0QixFQUFFLGVBQWU7SUFDaEQsU0FBQTtJQUNKLEtBQUEsQ0FBQyxDQUFDO1FBS0MsZUFBZSxDQUFpQjtZQUNoQyxnQkFBZ0I7SUFDaEIsUUFBQSx1QkFBdUIsRUFBRTtnQkFDckIsV0FBVztJQUNYLFlBQUEscUJBQXFCLEVBQUUsZ0JBQWdCO0lBQ3ZDLFlBQUEseUJBQXlCLEVBQUUsb0JBQW9CO0lBQy9DLFlBQUEscUJBQXFCLEVBQUUsZ0JBQWdCO0lBQzFDLFNBQUE7SUFDRCxRQUFBLHNCQUFzQixFQUFFO0lBQ3BCLFlBQUEsb0JBQW9CLEVBQUUsY0FBYztJQUNwQyxZQUFBLHlCQUF5QixFQUFFLG1CQUFtQjtJQUNqRCxTQUFBO0lBQ0osS0FBQSxFQUFFO1FBQ0gsUUFDSWlKLGFBQUssS0FBSyxFQUFDLE1BQU0sRUFDYixRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxhQUFBLEVBQUEsQ0FBb0IsRUFDcEJELEdBQVMsQ0FBQSxLQUFBLEVBQUEsRUFBQSxJQUFDLGNBQWMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsdUJBQVFDLEdBQUssQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFRLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxFQUFBLFFBQUEsRUFBQSxlQUFBLEVBQUEsQ0FBcUIsQ0FBTSxFQUFBLENBQUEsRUFDakxBLHVCQUNJRCxHQUNJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxvQkFBQSxFQUF1QixPQUFPLENBQUMsUUFBUSxFQUFFLEVBQUksSUFBQSxFQUFBLFdBQVcsQ0FBQyxRQUFRLEVBQUUsSUFBTSxFQUN6RUEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGlCQUFBLEVBQW9CLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBSSxJQUFBLEVBQUEsZ0JBQWdCLENBQUMsUUFBUSxFQUFFLENBQUEsRUFBQSxDQUFNLEVBQ2hGQSxHQUFxQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGtCQUFBLEVBQUEsYUFBYSxDQUFDLFFBQVEsRUFBRSxJQUFNLEVBQ25EQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsaUJBQUEsRUFBb0IsYUFBYSxFQUFFLFdBQVcsSUFBTSxFQUNwREEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLHFCQUFBLEVBQXdCLGlCQUFpQixFQUFFLFdBQVcsSUFBTSxDQUMzRCxFQUFBLENBQUEsRUFBQSxDQUNILENBQ0osRUFBQSxDQUFBLEVBQ1Q7SUFDTCxDQUFDLENBQUMsQ0FBQTtJQUdGLE1BQU0sY0FBYyxHQUFHbFAsR0FBYSxDQUEwRixJQUFLLENBQUMsQ0FBQztJQUNySSxNQUFNLGVBQWUsR0FBR0EsR0FBYSxDQUEwRCxJQUFLLENBQUMsQ0FBQztBQUN6RixVQUFBLFdBQVcsR0FBR2lHLENBQUksQ0FBQyxNQUFLOzs7SUFJakMsSUFBQSxNQUFNLEVBQ0Ysb0JBQW9CLEVBQUUsRUFBRSxhQUFhLEVBQUUsRUFDdkMsc0JBQXNCLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQzNDLG9CQUFvQixFQUFFLEVBQUcsRUFDekIscUJBQXFCLEVBQUUsRUFBRyxFQUMxQixvQkFBb0IsRUFBRSxFQUFHLEVBQ3pCLHlCQUF5QixFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxFQUM5QyxvQkFBb0IsRUFDdkIsR0FBRyxpQkFBaUIsQ0FBNkY7SUFDOUcsUUFBQSx3QkFBd0IsRUFBRSxFQUFFO0lBQzVCLFFBQUEsMEJBQTBCLEVBQUUsRUFBRTtJQUM5QixRQUFBLHdCQUF3QixFQUFFLEVBQUU7SUFDNUIsUUFBQSw2QkFBNkIsRUFBRSxFQUFFO0lBQ2pDLFFBQUEseUJBQXlCLEVBQUUsRUFBRTtJQUM3QixRQUFBLHdCQUF3QixFQUFFLEVBQUU7SUFDL0IsS0FBQSxDQUFDLENBQUM7UUFFSCxRQUNJaUosR0FBSyxDQUFBLEtBQUEsRUFBQSxFQUFBLEtBQUssRUFBQyxNQUFNLEVBQ1osUUFBQSxFQUFBLENBQUFBLEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxrQkFBQSxFQUFzQixhQUFhLENBQUEsRUFBQSxDQUFPLEVBQzNDQSxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsR0FBVyxFQUFFLE1BQU0sRUFBRSxHQUFHLEVBQVEsRUFBRSxLQUFLLEVBQUUsRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLEVBQUEsUUFBQSxFQUFBLENBRTdEQyxHQUNJLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQ0lDLEdBQXlCLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGtCQUFBLEVBQUEsQ0FBQSxFQUN6QkEsbUNBQWlCLEVBQ2pCQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFpQixDQUNoQixFQUFBLENBQUEsRUFBQSxDQUNELEVBQ1JBLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFXLGNBQWMsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQzdCLFFBQUEsRUFBQUEsR0FBQSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUEsRUFBQyxLQUFLLEVBQUUsb0JBQW9CLEVBQUEsUUFBQSxFQUMvQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBUztvQ0FDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTt3Q0FDekIsTUFBTUEsR0FBQSxDQUFDLGNBQWMsRUFBQyxFQUFBLEtBQUssRUFBRSxDQUFDLEVBQUEsRUFBTyxDQUFDLENBQUksQ0FBQTtJQUM3QyxpQ0FBQTtpQ0FDSixHQUFHLENBQUMsRUFBQSxDQUNpQixHQUN0QixDQUNKLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FDTixFQUNSO0lBQ04sQ0FBQyxFQUFDO0lBR0YsTUFBTSxjQUFjLEdBQUdsSixDQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBcUIsS0FBSTtJQUMxRCxJQUFzQixRQUFRLENBQUMsTUFBTSxXQUFXLENBQUMsS0FBSywwREFBeUQsRUFBRTtJQUNqSCxJQUFBLE1BQU0sVUFBVSxHQUFHeEIsQ0FBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzlDLElBQUEsTUFBTSxFQUFFLGdCQUFnQixFQUFFLEdBQUcsYUFBYSxDQUFzQixFQUFFLG9CQUFvQixFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUE7SUFDN0YsSUFBQSxNQUFNLEVBQUUsV0FBVyxFQUFFLEVBQUUsRUFBRSxHQUFHLGdCQUFnQixDQUFDO1FBQzdDLE1BQU0sRUFDRixxQkFBcUIsRUFDckIsZUFBZSxFQUFFLEVBQ2Isc0JBQXNCLEVBQUUsRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLEVBQzNDLG9CQUFvQixFQUFFLEVBQUcsRUFDekIscUJBQXFCLEVBQUUsRUFBRyxFQUMxQixvQkFBb0IsRUFBRSxFQUFHLEVBQ3pCLHlCQUF5QixFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsR0FBRyxFQUVsRCxFQUNELFVBQVUsRUFBRSxFQUFFLHlCQUF5QixFQUFFLHlCQUF5QixFQUFFLEVBQUUsUUFBUSxFQUFFLGFBQWEsRUFBRSxFQUFFLEVBQUUsRUFBRSxHQUN4RyxHQUFHLFVBQVUsQ0FBQztJQUNYLFFBQUEsbUJBQW1CLEVBQUU7Z0JBQ2pCLGdCQUFnQjtJQUNoQixZQUFBLHNCQUFzQixFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUU7SUFDNUMsWUFBQSw2QkFBNkIsRUFBRSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUU7Z0JBQzNDLDZCQUE2QixFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFO0lBQzlFLFlBQUEsT0FBTyxFQUFFLEVBQUU7SUFDZCxTQUFBO0lBQ0QsUUFBQSxrQkFBa0IsRUFBRTtJQUNoQixZQUFBLDBCQUEwQixFQUFFLEVBQUU7SUFDOUIsWUFBQSx3QkFBd0IsRUFBRSxFQUFFO0lBQzVCLFlBQUEsd0JBQXdCLEVBQUUsRUFBRTtJQUM1QixZQUFBLDZCQUE2QixFQUFFLEVBQUU7SUFDakMsWUFBQSx5QkFBeUIsRUFBRSxFQUFFO0lBQ2hDLFNBQUE7SUFDSixLQUFBLENBQUMsQ0FBQztJQUNILElBRUksa0JBQWtCLENBQXNCO1lBQ3hDLGdCQUFnQjtJQUNoQixRQUFBLHlCQUF5QixFQUFFO0lBQ3ZCLFlBQUEsdUJBQXVCLEVBQUUsSUFBSTtJQUM3QixZQUFBLEdBQUcseUJBQXlCO0lBQy9CLFNBQUE7SUFDSixLQUFBLEVBQUU7SUFFSCxJQUFBLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQyxjQUFjLENBQUMsY0FBYyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUM3RSxJQUFBLFFBQ0kwSyxHQUFRLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBQSxLQUFLLFlBQ1RBLEdBQUMsQ0FBQSxlQUFlLENBQUMsUUFBUSxFQUFBLEVBQUMsS0FBSyxFQUFFLHFCQUFxQixZQUNqRCxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBUztvQkFDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRTtJQUN4QixvQkFBQSxNQUFNQSxJQUFDLGVBQWUsRUFBQSxFQUFDLEtBQUssRUFBRSxDQUFDLEVBQVUsR0FBRyxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsUUFBUSxFQUF0QyxFQUFBLENBQUMsQ0FBeUMsQ0FBQTtJQUNuRixpQkFBQTtJQUNMLGFBQUMsR0FBRyxDQUFDLEVBQ2tCLENBQUEsRUFBQSxDQUMxQixFQUNSO0lBQ0wsQ0FBQyxFQUFFLENBQUM7SUFFSixNQUFNLGVBQWUsSUFBSSxDQUFDLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQTBELEtBQUk7SUFDL0csSUFBQSxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHLENBQUM7SUFDckMsUUFBQSxPQUFPLElBQUksQ0FBQztJQUVoQixJQUFBLElBQUksVUFBVSxHQUFHLENBQUMsR0FBRyxLQUFLLENBQUMsSUFBSSxlQUFlLEdBQUcsRUFBRSxDQUFBO0lBRW5ELElBQUEsTUFBTSxXQUFXLEdBQUcxSyxDQUFVLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDaEQsSUFBQSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxhQUFhLENBQXVCLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMvRixJQUFBLE1BQU0sRUFBRSxXQUFXLEVBQUUsRUFBRSxFQUFFLEdBQUcsZ0JBQWdCLENBQUM7UUFDN0MsTUFBTSxFQUNGLHlCQUF5QixFQUN6QixvQkFBb0IsRUFBRSxFQUFHLEVBQ3pCLHlCQUF5QixFQUFFLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsRUFBRSxFQUFFLEdBQzdFLEdBQUcsV0FBVyxDQUFDOzs7SUFHWixRQUFBLDZCQUE2QixFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTs7WUFFM0MsZ0JBQWdCO1lBQ2hCLDZCQUE2QixFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDcEcsUUFBQSxzQkFBc0IsRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxFQUFFO0lBQzVDLFFBQUEsT0FBTyxFQUFFLEVBQUU7SUFDZCxLQUFBLENBQUMsQ0FBQztRQUNILE1BQU0sRUFDRixxQkFBcUIsRUFBRSxFQUFFLFdBQVcsRUFBRSxFQUFFLEVBQUUsRUFDN0MsR0FBRyxrQkFBa0IsQ0FBdUI7WUFDekMsZ0JBQWdCO1lBQ2hCLHlCQUF5QixFQUFFLEVBQUUsdUJBQXVCLEVBQUUsSUFBSSxFQUFFLEdBQUcseUJBQXlCLEVBQUU7SUFDN0YsS0FBQSxDQUFDLENBQUE7UUFFRixNQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsRUFBRSxFQUFFLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUV6QyxJQUFBLE1BQU0sQ0FBQyxJQUFJLGNBQWMsR0FBRyxZQUFZLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQTtRQUU1RCxJQUFJLEtBQUssS0FBSyxDQUFDO1lBQ1gsT0FBTzBLLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxHQUFRLEtBQUssRUFBRyxRQUFBLEVBQUEsYUFBYSxDQUFDLFFBQVEsRUFBRSxHQUFNLENBQUE7SUFDcEQsU0FBQTtZQUNELElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDekIsSUFBSSxLQUFLLEtBQUssQ0FBQztvQkFDWCxPQUFPRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBUSxLQUFLLEVBQUEsUUFBQSxFQUFBLENBQUEsYUFBQSxFQUFjLEtBQUssR0FBRyxDQUFDLEVBQUEsR0FBQSxFQUFHLENBQUMsRUFBRSxVQUFVLENBQUEsRUFBQSxDQUFNLENBQUE7O0lBRWpFLGdCQUFBLE9BQU9DLEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUFELEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBT0MsR0FBYSxDQUFBLE9BQUEsRUFBQSxFQUFBLEdBQUEsS0FBYSxFQUFFLElBQUksRUFBQyxVQUFVLEVBQUEsQ0FBRyxrQkFBYSxDQUFDLEVBQUUsVUFBVSxDQUFBLEVBQUEsQ0FBUyxHQUFLLENBQUE7SUFDL0csU0FBQTtJQUNJLGFBQUE7Z0JBQ0QsSUFBSSxLQUFLLEtBQUssQ0FBQztJQUNYLGdCQUFBLE9BQU9ELEdBQVEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxHQUFBLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFBQSxDQUFBLGFBQUEsRUFBYyxLQUFLLEdBQUcsQ0FBQyxFQUFXLFdBQUEsRUFBQSxDQUFDLEVBQUUsVUFBVSxJQUFNLENBQUE7O0lBRXJGLGdCQUFBLE9BQU8sSUFBSSxDQUFDO0lBRW5CLFNBQUE7SUFDSixLQUFBO0lBQ0wsQ0FBQyxDQUFDLENBQUE7SUFFRixNQUFNLFNBQVMsR0FBRyxNQUFLO0lBQ25CLElBQUEsT0FBT0EsYUFBSyxLQUFLLEVBQUMsTUFBTSxFQUFDLEtBQUssRUFBRSxFQUFFLFFBQVEsRUFBRSxNQUFNLEVBQUUsRUFBQSxRQUFBLEVBQUEsQ0FDaERDLElBQUMsU0FBUyxFQUFBLEVBQUEsQ0FBRyxFQUNiQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNOQSxHQUFDLENBQUEsV0FBVyxLQUFHLEVBQ2ZBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFNLEVBQ05BLEdBQUEsQ0FBQyxjQUFjLEVBQUcsRUFBQSxDQUFBLEVBQ2xCQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNOQSxJQUFDLGVBQWUsRUFBQSxFQUFBLENBQUcsRUFDbkJBLEdBQU0sQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFBLEVBQ05BLElBQUMscUJBQXFCLEVBQUEsRUFBQSxDQUFHLEVBQ3pCQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBTSxFQUdOQSxHQUFDLENBQUEsZ0JBQWdCLEVBQUcsRUFBQSxDQUFBLEVBQ3BCQSxhQUFNLEVBQ05BLEdBQUEsQ0FBQyxvQkFBb0IsRUFBQSxFQUFBLENBQUcsRUFDeEJBLEdBQU0sQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFBLEVBQ05BLElBQUMsb0JBQW9CLEVBQUEsRUFBQSxDQUFHLEVBQ3hCQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNOQSxHQUFDLENBQUEsZ0JBQWdCLEtBQUcsRUFDcEJBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFNLEVBQ05BLEdBQUMsQ0FBQSxnQkFBZ0IsS0FBRyxFQUNwQkEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQU0sRUFDTkEsR0FBQSxDQUFDLDJCQUEyQixFQUFHLEVBQUEsQ0FBQSxFQUMvQkEsYUFBTSxFQUNOQSxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsQ0FBUyxJQUNQLENBQUE7SUFDVixDQUFDLENBQUE7SUFFRCxxQkFBcUIsQ0FBQyxNQUFLO0lBQ3ZCLElBQUE5UixDQUFNLENBQUM4UixHQUFBLENBQUMsU0FBUyxFQUFBLEVBQUEsQ0FBRyxFQUFFLFFBQVEsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFFLENBQUMsQ0FBQztJQUM1RCxDQUFDLENBQUM7Ozs7Ozs7Ozs7OzsifQ==
