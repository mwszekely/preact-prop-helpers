var bundle = (function (exports) {
    'use strict';

    var n,l$1,u$1,t$1,o$2,r$2,f$1={},e$2=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$1(n,l){for(var u in l)n[u]=l[u];return n}function a$1(n){var l=n.parentNode;l&&l.removeChild(n);}function h$1(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return v$1(l,f,t,o,null)}function v$1(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u$1:r};return null==r&&null!=l$1.vnode&&l$1.vnode(f),f}function p$1(n){return n.children}function d$1(n,l){this.props=n,this.context=l;}function _$1(n,l){if(null==l)return n.__?_$1(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?_$1(n):null}function k$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k$1(n)}}function b$1(n){(!n.__d&&(n.__d=!0)&&t$1.push(n)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2);}function g$2(){for(var n;g$2.__r=t$1.length;)n=t$1.sort(function(n,l){return n.__v.__b-l.__v.__b}),t$1=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=s$1({},t)).__v=t.__v+1,j$2(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?_$1(t):o,t.__h),z$1(u,t),t.__e!=o&&k$1(t)));});}function w$2(n,l,u,i,t,o,r,c,s,a){var h,y,d,k,b,g,w,x=i&&i.__k||e$2,C=x.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v$1(null,k,null,null,k):Array.isArray(k)?v$1(p$1,{children:k},null,null,null):k.__b>0?v$1(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=x[h])||d&&k.key==d.key&&k.type===d.type)x[h]=void 0;else for(y=0;y<C;y++){if((d=x[y])&&k.key==d.key&&k.type===d.type){x[y]=void 0;break}d=null;}j$2(n,k,d=d||f$1,t,o,r,c,s,a),b=k.__e,(y=k.ref)&&d.ref!=y&&(w||(w=[]),d.ref&&w.push(d.ref,null,k),w.push(y,k.__c||b,k)),null!=b?(null==g&&(g=b),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=m$1(k,s,n):s=A$1(n,k,d,x,b,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_$1(d));}for(u.__e=g,h=C;h--;)null!=x[h]&&("function"==typeof u.type&&null!=x[h].__e&&x[h].__e==u.__d&&(u.__d=_$1(i,h+1)),N(x[h],x[h]));if(w)for(h=0;h<w.length;h++)M$1(w[h],w[++h],w[++h]);}function m$1(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l="function"==typeof i.type?m$1(i,l,u):A$1(u,i,i,t,i.__e,l));return l}function x(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){x(n,l);}):l.push(n)),l}function A$1(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function C$1(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H$1(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H$1(n,o,l[o],u[o],i);}function $$1(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c$1.test(l)?u:u+"px";}function H$1(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$$1(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$$1(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T$2:I,o):n.removeEventListener(l,o?T$2:I,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l));}}function I(n){this.l[n.type+!1](l$1.event?l$1.event(n):n);}function T$2(n){this.l[n.type+!0](l$1.event?l$1.event(n):n);}function j$2(n,u,i,t,o,r,f,e,c){var a,h,v,y,_,k,b,g,m,x,A,C,$,H=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=l$1.__b)&&a(u);try{n:if("function"==typeof H){if(g=u.props,m=(a=H.contextType)&&t[a.__c],x=a?m?m.props.value:a.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in H&&H.prototype.render?u.__c=h=new H(g,x):(u.__c=h=new d$1(g,x),h.constructor=H,h.render=O$1),m&&m.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=H.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s$1({},h.__s)),s$1(h.__s,H.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state,v)null==H.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==H.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,k);});}if(h.context=x,h.props=g,h.__v=u,h.__P=n,A=l$1.__r,C=0,"prototype"in H&&H.prototype.render)h.state=h.__s,h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context);else do{h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++C<25);h.state=h.__s,null!=h.getChildContext&&(t=s$1(s$1({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,_)),$=null!=a&&a.type===p$1&&null==a.key?a.props.children:a,w$2(n,Array.isArray($)?$:[$],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L$1(i.__e,u,i,t,o,r,f,c);(a=l$1.diffed)&&a(u);}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l$1.__e(n,u,i);}}function z$1(n,u){l$1.__c&&l$1.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$1.__e(n,u.__v);}});}function L$1(l,u,i,t,o,r,e,c){var s,h,v,y=i.props,p=u.props,d=u.type,k=0;if("svg"===d&&(o=!0),null!=r)for(;k<r.length;k++)if((s=r[k])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[k]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(r=r&&n.call(l.childNodes),h=(y=i.props||f$1).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},k=0;k<l.attributes.length;k++)y[l.attributes[k].name]=l.attributes[k].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C$1(l,p,y,o,c),v)u.__k=[];else if(k=u.props.children,w$2(l,Array.isArray(k)?k:[k],u,i,t,o&&"foreignObject"!==d,r,e,r?r[0]:i.__k&&_$1(i,0),c),null!=r)for(k=r.length;k--;)null!=r[k]&&a$1(r[k]);c||("value"in p&&void 0!==(k=p.value)&&(k!==l.value||"progress"===d&&!k||"option"===d&&k!==y.value)&&H$1(l,"value",k,y.value,!1),"checked"in p&&void 0!==(k=p.checked)&&k!==l.checked&&H$1(l,"checked",k,y.checked,!1));}return l}function M$1(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$1.__e(n,i);}}function N(n,u,i){var t,o;if(l$1.unmount&&l$1.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M$1(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$1.__e(n,u);}t.base=t.__P=null;}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,"function"!=typeof n.type);i||null==n.__e||a$1(n.__e),n.__e=n.__d=void 0;}function O$1(n,l,u){return this.constructor(n,u)}function P$1(u,i,t){var o,r,e;l$1.__&&l$1.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,e=[],j$2(i,u=(!o&&t||i).__k=h$1(p$1,null,[u]),r||f$1,f$1,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,e,!o&&t?t:r?r.__e:i.firstChild,o),z$1(e,u);}function B(n,l){var u={__c:l="__cC"+r$2++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(b$1);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=e$2.slice,l$1={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l;}throw n}},u$1=0,d$1.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s$1({},this.state),"function"==typeof n&&(n=n(s$1({},u),this.props)),n&&s$1(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),b$1(this));},d$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),b$1(this));},d$1.prototype.render=p$1,t$1=[],g$2.__r=0,r$2=0;

    var o$1=0;function e$1(_,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:_,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--o$1,__source:f,__self:t};if("function"==typeof _&&(l=_.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return l$1.vnode&&l$1.vnode(a),a}

    var t,u,r$1,o,i=0,c=[],f=[],e=l$1.__b,a=l$1.__r,v=l$1.diffed,l=l$1.__c,m=l$1.unmount;function p(t,r){l$1.__h&&l$1.__h(u,t,i||r),i=0;var o=u.__H||(u.__H={__:[],__h:[]});return t>=o.__.length&&o.__.push({__V:f}),o.__[t]}function y(n){return i=1,d(z,n)}function d(n,r,o){var i=p(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):z(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}));}],i.__c=u),i.__}function _(r,o){var i=p(t++,3);!l$1.__s&&w$1(i.__H,o)&&(i.__=r,i.u=o,u.__H.__h.push(i));}function h(r,o){var i=p(t++,4);!l$1.__s&&w$1(i.__H,o)&&(i.__=r,i.u=o,u.__h.push(i));}function s(n){return i=5,F$1(function(){return {current:n}},[])}function F$1(n,u){var r=p(t++,7);return w$1(r.__H,u)?(r.__V=n(),r.u=u,r.__h=n,r.__V):r.__}function T$1(n,t){return i=8,F$1(function(){return n},t)}function q$1(n){var r=u.context[n.__c],o=p(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function b(){for(var t;t=c.shift();)if(t.__P)try{t.__H.__h.forEach(j$1),t.__H.__h.forEach(k),t.__H.__h=[];}catch(u){t.__H.__h=[],l$1.__e(u,t.__v);}}l$1.__b=function(n){u=null,e&&e(n);},l$1.__r=function(n){a&&a(n),t=0;var o=(u=n.__c).__H;o&&(r$1===u?(o.__h=[],u.__h=[],o.__.forEach(function(n){n.__V=f,n.u=void 0;})):(o.__h.forEach(j$1),o.__h.forEach(k),o.__h=[])),r$1=u;},l$1.diffed=function(t){v&&v(t);var i=t.__c;i&&i.__H&&(i.__H.__h.length&&(1!==c.push(i)&&o===l$1.requestAnimationFrame||((o=l$1.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),g$1&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);g$1&&(t=requestAnimationFrame(u));})(b)),i.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.__V!==f&&(n.__=n.__V),n.u=void 0,n.__V=f;})),r$1=u=null;},l$1.__c=function(t,u){u.some(function(t){try{t.__h.forEach(j$1),t.__h=t.__h.filter(function(n){return !n.__||k(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],l$1.__e(r,t.__v);}}),l&&l(t,u);},l$1.unmount=function(t){m&&m(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{j$1(n);}catch(n){u=n;}}),u&&l$1.__e(u,r.__v));};var g$1="function"==typeof requestAnimationFrame;function j$1(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function k(n){var t=u;n.__c=n.__(),u=t;}function w$1(n,t){return !n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function z(n,t){return "function"==typeof t?t(n):t}

    function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return !r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,h$1(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new d$1).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w=l$1.__b;l$1.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w&&w(n);};var A=l$1.__e;l$1.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);A(n,t,e,r);};var O=l$1.unmount;function T(){this.__u=0,this.t=null,this.__b=null;}function L(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function D(){this.u=null,this.o=null;}l$1.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n);},(T.prototype=new d$1).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=L(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate();}},f=!0===t.__h;r.__u++||f||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i);},T.prototype.componentWillUnmount=function(){this.t=[];},T.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__a&&h$1(p$1,null,n.fallback);return u&&(u.__h=null),[h$1(p$1,null,t.__a?null:n.children),u]};var F=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};(D.prototype=new d$1).__a=function(n){var t=this,e=L(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),F(t,n,r)):u();};e?e(o):o();}},D.prototype.render=function(n){this.u=null,this.o=new Map;var t=x(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},D.prototype.componentDidUpdate=D.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){F(n,e,t);});};var W="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|shape|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,$="undefined"!=typeof document,j=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(d$1.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var H=l$1.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}l$1.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var J={configurable:!0,get:function(){return this.class}},K=l$1.vnode;l$1.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];$&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!j(e.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),/^oninput$/i.test(o)&&(o=o.toLowerCase(),r[o]&&(o="oninputCapture")),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=x(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=x(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r,e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J));}n.$$typeof=W,K&&K(n);};var Q=l$1.__r;l$1.__r=function(n){Q&&Q(n),n.__c;};

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */
    function useEnsureStability(parentHookName, ...values) {
        useHelper(values.length, 0);
        values.forEach(useHelper);
        return;
        function useHelper(value, index) {
            // Make sure that the provided functions are perfectly stable across renders
            const helperToEnsureStability = s(value);
            const shownError = s(false);
            if (helperToEnsureStability.current != value) {
                if (!shownError.current) {
                    /* eslint-disable no-debugger */
                    debugger;
                    console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
                    shownError.current = true;
                }
            }
        }
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */
    function usePassiveState(onChange, getInitialValue) {
        const valueRef = s(Unset$1);
        const warningRef = s(false);
        const cleanupCallbackRef = s(undefined);
        // Make sure that the provided functions are perfectly stable across renders
        useEnsureStability("usePassiveState", onChange, getInitialValue);
        // Shared between "dependency changed" and "component unmounted".
        const onShouldCleanUp = T$1(() => {
            const cleanupCallback = cleanupCallbackRef.current;
            if (cleanupCallback)
                cleanupCallback();
        }, []);
        // There are a couple places where we'd like to use our initial
        // value in place of having no value at all yet.
        // This is the shared code for that, used on mount and whenever
        // getValue is called.
        const tryEnsureValue = T$1(() => {
            if (valueRef.current === Unset$1 && getInitialValue != undefined) {
                try {
                    const initialValue = getInitialValue();
                    valueRef.current = initialValue;
                    cleanupCallbackRef.current = (onChange?.(initialValue, undefined) ?? undefined);
                }
                catch (ex) {
                    // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
                }
            }
        }, [ /* getInitialValue and onChange intentionally omitted */]);
        const getValue = T$1(() => {
            if (warningRef.current)
                console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
            // The first time we call getValue, if we haven't been given a value yet,
            // (and we were given an initial value to use)
            // return the initial value instead of nothing.
            if (valueRef.current === Unset$1)
                tryEnsureValue();
            return (valueRef.current === Unset$1 ? undefined : valueRef.current);
        }, []);
        h(() => {
            // Make sure we've run our effect at least once on mount.
            // (If we have an initial value, of course)
            tryEnsureValue();
        }, []);
        // The actual code the user calls to (possibly) run a new effect.
        const r = s({ microtaskQueued: false, arg: undefined, prevDep: undefined, handle: null });
        const setValue = T$1((arg) => {
            r.current.prevDep = valueRef.current === Unset$1 ? undefined : getValue();
            r.current.arg = arg;
            if (!r.current.microtaskQueued) {
                r.current.microtaskQueued = true;
                r.current.handle = setTimeout(() => {
                    r.current.microtaskQueued = false;
                    r.current.handle = null;
                    const prevDep = r.current.prevDep;
                    const arg = r.current.arg;
                    const dep = arg instanceof Function ? arg(prevDep) : arg;
                    if (dep !== valueRef.current) {
                        // Indicate to the user that they shouldn't call getValue during onChange
                        warningRef.current = true;
                        try {
                            // Call any registered cleanup function
                            onShouldCleanUp();
                            cleanupCallbackRef.current = (onChange?.(dep, prevDep) ?? undefined);
                            valueRef.current = dep;
                        }
                        finally {
                            // Allow the user to normally call getValue again
                            warningRef.current = false;
                        }
                    }
                }, 0);
            }
        }, []);
        return [getValue, setValue];
    }
    const Unset$1 = Symbol();
    // Easy constants for getInitialValue
    function returnTrue() { return true; }
    function returnFalse() { return false; }
    function returnNull() { return null; }
    function returnZero() { return 0; }

    function useMergedChildren({ children: lhs }, { children: rhs }) {
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return h$1(p$1, {}, lhs, rhs);
        }
    }

    function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */
    function useMergedClasses({ class: lhsClass, className: lhsClassName }, { class: rhsClass, className: rhsClassName }) {
        // Note: For the sake of forward compatibility, this function is labelled as
        // a hook, but as it uses no other hooks it technically isn't one.
        if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
            const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
            const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
            const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
            return Array.from(allClasses).join(" ");
        }
        else {
            return undefined;
        }
    }

    function processRef(instance, ref) {
        if (typeof ref === "function") {
            ref(instance);
        }
        else if (ref != null) {
            ref.current = instance;
        }
        else {
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
        }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */
    function useMergedRefs({ ref: rhs }, { ref: lhs }) {
        const combined = T$1((current) => {
            processRef(current, lhs);
            processRef(current, rhs);
        }, [lhs, rhs]);
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return combined;
        }
    }

    function styleStringToObject(style) {
        // TODO: This sucks D:
        return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
        // Easy case, when there are no styles to merge return nothing.
        if (!lhs?.style && !rhs?.style)
            return undefined;
        if (typeof lhs != typeof rhs) {
            // Easy cases, when one is null and the other isn't.
            if (lhs?.style && !rhs?.style)
                return lhs.style;
            if (!lhs?.style && rhs?.style)
                return rhs.style;
            // They're both non-null but different types.
            // Convert the string type to an object bag type and run it again.
            if (lhs?.style && rhs?.style) {
                // (useMergedStyles isn't a true hook -- this isn't a violation)
                if (typeof lhs?.style == "string")
                    return useMergedStyles({ style: styleStringToObject(lhs?.style) }, rhs);
                if (typeof rhs?.style == "string")
                    return useMergedStyles(lhs, { style: styleStringToObject(rhs?.style) });
            }
            // Logic???
            return undefined;
        }
        // They're both strings, just concatenate them.
        if (typeof lhs?.style == "string") {
            return `${lhs.style};${rhs?.style ?? ""}`;
        }
        // They're both objects, just merge them.
        return {
            ...(lhs?.style ?? {}),
            ...(rhs?.style ?? {})
        };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */
    function useMergedProps(lhsAll, rhsAll) {
        // First, separate the props we were given into two groups:
        // lhsAll and rhsAll contain all the props we were given, and
        // lhsMisc and rhsMisc contain all props *except* for the easy ones
        // like className and style that we already know how to merge.
        const { children: _lhsChildren, class: _lhsClass, className: _lhsClassName, style: _lhsStyle, ref: _lhsRef, ...lhsMisc } = lhsAll;
        const { children: _rhsChildren, class: _rhsClass, className: _rhsClassName, style: _rhsStyle, ref: _rhsRef, ...rhsMisc } = rhsAll;
        const ret = {
            ...lhsMisc,
            ref: useMergedRefs(lhsAll, rhsAll),
            style: useMergedStyles(lhsAll, rhsAll),
            className: useMergedClasses(lhsAll, rhsAll),
            children: useMergedChildren(lhsAll, rhsAll),
        };
        if (ret.ref === undefined)
            delete ret.ref;
        if (ret.style === undefined)
            delete ret.style;
        if (ret.className === undefined)
            delete ret.className;
        if (ret.children === undefined)
            delete ret.children;
        // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];
        const rhsEntries = Object.entries(rhsMisc);
        for (const [rhsKeyU, rhsValue] of rhsEntries) {
            const rhsKey = rhsKeyU;
            const lhsValue = lhsMisc[rhsKey];
            if (typeof lhsValue === "function" || typeof rhsValue === "function") {
                // They're both functions that can be merged (or one's a function and the other's null).
                // Not an *easy* case, but a well-defined one.
                const merged = mergeFunctions(lhsValue, rhsValue);
                ret[rhsKey] = merged;
            }
            else {
                // Uh...we're here because one of them's null, right?
                if (lhsValue == null && rhsValue == null) {
                    if (rhsValue === null && lhsValue === undefined)
                        ret[rhsKey] = rhsValue;
                    else
                        ret[rhsKey] = lhsValue;
                }
                if (lhsValue == null)
                    ret[rhsKey] = rhsValue;
                else if (rhsValue == null)
                    ret[rhsKey] = lhsValue;
                else if (rhsValue == lhsValue) ;
                else {
                    // Ugh.
                    // No good strategies here, just log it if requested
                    log?.(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
                    ret[rhsKey] = rhsValue;
                }
            }
        }
        return ret;
    }
    function mergeFunctions(lhs, rhs) {
        if (!lhs)
            return rhs;
        if (!rhs)
            return lhs;
        return (...args) => {
            const lv = lhs(...args);
            const rv = rhs(...args);
            if (lv instanceof Promise || rv instanceof Promise)
                return Promise.all([lv, rv]);
        };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */
    function useRefElement(args) {
        const { onElementChange, onMount, onUnmount } = (args ?? {});
        useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
        // Called (indirectly) by the ref that the element receives.
        const handler = T$1((e, prevValue) => {
            const cleanup = onElementChange?.(e, prevValue);
            if (prevValue)
                onUnmount?.(prevValue);
            if (e)
                onMount?.(e);
            return cleanup;
        }, []);
        // Let us store the actual (reference to) the element we capture
        const [getElement, setElement] = usePassiveState(handler, returnNull);
        const useRefElementProps = T$1((props) => useMergedProps({ ref: setElement }, props), []);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        return {
            useRefElementProps,
            getElement
        };
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Set();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.
    function forEachUpdater(window, map, value) {
        if (!microtasks.has(map)) {
            microtasks.add(map);
            queueMicrotask(() => {
                microtasks.delete(map);
                const updaters = map.get(window);
                if (updaters) {
                    for (const updater of updaters) {
                        updater?.(value);
                    }
                }
            });
        }
    }
    function focusout(e) {
        const window = e.target.ownerDocument.defaultView;
        if (e.relatedTarget == null) {
            forEachUpdater(window, activeElementUpdaters, null);
        }
    }
    function focusin(e) {
        const window = e.target.ownerDocument.defaultView;
        const currentlyFocusedElement = e.target;
        forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
        forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }
    function windowFocus(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, true);
        forEachUpdater(window, windowFocusedUpdaters, true);
    }
    function windowBlur(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, false);
        forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */
    function useActiveElement({ onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMount, onUnmount, onMountChange }) {
        useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMountChange, onMount, onUnmount);
        const { getElement, useRefElementProps } = useRefElement({
            onMount,
            onUnmount,
            onElementChange: T$1((element, prevValue) => {
                onMountChange?.(element, prevValue);
                if (element) {
                    const document = element.ownerDocument;
                    const window = document?.defaultView;
                    if ((activeElementUpdaters.get(window)?.size ?? 0) === 0) {
                        document?.addEventListener("focusin", focusin, { passive: true });
                        document?.addEventListener("focusout", focusout, { passive: true });
                        window?.addEventListener("focus", windowFocus, { passive: true });
                        window?.addEventListener("blur", windowBlur, { passive: true });
                    }
                    // Add them even if they're undefined to more easily
                    // manage the ">0 means don't add handlers" logic.
                    const localActiveElementUpdaters = activeElementUpdaters.get(window) ?? new Set();
                    const localLastActiveElementUpdaters = lastActiveElementUpdaters.get(window) ?? new Set();
                    const localWindowFocusedUpdaters = windowFocusedUpdaters.get(window) ?? new Set();
                    localActiveElementUpdaters.add(setActiveElement);
                    localLastActiveElementUpdaters.add(setLastActiveElement);
                    localWindowFocusedUpdaters.add(setWindowFocused);
                    activeElementUpdaters.set(window, localActiveElementUpdaters);
                    lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
                    windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
                    return () => {
                        activeElementUpdaters.get(window).delete(setActiveElement);
                        lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
                        windowFocusedUpdaters.get(window).delete(setWindowFocused);
                        if (activeElementUpdaters.size === 0) {
                            document?.removeEventListener("focusin", focusin);
                            document?.removeEventListener("focusout", focusout);
                            window?.removeEventListener("focus", windowFocus);
                            window?.removeEventListener("blur", windowBlur);
                        }
                    };
                }
            }, [])
        });
        const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
        const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
        const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
        return { getElement, useActiveElementProps: useRefElementProps, getActiveElement, getLastActiveElement, getWindowFocused };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
    function base64(value) {
        return Table[value];
    }
    function random6Bits() {
        return Math.floor(Math.random() * 0b1000000);
    }
    function random64Bits() {
        return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */
    function generateRandomId(prefix) {
        return `${prefix ?? "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map();
    // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.
    const commitName = "diffed";
    const originalCommit = l$1[commitName];
    const newCommit = (...args) => {
        for (const [id, effectInfo] of toRun) {
            const oldInputs = previousInputs.get(id);
            if (argsChanged(oldInputs, effectInfo.inputs)) {
                effectInfo.cleanup?.();
                effectInfo.cleanup = effectInfo.effect();
                previousInputs.set(id, effectInfo.inputs);
            }
        }
        toRun.clear();
        originalCommit?.(...args);
    };
    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */
    function useBeforeLayoutEffect(effect, inputs) {
        /*(() => {
            const cleanup = useRef<void | (() => void) | null>(null);
            const prevArgsRef = useRef<Inputs>(null!);
            if (argsChanged(inputs, prevArgsRef.current)) {
                prevArgsRef.current = inputs!;
                if (cleanup.current)
                    cleanup.current();
                cleanup.current = effect();
            }
        })();*/
        const [id] = y(() => generateRandomId());
        toRun.set(id, { effect, inputs, cleanup: null });
        _(() => {
            return () => {
                toRun.delete(id);
                previousInputs.delete(id);
            };
        }, [id]);
    }
    function argsChanged(oldArgs, newArgs) {
        return !!(!oldArgs ||
            oldArgs.length !== newArgs?.length ||
            newArgs?.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */
    function useStableGetter(value) {
        const ref = s(Unset);
        useBeforeLayoutEffect(() => { ref.current = value; }, [value]);
        return T$1(() => {
            if (ref.current === Unset) {
                throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
            }
            return ref.current;
        }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */
    function useStableCallback(fn) {
        const currentCallbackGetter = useStableGetter(fn);
        return T$1((...args) => {
            return currentCallbackGetter()(...args);
        }, []);
    }

    const SharedAnimationFrameContext = B(null);
    /**
     * The (optionally non-stable) `callback` you provide will start running every frame after the component mounts.
     *
     * Passing `null` is fine and simply stops the effect until you restart it by providing a non-null callback.
     *
     * **This hook does not return anything at all, including no prop-modifying hooks**
     */
    function useAnimationFrame({ callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback ?? noop);
        const hasCallback = (callback != null);
        const sharedAnimationFrameContext = q$1(SharedAnimationFrameContext);
        _(() => {
            if (sharedAnimationFrameContext) {
                if (hasCallback) {
                    sharedAnimationFrameContext.addCallback(stableCallback);
                }
                else {
                    sharedAnimationFrameContext.removeCallback(stableCallback);
                }
            }
            else {
                if (hasCallback) {
                    // Get a wrapper around the wrapper around the callback
                    // that also calls `requestAnimationFrame` again.
                    const rafCallback = (ms) => {
                        handle = requestAnimationFrame(rafCallback);
                        stableCallback(ms);
                    };
                    let handle = requestAnimationFrame(rafCallback);
                    return () => cancelAnimationFrame(handle);
                }
            }
        }, [sharedAnimationFrameContext, hasCallback]);
    }
    // eslint-disable @typescript-eslint/no-empty-function
    function noop() { }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$5.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$4.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */
    function useState(initialState) {
        // We keep both, but overrride the `setState` functionality
        const [state, setStateP] = y(initialState);
        const ref = s(state);
        // Hijack the normal setter function 
        // to also set our ref to the new value
        const setState = T$1(value => {
            if (typeof value === "function") {
                const callback = value;
                setStateP(prevValue => {
                    const nextValue = callback(prevValue);
                    ref.current = nextValue;
                    return nextValue;
                });
            }
            else {
                ref.current = value;
                setStateP(value);
            }
        }, []);
        const getState = () => { return ref.current; };
        console.assert(ref.current === state || (typeof state === "number" && isNaN(state)));
        return [state, setState, getState];
    }

    function identity$1(...t) { return t; }
    function useThrottled(callback, wait, options) {
        const throttled = F$1(() => {
            return callback ? throttle(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.trailing]);
        _(() => {
            return () => throttled?.cancel();
        }, [throttled]);
        return throttled;
    }
    function useDebounced(callback, wait, options) {
        const debounced = F$1(() => {
            return callback ? debounce(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.maxWait, options?.trailing]);
        _(() => {
            return () => debounced?.cancel();
        }, [debounced]);
        return debounced;
    }
    /**
     * Given an async function, returns a function that's suitable for non-async APIs,
     * along with other information about the current run's status.
     *
     * See also `useAsyncHandler` for a version that's specialized for DOM event handlers.
     *
     * When called multiple times in quick succession, (i.e. before the handler has finished),
     * this works like Lodash's `throttle` function with the `wait` option always
     * set to however long the handler takes to complete. A second call to the sync function will be
     * throttled until the first call has finished. The return value of the function is the result
     * of the previous invocation, or `undefined` on the first call.
     *
     * The handler is only ever delayed if one is currently running, so, e.g. for iOS touch events the
     * first call happens in the same event handler (which means things like calls to `element.focus()`
     * will work as intended, since that fails when the event is "split up")
     *
     * Finally, because the sync handler may be invoked on a delay, any property references on the arguments
     * provided might be stale by the time it's actually invoked (e.g. accessing `event.currentTarget.checked`
     * is not stable across time because it's a "live" value -- you almost always want the value that it
     * had at the original time the handler was called). The `capture` option allows you to save that kind of
     * dynamic data at the time it runs; the `AP` and `SP` type parameters likewise control
     * the parameters the async handler and sync handler expect respectively.
     *
     */
    function useAsync(asyncHandler, options) {
        /* eslint-disable prefer-const */
        let { throttle, debounce, capture } = (options ?? {});
        capture ??= identity$1;
        // We keep, like, a lot of render-state, but it only ever triggers a re-render
        // when we start/stop an async action.
        // Keep track of this for the caller's sake -- we don't really care.
        const [currentType, setCurrentType] = useState(null);
        const [runCount, setRunCount] = useState(0);
        const [settleCount, setSettleCount] = useState(0);
        const [resolveCount, setResolveCount] = useState(0);
        const [rejectCount, setRejectCount] = useState(0);
        // Things related to current execution
        // Because we can both return and throw undefined, 
        // we need separate state to track their existance too.
        const [pending, setPending, getPending] = useState(false);
        const [result, setResult, getResult] = useState(undefined);
        const [error, setError, _getError] = useState(undefined);
        const [hasError, setHasError, _getHasError] = useState(false);
        const [hasResult, setHasResult, _getHasResult] = useState(false);
        // We implement our own throttling behavior in regards to waiting until the async handler finishes.
        // These two passive state variables keep track of that, automatically queueing/dequeuing the next handler.
        const [getQueued, setQueued] = usePassiveState(null, returnNull);
        // The actual sync handler.
        // Capture/transform the given parameters if applicable,
        // then run further logic that's debounced/throttled
        const captureArgsAndExecuteDebouncedHandler = useStableCallback(function onNewExecuteRequest(...newArgs2) {
            // Capture the arguments we were given.
            // We might use them immediately, or we might store them to `queued`,
            // but in either case we do need the captured value.
            const captured = capture(...newArgs2);
            // This is all logic that deals with the captured value instead of the raw arguments.
            // It's called in two separate circumstances,
            // and has the debounce/throttle logic already applied
            return executeHandlerWithDebounce(getPending(), ...captured);
        });
        // This is the logic that runs when the handler is *just* about to start.
        // This function itself is further transformed to be throttled/debounced if requested,
        // so this might not be called immediately after 
        const executeHandlerWithoutDebounce = useStableCallback(function onNewExecuteRequest2(enqueue, ...newArgs) {
            const onThen = (value) => { setResult(value); setHasResult(true); setHasError(false); setResolveCount(r => ++r); };
            const onCatch = (ex) => { setError(ex); setHasError(true); setHasResult(false); setRejectCount(r => ++r); };
            const onFinally = () => {
                const queued = getQueued();
                setSettleCount(s => ++s);
                if (queued) {
                    setQueued(null);
                    executeHandlerWithDebounce(false, ...queued);
                }
                else {
                    setPending(false);
                }
            };
            if (!enqueue) {
                // Nothing is pending at the moment, so we can run our function immediately.
                setRunCount(r => ++r);
                setPending(true);
                const result = asyncHandler?.(...newArgs);
                const isPromise = (result != null && typeof result == "object" && "then" in result);
                if (result == null || !isPromise) {
                    // It's synchronous and returned successfully.
                    // Bail out early.
                    onThen(result);
                    onFinally();
                    setCurrentType("sync");
                }
                else {
                    result.then(onThen).catch(onCatch).finally(onFinally);
                    setCurrentType("async");
                }
            }
            else {
                // When we're still running a previous handler,
                // just set ourselves as the next one to run and quit early.
                // Nothing more to do.
                setQueued(newArgs);
            }
            return getResult();
        });
        const executeHandlerWithT = useThrottled(!throttle ? null : executeHandlerWithoutDebounce, throttle ?? 0);
        const executeHandlerWithD = useDebounced(!debounce ? null : (executeHandlerWithT ?? executeHandlerWithoutDebounce), debounce ?? 0);
        const executeHandlerWithDebounce = (executeHandlerWithD ?? executeHandlerWithT ?? executeHandlerWithoutDebounce);
        const flushDebouncedPromise = useStableCallback(() => {
            if (executeHandlerWithDebounce && "flush" in executeHandlerWithDebounce)
                executeHandlerWithDebounce.flush();
        });
        return {
            syncHandler: captureArgsAndExecuteDebouncedHandler,
            currentType,
            pending,
            result,
            error,
            hasError,
            hasResult,
            resolveCount,
            rejectCount,
            settleCount,
            callCount: runCount,
            flushDebouncedPromise
        };
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * Note that because the handler you provide may be called with a delay, and
     * because the value of, e.g., an `<input>` element will likely be stale by the
     * time the delay is over, a `capture` function is necessary in order to
     * capture the relevant information from the DOM. Any other simple event data,
     * like `mouseX` or `shiftKey` can stay on the event itself and don't
     * need to be captured &ndash; it's never stale.
     *
     * ```tsx
     * const asyncOnInput = async (value: number, e: Event) => {
     *     [...] // Ex. send to a server and setState when done
     * };
     * const {
     *     // A sync version of asyncOnInput
     *     syncHandler,
     *     // True while the handler is running
     *     pending,
     *     // The error thrown, if any
     *     error,
     *     // Show this value while the operation's pending
     *     currentCapture,
     *     // And others, see `UseAsyncHandlerReturnType`
     *     ...rest
     * } = useAsyncHandler<HTMLInputElement>()(asyncOnInput, {
     *     // Pass in the capture function that saves event data
     *     // from being stale.
     *     capture: e => {
     *         // `capture` can have side-effects because
     *         // it's called exactly once per invocation
     *         e.preventDefault();
     *
     *         // Save this value so that it's never stale
     *         return e.currentTarget.valueAsNumber;
     *     }
     * });
     *
     * const onInput = pending? null : syncHandler;
     * ```
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     *
     * You may optionally *also* specify debounce and throttle parameters that wait until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * @see useAsync A more general version of this hook that can work with any type of handler, not just DOM event handlers.
     */
    function useAsyncHandler(asyncHandler, { capture: originalCapture, ...restAsyncOptions }) {
        // We need to differentiate between "nothing captured yet" and "`undefined` was captured"
        const [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        const [hasCapture, setHasCapture] = useState(false);
        // Wrap around the normal `useAsync` `capture` function to also
        // keep track of the last value the user actually input.
        // 
        // Without this there's no way to re-render the control with
        // it being both controlled and also having the "correct" value,
        // and at any rate also protects against sudden exceptions reverting
        // your change out from under you.
        const capture = useStableCallback((e) => {
            const captured = originalCapture(e);
            setCurrentCapture(captured);
            setHasCapture(true);
            return [captured, e];
        });
        return {
            getCurrentCapture,
            currentCapture,
            hasCapture,
            ...useAsync(asyncHandler, { capture, ...restAsyncOptions })
        };
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
     * passing one of them as this argument. By default, it's `useEffect`.
     */
    function useEffect(effect, inputs, impl = _) {
        const prevInputs = s(undefined);
        const effect2 = () => {
            const changes = [];
            if (inputs && prevInputs.current) {
                for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
                    if (prevInputs.current[i] != inputs[i])
                        changes[i] = { from: prevInputs.current[i], to: inputs[i] };
                }
            }
            const ret = effect(prevInputs.current, changes);
            prevInputs.current = inputs;
            return ret;
        };
        impl(effect2, inputs);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */
    function useLayoutEffect(effect, inputs) {
        return useEffect(effect, inputs, h);
    }

    //export type UseManagedChildParameters<I extends {}> = { info: I };
    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */
    function useManagedChildren(parentParameters) {
        const { managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
        const getHighestIndex = T$1(() => {
            return managedChildrenArray.current.highestIndex;
        }, []);
        // All the information we have about our children is stored in this **stable** array.
        // Any mutations to this array **DO NOT** trigger any sort of a re-render.
        const managedChildrenArray = s({ arr: [], rec: {}, highestIndex: 0, lowestIndex: 0 });
        // For indirect access to each child
        // Compare getManagedChildInfo
        // TODO: The primary use for this is flaggable closest fits
        // which need to search all children for that closest fit.
        // It would be nice if there was something better for that.
        const forEachChild = T$1((f) => {
            for (const child of managedChildrenArray.current.arr) {
                f(child);
            }
            for (const field in managedChildrenArray.current.rec) {
                const child = managedChildrenArray.current.rec[field];
                if (child)
                    f(child);
            }
        }, []);
        // Retrieves the information associated with the child with the given index.
        // `undefined` if not child there, or it's unmounted.
        const getManagedChildInfo = T$1((index) => {
            if (typeof index == "number")
                return managedChildrenArray.current.arr[index];
            else
                return managedChildrenArray.current.rec[index];
        }, []);
        // tl;dr this is a way to have run useLayoutEffect once after all N children
        // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
        // ourselves because of having a `childCount` state or anything similar.
        //
        // When the child count ref updates, we want the parent to also run an effect
        // to maybe do something with all these children that just mounted.
        // The easiest way would be useEffect(..., [childCount]) but
        // that would require us having a childCount state, then calling
        // setChildCount and re-rendering every time children mount
        // (only one re-render at a time unless children are staggered, but still)
        // 
        // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
        // to emulate running ULE on the parent. Only the first child will actually queue
        // the microtask (by checking hasRemoteULE first) so that the "effect" only
        // runs once. When it's done, hasRemoteULE is reset so it can run again if
        // more children mount/unmount.
        const hasRemoteULEChildMounted = s(null);
        const remoteULEChildChangedCausers = s(new Set());
        const remoteULEChildChanged = T$1((index) => {
            if (remoteULEChildChangedCausers.current.size == 0) {
                queueMicrotask(() => {
                    onAfterChildLayoutEffect?.(remoteULEChildChangedCausers.current);
                    remoteULEChildChangedCausers.current.clear();
                });
            }
            remoteULEChildChangedCausers.current.add(index);
            return () => { };
        }, [ /* Must remain stable */]);
        const remoteULEChildMounted = T$1((index, mounted) => {
            if (!hasRemoteULEChildMounted.current) {
                hasRemoteULEChildMounted.current = {
                    mounts: new Set(),
                    unmounts: new Set(),
                };
                queueMicrotask(() => {
                    onChildrenMountChange?.(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
                    hasRemoteULEChildMounted.current = null;
                });
            }
            if (mounted) {
                managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
            }
            else {
                if (typeof index == "number") {
                    delete managedChildrenArray.current.arr[index];
                    let shave = 0;
                    while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined)
                        ++shave;
                    managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - 1 - shave, shave);
                }
                else
                    delete managedChildrenArray.current.rec[index];
            }
            hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
        }, [ /* Must remain stable */]);
        const useManagedChild = T$1(({ managedChild: info, }) => {
            // Any time our child props change, make that information available
            // the parent if they need it.
            // The parent can listen for all updates and only act on the ones it cares about,
            // and multiple children updating in the same tick will all be sent at once.
            useLayoutEffect(() => {
                // Insert this information in-place
                if (typeof info.index == "number")
                    managedChildrenArray.current.arr[info.index] = { index: info.index, flags: info.flags ?? {}, subInfo: info.subInfo };
                else
                    managedChildrenArray.current.rec[info.index] = { index: info.index, flags: info.flags ?? {}, subInfo: info.subInfo };
                return remoteULEChildChanged(info.index);
            }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
            // When we mount, notify the parent via queueMicrotask
            // (every child does this, so everything's coordinated to only queue a single microtask per tick)
            // Do the same on unmount.
            // Note: It's important that this comes AFTER remoteULEChildChanged
            // so that remoteULEChildMounted has access to all the info on mount.
            useLayoutEffect(() => {
                remoteULEChildMounted?.(info.index, true);
                return () => remoteULEChildMounted?.(info.index, false);
            }, [info.index]);
        }, [ /* Must remain stable */]);
        const managedChildren = s({
            ...{ _: managedChildrenArray.current },
            forEach: forEachChild,
            getAt: getManagedChildInfo,
            getHighestIndex: getHighestIndex,
            arraySlice: () => {
                return managedChildrenArray.current.arr.slice();
            }
        });
        return {
            useManagedChild,
            managedChildren: { children: managedChildren.current }
        };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */
    function useChildrenFlag({ children, initialIndex, closestFit, onIndexChange, key }) {
        useEnsureStability("useChildrenFlag", onIndexChange, key);
        const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, T$1(() => (initialIndex ?? (null)), []));
        const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, T$1(() => (initialIndex ?? (null)), []));
        //    const getFitNullToZero = useStableGetter(fitNullToZero);
        // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
        const getClosestFit = T$1((requestedIndex) => {
            let closestDistance = Infinity;
            let closestIndex = null;
            children.forEach(child => {
                if (child.flags?.[key]?.isValid()) {
                    const newDistance = Math.abs(child.index - requestedIndex);
                    if (newDistance < closestDistance || (newDistance == closestDistance && child.index < requestedIndex)) {
                        closestDistance = newDistance;
                        closestIndex = child.index;
                    }
                }
            });
            return closestIndex;
        }, [ /* Must remain stable! */]);
        // Any time a child mounts/unmounts, we need to double-check to see if that affects 
        // the "currently selected" (or whatever) index.  The two cases we're looking for:
        // 1. The currently selected child unmounted
        // 2. A child mounted, and it mounts with the index we're looking for
        const reevaluateClosestFit = useStableCallback(() => {
            const requestedIndex = getRequestedIndex();
            const currentIndex = getCurrentIndex();
            const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
            if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !currentChild.flags?.[key]?.isValid())) {
                currentChild?.flags?.[key].set(false);
                const closestFitIndex = getClosestFit(requestedIndex);
                setCurrentIndex(closestFitIndex);
                if (closestFitIndex != null) {
                    const closestFitChild = children.getAt(closestFitIndex);
                    console.assert(closestFitChild != null, "Internal logic???");
                    closestFitChild.flags?.[key].set(true);
                }
            }
        });
        const changeIndex = T$1((arg) => {
            const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
            //if (requestedIndex == null && getFitNullToZero())
            //    requestedIndex = 0;
            setRequestedIndex(requestedIndex);
            const currentIndex = getCurrentIndex();
            if (currentIndex == requestedIndex)
                return requestedIndex;
            let newMatchingChild = (requestedIndex == null ? null : children.getAt(requestedIndex));
            const oldMatchingChild = (currentIndex == null ? null : children.getAt(currentIndex));
            if (requestedIndex == null) {
                // Easy case
                setCurrentIndex(null);
                oldMatchingChild?.flags?.[key].set(false);
                return null;
            }
            else {
                if (newMatchingChild && newMatchingChild.flags?.[key].isValid()) {
                    setCurrentIndex(requestedIndex);
                    oldMatchingChild?.flags?.[key].set(false);
                    newMatchingChild.flags?.[key].set(true);
                    return requestedIndex;
                }
                else {
                    const closestFitIndex = getClosestFit(requestedIndex);
                    setCurrentIndex(closestFitIndex);
                    if (closestFitIndex != null) {
                        newMatchingChild = children.getAt(closestFitIndex);
                        console.assert(newMatchingChild != null, "Internal logic???");
                        oldMatchingChild?.flags?.[key].set(false);
                        newMatchingChild.flags?.[key].set(true);
                        return closestFitIndex;
                    }
                    else {
                        oldMatchingChild?.flags?.[key].set(false);
                        return null;
                    }
                }
            }
        }, []);
        useLayoutEffect(() => {
            if (initialIndex != null)
                children.getAt(initialIndex)?.flags?.[key]?.set(true);
        }, []);
        return { changeIndex, reevaluateClosestFit, getCurrentIndex };
    }
    /*export type Spread<A extends {}, B extends {}> = Omit<A, keyof B> & B;
    export function spread<A extends {}, B extends {}>(a: A, b: B): Spread<A, B> {
        return {
            ...a,
            ...b
        }
    }*/
    /*
    function test() {
        type C = { foo: "bar" };
        type K = "flag2";

        const { children, useManagedChild } = useManagedChildren<number, C, K>({ managedChildren: { onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => onChildrenMountChange(mounted, unmounted)) } });
        useManagedChild({ managedChild: { index: 0, info: { foo: "bar" }, flags: {  } } });
        const { changeIndex, getCurrentIndex, onChildrenMountChange } = useChildrenFlag<C, K>({ children, initialIndex: 0, key: "flag2" })
    }*/

    function getDocument(element) { return (element?.ownerDocument ?? document ?? window.document ?? globalThis.document); }

    function useDraggable({ effectAllowed, data, dragImage, dragImageXOffset, dragImageYOffset }) {
        const [dragging, setDragging, getDragging] = useState(false);
        const [lastDropEffect, setLastDropEffect, getLastDropEffect] = useState(null);
        const useDraggableProps = T$1((p) => {
            const ref = s(null);
            const onDragStart = (e) => {
                //e.preventDefault();
                setDragging(true);
                if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = (effectAllowed ?? "all");
                    if (dragImage)
                        e.dataTransfer.setDragImage(dragImage, dragImageXOffset ?? 0, dragImageYOffset ?? 0);
                    const entries = Object.entries(data);
                    for (const [mimeType, data] of entries) {
                        e.dataTransfer.setData(mimeType, data);
                    }
                }
            };
            const onDragEnd = (e) => {
                e.preventDefault();
                setDragging(false);
                if (e.dataTransfer) {
                    if (e.dataTransfer.dropEffect != "none") {
                        setLastDropEffect(e.dataTransfer.dropEffect);
                    }
                    else {
                        setLastDropEffect(null);
                    }
                }
            };
            return useMergedProps({
                draggable: true,
                onDragStart,
                onDragEnd,
                ref
            }, p);
        }, [effectAllowed, dragImage, dragImageXOffset, dragImageYOffset, ...Object.entries(data).flat()]);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        const ret = {
            useDraggableProps,
            dragging,
            getDragging,
            lastDropEffect,
            getLastDropEffect
        };
        return ret;
    }

    class DroppableFileError extends Error {
        fileName;
        errorType;
        constructor(fileName, base) {
            super(base?.message ?? "An unspecified error occurred reading the file.");
            this.fileName = fileName;
            this.errorType = base?.name;
        }
    }
    function useDroppable({ effect }) {
        const [filesForConsideration, setFilesForConsideration] = useState(null);
        const [stringsForConsideration, setStringsForConsideration] = useState(null);
        const [droppedFiles, setDroppedFiles] = useState(null);
        const [droppedStrings, setDroppedStrings] = useState(null);
        const [dropError, setDropError] = useState(undefined);
        // All the promises generated from the drop events.
        // Used to process multiple drop events in succession
        const dropPromisesRef = s([]);
        const [currentPromiseIndex, setCurrentPromiseIndex, getCurrentPromiseIndex] = useState(-1);
        const [promiseCount, setPromiseCount, getPromiseCount] = useState(0);
        // Any time we add a new promise, if there's no current promise running, we need to start one.
        // If there is one, then we don't need to do anything, since it runs the same check.
        _(() => {
            const currentPromiseIndex = getCurrentPromiseIndex();
            const promiseCount = getPromiseCount();
            if (promiseCount > 0) {
                if ((currentPromiseIndex + 1) < promiseCount) {
                    setCurrentPromiseIndex(i => ++i);
                }
            }
        }, [promiseCount]);
        // Anytime our current promise changes,
        // wait for it to finish, then set our state to its result.
        // Finally, check to see if there are anymore promises.
        // If there are, then increase currentPromiseCount,
        // which will trigger this again.
        //
        // This shouldn't happen *often*, but maybe in the case of
        // individually dropping a bunch of large files or something.
        _(() => {
            if (currentPromiseIndex >= 0) {
                const currentPromise = dropPromisesRef.current[currentPromiseIndex];
                currentPromise.then((info) => {
                    if (info !== null) {
                        const { files, strings } = info;
                        setDroppedFiles(files);
                        setDroppedStrings(strings);
                    }
                    // Now that we're done, are there more promises in the queue?
                    const currentPromiseIndex = getCurrentPromiseIndex();
                    const promiseCount = getPromiseCount();
                    if ((currentPromiseIndex + 1) < promiseCount) {
                        // Since this promise has started, more have been added.
                        // Run this effect again.
                        setCurrentPromiseIndex(i => ++i);
                    }
                });
            }
        }, [currentPromiseIndex]);
        const useDroppableProps = (p) => {
            //const ref = useRef<E>(null);
            // Handle collecting the current file metadata or MIME types.
            const onDragEnter = (e) => {
                e.preventDefault();
                if (e.dataTransfer) {
                    // Is there a default? I can't find one anywhere.
                    e.dataTransfer.dropEffect = (effect ?? "move");
                    const newMimeTypes = new Set();
                    const newFiles = new Array();
                    for (const item of e.dataTransfer?.items ?? []) {
                        const { kind, type } = item;
                        if (kind === "string") {
                            newMimeTypes.add(type);
                        }
                        else if (kind === "file") {
                            newFiles.push({ type: item.type });
                        }
                    }
                    setFilesForConsideration(newFiles);
                    setStringsForConsideration(newMimeTypes);
                }
            };
            // Handle resetting the current file metadata or MIME types
            const onDragLeave = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
            };
            // Boilerplate, I guess
            const onDragOver = (e) => {
                e.preventDefault();
            };
            // Handle getting the drop data asynchronously
            const onDrop = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
                const allPromises = new Array();
                const dropData = {};
                const dropFile = [];
                for (const item of e.dataTransfer?.items ?? []) {
                    const { kind, type } = item;
                    if (kind === "string") {
                        allPromises.push((new Promise((resolve, _reject) => item.getAsString(resolve))).then(str => dropData[type] = str));
                    }
                    else if (kind === "file") {
                        const file = item.getAsFile();
                        if (file) {
                            allPromises.push(new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (_) => {
                                    resolve();
                                    const data = reader.result;
                                    dropFile.push({ data, name: file.name, type: file.type, size: data.byteLength, lastModified: file.lastModified });
                                };
                                reader.onerror = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.onabort = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.readAsArrayBuffer(file);
                            }));
                            dropFile.push();
                        }
                    }
                }
                dropPromisesRef.current.push(Promise.all(allPromises).then(() => {
                    setPromiseCount(i => ++i);
                    setDropError(null);
                    return {
                        strings: dropData,
                        files: dropFile
                    };
                }).catch(ex => {
                    /* eslint-disable no-debugger */
                    debugger;
                    setPromiseCount(i => ++i);
                    setDropError(ex);
                    return null;
                }));
            };
            return useMergedProps({ onDragEnter, onDragLeave, onDragOver, onDrop }, p);
        };
        return {
            useDroppableProps,
            filesForConsideration,
            stringsForConsideration,
            droppedFiles,
            droppedStrings,
            dropError
        };
    }

    function useElementSize({ getObserveBox, onSizeChange }) {
        useEnsureStability("useElementSize", getObserveBox, onSizeChange);
        const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
        const currentObserveBox = s(undefined);
        const needANewObserver = T$1((element, observeBox) => {
            if (element) {
                const document = getDocument(element);
                const window = document.defaultView;
                const handleUpdate = () => {
                    if (element.isConnected) {
                        const { clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop } = element;
                        setSize({ clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop });
                    }
                };
                if (window && ("ResizeObserver" in window)) {
                    const observer = new ResizeObserver((_entries) => { handleUpdate(); });
                    observer.observe(element, { box: observeBox });
                    return () => observer.disconnect();
                }
                else {
                    document.addEventListener("resize", handleUpdate, { passive: true });
                    return () => document.removeEventListener("resize", handleUpdate);
                }
            }
        }, []);
        const { getElement, useRefElementProps } = useRefElement({ onElementChange: T$1((e) => needANewObserver(e, getObserveBox?.()), []) });
        _(() => {
            if (getObserveBox) {
                if (currentObserveBox.current !== getObserveBox())
                    needANewObserver(getElement(), getObserveBox());
            }
        });
        return {
            getElement,
            getSize,
            useElementSizeProps: useRefElementProps
        };
    }

    /*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot;

      // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);

      if (!displayCheck || displayCheck === 'full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (nodeIsAttached) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck` mode


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
    	(function (global, factory) {
    	  factory() ;
    	}(commonjsGlobal, (function () {
    	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	  /**
    	   * This work is licensed under the W3C Software and Document License
    	   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
    	   */

    	  (function () {
    	    // Return early if we're not running inside of the browser.
    	    if (typeof window === 'undefined') {
    	      return;
    	    }

    	    // Convenience function for converting NodeLists.
    	    /** @type {typeof Array.prototype.slice} */
    	    var slice = Array.prototype.slice;

    	    /**
    	     * IE has a non-standard name for "matches".
    	     * @type {typeof Element.prototype.matches}
    	     */
    	    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    	    /** @type {string} */
    	    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    	    /**
    	     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
    	     * attribute.
    	     *
    	     * Its main functions are:
    	     *
    	     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
    	     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
    	     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
    	     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
    	     *   instance exists for each focusable node which has at least one inert root as an ancestor.
    	     *
    	     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
    	     *   attribute is removed from the root node). This is handled in the destructor, which calls the
    	     *   `deregister` method on `InertManager` for each managed inert node.
    	     */

    	    var InertRoot = function () {
    	      /**
    	       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
    	       * @param {!InertManager} inertManager The global singleton InertManager object.
    	       */
    	      function InertRoot(rootElement, inertManager) {
    	        _classCallCheck(this, InertRoot);

    	        /** @type {!InertManager} */
    	        this._inertManager = inertManager;

    	        /** @type {!HTMLElement} */
    	        this._rootElement = rootElement;

    	        /**
    	         * @type {!Set<!InertNode>}
    	         * All managed focusable nodes in this InertRoot's subtree.
    	         */
    	        this._managedNodes = new Set();

    	        // Make the subtree hidden from assistive technology
    	        if (this._rootElement.hasAttribute('aria-hidden')) {
    	          /** @type {?string} */
    	          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
    	        } else {
    	          this._savedAriaHidden = null;
    	        }
    	        this._rootElement.setAttribute('aria-hidden', 'true');

    	        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
    	        this._makeSubtreeUnfocusable(this._rootElement);

    	        // Watch for:
    	        // - any additions in the subtree: make them unfocusable too
    	        // - any removals from the subtree: remove them from this inert root's managed nodes
    	        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
    	        //   element, make that node a managed node.
    	        this._observer = new MutationObserver(this._onMutation.bind(this));
    	        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
    	       * stored in this object and updates the state of all of the managed nodes.
    	       */


    	      _createClass(InertRoot, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._observer.disconnect();

    	          if (this._rootElement) {
    	            if (this._savedAriaHidden !== null) {
    	              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
    	            } else {
    	              this._rootElement.removeAttribute('aria-hidden');
    	            }
    	          }

    	          this._managedNodes.forEach(function (inertNode) {
    	            this._unmanageNode(inertNode.node);
    	          }, this);

    	          // Note we cast the nulls to the ANY type here because:
    	          // 1) We want the class properties to be declared as non-null, or else we
    	          //    need even more casts throughout this code. All bets are off if an
    	          //    instance has been destroyed and a method is called.
    	          // 2) We don't want to cast "this", because we want type-aware optimizations
    	          //    to know which properties we're setting.
    	          this._observer = /** @type {?} */null;
    	          this._rootElement = /** @type {?} */null;
    	          this._managedNodes = /** @type {?} */null;
    	          this._inertManager = /** @type {?} */null;
    	        }

    	        /**
    	         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
    	         */

    	      }, {
    	        key: '_makeSubtreeUnfocusable',


    	        /**
    	         * @param {!Node} startNode
    	         */
    	        value: function _makeSubtreeUnfocusable(startNode) {
    	          var _this2 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this2._visitNode(node);
    	          });

    	          var activeElement = document.activeElement;

    	          if (!document.body.contains(startNode)) {
    	            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
    	            var node = startNode;
    	            /** @type {!ShadowRoot|undefined} */
    	            var root = undefined;
    	            while (node) {
    	              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    	                root = /** @type {!ShadowRoot} */node;
    	                break;
    	              }
    	              node = node.parentNode;
    	            }
    	            if (root) {
    	              activeElement = root.activeElement;
    	            }
    	          }
    	          if (startNode.contains(activeElement)) {
    	            activeElement.blur();
    	            // In IE11, if an element is already focused, and then set to tabindex=-1
    	            // calling blur() will not actually move the focus.
    	            // To work around this we call focus() on the body instead.
    	            if (activeElement === document.activeElement) {
    	              document.body.focus();
    	            }
    	          }
    	        }

    	        /**
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_visitNode',
    	        value: function _visitNode(node) {
    	          if (node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */node;

    	          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
    	          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
    	          if (element !== this._rootElement && element.hasAttribute('inert')) {
    	            this._adoptInertRoot(element);
    	          }

    	          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
    	            this._manageNode(element);
    	          }
    	        }

    	        /**
    	         * Register the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_manageNode',
    	        value: function _manageNode(node) {
    	          var inertNode = this._inertManager.register(node, this);
    	          this._managedNodes.add(inertNode);
    	        }

    	        /**
    	         * Unregister the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_unmanageNode',
    	        value: function _unmanageNode(node) {
    	          var inertNode = this._inertManager.deregister(node, this);
    	          if (inertNode) {
    	            this._managedNodes['delete'](inertNode);
    	          }
    	        }

    	        /**
    	         * Unregister the entire subtree starting at `startNode`.
    	         * @param {!Node} startNode
    	         */

    	      }, {
    	        key: '_unmanageSubtree',
    	        value: function _unmanageSubtree(startNode) {
    	          var _this3 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this3._unmanageNode(node);
    	          });
    	        }

    	        /**
    	         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
    	         * @param {!HTMLElement} node
    	         */

    	      }, {
    	        key: '_adoptInertRoot',
    	        value: function _adoptInertRoot(node) {
    	          var inertSubroot = this._inertManager.getInertRoot(node);

    	          // During initialisation this inert root may not have been registered yet,
    	          // so register it now if need be.
    	          if (!inertSubroot) {
    	            this._inertManager.setInert(node, true);
    	            inertSubroot = this._inertManager.getInertRoot(node);
    	          }

    	          inertSubroot.managedNodes.forEach(function (savedInertNode) {
    	            this._manageNode(savedInertNode.node);
    	          }, this);
    	        }

    	        /**
    	         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_onMutation',
    	        value: function _onMutation(records, self) {
    	          records.forEach(function (record) {
    	            var target = /** @type {!HTMLElement} */record.target;
    	            if (record.type === 'childList') {
    	              // Manage added nodes
    	              slice.call(record.addedNodes).forEach(function (node) {
    	                this._makeSubtreeUnfocusable(node);
    	              }, this);

    	              // Un-manage removed nodes
    	              slice.call(record.removedNodes).forEach(function (node) {
    	                this._unmanageSubtree(node);
    	              }, this);
    	            } else if (record.type === 'attributes') {
    	              if (record.attributeName === 'tabindex') {
    	                // Re-initialise inert node if tabindex changes
    	                this._manageNode(target);
    	              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
    	                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
    	                // already managed nodes from this inert subroot.
    	                this._adoptInertRoot(target);
    	                var inertSubroot = this._inertManager.getInertRoot(target);
    	                this._managedNodes.forEach(function (managedNode) {
    	                  if (target.contains(managedNode.node)) {
    	                    inertSubroot._manageNode(managedNode.node);
    	                  }
    	                });
    	              }
    	            }
    	          }, this);
    	        }
    	      }, {
    	        key: 'managedNodes',
    	        get: function get() {
    	          return new Set(this._managedNodes);
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'hasSavedAriaHidden',
    	        get: function get() {
    	          return this._savedAriaHidden !== null;
    	        }

    	        /** @param {?string} ariaHidden */

    	      }, {
    	        key: 'savedAriaHidden',
    	        set: function set(ariaHidden) {
    	          this._savedAriaHidden = ariaHidden;
    	        }

    	        /** @return {?string} */
    	        ,
    	        get: function get() {
    	          return this._savedAriaHidden;
    	        }
    	      }]);

    	      return InertRoot;
    	    }();

    	    /**
    	     * `InertNode` initialises and manages a single inert node.
    	     * A node is inert if it is a descendant of one or more inert root elements.
    	     *
    	     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
    	     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
    	     * is intrinsically focusable or not.
    	     *
    	     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
    	     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
    	     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
    	     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
    	     * or removes the `tabindex` attribute if the element is intrinsically focusable.
    	     */


    	    var InertNode = function () {
    	      /**
    	       * @param {!Node} node A focusable element to be made inert.
    	       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
    	       */
    	      function InertNode(node, inertRoot) {
    	        _classCallCheck(this, InertNode);

    	        /** @type {!Node} */
    	        this._node = node;

    	        /** @type {boolean} */
    	        this._overrodeFocusMethod = false;

    	        /**
    	         * @type {!Set<!InertRoot>} The set of descendant inert roots.
    	         *    If and only if this set becomes empty, this node is no longer inert.
    	         */
    	        this._inertRoots = new Set([inertRoot]);

    	        /** @type {?number} */
    	        this._savedTabIndex = null;

    	        /** @type {boolean} */
    	        this._destroyed = false;

    	        // Save any prior tabindex info and make this node untabbable
    	        this.ensureUntabbable();
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.
    	       * This makes the managed node focusable again and deletes all of the previously stored state.
    	       */


    	      _createClass(InertNode, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._throwIfDestroyed();

    	          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
    	            var element = /** @type {!HTMLElement} */this._node;
    	            if (this._savedTabIndex !== null) {
    	              element.setAttribute('tabindex', this._savedTabIndex);
    	            } else {
    	              element.removeAttribute('tabindex');
    	            }

    	            // Use `delete` to restore native focus method.
    	            if (this._overrodeFocusMethod) {
    	              delete element.focus;
    	            }
    	          }

    	          // See note in InertRoot.destructor for why we cast these nulls to ANY.
    	          this._node = /** @type {?} */null;
    	          this._inertRoots = /** @type {?} */null;
    	          this._destroyed = true;
    	        }

    	        /**
    	         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
    	         * If the object has been destroyed, any attempt to access it will cause an exception.
    	         */

    	      }, {
    	        key: '_throwIfDestroyed',


    	        /**
    	         * Throw if user tries to access destroyed InertNode.
    	         */
    	        value: function _throwIfDestroyed() {
    	          if (this.destroyed) {
    	            throw new Error('Trying to access destroyed InertNode');
    	          }
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'ensureUntabbable',


    	        /** Save the existing tabindex value and make the node untabbable and unfocusable */
    	        value: function ensureUntabbable() {
    	          if (this.node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */this.node;
    	          if (matches.call(element, _focusableElementsString)) {
    	            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
    	              return;
    	            }

    	            if (element.hasAttribute('tabindex')) {
    	              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            }
    	            element.setAttribute('tabindex', '-1');
    	            if (element.nodeType === Node.ELEMENT_NODE) {
    	              element.focus = function () {};
    	              this._overrodeFocusMethod = true;
    	            }
    	          } else if (element.hasAttribute('tabindex')) {
    	            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            element.removeAttribute('tabindex');
    	          }
    	        }

    	        /**
    	         * Add another inert root to this inert node's set of managing inert roots.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'addInertRoot',
    	        value: function addInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots.add(inertRoot);
    	        }

    	        /**
    	         * Remove the given inert root from this inert node's set of managing inert roots.
    	         * If the set of managing inert roots becomes empty, this node is no longer inert,
    	         * so the object should be destroyed.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'removeInertRoot',
    	        value: function removeInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots['delete'](inertRoot);
    	          if (this._inertRoots.size === 0) {
    	            this.destructor();
    	          }
    	        }
    	      }, {
    	        key: 'destroyed',
    	        get: function get() {
    	          return (/** @type {!InertNode} */this._destroyed
    	          );
    	        }
    	      }, {
    	        key: 'hasSavedTabIndex',
    	        get: function get() {
    	          return this._savedTabIndex !== null;
    	        }

    	        /** @return {!Node} */

    	      }, {
    	        key: 'node',
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._node;
    	        }

    	        /** @param {?number} tabIndex */

    	      }, {
    	        key: 'savedTabIndex',
    	        set: function set(tabIndex) {
    	          this._throwIfDestroyed();
    	          this._savedTabIndex = tabIndex;
    	        }

    	        /** @return {?number} */
    	        ,
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._savedTabIndex;
    	        }
    	      }]);

    	      return InertNode;
    	    }();

    	    /**
    	     * InertManager is a per-document singleton object which manages all inert roots and nodes.
    	     *
    	     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
    	     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
    	     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
    	     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
    	     * is created for each such node, via the `_managedNodes` map.
    	     */


    	    var InertManager = function () {
    	      /**
    	       * @param {!Document} document
    	       */
    	      function InertManager(document) {
    	        _classCallCheck(this, InertManager);

    	        if (!document) {
    	          throw new Error('Missing required argument; InertManager needs to wrap a document.');
    	        }

    	        /** @type {!Document} */
    	        this._document = document;

    	        /**
    	         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertNode>}
    	         */
    	        this._managedNodes = new Map();

    	        /**
    	         * All inert roots known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertRoot>}
    	         */
    	        this._inertRoots = new Map();

    	        /**
    	         * Observer for mutations on `document.body`.
    	         * @type {!MutationObserver}
    	         */
    	        this._observer = new MutationObserver(this._watchForInert.bind(this));

    	        // Add inert style.
    	        addInertStyle(document.head || document.body || document.documentElement);

    	        // Wait for document to be loaded.
    	        if (document.readyState === 'loading') {
    	          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
    	        } else {
    	          this._onDocumentLoaded();
    	        }
    	      }

    	      /**
    	       * Set whether the given element should be an inert root or not.
    	       * @param {!HTMLElement} root
    	       * @param {boolean} inert
    	       */


    	      _createClass(InertManager, [{
    	        key: 'setInert',
    	        value: function setInert(root, inert) {
    	          if (inert) {
    	            if (this._inertRoots.has(root)) {
    	              // element is already inert
    	              return;
    	            }

    	            var inertRoot = new InertRoot(root, this);
    	            root.setAttribute('inert', '');
    	            this._inertRoots.set(root, inertRoot);
    	            // If not contained in the document, it must be in a shadowRoot.
    	            // Ensure inert styles are added there.
    	            if (!this._document.body.contains(root)) {
    	              var parent = root.parentNode;
    	              while (parent) {
    	                if (parent.nodeType === 11) {
    	                  addInertStyle(parent);
    	                }
    	                parent = parent.parentNode;
    	              }
    	            }
    	          } else {
    	            if (!this._inertRoots.has(root)) {
    	              // element is already non-inert
    	              return;
    	            }

    	            var _inertRoot = this._inertRoots.get(root);
    	            _inertRoot.destructor();
    	            this._inertRoots['delete'](root);
    	            root.removeAttribute('inert');
    	          }
    	        }

    	        /**
    	         * Get the InertRoot object corresponding to the given inert root element, if any.
    	         * @param {!Node} element
    	         * @return {!InertRoot|undefined}
    	         */

    	      }, {
    	        key: 'getInertRoot',
    	        value: function getInertRoot(element) {
    	          return this._inertRoots.get(element);
    	        }

    	        /**
    	         * Register the given InertRoot as managing the given node.
    	         * In the case where the node has a previously existing inert root, this inert root will
    	         * be added to its set of inert roots.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {!InertNode} inertNode
    	         */

    	      }, {
    	        key: 'register',
    	        value: function register(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (inertNode !== undefined) {
    	            // node was already in an inert subtree
    	            inertNode.addInertRoot(inertRoot);
    	          } else {
    	            inertNode = new InertNode(node, inertRoot);
    	          }

    	          this._managedNodes.set(node, inertNode);

    	          return inertNode;
    	        }

    	        /**
    	         * De-register the given InertRoot as managing the given inert node.
    	         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
    	         * node from the InertManager's set of managed nodes if it is destroyed.
    	         * If the node is not currently managed, this is essentially a no-op.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
    	         */

    	      }, {
    	        key: 'deregister',
    	        value: function deregister(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (!inertNode) {
    	            return null;
    	          }

    	          inertNode.removeInertRoot(inertRoot);
    	          if (inertNode.destroyed) {
    	            this._managedNodes['delete'](node);
    	          }

    	          return inertNode;
    	        }

    	        /**
    	         * Callback used when document has finished loading.
    	         */

    	      }, {
    	        key: '_onDocumentLoaded',
    	        value: function _onDocumentLoaded() {
    	          // Find all inert roots in document and make them actually inert.
    	          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
    	          inertElements.forEach(function (inertElement) {
    	            this.setInert(inertElement, true);
    	          }, this);

    	          // Comment this out to use programmatic API only.
    	          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });
    	        }

    	        /**
    	         * Callback used when mutation observer detects attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_watchForInert',
    	        value: function _watchForInert(records, self) {
    	          var _this = this;
    	          records.forEach(function (record) {
    	            switch (record.type) {
    	              case 'childList':
    	                slice.call(record.addedNodes).forEach(function (node) {
    	                  if (node.nodeType !== Node.ELEMENT_NODE) {
    	                    return;
    	                  }
    	                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
    	                  if (matches.call(node, '[inert]')) {
    	                    inertElements.unshift(node);
    	                  }
    	                  inertElements.forEach(function (inertElement) {
    	                    this.setInert(inertElement, true);
    	                  }, _this);
    	                }, _this);
    	                break;
    	              case 'attributes':
    	                if (record.attributeName !== 'inert') {
    	                  return;
    	                }
    	                var target = /** @type {!HTMLElement} */record.target;
    	                var inert = target.hasAttribute('inert');
    	                _this.setInert(target, inert);
    	                break;
    	            }
    	          }, this);
    	        }
    	      }]);

    	      return InertManager;
    	    }();

    	    /**
    	     * Recursively walk the composed tree from |node|.
    	     * @param {!Node} node
    	     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
    	     *     before descending into child nodes.
    	     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
    	     */


    	    function composedTreeWalk(node, callback, shadowRootAncestor) {
    	      if (node.nodeType == Node.ELEMENT_NODE) {
    	        var element = /** @type {!HTMLElement} */node;
    	        if (callback) {
    	          callback(element);
    	        }

    	        // Descend into node:
    	        // If it has a ShadowRoot, ignore all child elements - these will be picked
    	        // up by the <content> or <shadow> elements. Descend straight into the
    	        // ShadowRoot.
    	        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
    	        if (shadowRoot) {
    	          composedTreeWalk(shadowRoot, callback);
    	          return;
    	        }

    	        // If it is a <content> element, descend into distributed elements - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'content') {
    	          var content = /** @type {!HTMLContentElement} */element;
    	          // Verifies if ShadowDom v0 is supported.
    	          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
    	          for (var i = 0; i < distributedNodes.length; i++) {
    	            composedTreeWalk(distributedNodes[i], callback);
    	          }
    	          return;
    	        }

    	        // If it is a <slot> element, descend into assigned nodes - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'slot') {
    	          var slot = /** @type {!HTMLSlotElement} */element;
    	          // Verify if ShadowDom v1 is supported.
    	          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];
    	          for (var _i = 0; _i < _distributedNodes.length; _i++) {
    	            composedTreeWalk(_distributedNodes[_i], callback);
    	          }
    	          return;
    	        }
    	      }

    	      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
    	      // element, nor a <shadow> element recurse normally.
    	      var child = node.firstChild;
    	      while (child != null) {
    	        composedTreeWalk(child, callback);
    	        child = child.nextSibling;
    	      }
    	    }

    	    /**
    	     * Adds a style element to the node containing the inert specific styles
    	     * @param {!Node} node
    	     */
    	    function addInertStyle(node) {
    	      if (node.querySelector('style#inert-style, link#inert-style')) {
    	        return;
    	      }
    	      var style = document.createElement('style');
    	      style.setAttribute('id', 'inert-style');
    	      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
    	      node.appendChild(style);
    	    }

    	    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
    	      /** @type {!InertManager} */
    	      var inertManager = new InertManager(document);

    	      Object.defineProperty(HTMLElement.prototype, 'inert', {
    	        enumerable: true,
    	        /** @this {!HTMLElement} */
    	        get: function get() {
    	          return this.hasAttribute('inert');
    	        },
    	        /** @this {!HTMLElement} */
    	        set: function set(inert) {
    	          inertManager.setInert(this, inert);
    	        }
    	      });
    	    }
    	  })();

    	})));
    } ());

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
        var _a, _b, _c;
        /* Symbols for private properties */
        const _blockingElements = Symbol();
        const _alreadyInertElements = Symbol();
        const _topElParents = Symbol();
        const _siblingsToRestore = Symbol();
        const _parentMO = Symbol();
        /* Symbols for private static methods */
        const _topChanged = Symbol();
        const _swapInertedSibling = Symbol();
        const _inertSiblings = Symbol();
        const _restoreInertedSiblings = Symbol();
        const _getParents = Symbol();
        const _getDistributedChildren = Symbol();
        const _isInertable = Symbol();
        const _handleMutations = Symbol();
        class BlockingElementsImpl {
            constructor() {
                /**
                 * The blocking elements.
                 */
                this[_a] = [];
                /**
                 * Used to keep track of the parents of the top element, from the element
                 * itself up to body. When top changes, the old top might have been removed
                 * from the document, so we need to memoize the inerted parents' siblings
                 * in order to restore their inerteness when top changes.
                 */
                this[_b] = [];
                /**
                 * Elements that are already inert before the first blocking element is
                 * pushed.
                 */
                this[_c] = new Set();
            }
            destructor() {
                // Restore original inertness.
                this[_restoreInertedSiblings](this[_topElParents]);
                // Note we don't want to make these properties nullable on the class,
                // since then we'd need non-null casts in many places. Calling a method on
                // a BlockingElements instance after calling destructor will result in an
                // exception.
                const nullable = this;
                nullable[_blockingElements] = null;
                nullable[_topElParents] = null;
                nullable[_alreadyInertElements] = null;
            }
            get top() {
                const elems = this[_blockingElements];
                return elems[elems.length - 1] || null;
            }
            push(element) {
                if (!element || element === this.top) {
                    return;
                }
                // Remove it from the stack, we'll bring it to the top.
                this.remove(element);
                this[_topChanged](element);
                this[_blockingElements].push(element);
            }
            remove(element) {
                const i = this[_blockingElements].indexOf(element);
                if (i === -1) {
                    return false;
                }
                this[_blockingElements].splice(i, 1);
                // Top changed only if the removed element was the top element.
                if (i === this[_blockingElements].length) {
                    this[_topChanged](this.top);
                }
                return true;
            }
            pop() {
                const top = this.top;
                top && this.remove(top);
                return top;
            }
            has(element) {
                return this[_blockingElements].indexOf(element) !== -1;
            }
            /**
             * Sets `inert` to all document elements except the new top element, its
             * parents, and its distributed content.
             */
            [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
                const toKeepInert = this[_alreadyInertElements];
                const oldParents = this[_topElParents];
                // No new top, reset old top if any.
                if (!newTop) {
                    this[_restoreInertedSiblings](oldParents);
                    toKeepInert.clear();
                    this[_topElParents] = [];
                    return;
                }
                const newParents = this[_getParents](newTop);
                // New top is not contained in the main document!
                if (newParents[newParents.length - 1].parentNode !== document.body) {
                    throw Error('Non-connected element cannot be a blocking element');
                }
                // Cast here because we know we'll call _inertSiblings on newParents
                // below.
                this[_topElParents] = newParents;
                const toSkip = this[_getDistributedChildren](newTop);
                // No previous top element.
                if (!oldParents.length) {
                    this[_inertSiblings](newParents, toSkip, toKeepInert);
                    return;
                }
                let i = oldParents.length - 1;
                let j = newParents.length - 1;
                // Find common parent. Index 0 is the element itself (so stop before it).
                while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
                    i--;
                    j--;
                }
                // If up the parents tree there are 2 elements that are siblings, swap
                // the inerted sibling.
                if (oldParents[i] !== newParents[j]) {
                    this[_swapInertedSibling](oldParents[i], newParents[j]);
                }
                // Restore old parents siblings inertness.
                i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
                // Make new parents siblings inert.
                j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
            }
            /**
             * Swaps inertness between two sibling elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_swapInertedSibling](oldInert, newInert) {
                const siblingsToRestore = oldInert[_siblingsToRestore];
                // oldInert is not contained in siblings to restore, so we have to check
                // if it's inertable and if already inert.
                if (this[_isInertable](oldInert) && !oldInert.inert) {
                    oldInert.inert = true;
                    siblingsToRestore.add(oldInert);
                }
                // If newInert was already between the siblings to restore, it means it is
                // inertable and must be restored.
                if (siblingsToRestore.has(newInert)) {
                    newInert.inert = false;
                    siblingsToRestore.delete(newInert);
                }
                newInert[_parentMO] = oldInert[_parentMO];
                newInert[_siblingsToRestore] = siblingsToRestore;
                oldInert[_parentMO] = undefined;
                oldInert[_siblingsToRestore] = undefined;
            }
            /**
             * Restores original inertness to the siblings of the elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_restoreInertedSiblings](elements) {
                for (const element of elements) {
                    const mo = element[_parentMO];
                    mo.disconnect();
                    element[_parentMO] = undefined;
                    const siblings = element[_siblingsToRestore];
                    for (const sibling of siblings) {
                        sibling.inert = false;
                    }
                    element[_siblingsToRestore] = undefined;
                }
            }
            /**
             * Inerts the siblings of the elements except the elements to skip. Stores
             * the inerted siblings into the element's symbol `_siblingsToRestore`.
             * Pass `toKeepInert` to collect the already inert elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_inertSiblings](elements, toSkip, toKeepInert) {
                for (const element of elements) {
                    // Assume element is not a Document, so it must have a parentNode.
                    const parent = element.parentNode;
                    const children = parent.children;
                    const inertedSiblings = new Set();
                    for (let j = 0; j < children.length; j++) {
                        const sibling = children[j];
                        // Skip the input element, if not inertable or to be skipped.
                        if (sibling === element || !this[_isInertable](sibling) ||
                            (toSkip && toSkip.has(sibling))) {
                            continue;
                        }
                        // Should be collected since already inerted.
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                    // Store the siblings that were inerted.
                    element[_siblingsToRestore] = inertedSiblings;
                    // Observe only immediate children mutations on the parent.
                    const mo = new MutationObserver(this[_handleMutations].bind(this));
                    element[_parentMO] = mo;
                    let parentToObserve = parent;
                    // If we're using the ShadyDOM polyfill, then our parent could be a
                    // shady root, which is an object that acts like a ShadowRoot, but isn't
                    // actually a node in the real DOM. Observe the real DOM parent instead.
                    const maybeShadyRoot = parentToObserve;
                    if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
                        parentToObserve = maybeShadyRoot.host;
                    }
                    mo.observe(parentToObserve, {
                        childList: true,
                    });
                }
            }
            /**
             * Handles newly added/removed nodes by toggling their inertness.
             * It also checks if the current top Blocking Element has been removed,
             * notifying and removing it.
             */
            [_handleMutations](mutations) {
                const parents = this[_topElParents];
                const toKeepInert = this[_alreadyInertElements];
                for (const mutation of mutations) {
                    // If the target is a shadowRoot, get its host as we skip shadowRoots when
                    // computing _topElParents.
                    const target = mutation.target.host || mutation.target;
                    const idx = target === document.body ?
                        parents.length :
                        parents.indexOf(target);
                    const inertedChild = parents[idx - 1];
                    const inertedSiblings = inertedChild[_siblingsToRestore];
                    // To restore.
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        const sibling = mutation.removedNodes[i];
                        if (sibling === inertedChild) {
                            console.info('Detected removal of the top Blocking Element.');
                            this.pop();
                            return;
                        }
                        if (inertedSiblings.has(sibling)) {
                            sibling.inert = false;
                            inertedSiblings.delete(sibling);
                        }
                    }
                    // To inert.
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        const sibling = mutation.addedNodes[i];
                        if (!this[_isInertable](sibling)) {
                            continue;
                        }
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                }
            }
            /**
             * Returns if the element is inertable.
             */
            [_isInertable](element) {
                return false === /^(style|template|script)$/.test(element.localName);
            }
            /**
             * Returns the list of newParents of an element, starting from element
             * (included) up to `document.body` (excluded).
             */
            [_getParents](element) {
                const parents = [];
                let current = element;
                // Stop to body.
                while (current && current !== document.body) {
                    // Skip shadow roots.
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        parents.push(current);
                    }
                    // ShadowDom v1
                    if (current.assignedSlot) {
                        // Collect slots from deepest slot to top.
                        while (current = current.assignedSlot) {
                            parents.push(current);
                        }
                        // Continue the search on the top slot.
                        current = parents.pop();
                        continue;
                    }
                    current = current.parentNode ||
                        current.host;
                }
                return parents;
            }
            /**
             * Returns the distributed children of the element's shadow root.
             * Returns null if the element doesn't have a shadow root.
             */
            [_getDistributedChildren](element) {
                const shadowRoot = element.shadowRoot;
                if (!shadowRoot) {
                    return null;
                }
                const result = new Set();
                let i;
                let j;
                let nodes;
                const slots = shadowRoot.querySelectorAll('slot');
                if (slots.length && slots[0].assignedNodes) {
                    for (i = 0; i < slots.length; i++) {
                        nodes = slots[i].assignedNodes({
                            flatten: true,
                        });
                        for (j = 0; j < nodes.length; j++) {
                            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                                result.add(nodes[j]);
                            }
                        }
                    }
                    // No need to search for <content>.
                }
                return result;
            }
        }
        document.$blockingElements =
            new BlockingElementsImpl();
    })();

    function blockingElements() { return getDocument().$blockingElements; }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */
    function useBlockingElement(enabled, getTarget) {
        const stableGetTarget = useStableCallback(getTarget);
        /**
         * Push/pop the element from the blockingElements stack.
         */
        h(() => {
            const target = stableGetTarget();
            if (enabled) {
                // Sometimes blockingElements will fail if, for example,
                // the target element isn't connected to document.body.
                // This is rare, but it's better to fail silently with weird tabbing behavior
                // than to crash the entire application.
                try {
                    blockingElements().push(target);
                    return () => {
                        blockingElements().remove(target);
                    };
                }
                catch (ex) {
                    // Well, semi-silently.
                    console.error(ex);
                }
            }
        }, [enabled]);
    }
    function getTopElement() {
        return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap({ trapActive }) {
        const handleActiveChange = T$1((trapActive, element) => {
            if (trapActive && element) {
                let rafHandle = requestAnimationFrame(() => {
                    // TODO: This extra queueMicrotask is needed for
                    // ...reasons?
                    queueMicrotask(() => {
                        findFirstFocusable(element)?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
            else if (element) {
                // Restore the focus to the element
                // that has returned to the top of the stack
                let rafHandle = requestAnimationFrame(() => {
                    queueMicrotask(() => {
                        elementsToRestoreFocusTo.get(getTopElement())?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
        }, []);
        const { getLastActiveElement, useActiveElementProps, getElement } = useActiveElement({ onMountChange: useStableCallback((element) => handleActiveChange(trapActive, element)) });
        // When the trap becomes active, before we let the blockingElements hook run,
        // keep track of whatever's currently focused and save it.
        h(() => {
            const element = getElement();
            if (trapActive && element) {
                const document = getDocument(element);
                // Save the currently focused element
                // to whatever's currently at the top of the stack
                elementsToRestoreFocusTo.set(getTopElement(), getLastActiveElement() ?? document.body);
            }
        }, [trapActive]);
        useBlockingElement(trapActive, getElement);
        /**
         * Any time we activate or deactivate the trap,
         * change focus to something else (something in
         * the trap if it's active, or whatever we've
         * tracked in elementsToRestoreFocusTo if not)
         */
        h(() => {
            handleActiveChange(trapActive, getElement());
        }, [trapActive]);
        const useFocusTrapProps = ((props) => {
            const p1 = useActiveElementProps(props);
            const p2 = { "aria-modal": trapActive ? "true" : undefined };
            return useMergedProps(p1, p2);
        });
        return {
            useFocusTrapProps,
            getElement
        };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */
    function findFirstFocusable(element) {
        const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => (node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP) });
        const firstFocusable = treeWalker.firstChild();
        return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */
    function useForceUpdate() {
        const [, set] = y(0);
        return s(() => set(i => ++i)).current;
    }

    function useHasFocus({ onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange }) {
        useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
        const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
        const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
        const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse);
        const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse);
        const { getActiveElement, getLastActiveElement, getWindowFocused, useActiveElementProps, getElement } = useActiveElement({
            onActiveElementChange: T$1((activeElement, prevActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == activeElement));
                const focusedInner = (!!selfElement?.contains(activeElement));
                setFocused(focused);
                setFocusedInner(focusedInner);
                onActiveElementChange?.(activeElement, prevActiveElement);
            }, []),
            onLastActiveElementChange: T$1((lastActiveElement, prevLastActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == lastActiveElement));
                const focusedInner = (!!selfElement?.contains(lastActiveElement));
                setLastFocused(focused);
                setLastFocusedInner(focusedInner);
                onLastActiveElementChange?.(lastActiveElement, prevLastActiveElement);
            }, []),
            onWindowFocusedChange
        });
        const useHasFocusProps = T$1((props) => { return useActiveElementProps(props); }, []);
        return {
            useHasFocusProps,
            getElement,
            getFocused,
            getFocusedInner,
            getLastFocused,
            getLastFocusedInner,
            getActiveElement,
            getLastActiveElement,
            getWindowFocused
        };
    }

    function capitalize(str) {
        return (str[0].toUpperCase() + str.substring(1));
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */
    function useLogicalDirection({ onLogicalDirectionChange }) {
        useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
        const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
        const { getElement, useRefElementProps } = useRefElement({
            onElementChange: T$1((element) => {
                if (element) {
                    setComputedStyles(window.getComputedStyle(element));
                }
            }, [])
        });
        // TODO: There's no way to refresh which writing mode we have once mounted.
        //   A. There's no way to watch for CSS style changes
        //   B. Calling getComputedStyle after every render for every element gets expensive fast and
        //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
        //      (Those that do will need to mount and unmount the component that uses it)
        //
        // As a solution, here's a cheap workaround that checks when the element's size has changed,
        // and if so, tests if the writing mode has changed too.
        //
        // This will work for at least some number of cases, but a better solution is still needed.
        const { useElementSizeProps } = useElementSize({ onSizeChange: T$1(_ => onLogicalDirectionChange?.(getLogicalDirectionInfo()), []) });
        const getLogicalDirectionInfo = T$1(() => {
            const computedStyles = getComputedStyles();
            if (computedStyles) {
                const w = computedStyles.writingMode;
                let d = computedStyles.direction;
                const t = computedStyles.textOrientation;
                if (t == "upright")
                    d = "ltr";
                return ({ ...WritingModes[w || "horizontal-tb"][d || "ltr"] });
            }
            return null;
        }, []);
        //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);
        const convertToLogicalOrientation = T$1((elementOrientation, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction?.inlineOrientation === elementOrientation)
                return "inline";
            return "block";
        }, []);
        const convertToPhysicalSide = T$1((side, direction) => {
            direction ??= getLogicalDirectionInfo();
            switch (side) {
                case "block-start":
                    return M[(direction?.blockDirection ?? "ttb")[0]];
                case "block-end":
                    return M[(direction?.blockDirection ?? "ttb")[2]];
                case "inline-start":
                    return M[(direction?.inlineDirection ?? "ltr")[0]];
                case "inline-end":
                    return M[(direction?.inlineDirection ?? "ltr")[2]];
            }
        }, []);
        const convertToLogicalSide = T$1((side, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction?.inlineOrientation === "vertical") {
                switch (side) {
                    case "top":
                        return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";
                    case "bottom":
                        return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";
                    case "left":
                        return direction.blockDirection === "ltr" ? "block-start" : "block-end";
                    case "right":
                        return direction.blockDirection === "rtl" ? "block-start" : "block-end";
                }
            }
            else if (direction?.inlineOrientation === "horizontal") {
                switch (side) {
                    case "top":
                        return direction.blockDirection === "ttb" ? "block-start" : "block-end";
                    case "bottom":
                        return direction.blockDirection === "btt" ? "block-start" : "block-end";
                    case "left":
                        return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";
                    case "right":
                        return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
                }
            }
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false);
            return "inline-start";
        }, []);
        const convertToPhysicalOrientation = T$1((elementOrientation, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (elementOrientation == "inline") {
                if (direction?.inlineOrientation == "horizontal")
                    return "horizontal";
                return "vertical";
            }
            else {
                if (direction?.blockOrientation == "vertical")
                    return "vertical";
                return "horizontal";
            }
        }, []);
        const convertElementSize = T$1((elementSize, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction) {
                const { inlineSize, blockSize, inlineDirection, blockDirection } = direction;
                // Size is relatively simple
                const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
                const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
                const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
                const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
                const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
                const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
                const f1 = getPhysicalLeftTop(inlineDirection);
                const f2 = getPhysicalRightBottom(inlineDirection);
                const f3 = getPhysicalLeftTop(blockDirection);
                const f4 = getPhysicalRightBottom(blockDirection);
                const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
                const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
                const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : (elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]));
                const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
                const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
                const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : (elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]));
                return {
                    clientInlineSize,
                    scrollInlineSize,
                    offsetInlineSize,
                    clientBlockSize,
                    scrollBlockSize,
                    offsetBlockSize,
                    clientInlineInset,
                    scrollInlineInset,
                    offsetInlineInset,
                    clientBlockInset,
                    scrollBlockInset,
                    offsetBlockInset,
                };
            }
            return null;
        }, []);
        return {
            useLogicalDirectionProps: T$1((props) => useRefElementProps(useElementSizeProps(props)), []),
            getElement,
            getLogicalDirectionInfo,
            convertToLogicalSize: convertElementSize,
            convertToLogicalOrientation,
            convertToPhysicalOrientation,
            convertToLogicalSide,
            convertToPhysicalSide
        };
    }
    // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)
    function getPhysicalLeftTop(dir) { if (dir === "ltr" || dir == "rtl")
        return "left"; return "top"; }
    function getPhysicalRightBottom(dir) { if (dir === "rtl")
        return "width"; if (dir === "btt")
        return "height"; return null; }
    // Helper for extracting info from "ltr", "ttb", etc.
    const M = {
        t: "top",
        b: "bottom",
        l: "left",
        r: "right"
    };
    const HorizontalTbLtr = {
        inlineDirection: "ltr",
        blockDirection: "ttb",
        inlineOrientation: "horizontal",
        blockOrientation: "vertical",
        inlineSize: "width",
        blockSize: "height",
        leftRightDirection: "ltr",
        overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = {
        ...HorizontalTbLtr,
        inlineDirection: "rtl",
    };
    const VerticalRlLtr = {
        inlineDirection: "ttb",
        blockDirection: "rtl",
        inlineOrientation: "vertical",
        blockOrientation: "horizontal",
        inlineSize: "height",
        blockSize: "width",
        leftRightDirection: "ttb",
        overUnderDirection: "rtl"
    };
    const VerticalRlRtl = {
        ...VerticalRlLtr,
        inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr };
    const SidewaysRlRtl = { ...VerticalRlRtl };
    const VerticalLrLtr = {
        ...VerticalRlLtr,
        blockDirection: "ltr",
    };
    const VerticalLrRtl = {
        ...VerticalRlRtl,
        blockDirection: "ltr",
    };
    const SidewaysLtLtr = {
        ...VerticalLrLtr,
        inlineDirection: "btt",
        leftRightDirection: "btt",
        overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = {
        ...SidewaysLtLtr,
        inlineDirection: "ttb"
    };
    const HorizontalTb = {
        ltr: HorizontalTbLtr,
        rtl: HorizontalTbRtl
    };
    const VerticalRl = {
        ltr: VerticalRlLtr,
        rtl: VerticalRlRtl
    };
    const VerticalLr = {
        ltr: VerticalLrLtr,
        rtl: VerticalLrRtl
    };
    const SidewaysRl = {
        ltr: SidewaysRlLtr,
        rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
        ltr: SidewaysLtLtr,
        rtl: SidewaysLtRtl
    };
    const WritingModes = {
        "horizontal-tb": HorizontalTb,
        "vertical-lr": VerticalLr,
        "vertical-rl": VerticalRl,
        "sideways-lr": SidewaysLr,
        "sideways-rl": SidewaysRl
    };

    function useTimeout({ timeout, callback, triggerIndex }) {
        const stableCallback = useStableCallback(() => { startTimeRef.current = null; callback(); });
        const getTimeout = useStableGetter(timeout);
        // Set any time we start timeout.
        // Unset any time the timeout completes
        const startTimeRef = s(null);
        const timeoutIsNull = (timeout == null);
        // Any time the triggerIndex changes (including on mount)
        // restart the timeout.  The timeout does NOT reset
        // when the duration or callback changes, only triggerIndex.
        _(() => {
            if (!timeoutIsNull) {
                const timeout = getTimeout();
                console.assert(timeoutIsNull == (timeout == null));
                if (timeout != null) {
                    startTimeRef.current = +(new Date());
                    const handle = setTimeout(stableCallback, timeout);
                    return () => clearTimeout(handle);
                }
            }
        }, [triggerIndex, timeoutIsNull]);
        const getElapsedTime = T$1(() => {
            return (+(new Date())) - (+(startTimeRef.current ?? new Date()));
        }, []);
        const getRemainingTime = T$1(() => {
            const timeout = getTimeout();
            return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
        }, []);
        return { getElapsedTime, getRemainingTime };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useLinearNavigation({ linearNavigation: { navigateToFirst: ntf, navigateToLast: ntl, navigateToNext: ntn, navigateToPrev: ntp, navigationDirection: nd, disableArrowKeys: dak, disableHomeEndKeys: dhek } }) {
        nd ??= "either";
        const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection({});
        const navigateToFirst = useStableCallback(ntf);
        const navigateToLast = useStableCallback(ntl);
        const navigateToNext = useStableCallback(ntn);
        const navigateToPrev = useStableCallback(ntp);
        const getDisableArrowKeys = useStableGetter(dak);
        const getDisableHomeEndKeys = useStableGetter(dhek);
        const getNavigationDirection = useStableGetter(nd);
        return {
            linearNavigation: {},
            useLinearNavigationProps: T$1((props) => {
                const onKeyDown = (e) => {
                    // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                    if (e.ctrlKey || e.metaKey)
                        return;
                    const info = getLogicalDirectionInfo();
                    const navigationDirection = getNavigationDirection();
                    const disableArrowKeys = getDisableArrowKeys();
                    const disableHomeEndKeys = getDisableHomeEndKeys();
                    const allowsBlockNavigation = (navigationDirection == "block" || navigationDirection == "either");
                    const allowsInlineNavigation = (navigationDirection == "inline" || navigationDirection == "either");
                    switch (e.key) {
                        case "ArrowUp": {
                            const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.blockOrientation === "vertical" ? allowsBlockNavigation : allowsInlineNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "btt") {
                                    navigateToNext();
                                }
                                else {
                                    navigateToPrev();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowDown": {
                            const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.blockOrientation === "vertical" ? allowsBlockNavigation : allowsInlineNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "btt") {
                                    navigateToPrev();
                                }
                                else {
                                    navigateToNext();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowLeft": {
                            const propName = (info?.inlineOrientation === "horizontal" ? "inlineDirection" : "blockDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.inlineOrientation === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "rtl") {
                                    navigateToNext();
                                }
                                else {
                                    navigateToPrev();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowRight": {
                            const propName = (info?.inlineOrientation === "horizontal" ? "inlineDirection" : "blockDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.inlineOrientation === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "rtl") {
                                    navigateToPrev();
                                }
                                else {
                                    navigateToNext();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                        case "Home":
                            if (!disableHomeEndKeys) {
                                navigateToFirst();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        case "End":
                            if (!disableHomeEndKeys) {
                                navigateToLast();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                    }
                };
                return useLogicalDirectionProps(useMergedProps({ onKeyDown }, props));
            }, []),
        };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useTypeaheadNavigation({ typeaheadNavigation: { collator, getIndex, typeaheadTimeout, setIndex, noTypeahead } }) {
        // For typeahead, keep track of what our current "search" string is (if we have one)
        // and also clear it every 1000 ms since the last time it changed.
        // Next, keep a mapping of typeahead values to indices for faster searching.
        // And, for the user's sake, let them know when their typeahead can't match anything anymore
        const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
        useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
        const sortedTypeaheadInfo = s([]);
        const [invalidTypeahead, setInvalidTypeahead] = useState(false);
        // Handle typeahead for input method editors as well
        // Essentially, when active, ignore further keys 
        // because we're waiting for a CompositionEnd event
        const [, setImeActive, getImeActive] = useState(false);
        // Because composition events fire *after* keydown events 
        // (but within the same task, which, TODO, could be browser-dependent),
        // we can use this to keep track of which event we're listening for on the first keydown.
        const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
        useLayoutEffect(() => {
            if (nextTypeaheadChar !== null) {
                setCurrentTypeahead(typeahead => ((typeahead ?? "") + nextTypeaheadChar));
                setNextTypeaheadChar(null);
            }
        }, [nextTypeaheadChar]);
        const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
            let compare;
            // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
            // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
            safeLhs = safeLhs.normalize("NFD");
            safeRhs = safeRhs.normalize("NFD");
            if (collator)
                compare = collator.compare(safeLhs, safeRhs);
            else
                compare = safeLhs.toLowerCase().localeCompare(safeRhs.toLowerCase() ?? "");
            return compare;
        });
        const insertingComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                return comparatorShared(lhs, rhs.text);
            }
            return lhs - rhs;
        });
        const typeaheadComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                // During typeahead, all strings longer than ours should be truncated
                // so that they're all considered equally by that point.
                return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
            }
            return lhs - rhs;
        });
        const isDisabled = useStableGetter(noTypeahead);
        const useTypeaheadNavigationProps = T$1(function ({ ...props }) {
            const onCompositionStart = (_e) => { setImeActive(true); };
            const onCompositionEnd = (e) => {
                setNextTypeaheadChar(e.data);
                setImeActive(false);
            };
            const onKeyDown = (e) => {
                if (isDisabled())
                    return;
                const imeActive = getImeActive();
                const key = e.key;
                // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                if (e.ctrlKey || e.metaKey)
                    return;
                if (!imeActive && e.key === "Backspace") {
                    // Remove the last character in a way that doesn't split UTF-16 surrogates.
                    setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                // The key property represents the typed character OR the "named key attribute" of the key pressed.
                // There's no definite way to tell the difference, but for all intents and purposes
                // there are no one-character names, and there are no non-ASCII-alpha names.
                // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
                const isCharacterKey = (key.length === 1 || !/^[A-Za-z]/.test(key));
                if (isCharacterKey) {
                    if (key == " " && (getCurrentTypeahead() ?? "").trim().length == 0) ;
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        // Note: Won't be true for the first keydown
                        // but will be overwritten before useLayoutEffect is called
                        // to actually apply the change
                        if (!imeActive)
                            setNextTypeaheadChar(key);
                    }
                }
            };
            return useMergedProps({ onKeyDown, onCompositionStart, onCompositionEnd, }, props);
        }, []);
        // Handle changes in typeahead that cause changes to the tabbable index
        _(() => {
            if (currentTypeahead && sortedTypeaheadInfo.current.length) {
                const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
                if (sortedTypeaheadIndex < 0) {
                    // The user has typed an entry that doesn't exist in the list
                    // (or more specifically "for which there is no entry that starts with that input")
                    setInvalidTypeahead(true);
                }
                else {
                    setInvalidTypeahead(false);
                    /*
                      We know roughly where, in the sorted array of strings, our next typeahead location is.
                      But roughly isn't good enough if there are multiple matches.
                      To convert our sorted index to the unsorted index we need, we have to find the first
                      element that matches us *and* (if any such exist) is *after* our current selection.

                      In other words, the only way typeahead moves backwards relative to our current
                      position is if the only other option is behind us.

                      It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
                      Though there's also a case for just going upwards to the nearest to prevent jumpiness.
                      But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
                      I dunno. Going back to the start is the simplist though.

                      Basically what this does: Starting from where we found ourselves after our binary search,
                      scan backwards and forwards through all adjacent entries that also compare equally so that
                      we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
                      (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).

                      TODO: The binary search starts this off with a solid O(log n), but one-character
                      searches are, thanks to pigeonhole principal, eventually guaranteed to become
                      O(n*log n). This is annoying but probably not easily solvable? There could be an
                      exception for one-character strings, but that's just kicking the can down
                      the road. Maybe one or two characters would be good enough though.
                    */
                    // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
                    let lowestUnsortedIndexAll = null;
                    let lowestSortedIndexAll = sortedTypeaheadIndex;
                    // These two are only set for elements that are ahead of us, but the principle's the same otherwise
                    let lowestUnsortedIndexNext = null;
                    let lowestSortedIndexNext = sortedTypeaheadIndex;
                    const updateBestFit = (u) => {
                        if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                            lowestUnsortedIndexAll = u;
                            lowestSortedIndexAll = i;
                        }
                        if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > (getIndex() ?? -Infinity)) {
                            lowestUnsortedIndexNext = u;
                            lowestSortedIndexNext = i;
                        }
                    };
                    let i = sortedTypeaheadIndex;
                    while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        --i;
                    }
                    i = sortedTypeaheadIndex;
                    while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        ++i;
                    }
                    if (lowestUnsortedIndexNext !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);
                    else if (lowestUnsortedIndexAll !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
                }
            }
        }, [currentTypeahead]);
        const useTypeaheadNavigationChild = T$1(({ index, text }) => {
            _(() => {
                if (text) {
                    // Find where to insert this item.
                    // Because all index values should be unique, the returned sortedIndex
                    // should always refer to a new location (i.e. be negative)                
                    const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                    console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                    if (sortedIndex < 0) {
                        sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, { text, unsortedIndex: index });
                    }
                    else {
                        sortedTypeaheadInfo.current.splice(sortedIndex, 0, { text, unsortedIndex: index });
                    }
                    return () => {
                        // When unmounting, find where we were and remove ourselves.
                        // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
                        const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                        console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                        if (sortedIndex >= 0) {
                            sortedTypeaheadInfo.current.splice(sortedIndex, 1);
                        }
                    };
                }
            }, [text]);
            return;
        }, []);
        return {
            useTypeaheadNavigationChild,
            useTypeaheadNavigationProps,
            typeaheadNavigation: {
                currentTypeahead,
                invalidTypeahead,
            }
        };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */
    function binarySearch(array, wanted, comparator) {
        let firstIndex = 0;
        let lastIndex = array.length - 1;
        while (firstIndex <= lastIndex) {
            const testIndex = (lastIndex + firstIndex) >> 1;
            const comparisonResult = comparator(wanted, array[testIndex]);
            if (comparisonResult > 0) {
                firstIndex = testIndex + 1;
            }
            else if (comparisonResult < 0) {
                lastIndex = testIndex - 1;
            }
            else {
                return testIndex;
            }
        }
        return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */
    function useRovingTabIndex(parentParameters) {
        let { rovingTabIndex: { initialIndex, onTabbedInTo, onTabbedOutOf, onTabbableRender, onTabbableIndexChange }, managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        initialIndex ??= 0;
        const stableOnTabbableRender = useStableCallback(onTabbableRender ?? (() => { }));
        const [_getAnyFocused, setAnyFocused] = usePassiveState(useStableCallback((newCount, oldCount) => {
            if (oldCount == 0 && newCount > 0) {
                onTabbedInTo?.();
            }
            if (newCount == 0 && (oldCount ?? 0) > 0) {
                onTabbedOutOf?.();
            }
        }), returnZero);
        // Keep track of three things related to the currently tabbable element's index:
        // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.
        const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, T$1(() => { return initialIndex ?? 0; }, []));
        const setTabbableIndex = T$1((updater, fromUserInteraction) => {
            setTabbableIndex2((prevIndex) => {
                let nextIndex = prevIndex;
                if (typeof updater === "function")
                    nextIndex = updater(prevIndex ?? null);
                else
                    nextIndex = updater;
                nextIndex = changeIndex(nextIndex);
                if (prevIndex != nextIndex) {
                    const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
                    const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
                    if (prevChild != null)
                        prevChild.subInfo.blurSelf();
                    if (nextChild != null && fromUserInteraction)
                        nextChild.subInfo.focusSelf();
                }
                return nextIndex;
            });
        }, []);
        // Any time the tabbable index changes,
        // notify the previous child that it's no longer tabbable,
        // and notify the next child that is allowed to be tabbed to.
        const parentReturnType = useManagedChildren({
            managedChildren: {
                onAfterChildLayoutEffect,
                onChildrenMountChange: useStableCallback((mounted, unmounted) => { onChildrenMountChange?.(mounted, unmounted); reevaluateClosestFit(); }),
            },
        });
        const { useManagedChild } = parentReturnType;
        const { changeIndex, reevaluateClosestFit } = useChildrenFlag({ initialIndex, children: parentReturnType.managedChildren.children, closestFit: true, key: "tabbable" });
        const useRovingTabIndexChild = T$1((childParameters) => {
            const { subInfo, managedChild: { index, flags }, rovingTabIndex: { hidden, blurSelf: blurSelfOverride, focusSelf: focusSelfOverride } } = childParameters;
            _(() => {
                reevaluateClosestFit();
            }, [!!hidden]);
            const bsOverride = useStableGetter(blurSelfOverride);
            const fsOverride = useStableGetter(focusSelfOverride);
            const focusSelf = T$1(() => {
                const fs = fsOverride();
                if (fs) {
                    console.log(`useRovingTabIndexChild[${index}].focusSelf (override)`);
                    fs();
                }
                else {
                    console.log(`useRovingTabIndexChild[${index}].focusSelf (default)`);
                    const element = getElement();
                    if (element)
                        element.focus?.();
                }
            }, []);
            const blurSelf = T$1(() => {
                const bs = bsOverride();
                if (bs) {
                    console.log(`useRovingTabIndexChild[${index}].blurSelf (override)`);
                    bs();
                }
                else {
                    console.log(`useRovingTabIndexChild[${index}].blurSelf (default)`);
                    const element = getElement();
                    if (element)
                        element.blur?.();
                }
            }, []);
            const onFocusedInnerChanged = useStableCallback((focused) => {
                setAnyFocused(prev => (focused ? ((prev ?? 0) + 1) : ((prev ?? 0) - 1)));
                if (focused) {
                    console.log(`Child ${index} has been focused and will set itself as the tabbable child`);
                    setTabbableIndex(index, true);
                }
            });
            const { getElement, useHasFocusProps } = useHasFocus({ onFocusedInnerChanged });
            const [tabbable, setTabbable, getTabbable] = useState(false);
            const tabbableFlags = s({ get: getTabbable, set: setTabbable, isValid: useStableCallback(() => !hidden) });
            useManagedChild({
                managedChild: {
                    index,
                    flags: { ...flags, tabbable: tabbableFlags.current },
                    subInfo: {
                        blurSelf,
                        focusSelf,
                        getElement,
                        hidden: !!hidden,
                        subInfo
                    }
                }
            });
            _(() => {
                if (tabbable)
                    stableOnTabbableRender(index);
            }, [tabbable, index]);
            function useRovingTabIndexChildProps(props) {
                console.assert(props.tabIndex == null);
                return useMergedProps(useHasFocusProps({ tabIndex: tabbable ? 0 : -1 }), props);
            }
            return {
                useRovingTabIndexChildProps,
                rovingTabIndex: {
                    getElement,
                    tabbable,
                    getTabbable
                }
            };
        }, [ /* Must remain stable */]);
        const focusSelf = T$1(() => {
            console.log(`useRovingTabIndex.focusSelf`);
            const index = getTabbableIndex();
            if (index != null)
                parentReturnType.managedChildren.children.getAt(index)?.subInfo.focusSelf?.();
            else
                setTabbableIndex(null, true);
        }, []);
        return {
            useRovingTabIndexChild,
            managedChildren: { children: parentReturnType.managedChildren.children },
            rovingTabIndex: {
                setTabbableIndex,
                getTabbableIndex,
                focusSelf,
            }
        };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Built-in value references. */
    var Buffer = moduleExports$1 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$1;

      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useRearrangeableChildren({ rearrangeableChildren: { getIndex } }) {
        // These are used to keep track of a mapping between unsorted index <---> sorted index.
        // These are needed for navigation with the arrow keys.
        const mangleMap = s(new Map());
        const demangleMap = s(new Map());
        const indexMangler = T$1((n) => (mangleMap.current.get(n) ?? n), []);
        const indexDemangler = T$1((n) => (demangleMap.current.get(n) ?? n), []);
        // The sort function needs to be able to update whoever has all the sortable children.
        // Because that might not be the consumer of *this* hook directly (e.g. a table uses
        // this hook, but it's tbody that actually needs updating), we need to remotely
        // get and set a forceUpdate function.
        //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
        const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
        const rearrange = T$1((sortedRows) => {
            // Update our sorted <--> unsorted indices map 
            // and rerender the whole table, basically
            for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
                const indexAsUnsorted = sortedRows[indexAsSorted].index;
                mangleMap.current.set(indexAsUnsorted, indexAsSorted);
                demangleMap.current.set(indexAsSorted, indexAsUnsorted);
            }
            getForceUpdate()?.();
        }, []);
        const useRearrangeableProps = T$1(({ children, ...props }) => {
            const forceUpdate = useForceUpdate();
            h(() => { setForceUpdate(_prev => forceUpdate); }, [forceUpdate]);
            return (useMergedProps({
                children: children
                    .slice()
                    .map(child => ({ child, mangledIndex: indexMangler(getIndex(child.props)), demangledIndex: getIndex(child.props) }))
                    .sort((lhs, rhs) => { return lhs.mangledIndex - rhs.mangledIndex; })
                    .map(({ child, mangledIndex, demangledIndex }) => {
                    return h$1(child.type, { ...child.props, key: demangledIndex, "data-mangled-index": mangledIndex, "data-unmangled-index": demangledIndex });
                })
            }, props));
        }, []);
        return { useRearrangeableProps, rearrangeableChildren: { indexMangler, indexDemangler, mangleMap, demangleMap, rearrange } };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useSortableChildren({ rearrangeableChildren: { getIndex }, sortableChildren: { compare: userCompare, getValue } }) {
        const compare = (userCompare ?? defaultCompare);
        const { useRearrangeableProps: useSortableProps, ...rearrangeableChildrenReturnType } = useRearrangeableChildren({ rearrangeableChildren: { getIndex } });
        const { rearrangeableChildren: { rearrange } } = rearrangeableChildrenReturnType;
        // The actual sort function.
        const sort = T$1((managedRows, direction, ...args) => {
            const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
                const lhsValue = getValue(lhsRow, ...args);
                const rhsValue = getValue(rhsRow, ...args);
                const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);
                if (direction[0] == "d")
                    return -result;
                return result;
            });
            return rearrange(sortedRows);
        }, [ /* Must remain stable */]);
        const shuffle$1 = T$1((managedRows) => {
            const shuffledRows = shuffle(managedRows.arraySlice());
            return rearrange(shuffledRows);
        }, [ /* Must remain stable */]);
        return {
            useSortableProps,
            sortableChildren: { sort, shuffle: shuffle$1 },
            rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
        };
    }
    function defaultCompare(lhs, rhs) {
        return compare1(lhs, rhs);
        function compare3(lhs, rhs) {
            // Coerce strings to numbers if they seem to stay the same when serialized
            if (`${+lhs}` === lhs)
                lhs = +lhs;
            if (`${+rhs}` === rhs)
                rhs = +rhs;
            // At this point, if either argument is a string, turn the other one into one too
            if (typeof lhs === "string")
                rhs = `${rhs}`;
            if (typeof rhs === "string")
                lhs = `${lhs}`;
            console.assert(typeof lhs === typeof rhs);
            if (typeof lhs === "string")
                return lhs.localeCompare(rhs);
            if (typeof lhs === "number")
                return +lhs - +rhs;
            return 0;
        }
        function compare2(lhs, rhs) {
            if (typeof lhs === "boolean" || lhs instanceof Date)
                lhs = +lhs;
            if (typeof rhs === "boolean" || rhs instanceof Date)
                rhs = +rhs;
            return compare3(lhs, rhs);
        }
        function compare1(lhs, rhs) {
            if (lhs == null && rhs == null) {
                // They're both null
                return 0;
            }
            else if (lhs == null || rhs == null) {
                // One of the two is null -- easy case
                return lhs != null ? 1 : -1;
            }
            return compare2(lhs, rhs);
        }
    }

    function identity(t) { return t; }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */
    function useListNavigation({ managedChildren: mc, rovingTabIndex, listNavigation: { indexDemangler, indexMangler }, linearNavigation, typeaheadNavigation }) {
        indexMangler ??= identity;
        indexDemangler ??= identity;
        useEnsureStability("useListNavigation", indexMangler, indexDemangler);
        const parentReturnType = useRovingTabIndex({
            managedChildren: mc,
            rovingTabIndex
        });
        const { useRovingTabIndexChild, managedChildren: { children }, rovingTabIndex: { getTabbableIndex, setTabbableIndex } } = parentReturnType;
        const navigateToIndex = T$1((i, fromUserInteraction) => {
            if (i != null) {
                const nextIndex = tryNavigateToIndex({
                    children: children,
                    default: 0,
                    target: i,
                    searchDirection: 1,
                    indexMangler: indexMangler ?? identity,
                    indexDemangler: indexDemangler ?? identity
                });
                setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
            }
            else {
                setTabbableIndex(null, fromUserInteraction);
            }
        }, []);
        const { useTypeaheadNavigationChild, useTypeaheadNavigationProps, typeaheadNavigation: { currentTypeahead, invalidTypeahead } } = useTypeaheadNavigation({
            typeaheadNavigation: {
                getIndex: getTabbableIndex,
                setIndex: T$1((index) => {
                    setTabbableIndex(index, true);
                }, []),
                ...typeaheadNavigation
            }
        });
        const { useLinearNavigationProps } = useLinearNavigation({
            linearNavigation: {
                navigateToPrev: T$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler((c ?? 0)) - 1), searchDirection: -1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToNext: T$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler(c ?? 0) + 1), searchDirection: 1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToFirst: T$1(() => { navigateToIndex(indexDemangler(0), true); }, []),
                navigateToLast: T$1(() => { navigateToIndex(indexDemangler(children.getHighestIndex()), true); }, []),
                ...linearNavigation
            }
        });
        const useListNavigationProps = T$1((props) => {
            return useLinearNavigationProps(useTypeaheadNavigationProps(props));
        }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
        const useListNavigationChild = T$1(({ managedChild: { index, flags }, rovingTabIndex: { blurSelf, focusSelf, hidden }, listNavigation: { text }, subInfo }) => {
            useTypeaheadNavigationChild({ text, index });
            const getIndex = useStableGetter(index);
            useEffect(() => {
                return () => {
                    if (getTabbableIndex() == getIndex()) {
                        navigateToIndex(index, false);
                    }
                };
            }, []);
            const { useRovingTabIndexChildProps, rovingTabIndex: { tabbable, getTabbable, getElement } } = useRovingTabIndexChild({
                managedChild: { index, flags },
                rovingTabIndex: { blurSelf, focusSelf, hidden: !!hidden },
                subInfo: { text, subInfo }
            });
            const useListNavigationChildProps = function ({ ...props }) {
                return useMergedProps(useRovingTabIndexChildProps({ inert: hidden }), props);
            };
            return {
                useListNavigationChildProps,
                rovingTabIndex: {
                    tabbable,
                    getTabbable,
                    getElement
                }
            };
        }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
        return {
            useListNavigationChild,
            useListNavigationProps,
            listNavigation: { navigateToIndex },
            managedChildren: parentReturnType.managedChildren,
            rovingTabIndex: parentReturnType.rovingTabIndex,
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }
            /*listNavigation: { navigateToIndex },
            rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/
        };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */
    function useListNavigationSingleSelection({ singleSelection: { selectedIndex }, listNavigation, managedChildren: { /*onChildrenMountChange: ocmc,*/ ...mc }, rovingTabIndex: { initialIndex, ...rovingTabIndex }, linearNavigation, typeaheadNavigation }) {
        const parentReturnType = useListNavigation({
            listNavigation,
            managedChildren: {
                ...mc,
                /*onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => {
                    reevaluateClosestFit();
                    ocmc?.(mounted, unmounted);
                })*/
            },
            rovingTabIndex: {
                initialIndex: (initialIndex ?? selectedIndex ?? undefined),
                ...rovingTabIndex
            },
            linearNavigation,
            typeaheadNavigation
        });
        const { useListNavigationChild, useListNavigationProps, ...listRest } = parentReturnType;
        const { managedChildren: { children } } = listRest;
        const { changeIndex: changeSelectedIndex, getCurrentIndex: getSelectedIndex,
        //reevaluateClosestFit
         } = useChildrenFlag({
            children: children,
            initialIndex: selectedIndex,
            key: "selected",
            closestFit: false
        });
        h(() => {
            changeSelectedIndex(selectedIndex);
        }, [selectedIndex]);
        return {
            useListNavigationSingleSelectionChild: T$1(({ managedChild: { index, flags }, rovingTabIndex: rti, listNavigation: ls, subInfo }) => {
                const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
                const selectedRef = s({ get: getIsSelected, set: setIsSelected, isValid: useStableCallback(() => !rti.hidden) });
                const { rovingTabIndex: rti_ret, useListNavigationChildProps } = useListNavigationChild({
                    managedChild: {
                        index,
                        flags: {
                            selected: selectedRef.current,
                            ...flags
                        }
                    },
                    rovingTabIndex: rti,
                    listNavigation: ls,
                    subInfo
                });
                return {
                    useListNavigationSingleSelectionChildProps: useListNavigationChildProps,
                    rovingTabIndex: rti_ret,
                    singleSelection: { selected: isSelected, getSelected: getIsSelected }
                };
            }, []),
            useListNavigationSingleSelectionProps: T$1((...p) => { return useListNavigationProps(...p); }, []),
            ...listRest,
            singleSelection: {}
        };
    }
    function useSortableListNavigationSingleSelection({ linearNavigation, listNavigation, managedChildren, rovingTabIndex, singleSelection, typeaheadNavigation }) {
        const { useSortableProps, ...sortableReturnType } = useSortableChildren({
            rearrangeableChildren: { getIndex: T$1((row) => row.index, []) },
            sortableChildren: {
                getValue: T$1((row) => row.index, []),
                compare: T$1((lhs, rhs) => { return lhs - rhs; }, []),
            }
        });
        const { rearrangeableChildren: { indexDemangler, indexMangler } } = sortableReturnType;
        const { useListNavigationSingleSelectionChild, useListNavigationSingleSelectionProps, ...listNavReturnType } = useListNavigationSingleSelection({
            linearNavigation: linearNavigation,
            listNavigation: { indexDemangler, indexMangler, ...listNavigation },
            managedChildren: managedChildren,
            rovingTabIndex: rovingTabIndex,
            typeaheadNavigation: typeaheadNavigation,
            singleSelection: singleSelection
        });
        const useSortableListNavigationSingleSelectionProps = (props) => {
            return (useListNavigationSingleSelectionProps(useSortableProps(props)));
        };
        const useSortableListNavigationSingleSelectionChild = (p) => {
            return useListNavigationSingleSelectionChild(p);
        };
        return ({
            useSortableListNavigationSingleSelectionChild,
            useSortableListNavigationSingleSelectionProps,
            //sortable: { sort, shuffle, rearrange, demangleMap, indexDemangler, indexMangler, mangleMap },
            ...sortableReturnType,
            ...listNavReturnType
        });
    }
    function tryNavigateToIndex({ children, searchDirection, indexDemangler, indexMangler, target }) {
        const upper = children.getHighestIndex();
        const lower = 0;
        if (searchDirection === -1) {
            while ((target >= lower && (children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden))
                target = indexDemangler(indexMangler(target) - 1);
            return target < lower ? indexDemangler(lower) : target;
        }
        else if (searchDirection === 1) {
            while ((target <= upper && children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden)
                target = indexDemangler(indexMangler(target) + 1);
            return target > upper ? indexDemangler(upper) : target;
        }
        else {
            return lower;
        }
    }

    function useGridNavigation({ managedChildren: mc, rovingTabIndex: rti, listNavigation: ls, linearNavigation: ln, typeaheadNavigation: tn }) {
        const [currentColumn, setCurrentColumn, getCurrentColumn] = useState(rti.initialIndex ?? 0);
        const { useListNavigationChild: useListNavigationChildAsGridRow, useListNavigationProps: useListNavigationPropsAsGridParent, ...parentLsReturnType } = useListNavigation({
            managedChildren: mc,
            rovingTabIndex: rti,
            listNavigation: ls,
            linearNavigation: { navigationDirection: "block", ...ln },
            typeaheadNavigation: tn,
        });
        const useGridNavigationRow = T$1(({ asChildRowOfSection: asChild, asParentRowOfCells: asParent }) => {
            // Override the focusSelf that rovingTabIndex does.
            // Instead of focusing the entire row, we ask the cell that corresponds
            // to our current column to focus itself.
            const focusSelf = useStableCallback(() => {
                const c2 = getCurrentColumn();
                console.log(`row #${asChild.managedChild.index},${c2} focusSelf`);
                if (asChild.rovingTabIndex.focusSelf) {
                    asChild.rovingTabIndex.focusSelf();
                }
                else {
                    navigateToIndex(c2 ?? 0, true);
                }
            });
            const rowLsChildReturnType = useListNavigationChildAsGridRow({
                managedChild: asChild.managedChild,
                listNavigation: { ...asChild.listNavigation },
                rovingTabIndex: { ...asChild.rovingTabIndex, focusSelf },
                subInfo: asChild.subInfo,
            });
            const { rovingTabIndex: { tabbable }, useListNavigationChildProps } = rowLsChildReturnType;
            _(() => {
                if (!tabbable) {
                    navigateToIndex(null, false);
                }
            }, [tabbable]);
            const rowLsReturnType = useListNavigation({
                managedChildren: { ...asParent.managedChildren },
                rovingTabIndex: { ...asParent.rovingTabIndex },
                linearNavigation: {
                    ...asParent.linearNavigation,
                    navigationDirection: "inline",
                },
                typeaheadNavigation: { ...asParent.typeaheadNavigation, noTypeahead: true },
                listNavigation: { ...asParent.listNavigation }
            });
            const { rovingTabIndex: { setTabbableIndex }, useListNavigationChild: useGridNavigationColumn2, useListNavigationProps: useGridNavigationColumnProps, listNavigation: { navigateToIndex } } = rowLsReturnType;
            //const rowHidden = !!asChild.rovingTabIndex.hidden;
            const useGridNavigationCell = T$1(({ subInfo, managedChild, listNavigation: ls, rovingTabIndex: { blurSelf: bs, focusSelf: fs, ...rti } }) => {
                //rti.hidden || rowHidden;
                const focusSelf = useStableCallback(() => {
                    console.log(`cell #${managedChild.index} focusSelf`);
                    setCurrentColumn(managedChild.index);
                    setTabbableIndex(managedChild.index, false);
                    if (fs)
                        fs();
                    else
                        rti_cell_ret.getElement()?.focus?.();
                });
                const blurSelf = useStableCallback(() => {
                    if (bs)
                        bs();
                    else
                        rti_cell_ret.getElement()?.blur?.();
                });
                const { useListNavigationChildProps, rovingTabIndex: rti_cell_ret } = useGridNavigationColumn2({
                    managedChild: managedChild,
                    listNavigation: { ...ls },
                    rovingTabIndex: { blurSelf, focusSelf, ...rti },
                    subInfo
                });
                const { useHasFocusProps } = useHasFocus({
                    onLastFocusedInnerChanged: useStableCallback((focused) => {
                        if (focused) {
                            setCurrentColumn(managedChild.index);
                            setTabbableIndex(managedChild.index, false);
                        }
                    })
                });
                const ret = {
                    gridNavigation: { getCurrentColumn },
                    rovingTabIndex: rti_cell_ret,
                    useGridNavigationCellProps: function (props) { return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props))); }
                };
                return ret;
            }, []);
            const ret = {
                asParentOfCells: {
                    linearNavigation: rowLsReturnType.linearNavigation,
                    listNavigation: rowLsReturnType.listNavigation,
                    managedChildren: rowLsReturnType.managedChildren,
                    rovingTabIndex: rowLsReturnType.rovingTabIndex,
                    typeaheadNavigation: rowLsReturnType.typeaheadNavigation,
                },
                asChildRow: rowLsChildReturnType,
                useGridNavigationCell,
                useGridNavigationRowProps: function (props) {
                    const ret = useListNavigationChildProps(props);
                    ret.tabIndex = -1;
                    return ret;
                }
            };
            return ret;
        }, []);
        return {
            gridNavigation: {
                getCurrentColumn,
                currentColumn
            },
            linearNavigation: parentLsReturnType.linearNavigation,
            listNavigation: parentLsReturnType.listNavigation,
            rovingTabIndex: parentLsReturnType.rovingTabIndex,
            typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
            managedChildren: parentLsReturnType.managedChildren,
            useGridNavigationRow,
            useGridNavigationProps: useListNavigationPropsAsGridParent,
        };
    }

    function useInterval({ interval, callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback);
        const getInterval = useStableGetter(interval);
        _(() => {
            const interval = getInterval();
            let lastDelayUsed = interval;
            if (interval == null)
                return;
            // Get a wrapper around the wrapper around the callback
            // that clears and resets the interval if it changes.
            const adjustableCallback = () => {
                stableCallback();
                const currentInterval = getInterval();
                if (currentInterval != lastDelayUsed) {
                    clearInterval(handle);
                    if (currentInterval != null)
                        handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
                }
            };
            let handle = setInterval(adjustableCallback, interval);
            return () => clearInterval(handle);
        }, []);
    }

    const DemoUseInterval = () => {
        const [interval, setInterval] = y(1000);
        const [fireCount, setFireCount] = y(0);
        useInterval({ interval, callback: () => setFireCount(i => ++i) });
        return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Interval duration: ", e$1("input", { type: "number", value: interval, onInput: e => setInterval(e.currentTarget.valueAsNumber) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const RovingChildContext = B(null);
    const DemoUseRovingTabIndex = g(() => {
        const [count, setCount] = useState(10);
        const [_lastFocusedInner, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner });
        //const forceUpdate = useForceUpdate();
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [tabbableIndex, setLocalTabbableIndex] = useState(0);
        /*const {
            indexDemangler,
            indexMangler,
            useSortableProps,
            shuffle
        } = useSortableChildren<HTMLUListElement, {}, string, [], number>({
            getIndex: useCallback((row) => row.index, []),
            getValue: useCallback((row) => row.index, []),
            compare: useCallback((lhs, rhs) => { return lhs - rhs; }, [])
        });*/
        const { managedChildren: { children }, useSortableListNavigationSingleSelectionChild, useSortableListNavigationSingleSelectionProps, rovingTabIndex: { setTabbableIndex }, typeaheadNavigation: { currentTypeahead }, sortableChildren: { shuffle }, } = useSortableListNavigationSingleSelection({
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: { onTabbableIndexChange: T$1((index) => { if (index != null)
                    setLocalTabbableIndex(index); }, []) },
            typeaheadNavigation: {},
            singleSelection: { selectedIndex }
        });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        return (e$1("div", { className: "demo", children: [e$1("h2", { children: "Keyboard & List Navigation" }), e$1("h3", { children: e$1("code", { children: "useRovingTabIndex" }) }), e$1("p", { children: ["Native HTML elements offer fantastic keyboard accessability, but cover a relatively limited number of use cases. There is no native HTML tree element, for example, that allows keyboard navigation of its items, nor is it possible to combine the keyboard navigation behavior of a ", e$1("code", { children: "<select>" }), " menu with the menu in a drawer component."] }), e$1("p", { children: ["When coming across a List or a Menu or a RadioGroup or a ToggleButtonGroup or any other \"one component made up of child components\", the usual expected behavior, at least natively, is that tabbing into the component is one action, and tabbing out is another.  Navigating ", e$1("em", { children: "within" }), " the component is done with the arrow keys or other methods."] }), e$1("p", { children: ["This is important both for accessability, but also just for general usability.  When tabbing back and forth, the ability to skip a long list without needing to trudge through ", e$1("em", { children: "every one" }), " of its child elements is extremely important."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " wraps up the functionality of a few hooks (", e$1("code", { children: "useRovingTabIndex" }), ", ", e$1("code", { children: "useLinearNavigation" }), ", ", e$1("code", { children: "useTypeaheadNavigation" }), ") to allow for ARIA-compliant navigation of lists and other similar components.  For more advanced use cases, you can use the other hooks individually."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " (and ", e$1("code", { children: "useRovingTabIndex" }), ") internally use ", e$1("code", { children: "useChildManager" }), ", which is how the child elements and the parent communicate with each other. This means there are virtually no restrictions on how the DOM is set up as long as you can provide the children with the ", e$1("code", { children: "useListNavigationChild" }), " hook that's returned, usually with a simple ", e$1("code", { children: "Context" }), ". If the child element itself has a focusable element, like a button, it can also be wired up to disable itself Feel free to nest them too, as long as you are aware of your ", e$1("code", { children: "Context" }), " management (i.e. remember that you need to create a new ", e$1("code", { children: "Context" }), " for each use case)."] }), e$1("label", { children: ["# of items", e$1("input", { type: "number", value: count, min: 0, onInput: e => { e.preventDefault(); setCount(e.currentTarget.valueAsNumber); } })] }), e$1("button", { onClick: () => shuffle(children), children: "Shuffle" }), e$1("label", { children: ["Tabbable index: ", e$1("input", { type: "number", value: tabbableIndex ?? undefined, onInput: e => { e.preventDefault(); setTabbableIndex(e.currentTarget.valueAsNumber, false); } })] }), e$1(RovingChildContext.Provider, { value: useSortableListNavigationSingleSelectionChild, children: e$1("ul", { ...useHasFocusProps(useSortableListNavigationSingleSelectionProps({
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield e$1(DemoUseRovingTabIndexChild, { index: i, setSelectedIndex: setSelectedIndex }, i);
                                }
                            })())
                        })) }) }), currentTypeahead && e$1("div", { children: ["Typeahead: ", currentTypeahead] })] }));
    });
    const DemoUseRovingTabIndexChild = g((({ index, setSelectedIndex }) => {
        const hidden = (index == 7);
        const [randomWord] = useState(() => RandomWords$1[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useRovingTabIndexChild = q$1(RovingChildContext);
        const text = `${randomWord} This is item #${index}${hidden ? " (hidden)" : ""}`;
        const { useListNavigationSingleSelectionChildProps, rovingTabIndex: { tabbable }, singleSelection: { selected } } = useRovingTabIndexChild({ managedChild: { index }, listNavigation: { text }, rovingTabIndex: { hidden }, subInfo: {} });
        const props = useListNavigationSingleSelectionChildProps({});
        return (e$1("li", { ...props, onClick: () => setSelectedIndex(index), children: [text, " (", tabbable ? "Tabbable" : "Not tabbable", ", ", selected ? "Selected" : "Not selected", ")", e$1("input", { ...useListNavigationSingleSelectionChildProps({ type: "number" }), style: { width: "5ch" } })] }));
    }));

    const DemoUseTimeout = () => {
        const [timeout, setTimeout] = y(1000);
        const [triggerIndex, setTriggerIndex] = y("");
        const [fireCount, setFireCount] = y(0);
        useTimeout({ timeout, triggerIndex, callback: () => setFireCount(i => ++i) });
        return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Timeout duration: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Refresh key: ", e$1("input", { type: "text", value: triggerIndex, onInput: e => setTriggerIndex(e.currentTarget.value) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const DemoUseDroppable = () => {
        const { droppedFiles, droppedStrings, filesForConsideration, stringsForConsideration, useDroppableProps, dropError } = useDroppable({ effect: "copy" });
        useMergedProps({}, { ref: s(null) });
        const p = useDroppableProps({ className: "demo droppable" });
        return (e$1("div", { ...p, children: [droppedStrings != null && e$1("div", { children: ["Data dropped: ", e$1("ul", { children: Object.entries(droppedStrings).map(([type, value]) => e$1("li", { children: [type, ": ", value] })) })] }), droppedFiles != null && e$1("div", { children: ["Files dropped: ", e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Name" }), e$1("th", { children: "Size" }), e$1("th", { children: "Type" }), e$1("th", { children: "Last modified" })] }) }), e$1("tbody", { children: droppedFiles.map(f => e$1("tr", { children: [e$1("td", { children: f.name }), f.data.byteLength, e$1("td", { children: f.type }), e$1("td", { children: new Date(f.lastModified ?? 0) })] })) })] })] }), e$1("hr", {}), stringsForConsideration != null && e$1("div", { children: ["Data being considered: ", e$1("ul", { children: Array.from(stringsForConsideration).map(type => e$1("li", { children: type })) })] }), filesForConsideration != null && e$1("div", { children: ["Files being considered: ", e$1("ul", { children: filesForConsideration.map(f => e$1("li", { children: JSON.stringify(f) })) })] }), e$1("hr", {}), dropError && e$1("div", { children: dropError instanceof Error ? dropError.message : JSON.stringify(dropError) })] }));
    };
    const DemoUseDraggable = () => {
        const { useDraggableProps } = useDraggable({ data: { "text/plain": "This is custom draggable content of type text/plain." } });
        return (e$1("div", { ...useDraggableProps({ className: "demo" }), children: "Draggable content" }));
    };
    const DemoUseElementSizeAnimation = () => {
        const [height, setHeight] = useState(0);
        const [angle, setAngle] = useState(0);
        useAnimationFrame({
            callback: (_ms) => {
                setAngle(a => a + 0.01);
                setHeight((Math.sin(angle) + 1) / 0.5);
            }
        });
        const [elementSize, setElementSize] = useState(null);
        const { useElementSizeProps } = useElementSize({ onSizeChange: setElementSize });
        return (e$1("div", { ...useElementSizeProps({ ref: undefined, className: "demo", style: { height: `${(height * 100) + 100}px` } }), children: e$1("pre", { children: JSON.stringify(elementSize, null, 2) }) }));
    };
    const DemoUseFocusTrap = g(({ depth }) => {
        const [active, setActive] = useState(false);
        const { useFocusTrapProps } = useFocusTrap({ trapActive: active });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        const divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return e$1("div", {});
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), e$1("div", { ...divProps, children: e$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
    });
    const DemoUseFocusTrapChild = g(({ setActive, active }) => {
        return (e$1(p$1, { children: [e$1("button", { children: "Button 1" }), e$1("button", { children: "Button 2" }), e$1("button", { children: "Button 3" }), e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
    });
    const DemoUseAsyncHandler1 = g(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const asyncOnClick = ((_v, _e) => new Promise((resolve, reject) => window.setTimeout(() => getShouldThrow() ? reject() : resolve(), timeout)));
        const { callCount, settleCount, hasCapture, syncHandler, pending, hasError, rejectCount, resolveCount } = useAsyncHandler(asyncOnClick, { capture: () => { }, debounce: debounce == 0 ? undefined : debounce });
        const onClick = pending ? undefined : syncHandler;
        return (e$1("div", { className: "demo", children: [e$1("button", { disabled: pending && disableConsecutive, onClick: onClick, children: "Click me!" }), e$1("label", { children: ["Sleep for: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Throw an error ", e$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), e$1("label", { children: ["Disabled while pending ", e$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), e$1("label", { children: ["Debounce: ", e$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Field" }), e$1("th", { children: "Value" })] }) }), e$1("tbody", { children: [e$1("tr", { children: [e$1("td", { children: "callCount" }), e$1("td", { children: callCount })] }), e$1("tr", { children: [e$1("td", { children: "settleCount" }), e$1("td", { children: settleCount })] }), e$1("tr", { children: [e$1("td", { children: "resolveCount" }), e$1("td", { children: resolveCount })] }), e$1("tr", { children: [e$1("td", { children: "rejectCount" }), e$1("td", { children: rejectCount })] }), e$1("tr", { children: [e$1("td", { children: "hasError" }), e$1("td", { children: hasError.toString() })] }), e$1("tr", { children: [e$1("td", { children: "hasCapture" }), e$1("td", { children: hasCapture.toString() })] })] })] })] }));
    });
    const DemoUseAsyncHandler2 = g(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const [text, setText] = useState("");
        const onInputAsync = async (v, _e) => new Promise((resolve, reject) => window.setTimeout(() => {
            if (getShouldThrow()) {
                reject();
            }
            else {
                setText(v);
                resolve();
            }
        }, timeout));
        const { callCount, settleCount, hasCapture, syncHandler, currentCapture, pending, hasError, rejectCount, resolveCount } = useAsyncHandler(onInputAsync, { capture: (e) => { e.preventDefault(); return e.currentTarget.value; }, debounce: debounce == 0 ? undefined : debounce });
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Demo text: ", e$1("input", { value: hasCapture ? currentCapture : text, disabled: pending && disableConsecutive, onInput: syncHandler })] }), e$1("hr", {}), e$1("label", { children: ["Sleep for: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Throw an error ", e$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), e$1("label", { children: ["Disabled while pending ", e$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), e$1("label", { children: ["Debounce: ", e$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Field" }), e$1("th", { children: "Value" })] }) }), e$1("tbody", { children: [e$1("tr", { children: [e$1("td", { children: "callCount" }), e$1("td", { children: callCount })] }), e$1("tr", { children: [e$1("td", { children: "settleCount" }), e$1("td", { children: settleCount })] }), e$1("tr", { children: [e$1("td", { children: "resolveCount" }), e$1("td", { children: resolveCount })] }), e$1("tr", { children: [e$1("td", { children: "rejectCount" }), e$1("td", { children: rejectCount })] }), e$1("tr", { children: [e$1("td", { children: "hasError" }), e$1("td", { children: hasError.toString() })] }), e$1("tr", { children: [e$1("td", { children: "currentCapture" }), e$1("td", { children: currentCapture })] }), e$1("tr", { children: [e$1("td", { children: "\"Saved\" input" }), e$1("td", { children: text })] })] })] })] }));
    });
    const DemoFocus = g(() => {
        const [lastActiveElement, setLastActiveElement] = useState(null);
        const [activeElement, setActiveElement] = useState(null);
        const [windowFocused, setWindowFocused] = useState(false);
        const [focused, setFocused] = useState(false);
        const [focusedInner, setFocusedInner] = useState(false);
        const [lastFocused, setLastFocused] = useState(false);
        const [lastFocusedInner, setLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({
            onFocusedChanged: setFocused,
            onFocusedInnerChanged: setFocusedInner,
            onLastFocusedChanged: setLastFocused,
            onLastFocusedInnerChanged: setLastFocusedInner,
            onActiveElementChange: setActiveElement,
            onLastActiveElementChange: setLastActiveElement,
            onWindowFocusedChange: setWindowFocused
        });
        return (e$1("div", { class: "demo", children: [e$1("h2", { children: "useHasFocus" }), e$1("div", { ...useHasFocusProps({ style: { border: "1px solid black" }, tabIndex: 0 }), children: ["Outer ", e$1("div", { tabIndex: 0, style: { border: "1px solid black" }, children: "Inner element" })] }), e$1("div", { children: e$1("ul", { children: [e$1("li", { children: ["Strictly focused: ", focused.toString(), ", ", lastFocused.toString()] }), e$1("li", { children: ["Inner focused: ", focusedInner.toString(), ", ", lastFocusedInner.toString()] }), e$1("li", { children: ["Window focused: ", windowFocused.toString()] }), e$1("li", { children: ["activeElement: ", activeElement?.textContent] }), e$1("li", { children: ["lastActiveElement: ", lastActiveElement?.textContent] })] }) })] }));
    });
    const GridRowContext = B(null);
    const GridCellContext = B(null);
    const DemoUseGrid = g(() => {
        const [, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner });
        const { useGridNavigationRow, useGridNavigationProps, gridNavigation: { currentColumn } } = useGridNavigation({
            rovingTabIndex: {},
            linearNavigation: {},
            listNavigation: {},
            typeaheadNavigation: {},
            managedChildren: {}
        });
        return (e$1("div", { class: "demo", children: [e$1("div", { children: ["Current column: ", currentColumn] }), e$1("table", { ...{ border: "2" }, style: { whiteSpace: "nowrap" }, children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Row is tabbable?" }), e$1("th", { children: "Column 1" }), e$1("th", { children: "Column 2" })] }) }), e$1("tbody", { ...useHasFocusProps(useGridNavigationProps({})), children: e$1(GridRowContext.Provider, { value: useGridNavigationRow, children: Array.from((function* () {
                                    for (let i = 0; i < 10; ++i) {
                                        yield e$1(DemoUseGridRow, { index: i }, i);
                                    }
                                })()) }) })] })] }));
    });
    const DemoUseGridRow = g((({ index }) => {
        useState(() => RandomWords[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useGridRow = q$1(GridRowContext);
        const { useGridNavigationRowProps, useGridNavigationCell, asChildRow: { rovingTabIndex: { tabbable } }, } = useGridRow({
            asChildRowOfSection: { managedChild: { index }, listNavigation: { text: "" }, rovingTabIndex: { hidden: index == 3 }, subInfo: {} },
            asParentRowOfCells: { linearNavigation: {}, listNavigation: {}, rovingTabIndex: {}, typeaheadNavigation: {}, managedChildren: {} },
        });
        const props = useGridNavigationRowProps({});
        return (e$1("tr", { ...props, children: e$1(GridCellContext.Provider, { value: useGridNavigationCell, children: Array.from((function* () {
                    for (let i = 0; i < 3; ++i) {
                        yield e$1(DemoUseGridCell, { index: i, row: index, rowIsTabbable: tabbable }, i);
                    }
                })()) }) }));
    }));
    const DemoUseGridCell = (({ index, row, rowIsTabbable }) => {
        if (row >= 6 && row % 2 == 0 && index > 1)
            return null;
        let hiddenText = (row === 3) ? " (row hidden)" : "";
        const useGridCell = q$1(GridCellContext);
        const { useGridNavigationCellProps, rovingTabIndex: { tabbable: cellIsTabbable } } = useGridCell({
            listNavigation: { text: "" },
            managedChild: { index },
            rovingTabIndex: { hidden: false },
            subInfo: {},
        });
        const props = useGridNavigationCellProps({});
        const t = (cellIsTabbable ? "(Tabbable)" : "(Not tabbable)");
        if (index === 0)
            return e$1("td", { ...props, children: rowIsTabbable.toString() });
        else {
            if (row < 6 || row % 2 != 0) {
                if (index === 1)
                    return e$1("td", { ...props, children: ["Grid cell #", index + 1, " ", t, hiddenText] });
                else
                    return e$1("td", { children: e$1("label", { children: [e$1("input", { ...props, type: "checkbox" }), " Test input ", t, hiddenText] }) });
            }
            else {
                if (index === 1)
                    return e$1("td", { ...props, colSpan: 2, children: ["Grid cell #", index + 1, ", span 2 ", t, hiddenText] });
                else
                    return null;
            }
        }
    });
    const Component = () => {
        return e$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [e$1(DemoFocus, {}), e$1("hr", {}), e$1(DemoUseGrid, {}), e$1("hr", {}), e$1(DemoUseTimeout, {}), e$1("hr", {}), e$1(DemoUseInterval, {}), e$1("hr", {}), e$1(DemoUseRovingTabIndex, {}), e$1("hr", {}), e$1(DemoUseFocusTrap, {}), e$1("hr", {}), e$1(DemoUseAsyncHandler1, {}), e$1("hr", {}), e$1(DemoUseAsyncHandler2, {}), e$1("hr", {}), e$1(DemoUseDroppable, {}), e$1("hr", {}), e$1(DemoUseDraggable, {}), e$1("hr", {}), e$1(DemoUseElementSizeAnimation, {}), e$1("hr", {}), e$1("input", {})] });
    };
    requestAnimationFrame(() => {
        P$1(e$1(Component, {}), document.getElementById("root"));
    });

    exports.DemoUseGrid = DemoUseGrid;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwiLi4vc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub3cuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190cmltbWVkRW5kSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVHJpbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9OdW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2RlYm91bmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90aHJvdHRsZS5qcyIsIi4uL3NyYy91c2Utc3RhdGUudHN4IiwiLi4vc3JjL3VzZS1hc3luYy50c3giLCIuLi9zcmMvdXNlLWFzeW5jLWhhbmRsZXIudHN4IiwiLi4vc3JjL3VzZS1lZmZlY3QudHN4IiwiLi4vc3JjL3VzZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9zcmMvdXNlLWRvY3VtZW50LWNsYXNzLnRzeCIsIi4uL3NyYy91c2UtZHJhZ2dhYmxlLnRzeCIsIi4uL3NyYy91c2UtZHJvcHBhYmxlLnRzeCIsIi4uL3NyYy91c2UtZWxlbWVudC1zaXplLnRzeCIsIi4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL3NyYy91c2UtYmxvY2tpbmctZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWZvY3VzLXRyYXAudHN4IiwiLi4vc3JjL3VzZS1mb3JjZS11cGRhdGUudHN4IiwiLi4vc3JjL3VzZS1oYXMtZm9jdXMudHN4IiwiLi4vc3JjL3VzZS1sb2dpY2FsLWRpcmVjdGlvbi50c3giLCIuLi9zcmMvdXNlLXRpbWVvdXQudHN4IiwiLi4vc3JjL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2Utcm92aW5nLXRhYmluZGV4LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3ZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zaHVmZmxlLmpzIiwiLi4vc3JjL3VzZS1zb3J0YWJsZS1jaGlsZHJlbi50c3giLCIuLi9zcmMvdXNlLWxpc3QtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLWdyaWQtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLWludGVydmFsLnRzeCIsImRlbW9zL3VzZS1pbnRlcnZhbC50c3giLCJkZW1vcy91c2Utcm92aW5nLXRhYi1pbmRleC50c3giLCJkZW1vcy91c2UtdGltZW91dC50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbi8qKlxuICogRW5xdWV1ZSBhIHJlcmVuZGVyIG9mIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYyBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGMpIHtcblx0aWYgKFxuXHRcdCghYy5fZGlydHkgJiZcblx0XHRcdChjLl9kaXJ0eSA9IHRydWUpICYmXG5cdFx0XHRyZXJlbmRlclF1ZXVlLnB1c2goYykgJiZcblx0XHRcdCFwcm9jZXNzLl9yZXJlbmRlckNvdW50KyspIHx8XG5cdFx0cHJldkRlYm91bmNlICE9PSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nXG5cdCkge1xuXHRcdHByZXZEZWJvdW5jZSA9IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmc7XG5cdFx0KHByZXZEZWJvdW5jZSB8fCBzZXRUaW1lb3V0KShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBxdWV1ZTtcblx0d2hpbGUgKChwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gcmVyZW5kZXJRdWV1ZS5sZW5ndGgpKSB7XG5cdFx0cXVldWUgPSByZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdFx0cmVyZW5kZXJRdWV1ZSA9IFtdO1xuXHRcdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHRcdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdFx0cXVldWUuc29tZShjID0+IHtcblx0XHRcdGlmIChjLl9kaXJ0eSkgcmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdH0pO1xuXHR9XG59XG5wcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY29udGV4dElkKSB7XG5cdGNvbnRleHRJZCA9ICdfX2NDJyArIGkrKztcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogY29udGV4dElkLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdENvbnN1bWVyKHByb3BzLCBjb250ZXh0VmFsdWUpIHtcblx0XHRcdC8vIHJldHVybiBwcm9wcy5jaGlsZHJlbihcblx0XHRcdC8vIFx0Y29udGV4dFtjb250ZXh0SWRdID8gY29udGV4dFtjb250ZXh0SWRdLnByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlXG5cdFx0XHQvLyApO1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHRWYWx1ZSk7XG5cdFx0fSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdFByb3ZpZGVyKHByb3BzKSB7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0Q2hpbGRDb250ZXh0KSB7XG5cdFx0XHRcdGxldCBzdWJzID0gW107XG5cdFx0XHRcdGxldCBjdHggPSB7fTtcblx0XHRcdFx0Y3R4W2NvbnRleHRJZF0gPSB0aGlzO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gY3R4O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24oX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGVucXVldWVSZW5kZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwgfHwgdHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gIT0gbnVsbCAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tID09IG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIG5ld1BhcmVudFZOb2RlLl9fbmV4dERvbSBwb2ludHMgdG8gYSBkb20gbm9kZSB0aGF0IGlzIGFib3V0IHRvXG5cdFx0XHRcdC8vIGJlIHVubW91bnRlZCwgdGhlbiBnZXQgdGhlIG5leHQgc2libGluZyBvZiB0aGF0IHZub2RlIGFuZCBzZXRcblx0XHRcdFx0Ly8gX25leHREb20gdG8gaXRcblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBnZXREb21TaWJsaW5nKG9sZFBhcmVudFZOb2RlLCBpICsgMSk7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0dm5vZGUsXG5cdFx0XHRcdFx0dm5vZGUsXG5cdFx0XHRcdFx0Yyxcblx0XHRcdFx0XHR2bm9kZS5fZG9tLFxuXHRcdFx0XHRcdG9sZERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAyXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG4iLCJpbXBvcnQgeyBJU19OT05fRElNRU5TSU9OQUwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0aGUgb2xkIGFuZCBuZXcgcHJvcGVydGllcyBvZiBhIFZOb2RlIGFuZCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBhcHBseVxuICogY2hhbmdlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFRoZSBuZXcgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBUaGUgb2xkIHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBoeWRyYXRlIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb24gbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaHlkcmF0ZSkge1xuXHRsZXQgaTtcblxuXHRmb3IgKGkgaW4gb2xkUHJvcHMpIHtcblx0XHRpZiAoaSAhPT0gJ2NoaWxkcmVuJyAmJiBpICE9PSAna2V5JyAmJiAhKGkgaW4gbmV3UHJvcHMpKSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG51bGwsIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpIGluIG5ld1Byb3BzKSB7XG5cdFx0aWYgKFxuXHRcdFx0KCFoeWRyYXRlIHx8IHR5cGVvZiBuZXdQcm9wc1tpXSA9PSAnZnVuY3Rpb24nKSAmJlxuXHRcdFx0aSAhPT0gJ2NoaWxkcmVuJyAmJlxuXHRcdFx0aSAhPT0gJ2tleScgJiZcblx0XHRcdGkgIT09ICd2YWx1ZScgJiZcblx0XHRcdGkgIT09ICdjaGVja2VkJyAmJlxuXHRcdFx0b2xkUHJvcHNbaV0gIT09IG5ld1Byb3BzW2ldXG5cdFx0KSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG5ld1Byb3BzW2ldLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwga2V5LCB2YWx1ZSkge1xuXHRpZiAoa2V5WzBdID09PSAnLScpIHtcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3R5bGVba2V5XSA9ICcnO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJyB8fCBJU19OT05fRElNRU5TSU9OQUwudGVzdChrZXkpKSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZSArICdweCc7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSB2YWx1ZSBvbiBhIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIG1vZGlmeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBwcm9wZXJ0eSB0b1xuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIHRoZSBwcm9wZXJ0eSBoYWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5KGRvbSwgbmFtZSwgdmFsdWUsIG9sZFZhbHVlLCBpc1N2Zykge1xuXHRsZXQgdXNlQ2FwdHVyZTtcblxuXHRvOiBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRWYWx1ZSA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2xkVmFsdWUpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIG9sZFZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCEodmFsdWUgJiYgbmFtZSBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKGRvbS5zdHlsZSwgbmFtZSwgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCFvbGRWYWx1ZSB8fCB2YWx1ZVtuYW1lXSAhPT0gb2xkVmFsdWVbbmFtZV0pIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKGRvbS5zdHlsZSwgbmFtZSwgdmFsdWVbbmFtZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBCZW5jaG1hcmsgZm9yIGNvbXBhcmlzb246IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNTc0Yzk1NGJkYjk2NWI5YTAwOTY1YWM2XG5cdGVsc2UgaWYgKG5hbWVbMF0gPT09ICdvJyAmJiBuYW1lWzFdID09PSAnbicpIHtcblx0XHR1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcblxuXHRcdC8vIEluZmVyIGNvcnJlY3QgY2FzaW5nIGZvciBET00gYnVpbHQtaW4gZXZlbnRzOlxuXHRcdGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgaW4gZG9tKSBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpO1xuXHRcdGVsc2UgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG5cblx0XHRpZiAoIWRvbS5fbGlzdGVuZXJzKSBkb20uX2xpc3RlbmVycyA9IHt9O1xuXHRcdGRvbS5fbGlzdGVuZXJzW25hbWUgKyB1c2VDYXB0dXJlXSA9IHZhbHVlO1xuXG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRpZiAoIW9sZFZhbHVlKSB7XG5cdFx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSAhPT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJykge1xuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0Ly8gTm9ybWFsaXplIGluY29ycmVjdCBwcm9wIHVzYWdlIGZvciBTVkc6XG5cdFx0XHQvLyAtIHhsaW5rOmhyZWYgLyB4bGlua0hyZWYgLS0+IGhyZWYgKHhsaW5rOmhyZWYgd2FzIHJlbW92ZWQgZnJvbSBTVkcgYW5kIGlzbid0IG5lZWRlZClcblx0XHRcdC8vIC0gY2xhc3NOYW1lIC0tPiBjbGFzc1xuXHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZSgveGxpbmsoSHw6aCkvLCAnaCcpLnJlcGxhY2UoL3NOYW1lJC8sICdzJyk7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHZhbHVlICE9IG51bGwgJiZcblx0XHRcdCh2YWx1ZSAhPT0gZmFsc2UgfHwgKG5hbWVbMF0gPT09ICdhJyAmJiBuYW1lWzFdID09PSAncicpKVxuXHRcdCkge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkgYy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4uZm9yRWFjaCh2bm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUpIHZub2RlLl9wYXJlbnQgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkgYXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KHJbaV0sIHBhcmVudFZOb2RlLCB0eXBlb2Ygdm5vZGUudHlwZSAhPSAnZnVuY3Rpb24nKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSByZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG9iamVjdH0gW3JlcGxhY2VOb2RlXSBPcHRpb25hbDogQXR0ZW1wdCB0byByZS11c2UgYW5cbiAqIGV4aXN0aW5nIERPTSB0cmVlIHJvb3RlZCBhdCBgcmVwbGFjZU5vZGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudERvbSwgcmVwbGFjZU5vZGUpIHtcblx0aWYgKG9wdGlvbnMuX3Jvb3QpIG9wdGlvbnMuX3Jvb3Qodm5vZGUsIHBhcmVudERvbSk7XG5cblx0Ly8gV2UgYWJ1c2UgdGhlIGByZXBsYWNlTm9kZWAgcGFyYW1ldGVyIGluIGBoeWRyYXRlKClgIHRvIHNpZ25hbCBpZiB3ZSBhcmUgaW5cblx0Ly8gaHlkcmF0aW9uIG1vZGUgb3Igbm90IGJ5IHBhc3NpbmcgdGhlIGBoeWRyYXRlYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIGEgRE9NXG5cdC8vIGVsZW1lbnQuLlxuXHRsZXQgaXNIeWRyYXRpbmcgPSB0eXBlb2YgcmVwbGFjZU5vZGUgPT09ICdmdW5jdGlvbic7XG5cblx0Ly8gVG8gYmUgYWJsZSB0byBzdXBwb3J0IGNhbGxpbmcgYHJlbmRlcigpYCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZVxuXHQvLyBET00gbm9kZSwgd2UgbmVlZCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIHRyZWUuIFdlIGRvXG5cdC8vIHRoaXMgYnkgYXNzaWduaW5nIGEgbmV3IGBfY2hpbGRyZW5gIHByb3BlcnR5IHRvIERPTSBub2RlcyB3aGljaCBwb2ludHNcblx0Ly8gdG8gdGhlIGxhc3QgcmVuZGVyZWQgdHJlZS4gQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50LCB3aGljaFxuXHQvLyBtZWFucyB0aGF0IHdlIGFyZSBtb3VudGluZyBhIG5ldyB0cmVlIGZvciB0aGUgZmlyc3QgdGltZS5cblx0bGV0IG9sZFZOb2RlID0gaXNIeWRyYXRpbmdcblx0XHQ/IG51bGxcblx0XHQ6IChyZXBsYWNlTm9kZSAmJiByZXBsYWNlTm9kZS5fY2hpbGRyZW4pIHx8IHBhcmVudERvbS5fY2hpbGRyZW47XG5cblx0dm5vZGUgPSAoXG5cdFx0KCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZSkgfHxcblx0XHRwYXJlbnREb21cblx0KS5fY2hpbGRyZW4gPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHR2bm9kZSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkXG5cdFx0XHQ/IHNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IHJlcGxhY2VOb2RlXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG9sZFZOb2RlLl9kb21cblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGQsXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBoeWRyYXRlKTtcbn1cbiIsIi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gW29sZFZOb2RlXVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuRXJyb3JJbmZvfSBbZXJyb3JJbmZvXVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCwgY3RvciwgaGFuZGxlZDtcblxuXHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5fcHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcblxuXHRcdFx0XHRpZiAoY3RvciAmJiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNldFN0YXRlKGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyB8fCB7fSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIGVycm9yIGJvdW5kYXJ5LiBNYXJrIGl0IGFzIGhhdmluZyBiYWlsZWQgb3V0LCBhbmQgd2hldGhlciBpdCB3YXMgbWlkLWh5ZHJhdGlvbi5cblx0XHRcdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGNvbXBvbmVudC5fcGVuZGluZ0Vycm9yID0gY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdwcmVhY3QnKS5WTm9kZX0gVk5vZGUgKi9cblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoaXMgZmlsZSBleHBvcnRzIHZhcmlvdXMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBCYWJlbCdzIFwiYXV0b21hdGljXCIgSlNYIHJ1bnRpbWUgQVBJOlxuICogLSBqc3godHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4cyh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgX19zb3VyY2UsIF9fc2VsZilcbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgY3JlYXRlVk5vZGUgaGVyZSBpcyBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlLlxuICogQmVuY2htYXJrczogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81ZjZiNTRhMGI0NjMyMTAwYTdkY2QyYjNcbiAqL1xuXG4vKipcbiAqIEpTWC5FbGVtZW50IGZhY3RvcnkgdXNlZCBieSBCYWJlbCdzIHtydW50aW1lOlwiYXV0b21hdGljXCJ9IEpTWCB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7Vk5vZGVbJ3R5cGUnXX0gdHlwZVxuICogQHBhcmFtIHtWTm9kZVsncHJvcHMnXX0gcHJvcHNcbiAqIEBwYXJhbSB7Vk5vZGVbJ2tleSddfSBba2V5XVxuICogQHBhcmFtIHtzdHJpbmd9IFtfX3NlbGZdXG4gKiBAcGFyYW0ge3N0cmluZ30gW19fc291cmNlXVxuICovXG5mdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCBfX3NlbGYsIF9fc291cmNlKSB7XG5cdC8vIFdlJ2xsIHdhbnQgdG8gcHJlc2VydmUgYHJlZmAgaW4gcHJvcHMgdG8gZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3Jcblx0Ly8gZm9yd2FyZFJlZiBjb21wb25lbnRzIGluIHRoZSBmdXR1cmUsIGJ1dCB0aGF0IHNob3VsZCBoYXBwZW4gdmlhXG5cdC8vIGEgc2VwYXJhdGUgUFIuXG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ3JlZicpIHtcblx0XHRcdHJlZiA9IHByb3BzW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzOiBub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogLS12bm9kZUlkLFxuXHRcdF9fc291cmNlLFxuXHRcdF9fc2VsZlxuXHR9O1xuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wcy5cblx0Ly8gTm90ZTogYHR5cGVgIGlzIG9mdGVuIGEgU3RyaW5nLCBhbmQgY2FuIGJlIGB1bmRlZmluZWRgIGluIGRldmVsb3BtZW50LlxuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgKHJlZiA9IHR5cGUuZGVmYXVsdFByb3BzKSkge1xuXHRcdGZvciAoaSBpbiByZWYpXG5cdFx0XHRpZiAodHlwZW9mIG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcmVmW2ldO1xuXHRcdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCB7XG5cdGNyZWF0ZVZOb2RlIGFzIGpzeCxcblx0Y3JlYXRlVk5vZGUgYXMganN4cyxcblx0Y3JlYXRlVk5vZGUgYXMganN4REVWLFxuXHRGcmFnbWVudFxufTtcbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SW5kZXg7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IHByZXZpb3VzQ29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgRU1QVFkgPSBbXTtcblxubGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xubGV0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbmxldCBvbGRBZnRlckRpZmYgPSBvcHRpb25zLmRpZmZlZDtcbmxldCBvbGRDb21taXQgPSBvcHRpb25zLl9jb21taXQ7XG5sZXQgb2xkQmVmb3JlVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcblxuY29uc3QgUkFGX1RJTUVPVVQgPSAxMDA7XG5sZXQgcHJldlJhZjtcblxub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihob29rU3RhdGUuX3ZhbHVlWzBdLCBhY3Rpb24pO1xuXHRcdFx0XHRpZiAoaG9va1N0YXRlLl92YWx1ZVswXSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA0KTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG5cdGN1cnJlbnRIb29rID0gNTtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLCBbXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJlZlxuICogQHBhcmFtIHsoKSA9PiBvYmplY3R9IGNyZWF0ZUhhbmRsZVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZUhhbmRsZSwgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDY7XG5cdHVzZUxheW91dEVmZmVjdChcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJlZihjcmVhdGVIYW5kbGUoKSk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiByZWYobnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZikge1xuXHRcdFx0XHRyZWYuY3VycmVudCA9IGNyZWF0ZUhhbmRsZSgpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcmdzID09IG51bGwgPyBhcmdzIDogYXJncy5jb25jYXQocmVmKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmYWN0b3J5XG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKGZhY3RvcnksIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5NZW1vSG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNyk7XG5cdGlmIChhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fcGVuZGluZ1ZhbHVlID0gZmFjdG9yeSgpO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cdFx0c3RhdGUuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdHJldHVybiBzdGF0ZS5fcGVuZGluZ1ZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbnRleHRIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA5KTtcblx0Ly8gVGhlIGRldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3QgdG9cblx0Ly8gYmUgYWJsZSB0byBwdWxsIG9mIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gbm8gcHJvdmlkZXJcblx0Ly8gaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cblx0c3RhdGUuX2NvbnRleHQgPSBjb250ZXh0O1xuXHRpZiAoIXByb3ZpZGVyKSByZXR1cm4gY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuXHQvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCBzYWZlIHRvIGNvbnZlcnQgdG8gXCIhXCJcblx0aWYgKHN0YXRlLl92YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gdHJ1ZTtcblx0XHRwcm92aWRlci5zdWIoY3VycmVudENvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHByb3ZpZGVyLnByb3BzLnZhbHVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYSBjdXN0b20gbGFiZWwgZm9yIGEgY3VzdG9tIGhvb2sgZm9yIHRoZSBkZXZ0b29scyBwYW5lbFxuICogQHR5cGUgezxUPih2YWx1ZTogVCwgY2I/OiAodmFsdWU6IFQpID0+IHN0cmluZyB8IG51bWJlcikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlcikge1xuXHRpZiAob3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKSB7XG5cdFx0b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyhlcnJvcjogYW55KSA9PiB2b2lkfSBjYlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeShjYikge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVycm9yQm91bmRhcnlIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSBlcnIgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVycik7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSkgY29udGludWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH1cbn1cblxubGV0IEhBU19SQUYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogU2NoZWR1bGUgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBicm93c2VyIGhhcyBhIGNoYW5jZSB0byBwYWludCBhIG5ldyBmcmFtZS5cbiAqIERvIHRoaXMgYnkgY29tYmluaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSAockFGKSArIHNldFRpbWVvdXQgdG8gaW52b2tlIGEgY2FsbGJhY2sgYWZ0ZXJcbiAqIHRoZSBuZXh0IGJyb3dzZXIgZnJhbWUuXG4gKlxuICogQWxzbywgc2NoZWR1bGUgYSB0aW1lb3V0IGluIHBhcmFsbGVsIHRvIHRoZSB0aGUgckFGIHRvIGVuc3VyZSB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZFxuICogZXZlbiBpZiBSQUYgZG9lc24ndCBmaXJlIChmb3IgZXhhbXBsZSBpZiB0aGUgYnJvd3NlciB0YWIgaXMgbm90IHZpc2libGUpXG4gKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBhZnRlck5leHRGcmFtZShjYWxsYmFjaykge1xuXHRjb25zdCBkb25lID0gKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRpZiAoSEFTX1JBRikgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrKTtcblx0fTtcblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZG9uZSwgUkFGX1RJTUVPVVQpO1xuXG5cdGxldCByYWY7XG5cdGlmIChIQVNfUkFGKSB7XG5cdFx0cmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvbmUpO1xuXHR9XG59XG5cbi8vIE5vdGU6IGlmIHNvbWVvbmUgdXNlZCBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuLy8gdGhlbiBlZmZlY3RzIHdpbGwgQUxXQVlTIHJ1biBvbiB0aGUgTkVYVCBmcmFtZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZSwgaW5jdXJyaW5nIGEgfjE2bXMgZGVsYXkuXG4vLyBQZXJoYXBzIHRoaXMgaXMgbm90IHN1Y2ggYSBiaWcgZGVhbC5cbi8qKlxuICogU2NoZWR1bGUgYWZ0ZXJQYWludEVmZmVjdHMgZmx1c2ggYWZ0ZXIgdGhlIGJyb3dzZXIgcGFpbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3UXVldWVMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJQYWludChuZXdRdWV1ZUxlbmd0aCkge1xuXHRpZiAobmV3UXVldWVMZW5ndGggPT09IDEgfHwgcHJldlJhZiAhPT0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRwcmV2UmFmID0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0KHByZXZSYWYgfHwgYWZ0ZXJOZXh0RnJhbWUpKGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2xlYW51cChob29rKSB7XG5cdC8vIEEgaG9vayBjbGVhbnVwIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGxldCBjbGVhbnVwID0gaG9vay5fY2xlYW51cDtcblx0aWYgKHR5cGVvZiBjbGVhbnVwID09ICdmdW5jdGlvbicpIHtcblx0XHRob29rLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogTWVtb2l6ZSBhIGNvbXBvbmVudCwgc28gdGhhdCBpdCBvbmx5IHVwZGF0ZXMgd2hlbiB0aGUgcHJvcHMgYWN0dWFsbHkgaGF2ZVxuICogY2hhbmdlZC4gVGhpcyB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgUmVhY3QucHVyZWAuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSBjIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gKiBAcGFyYW0geyhwcmV2OiBvYmplY3QsIG5leHQ6IG9iamVjdCkgPT4gYm9vbGVhbn0gW2NvbXBhcmVyXSBDdXN0b20gZXF1YWxpdHkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW8oYywgY29tcGFyZXIpIHtcblx0ZnVuY3Rpb24gc2hvdWxkVXBkYXRlKG5leHRQcm9wcykge1xuXHRcdGxldCByZWYgPSB0aGlzLnByb3BzLnJlZjtcblx0XHRsZXQgdXBkYXRlUmVmID0gcmVmID09IG5leHRQcm9wcy5yZWY7XG5cdFx0aWYgKCF1cGRhdGVSZWYgJiYgcmVmKSB7XG5cdFx0XHRyZWYuY2FsbCA/IHJlZihudWxsKSA6IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdH1cblxuXHRcdGlmICghY29tcGFyZXIpIHtcblx0XHRcdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhY29tcGFyZXIodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhdXBkYXRlUmVmO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVtb2VkKHByb3BzKSB7XG5cdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBzaG91bGRVcGRhdGU7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoYywgcHJvcHMpO1xuXHR9XG5cdE1lbW9lZC5kaXNwbGF5TmFtZSA9ICdNZW1vKCcgKyAoYy5kaXNwbGF5TmFtZSB8fCBjLm5hbWUpICsgJyknO1xuXHRNZW1vZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHRNZW1vZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBNZW1vZWQ7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9pXG5cdFx0OiAvZmlsfGNoZXxyYS9pXG5cdCkudGVzdCh0eXBlKTtcblxuLy8gU29tZSBsaWJyYXJpZXMgbGlrZSBgcmVhY3QtdmlydHVhbGl6ZWRgIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoaXMuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLy8gYFVOU0FGRV8qYCBsaWZlY3ljbGUgaG9va3Ncbi8vIFByZWFjdCBvbmx5IGV2ZXIgaW52b2tlcyB0aGUgdW5wcmVmaXhlZCBtZXRob2RzLlxuLy8gSGVyZSB3ZSBwcm92aWRlIGEgYmFzZSBcImZhbGxiYWNrXCIgaW1wbGVtZW50YXRpb24gdGhhdCBjYWxscyBhbnkgZGVmaW5lZCBVTlNBRkVfIHByZWZpeGVkIG1ldGhvZC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBpdHMgb3duIGBjb21wb25lbnREaWRNb3VudCgpYCAoaW5jbHVkaW5nIHZpYSBkZWZpbmVQcm9wZXJ0eSksIHVzZSB0aGF0LlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGBVTlNBRkVfY29tcG9uZW50RGlkTW91bnQoKWAsIGBjb21wb25lbnREaWRNb3VudGAgaXMgdGhlIGFsaWFzIGdldHRlci9zZXR0ZXIuXG4vLyAtIElmIGFueXRoaW5nIGFzc2lnbnMgdG8gYW4gYFVOU0FGRV8qYCBwcm9wZXJ0eSwgdGhlIGFzc2lnbm1lbnQgaXMgZm9yd2FyZGVkIHRvIHRoZSB1bnByZWZpeGVkIHByb3BlcnR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE5NDFcbltcblx0J2NvbXBvbmVudFdpbGxNb3VudCcsXG5cdCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcblx0J2NvbXBvbmVudFdpbGxVcGRhdGUnXG5dLmZvckVhY2goa2V5ID0+IHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIGtleSwge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1snVU5TQUZFXycgKyBrZXldO1xuXHRcdH0sXG5cdFx0c2V0KHYpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHZcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KTtcblxuLyoqXG4gKiBQcm94eSByZW5kZXIoKSBzaW5jZSBSZWFjdCByZXR1cm5zIGEgQ29tcG9uZW50IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFZOb2RlIHRyZWUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudCBET00gbm9kZSB0byByZW5kZXIgdm5vZGUgdHJlZSBpbnRvXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciByZW5kZXJpbmdcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQgfCBudWxsfSBUaGUgcm9vdCBjb21wb25lbnQgcmVmZXJlbmNlIG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHQvLyBSZWFjdCBkZXN0cm95cyBhbnkgZXhpc3RpbmcgRE9NIG5vZGVzLCBzZWUgIzE3Mjdcblx0Ly8gLi4uYnV0IG9ubHkgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlICMxODI4XG5cdGlmIChwYXJlbnQuX2NoaWxkcmVuID09IG51bGwpIHtcblx0XHRwYXJlbnQudGV4dENvbnRlbnQgPSAnJztcblx0fVxuXG5cdHByZWFjdFJlbmRlcih2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHRwcmVhY3RIeWRyYXRlKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmxldCBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGUgPT4ge1xuXHRpZiAob2xkRXZlbnRIb29rKSBlID0gb2xkRXZlbnRIb29rKGUpO1xuXHRlLnBlcnNpc3QgPSBlbXB0eTtcblx0ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGlzUHJvcGFnYXRpb25TdG9wcGVkO1xuXHRlLmlzRGVmYXVsdFByZXZlbnRlZCA9IGlzRGVmYXVsdFByZXZlbnRlZDtcblx0cmV0dXJuIChlLm5hdGl2ZUV2ZW50ID0gZSk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuXHRyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGU7XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxubGV0IGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5sZXQgb2xkVk5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdGxldCB0eXBlID0gdm5vZGUudHlwZTtcblx0bGV0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBwcm9wcztcblxuXHQvLyBvbmx5IG5vcm1hbGl6ZSBwcm9wcyBvbiBFbGVtZW50IG5vZGVzXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCBub25DdXN0b21FbGVtZW50ID0gdHlwZS5pbmRleE9mKCctJykgPT09IC0xO1xuXHRcdG5vcm1hbGl6ZWRQcm9wcyA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRcdGlmIChJU19ET00gJiYgaSA9PT0gJ2NoaWxkcmVuJyAmJiB0eXBlID09PSAnbm9zY3JpcHQnKSB7XG5cdFx0XHRcdC8vIEVtdWxhdGUgUmVhY3QncyBiZWhhdmlvciBvZiBub3QgcmVuZGVyaW5nIHRoZSBjb250ZW50cyBvZiBub3NjcmlwdCB0YWdzIG9uIHRoZSBjbGllbnQuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAndmFsdWUnICYmICdkZWZhdWx0VmFsdWUnIGluIHByb3BzICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gU2tpcCBhcHBseWluZyB2YWx1ZSBpZiBpdCBpcyBudWxsL3VuZGVmaW5lZCBhbmQgd2UgYWxyZWFkeSBzZXRcblx0XHRcdFx0Ly8gYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aSA9PT0gJ2RlZmF1bHRWYWx1ZScgJiZcblx0XHRcdFx0J3ZhbHVlJyBpbiBwcm9wcyAmJlxuXHRcdFx0XHRwcm9wcy52YWx1ZSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaXMgdHJlYXRlZCBhcyBhIGZhbGxiYWNrIGB2YWx1ZWAgd2hlbiBhIHZhbHVlIHByb3AgaXMgcHJlc2VudCBidXQgbnVsbC91bmRlZmluZWQuXG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGZvciBFbGVtZW50cyB3aXRoIG5vIHZhbHVlIHByb3AgaXMgdGhlIHNhbWUgYXMgdGhlIERPTSBkZWZhdWx0VmFsdWUgcHJvcGVydHkuXG5cdFx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAnZG93bmxvYWQnICYmIHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIENhbGxpbmcgYHNldEF0dHJpYnV0ZWAgd2l0aCBhIHRydXRoeSB2YWx1ZSB3aWxsIGxlYWQgdG8gaXQgYmVpbmdcblx0XHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdFx0Ly8gY29udmVydHMgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQsIG90aGVyd2lzZSB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZmlsZSB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmICgvb25kb3VibGVjbGljay9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdC9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpICsgdHlwZSkgJiZcblx0XHRcdFx0IW9uQ2hhbmdlSW5wdXRUeXBlKHByb3BzLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0aSA9ICdvbmlucHV0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmZvY3VzJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3VzaW4nO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uYmx1ciQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c291dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wfENvbXBvKS8udGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChub25DdXN0b21FbGVtZW50ICYmIENBTUVMX1BST1BTLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkucmVwbGFjZSgvW0EtWjAtOV0vLCAnLSQmJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBzdXBwb3J0IGZvciBvbklucHV0IGFuZCBvbkNoYW5nZSwgc2VlICMzNTYxXG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGFuIG9uaW5wdXQgcHJvcCBhbHJlYWR5IGNoYW5nZSBpdCB0byBvbmlucHV0Q2FwdHVyZVxuXHRcdFx0aWYgKC9eb25pbnB1dCQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0pIHtcblx0XHRcdFx0XHRpID0gJ29uaW5wdXRDYXB0dXJlJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgc3VwcG9ydCBmb3IgYXJyYXkgc2VsZWN0IHZhbHVlczogPHNlbGVjdCBtdWx0aXBsZSB2YWx1ZT17W119IC8+XG5cdFx0aWYgKFxuXHRcdFx0dHlwZSA9PSAnc2VsZWN0JyAmJlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLm11bHRpcGxlICYmXG5cdFx0XHRBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSlcblx0XHQpIHtcblx0XHRcdC8vIGZvckVhY2goKSBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHdoaWNoIHdlIGFidXNlIGhlcmUgdG8gdW5zZXQgdGhlIHZhbHVlIHByb3AuXG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkaW5nIHN1cHBvcnQgZm9yIGRlZmF1bHRWYWx1ZSBpbiBzZWxlY3QgdGFnXG5cdFx0aWYgKHR5cGUgPT0gJ3NlbGVjdCcgJiYgbm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzLm11bHRpcGxlKSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlID09IGNoaWxkLnByb3BzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2bm9kZS5wcm9wcyA9IG5vcm1hbGl6ZWRQcm9wcztcblxuXHRcdGlmIChwcm9wcy5jbGFzcyAhPSBwcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIHByb3BzO1xuXHRcdFx0aWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSBub3JtYWxpemVkUHJvcHMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsaXplZFByb3BzLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG5cdFx0fVxuXHR9XG5cblx0dm5vZGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblx0aWYgKG9sZFZOb2RlSG9vaykgb2xkVk5vZGVIb29rKHZub2RlKTtcbn07XG5cbi8vIE9ubHkgbmVlZGVkIGZvciByZWFjdC1yZWxheVxubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5jb25zdCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5vcHRpb25zLl9yZW5kZXIgPSBmdW5jdGlvbih2bm9kZSkge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSB7XG5cdFx0b2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcbn07XG5cbi8vIFRoaXMgaXMgYSB2ZXJ5IHZlcnkgcHJpdmF0ZSBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgUmVhY3QgaXRcbi8vIGlzIHVzZWQgdG8gc29ydC1vZiBkbyBydW50aW1lIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBTbyBmYXJcbi8vIG9ubHkgYHJlYWN0LXJlbGF5YCBtYWtlcyB1c2Ugb2YgaXQuIEl0IHVzZXMgaXQgdG8gcmVhZCB0aGVcbi8vIGNvbnRleHQgdmFsdWUuXG5leHBvcnQgY29uc3QgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSB7XG5cdFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IHtcblx0XHRjdXJyZW50OiB7XG5cdFx0XHRyZWFkQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50Q29tcG9uZW50Ll9nbG9iYWxDb250ZXh0W2NvbnRleHQuX2lkXS5wcm9wcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcclxuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4gPSAoKHZhbHVlOiBULCBwcmV2VmFsdWU6IFQgfCB1bmRlZmluZWQpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XHJcblxyXG4vKipcclxuICogRGVidWcgaG9vay5cclxuICogXHJcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXHJcbiAqIFxyXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xyXG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGgsIDApO1xyXG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcclxuICAgIHJldHVybjtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFU+KHZhbHVlOiBVLCBpbmRleDogbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcclxuICAgICAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZih2YWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpbmRleH0taW5kZXhlZCBhcmd1bWVudC5gKTtcclxuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxyXG4gKiBcclxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxyXG4gKiBcclxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XHJcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxyXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXHJcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cclxuICogXHJcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cclxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBUKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xyXG5cclxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcclxuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSk7XHJcblxyXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXHJcbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcclxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXHJcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cclxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxyXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcclxuXHJcblxyXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxyXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxyXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcclxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxyXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcclxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xyXG5cclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cclxuICAgIGNvbnN0IHIgPSB1c2VSZWYoeyBtaWNyb3Rhc2tRdWV1ZWQ6IGZhbHNlLCBhcmc6IHVuZGVmaW5lZCBhcyB1bmRlZmluZWQgfCBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+WzBdLCBwcmV2RGVwOiB1bmRlZmluZWQgYXMgVCB8IHVuZGVmaW5lZCwgaGFuZGxlOiBudWxsIGFzIG51bWJlciB8IG51bGwgfSk7XHJcbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChhcmcpID0+IHtcclxuICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogZ2V0VmFsdWUoKTtcclxuICAgICAgICByLmN1cnJlbnQuYXJnID0gYXJnO1xyXG4gICAgICAgIGlmICghci5jdXJyZW50Lm1pY3JvdGFza1F1ZXVlZCkge1xyXG4gICAgICAgICAgICByLmN1cnJlbnQubWljcm90YXNrUXVldWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgci5jdXJyZW50LmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgci5jdXJyZW50Lm1pY3JvdGFza1F1ZXVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgci5jdXJyZW50LmhhbmRsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gci5jdXJyZW50LnByZXZEZXA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSByLmN1cnJlbnQuYXJnITtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHByZXZEZXAhKSA6IGFyZztcclxuICAgICAgICAgICAgICAgIGlmIChkZXAgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgdG8gdGhlIHVzZXIgdGhhdCB0aGV5IHNob3VsZG4ndCBjYWxsIGdldFZhbHVlIGR1cmluZyBvbkNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihkZXAsIHByZXZEZXApID8/IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkZXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XHJcbn1cclxuXHJcbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XHJcblxyXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXHJcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cclxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH0iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xyXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxyXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cclxuICogXHJcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XHJcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyBjbGFzczogbGhzQ2xhc3MsIGNsYXNzTmFtZTogbGhzQ2xhc3NOYW1lIH06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+LCB7IGNsYXNzOiByaHNDbGFzcywgY2xhc3NOYW1lOiByaHNDbGFzc05hbWV9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBcImNsYXNzXCIgfCBcImNsYXNzTmFtZVwiPik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblxyXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xyXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXHJcblxyXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcclxuICAgICAgICBjb25zdCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWxsQ2xhc3Nlcykuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGgsIFJlZiwgUmVmQ2FsbGJhY2ssIFJlZk9iamVjdCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJlZihpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgIChyZWYgYXMgUmVmT2JqZWN0PFQgfCBudWxsPikuY3VycmVudCA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBSPEU+IHtcclxuICAgIHJlZj86IFJlZjxFPjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cclxuICogQHBhcmFtIGxocyBcclxuICogQHBhcmFtIHJocyBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHsgcmVmOiByaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHsgcmVmOiBsaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pIHtcclxuICAgIGNvbnN0IGNvbWJpbmVkOiBSZWZDYWxsYmFjazxFPiA9IHVzZUNhbGxiYWNrKChjdXJyZW50OiBFIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcclxuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIHJocyk7XHJcbiAgICB9LCBbbGhzLCByaHNdKTtcclxuXHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsaHMhO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG5mdW5jdGlvbiBzdHlsZVN0cmluZ1RvT2JqZWN0KHN0eWxlOiBzdHJpbmcpOiBoLkpTWC5DU1NQcm9wZXJ0aWVzIHtcclxuICAgIC8vIFRPRE86IFRoaXMgc3Vja3MgRDpcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0d28gc3R5bGUgb2JqZWN0cywgcmV0dXJuaW5nIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcclxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcclxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+LCByaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0ge1xyXG5cclxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxyXG4gICAgaWYgKCFsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xyXG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiAhcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5zdHlsZTtcclxuICAgICAgICBpZiAoIWxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIHJocy5zdHlsZTtcclxuXHJcbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSkge1xyXG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyh7IHN0eWxlOiBzdHlsZVN0cmluZ1RvT2JqZWN0KGxocz8uc3R5bGUgYXMgc3RyaW5nKSB9LCByaHMpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QocmhzPy5zdHlsZSBhcyBzdHJpbmcpIH0pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2dpYz8/P1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cclxuICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2xocy5zdHlsZX07JHtyaHM/LnN0eWxlID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi4obGhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgICAgICAuLi4ocmhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcmVmc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlc1wiO1xyXG5cclxubGV0IGxvZyA9IGNvbnNvbGUud2FybjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xyXG4gICAgbG9nID0gbG9nMlxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gKiBcclxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cclxuICogQHBhcmFtIGxoczIgXHJcbiAqIEBwYXJhbSByaHMyIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAvLyBGaXJzdCwgc2VwYXJhdGUgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4gaW50byB0d28gZ3JvdXBzOlxyXG4gICAgLy8gbGhzQWxsIGFuZCByaHNBbGwgY29udGFpbiBhbGwgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4sIGFuZFxyXG4gICAgLy8gbGhzTWlzYyBhbmQgcmhzTWlzYyBjb250YWluIGFsbCBwcm9wcyAqZXhjZXB0KiBmb3IgdGhlIGVhc3kgb25lc1xyXG4gICAgLy8gbGlrZSBjbGFzc05hbWUgYW5kIHN0eWxlIHRoYXQgd2UgYWxyZWFkeSBrbm93IGhvdyB0byBtZXJnZS5cclxuICAgIGNvbnN0IHsgY2hpbGRyZW46IF9saHNDaGlsZHJlbiwgY2xhc3M6IF9saHNDbGFzcywgY2xhc3NOYW1lOiBfbGhzQ2xhc3NOYW1lLCBzdHlsZTogX2xoc1N0eWxlLCByZWY6IF9saHNSZWYsIC4uLmxoc01pc2MgfSA9IGxoc0FsbDtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW46IF9yaHNDaGlsZHJlbiwgY2xhc3M6IF9yaHNDbGFzcywgY2xhc3NOYW1lOiBfcmhzQ2xhc3NOYW1lLCBzdHlsZTogX3Joc1N0eWxlLCByZWY6IF9yaHNSZWYsIC4uLnJoc01pc2MgfSA9IHJoc0FsbDtcclxuXHJcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xyXG4gICAgICAgIC4uLmxoc01pc2MsXHJcbiAgICAgICAgcmVmOiB1c2VNZXJnZWRSZWZzPEU+KGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBzdHlsZTogdXNlTWVyZ2VkU3R5bGVzKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNoaWxkcmVuOiB1c2VNZXJnZWRDaGlsZHJlbihsaHNBbGwsIHJoc0FsbCksXHJcbiAgICB9IGFzIGFueTtcclxuXHJcbiAgICBpZiAocmV0LnJlZiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnJlZjtcclxuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcclxuICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xyXG4gICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xyXG5cclxuICAgIC8vIE5vdywgZG8gKmV2ZXJ5dGhpbmcqIGVsc2VcclxuICAgIC8vIE1lcmdlIGV2ZXJ5IHJlbWFpbmluZyBleGlzdGluZyBlbnRyeSBpbiBsaHMgd2l0aCB3aGF0IHdlJ3ZlIGFscmVhZHkgcHV0IGluIHJldC5cclxuICAgIC8vY29uc3QgbGhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGxocykgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW107XHJcbiAgICBjb25zdCByaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmhzTWlzYyk7XHJcblxyXG4gICAgZm9yIChjb25zdCBbcmhzS2V5VSwgcmhzVmFsdWVdIG9mIHJoc0VudHJpZXMpIHtcclxuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG5cclxuICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc01pc2NbcmhzS2V5IGFzIGtleW9mIHR5cGVvZiBsaHNNaXNjXTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXHJcbiAgICAgICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VGdW5jdGlvbnMobGhzVmFsdWUgYXMgbmV2ZXIsIHJoc1ZhbHVlIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgcmV0W3Joc0tleSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPl0gPSBtZXJnZWQgYXMgbmV2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gbGhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJoc1ZhbHVlIGFzIGFueSkgPT0gbGhzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEkgbWVhbiwgdGhleSdyZSB0aGUgc2FtZSB2YWx1ZSBhdCBsZWFzdFxyXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCByZWFsbHkgaWRlYWwgdGhvdWdoLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gTm8gZ29vZCBzdHJhdGVnaWVzIGhlcmUsIGp1c3QgbG9nIGl0IGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgbG9nPy4oYFRoZSBwcm9wIFwiJHtyaHNLZXl9XCIgY2Fubm90IHNpbXVsdGFuZW91c2x5IGJlIHRoZSB2YWx1ZXMgJHtsaHNWYWx1ZX0gYW5kICR7cmhzVmFsdWV9LiBPbmUgbXVzdCBiZSBjaG9zZW4gb3V0c2lkZSBvZiB1c2VNZXJnZWRQcm9wcy5gKTtcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnM8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBVIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuXHJcbiAgICBpZiAoIWxocylcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgaWYgKCFyaHMpXHJcbiAgICAgICAgcmV0dXJuIGxocztcclxuXHJcbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcclxuICAgICAgICBjb25zdCBsdiA9IGxocyguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgaWYgKGx2IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBydiBpbnN0YW5jZW9mIFByb21pc2UpXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKlxyXG5mdW5jdGlvbiB0ZXN0PFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuXHJcbiAgICBjb25zdCBpZDA6IEdlbmVyaWNHZXQ8e30sIFwiaWRcIiwgc3RyaW5nPiA9IFwiXCI7XHJcbiAgICBjb25zdCBpZDM6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNDogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ1OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDY6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIC8vY29uc3QgaWQyOiBaaXBTaW5nbGU8c3RyaW5nIHwgdW5kZWZpbmVkLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQxOiBaaXBPYmplY3Q8eyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHsgaWQ6IHVuZGVmaW5lZCB9O1xyXG5cclxuICAgIHR5cGUgTTEgPSBHZW5lcmljR2V0PFAsIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIHR5cGUgTTIgPSBHZW5lcmljR2V0PHt9LCBcInN0eWxlXCIsIHN0cmluZz47XHJcbiAgICBjb25zdCBtMTogTTEgPSBcIlwiO1xyXG4gICAgY29uc3QgbTI6IE0xID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG0zOiBNMSA9IDA7XHJcblxyXG4gICAgY29uc3QgbTQ6IE0yID0gXCJcIjtcclxuICAgIGNvbnN0IG01OiBNMiA9IHVuZGVmaW5lZDtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXHJcbiAgICBjb25zdCBtNjogTTIgPSAwO1xyXG5cclxuICAgIGNvbnN0IHAxOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAyOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAzOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDQ6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7fT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7fSk7XHJcbiAgICBjb25zdCBwNSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHt9KTtcclxuICAgIGNvbnN0IHA2ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDcgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG5cclxuXHJcbiAgICBwMS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHAzLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICBwNC5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBwNS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDYuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHA3LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDUuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDYuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDcuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA1LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDYuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNy5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgaXQgd29ya3MgcmVjdXJzaXZlbHlcclxuICAgIGNvbnN0IHIxYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAxKTtcclxuICAgIGNvbnN0IHIxYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAxKTtcclxuICAgIGNvbnN0IHIyYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAyKTtcclxuICAgIGNvbnN0IHIyYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAyKTtcclxuICAgIGNvbnN0IHIzYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAzKTtcclxuICAgIGNvbnN0IHIzYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAzKTtcclxuICAgIGNvbnN0IHI0YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA0KTtcclxuICAgIGNvbnN0IHI0YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA0KTtcclxuICAgIGNvbnN0IHI1YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA1KTtcclxuICAgIGNvbnN0IHI1YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA1KTtcclxuICAgIGNvbnN0IHI2YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA2KTtcclxuICAgIGNvbnN0IHI2YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA2KTtcclxuICAgIGNvbnN0IHI3YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA3KTtcclxuICAgIGNvbnN0IHI3YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA3KTtcclxuXHJcblxyXG4gICAgcjFhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMWIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIyYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHIzYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjNiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICByNGEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI0Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICByNWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI1Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjZhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI3YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjVhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI1Yi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjZiLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByN2IuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxufVxyXG5mdW5jdGlvbiBhY2NlcHRzTmV2ZXIobjogbmV2ZXIpIHt9XHJcbiovIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRFbGVtZW50KCk6IFQgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XHJcbiAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD47XHJcbiAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbiAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXHJcbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsIFxyXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cclxuICogXHJcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxyXG4gKiBcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJncz86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4ge1xyXG4gICAgY29uc3QgeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9ID0gKGFyZ3MgPz8ge30pO1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xyXG5cclxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxyXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xyXG4gICAgICAgIGlmIChwcmV2VmFsdWUpXHJcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xyXG5cclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xlYW51cDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXHJcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGw+KGhhbmRsZXIsIHJldHVybk51bGwpO1xyXG4gICAgY29uc3QgdXNlUmVmRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD5bXCJ1c2VSZWZFbGVtZW50UHJvcHNcIl0+KChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHM8VD4oeyByZWY6IHNldEVsZW1lbnQgfSwgcHJvcHMpLCBbXSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXHJcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJlZkVsZW1lbnRQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50XHJcbiAgICB9XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBcclxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcclxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XHJcbiAqIFxyXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cclxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcclxuICogICAgKiBObyBmb2N1cyBldmVudHMgYXJlIGZpcmVkLlxyXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXHJcbiAqICAgICogQSBgZm9jdXNgL2Bmb2N1c2luYCBldmVudCAqTUlHSFQqIGJlIGZpcmVkIGZvciBgYm9keWAuIERlcGVuZGluZyBvblxyXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cclxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXHJcbiAqIDMuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXHJcbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXHJcbiAqICAgICogYGZvY3VzYCBhbmQgYGZvY3VzaW5gIGFyZSBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxyXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cclxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXHJcbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgbmV3IGVsZW1lbnQuXHJcbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cclxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxyXG4gKiA1LiBBbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXHJcbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxyXG4gKiAgICAqIGBmb2N1c2luYCBpcyAqbm90KiBmaXJlZCBvbiBgYm9keWAuXHJcbiAqIFxyXG4gKiBcclxuICogSW4gc3VtbWFyeTpcclxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxyXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cclxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxyXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBjYWxsYmFjayBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5jb25zdCBfZHVtbXkgPSAwO1xyXG5cclxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCk+PigpO1xyXG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlKSA9PiB2b2lkKT4+KCk7XHJcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xyXG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xyXG5cclxuY29uc3QgbWljcm90YXNrcyA9IG5ldyBTZXQ8TWFwPGFueSwgYW55Pj4oKTtcclxuXHJcbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXHJcbi8vIEUuRy4gY2FsbGluZyBlbGVtZW50LmZvY3VzKCkgY2FuIGNhdXNlIGEgZm9jdXNpbiBldmVudCBoYW5kbGVyIHRvIGltbWVkaWF0ZWx5IGludGVycnVwdCB0aGF0IGNvZGUuXHJcbi8vIEZvciB0aGUgcHVycG9zZSBvZiBpbXByb3Zpbmcgc3RhYmlsaXR5LCB3ZSBkZWJvdW5jZSBhbGwgZm9jdXMgZXZlbnRzIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cclxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBUKSA9PiB2b2lkKT4+LCB2YWx1ZTogVCkge1xyXG4gICAgaWYgKCFtaWNyb3Rhc2tzLmhhcyhtYXApKSB7XHJcbiAgICAgICAgbWljcm90YXNrcy5hZGQobWFwKTtcclxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgIG1pY3JvdGFza3MuZGVsZXRlKG1hcCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVycyA9IG1hcC5nZXQod2luZG93KTtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyPy4odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgY29uc3QgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpO1xyXG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcclxuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3aW5kb3dGb2N1cyhlOiBGb2N1c0V2ZW50KSB7XHJcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcclxuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XHJcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpbmRvd0JsdXIoZTogRm9jdXNFdmVudCkge1xyXG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XHJcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcclxuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCBmYWxzZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy4gTXVzdCBiZSBzdGFibGUuXHJcbiAgICAgKi9cclxuICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcyBhbmQgaXMgbm90IG51bGwuIFxyXG4gICAgICogTXVzdCBiZSBzdGFibGUuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50PjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgd2luZG93IGdhaW5zL2xvc2VzIGZvY3VzLiBNdXN0IGJlIHN0YWJsZS5cclxuICAgICAqL1xyXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbj47XHJcblxyXG4gICAgb25Nb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Nb3VudFwiXTtcclxuICAgIG9uVW5tb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Vbm1vdW50XCJdO1xyXG4gICAgb25Nb3VudENoYW5nZT86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25FbGVtZW50Q2hhbmdlXCJdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+IHtcclxuICAgIC8qKiBcclxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQgfCBudWxsO1xyXG4gICAgLyoqIFxyXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciB3aGF0ZXZlciBlbGVtZW50IHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQ7XHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcclxuXHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlQWN0aXZlRWxlbWVudFByb3BzOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxyXG4gKiAqIGBnZXRBY3RpdmVFbGVtZW50KClgXHJcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXHJcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcclxuICogXHJcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcclxuICogXHJcbiAqIFRoaXMgaXMgYSBwYXNzaXZlIGhvb2ssIHNvIGJ5IGRlZmF1bHQgaXQgcmV0dXJucyBnZXR0ZXIgZnVuY3Rpb25zIHRoYXQgcmVwb3J0IHRoaXMgaW5mb3JtYXRpb24gYnV0IHRoZSBjb21wb25lbnQgd2lsbCBub3QgcmUtcmVuZGVyIGJ5IGRlZmF1bHQgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy5cclxuICogXHJcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQ8VCBleHRlbmRzIE5vZGU+KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgb25Nb3VudENoYW5nZSB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VBY3RpdmVFbGVtZW50XCIsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBvbk1vdW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcclxuICAgICAgICBvbk1vdW50LFxyXG4gICAgICAgIG9uVW5tb3VudCxcclxuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCwgcHJldlZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgICAgICBvbk1vdW50Q2hhbmdlPy4oZWxlbWVudCwgcHJldlZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpPy5zaXplID8/IDApID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XHJcbiAgICAgICAgICAgICAgICAvLyBtYW5hZ2UgdGhlIFwiPjAgbWVhbnMgZG9uJ3QgYWRkIGhhbmRsZXJzXCIgbG9naWMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+KTtcclxuICAgICAgICAgICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcclxuICAgICAgICAgICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChzZXRXaW5kb3dGb2N1c2VkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPik7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0V2luZG93Rm9jdXNlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW10pXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IFtnZXRBY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50IHwgbnVsbD4ob25BY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xyXG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHsgZ2V0RWxlbWVudCwgdXNlQWN0aXZlRWxlbWVudFByb3BzOiB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuXHJcbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XHJcblxyXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xyXG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXHJcbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxyXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxyXG4gKiBcclxuICogXHJcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcclxuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxyXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcclxufVxyXG5cclxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xyXG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcclxuXHJcblxyXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcclxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxyXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xyXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxyXG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cclxuLy8gXHJcbi8vIEFsc28gaXQncyBwcml2YXRlLlxyXG4vL1xyXG4vLyAuLi5cclxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxyXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXHJcbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXHJcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXHJcbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xyXG5cclxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcclxuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcclxuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcclxuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcclxuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9SdW4uY2xlYXIoKTtcclxuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XHJcbn1cclxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxyXG5cclxuLyoqXHJcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cclxuICogXHJcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXHJcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XHJcblxyXG4gICAgLyooKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xyXG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xyXG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XHJcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKCk7Ki9cclxuXHJcbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcclxuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lkXSlcclxufVxyXG5cclxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuICEhKFxyXG4gICAgICAgICFvbGRBcmdzIHx8XHJcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxyXG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHJpbW1lZEVuZEluZGV4O1xuIiwiaW1wb3J0IHRyaW1tZWRFbmRJbmRleCBmcm9tICcuL190cmltbWVkRW5kSW5kZXguanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUcmltO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBiYXNlVHJpbSBmcm9tICcuL19iYXNlVHJpbS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b051bWJlcjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBub3cgZnJvbSAnLi9ub3cuanMnO1xuaW1wb3J0IHRvTnVtYmVyIGZyb20gJy4vdG9OdW1iZXIuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVib3VuY2U7XG4iLCJpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRocm90dGxlO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiXHJcbmltcG9ydCBkZWJvdW5jZSwgeyBEZWJvdW5jZWRGdW5jLCB0eXBlIERlYm91bmNlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL2RlYm91bmNlXCI7XHJcbmltcG9ydCB0aHJvdHRsZSwgeyB0eXBlIFRocm90dGxlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL3Rocm90dGxlXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG50eXBlIEZ1bmMgPSAoLi4uYXJnczogYW55KSA9PiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93bjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNQYXJhbWV0ZXJzPEFQIGV4dGVuZHMgdW5rbm93bltdLCBTUCBleHRlbmRzIHVua25vd25bXSA9IEFQPiB7XHJcbiAgICAvKipcclxuICAgICAqIElmIHByb3ZpZGVkLCBhZGRzIGEgZGVib3VuY2UgYmVoYXZpb3IgKmluIGFkZGl0aW9uKiB0b1xyXG4gICAgICogdGhlIGRlZmF1bHQgXCJ3YWl0IHVudGlsIHJlc29sdmVkXCIgdGhyb3R0bGluZyBiZWhhdmlvci5cclxuICAgICAqL1xyXG4gICAgZGVib3VuY2U/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBgdXNlQXN5bmNgIHdpdGggYXV0by10aHJvdHRsZSBiYXNlZCBvbiBob3cgbG9uZyBpdCB0YWtlc1xyXG4gICAgICogZm9yIHRoZSBvcGVyYXRpb24gdG8gY29tcGxldGUuICBJZiB5b3Ugd291bGQgbGlrZSB0aGVyZSB0byBiZSBhXHJcbiAgICAgKiBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGFsbG93aW5nIGEgc2Vjb25kIG9wZXJhdGlvbixcclxuICAgICAqIHRoZSBgdGhyb3R0bGVgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBhZGRpdGlvbiB0byB0aGF0IGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICB0aHJvdHRsZT86IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYW4gYXN5bmMgZnVuY3Rpb24gaXMgZGVib3VuY2VkIGR1ZSB0byBvbmUgYWxyZWFkeSBydW5uaW5nLFxyXG4gICAgICogaXQgd2lsbCBydW4gb24gYSBkZWxheSBhbmQsIGFzIGEgcmVzdWx0LCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXHJcbiAgICAgKiB0aGF0IHdlcmUgcGFzc2VkIHRvIGl0IG1heSBuZWVkIHRvIGJlIGFkanVzdGVkIHRvIGFjY291bnQgZm9yIHRoYXQuXHJcbiAgICAgKiBcclxuICAgICAqIEZvciBleGFtcGxlLCBkdXJpbmcgYG9uSW5wdXRgLCB0aGUgYHZhbHVlYCBvZiB0aGF0IGV2ZW50IGlzbid0IHN0b3JlZFxyXG4gICAgICogaW4gdGhlIGV2ZW50IGl0c2VsZiwgaXQncyBzdG9yZWQgaW4gdGhlIGBIVE1MSW5wdXRFbGVtZW50YCB0aGF0IHJhaXNlZCBpdC5cclxuICAgICAqIFNvIHdoZW4gb3VyIGhhbmRsZXIgYWN0dWFsbHkgcnVucyBhIGZldyBzZWNvbmRzIGxhdGVyLCBpdCdsbCByZWFkIHRoZSAqKm5leHQqKlxyXG4gICAgICogYGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWVgLCBpbnN0ZWFkIG9mIHRoZSBvbmUgZnJvbSBhIGZldyBzZWNvbmRzIGFnbyBcclxuICAgICAqIHRoYXQgYWN0dWFsbHkgcmFpc2VkIHRoZSBldmVudCFcclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGFyZ3VtZW50cyB0byB5b3VyIGhhbmRsZXIgcmVxdWlyZSByZWZlcmVuY2luZyBkYXRhIGluIHRoZSBhcmd1bWVudHNcclxuICAgICAqIHRoYXQgbWF5IGJlY29tZSBcInN0YWxlXCIgYnkgdGhlIHRpbWUgdGhlIGZ1bmN0aW9uIGFjdHVhbGx5IHJ1bnMgKGdlbmVyYWxseSBldmVudFxyXG4gICAgICogaGFuZGxlcnMgYW5kIG90aGVyIHRoaW5ncyB0aGF0IHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiBleGlzdGluZyBvYmplY3RzKSxcclxuICAgICAqIHRoZSBgY2FwdHVyZWAgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwYXJhbWV0ZXJzIHlvdSB3ZXJlIGdpdmVuXHJcbiAgICAgKiB3aGVuIHRoZSByZXF1ZXN0IHRvIHJ1biB3YXMgaW5pdGlhbGx5IG1hZGUgaW50byBwYXJhbWV0ZXJzIHRoYXQgeW91IGhhdmVcclxuICAgICAqIGd1YXJhbnRlZWQgd2lsbCBzdGlsbCBiZSBnb29kIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGFjdHVhbGx5IHJ1bnMuXHJcbiAgICAgKi9cclxuICAgIGNhcHR1cmU/OiBDYXB0dXJlRnVuY3Rpb25UeXBlPEFQLCBTUD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNSZXR1cm5UeXBlPFNQIGV4dGVuZHMgdW5rbm93bltdLCBSPiB7XHJcblxyXG4gICAgLy9wcm9taXNlOiBQcm9taXNlPEF3YWl0ZWQ8UmV0dXJuVHlwZTxGPj4+IHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYSBoYW5kbGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcsIHRoaXMgaXMgdHJ1ZS5cclxuICAgICAqIFxyXG4gICAgICogSXQgaXMgZmFsc2UgYmVmb3JlIHRoZSBmaXJzdCBleGVjdXRpb24sIHRydWUgZHVyaW5nIHRoZVxyXG4gICAgICogZmlyc3QgZXhlY3V0aW9uLCByZW1haW5zIHRydWUgaWYgY29udGludWluZyBpbW1lZGlhdGVseVxyXG4gICAgICogaW50byBhIHNlY29uZCwgYW5kIG9ubHkgcmV0dXJucyB0byBmYWxzZSB3aGVuIGEgaGFuZGxlclxyXG4gICAgICogY29tcGxldGVzIHdpdGggbm8gaGFuZGxlciBpbiB3YWl0aW5nLlxyXG4gICAgICovXHJcbiAgICBwZW5kaW5nOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgcnVuLlxyXG4gICAgICogRG9lcyBub3QgaW5jbHVkZSB0aW1lcyB3aGVyZSBpdCB3YXMgdGhyb3R0bGVkIG9yIGRlYm91bmNlZCBhd2F5LlxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgZm9yIGtub3dpbmcgaWYgdGhlIGhhbmRsZXIgaGFzIGJlZW4gY2FsbGVkIHlldCwgb3IgZm9yXHJcbiAgICAgKiBzZXR0aW5nIGEgbmV3IHRpbWVvdXQgdG8gc2hvdyBhIHNwaW5uZXIuXHJcbiAgICAgKi9cclxuICAgIGNhbGxDb3VudDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgc2V0dGxlZFxyXG4gICAgICogKHJlc29sdmVkIG9yIHJlamVjdGVkKSwgc2ltaWxhcmx5IHRvIGBjYWxsQ291bnRgLlxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgZm9yIGtub3dpbmcgaWYgdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBldmVuIG9uY2UgeWV0LFxyXG4gICAgICogb3IganVzdCBmb3Igd2hlbiB0aGUgaGFuZGxlciBoYXMgZmluaXNoZWRcclxuICAgICAqL1xyXG4gICAgc2V0dGxlQ291bnQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIFxyXG4gICAgICogc2ltaWxhcmx5IHRvIGBzZXR0bGVDb3VudGAuXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVDb3VudDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGZhaWxlZCB0byBjb21wbGV0ZSwgXHJcbiAgICAgKiBzaW1pbGFybHkgdG8gYHJlc29sdmVDb3VudGAuXHJcbiAgICAgKi9cclxuICAgIHJlamVjdENvdW50OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IHJldHVybmVkIGZyb20gYSBzdWNjZXNzZnVsIGhhbmRsZXIgaW52b2NhdGlvbixcclxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiBubyBoYW5kbGVyIGhhcyBzdWNjZXNzZnVsbHkgcmV0dXJuZWQgeWV0LlxyXG4gICAgICogXHJcbiAgICAgKiBJZiB0aGUgaGFuZGxlciByZWplY3RzIGFmdGVyIGhhdmluZyBzdWNjZWVkZWQgcHJldmlvdXNseSwgdGhlblxyXG4gICAgICogYHJlc3VsdGAgd2lsbCBzdGlsbCBrZWVwIGl0cyB2YWx1ZTsgaXQgd29uJ3QgYmUgXCJlcmFzZWRcIiBkdWUgdG8gdGhlIGVycm9yLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGByZXN1bHRgIGFuZCBgZXJyb3JgIGNhbiBib3RoIGJlIHBvcHVsYXRlZCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIGhhc1Jlc3VsdCBmb3IgaWYgYHJlc3VsdGAgYmVpbmcgYHVuZGVmaW5lZGAgbWVhbnMgaXQncyB1bmZpbmlzaGVkIG9yIHRoZSBmdW5jdGlvbiBpdHNlbGYgcmV0dXJuZWQgYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIHJlc3VsdDogUiB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydWUgd2hlbiB0aGUgbW9zdCByZWNlbnRseS1ydW4gaGFuZGxlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LFxyXG4gICAgICogYWxzbyBtZWFuaW5nIHRoYXQgdGhhdCBpdCdzIHJldHVybmVkIGEgdmFsdWUgdGhhdCB3ZSBjdXJyZW50bHkgaGF2ZS5cclxuICAgICAqIFxyXG4gICAgICogV2hpbGUgYHBlbmRpbmdgIGlzIHRydWUsICoqYGhhc1Jlc3VsdGAgYW5kIGBoYXNFcnJvcmAgbWF5IGJlIHNpbXVsdGFuZW91c2x5IHRydWUqKixcclxuICAgICAqIGJ1dCBpbiBhbGwgb3RoZXIgY2FzZXMgdGhleSdyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGhhc1Jlc3VsdDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlcnJvciB0aGUgaGFuZGxlciB0aHJldy4gYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB0aG91Z2ggbm90ZVxyXG4gICAgICogdGhhdCBgdW5kZWZpbmVkYCBpcyBhIHZhbGlkIHRoaW5nIHRvIHRocm93LCBzbyBjaGVjayBgaGFzRXJyb3JgIHRvby5cclxuICAgICAqIFxyXG4gICAgICogQHNlZSBoYXNFcnJvclxyXG4gICAgICovXHJcbiAgICBlcnJvcjogdW5rbm93bjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb3N0IHJlY2VudCBoYW5kbGVyIGZpbmlzaGVkIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UsIHRlY2huaWNhbGx5LCBgZXJyb3JgIGNhbiBiZSBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgaGFzRXJyb3I6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSBhbnkgY3VycmVudGx5IGRlYm91bmNlZC1idXQtZXZlbnR1YWxseS1wZW5kaW5nIHByb21pc2VzIHRvIGltbWVkaWF0ZWx5IGJlIGNvbnNpZGVyZWQgYnkgY2FuY2VsbGluZyB0aGVpciBkZWJvdW5jZSB0aW1lb3V0LFxyXG4gICAgICogeW91IGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uICBOb3JtYWwgcHJvY2VkdXJlIGFwcGxpZXMgYXMgaWYgdGhlIGRlYm91bmNlZCBlbmRlZCBub3JtYWxseSAtLSBpZiB0aGVyZSdzIG5vIHByb21pc2Ugd2FpdGluZyBpbiB0aGUgcXVldWUsXHJcbiAgICAgKiB0aGUgZGVib3VuY2VkIHByb21pc2UgcnVucyBub3JtYWxseSwgb3RoZXJ3aXNlLCBpdCB3YWl0cyBpdHMgdHVybiB1bnRpbCB0aGUgY3VycmVudCBvbmUgZW5kcywgcG90ZW50aWFsbHkgYmVpbmcgb3ZlcndyaXR0ZW4gbGF0ZXIgb25cclxuICAgICAqIGlmIGEgbmV3IHByb21pc2UgcnVucyBvdXQgKml0cyogZGVib3VuY2UgdGltZXIgYmVmb3JlIHRoaXMgb25lIGdvdCBhIGNoYW5jZSB0byBydW4uXHJcbiAgICAgKiBcclxuICAgICAqICoqUXVhc2ktc3RhYmxlKiogKGRvbid0IHVzZSBkdXJpbmcgcmVuZGVyKVxyXG4gICAgICovXHJcbiAgICBmbHVzaERlYm91bmNlZFByb21pc2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlZCBvbiB0aGUgdHlwZSBvZiBoYW5kbGVyIHBhc3NlZCBpbiwgdGhpcyByZXR1cm5lZCB2YWx1ZSB3aWxsXHJcbiAgICAgKiByZXByZXNlbnQgd2hhdCB0eXBlIG9mIGhhbmRsZXIgaXQgd2FzLCBqdXN0IGluIGNhc2UgeW91XHJcbiAgICAgKiB5b3Vyc2VsZiBuZWVkIHRvIGtub3cgdGhhdCBhbmQgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsXHJcbiAgICAgKiB0byBmaW5kIG91dCB3aXRob3V0IGl0IGFjdHVhbGx5IGJlaW5nIHJ1bi5cclxuICAgICAqIFxyXG4gICAgICogVW50aWwgYSBoYW5kbGVyIGlzIGNhbGxlZCwgdGhpcyB3aWxsIGJlIG51bGwuICBOYXR1cmFsbHksIGlmIFxyXG4gICAgICogZGlmZmVyZW50IGhhbmRsZXJzIGFyZSBwYXNzZWQgaW4sIGl0IGNhbiBmbGlwIGJhY2sgYW5kXHJcbiAgICAgKiBmb3J0aCBiZXR3ZWVuIFwiYXN5bmNcIiBhbmQgXCJzeW5jXCIgYXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgY3VycmVudFR5cGU6IG51bGwgfCBcInN5bmNcIiB8IFwiYXN5bmNcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIHRoZSBhc3luYyBoYW5kbGVyIHByb3ZpZGVkLFxyXG4gICAgICogbm93IHN5bmNocm9ub3VzIGFuZC9vciB0aHJvdHRsZWQgYW5kL29yIGRlYm91bmNlZFxyXG4gICAgICogXHJcbiAgICAgKiAqKlF1YXNpLXN0YWJsZSoqIChkb24ndCB1c2UgZHVyaW5nIHJlbmRlcilcclxuICAgICAqL1xyXG4gICAgc3luY0hhbmRsZXI6IFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eTxBUCBleHRlbmRzIHVua25vd25bXSwgU1AgZXh0ZW5kcyB1bmtub3duW10+KC4uLnQ6IFNQKSB7IHJldHVybiB0IGFzIHVua25vd25bXSBhcyBBUDsgfVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbi5cclxuICogXHJcbiAqIElmIHRoZSBjYWxsYmFjayBpcyBgbnVsbGAsIHRoZW4gYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSBgY2FsbGJhY2tgIG11c3QgYmUgc3RhYmxlIGZvciB0aGlzIHRvIHdvcmsgYXMgaW50ZW50ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhyb3R0bGVkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IFRocm90dGxlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhyb3R0bGVkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IFRocm90dGxlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xyXG4gICAgY29uc3QgdGhyb3R0bGVkID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gdGhyb3R0bGUoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcclxuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8udHJhaWxpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0aHJvdHRsZWQ/LmNhbmNlbCgpO1xyXG4gICAgfSwgW3Rocm90dGxlZF0pXHJcblxyXG4gICAgcmV0dXJuIHRocm90dGxlZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYGRlYm91bmNlZGAgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBJZiB0aGUgY2FsbGJhY2sgaXMgYG51bGxgLCB0aGVuIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgYGNhbGxiYWNrYCBtdXN0IGJlIHN0YWJsZSBmb3IgdGhpcyB0byB3b3JrIGFzIGludGVudGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBEZWJvdW5jZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xyXG4gICAgY29uc3QgZGVib3VuY2VkID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gZGVib3VuY2UoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcclxuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8ubWF4V2FpdCwgb3B0aW9ucz8udHJhaWxpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBkZWJvdW5jZWQ/LmNhbmNlbCgpO1xyXG4gICAgfSwgW2RlYm91bmNlZF0pXHJcblxyXG4gICAgcmV0dXJuIGRlYm91bmNlZDtcclxufVxyXG5cclxudHlwZSBTeW5jRnVuY3Rpb25UeXBlPFNQIGV4dGVuZHMgdW5rbm93bltdLCBSPiA9ICguLi5hcmdzOiBTUCkgPT4gKFIgfCB1bmRlZmluZWQpO1xyXG50eXBlIEFzeW5jRnVuY3Rpb25UeXBlPEFQIGV4dGVuZHMgdW5rbm93bltdLCBSPiA9ICgoLi4uYXJnczogQVApID0+IChSIHwgUHJvbWlzZTxSPikpO1xyXG50eXBlIEdsdWVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKGVucXVldWU6IGJvb2xlYW4sIC4uLmFyZ3M6IEFQKSA9PiBSIHwgdW5kZWZpbmVkO1xyXG50eXBlIENhcHR1cmVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+ID0gKC4uLmFyZ3M6IFNQKSA9PiBBUDtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhc3luYyBmdW5jdGlvbiwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQncyBzdWl0YWJsZSBmb3Igbm9uLWFzeW5jIEFQSXMsIFxyXG4gKiBhbG9uZyB3aXRoIG90aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHJ1bidzIHN0YXR1cy5cclxuICogXHJcbiAqIFNlZSBhbHNvIGB1c2VBc3luY0hhbmRsZXJgIGZvciBhIHZlcnNpb24gdGhhdCdzIHNwZWNpYWxpemVkIGZvciBET00gZXZlbnQgaGFuZGxlcnMuXHJcbiAqIFxyXG4gKiBXaGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBxdWljayBzdWNjZXNzaW9uLCAoaS5lLiBiZWZvcmUgdGhlIGhhbmRsZXIgaGFzIGZpbmlzaGVkKSwgXHJcbiAqIHRoaXMgd29ya3MgbGlrZSBMb2Rhc2gncyBgdGhyb3R0bGVgIGZ1bmN0aW9uIHdpdGggdGhlIGB3YWl0YCBvcHRpb24gYWx3YXlzXHJcbiAqIHNldCB0byBob3dldmVyIGxvbmcgdGhlIGhhbmRsZXIgdGFrZXMgdG8gY29tcGxldGUuIEEgc2Vjb25kIGNhbGwgdG8gdGhlIHN5bmMgZnVuY3Rpb24gd2lsbCBiZSBcclxuICogdGhyb3R0bGVkIHVudGlsIHRoZSBmaXJzdCBjYWxsIGhhcyBmaW5pc2hlZC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBcclxuICogb2YgdGhlIHByZXZpb3VzIGludm9jYXRpb24sIG9yIGB1bmRlZmluZWRgIG9uIHRoZSBmaXJzdCBjYWxsLlxyXG4gKiBcclxuICogVGhlIGhhbmRsZXIgaXMgb25seSBldmVyIGRlbGF5ZWQgaWYgb25lIGlzIGN1cnJlbnRseSBydW5uaW5nLCBzbywgZS5nLiBmb3IgaU9TIHRvdWNoIGV2ZW50cyB0aGVcclxuICogZmlyc3QgY2FsbCBoYXBwZW5zIGluIHRoZSBzYW1lIGV2ZW50IGhhbmRsZXIgKHdoaWNoIG1lYW5zIHRoaW5ncyBsaWtlIGNhbGxzIHRvIGBlbGVtZW50LmZvY3VzKClgXHJcbiAqIHdpbGwgd29yayBhcyBpbnRlbmRlZCwgc2luY2UgdGhhdCBmYWlscyB3aGVuIHRoZSBldmVudCBpcyBcInNwbGl0IHVwXCIpXHJcbiAqIFxyXG4gKiBGaW5hbGx5LCBiZWNhdXNlIHRoZSBzeW5jIGhhbmRsZXIgbWF5IGJlIGludm9rZWQgb24gYSBkZWxheSwgYW55IHByb3BlcnR5IHJlZmVyZW5jZXMgb24gdGhlIGFyZ3VtZW50c1xyXG4gKiBwcm92aWRlZCBtaWdodCBiZSBzdGFsZSBieSB0aGUgdGltZSBpdCdzIGFjdHVhbGx5IGludm9rZWQgKGUuZy4gYWNjZXNzaW5nIGBldmVudC5jdXJyZW50VGFyZ2V0LmNoZWNrZWRgXHJcbiAqIGlzIG5vdCBzdGFibGUgYWNyb3NzIHRpbWUgYmVjYXVzZSBpdCdzIGEgXCJsaXZlXCIgdmFsdWUgLS0geW91IGFsbW9zdCBhbHdheXMgd2FudCB0aGUgdmFsdWUgdGhhdCBpdFxyXG4gKiBoYWQgYXQgdGhlIG9yaWdpbmFsIHRpbWUgdGhlIGhhbmRsZXIgd2FzIGNhbGxlZCkuIFRoZSBgY2FwdHVyZWAgb3B0aW9uIGFsbG93cyB5b3UgdG8gc2F2ZSB0aGF0IGtpbmQgb2ZcclxuICogZHluYW1pYyBkYXRhIGF0IHRoZSB0aW1lIGl0IHJ1bnM7IHRoZSBgQVBgIGFuZCBgU1BgIHR5cGUgcGFyYW1ldGVycyBsaWtld2lzZSBjb250cm9sXHJcbiAqIHRoZSBwYXJhbWV0ZXJzIHRoZSBhc3luYyBoYW5kbGVyIGFuZCBzeW5jIGhhbmRsZXIgZXhwZWN0IHJlc3BlY3RpdmVseS5cclxuICogXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFIsIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+KGFzeW5jSGFuZGxlcjogQXN5bmNGdW5jdGlvblR5cGU8QVAsIFI+IHwgbnVsbCwgb3B0aW9ucz86IFVzZUFzeW5jUGFyYW1ldGVyczxBUCwgU1A+KTogVXNlQXN5bmNSZXR1cm5UeXBlPFNQLCBSPiB7XHJcblxyXG5cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xyXG4gICAgbGV0IHsgdGhyb3R0bGUsIGRlYm91bmNlLCBjYXB0dXJlIH0gPSAob3B0aW9ucyA/PyB7fSk7XHJcbiAgICBjYXB0dXJlID8/PSBpZGVudGl0eTtcclxuXHJcbiAgICAvLyBXZSBrZWVwLCBsaWtlLCBhIGxvdCBvZiByZW5kZXItc3RhdGUsIGJ1dCBpdCBvbmx5IGV2ZXIgdHJpZ2dlcnMgYSByZS1yZW5kZXJcclxuICAgIC8vIHdoZW4gd2Ugc3RhcnQvc3RvcCBhbiBhc3luYyBhY3Rpb24uXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGZvciB0aGUgY2FsbGVyJ3Mgc2FrZSAtLSB3ZSBkb24ndCByZWFsbHkgY2FyZS5cclxuICAgIGNvbnN0IFtjdXJyZW50VHlwZSwgc2V0Q3VycmVudFR5cGVdID0gdXNlU3RhdGU8bnVsbCB8IFwic3luY1wiIHwgXCJhc3luY1wiPihudWxsKTtcclxuICAgIGNvbnN0IFtydW5Db3VudCwgc2V0UnVuQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2V0dGxlQ291bnQsIHNldFNldHRsZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3Jlc29sdmVDb3VudCwgc2V0UmVzb2x2ZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3JlamVjdENvdW50LCBzZXRSZWplY3RDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICAvLyBUaGluZ3MgcmVsYXRlZCB0byBjdXJyZW50IGV4ZWN1dGlvblxyXG4gICAgLy8gQmVjYXVzZSB3ZSBjYW4gYm90aCByZXR1cm4gYW5kIHRocm93IHVuZGVmaW5lZCwgXHJcbiAgICAvLyB3ZSBuZWVkIHNlcGFyYXRlIHN0YXRlIHRvIHRyYWNrIHRoZWlyIGV4aXN0YW5jZSB0b28uXHJcbiAgICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZywgZ2V0UGVuZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHQsIGdldFJlc3VsdF0gPSB1c2VTdGF0ZTxSPih1bmRlZmluZWQhKTtcclxuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3IsIF9nZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duPih1bmRlZmluZWQhKTtcclxuICAgIGNvbnN0IFtoYXNFcnJvciwgc2V0SGFzRXJyb3IsIF9nZXRIYXNFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaGFzUmVzdWx0LCBzZXRIYXNSZXN1bHQsIF9nZXRIYXNSZXN1bHRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIC8vIFdlIGltcGxlbWVudCBvdXIgb3duIHRocm90dGxpbmcgYmVoYXZpb3IgaW4gcmVnYXJkcyB0byB3YWl0aW5nIHVudGlsIHRoZSBhc3luYyBoYW5kbGVyIGZpbmlzaGVzLlxyXG4gICAgLy8gVGhlc2UgdHdvIHBhc3NpdmUgc3RhdGUgdmFyaWFibGVzIGtlZXAgdHJhY2sgb2YgdGhhdCwgYXV0b21hdGljYWxseSBxdWV1ZWluZy9kZXF1ZXVpbmcgdGhlIG5leHQgaGFuZGxlci5cclxuICAgIGNvbnN0IFtnZXRRdWV1ZWQsIHNldFF1ZXVlZF0gPSB1c2VQYXNzaXZlU3RhdGU8QVAgfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcclxuXHJcblxyXG4gICAgLy8gVGhlIGFjdHVhbCBzeW5jIGhhbmRsZXIuXHJcbiAgICAvLyBDYXB0dXJlL3RyYW5zZm9ybSB0aGUgZ2l2ZW4gcGFyYW1ldGVycyBpZiBhcHBsaWNhYmxlLFxyXG4gICAgLy8gdGhlbiBydW4gZnVydGhlciBsb2dpYyB0aGF0J3MgZGVib3VuY2VkL3Rocm90dGxlZFxyXG4gICAgY29uc3QgY2FwdHVyZUFyZ3NBbmRFeGVjdXRlRGVib3VuY2VkSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrPFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+PihmdW5jdGlvbiBvbk5ld0V4ZWN1dGVSZXF1ZXN0KC4uLm5ld0FyZ3MyOiBTUCkge1xyXG5cclxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBhcmd1bWVudHMgd2Ugd2VyZSBnaXZlbi5cclxuICAgICAgICAvLyBXZSBtaWdodCB1c2UgdGhlbSBpbW1lZGlhdGVseSwgb3Igd2UgbWlnaHQgc3RvcmUgdGhlbSB0byBgcXVldWVkYCxcclxuICAgICAgICAvLyBidXQgaW4gZWl0aGVyIGNhc2Ugd2UgZG8gbmVlZCB0aGUgY2FwdHVyZWQgdmFsdWUuXHJcbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlISguLi5uZXdBcmdzMik7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgYWxsIGxvZ2ljIHRoYXQgZGVhbHMgd2l0aCB0aGUgY2FwdHVyZWQgdmFsdWUgaW5zdGVhZCBvZiB0aGUgcmF3IGFyZ3VtZW50cy5cclxuICAgICAgICAvLyBJdCdzIGNhbGxlZCBpbiB0d28gc2VwYXJhdGUgY2lyY3Vtc3RhbmNlcyxcclxuICAgICAgICAvLyBhbmQgaGFzIHRoZSBkZWJvdW5jZS90aHJvdHRsZSBsb2dpYyBhbHJlYWR5IGFwcGxpZWRcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZ2V0UGVuZGluZygpLCAuLi5jYXB0dXJlZCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVGhpcyBpcyB0aGUgbG9naWMgdGhhdCBydW5zIHdoZW4gdGhlIGhhbmRsZXIgaXMgKmp1c3QqIGFib3V0IHRvIHN0YXJ0LlxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpdHNlbGYgaXMgZnVydGhlciB0cmFuc2Zvcm1lZCB0byBiZSB0aHJvdHRsZWQvZGVib3VuY2VkIGlmIHJlcXVlc3RlZCxcclxuICAgIC8vIHNvIHRoaXMgbWlnaHQgbm90IGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBcclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlID0gdXNlU3RhYmxlQ2FsbGJhY2s8R2x1ZUZ1bmN0aW9uVHlwZTxBUCwgUj4+KGZ1bmN0aW9uIG9uTmV3RXhlY3V0ZVJlcXVlc3QyKGVucXVldWU6IGJvb2xlYW4sIC4uLm5ld0FyZ3M6IEFQKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uVGhlbiA9ICh2YWx1ZTogUikgPT4geyBzZXRSZXN1bHQodmFsdWUpOyBzZXRIYXNSZXN1bHQodHJ1ZSk7IHNldEhhc0Vycm9yKGZhbHNlKTsgc2V0UmVzb2x2ZUNvdW50KHIgPT4gKytyKTsgfTtcclxuICAgICAgICBjb25zdCBvbkNhdGNoID0gKGV4OiBhbnkpID0+IHsgc2V0RXJyb3IoZXgpOyBzZXRIYXNFcnJvcih0cnVlKTsgc2V0SGFzUmVzdWx0KGZhbHNlKTsgc2V0UmVqZWN0Q291bnQociA9PiArK3IpOyB9O1xyXG4gICAgICAgIGNvbnN0IG9uRmluYWxseSA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcXVldWVkID0gZ2V0UXVldWVkKCk7XHJcbiAgICAgICAgICAgIHNldFNldHRsZUNvdW50KHMgPT4gKytzKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0UXVldWVkKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZmFsc2UsIC4uLnF1ZXVlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIWVucXVldWUpIHtcclxuICAgICAgICAgICAgLy8gTm90aGluZyBpcyBwZW5kaW5nIGF0IHRoZSBtb21lbnQsIHNvIHdlIGNhbiBydW4gb3VyIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICBzZXRSdW5Db3VudChyID0+ICsrcik7XHJcbiAgICAgICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzeW5jSGFuZGxlcj8uKC4uLm5ld0FyZ3MpIGFzIFI7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUHJvbWlzZSA9IChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gKHJlc3VsdCBhcyB1bmtub3duIGFzIFByb21pc2U8YW55PikpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgIWlzUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBzeW5jaHJvbm91cyBhbmQgcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkuXHJcbiAgICAgICAgICAgICAgICBvblRoZW4ocmVzdWx0IGFzIFIpO1xyXG4gICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZShcInN5bmNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocmVzdWx0IGFzIHVua25vd24gYXMgUHJvbWlzZTxSPikudGhlbihvblRoZW4pLmNhdGNoKG9uQ2F0Y2gpLmZpbmFsbHkob25GaW5hbGx5KTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlKFwiYXN5bmNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgc3RpbGwgcnVubmluZyBhIHByZXZpb3VzIGhhbmRsZXIsXHJcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IG91cnNlbHZlcyBhcyB0aGUgbmV4dCBvbmUgdG8gcnVuIGFuZCBxdWl0IGVhcmx5LlxyXG4gICAgICAgICAgICAvLyBOb3RoaW5nIG1vcmUgdG8gZG8uXHJcbiAgICAgICAgICAgIHNldFF1ZXVlZChuZXdBcmdzKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHJldHVybiBnZXRSZXN1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPSB1c2VUaHJvdHRsZWQ8Tm9uTnVsbGFibGU8dHlwZW9mIGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlPj4oIXRocm90dGxlID8gbnVsbCA6IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlLCB0aHJvdHRsZSA/PyAwKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aEQgPSB1c2VEZWJvdW5jZWQoIWRlYm91bmNlID8gbnVsbCA6IChleGVjdXRlSGFuZGxlcldpdGhUID8/IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlKSwgZGVib3VuY2UgPz8gMCk7XHJcbiAgICBjb25zdCBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZSA9IChleGVjdXRlSGFuZGxlcldpdGhEID8/IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPz8gZXhlY3V0ZUhhbmRsZXJXaXRob3V0RGVib3VuY2UpO1xyXG5cclxuICAgIGNvbnN0IGZsdXNoRGVib3VuY2VkUHJvbWlzZSA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAoZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UgJiYgXCJmbHVzaFwiIGluIGV4ZWN1dGVIYW5kbGVyV2l0aERlYm91bmNlKVxyXG4gICAgICAgICAgICBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZS5mbHVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzeW5jSGFuZGxlcjogY2FwdHVyZUFyZ3NBbmRFeGVjdXRlRGVib3VuY2VkSGFuZGxlcixcclxuICAgICAgICBjdXJyZW50VHlwZSxcclxuICAgICAgICBwZW5kaW5nLFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBoYXNFcnJvcixcclxuICAgICAgICBoYXNSZXN1bHQsXHJcbiAgICAgICAgcmVzb2x2ZUNvdW50LFxyXG4gICAgICAgIHJlamVjdENvdW50LFxyXG4gICAgICAgIHNldHRsZUNvdW50LFxyXG4gICAgICAgIGNhbGxDb3VudDogcnVuQ291bnQsXHJcbiAgICAgICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmMsIFVzZUFzeW5jUGFyYW1ldGVycywgVXNlQXN5bmNSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFzeW5jXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY0hhbmRsZXJQYXJhbWV0ZXJzPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4gZXh0ZW5kcyBPbWl0PFVzZUFzeW5jUGFyYW1ldGVyczxbQ2FwdHVyZVR5cGUsIEV2ZW50VHlwZV0sIFtFdmVudFR5cGVdPiwgXCJjYXB0dXJlXCI+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hhdCB0cmFuc2llbnQgaW5mb3JtYXRpb24gaXMgY2FwdHVyZWQgYnkgdGhpcyBldmVudCBcclxuICAgICAqIGFuZCBwcmVzZW50ZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBldmVudCBoYW5kbGVyP1xyXG4gICAgICogXHJcbiAgICAgKiBUaGUgXCJjYXB0dXJlXCIgcGFyYW1ldGVyIGFuc3dlcnMgdGhpcyBxdWVzdGlvbi4gVG8gaW1wbGVtZW50IGEgY2hlY2tib3gsIGZvciBleGFtcGxlLCByZXR1cm4gYHRhcmdldC5jaGVja2VkYC5cclxuICAgICAqL1xyXG4gICAgY2FwdHVyZTogKGV2ZW50OiBFdmVudFR5cGUpID0+IENhcHR1cmVUeXBlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFzeW5jSGFuZGxlclJldHVyblR5cGU8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQsIENhcHR1cmVUeXBlPiBleHRlbmRzIFVzZUFzeW5jUmV0dXJuVHlwZTxbRXZlbnRUeXBlXSwgdm9pZD4ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50bHkgY2FwdHVyZWQgdmFsdWUuIEluIG90aGVyIHdvcmRzLCByZXByZXNlbnRzIHdoYXRcclxuICAgICAqIHRoZSBjdXJyZW50IHZhbHVlIHdvdWxkIGJlIGlmIHRoaXMgb3BlcmF0aW9uIHdlcmUgc3luY2hyb25vdXMgYW5kIFxyXG4gICAgICogYW5kIGNvdWxkbid0IGZhaWwuIEl0J3MgdXNlZnVsIHRvIHByZXRlbmQgdGhpcyBpcyB0aGUgYWN0dWFsIHZhbHVlXHJcbiAgICAgKiBmb3IgYW4gaW5wdXQgZmllbGQsIGZvciBleGFtcGxlLCBzbyB0aGF0IHRoZSB2YWx1ZSBkb2Vzbid0IFwic25hcFxyXG4gICAgICogYmFja1wiIHdoaWxlIHlvdSdyZSB3YWl0aW5nIGZvciB0aGUgaGFuZGxlciB0byBmaW5pc2guXHJcbiAgICAgKiBcclxuICAgICAqIFNvbWV0aGluZyBsaWtlIGB2YWx1ZT17cGVuZGluZz8gY3VycmVudENhcHR1cmUgOiB2YWx1ZX1gIGlzIGdvb2QgZm9yIGNoZWNrYm94ZXMsXHJcbiAgICAgKiBzb21ldGhpbmcgbGlrZSBgdmFsdWU9eyhwZW5kaW5nIHx8IGhhc0ZvY3VzKT8gY3VycmVudENhcHR1cmUgOiB2YWx1ZX0gZm9yIHRleHQgZmllbGRzLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIGhhc0NhcHR1cmVcclxuICAgICAqL1xyXG4gICAgY3VycmVudENhcHR1cmU6IENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFRoZSBhYm92ZSwgYnV0IHN0YWJsZSwgaWYgeW91IG5lZWQgdGhlIGN1cnJlbnQgY2FwdHVyZSB3aXRob3V0IGl0IGJlaW5nIGFuIGV4cGxpY2l0IGRlcGVuZGVuY3kuXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKiAgKi9cclxuICAgIGdldEN1cnJlbnRDYXB0dXJlKCk6IChDYXB0dXJlVHlwZSB8IHVuZGVmaW5lZCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWNhdXNlIHlvdSdyZSBhbGxvd2VkIHRvIGhhdmUgYENhcHR1cmVUeXBlYCBleHRlbmQgYHVuZGVmaW5lZGAsXHJcbiAgICAgKiB5b3UgbWlnaHQgbmVlZCB0aGlzLlxyXG4gICAgICovXHJcbiAgICBoYXNDYXB0dXJlOiBib29sZWFuO1xyXG5cclxuICAgIC8vIFNhbWUgYXMgaW4gdXNlQXN5bmMsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IHR5cGVcclxuICAgIC8vcHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGw7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXN5bmNyb25vdXMgZXZlbnQgaGFuZGxlciwgcmV0dXJucyBhIHN5bmNyb25vdXMgb25lIHRoYXQgd29ya3Mgb24gdGhlIERPTSxcclxuICogYWxvbmcgd2l0aCBzb21lIG90aGVyIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAqIERvZXMgbm90IG1vZGlmeSBhbnkgcHJvcHMuXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB0aGUgaGFuZGxlciB5b3UgcHJvdmlkZSBtYXkgYmUgY2FsbGVkIHdpdGggYSBkZWxheSwgYW5kIFxyXG4gKiBiZWNhdXNlIHRoZSB2YWx1ZSBvZiwgZS5nLiwgYW4gYDxpbnB1dD5gIGVsZW1lbnQgd2lsbCBsaWtlbHkgYmUgc3RhbGUgYnkgdGhlIFxyXG4gKiB0aW1lIHRoZSBkZWxheSBpcyBvdmVyLCBhIGBjYXB0dXJlYCBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gXHJcbiAqIGNhcHR1cmUgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gQW55IG90aGVyIHNpbXBsZSBldmVudCBkYXRhLCBcclxuICogbGlrZSBgbW91c2VYYCBvciBgc2hpZnRLZXlgIGNhbiBzdGF5IG9uIHRoZSBldmVudCBpdHNlbGYgYW5kIGRvbid0IFxyXG4gKiBuZWVkIHRvIGJlIGNhcHR1cmVkICZuZGFzaDsgaXQncyBuZXZlciBzdGFsZS5cclxuICogXHJcbiAqIGBgYHRzeFxyXG4gKiBjb25zdCBhc3luY09uSW5wdXQgPSBhc3luYyAodmFsdWU6IG51bWJlciwgZTogRXZlbnQpID0+IHsgXHJcbiAqICAgICBbLi4uXSAvLyBFeC4gc2VuZCB0byBhIHNlcnZlciBhbmQgc2V0U3RhdGUgd2hlbiBkb25lXHJcbiAqIH07XHJcbiAqIGNvbnN0IHtcclxuICogICAgIC8vIEEgc3luYyB2ZXJzaW9uIG9mIGFzeW5jT25JbnB1dFxyXG4gKiAgICAgc3luY0hhbmRsZXIsXHJcbiAqICAgICAvLyBUcnVlIHdoaWxlIHRoZSBoYW5kbGVyIGlzIHJ1bm5pbmdcclxuICogICAgIHBlbmRpbmcsXHJcbiAqICAgICAvLyBUaGUgZXJyb3IgdGhyb3duLCBpZiBhbnlcclxuICogICAgIGVycm9yLFxyXG4gKiAgICAgLy8gU2hvdyB0aGlzIHZhbHVlIHdoaWxlIHRoZSBvcGVyYXRpb24ncyBwZW5kaW5nXHJcbiAqICAgICBjdXJyZW50Q2FwdHVyZSxcclxuICogICAgIC8vIEFuZCBvdGhlcnMsIHNlZSBgVXNlQXN5bmNIYW5kbGVyUmV0dXJuVHlwZWBcclxuICogICAgIC4uLnJlc3RcclxuICogfSA9IHVzZUFzeW5jSGFuZGxlcjxIVE1MSW5wdXRFbGVtZW50PigpKGFzeW5jT25JbnB1dCwgeyBcclxuICogICAgIC8vIFBhc3MgaW4gdGhlIGNhcHR1cmUgZnVuY3Rpb24gdGhhdCBzYXZlcyBldmVudCBkYXRhXHJcbiAqICAgICAvLyBmcm9tIGJlaW5nIHN0YWxlLlxyXG4gKiAgICAgY2FwdHVyZTogZSA9PiB7IFxyXG4gKiAgICAgICAgIC8vIGBjYXB0dXJlYCBjYW4gaGF2ZSBzaWRlLWVmZmVjdHMgYmVjYXVzZVxyXG4gKiAgICAgICAgIC8vIGl0J3MgY2FsbGVkIGV4YWN0bHkgb25jZSBwZXIgaW52b2NhdGlvblxyXG4gKiAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgXHJcbiAqIFxyXG4gKiAgICAgICAgIC8vIFNhdmUgdGhpcyB2YWx1ZSBzbyB0aGF0IGl0J3MgbmV2ZXIgc3RhbGVcclxuICogICAgICAgICByZXR1cm4gZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXI7XHJcbiAqICAgICB9XHJcbiAqIH0pO1xyXG4gKiBcclxuICogY29uc3Qgb25JbnB1dCA9IHBlbmRpbmc/IG51bGwgOiBzeW5jSGFuZGxlcjtcclxuICogYGBgXHJcbiAqIFxyXG4gKiBUaGUgaGFuZGxlciBpcyBhdXRvbWF0aWNhbGx5IHRocm90dGxlZCB0byBvbmx5IHJ1biBvbmUgYXQgYSB0aW1lLiBcclxuICogSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkLCBhbmQgdGhlbiBiZWZvcmUgaXQgZmluaXNoZXMsIGlzIGNhbGxlZCBhZ2FpbixcclxuICogaXQgd2lsbCBiZSBwdXQgb24gaG9sZCB1bnRpbCB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsIGF0IHdoaWNoIHBvaW50XHJcbiAqIHRoZSBzZWNvbmQgb25lIHdpbGwgcnVuLiAgSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkIGEgdGhpcmQgdGltZSBiZWZvcmVcclxuICogdGhlIGZpcnN0IGhhcyBmaW5pc2hlZCwgaXQgd2lsbCAqcmVwbGFjZSogdGhlIHNlY29uZCwgc28gb25seSB0aGUgbW9zdFxyXG4gKiByZWNlbnRseSBjYWxsZWQgaXRlcmF0aW9uIG9mIHRoZSBoYW5kbGVyIHdpbGwgcnVuLlxyXG4gKiBcclxuICogXHJcbiAqIFlvdSBtYXkgb3B0aW9uYWxseSAqYWxzbyogc3BlY2lmeSBkZWJvdW5jZSBhbmQgdGhyb3R0bGUgcGFyYW1ldGVycyB0aGF0IHdhaXQgdW50aWwgdGhlXHJcbiAqIHN5bmNyb25vdXMgaGFuZGxlciBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxyXG4gKiBtaWxsaXNlY29uZHMsIGF0IHdoaWNoIHBvaW50IHdlICphY3R1YWxseSogcnVuIHRoZSBhc3luY3Jvbm91cyBoYW5kbGVyXHJcbiAqIGFjY29yZGluZyB0byB0aGUgbG9naWMgaW4gdGhlIHByZXZpb3VzIHBhcmFncmFwaC4gVGhpcyBpcyBpblxyXG4gKiAqYWRkaXRpb24qIHRvIHRocm90dGxpbmcgdGhlIGhhbmRsZXIsIGFuZCBkb2VzIG5vdCByZXBsYWNlIHRoYXQgYmVoYXZpb3IuXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUFzeW5jIEEgbW9yZSBnZW5lcmFsIHZlcnNpb24gb2YgdGhpcyBob29rIHRoYXQgY2FuIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBoYW5kbGVyLCBub3QganVzdCBET00gZXZlbnQgaGFuZGxlcnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNIYW5kbGVyPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4oYXN5bmNIYW5kbGVyOiAoKGM6IENhcHR1cmVUeXBlLCBlOiBFdmVudFR5cGUpID0+IChQcm9taXNlPHZvaWQ+IHwgdm9pZCkpIHwgbnVsbCwgeyBjYXB0dXJlOiBvcmlnaW5hbENhcHR1cmUsIC4uLnJlc3RBc3luY09wdGlvbnMgfTogVXNlQXN5bmNIYW5kbGVyUGFyYW1ldGVyczxFdmVudFR5cGUsIENhcHR1cmVUeXBlPik6IFVzZUFzeW5jSGFuZGxlclJldHVyblR5cGU8RXZlbnRUeXBlLCBDYXB0dXJlVHlwZT4ge1xyXG4gICAgXHJcbiAgICAvLyBXZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBcIm5vdGhpbmcgY2FwdHVyZWQgeWV0XCIgYW5kIFwiYHVuZGVmaW5lZGAgd2FzIGNhcHR1cmVkXCJcclxuICAgIGNvbnN0IFtjdXJyZW50Q2FwdHVyZSwgc2V0Q3VycmVudENhcHR1cmUsIGdldEN1cnJlbnRDYXB0dXJlXSA9IHVzZVN0YXRlPENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgW2hhc0NhcHR1cmUsIHNldEhhc0NhcHR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgXHJcbiAgICAvLyBXcmFwIGFyb3VuZCB0aGUgbm9ybWFsIGB1c2VBc3luY2AgYGNhcHR1cmVgIGZ1bmN0aW9uIHRvIGFsc29cclxuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdmFsdWUgdGhlIHVzZXIgYWN0dWFsbHkgaW5wdXQuXHJcbiAgICAvLyBcclxuICAgIC8vIFdpdGhvdXQgdGhpcyB0aGVyZSdzIG5vIHdheSB0byByZS1yZW5kZXIgdGhlIGNvbnRyb2wgd2l0aFxyXG4gICAgLy8gaXQgYmVpbmcgYm90aCBjb250cm9sbGVkIGFuZCBhbHNvIGhhdmluZyB0aGUgXCJjb3JyZWN0XCIgdmFsdWUsXHJcbiAgICAvLyBhbmQgYXQgYW55IHJhdGUgYWxzbyBwcm90ZWN0cyBhZ2FpbnN0IHN1ZGRlbiBleGNlcHRpb25zIHJldmVydGluZ1xyXG4gICAgLy8geW91ciBjaGFuZ2Ugb3V0IGZyb20gdW5kZXIgeW91LlxyXG4gICAgY29uc3QgY2FwdHVyZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBFdmVudFR5cGUpOiBbQ2FwdHVyZVR5cGUsIEV2ZW50VHlwZV0gPT4geyBcclxuICAgICAgICBjb25zdCBjYXB0dXJlZCA9IG9yaWdpbmFsQ2FwdHVyZShlKTsgXHJcbiAgICAgICAgc2V0Q3VycmVudENhcHR1cmUoY2FwdHVyZWQpO1xyXG4gICAgICAgIHNldEhhc0NhcHR1cmUodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIFtjYXB0dXJlZCwgZV07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgIGN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgIGhhc0NhcHR1cmUsXHJcbiAgICAgICAgLi4udXNlQXN5bmMoYXN5bmNIYW5kbGVyLCB7IGNhcHR1cmUsIC4uLnJlc3RBc3luY09wdGlvbnMgfSlcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7IElucHV0cywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdE5hdGl2ZSwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuLyoqXHJcbiAqIFdyYXAgdGhlIG5hdGl2ZSBgdXNlRWZmZWN0YCB0byBhZGQgYXJndW1lbnRzIFxyXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICogQHBhcmFtIGltcGwgWW91IGNhbiBjaG9vc2Ugd2hldGhlciB0byB1c2UgYHVzZUVmZmVjdGAgb3IgYHVzZUxheW91dEVmZmVjdGAgYnlcclxuICogcGFzc2luZyBvbmUgb2YgdGhlbSBhcyB0aGlzIGFyZ3VtZW50LiBCeSBkZWZhdWx0LCBpdCdzIGB1c2VFZmZlY3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEksIGltcGwgPSB1c2VFZmZlY3ROYXRpdmUpIHtcclxuXHJcbiAgICBjb25zdCBwcmV2SW5wdXRzID0gdXNlUmVmPHVuZGVmaW5lZCB8IEk+KHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBlZmZlY3QyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IHsgZnJvbTogYW55LCB0bzogYW55IH1bXSA9IFtdO1xyXG4gICAgICAgIGlmIChpbnB1dHMgJiYgcHJldklucHV0cy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgocHJldklucHV0cy5jdXJyZW50Lmxlbmd0aCwgaW5wdXRzLmxlbmd0aCk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZJbnB1dHMuY3VycmVudFtpXSAhPSBpbnB1dHNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1tpXSA9IHsgZnJvbTogcHJldklucHV0cy5jdXJyZW50W2ldLCB0bzogaW5wdXRzW2ldIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXQgPSBlZmZlY3QocHJldklucHV0cy5jdXJyZW50LCBjaGFuZ2VzKTtcclxuICAgICAgICBwcmV2SW5wdXRzLmN1cnJlbnQgPSBpbnB1dHM7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcblxyXG4gICAgaW1wbChlZmZlY3QyLCBpbnB1dHMpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVmZmVjdENoYW5nZTxJIGV4dGVuZHMgSW5wdXRzLCBOIGV4dGVuZHMgbnVtYmVyPiB7IGZyb206IElbTl0sIHRvOiBJW05dIH1cclxuIiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0TmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWZmZWN0Q2hhbmdlLCB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XG5cbi8qKlxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYXMgd2VsbCBhcyB0aGUgY2hhbmdlcyB0aGF0IGNhdXNlZCB0aGUgaG9vayB0byBiZSBjYWxsZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3Q8SSBleHRlbmRzIElucHV0cz4oZWZmZWN0OiAocHJldjogSSB8IHVuZGVmaW5lZCwgY2hhbmdlczogRWZmZWN0Q2hhbmdlPEksIG51bWJlcj5bXSkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpLCBpbnB1dHM/OiBJKSB7XG4gICAgcmV0dXJuIHVzZUVmZmVjdChlZmZlY3QsIGlucHV0cywgdXNlTGF5b3V0RWZmZWN0TmF0aXZlKTtcbn1cbiIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogUmVtaW5kZXIgb2Ygb3JkZXIgb2YgZXhlY3V0aW9uOlxyXG4gKiBcclxuICogKiAodHJlZSBtb3VudHMpXHJcbiAqICogUGFyZW50IHJlbmRlcnNcclxuICogKiBDaGlsZHJlbiByZW5kZXJcclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcclxuICogKiBQYXJlbnQgcmVjZWl2ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxyXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXHJcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xyXG4gKiBcclxuICogKiAodHJlZSB1bm1vdW50cylcclxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxyXG4gKiAqIFBhcmVudCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcclxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXHJcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXHJcbiAqIFxyXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcclxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cclxuICogKiByZWZzIGFyZSAqdXN1YWxseSogY2FsbGVkIGJlZm9yZSBlZmZlY3RzLCBidXQgb25seSB3aGVuIHRoYXQgSFRNTEVsZW1lbnQgcmVuZGVycy4gQmFzaWNhbGx5IGp1c3QgYSByZW1pbmRlciB0aGF0IGEgY29tcG9uZW50IGNhbiBiZSBtb3VudGVkIHdpdGhvdXQgaXQgZXhpc3RpbmcgaW4gdGhlIERPTS5cclxuICovXHJcbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXHJcbiAqIFxyXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXHJcbiAqICogYGZsYWdzYCBhcmUgcXVpY2stYW5kLWVhc3kgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IHlvdSBjYW4gb3B0aW9uYWxseSB1c2VcclxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xyXG4gICAgaW5kZXg6IFQ7XHJcbiAgICBmbGFncz86IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PjtcclxuICAgIHN1YkluZm86IEM7XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcclxuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XHJcblxyXG5pbnRlcmZhY2UgTUNQPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmc+IHtcclxuICAgIC8qKlxyXG4gICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cclxuICAgICAqIFxyXG4gICAgICogT25seSBvbmUgd2lsbCBydW4gcGVyIHRpY2ssIGp1c3QgbGlrZSBsYXlvdXRFZmZlY3QsIGJ1dCBpdCBpc24ndFxyXG4gICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxyXG4gICAgICovXHJcbiAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyA9IGtleW9mIE1DUDxhbnk+O1xyXG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRPbWl0cyA9IGtleW9mIE1hbmFnZWRDaGlsZEluZm88YW55LCBhbnksIGFueT47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgT21pdHMgZXh0ZW5kcyBrZXlvZiBNQ1A8VD4+IHtcclxuICAgIG1hbmFnZWRDaGlsZHJlbjogT21pdDxNQ1A8VD4sIE9taXRzPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cz4ge1xyXG4gICAgbWFuYWdlZENoaWxkOiBPbWl0PE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4sIE1jT21pdHM+O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNoaWxkIHRoYXQgcmVuZGVyZWQgaXRzZWxmIHdpdGggdGhlIHJlcXVlc3RlZCBrZXkuXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxyXG4gICAgICovXHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcclxuICAgICAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPFQsIEMsIEs+O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxULCBDLCBLPiB7XHJcbiAgICAvKipcclxuICAgICAqIEEgaG9vayB0aGF0IG11c3QgYmUgY2FsbGVkIGJ5IGV2ZXJ5IGNoaWxkIGNvbXBvbmVudCB0aGF0XHJcbiAgICAgKiBpcyB0byBiZSBtYW5hZ2VkIGJ5IHRoaXMgb25lLiBUaGUgYXJndW1lbnQgdG8gdGhlIGhvb2tcclxuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcclxuICAgICAqIGluY2x1ZGluZyB0aGUgY2hpbGQncyBpbmRleC5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICB1c2VNYW5hZ2VkQ2hpbGQ6IFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XHJcblxyXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGQ8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxULCBDLCBLLCBuZXZlcj4pID0+IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRBdChpbmRleDogVCk6IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPikgPT4gdm9pZCkgPT4gdm9pZDtcclxuXHJcbiAgICAvKiogKipVTlNUQUJMRSoqLCBhbHNvIGludGVybmFsLXVzZSBvbmx5LCBhbHNvIFRPRE8gbmVlZCBhIHdvcmthcm91bmQgZm9yIHRoaXMgZm9yIHNvcnRhYmxlIGNoaWxkcmVuICovXHJcbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+W107XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8vZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxJIGV4dGVuZHMge30+ID0geyBpbmZvOiBJIH07XHJcblxyXG4vKipcclxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxyXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxyXG4gKiBcclxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcclxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXHJcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cclxuICogXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQsIG5ldmVyPik6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCwgQywgSz4ge1xyXG4gICAgLy90eXBlIEkgPSBJMyAmIE1hbmFnZWRDaGlsZEluZm9CYXNlPHN0cmluZyB8IG51bWJlcj47XHJcbiAgICB0eXBlIEluZm8gPSBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+O1xyXG5cclxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSA9IHBhcmVudFBhcmFtZXRlcnM7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTWFuYWdlZENoaWxkcmVuXCIsIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBnZXRIaWdoZXN0SW5kZXggPSB1c2VDYWxsYmFjaygoKTogbnVtYmVyID0+IHtcclxuICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXg7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gQWxsIHRoZSBpbmZvcm1hdGlvbiB3ZSBoYXZlIGFib3V0IG91ciBjaGlsZHJlbiBpcyBzdG9yZWQgaW4gdGhpcyAqKnN0YWJsZSoqIGFycmF5LlxyXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cclxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbkFycmF5ID0gdXNlUmVmPHsgYXJyOiBBcnJheTxJbmZvPjsgcmVjOiBQYXJ0aWFsPFJlY29yZDxULCBJbmZvPj47IGhpZ2hlc3RJbmRleDogbnVtYmVyLCBsb3dlc3RJbmRleDogbnVtYmVyIH0+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcclxuXHJcbiAgICAvLyBGb3IgaW5kaXJlY3QgYWNjZXNzIHRvIGVhY2ggY2hpbGRcclxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xyXG4gICAgLy8gVE9ETzogVGhlIHByaW1hcnkgdXNlIGZvciB0aGlzIGlzIGZsYWdnYWJsZSBjbG9zZXN0IGZpdHNcclxuICAgIC8vIHdoaWNoIG5lZWQgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cclxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyBiZXR0ZXIgZm9yIHRoYXQuXHJcbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiB2b2lkKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikgeyBmKGNoaWxkKTsgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcclxuICAgICAgICAgICAgY29uc3QgY2hpbGQ6IEluZm8gfCB1bmRlZmluZWQgPSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tmaWVsZCBhcyBrZXlvZiBSZWNvcmQ8VCwgSW5mbz5dO1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpXHJcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXHJcbiAgICAvLyBgdW5kZWZpbmVkYCBpZiBub3QgY2hpbGQgdGhlcmUsIG9yIGl0J3MgdW5tb3VudGVkLlxyXG4gICAgY29uc3QgZ2V0TWFuYWdlZENoaWxkSW5mbyA9IHVzZUNhbGxiYWNrPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPltcImdldEF0XCJdPigoaW5kZXg6IFQpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdITtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBUXSE7XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICAvLyB0bDtkciB0aGlzIGlzIGEgd2F5IHRvIGhhdmUgcnVuIHVzZUxheW91dEVmZmVjdCBvbmNlIGFmdGVyIGFsbCBOIGNoaWxkcmVuXHJcbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xyXG4gICAgLy8gb3Vyc2VsdmVzIGJlY2F1c2Ugb2YgaGF2aW5nIGEgYGNoaWxkQ291bnRgIHN0YXRlIG9yIGFueXRoaW5nIHNpbWlsYXIuXHJcbiAgICAvL1xyXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcclxuICAgIC8vIHRvIG1heWJlIGRvIHNvbWV0aGluZyB3aXRoIGFsbCB0aGVzZSBjaGlsZHJlbiB0aGF0IGp1c3QgbW91bnRlZC5cclxuICAgIC8vIFRoZSBlYXNpZXN0IHdheSB3b3VsZCBiZSB1c2VFZmZlY3QoLi4uLCBbY2hpbGRDb3VudF0pIGJ1dFxyXG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xyXG4gICAgLy8gc2V0Q2hpbGRDb3VudCBhbmQgcmUtcmVuZGVyaW5nIGV2ZXJ5IHRpbWUgY2hpbGRyZW4gbW91bnRcclxuICAgIC8vIChvbmx5IG9uZSByZS1yZW5kZXIgYXQgYSB0aW1lIHVubGVzcyBjaGlsZHJlbiBhcmUgc3RhZ2dlcmVkLCBidXQgc3RpbGwpXHJcbiAgICAvLyBcclxuICAgIC8vIEFzIGFuIGFsdGVybmF0ZSBzb2x1dGlvbiwgYW55IHRpbWUgYSBjaGlsZCB1c2VzIFVMRSBvbiBtb3VudCwgaXQgcXVldWVzIGEgbWljcm90YXNrXHJcbiAgICAvLyB0byBlbXVsYXRlIHJ1bm5pbmcgVUxFIG9uIHRoZSBwYXJlbnQuIE9ubHkgdGhlIGZpcnN0IGNoaWxkIHdpbGwgYWN0dWFsbHkgcXVldWVcclxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XHJcbiAgICAvLyBydW5zIG9uY2UuIFdoZW4gaXQncyBkb25lLCBoYXNSZW1vdGVVTEUgaXMgcmVzZXQgc28gaXQgY2FuIHJ1biBhZ2FpbiBpZlxyXG4gICAgLy8gbW9yZSBjaGlsZHJlbiBtb3VudC91bm1vdW50LlxyXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8VD4sIHVubW91bnRzOiBTZXQ8VD4gfSB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2VycyA9IHVzZVJlZihuZXcgU2V0PFQ+KCkpO1xyXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBUKSA9PiB7XHJcblxyXG4gICAgICAgIGlmIChyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuc2l6ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdD8uKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuYWRkKGluZGV4KTtcclxuXHJcbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcclxuXHJcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XHJcblxyXG4gICAgY29uc3QgcmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlQ2FsbGJhY2soKGluZGV4OiBULCBtb3VudGVkOiBib29sZWFuKTogdm9pZCA9PiB7XHJcbiAgICAgICAgaWYgKCFoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCkge1xyXG4gICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IHtcclxuICAgICAgICAgICAgICAgIG1vdW50czogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICAgICAgdW5tb3VudHM6IG5ldyBTZXQoKSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4oaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLm1vdW50cywgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQhLnVubW91bnRzKVxyXG4gICAgICAgICAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChtb3VudGVkKSB7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4ID0gTWF0aC5tYXgobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXgsIGluZGV4IGFzIG51bWJlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycltpbmRleCBhcyBudW1iZXJdO1xyXG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChzaGF2ZSA8PSBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggJiYgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlXSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgICsrc2hhdmU7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gMSAtIHNoYXZlLCBzaGF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XHJcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZU1hbmFnZWRDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPj4oKHsgbWFuYWdlZENoaWxkOiBpbmZvLCB9KSA9PiB7XHJcbiAgICAgICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxyXG4gICAgICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxyXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxyXG4gICAgICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8uaW5kZXggPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZm8uaW5kZXggYXMgbnVtYmVyXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5mby5pbmRleCBhcyBUXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmZvLmluZGV4IGFzIFQpO1xyXG4gICAgICAgIH0sIFsuLi5PYmplY3QuZW50cmllcyhpbmZvKS5mbGF0KDkpXSk7ICAvLyA5IGlzIGluZmluaXR5LCByaWdodD8gU3VyZS4gVW5yZWxhdGVkOiBUT0RPLlxyXG5cclxuICAgICAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcclxuICAgICAgICAvLyAoZXZlcnkgY2hpbGQgZG9lcyB0aGlzLCBzbyBldmVyeXRoaW5nJ3MgY29vcmRpbmF0ZWQgdG8gb25seSBxdWV1ZSBhIHNpbmdsZSBtaWNyb3Rhc2sgcGVyIHRpY2spXHJcbiAgICAgICAgLy8gRG8gdGhlIHNhbWUgb24gdW5tb3VudC5cclxuICAgICAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXHJcbiAgICAgICAgLy8gc28gdGhhdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgaGFzIGFjY2VzcyB0byBhbGwgdGhlIGluZm8gb24gbW91bnQuXHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5mby5pbmRleCBhcyBULCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHJlbW90ZVVMRUNoaWxkTW91bnRlZD8uKGluZm8uaW5kZXggYXMgVCwgZmFsc2UpO1xyXG4gICAgICAgIH0sIFtpbmZvLmluZGV4XSk7XHJcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IG1hbmFnZWRDaGlsZHJlbiA9IHVzZVJlZjxNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz4+KHtcclxuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcclxuICAgICAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGQsXHJcbiAgICAgICAgZ2V0QXQ6IGdldE1hbmFnZWRDaGlsZEluZm8sXHJcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXHJcbiAgICAgICAgYXJyYXlTbGljZTogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc2xpY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZU1hbmFnZWRDaGlsZCxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW46IG1hbmFnZWRDaGlsZHJlbi5jdXJyZW50IH1cclxuICAgIH1cclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cclxuICAgICAqIFxyXG4gICAgICogQWZ0ZXIgbW91bnQsIGNoYW5nZSB0aGUgY3VycmVudCBhY3RpdmUgY2hpbGQgd2l0aCBgY2hhbmdlSW5kZXhgLlxyXG4gICAgICovXHJcbiAgICBpbml0aWFsSW5kZXg6IG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIHByb3ZpZGVkLCBpZiB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXggZG9lc24ndCBtYXAgb250byBhbnlcclxuICAgICAqIHByb3ZpZGVkIGNoaWxkIChlaXRoZXIgYmVjYXVzZSBpdCdzIHRvbyBsYXJnZSBvciB0aGF0IGNoaWxkXHJcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XHJcbiAgICAgKiB3aWxsIGhhdmUgaXRzIGZsYWcgc2V0IGluc3RlYWQuXHJcbiAgICAgKiBcclxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XHJcbiAgICAgKiB3aGlsZSB0aGUgcGFyZW50IHRoaW5rcyBpdCBzaG91bGRuJ3QgYmUgY291bGQgY2F1c2UgaXNzdWVzLlxyXG4gICAgICovXHJcbiAgICAvL2Nsb3Nlc3RGaXQ/OiBib29sZWFuO1xyXG4gICAgY2xvc2VzdEZpdDogYm9vbGVhbjtcclxuXHJcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXHJcbiAgICAgKiBcclxuICAgICAqIE5vdGFibHksIHRoZSB2YWx1ZSBjYW4gYmUgZGlmZmVyZW50IHRoYW4gd2hhdCB3YXMgY2FsbGVkIHdpdGggY2hhbmdlSW5kZXgoKVxyXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cclxuICAgICAqL1xyXG4gICAgb25JbmRleENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPG51bWJlciB8IG51bGw+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBjaGlsZHJlbiBoYXZlIG11bHRpcGxlIGZsYWdzLCB0aGUgYGtleWAgcGFyYW1ldGVyIGNvbnRyb2xzIHdoaWNoIGZsYWcgd2UncmUgY2hlY2tpbmcuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgY2FuIGJlIGFueXRoaW5nIHlvdSB3YW50LCBidXQgbXVzdCBub3QgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBrZXk6IEs7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoaWxkRmxhZ09wZXJhdGlvbnMge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTXVzdCByZXR1cm4gd2hldGhlciB0aGUgY3VycmVudCBjaGlsZCBpcyBhY3RpdmVcclxuICAgICAqL1xyXG4gICAgZ2V0OiAoKSA9PiBib29sZWFuO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY2hpbGQgbXVzdCBzZXQgaXRzZWxmIGFzIGFjdGl2ZS9pbmFjdGl2ZSwgd2hhdGV2ZXIgdGhhdCBlbnRhaWxzLlxyXG4gICAgICogVGhpcyBjb3VsZCBiZSBhcyBzaW1wbGUgYXMgYSBzZXRTdGF0ZSBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgc2V0OiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IHJldHVybiB0cnVlIGlmIHRoaXMgY2hpbGQgaXMgYSB2YWxpZCBjYW5kaWRhdGUgdG8gYmUgZmxhZ2dlZCwgYW5kIGZhbHNlIGlmIG5vdC5cclxuICAgICAqIE1vc3QgY2hpbGRyZW4gc2hvdWxkIHJldHVybiB0cnVlLiBSZXR1cm5pbmcgZmFsc2UgaXMgb25seSB1c2VmdWwgdG8gbWFyayBhIGNoaWxkIGFzIFwiaW52YWxpZFwiIGluIHNvbWUgd2F5LlxyXG4gICAgICogUmVtb3ZpbmcgYSBjaGlsZCBmcm9tIHRoZSBsaXN0IGRvZXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcsIGJ1dCB0aGlzIGxldHMgeW91IGtlZXAgdGhlIGNoaWxkIGFyb3VuZC5cclxuICAgICAqL1xyXG4gICAgaXNWYWxpZCgpOiBib29sZWFuO1xyXG59XHJcblxyXG5cclxuLy9leHBvcnQgaW50ZXJmYWNlIEZsYWdnYWJsZUNoaWxkSW5mb0I8SyBleHRlbmRzIHN0cmluZz4geyBmbGFnczogUGFydGlhbDxSZWNvcmQ8SywgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+IH0gXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdSZXR1cm5UeXBlIHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBjaGFuZ2VJbmRleDogKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiBudW1iZXIgfCBudWxsO1xyXG4gICAgLyoqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICogXHJcbiAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIG9yIHdoZW5ldmVyIGNhbGxpbmcgYSBjaGlsZCdzIGlzVmFsaWQoKSB3b3VsZCBjaGFuZ2VcclxuICAgICAqICAqL1xyXG4gICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQ6ICgpID0+IHZvaWQ7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xyXG59XHJcblxyXG4vKipcclxuICogQW4gZXh0ZW5zaW9uIHRvIHVzZU1hbmFnZWRDaGlsZHJlbiB0aGF0IGhhbmRsZXMgdGhlIGZvbGxvd2luZyBjb21tb24gY2FzZTpcclxuICogMS4gWW91IGhhdmUgYSBidW5jaCBvZiBjaGlsZHJlblxyXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXHJcbiAqIDMuIFRoZSBwYXJlbnQgaGFzIGNvbnRyb2wgb3ZlciB3aG8gaXMgXCJzZWxlY3RlZFwiIHZpYSBhIG51bWVyaWNhbCBpbmRleC5cclxuICogXHJcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cclxuICogXHJcbiAqIE5vdGUgdGhhdCBiZWNhdXNlIHlvdSBtYXkgd2FudCB0byB1c2UgbXVsdGlwbGUgZmxhZ3Mgd2l0aCB0aGUgc2FtZSBjaGlsZHJlbiwgdGhpcyBob29rICpkb2VzIG5vdCogdXNlIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIVxyXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxyXG4gKiBcclxuICogQWxzbyBiZWNhdXNlIG9mIHRoYXQsIHRoZSB0eXBlcyBvZiB0aGlzIGZ1bmN0aW9uIGFyZSByYXRoZXIgb2RkLiAgSXQncyBiZXR0ZXIgdG8gc3RhcnQgb2ZmIHVzaW5nIGEgaG9vayB0aGF0IGFscmVhZHkgdXNlcyBhIGZsYWcsIHN1Y2ggYXMgYHVzZVJvdmluZ1RhYkluZGV4YCwgYXMgYW4gZXhhbXBsZS5cclxuICogXHJcbiAqIFxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkZsYWc8QywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbiwgaW5pdGlhbEluZGV4LCBjbG9zZXN0Rml0LCBvbkluZGV4Q2hhbmdlLCBrZXkgfTogVXNlQ2hpbGRyZW5GbGFnUGFyYW1ldGVyczxDLCBLPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQ2hpbGRyZW5GbGFnXCIsIG9uSW5kZXhDaGFuZ2UsIGtleSk7XHJcblxyXG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihvbkluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XHJcblxyXG4gICAgY29uc3QgW2dldFJlcXVlc3RlZEluZGV4LCBzZXRSZXF1ZXN0ZWRJbmRleF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8IG51bWJlcj4obnVsbCwgdXNlQ2FsbGJhY2soKCkgPT4gKGluaXRpYWxJbmRleCA/PyAobnVsbCkpLCBbXSkpO1xyXG5cclxuICAgIC8vICAgIGNvbnN0IGdldEZpdE51bGxUb1plcm8gPSB1c2VTdGFibGVHZXR0ZXIoZml0TnVsbFRvWmVybyk7XHJcblxyXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gb25DaGlsZHJlbk1vdW50Q2hhbmdlIGFuZCBjaGFuZ2VJbmRleCwgbm90IHB1YmxpYyAoYnV0IGNvdWxkIGJlIEkgZ3Vlc3MpXHJcbiAgICBjb25zdCBnZXRDbG9zZXN0Rml0ID0gdXNlQ2FsbGJhY2soKHJlcXVlc3RlZEluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XHJcblxyXG4gICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3M/LltrZXldPy5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Rpc3RhbmNlID0gTWF0aC5hYnMoY2hpbGQuaW5kZXggLSByZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV3RGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UgfHwgKG5ld0Rpc3RhbmNlID09IGNsb3Nlc3REaXN0YW5jZSAmJiBjaGlsZC5pbmRleCA8IHJlcXVlc3RlZEluZGV4KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RJbmRleCA9IGNoaWxkLmluZGV4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XHJcblxyXG4gICAgLy8gQW55IHRpbWUgYSBjaGlsZCBtb3VudHMvdW5tb3VudHMsIHdlIG5lZWQgdG8gZG91YmxlLWNoZWNrIHRvIHNlZSBpZiB0aGF0IGFmZmVjdHMgXHJcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcclxuICAgIC8vIDEuIFRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgY2hpbGQgdW5tb3VudGVkXHJcbiAgICAvLyAyLiBBIGNoaWxkIG1vdW50ZWQsIGFuZCBpdCBtb3VudHMgd2l0aCB0aGUgaW5kZXggd2UncmUgbG9va2luZyBmb3JcclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gZ2V0UmVxdWVzdGVkSW5kZXgoKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSBjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpO1xyXG5cclxuICAgICAgICBpZiAocmVxdWVzdGVkSW5kZXggIT0gbnVsbCAmJiBjbG9zZXN0Rml0ICYmIChyZXF1ZXN0ZWRJbmRleCAhPSBjdXJyZW50SW5kZXggfHwgY3VycmVudENoaWxkID09IG51bGwgfHwgIWN1cnJlbnRDaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkpIHtcclxuICAgICAgICAgICAgY3VycmVudENoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcclxuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0Q2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNsb3Nlc3RGaXRDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xyXG4gICAgICAgICAgICAgICAgY2xvc2VzdEZpdENoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2soKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyhnZXRSZXF1ZXN0ZWRJbmRleCgpKSA6IGFyZztcclxuICAgICAgICAvL2lmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsICYmIGdldEZpdE51bGxUb1plcm8oKSlcclxuICAgICAgICAvLyAgICByZXF1ZXN0ZWRJbmRleCA9IDA7XHJcblxyXG4gICAgICAgIHNldFJlcXVlc3RlZEluZGV4KHJlcXVlc3RlZEluZGV4KTtcclxuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcclxuICAgICAgICBpZiAoY3VycmVudEluZGV4ID09IHJlcXVlc3RlZEluZGV4KVxyXG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdGVkSW5kZXg7XHJcblxyXG4gICAgICAgIGxldCBuZXdNYXRjaGluZ0NoaWxkID0gKHJlcXVlc3RlZEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQocmVxdWVzdGVkSW5kZXgpKTtcclxuICAgICAgICBjb25zdCBvbGRNYXRjaGluZ0NoaWxkID0gKGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCkpO1xyXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIEVhc3kgY2FzZVxyXG4gICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgobnVsbCk7XHJcbiAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAobmV3TWF0Y2hpbmdDaGlsZCAmJiBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuaXNWYWxpZCgpKSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgocmVxdWVzdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLnNldCh0cnVlKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRJbmRleCA9IGdldENsb3Nlc3RGaXQocmVxdWVzdGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoaW5pdGlhbEluZGV4ICE9IG51bGwpXHJcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGluaXRpYWxJbmRleCk/LmZsYWdzPy5ba2V5XT8uc2V0KHRydWUpO1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcclxufVxyXG5cclxuXHJcblxyXG4vKmV4cG9ydCB0eXBlIFNwcmVhZDxBIGV4dGVuZHMge30sIEIgZXh0ZW5kcyB7fT4gPSBPbWl0PEEsIGtleW9mIEI+ICYgQjtcclxuZXhwb3J0IGZ1bmN0aW9uIHNwcmVhZDxBIGV4dGVuZHMge30sIEIgZXh0ZW5kcyB7fT4oYTogQSwgYjogQik6IFNwcmVhZDxBLCBCPiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmEsXHJcbiAgICAgICAgLi4uYlxyXG4gICAgfVxyXG59Ki9cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3QoKSB7XHJcbiAgICB0eXBlIEMgPSB7IGZvbzogXCJiYXJcIiB9O1xyXG4gICAgdHlwZSBLID0gXCJmbGFnMlwiO1xyXG5cclxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIHVzZU1hbmFnZWRDaGlsZCB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG1vdW50ZWQsIHVubW91bnRlZCkgPT4gb25DaGlsZHJlbk1vdW50Q2hhbmdlKG1vdW50ZWQsIHVubW91bnRlZCkpIH0gfSk7XHJcbiAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXg6IDAsIGluZm86IHsgZm9vOiBcImJhclwiIH0sIGZsYWdzOiB7ICB9IH0gfSk7XHJcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCBnZXRDdXJyZW50SW5kZXgsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9ID0gdXNlQ2hpbGRyZW5GbGFnPEMsIEs+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleDogMCwga2V5OiBcImZsYWcyXCIgfSlcclxufSovXHJcbiIsImltcG9ydCBjbHN4IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREb2N1bWVudChlbGVtZW50PzogTm9kZSkgeyByZXR1cm4gKGVsZW1lbnQ/Lm93bmVyRG9jdW1lbnQgPz8gZG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ID8/IGdsb2JhbFRoaXMuZG9jdW1lbnQpOyB9XHJcblxyXG50eXBlIFAgPSBQYXJhbWV0ZXJzPHR5cGVvZiBjbHN4PjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEb2N1bWVudENsYXNzKGNsYXNzTmFtZTogUFswXSwgYWN0aXZlPzogYm9vbGVhbiwgZWxlbWVudD86IEhUTUxFbGVtZW50KSB7XHJcbiAgICBlbGVtZW50ID8/PSBnZXREb2N1bWVudCgpLmRvY3VtZW50RWxlbWVudDtcclxuICAgIGNsYXNzTmFtZSA9IGNsc3goY2xhc3NOYW1lKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lIGFzIHN0cmluZyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gZWxlbWVudCEuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUgYXMgc3RyaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBbY2xhc3NOYW1lLCBhY3RpdmUsIGVsZW1lbnRdKTtcclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYWdnYWJsZVJldHVyblR5cGU8RSBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlRHJhZ2dhYmxlUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWRcclxuICAgICAqL1xyXG4gICAgZHJhZ2dpbmc6IGJvb2xlYW47XHJcbiAgICBcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXREcmFnZ2luZzogKCkgPT4gYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9uY2UgdGhlIGRyYWcgZW5kcywgaWYgaXQgd2FzIG92ZXIgYSB2YWxpZCBkcm9wcGFibGUsIHRoaXMgd2lsbCBiZVxyXG4gICAgICogc2V0IHRvIHRoZSBgZHJvcEVmZmVjdGAgdmFsdWUgaXQgaGFkLlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGRldGVjdCB3aGVuIHRoZSBlbGVtZW50IGhhcyBkcm9wcGVkLCBcclxuICAgICAqIGFuZCB0aGVuIHdoYXQgc2hvdWxkIGJlIGRvbmUgd2l0aCBpdCAoZ2VuZXJhbGx5IGRlbGV0ZWQgaWYgdGhlIGVmZmVjdCB3YXMgXCJtb3ZlXCIpXHJcbiAgICAgKi9cclxuICAgIGxhc3REcm9wRWZmZWN0OiBEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbDtcclxuXHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0TGFzdERyb3BFZmZlY3Q6ICgpID0+IChEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbCk7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYWdnYWJsZVBhcmFtZXRlcnMge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB0byB0aGUgRHJhZyBhbmQgRHJvcCBBUEkgLS0gYWxsb3dzIGxpbWl0aW5nIHRoZSBhcmVhcyB0aGlzIGVsZW1lbnQgY2FuIGJlIGRyb3BwZWQuXHJcbiAgICAgKiBGb3IgZXhhbXBsZSwgc2V0dGluZyB0aGlzIHRvIFwiY29weUxpbmtcIiB3aWxsIGFsbG93IHRoaXMgdGhpcyB0byBiZSBkcm9wcGVkIG9udG9cclxuICAgICAqIGEgZHJvcHBhYmxlIHdpdGggYW4gZWZmZWN0IG9mIFwiY29weVwiIG9yIFwibGlua1wiLCBidXQgbm90IFwibW92ZVwiLlxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIGVmZmVjdEFsbG93ZWQ/OiBEYXRhVHJhbnNmZXJbXCJlZmZlY3RBbGxvd2VkXCJdIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIHVzZWQgdG8gc3BlY2lmeSBhIGN1c3RvbSBkcmFnIGltYWdlIGluc3RlYWQgb2YgdGhlIGJyb3dzZXIgZGVmYXVsdCAoYSB0cmFuc3BhcmVudCByZW5kZXIgb2YgdGhlIG9yaWdpbmFsIGVsZW1lbnQsIGdlbmVyYWxseSlcclxuICAgICAqL1xyXG4gICAgZHJhZ0ltYWdlPzogSFRNTENhbnZhc0VsZW1lbnQgfCBIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTFZpZGVvRWxlbWVudDtcclxuICAgIGRyYWdJbWFnZVhPZmZzZXQ/OiBudW1iZXI7XHJcbiAgICBkcmFnSW1hZ2VZT2Zmc2V0PzogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyBhIGRpY3Rpb25hcnkgbWFwcGluZyBvZiBNSU1FIHR5cGVzIHRvIGRhdGFcclxuICAgICAqL1xyXG4gICAgZGF0YTogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJhZ2dhYmxlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBlZmZlY3RBbGxvd2VkLCBkYXRhLCBkcmFnSW1hZ2UsIGRyYWdJbWFnZVhPZmZzZXQsIGRyYWdJbWFnZVlPZmZzZXQgfTogVXNlRHJhZ2dhYmxlUGFyYW1ldGVycykge1xyXG5cclxuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmcsIGdldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtsYXN0RHJvcEVmZmVjdCwgc2V0TGFzdERyb3BFZmZlY3QsIGdldExhc3REcm9wRWZmZWN0XSA9IHVzZVN0YXRlPERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCB1c2VEcmFnZ2FibGVQcm9wcyA9IHVzZUNhbGxiYWNrKDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHA6IFApID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgcmVmID0gdXNlUmVmPEU+KG51bGwpO1xyXG5cclxuICAgICAgICBjb25zdCBvbkRyYWdTdGFydCA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgLy9lLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcclxuICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmVmZmVjdEFsbG93ZWQgPSAoZWZmZWN0QWxsb3dlZCA/PyBcImFsbFwiKTtcclxuICAgICAgICAgICAgICAgIGlmIChkcmFnSW1hZ2UpXHJcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RHJhZ0ltYWdlKGRyYWdJbWFnZSwgZHJhZ0ltYWdlWE9mZnNldCA/PyAwLCBkcmFnSW1hZ2VZT2Zmc2V0ID8/IDApXHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGRhdGEpIGFzIFttaW1lVHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmddW107XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFttaW1lVHlwZSwgZGF0YV0gb2YgZW50cmllcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERhdGEobWltZVR5cGUsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25EcmFnRW5kID0gKGU6IERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHNldERyYWdnaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCAhPSBcIm5vbmVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldExhc3REcm9wRWZmZWN0KGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFzdERyb3BFZmZlY3QobnVsbCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHtcclxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBvbkRyYWdTdGFydCxcclxuICAgICAgICAgICAgb25EcmFnRW5kLFxyXG4gICAgICAgICAgICByZWZcclxuICAgICAgICB9LCBwKTtcclxuXHJcbiAgICB9LCBbZWZmZWN0QWxsb3dlZCwgZHJhZ0ltYWdlLCBkcmFnSW1hZ2VYT2Zmc2V0LCBkcmFnSW1hZ2VZT2Zmc2V0LCAuLi5PYmplY3QuZW50cmllcyhkYXRhKS5mbGF0KCldKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIGNvbnN0IHJldDogVXNlRHJhZ2dhYmxlUmV0dXJuVHlwZTxFPiA9IHtcclxuICAgICAgICB1c2VEcmFnZ2FibGVQcm9wcyxcclxuICAgICAgICBkcmFnZ2luZyxcclxuICAgICAgICBnZXREcmFnZ2luZyxcclxuICAgICAgICBsYXN0RHJvcEVmZmVjdCxcclxuICAgICAgICBnZXRMYXN0RHJvcEVmZmVjdFxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyb3BwYWJsZVJldHVyblR5cGU8RSBleHRlbmRzIEhUTUxFbGVtZW50PiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBIb29rIGZvciBtb2RpZnlpbmcgdGhlIHByb3BzIHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8geW91ciBkcm9wIHRhcmdldCBFbGVtZW50LlxyXG4gICAgICogXHJcbiAgICAgKiAqVW5zdGFibGUqXHJcbiAgICAgKi9cclxuICAgIHVzZURyb3BwYWJsZVByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hpbGUgc29tZXRoaW5nIGlzIGJlaW5nIGRyYWdnZWQgb3ZlciB0aGlzIGVsZW1lbnQsIHRoaXMgd2lsbCBjb250YWluIGFueSBpbmZvcm1hdGlvbiBhYm91dCBhbnkgZmlsZXMgaW5jbHVkZWQgaW4gdGhhdCBkcm9wLlxyXG4gICAgICogT3RoZXJ3aXNlLCBpdCdsbCBiZSBudWxsLCBtZWFuaW5nIG5vdGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgZmlsZXNGb3JDb25zaWRlcmF0aW9uOiBEcm9wRmlsZU1ldGFkYXRhW10gfCBudWxsO1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGlsZSBzb21ldGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudCwgYSBsaXN0IG9mIGF2YWlsYWJsZSBNSU1FIHR5cGVzIGZvciB0aGUgbm9uLWZpbGUgZGF0YSB3aWxsIGJlIGxpc3RlZCBoZXJlLlxyXG4gICAgICogT3RoZXJ3aXNlLCBpdCdsbCBiZSBudWxsLCBtZWFuaW5nIG5vdGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb246IFNldDxzdHJpbmc+IHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gZmlsZXMgYXJlIGRyb3BwZWQgb3ZlciB0aGUgZWxlbWVudCwgdGhlaXIgZGF0YSB3aWxsIGJlIGdpdmVuIGhlcmUuXHJcbiAgICAgKiBUaGlzIHdpbGwgdXBkYXRlIGFzIG5ldyBkcm9wcyBoYXBwZW4uXHJcbiAgICAgKi9cclxuICAgIGRyb3BwZWRGaWxlczogRHJvcEZpbGVbXSB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIG5vbi1maWxlIGRhdGEgaXMgZHJvcHBlZCBvdmVyIHRoZSBlbGVtZW50LCB0aGVpciBkYXRhIHdpbGwgYmUgZ2l2ZW4gaGVyZS5cclxuICAgICAqIFRoaXMgd2lsbCB1cGRhdGUgYXMgbmV3IGRyb3BzIGhhcHBlbi5cclxuICAgICAqL1xyXG4gICAgZHJvcHBlZFN0cmluZ3M6IHsgW01pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSB8IG51bGw7XHJcblxyXG5cclxuICAgIGRyb3BFcnJvcjogdW5rbm93bjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VEcm9wcGFibGVQYXJhbWV0ZXJzIHtcclxuICAgIC8qKlxyXG4gICAgICogTWFwcyB0byB0aGUgRHJhZyBhbmQgRHJvcCBBUEkgLS0gZWZmZWN0aXZlbHkgbWVhbnMgXCJhcyBjbG9zZSBhcyBwb3NzaWJsZSwgd2hhdCdzIGhhcHBlbmluZyB0byB0aGUgZGF0YSB3aGVuIEkgZHJvcCBpdCBoZXJlPyBcclxuICAgICAqIEFtIEkgY29weWluZyBpdCBhbmQgbGVhdmluZyB0aGUgb3JpZ2luYWwsIGFtIEkgbW92aW5nIGl0IGFuZCBkZWxldGluZyB0aGUgb3JpZ2luYWwsIG9yIGFtIEkgbGlua2luZyBpdCB0byB0aGUgb3JpZ2luYWw/XCJcclxuICAgICAqIFxyXG4gICAgICogV2hhdGV2ZXIgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgd2lsbCBoYXZlIGl0cyBvd24gcGVybWlzc2lvbiB0aGF0J3MgY2hlY2tlZCBhZ2FpbnN0IHRoaXMuXHJcbiAgICAgKi9cclxuICAgIGVmZmVjdDogRGF0YVRyYW5zZmVyW1wiZHJvcEVmZmVjdFwiXSB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBEcm9wRmlsZSBleHRlbmRzIERyb3BGaWxlTWV0YWRhdGEgeyBuYW1lOiBzdHJpbmcsIGRhdGE6IEFycmF5QnVmZmVyLCBzaXplOiBudW1iZXIgfCB1bmRlZmluZWQsIGxhc3RNb2RpZmllZDogbnVtYmVyIHwgdW5kZWZpbmVkIH1cclxuZXhwb3J0IGludGVyZmFjZSBEcm9wRmlsZU1ldGFkYXRhIHsgdHlwZTogc3RyaW5nIHwgdW5kZWZpbmVkIH1cclxuXHJcblxyXG50eXBlIERyb3BwYWJsZUZpbGVFcnJvclR5cGUgPSBcIkluZGV4U2l6ZUVycm9yXCIgfCBcIkhpZXJhcmNoeVJlcXVlc3RFcnJvclwiIHwgXCJXcm9uZ0RvY3VtZW50RXJyb3JcIiB8IFwiSW52YWxpZENoYXJhY3RlckVycm9yXCIgfCBcIk5vTW9kaWZpY2F0aW9uQWxsb3dlZEVycm9yXCIgfCBcIk5vdEZvdW5kRXJyb3JcIiB8IFwiTm90U3VwcG9ydGVkRXJyb3JcIiB8IFwiSW52YWxpZFN0YXRlRXJyb3JcIiB8IFwiSW5Vc2VBdHRyaWJ1dGVFcnJvclwiIHwgXCJTeW50YXhFcnJvclwiIHwgXCJJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3JcIiB8IFwiTmFtZXNwYWNlRXJyb3JcIiB8IFwiSW52YWxpZEFjY2Vzc0Vycm9yXCIgfCBcIlR5cGVNaXNtYXRjaEVycm9yXCIgfCBcIlNlY3VyaXR5RXJyb3JcIiB8IFwiTmV0d29ya0Vycm9yXCIgfCBcIkFib3J0RXJyb3JcIiB8IFwiVVJMTWlzbWF0Y2hFcnJvclwiIHwgXCJRdW90YUV4Y2VlZGVkRXJyb3JcIiB8IFwiVGltZW91dEVycm9yXCIgfCBcIkludmFsaWROb2RlVHlwZUVycm9yXCIgfCBcIkRhdGFDbG9uZUVycm9yXCIgfCBcIkVuY29kaW5nRXJyb3JcIiB8IFwiTm90UmVhZGFibGVFcnJvclwiIHwgXCJVbmtub3duRXJyb3JcIiB8IFwiQ29uc3RyYWludEVycm9yXCIgfCBcIkRhdGFFcnJvclwiIHwgXCJUcmFuc2FjdGlvbkluYWN0aXZlRXJyb3JcIiB8IFwiUmVhZE9ubHlFcnJvclwiIHwgXCJWZXJzaW9uRXJyb3JcIiB8IFwiT3BlcmF0aW9uRXJyb3JcIiB8IFwiTm90QWxsb3dlZEVycm9yXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgRHJvcHBhYmxlRmlsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xyXG4gICAgZmlsZU5hbWU6IHN0cmluZztcclxuICAgIGVycm9yVHlwZTogRHJvcHBhYmxlRmlsZUVycm9yVHlwZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihmaWxlTmFtZTogc3RyaW5nLCBiYXNlOiBET01FeGNlcHRpb24gfCBudWxsKSB7XHJcbiAgICAgICAgc3VwZXIoYmFzZT8ubWVzc2FnZSA/PyBcIkFuIHVuc3BlY2lmaWVkIGVycm9yIG9jY3VycmVkIHJlYWRpbmcgdGhlIGZpbGUuXCIpO1xyXG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcclxuICAgICAgICB0aGlzLmVycm9yVHlwZSA9IChiYXNlPy5uYW1lIGFzIERyb3BwYWJsZUZpbGVFcnJvclR5cGUpO1xyXG4gICAgfVxyXG5cclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRHJvcHBhYmxlPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyBlZmZlY3QgfTogVXNlRHJvcHBhYmxlUGFyYW1ldGVycyk6IFVzZURyb3BwYWJsZVJldHVyblR5cGU8RT4ge1xyXG5cclxuICAgIGNvbnN0IFtmaWxlc0ZvckNvbnNpZGVyYXRpb24sIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbl0gPSB1c2VTdGF0ZTxudWxsIHwgRHJvcEZpbGVNZXRhZGF0YVtdPihudWxsKTtcclxuICAgIGNvbnN0IFtzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb25dID0gdXNlU3RhdGU8bnVsbCB8IFNldDxzdHJpbmc+PihudWxsKTtcclxuXHJcbiAgICBjb25zdCBbZHJvcHBlZEZpbGVzLCBzZXREcm9wcGVkRmlsZXNdID0gdXNlU3RhdGU8bnVsbCB8IERyb3BGaWxlW10+KG51bGwpO1xyXG4gICAgY29uc3QgW2Ryb3BwZWRTdHJpbmdzLCBzZXREcm9wcGVkU3RyaW5nc10gPSB1c2VTdGF0ZTxudWxsIHwgeyBbTWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9PihudWxsKTtcclxuXHJcbiAgICBjb25zdCBbZHJvcEVycm9yLCBzZXREcm9wRXJyb3JdID0gdXNlU3RhdGU8dW5rbm93biB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbiAgICAvLyBBbGwgdGhlIHByb21pc2VzIGdlbmVyYXRlZCBmcm9tIHRoZSBkcm9wIGV2ZW50cy5cclxuICAgIC8vIFVzZWQgdG8gcHJvY2VzcyBtdWx0aXBsZSBkcm9wIGV2ZW50cyBpbiBzdWNjZXNzaW9uXHJcbiAgICBjb25zdCBkcm9wUHJvbWlzZXNSZWYgPSB1c2VSZWY8UHJvbWlzZTxudWxsIHwgeyBzdHJpbmdzOiB7IFttaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH0sIGZpbGVzOiBEcm9wRmlsZVtdIH0+W10+KFtdKTtcclxuICAgIGNvbnN0IFtjdXJyZW50UHJvbWlzZUluZGV4LCBzZXRDdXJyZW50UHJvbWlzZUluZGV4LCBnZXRDdXJyZW50UHJvbWlzZUluZGV4XSA9IHVzZVN0YXRlKC0xKTtcclxuICAgIGNvbnN0IFtwcm9taXNlQ291bnQsIHNldFByb21pc2VDb3VudCwgZ2V0UHJvbWlzZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG5cclxuICAgIC8vIEFueSB0aW1lIHdlIGFkZCBhIG5ldyBwcm9taXNlLCBpZiB0aGVyZSdzIG5vIGN1cnJlbnQgcHJvbWlzZSBydW5uaW5nLCB3ZSBuZWVkIHRvIHN0YXJ0IG9uZS5cclxuICAgIC8vIElmIHRoZXJlIGlzIG9uZSwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLCBzaW5jZSBpdCBydW5zIHRoZSBzYW1lIGNoZWNrLlxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBjdXJyZW50UHJvbWlzZUluZGV4ID0gZ2V0Q3VycmVudFByb21pc2VJbmRleCgpO1xyXG4gICAgICAgIGNvbnN0IHByb21pc2VDb3VudCA9IGdldFByb21pc2VDb3VudCgpO1xyXG5cclxuICAgICAgICBpZiAocHJvbWlzZUNvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRQcm9taXNlSW5kZXggKyAxKSA8IHByb21pc2VDb3VudCkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFByb21pc2VJbmRleChpID0+ICsraSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgW3Byb21pc2VDb3VudF0pO1xyXG5cclxuICAgIC8vIEFueXRpbWUgb3VyIGN1cnJlbnQgcHJvbWlzZSBjaGFuZ2VzLFxyXG4gICAgLy8gd2FpdCBmb3IgaXQgdG8gZmluaXNoLCB0aGVuIHNldCBvdXIgc3RhdGUgdG8gaXRzIHJlc3VsdC5cclxuICAgIC8vIEZpbmFsbHksIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55bW9yZSBwcm9taXNlcy5cclxuICAgIC8vIElmIHRoZXJlIGFyZSwgdGhlbiBpbmNyZWFzZSBjdXJyZW50UHJvbWlzZUNvdW50LFxyXG4gICAgLy8gd2hpY2ggd2lsbCB0cmlnZ2VyIHRoaXMgYWdhaW4uXHJcbiAgICAvL1xyXG4gICAgLy8gVGhpcyBzaG91bGRuJ3QgaGFwcGVuICpvZnRlbiosIGJ1dCBtYXliZSBpbiB0aGUgY2FzZSBvZlxyXG4gICAgLy8gaW5kaXZpZHVhbGx5IGRyb3BwaW5nIGEgYnVuY2ggb2YgbGFyZ2UgZmlsZXMgb3Igc29tZXRoaW5nLlxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFByb21pc2VJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlID0gZHJvcFByb21pc2VzUmVmLmN1cnJlbnRbY3VycmVudFByb21pc2VJbmRleF07XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnRoZW4oKGluZm8pID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoaW5mbyAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsZXMsIHN0cmluZ3MgfSA9IGluZm87XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0RHJvcHBlZEZpbGVzKGZpbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXREcm9wcGVkU3RyaW5ncyhzdHJpbmdzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBOb3cgdGhhdCB3ZSdyZSBkb25lLCBhcmUgdGhlcmUgbW9yZSBwcm9taXNlcyBpbiB0aGUgcXVldWU/XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFByb21pc2VJbmRleCA9IGdldEN1cnJlbnRQcm9taXNlSW5kZXgoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VDb3VudCA9IGdldFByb21pc2VDb3VudCgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoY3VycmVudFByb21pc2VJbmRleCArIDEpIDwgcHJvbWlzZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBwcm9taXNlIGhhcyBzdGFydGVkLCBtb3JlIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhpcyBlZmZlY3QgYWdhaW4uXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudFByb21pc2VJbmRleChpID0+ICsraSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRQcm9taXNlSW5kZXhdKVxyXG5cclxuXHJcbiAgICBjb25zdCB1c2VEcm9wcGFibGVQcm9wczogVXNlRHJvcHBhYmxlUmV0dXJuVHlwZTxFPltcInVzZURyb3BwYWJsZVByb3BzXCJdID0gKHApID0+IHtcclxuXHJcbiAgICAgICAgLy9jb25zdCByZWYgPSB1c2VSZWY8RT4obnVsbCk7XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBjb2xsZWN0aW5nIHRoZSBjdXJyZW50IGZpbGUgbWV0YWRhdGEgb3IgTUlNRSB0eXBlcy5cclxuICAgICAgICBjb25zdCBvbkRyYWdFbnRlciA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBJcyB0aGVyZSBhIGRlZmF1bHQ/IEkgY2FuJ3QgZmluZCBvbmUgYW55d2hlcmUuXHJcbiAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gKGVmZmVjdCA/PyBcIm1vdmVcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TWltZVR5cGVzID0gbmV3IFNldDxzdHJpbmc+KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdGaWxlcyA9IG5ldyBBcnJheTxEcm9wRmlsZU1ldGFkYXRhPigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlLmRhdGFUcmFuc2Zlcj8uaXRlbXMgPz8gW10pIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtpbmQsIHR5cGUgfSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01pbWVUeXBlcy5hZGQodHlwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IFwiZmlsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZpbGVzLnB1c2goeyB0eXBlOiBpdGVtLnR5cGUgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obmV3RmlsZXMpO1xyXG4gICAgICAgICAgICAgICAgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb24obmV3TWltZVR5cGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSByZXNldHRpbmcgdGhlIGN1cnJlbnQgZmlsZSBtZXRhZGF0YSBvciBNSU1FIHR5cGVzXHJcbiAgICAgICAgY29uc3Qgb25EcmFnTGVhdmUgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBCb2lsZXJwbGF0ZSwgSSBndWVzc1xyXG4gICAgICAgIGNvbnN0IG9uRHJhZ092ZXIgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEhhbmRsZSBnZXR0aW5nIHRoZSBkcm9wIGRhdGEgYXN5bmNocm9ub3VzbHlcclxuICAgICAgICBjb25zdCBvbkRyb3AgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuXHJcbiAgICAgICAgICAgIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcclxuICAgICAgICAgICAgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBhbGxQcm9taXNlcyA9IG5ldyBBcnJheTxQcm9taXNlPHVua25vd24+PigpO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZHJvcERhdGE6IHsgW21pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCBkcm9wRmlsZTogRHJvcEZpbGVbXSA9IFtdO1xyXG5cclxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGUuZGF0YVRyYW5zZmVyPy5pdGVtcyA/PyBbXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBraW5kLCB0eXBlIH0gPSBpdGVtO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChraW5kID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaCgobmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgX3JlamVjdCkgPT4gaXRlbS5nZXRBc1N0cmluZyhyZXNvbHZlKSkpLnRoZW4oc3RyID0+IGRyb3BEYXRhW3R5cGVdID0gc3RyKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChraW5kID09PSBcImZpbGVcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBpdGVtLmdldEFzRmlsZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFByb21pc2VzLnB1c2goXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoXykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIucmVzdWx0IGFzIEFycmF5QnVmZmVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wRmlsZS5wdXNoKHsgZGF0YSwgbmFtZTogZmlsZS5uYW1lLCB0eXBlOiBmaWxlLnR5cGUsIHNpemU6IGRhdGEuYnl0ZUxlbmd0aCwgbGFzdE1vZGlmaWVkOiBmaWxlLmxhc3RNb2RpZmllZCB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmVycm9yID0gKF8pID0+IHsgcmVqZWN0KG5ldyBEcm9wcGFibGVGaWxlRXJyb3IoZmlsZS5uYW1lLCByZWFkZXIuZXJyb3IpKTsgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25hYm9ydCA9IChfKSA9PiB7IHJlamVjdChuZXcgRHJvcHBhYmxlRmlsZUVycm9yKGZpbGUubmFtZSwgcmVhZGVyLmVycm9yKSk7IH07XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGaWxlLnB1c2goKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBkcm9wUHJvbWlzZXNSZWYuY3VycmVudC5wdXNoKFByb21pc2UuYWxsKGFsbFByb21pc2VzKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFByb21pc2VDb3VudChpID0+ICsraSk7XHJcbiAgICAgICAgICAgICAgICBzZXREcm9wRXJyb3IobnVsbCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3M6IGRyb3BEYXRhLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVzOiBkcm9wRmlsZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5jYXRjaChleCA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgICAgICAgICBzZXRQcm9taXNlQ291bnQoaSA9PiArK2kpO1xyXG4gICAgICAgICAgICAgICAgc2V0RHJvcEVycm9yKGV4KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHsgb25EcmFnRW50ZXIsIG9uRHJhZ0xlYXZlLCBvbkRyYWdPdmVyLCBvbkRyb3AgfSwgcCk7XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlRHJvcHBhYmxlUHJvcHMsXHJcbiAgICAgICAgZmlsZXNGb3JDb25zaWRlcmF0aW9uLFxyXG4gICAgICAgIHN0cmluZ3NGb3JDb25zaWRlcmF0aW9uLFxyXG4gICAgICAgIGRyb3BwZWRGaWxlcyxcclxuICAgICAgICBkcm9wcGVkU3RyaW5ncyxcclxuXHJcbiAgICAgICAgZHJvcEVycm9yXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcblxyXG5pbnRlcmZhY2UgVXNlRWxlbWVudFNpemVQYXJhbWV0ZXJzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBicm93c2VyIGRldGVjdHMgYSBzaXplIGNoYW5nZVxyXG4gICAgICogb24gdGhlIGVsZW1lbnQuIERvZXMgbm90IG5lZWQgdG8gYmUgc3RhYmxlLCBzbyB5b3VcclxuICAgICAqIGNhbiBwYXNzIGFuIGFub255bW91cyBmdW5jdGlvbiB0aGF0IG9ubHkgc2V0cyB0aGVcclxuICAgICAqIHZhbHVlcyB5b3UgdXNlIGlmIHlvdSdkIGxpa2UuXHJcbiAgICAgKiBAcGFyYW0gc2l6ZUluZm8gXHJcbiAgICAgKi9cclxuICAgIG9uU2l6ZUNoYW5nZShzaXplSW5mbzogRWxlbWVudFNpemUpOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjcmVhdGVkIFJlc2l6ZU9ic2VydmVyLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SZXNpemVPYnNlcnZlci9vYnNlcnZlI3BhcmFtZXRlcnNcclxuICAgICAqL1xyXG4gICAgZ2V0T2JzZXJ2ZUJveD8oKTogUmVzaXplT2JzZXJ2ZXJPcHRpb25zW1wiYm94XCJdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVsZW1lbnRTaXplIHtcclxuICAgIGNsaWVudFdpZHRoOiBudW1iZXI7XHJcbiAgICBzY3JvbGxXaWR0aDogbnVtYmVyO1xyXG4gICAgb2Zmc2V0V2lkdGg6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNsaWVudEhlaWdodDogbnVtYmVyO1xyXG4gICAgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XHJcbiAgICBvZmZzZXRIZWlnaHQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNsaWVudExlZnQ6IG51bWJlcjtcclxuICAgIHNjcm9sbExlZnQ6IG51bWJlcjtcclxuICAgIG9mZnNldExlZnQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNsaWVudFRvcDogbnVtYmVyO1xyXG4gICAgc2Nyb2xsVG9wOiBudW1iZXI7XHJcbiAgICBvZmZzZXRUb3A6IG51bWJlciB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VFbGVtZW50U2l6ZVJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldFNpemUoKTogRWxlbWVudFNpemUgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZUVsZW1lbnRTaXplUHJvcHM6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+W1widXNlUmVmRWxlbWVudFByb3BzXCJdO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVsZW1lbnRTaXplPEUgZXh0ZW5kcyBFbGVtZW50Pih7IGdldE9ic2VydmVCb3gsIG9uU2l6ZUNoYW5nZSB9OiBVc2VFbGVtZW50U2l6ZVBhcmFtZXRlcnMpOiBVc2VFbGVtZW50U2l6ZVJldHVyblR5cGU8RT4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUVsZW1lbnRTaXplXCIsIGdldE9ic2VydmVCb3gsIG9uU2l6ZUNoYW5nZSk7XHJcblxyXG4gICAgY29uc3QgW2dldFNpemUsIHNldFNpemVdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnRTaXplIHwgbnVsbD4ob25TaXplQ2hhbmdlIGFzIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnRTaXplIHwgbnVsbD4sIHJldHVybk51bGwpO1xyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRPYnNlcnZlQm94ID0gdXNlUmVmPFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcclxuXHJcbiAgICBjb25zdCBuZWVkQU5ld09ic2VydmVyID0gdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IEUgfCBudWxsLCBvYnNlcnZlQm94OiBSZXNpemVPYnNlcnZlckJveE9wdGlvbnMgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCB3aW5kb3cgPSBkb2N1bWVudC5kZWZhdWx0VmlldztcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlzQ29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjbGllbnRXaWR0aCwgc2Nyb2xsV2lkdGgsIG9mZnNldFdpZHRoLCBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCwgb2Zmc2V0SGVpZ2h0LCBjbGllbnRMZWZ0LCBzY3JvbGxMZWZ0LCBvZmZzZXRMZWZ0LCBjbGllbnRUb3AsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wIH0gPSAoZWxlbWVudCBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldFNpemUoeyBjbGllbnRXaWR0aCwgc2Nyb2xsV2lkdGgsIG9mZnNldFdpZHRoLCBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCwgb2Zmc2V0SGVpZ2h0LCBjbGllbnRMZWZ0LCBzY3JvbGxMZWZ0LCBvZmZzZXRMZWZ0LCBjbGllbnRUb3AsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICAgICAgaWYgKHdpbmRvdyAmJiAoXCJSZXNpemVPYnNlcnZlclwiIGluIHdpbmRvdykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChfZW50cmllcykgPT4geyBoYW5kbGVVcGRhdGUoKTsgfSk7XHJcblxyXG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50LCB7IGJveDogb2JzZXJ2ZUJveCB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBoYW5kbGVVcGRhdGUsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVVwZGF0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxFPih7IG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGU6IEUgfCBudWxsKSA9PiBuZWVkQU5ld09ic2VydmVyKGUsIGdldE9ic2VydmVCb3g/LigpKSwgW10pIH0pO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGdldE9ic2VydmVCb3gpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRPYnNlcnZlQm94LmN1cnJlbnQgIT09IGdldE9ic2VydmVCb3goKSlcclxuICAgICAgICAgICAgICAgIG5lZWRBTmV3T2JzZXJ2ZXIoZ2V0RWxlbWVudCgpLCBnZXRPYnNlcnZlQm94KCkpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0RWxlbWVudCxcclxuICAgICAgICBnZXRTaXplLFxyXG4gICAgICAgIHVzZUVsZW1lbnRTaXplUHJvcHM6IHVzZVJlZkVsZW1lbnRQcm9wc1xyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuIiwiY29uc3QgY2FuZGlkYXRlU2VsZWN0b3JzID0gW1xuICAnaW5wdXQnLFxuICAnc2VsZWN0JyxcbiAgJ3RleHRhcmVhJyxcbiAgJ2FbaHJlZl0nLFxuICAnYnV0dG9uJyxcbiAgJ1t0YWJpbmRleF06bm90KHNsb3QpJyxcbiAgJ2F1ZGlvW2NvbnRyb2xzXScsXG4gICd2aWRlb1tjb250cm9sc10nLFxuICAnW2NvbnRlbnRlZGl0YWJsZV06bm90KFtjb250ZW50ZWRpdGFibGU9XCJmYWxzZVwiXSknLFxuICAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnLFxuICAnZGV0YWlscycsXG5dO1xuY29uc3QgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzLmpvaW4oJywnKTtcblxuY29uc3QgTm9FbGVtZW50ID0gdHlwZW9mIEVsZW1lbnQgPT09ICd1bmRlZmluZWQnO1xuXG5jb25zdCBtYXRjaGVzID0gTm9FbGVtZW50XG4gID8gZnVuY3Rpb24gKCkge31cbiAgOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmNvbnN0IGdldFJvb3ROb2RlID1cbiAgIU5vRWxlbWVudCAmJiBFbGVtZW50LnByb3RvdHlwZS5nZXRSb290Tm9kZVxuICAgID8gKGVsZW1lbnQpID0+IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKVxuICAgIDogKGVsZW1lbnQpID0+IGVsZW1lbnQub3duZXJEb2N1bWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChlbCwgaW5jbHVkZUNvbnRhaW5lciwgZmlsdGVyKSB7XG4gIGxldCBjYW5kaWRhdGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KFxuICAgIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoY2FuZGlkYXRlU2VsZWN0b3IpXG4gICk7XG4gIGlmIChpbmNsdWRlQ29udGFpbmVyICYmIG1hdGNoZXMuY2FsbChlbCwgY2FuZGlkYXRlU2VsZWN0b3IpKSB7XG4gICAgY2FuZGlkYXRlcy51bnNoaWZ0KGVsKTtcbiAgfVxuICBjYW5kaWRhdGVzID0gY2FuZGlkYXRlcy5maWx0ZXIoZmlsdGVyKTtcbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG4vKipcbiAqIEBjYWxsYmFjayBHZXRTaGFkb3dSb290XG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdG8gY2hlY2sgZm9yIHNoYWRvdyByb290XG4gKiBAcmV0dXJucyB7U2hhZG93Um9vdHxib29sZWFufSBTaGFkb3dSb290IGlmIGF2YWlsYWJsZSBvciBib29sZWFuIGluZGljYXRpbmcgaWYgYSBzaGFkb3dSb290IGlzIGF0dGFjaGVkIGJ1dCBub3QgYXZhaWxhYmxlLlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIFNoYWRvd1Jvb3RGaWx0ZXJcbiAqIEBwYXJhbSB7RWxlbWVudH0gc2hhZG93SG9zdE5vZGUgdGhlIGVsZW1lbnQgd2hpY2ggY29udGFpbnMgc2hhZG93IGNvbnRlbnRcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGEgc2hhZG93IHJvb3QgY291bGQgcG90ZW50aWFsbHkgY29udGFpbiB2YWxpZCBjYW5kaWRhdGVzLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gQ2FuZGlkYXRlc1Njb3BlXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHNjb3BlIGNvbnRhaW5zIGlubmVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXG4gKiBAcHJvcGVydHkge0dldFNoYWRvd1Jvb3R8Ym9vbGVhbn0gZ2V0U2hhZG93Um9vdCB0cnVlIGlmIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQ7IGZhbHN5IGlmIG5vdDtcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XG4gKiBAcHJvcGVydHkgeyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlc1Njb3BlIGludG8gdGhlIHJldHVybmVkIGxpc3RcbiAqIEBwcm9wZXJ0eSB7U2hhZG93Um9vdEZpbHRlcn0gc2hhZG93Um9vdEZpbHRlciBmaWx0ZXIgc2hhZG93IHJvb3RzO1xuICovXG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50W119IGVsZW1lbnRzIGxpc3Qgb2YgZWxlbWVudCBjb250YWluZXJzIHRvIG1hdGNoIGNhbmRpZGF0ZXMgZnJvbVxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgbGlzdCB0byBjaGVja1xuICogQHBhcmFtIHtJdGVyYXRpdmVPcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn1cbiAqL1xuY29uc3QgZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5ID0gZnVuY3Rpb24gKFxuICBlbGVtZW50cyxcbiAgaW5jbHVkZUNvbnRhaW5lcixcbiAgb3B0aW9uc1xuKSB7XG4gIGNvbnN0IGNhbmRpZGF0ZXMgPSBbXTtcbiAgY29uc3QgZWxlbWVudHNUb0NoZWNrID0gQXJyYXkuZnJvbShlbGVtZW50cyk7XG4gIHdoaWxlIChlbGVtZW50c1RvQ2hlY2subGVuZ3RoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzVG9DaGVjay5zaGlmdCgpO1xuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIGNvbnN0IGFzc2lnbmVkID0gZWxlbWVudC5hc3NpZ25lZEVsZW1lbnRzKCk7XG4gICAgICBjb25zdCBjb250ZW50ID0gYXNzaWduZWQubGVuZ3RoID8gYXNzaWduZWQgOiBlbGVtZW50LmNoaWxkcmVuO1xuICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY2hlY2sgY2FuZGlkYXRlIGVsZW1lbnRcbiAgICAgIGNvbnN0IHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmIChcbiAgICAgICAgdmFsaWRDYW5kaWRhdGUgJiZcbiAgICAgICAgb3B0aW9ucy5maWx0ZXIoZWxlbWVudCkgJiZcbiAgICAgICAgKGluY2x1ZGVDb250YWluZXIgfHwgIWVsZW1lbnRzLmluY2x1ZGVzKGVsZW1lbnQpKVxuICAgICAgKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICBjb25zdCBzaGFkb3dSb290ID1cbiAgICAgICAgZWxlbWVudC5zaGFkb3dSb290IHx8XG4gICAgICAgIC8vIGNoZWNrIGZvciBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKHR5cGVvZiBvcHRpb25zLmdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgICBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCkpO1xuXG4gICAgICBjb25zdCB2YWxpZFNoYWRvd1Jvb3QgPVxuICAgICAgICAhb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyIHx8IG9wdGlvbnMuc2hhZG93Um9vdEZpbHRlcihlbGVtZW50KTtcblxuICAgICAgaWYgKHNoYWRvd1Jvb3QgJiYgdmFsaWRTaGFkb3dSb290KSB7XG4gICAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNjb3BlIElJRiBhIHNoYWRvdyByb290IG5vZGUgd2FzIGdpdmVuOyBvdGhlcndpc2UsIGFuIHVuZGlzY2xvc2VkXG4gICAgICAgIC8vICBzaGFkb3cgZXhpc3RzLCBzbyBsb29rIGF0IGxpZ2h0IGRvbSBjaGlsZHJlbiBhcyBmYWxsYmFjayBCVVQgY3JlYXRlIGEgc2NvcGUgZm9yIGFueVxuICAgICAgICAvLyAgY2hpbGQgY2FuZGlkYXRlcyBmb3VuZCBiZWNhdXNlIHRoZXkncmUgbGlrZWx5IHNsb3R0ZWQgZWxlbWVudHMgKGVsZW1lbnRzIHRoYXQgYXJlXG4gICAgICAgIC8vICBjaGlsZHJlbiBvZiB0aGUgd2ViIGNvbXBvbmVudCBlbGVtZW50ICh3aGljaCBoYXMgdGhlIHNoYWRvdyksIGluIHRoZSBsaWdodCBkb20sIGJ1dFxuICAgICAgICAvLyAgc2xvdHRlZCBzb21ld2hlcmUgX2luc2lkZV8gdGhlIHVuZGlzY2xvc2VkIHNoYWRvdykgLS0gdGhlIHNjb3BlIGlzIGNyZWF0ZWQgYmVsb3csXG4gICAgICAgIC8vICBfYWZ0ZXJfIHdlIHJldHVybiBmcm9tIHRoaXMgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgY29uc3QgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShcbiAgICAgICAgICBzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICBvcHRpb25zXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQoLi4uZWxlbWVudC5jaGlsZHJlbik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgZ2V0VGFiaW5kZXggPSBmdW5jdGlvbiAobm9kZSwgaXNTY29wZSkge1xuICBpZiAobm9kZS50YWJJbmRleCA8IDApIHtcbiAgICAvLyBpbiBDaHJvbWUsIDxkZXRhaWxzLz4sIDxhdWRpbyBjb250cm9scy8+IGFuZCA8dmlkZW8gY29udHJvbHMvPiBlbGVtZW50cyBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAtMSB3aGVuIHRoZSAndGFiaW5kZXgnIGF0dHJpYnV0ZSBpc24ndCBzcGVjaWZpZWQgaW4gdGhlIERPTSxcbiAgICAvLyB5ZXQgdGhleSBhcmUgc3RpbGwgcGFydCBvZiB0aGUgcmVndWxhciB0YWIgb3JkZXI7IGluIEZGLCB0aGV5IGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIDA7IHNpbmNlIENocm9tZSBzdGlsbCBwdXRzIHRob3NlIGVsZW1lbnRzIGluIHRoZSByZWd1bGFyIHRhYlxuICAgIC8vIG9yZGVyLCBjb25zaWRlciB0aGVpciB0YWIgaW5kZXggdG8gYmUgMC5cbiAgICAvLyBBbHNvIGJyb3dzZXJzIGRvIG5vdCByZXR1cm4gYHRhYkluZGV4YCBjb3JyZWN0bHkgZm9yIGNvbnRlbnRFZGl0YWJsZSBub2RlcztcbiAgICAvLyBzbyBpZiB0aGV5IGRvbid0IGhhdmUgYSB0YWJpbmRleCBhdHRyaWJ1dGUgc3BlY2lmaWNhbGx5IHNldCwgYXNzdW1lIGl0J3MgMC5cbiAgICAvL1xuICAgIC8vIGlzU2NvcGUgaXMgcG9zaXRpdmUgZm9yIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0IGJ5IGRlZmF1bHRcbiAgICAvLyBoYXZlIHRhYkluZGV4IC0xLCBidXQgbmVlZCB0byBiZSBzb3J0ZWQgYnkgZG9jdW1lbnQgb3JkZXIgaW4gb3JkZXIgZm9yIHRoZWlyXG4gICAgLy8gY29udGVudCB0byBiZSBpbnNlcnRlZCBpbiB0aGUgY29ycmVjdCBwb3NpdGlvblxuICAgIGlmIChcbiAgICAgIChpc1Njb3BlIHx8XG4gICAgICAgIC9eKEFVRElPfFZJREVPfERFVEFJTFMpJC8udGVzdChub2RlLnRhZ05hbWUpIHx8XG4gICAgICAgIG5vZGUuaXNDb250ZW50RWRpdGFibGUpICYmXG4gICAgICBpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKVxuICAgICkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xuXG5jb25zdCBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gIHJldHVybiBhLnRhYkluZGV4ID09PSBiLnRhYkluZGV4XG4gICAgPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXJcbiAgICA6IGEudGFiSW5kZXggLSBiLnRhYkluZGV4O1xufTtcblxuY29uc3QgaXNJbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgPT09ICdJTlBVVCc7XG59O1xuXG5jb25zdCBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAnaGlkZGVuJztcbn07XG5cbmNvbnN0IGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgciA9XG4gICAgbm9kZS50YWdOYW1lID09PSAnREVUQUlMUycgJiZcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2VcbiAgICAgIC5hcHBseShub2RlLmNoaWxkcmVuKVxuICAgICAgLnNvbWUoKGNoaWxkKSA9PiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWScpO1xuICByZXR1cm4gcjtcbn07XG5cbmNvbnN0IGdldENoZWNrZWRSYWRpbyA9IGZ1bmN0aW9uIChub2RlcywgZm9ybSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG5vZGVzW2ldLmNoZWNrZWQgJiYgbm9kZXNbaV0uZm9ybSA9PT0gZm9ybSkge1xuICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgaXNUYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKCFub2RlLm5hbWUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCByYWRpb1Njb3BlID0gbm9kZS5mb3JtIHx8IGdldFJvb3ROb2RlKG5vZGUpO1xuICBjb25zdCBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHJhZGlvU2NvcGUucXVlcnlTZWxlY3RvckFsbChcbiAgICAgICdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXSdcbiAgICApO1xuICB9O1xuXG4gIGxldCByYWRpb1NldDtcbiAgaWYgKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mod2luZG93LkNTUy5lc2NhcGUobm9kZS5uYW1lKSk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHJhZGlvU2V0ID0gcXVlcnlSYWRpb3Mobm9kZS5uYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAnTG9va3MgbGlrZSB5b3UgaGF2ZSBhIHJhZGlvIGJ1dHRvbiB3aXRoIGEgbmFtZSBhdHRyaWJ1dGUgY29udGFpbmluZyBpbnZhbGlkIENTUyBzZWxlY3RvciBjaGFyYWN0ZXJzIGFuZCBuZWVkIHRoZSBDU1MuZXNjYXBlIHBvbHlmaWxsOiAlcycsXG4gICAgICAgIGVyci5tZXNzYWdlXG4gICAgICApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNoZWNrZWQgPSBnZXRDaGVja2VkUmFkaW8ocmFkaW9TZXQsIG5vZGUuZm9ybSk7XG4gIHJldHVybiAhY2hlY2tlZCB8fCBjaGVja2VkID09PSBub2RlO1xufTtcblxuY29uc3QgaXNSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ3JhZGlvJztcbn07XG5cbmNvbnN0IGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG5jb25zdCBpc1plcm9BcmVhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcbmNvbnN0IGlzSGlkZGVuID0gZnVuY3Rpb24gKG5vZGUsIHsgZGlzcGxheUNoZWNrLCBnZXRTaGFkb3dSb290IH0pIHtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIGNvbnN0IG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gVGhlIHJvb3Qgbm9kZSBpcyB0aGUgc2hhZG93IHJvb3QgaWYgdGhlIG5vZGUgaXMgaW4gYSBzaGFkb3cgRE9NOyBzb21lIGRvY3VtZW50IG90aGVyd2lzZVxuICAvLyAgKGJ1dCBOT1QgX3RoZV8gZG9jdW1lbnQ7IHNlZSBzZWNvbmQgJ0lmJyBjb21tZW50IGJlbG93IGZvciBtb3JlKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgc2hhZG93IHJvb3QsIGl0J2xsIGhhdmUgYSBob3N0LCB3aGljaCBpcyB0aGUgZWxlbWVudCB0byB3aGljaCB0aGUgc2hhZG93XG4gIC8vICBpcyBhdHRhY2hlZCwgYW5kIHRoZSBvbmUgd2UgbmVlZCB0byBjaGVjayBpZiBpdCdzIGluIHRoZSBkb2N1bWVudCBvciBub3QgKGJlY2F1c2UgdGhlXG4gIC8vICBzaGFkb3csIGFuZCBhbGwgbm9kZXMgaXQgY29udGFpbnMsIGlzIG5ldmVyIGNvbnNpZGVyZWQgaW4gdGhlIGRvY3VtZW50IHNpbmNlIHNoYWRvd3NcbiAgLy8gIGJlaGF2ZSBsaWtlIHNlbGYtY29udGFpbmVkIERPTXM7IGJ1dCBpZiB0aGUgc2hhZG93J3MgSE9TVCwgd2hpY2ggaXMgcGFydCBvZiB0aGUgZG9jdW1lbnQsXG4gIC8vICBpcyBoaWRkZW4sIG9yIGlzIG5vdCBpbiB0aGUgZG9jdW1lbnQgaXRzZWxmIGJ1dCBpcyBkZXRhY2hlZCwgaXQgd2lsbCBhZmZlY3QgdGhlIHNoYWRvdydzXG4gIC8vICB2aXNpYmlsaXR5LCBpbmNsdWRpbmcgYWxsIHRoZSBub2RlcyBpdCBjb250YWlucykuIFRoZSBob3N0IGNvdWxkIGJlIGFueSBub3JtYWwgbm9kZSxcbiAgLy8gIG9yIGEgY3VzdG9tIGVsZW1lbnQgKGkuZS4gd2ViIGNvbXBvbmVudCkuIEVpdGhlciB3YXksIHRoYXQncyB0aGUgb25lIHRoYXQgaXMgY29uc2lkZXJlZFxuICAvLyAgcGFydCBvZiB0aGUgZG9jdW1lbnQsIG5vdCB0aGUgc2hhZG93IHJvb3QsIG5vciBhbnkgb2YgaXRzIGNoaWxkcmVuIChpLmUuIHRoZSBub2RlIGJlaW5nXG4gIC8vICB0ZXN0ZWQpLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgY29uc3Qgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZSkuaG9zdDtcbiAgY29uc3Qgbm9kZUlzQXR0YWNoZWQgPVxuICAgIG5vZGVSb290SG9zdD8ub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8XG4gICAgbm9kZS5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGUpO1xuXG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnKSB7XG4gICAgaWYgKHR5cGVvZiBnZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBmaWd1cmUgb3V0IGlmIHdlIHNob3VsZCBjb25zaWRlciB0aGUgbm9kZSB0byBiZSBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgYW5kIHVzZSB0aGVcbiAgICAgIC8vICAnbm9uLXplcm8tYXJlYScgZmFsbGJhY2tcbiAgICAgIGNvbnN0IG9yaWdpbmFsTm9kZSA9IG5vZGU7XG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICBjb25zdCBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICBjb25zdCByb290Tm9kZSA9IGdldFJvb3ROb2RlKG5vZGUpO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGFyZW50RWxlbWVudCAmJlxuICAgICAgICAgICFwYXJlbnRFbGVtZW50LnNoYWRvd1Jvb3QgJiZcbiAgICAgICAgICBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBvcmlnaW5hbE5vZGU7XG4gICAgfVxuICAgIC8vIGVsc2UsIGBnZXRTaGFkb3dSb290YCBtaWdodCBiZSB0cnVlLCBidXQgYWxsIHRoYXQgZG9lcyBpcyBlbmFibGUgc2hhZG93IERPTSBzdXBwb3J0XG4gICAgLy8gIChpLmUuIGl0IGRvZXMgbm90IGFsc28gcHJlc3VtZSB0aGF0IGFsbCBub2RlcyBtaWdodCBoYXZlIHVuZGlzY2xvc2VkIHNoYWRvd3MpOyBvclxuICAgIC8vICBpdCBtaWdodCBiZSBhIGZhbHN5IHZhbHVlLCB3aGljaCBtZWFucyBzaGFkb3cgRE9NIHN1cHBvcnQgaXMgZGlzYWJsZWRcblxuICAgIC8vIFNpbmNlIHdlIGRpZG4ndCBmaW5kIGl0IHNpdHRpbmcgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IChvciBzaGFkb3dzIGFyZSBkaXNhYmxlZClcbiAgICAvLyAgbm93IHdlIGNhbiBqdXN0IHRlc3QgdG8gc2VlIGlmIGl0IHdvdWxkIG5vcm1hbGx5IGJlIHZpc2libGUgb3Igbm90LCBwcm92aWRlZCBpdCdzXG4gICAgLy8gIGF0dGFjaGVkIHRvIHRoZSBtYWluIGRvY3VtZW50LlxuICAgIC8vIE5PVEU6IFdlIG11c3QgY29uc2lkZXIgY2FzZSB3aGVyZSBub2RlIGlzIGluc2lkZSBhIHNoYWRvdyBET00gYW5kIGdpdmVuIGRpcmVjdGx5IHRvXG4gICAgLy8gIGBpc1RhYmJhYmxlKClgIG9yIGBpc0ZvY3VzYWJsZSgpYCAtLSByZWdhcmRsZXNzIG9mIGBnZXRTaGFkb3dSb290YCBvcHRpb24gc2V0dGluZy5cblxuICAgIGlmIChub2RlSXNBdHRhY2hlZCkge1xuICAgICAgLy8gdGhpcyB3b3JrcyB3aGVyZXZlciB0aGUgbm9kZSBpczogaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgY2xpZW50IHJlY3QsIGl0J3NcbiAgICAgIC8vICBzb21laG93IGRpc3BsYXllZDsgaXQgYWxzbyBjb3ZlcnMgdGhlIENTUyAnZGlzcGxheTogY29udGVudHMnIGNhc2Ugd2hlcmUgdGhlXG4gICAgICAvLyAgbm9kZSBpdHNlbGYgaXMgaGlkZGVuIGluIHBsYWNlIG9mIGl0cyBjb250ZW50czsgYW5kIHRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2hcbiAgICAgIC8vICB1cCB0aGUgaGllcmFyY2h5IGVpdGhlclxuICAgICAgcmV0dXJuICFub2RlLmdldENsaWVudFJlY3RzKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEVsc2UsIHRoZSBub2RlIGlzbid0IGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCwgd2hpY2ggbWVhbnMgdGhlIGBnZXRDbGllbnRSZWN0cygpYFxuICAgIC8vICBBUEkgd2lsbCBfX2Fsd2F5c19fIHJldHVybiB6ZXJvIHJlY3RzICh0aGlzIGNhbiBoYXBwZW4sIGZvciBleGFtcGxlLCBpZiBSZWFjdFxuICAgIC8vICBpcyB1c2VkIHRvIHJlbmRlciBub2RlcyBvbnRvIGEgZGV0YWNoZWQgdHJlZSwgYXMgY29uZmlybWVkIGluIHRoaXMgdGhyZWFkOlxuICAgIC8vICBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzkxMTcjaXNzdWVjb21tZW50LTI4NDIyODg3MClcbiAgICAvL1xuICAgIC8vIEl0IGFsc28gbWVhbnMgdGhhdCBldmVuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpLmRpc3BsYXkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGBcbiAgICAvLyAgYmVjYXVzZSBzdHlsZXMgYXJlIG9ubHkgY29tcHV0ZWQgZm9yIG5vZGVzIHRoYXQgYXJlIGluIHRoZSBkb2N1bWVudC5cbiAgICAvL1xuICAgIC8vIE5PVEU6IFRISVMgSEFTIEJFRU4gVEhFIENBU0UgRk9SIFlFQVJTLiBJdCBpcyBub3QgbmV3LCBub3IgaXMgaXQgY2F1c2VkIGJ5IHRhYmJhYmxlXG4gICAgLy8gIHNvbWVob3cuIFRob3VnaCBpdCB3YXMgbmV2ZXIgc3RhdGVkIG9mZmljaWFsbHksIGFueW9uZSB3aG8gaGFzIGV2ZXIgdXNlZCB0YWJiYWJsZVxuICAgIC8vICBBUElzIG9uIG5vZGVzIGluIGRldGFjaGVkIGNvbnRhaW5lcnMgaGFzIGFjdHVhbGx5IGltcGxpY2l0bHkgdXNlZCB0YWJiYWJsZSBpbiB3aGF0XG4gICAgLy8gIHdhcyBsYXRlciAoYXMgb2YgdjUuMi4wIG9uIEFwciA5LCAyMDIxKSBjYWxsZWQgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgbW9kZSAtLSBlc3NlbnRpYWxseVxuICAgIC8vICBjb25zaWRlcmluZyBfX2V2ZXJ5dGhpbmdfXyB0byBiZSB2aXNpYmxlIGJlY2F1c2Ugb2YgdGhlIGlubmFiaWxpdHkgdG8gZGV0ZXJtaW5lIHN0eWxlcy5cbiAgfSBlbHNlIGlmIChkaXNwbGF5Q2hlY2sgPT09ICdub24temVyby1hcmVhJykge1xuICAgIC8vIE5PVEU6IEV2ZW4gdGhvdWdoIHRoaXMgdGVzdHMgdGhhdCB0aGUgbm9kZSdzIGNsaWVudCByZWN0IGlzIG5vbi16ZXJvIHRvIGRldGVybWluZVxuICAgIC8vICB3aGV0aGVyIGl0J3MgZGlzcGxheWVkLCBhbmQgdGhhdCBhIGRldGFjaGVkIG5vZGUgd2lsbCBfX2Fsd2F5c19fIGhhdmUgYSB6ZXJvLWFyZWFcbiAgICAvLyAgY2xpZW50IHJlY3QsIHdlIGRvbid0IHNwZWNpYWwtY2FzZSBmb3Igd2hldGhlciB0aGUgbm9kZSBpcyBhdHRhY2hlZCBvciBub3QuIEluXG4gICAgLy8gIHRoaXMgbW9kZSwgd2UgZG8gd2FudCB0byBjb25zaWRlciBub2RlcyB0aGF0IGhhdmUgYSB6ZXJvIGFyZWEgdG8gYmUgaGlkZGVuIGF0IGFsbFxuICAgIC8vICB0aW1lcywgYW5kIHRoYXQgaW5jbHVkZXMgYXR0YWNoZWQgb3Igbm90LlxuICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICB9XG5cbiAgLy8gdmlzaWJsZSwgYXMgZmFyIGFzIHdlIGNhbiB0ZWxsLCBvciBwZXIgY3VycmVudCBgZGlzcGxheUNoZWNrYCBtb2RlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIGZvcm0gZmllbGRzIChuZXN0ZWQpIGluc2lkZSBhIGRpc2FibGVkIGZpZWxkc2V0IGFyZSBub3QgZm9jdXNhYmxlL3RhYmJhYmxlXG4vLyAgdW5sZXNzIHRoZXkgYXJlIGluIHRoZSBfZmlyc3RfIDxsZWdlbmQ+IGVsZW1lbnQgb2YgdGhlIHRvcC1tb3N0IGRpc2FibGVkXG4vLyAgZmllbGRzZXRcbmNvbnN0IGlzRGlzYWJsZWRGcm9tRmllbGRzZXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBjaGlsZCA9IHBhcmVudE5vZGUuY2hpbGRyZW4uaXRlbShpKTtcbiAgICAgICAgICAvLyB3aGVuIHRoZSBmaXJzdCA8bGVnZW5kPiAoaW4gZG9jdW1lbnQgb3JkZXIpIGlzIGZvdW5kXG4gICAgICAgICAgaWYgKGNoaWxkLnRhZ05hbWUgPT09ICdMRUdFTkQnKSB7XG4gICAgICAgICAgICAvLyBpZiBpdHMgcGFyZW50IDxmaWVsZHNldD4gaXMgbm90IG5lc3RlZCBpbiBhbm90aGVyIGRpc2FibGVkIDxmaWVsZHNldD4sXG4gICAgICAgICAgICAvLyByZXR1cm4gd2hldGhlciBgbm9kZWAgaXMgYSBkZXNjZW5kYW50IG9mIGl0cyBmaXJzdCA8bGVnZW5kPlxuICAgICAgICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChwYXJlbnROb2RlLCAnZmllbGRzZXRbZGlzYWJsZWRdIConKVxuICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgOiAhY2hpbGQuY29udGFpbnMobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+IGNvbnRhaW5pbmcgYG5vZGVgIGhhcyBubyA8bGVnZW5kPlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgfVxuICB9XG5cbiAgLy8gZWxzZSwgbm9kZSdzIHRhYmJhYmxlL2ZvY3VzYWJsZSBzdGF0ZSBzaG91bGQgbm90IGJlIGFmZmVjdGVkIGJ5IGEgZmllbGRzZXQnc1xuICAvLyAgZW5hYmxlZC9kaXNhYmxlZCBzdGF0ZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIG5vZGUuZGlzYWJsZWQgfHxcbiAgICBpc0hpZGRlbklucHV0KG5vZGUpIHx8XG4gICAgaXNIaWRkZW4obm9kZSwgb3B0aW9ucykgfHxcbiAgICAvLyBGb3IgYSBkZXRhaWxzIGVsZW1lbnQgd2l0aCBhIHN1bW1hcnksIHRoZSBzdW1tYXJ5IGVsZW1lbnQgZ2V0cyB0aGUgZm9jdXNcbiAgICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fFxuICAgIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlID0gZnVuY3Rpb24gKG9wdGlvbnMsIG5vZGUpIHtcbiAgaWYgKFxuICAgIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB8fFxuICAgIGdldFRhYmluZGV4KG5vZGUpIDwgMCB8fFxuICAgICFpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUgPSBmdW5jdGlvbiAoc2hhZG93SG9zdE5vZGUpIHtcbiAgY29uc3QgdGFiSW5kZXggPSBwYXJzZUludChzaGFkb3dIb3N0Tm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKTtcbiAgaWYgKGlzTmFOKHRhYkluZGV4KSB8fCB0YWJJbmRleCA+PSAwKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gSWYgYSBjdXN0b20gZWxlbWVudCBoYXMgYW4gZXhwbGljaXQgbmVnYXRpdmUgdGFiaW5kZXgsXG4gIC8vIGJyb3dzZXJzIHdpbGwgbm90IGFsbG93IHRhYiB0YXJnZXRpbmcgc2FpZCBlbGVtZW50J3MgY2hpbGRyZW4uXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVzU2NvcGU+fSBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyBFbGVtZW50W11cbiAqL1xuY29uc3Qgc29ydEJ5T3JkZXIgPSBmdW5jdGlvbiAoY2FuZGlkYXRlcykge1xuICBjb25zdCByZWd1bGFyVGFiYmFibGVzID0gW107XG4gIGNvbnN0IG9yZGVyZWRUYWJiYWJsZXMgPSBbXTtcbiAgY2FuZGlkYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XG4gICAgY29uc3QgaXNTY29wZSA9ICEhaXRlbS5zY29wZTtcbiAgICBjb25zdCBlbGVtZW50ID0gaXNTY29wZSA/IGl0ZW0uc2NvcGUgOiBpdGVtO1xuICAgIGNvbnN0IGNhbmRpZGF0ZVRhYmluZGV4ID0gZ2V0VGFiaW5kZXgoZWxlbWVudCwgaXNTY29wZSk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICBpc1Njb3BlXG4gICAgICAgID8gcmVndWxhclRhYmJhYmxlcy5wdXNoKC4uLmVsZW1lbnRzKVxuICAgICAgICA6IHJlZ3VsYXJUYWJiYWJsZXMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICBpc1Njb3BlOiBpc1Njb3BlLFxuICAgICAgICBjb250ZW50OiBlbGVtZW50cyxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXNcbiAgICAuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcylcbiAgICAucmVkdWNlKChhY2MsIHNvcnRhYmxlKSA9PiB7XG4gICAgICBzb3J0YWJsZS5pc1Njb3BlXG4gICAgICAgID8gYWNjLnB1c2goLi4uc29ydGFibGUuY29udGVudClcbiAgICAgICAgOiBhY2MucHVzaChzb3J0YWJsZS5jb250ZW50KTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pXG4gICAgLmNvbmNhdChyZWd1bGFyVGFiYmFibGVzKTtcbn07XG5cbmNvbnN0IHRhYmJhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICAgIHNoYWRvd1Jvb3RGaWx0ZXI6IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcyk7XG59O1xuXG5jb25zdCBmb2N1c2FibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgY2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi8gY2FuZGlkYXRlU2VsZWN0b3JzXG4gIC5jb25jYXQoJ2lmcmFtZScpXG4gIC5qb2luKCcsJyk7XG5cbmNvbnN0IGlzRm9jdXNhYmxlID0gZnVuY3Rpb24gKG5vZGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICghbm9kZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm8gbm9kZSBwcm92aWRlZCcpO1xuICB9XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmV4cG9ydCB7IHRhYmJhYmxlLCBmb2N1c2FibGUsIGlzVGFiYmFibGUsIGlzRm9jdXNhYmxlIH07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoJ2luZXJ0JywgZmFjdG9yeSkgOlxuICAoZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbiAgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuICAvKipcbiAgICogVGhpcyB3b3JrIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBXM0MgU29mdHdhcmUgYW5kIERvY3VtZW50IExpY2Vuc2VcbiAgICogKGh0dHA6Ly93d3cudzMub3JnL0NvbnNvcnRpdW0vTGVnYWwvMjAxNS9jb3B5cmlnaHQtc29mdHdhcmUtYW5kLWRvY3VtZW50KS5cbiAgICovXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZXR1cm4gZWFybHkgaWYgd2UncmUgbm90IHJ1bm5pbmcgaW5zaWRlIG9mIHRoZSBicm93c2VyLlxuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGZ1bmN0aW9uIGZvciBjb252ZXJ0aW5nIE5vZGVMaXN0cy5cbiAgICAvKiogQHR5cGUge3R5cGVvZiBBcnJheS5wcm90b3R5cGUuc2xpY2V9ICovXG4gICAgdmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXG4gICAgLyoqXG4gICAgICogSUUgaGFzIGEgbm9uLXN0YW5kYXJkIG5hbWUgZm9yIFwibWF0Y2hlc1wiLlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlc31cbiAgICAgKi9cbiAgICB2YXIgbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHwgRWxlbWVudC5wcm90b3R5cGUubXNNYXRjaGVzU2VsZWN0b3I7XG5cbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB2YXIgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nID0gWydhW2hyZWZdJywgJ2FyZWFbaHJlZl0nLCAnaW5wdXQ6bm90KFtkaXNhYmxlZF0pJywgJ3NlbGVjdDpub3QoW2Rpc2FibGVkXSknLCAndGV4dGFyZWE6bm90KFtkaXNhYmxlZF0pJywgJ2J1dHRvbjpub3QoW2Rpc2FibGVkXSknLCAnZGV0YWlscycsICdzdW1tYXJ5JywgJ2lmcmFtZScsICdvYmplY3QnLCAnZW1iZWQnLCAnW2NvbnRlbnRlZGl0YWJsZV0nXS5qb2luKCcsJyk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnRSb290YCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IHN1YnRyZWUsIGkuZS4gYSBET00gc3VidHJlZSB3aG9zZSByb290IGVsZW1lbnQgaGFzIGFuIGBpbmVydGBcbiAgICAgKiBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBJdHMgbWFpbiBmdW5jdGlvbnMgYXJlOlxuICAgICAqXG4gICAgICogLSB0byBjcmVhdGUgYW5kIG1haW50YWluIGEgc2V0IG9mIG1hbmFnZWQgYEluZXJ0Tm9kZWBzLCBpbmNsdWRpbmcgd2hlbiBtdXRhdGlvbnMgb2NjdXIgaW4gdGhlXG4gICAgICogICBzdWJ0cmVlLiBUaGUgYG1ha2VTdWJ0cmVlVW5mb2N1c2FibGUoKWAgbWV0aG9kIGhhbmRsZXMgY29sbGVjdGluZyBgSW5lcnROb2RlYHMgdmlhIHJlZ2lzdGVyaW5nXG4gICAgICogICBlYWNoIGZvY3VzYWJsZSBub2RlIGluIHRoZSBzdWJ0cmVlIHdpdGggdGhlIHNpbmdsZXRvbiBgSW5lcnRNYW5hZ2VyYCB3aGljaCBtYW5hZ2VzIGFsbCBrbm93blxuICAgICAqICAgZm9jdXNhYmxlIG5vZGVzIHdpdGhpbiBpbmVydCBzdWJ0cmVlcy4gYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgXG4gICAgICogICBpbnN0YW5jZSBleGlzdHMgZm9yIGVhY2ggZm9jdXNhYmxlIG5vZGUgd2hpY2ggaGFzIGF0IGxlYXN0IG9uZSBpbmVydCByb290IGFzIGFuIGFuY2VzdG9yLlxuICAgICAqXG4gICAgICogLSB0byBub3RpZnkgYWxsIG1hbmFnZWQgYEluZXJ0Tm9kZWBzIHdoZW4gdGhpcyBzdWJ0cmVlIHN0b3BzIGJlaW5nIGluZXJ0IChpLmUuIHdoZW4gdGhlIGBpbmVydGBcbiAgICAgKiAgIGF0dHJpYnV0ZSBpcyByZW1vdmVkIGZyb20gdGhlIHJvb3Qgbm9kZSkuIFRoaXMgaXMgaGFuZGxlZCBpbiB0aGUgZGVzdHJ1Y3Rvciwgd2hpY2ggY2FsbHMgdGhlXG4gICAgICogICBgZGVyZWdpc3RlcmAgbWV0aG9kIG9uIGBJbmVydE1hbmFnZXJgIGZvciBlYWNoIG1hbmFnZWQgaW5lcnQgbm9kZS5cbiAgICAgKi9cblxuICAgIHZhciBJbmVydFJvb3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290RWxlbWVudCBUaGUgSFRNTEVsZW1lbnQgYXQgdGhlIHJvb3Qgb2YgdGhlIGluZXJ0IHN1YnRyZWUuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydE1hbmFnZXJ9IGluZXJ0TWFuYWdlciBUaGUgZ2xvYmFsIHNpbmdsZXRvbiBJbmVydE1hbmFnZXIgb2JqZWN0LlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydFJvb3Qocm9vdEVsZW1lbnQsIGluZXJ0TWFuYWdlcikge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRSb290KTtcblxuICAgICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IGluZXJ0TWFuYWdlcjtcblxuICAgICAgICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSByb290RWxlbWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Tm9kZT59XG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIGZvY3VzYWJsZSBub2RlcyBpbiB0aGlzIEluZXJ0Um9vdCdzIHN1YnRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgU2V0KCk7XG5cbiAgICAgICAgLy8gTWFrZSB0aGUgc3VidHJlZSBoaWRkZW4gZnJvbSBhc3Npc3RpdmUgdGVjaG5vbG9neVxuICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IHRoaXMuX3Jvb3RFbGVtZW50LmdldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuXG4gICAgICAgIC8vIE1ha2UgYWxsIGZvY3VzYWJsZSBlbGVtZW50cyBpbiB0aGUgc3VidHJlZSB1bmZvY3VzYWJsZSBhbmQgYWRkIHRoZW0gdG8gX21hbmFnZWROb2Rlc1xuICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHRoaXMuX3Jvb3RFbGVtZW50KTtcblxuICAgICAgICAvLyBXYXRjaCBmb3I6XG4gICAgICAgIC8vIC0gYW55IGFkZGl0aW9ucyBpbiB0aGUgc3VidHJlZTogbWFrZSB0aGVtIHVuZm9jdXNhYmxlIHRvb1xuICAgICAgICAvLyAtIGFueSByZW1vdmFscyBmcm9tIHRoZSBzdWJ0cmVlOiByZW1vdmUgdGhlbSBmcm9tIHRoaXMgaW5lcnQgcm9vdCdzIG1hbmFnZWQgbm9kZXNcbiAgICAgICAgLy8gLSBhdHRyaWJ1dGUgY2hhbmdlczogaWYgYHRhYmluZGV4YCBpcyBhZGRlZCwgb3IgcmVtb3ZlZCBmcm9tIGFuIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlXG4gICAgICAgIC8vICAgZWxlbWVudCwgbWFrZSB0aGF0IG5vZGUgYSBtYW5hZ2VkIG5vZGUuXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fb25NdXRhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9yb290RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gIFRoaXMgdW53aW5kcyBhbGwgb2YgdGhlIHN0YXRlXG4gICAgICAgKiBzdG9yZWQgaW4gdGhpcyBvYmplY3QgYW5kIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIGFsbCBvZiB0aGUgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydFJvb3QsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fcm9vdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRoaXMuX3NhdmVkQXJpYUhpZGRlbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VOb2RlKGluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIE5vdGUgd2UgY2FzdCB0aGUgbnVsbHMgdG8gdGhlIEFOWSB0eXBlIGhlcmUgYmVjYXVzZTpcbiAgICAgICAgICAvLyAxKSBXZSB3YW50IHRoZSBjbGFzcyBwcm9wZXJ0aWVzIHRvIGJlIGRlY2xhcmVkIGFzIG5vbi1udWxsLCBvciBlbHNlIHdlXG4gICAgICAgICAgLy8gICAgbmVlZCBldmVuIG1vcmUgY2FzdHMgdGhyb3VnaG91dCB0aGlzIGNvZGUuIEFsbCBiZXRzIGFyZSBvZmYgaWYgYW5cbiAgICAgICAgICAvLyAgICBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQgYW5kIGEgbWV0aG9kIGlzIGNhbGxlZC5cbiAgICAgICAgICAvLyAyKSBXZSBkb24ndCB3YW50IHRvIGNhc3QgXCJ0aGlzXCIsIGJlY2F1c2Ugd2Ugd2FudCB0eXBlLWF3YXJlIG9wdGltaXphdGlvbnNcbiAgICAgICAgICAvLyAgICB0byBrbm93IHdoaWNoIHByb3BlcnRpZXMgd2UncmUgc2V0dGluZy5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybiB7IVNldDwhSW5lcnROb2RlPn0gQSBjb3B5IG9mIHRoaXMgSW5lcnRSb290J3MgbWFuYWdlZCBub2RlcyBzZXQuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYWtlU3VidHJlZVVuZm9jdXNhYmxlJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fdmlzaXROb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHN0YXJ0Tm9kZSkpIHtcbiAgICAgICAgICAgIC8vIHN0YXJ0Tm9kZSBtYXkgYmUgaW4gc2hhZG93IERPTSwgc28gZmluZCBpdHMgbmVhcmVzdCBzaGFkb3dSb290IHRvIGdldCB0aGUgYWN0aXZlRWxlbWVudC5cbiAgICAgICAgICAgIHZhciBub2RlID0gc3RhcnROb2RlO1xuICAgICAgICAgICAgLyoqIEB0eXBlIHshU2hhZG93Um9vdHx1bmRlZmluZWR9ICovXG4gICAgICAgICAgICB2YXIgcm9vdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICByb290ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi9ub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gcm9vdC5hY3RpdmVFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhcnROb2RlLmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50LmJsdXIoKTtcbiAgICAgICAgICAgIC8vIEluIElFMTEsIGlmIGFuIGVsZW1lbnQgaXMgYWxyZWFkeSBmb2N1c2VkLCBhbmQgdGhlbiBzZXQgdG8gdGFiaW5kZXg9LTFcbiAgICAgICAgICAgIC8vIGNhbGxpbmcgYmx1cigpIHdpbGwgbm90IGFjdHVhbGx5IG1vdmUgdGhlIGZvY3VzLlxuICAgICAgICAgICAgLy8gVG8gd29yayBhcm91bmQgdGhpcyB3ZSBjYWxsIGZvY3VzKCkgb24gdGhlIGJvZHkgaW5zdGVhZC5cbiAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdmlzaXROb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSkge1xuICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG5cbiAgICAgICAgICAvLyBJZiBhIGRlc2NlbmRhbnQgaW5lcnQgcm9vdCBiZWNvbWVzIHVuLWluZXJ0LCBpdHMgZGVzY2VuZGFudHMgd2lsbCBzdGlsbCBiZSBpbmVydCBiZWNhdXNlIG9mXG4gICAgICAgICAgLy8gdGhpcyBpbmVydCByb290LCBzbyBhbGwgb2YgaXRzIG1hbmFnZWQgbm9kZXMgbmVlZCB0byBiZSBhZG9wdGVkIGJ5IHRoaXMgSW5lcnRSb290LlxuICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QoZWxlbWVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpIHx8IGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5yZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuYWRkKGluZXJ0Tm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZ2l2ZW4gbm9kZSB3aXRoIHRoaXMgSW5lcnRSb290IGFuZCB3aXRoIEluZXJ0TWFuYWdlci5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIuZGVyZWdpc3Rlcihub2RlLCB0aGlzKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKGluZXJ0Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGVudGlyZSBzdWJ0cmVlIHN0YXJ0aW5nIGF0IGBzdGFydE5vZGVgLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlU3VidHJlZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VTdWJ0cmVlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMzLl91bm1hbmFnZU5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBkZXNjZW5kYW50IG5vZGUgaXMgZm91bmQgd2l0aCBhbiBgaW5lcnRgIGF0dHJpYnV0ZSwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19hZG9wdEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRvcHRJbmVydFJvb3Qobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuXG4gICAgICAgICAgLy8gRHVyaW5nIGluaXRpYWxpc2F0aW9uIHRoaXMgaW5lcnQgcm9vdCBtYXkgbm90IGhhdmUgYmVlbiByZWdpc3RlcmVkIHlldCxcbiAgICAgICAgICAvLyBzbyByZWdpc3RlciBpdCBub3cgaWYgbmVlZCBiZS5cbiAgICAgICAgICBpZiAoIWluZXJ0U3Vicm9vdCkge1xuICAgICAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyLnNldEluZXJ0KG5vZGUsIHRydWUpO1xuICAgICAgICAgICAgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydFN1YnJvb3QubWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKHNhdmVkSW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHNhdmVkSW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIHN1YnRyZWUgYWRkaXRpb25zLCByZW1vdmFscywgb3IgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25NdXRhdGlvbicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25NdXRhdGlvbihyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSAnY2hpbGRMaXN0Jykge1xuICAgICAgICAgICAgICAvLyBNYW5hZ2UgYWRkZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICAgIC8vIFVuLW1hbmFnZSByZW1vdmVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLnJlbW92ZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlU3VidHJlZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAndGFiaW5kZXgnKSB7XG4gICAgICAgICAgICAgICAgLy8gUmUtaW5pdGlhbGlzZSBpbmVydCBub2RlIGlmIHRhYmluZGV4IGNoYW5nZXNcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VOb2RlKHRhcmdldCk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0ICE9PSB0aGlzLl9yb290RWxlbWVudCAmJiByZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ2luZXJ0JyAmJiB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBuZXcgaW5lcnQgcm9vdCBpcyBhZGRlZCwgYWRvcHQgaXRzIG1hbmFnZWQgbm9kZXMgYW5kIG1ha2Ugc3VyZSBpdCBrbm93cyBhYm91dCB0aGVcbiAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IG1hbmFnZWQgbm9kZXMgZnJvbSB0aGlzIGluZXJ0IHN1YnJvb3QuXG4gICAgICAgICAgICAgICAgdGhpcy5fYWRvcHRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VkTm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldC5jb250YWlucyhtYW5hZ2VkTm9kZS5ub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydFN1YnJvb3QuX21hbmFnZU5vZGUobWFuYWdlZE5vZGUubm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdtYW5hZ2VkTm9kZXMnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFNldCh0aGlzLl9tYW5hZ2VkTm9kZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9zdHJpbmd9IGFyaWFIaWRkZW4gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChhcmlhSGlkZGVuKSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gYXJpYUhpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/c3RyaW5nfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW47XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Um9vdDtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBgSW5lcnROb2RlYCBpbml0aWFsaXNlcyBhbmQgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBub2RlLlxuICAgICAqIEEgbm9kZSBpcyBpbmVydCBpZiBpdCBpcyBhIGRlc2NlbmRhbnQgb2Ygb25lIG9yIG1vcmUgaW5lcnQgcm9vdCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIE9uIGNvbnN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgc2F2ZXMgdGhlIGV4aXN0aW5nIGB0YWJpbmRleGAgdmFsdWUgZm9yIHRoZSBub2RlLCBpZiBhbnksIGFuZFxuICAgICAqIGVpdGhlciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBvciBzZXRzIGl0IHRvIGAtMWAsIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBlbGVtZW50XG4gICAgICogaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUgb3Igbm90LlxuICAgICAqXG4gICAgICogYEluZXJ0Tm9kZWAgbWFpbnRhaW5zIGEgc2V0IG9mIGBJbmVydFJvb3RgcyB3aGljaCBhcmUgZGVzY2VuZGFudHMgb2YgdGhpcyBgSW5lcnROb2RlYC4gV2hlbiBhblxuICAgICAqIGBJbmVydFJvb3RgIGlzIGRlc3Ryb3llZCwgYW5kIGNhbGxzIGBJbmVydE1hbmFnZXIuZGVyZWdpc3RlcigpYCwgdGhlIGBJbmVydE1hbmFnZXJgIG5vdGlmaWVzIHRoZVxuICAgICAqIGBJbmVydE5vZGVgIHZpYSBgcmVtb3ZlSW5lcnRSb290KClgLCB3aGljaCBpbiB0dXJuIGRlc3Ryb3lzIHRoZSBgSW5lcnROb2RlYCBpZiBubyBgSW5lcnRSb290YHNcbiAgICAgKiByZW1haW4gaW4gdGhlIHNldC4gT24gZGVzdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHJlaW5zdGF0ZXMgdGhlIHN0b3JlZCBgdGFiaW5kZXhgIGlmIG9uZSBleGlzdHMsXG4gICAgICogb3IgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgaWYgdGhlIGVsZW1lbnQgaXMgaW50cmluc2ljYWxseSBmb2N1c2FibGUuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgQSBmb2N1c2FibGUgZWxlbWVudCB0byBiZSBtYWRlIGluZXJ0LlxuICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3QgVGhlIGluZXJ0IHJvb3QgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbmVydCBub2RlLlxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE5vZGUpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IU5vZGV9ICovXG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IGZhbHNlO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnRSb290Pn0gVGhlIHNldCBvZiBkZXNjZW5kYW50IGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiAgICBJZiBhbmQgb25seSBpZiB0aGlzIHNldCBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBTZXQoW2luZXJ0Um9vdF0pO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7P251bWJlcn0gKi9cbiAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IG51bGw7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBTYXZlIGFueSBwcmlvciB0YWJpbmRleCBpbmZvIGFuZCBtYWtlIHRoaXMgbm9kZSB1bnRhYmJhYmxlXG4gICAgICAgIHRoaXMuZW5zdXJlVW50YWJiYWJsZSgpO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuXG4gICAgICAgKiBUaGlzIG1ha2VzIHRoZSBtYW5hZ2VkIG5vZGUgZm9jdXNhYmxlIGFnYWluIGFuZCBkZWxldGVzIGFsbCBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgc3RhdGUuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnROb2RlLCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX25vZGUgJiYgdGhpcy5fbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5fbm9kZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIHRoaXMuX3NhdmVkVGFiSW5kZXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSBgZGVsZXRlYCB0byByZXN0b3JlIG5hdGl2ZSBmb2N1cyBtZXRob2QuXG4gICAgICAgICAgICBpZiAodGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCkge1xuICAgICAgICAgICAgICBkZWxldGUgZWxlbWVudC5mb2N1cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBTZWUgbm90ZSBpbiBJbmVydFJvb3QuZGVzdHJ1Y3RvciBmb3Igd2h5IHdlIGNhc3QgdGhlc2UgbnVsbHMgdG8gQU5ZLlxuICAgICAgICAgIHRoaXMuX25vZGUgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGlzIG9iamVjdCBpcyBvYnNvbGV0ZSBiZWNhdXNlIHRoZSBtYW5hZ2VkIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LlxuICAgICAgICAgKiBJZiB0aGUgb2JqZWN0IGhhcyBiZWVuIGRlc3Ryb3llZCwgYW55IGF0dGVtcHQgdG8gYWNjZXNzIGl0IHdpbGwgY2F1c2UgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdGhyb3dJZkRlc3Ryb3llZCcsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhyb3cgaWYgdXNlciB0cmllcyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdGhyb3dJZkRlc3Ryb3llZCgpIHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZW5zdXJlVW50YWJiYWJsZScsXG5cblxuICAgICAgICAvKiogU2F2ZSB0aGUgZXhpc3RpbmcgdGFiaW5kZXggdmFsdWUgYW5kIG1ha2UgdGhlIG5vZGUgdW50YWJiYWJsZSBhbmQgdW5mb2N1c2FibGUgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVuc3VyZVVudGFiYmFibGUoKSB7XG4gICAgICAgICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLm5vZGU7XG4gICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcpKSB7XG4gICAgICAgICAgICBpZiAoIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXggPT09IC0xICYmIHRoaXMuaGFzU2F2ZWRUYWJJbmRleCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQuZm9jdXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgICAgdGhpcy5fb3ZlcnJvZGVGb2N1c01ldGhvZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkIGFub3RoZXIgaW5lcnQgcm9vdCB0byB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2FkZEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuYWRkKGluZXJ0Um9vdCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBnaXZlbiBpbmVydCByb290IGZyb20gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBJZiB0aGUgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzIGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQsXG4gICAgICAgICAqIHNvIHRoZSBvYmplY3Qgc2hvdWxkIGJlIGRlc3Ryb3llZC5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVtb3ZlSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10oaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmRlc3RydWN0b3IoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVzdHJveWVkJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuICgvKiogQHR5cGUgeyFJbmVydE5vZGV9ICovdGhpcy5fZGVzdHJveWVkXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZFRhYkluZGV4JyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7IU5vZGV9ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbm9kZScsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcGFyYW0gez9udW1iZXJ9IHRhYkluZGV4ICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KHRhYkluZGV4KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSB0YWJJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHs/bnVtYmVyfSAqL1xuICAgICAgICAsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleDtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnROb2RlO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIEluZXJ0TWFuYWdlciBpcyBhIHBlci1kb2N1bWVudCBzaW5nbGV0b24gb2JqZWN0IHdoaWNoIG1hbmFnZXMgYWxsIGluZXJ0IHJvb3RzIGFuZCBub2Rlcy5cbiAgICAgKlxuICAgICAqIFdoZW4gYW4gZWxlbWVudCBiZWNvbWVzIGFuIGluZXJ0IHJvb3QgYnkgaGF2aW5nIGFuIGBpbmVydGAgYXR0cmlidXRlIHNldCBhbmQvb3IgaXRzIGBpbmVydGBcbiAgICAgKiBwcm9wZXJ0eSBzZXQgdG8gYHRydWVgLCB0aGUgYHNldEluZXJ0YCBtZXRob2QgY3JlYXRlcyBhbiBgSW5lcnRSb290YCBvYmplY3QgZm9yIHRoZSBlbGVtZW50LlxuICAgICAqIFRoZSBgSW5lcnRSb290YCBpbiB0dXJuIHJlZ2lzdGVycyBpdHNlbGYgYXMgbWFuYWdpbmcgYWxsIG9mIHRoZSBlbGVtZW50J3MgZm9jdXNhYmxlIGRlc2NlbmRhbnRcbiAgICAgKiBub2RlcyB2aWEgdGhlIGByZWdpc3RlcigpYCBtZXRob2QuIFRoZSBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWAgaW5zdGFuY2VcbiAgICAgKiBpcyBjcmVhdGVkIGZvciBlYWNoIHN1Y2ggbm9kZSwgdmlhIHRoZSBgX21hbmFnZWROb2Rlc2AgbWFwLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnRNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFEb2N1bWVudH0gZG9jdW1lbnRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRNYW5hZ2VyKGRvY3VtZW50KSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydE1hbmFnZXIpO1xuXG4gICAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQ7IEluZXJ0TWFuYWdlciBuZWVkcyB0byB3cmFwIGEgZG9jdW1lbnQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHR5cGUgeyFEb2N1bWVudH0gKi9cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQgPSBkb2N1bWVudDtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIG1hbmFnZWQgbm9kZXMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydE5vZGU+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgaW5lcnQgcm9vdHMga25vd24gdG8gdGhpcyBJbmVydE1hbmFnZXIuIEluIGEgbWFwIHRvIGFsbG93IGxvb2tpbmcgdXAgYnkgTm9kZS5cbiAgICAgICAgICogQHR5cGUgeyFNYXA8IU5vZGUsICFJbmVydFJvb3Q+fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogT2JzZXJ2ZXIgZm9yIG11dGF0aW9ucyBvbiBgZG9jdW1lbnQuYm9keWAuXG4gICAgICAgICAqIEB0eXBlIHshTXV0YXRpb25PYnNlcnZlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX29ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5fd2F0Y2hGb3JJbmVydC5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBBZGQgaW5lcnQgc3R5bGUuXG4gICAgICAgIGFkZEluZXJ0U3R5bGUoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5ib2R5IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2FpdCBmb3IgZG9jdW1lbnQgdG8gYmUgbG9hZGVkLlxuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQuYmluZCh0aGlzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fb25Eb2N1bWVudExvYWRlZCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIGVsZW1lbnQgc2hvdWxkIGJlIGFuIGluZXJ0IHJvb3Qgb3Igbm90LlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RcbiAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5lcnRcbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE1hbmFnZXIsIFt7XG4gICAgICAgIGtleTogJ3NldEluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEluZXJ0KHJvb3QsIGluZXJ0KSB7XG4gICAgICAgICAgaWYgKGluZXJ0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IGluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGluZXJ0Um9vdCA9IG5ldyBJbmVydFJvb3Qocm9vdCwgdGhpcyk7XG4gICAgICAgICAgICByb290LnNldEF0dHJpYnV0ZSgnaW5lcnQnLCAnJyk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLnNldChyb290LCBpbmVydFJvb3QpO1xuICAgICAgICAgICAgLy8gSWYgbm90IGNvbnRhaW5lZCBpbiB0aGUgZG9jdW1lbnQsIGl0IG11c3QgYmUgaW4gYSBzaGFkb3dSb290LlxuICAgICAgICAgICAgLy8gRW5zdXJlIGluZXJ0IHN0eWxlcyBhcmUgYWRkZWQgdGhlcmUuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2RvY3VtZW50LmJvZHkuY29udGFpbnMocm9vdCkpIHtcbiAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHJvb3QucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnQubm9kZVR5cGUgPT09IDExKSB7XG4gICAgICAgICAgICAgICAgICBhZGRJbmVydFN0eWxlKHBhcmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5lcnRSb290cy5oYXMocm9vdCkpIHtcbiAgICAgICAgICAgICAgLy8gZWxlbWVudCBpcyBhbHJlYWR5IG5vbi1pbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfaW5lcnRSb290ID0gdGhpcy5faW5lcnRSb290cy5nZXQocm9vdCk7XG4gICAgICAgICAgICBfaW5lcnRSb290LmRlc3RydWN0b3IoKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKHJvb3QpO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEdldCB0aGUgSW5lcnRSb290IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBnaXZlbiBpbmVydCByb290IGVsZW1lbnQsIGlmIGFueS5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gZWxlbWVudFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnRSb290fHVuZGVmaW5lZH1cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZ2V0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEluZXJ0Um9vdChlbGVtZW50KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2luZXJ0Um9vdHMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIG5vZGUuXG4gICAgICAgICAqIEluIHRoZSBjYXNlIHdoZXJlIHRoZSBub2RlIGhhcyBhIHByZXZpb3VzbHkgZXhpc3RpbmcgaW5lcnQgcm9vdCwgdGhpcyBpbmVydCByb290IHdpbGxcbiAgICAgICAgICogYmUgYWRkZWQgdG8gaXRzIHNldCBvZiBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHshSW5lcnROb2RlfSBpbmVydE5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAncmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub2RlIHdhcyBhbHJlYWR5IGluIGFuIGluZXJ0IHN1YnRyZWVcbiAgICAgICAgICAgIGluZXJ0Tm9kZS5hZGRJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5lcnROb2RlID0gbmV3IEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5zZXQobm9kZSwgaW5lcnROb2RlKTtcblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGUtcmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gaW5lcnQgbm9kZS5cbiAgICAgICAgICogUmVtb3ZlcyB0aGUgaW5lcnQgcm9vdCBmcm9tIHRoZSBJbmVydE5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMsIGFuZCByZW1vdmUgdGhlIGluZXJ0XG4gICAgICAgICAqIG5vZGUgZnJvbSB0aGUgSW5lcnRNYW5hZ2VyJ3Mgc2V0IG9mIG1hbmFnZWQgbm9kZXMgaWYgaXQgaXMgZGVzdHJveWVkLlxuICAgICAgICAgKiBJZiB0aGUgbm9kZSBpcyBub3QgY3VycmVudGx5IG1hbmFnZWQsIHRoaXMgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKiBAcmV0dXJuIHs/SW5lcnROb2RlfSBUaGUgcG90ZW50aWFsbHkgZGVzdHJveWVkIEluZXJ0Tm9kZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCBpZiBhbnkuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2RlcmVnaXN0ZXInLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVyZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoIWluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnROb2RlLnJlbW92ZUluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXNbJ2RlbGV0ZSddKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBpbmVydE5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIGRvY3VtZW50IGhhcyBmaW5pc2hlZCBsb2FkaW5nLlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfb25Eb2N1bWVudExvYWRlZCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Eb2N1bWVudExvYWRlZCgpIHtcbiAgICAgICAgICAvLyBGaW5kIGFsbCBpbmVydCByb290cyBpbiBkb2N1bWVudCBhbmQgbWFrZSB0aGVtIGFjdHVhbGx5IGluZXJ0LlxuICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbCh0aGlzLl9kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBDb21tZW50IHRoaXMgb3V0IHRvIHVzZSBwcm9ncmFtbWF0aWMgQVBJIG9ubHkuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudC5ib2R5IHx8IHRoaXMuX2RvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBzdWJ0cmVlOiB0cnVlLCBjaGlsZExpc3Q6IHRydWUgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgYXR0cmlidXRlIGNoYW5nZXMuXG4gICAgICAgICAqIEBwYXJhbSB7IUFycmF5PCFNdXRhdGlvblJlY29yZD59IHJlY29yZHNcbiAgICAgICAgICogQHBhcmFtIHshTXV0YXRpb25PYnNlcnZlcn0gc2VsZlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfd2F0Y2hGb3JJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfd2F0Y2hGb3JJbmVydChyZWNvcmRzLCBzZWxmKSB7XG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgc3dpdGNoIChyZWNvcmQudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdjaGlsZExpc3QnOlxuICAgICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbaW5lcnRdJykpO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCAnW2luZXJ0XScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMudW5zaGlmdChub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluZXJ0RWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgJ2F0dHJpYnV0ZXMnOlxuICAgICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSAhPT0gJ2luZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgICAgICB2YXIgaW5lcnQgPSB0YXJnZXQuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNldEluZXJ0KHRhcmdldCwgaW5lcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE1hbmFnZXI7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogUmVjdXJzaXZlbHkgd2FsayB0aGUgY29tcG9zZWQgdHJlZSBmcm9tIHxub2RlfC5cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHsoZnVuY3Rpb24gKCFIVE1MRWxlbWVudCkpPX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvciBlYWNoIGVsZW1lbnQgdHJhdmVyc2VkLFxuICAgICAqICAgICBiZWZvcmUgZGVzY2VuZGluZyBpbnRvIGNoaWxkIG5vZGVzLlxuICAgICAqIEBwYXJhbSB7P1NoYWRvd1Jvb3Q9fSBzaGFkb3dSb290QW5jZXN0b3IgVGhlIG5lYXJlc3QgU2hhZG93Um9vdCBhbmNlc3RvciwgaWYgYW55LlxuICAgICAqL1xuXG5cbiAgICBmdW5jdGlvbiBjb21wb3NlZFRyZWVXYWxrKG5vZGUsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXNjZW5kIGludG8gbm9kZTpcbiAgICAgICAgLy8gSWYgaXQgaGFzIGEgU2hhZG93Um9vdCwgaWdub3JlIGFsbCBjaGlsZCBlbGVtZW50cyAtIHRoZXNlIHdpbGwgYmUgcGlja2VkXG4gICAgICAgIC8vIHVwIGJ5IHRoZSA8Y29udGVudD4gb3IgPHNoYWRvdz4gZWxlbWVudHMuIERlc2NlbmQgc3RyYWlnaHQgaW50byB0aGVcbiAgICAgICAgLy8gU2hhZG93Um9vdC5cbiAgICAgICAgdmFyIHNoYWRvd1Jvb3QgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICAgIGlmIChzaGFkb3dSb290KSB7XG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzaGFkb3dSb290LCBjYWxsYmFjaywgc2hhZG93Um9vdCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8Y29udGVudD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdjb250ZW50Jykge1xuICAgICAgICAgIHZhciBjb250ZW50ID0gLyoqIEB0eXBlIHshSFRNTENvbnRlbnRFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZpZXMgaWYgU2hhZG93RG9tIHYwIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgZGlzdHJpYnV0ZWROb2RlcyA9IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcyA/IGNvbnRlbnQuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGRpc3RyaWJ1dGVkTm9kZXNbaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxzbG90PiBlbGVtZW50LCBkZXNjZW5kIGludG8gYXNzaWduZWQgbm9kZXMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgdmFyIHNsb3QgPSAvKiogQHR5cGUgeyFIVE1MU2xvdEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZnkgaWYgU2hhZG93RG9tIHYxIGlzIHN1cHBvcnRlZC5cbiAgICAgICAgICB2YXIgX2Rpc3RyaWJ1dGVkTm9kZXMgPSBzbG90LmFzc2lnbmVkTm9kZXMgPyBzbG90LmFzc2lnbmVkTm9kZXMoeyBmbGF0dGVuOiB0cnVlIH0pIDogW107XG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IF9kaXN0cmlidXRlZE5vZGVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhfZGlzdHJpYnV0ZWROb2Rlc1tfaV0sIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgbmVpdGhlciB0aGUgcGFyZW50IG9mIGEgU2hhZG93Um9vdCwgYSA8Y29udGVudD4gZWxlbWVudCwgYSA8c2xvdD5cbiAgICAgIC8vIGVsZW1lbnQsIG5vciBhIDxzaGFkb3c+IGVsZW1lbnQgcmVjdXJzZSBub3JtYWxseS5cbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoY2hpbGQsIGNhbGxiYWNrLCBzaGFkb3dSb290QW5jZXN0b3IpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzdHlsZSBlbGVtZW50IHRvIHRoZSBub2RlIGNvbnRhaW5pbmcgdGhlIGluZXJ0IHNwZWNpZmljIHN0eWxlc1xuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRJbmVydFN0eWxlKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlI2luZXJ0LXN0eWxlLCBsaW5rI2luZXJ0LXN0eWxlJykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnaWQnLCAnaW5lcnQtc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gJ1xcbicgKyAnW2luZXJ0XSB7XFxuJyArICcgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbicgKyAnICBjdXJzb3I6IGRlZmF1bHQ7XFxuJyArICd9XFxuJyArICdcXG4nICsgJ1tpbmVydF0sIFtpbmVydF0gKiB7XFxuJyArICcgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICd9XFxuJztcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cblxuICAgIGlmICghSFRNTEVsZW1lbnQucHJvdG90eXBlLmhhc093blByb3BlcnR5KCdpbmVydCcpKSB7XG4gICAgICAvKiogQHR5cGUgeyFJbmVydE1hbmFnZXJ9ICovXG4gICAgICB2YXIgaW5lcnRNYW5hZ2VyID0gbmV3IEluZXJ0TWFuYWdlcihkb2N1bWVudCk7XG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbmVydCcsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGluZXJ0KSB7XG4gICAgICAgICAgaW5lcnRNYW5hZ2VyLnNldEluZXJ0KHRoaXMsIGluZXJ0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9KSgpO1xuXG59KSkpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyoqXG4gKiBgQmxvY2tpbmdFbGVtZW50c2AgbWFuYWdlcyBhIHN0YWNrIG9mIGVsZW1lbnRzIHRoYXQgaW5lcnQgdGhlIGludGVyYWN0aW9uXG4gKiBvdXRzaWRlIHRoZW0uIFRoZSB0b3AgZWxlbWVudCBpcyB0aGUgaW50ZXJhY3RpdmUgcGFydCBvZiB0aGUgZG9jdW1lbnQuXG4gKiBUaGUgc3RhY2sgY2FuIGJlIHVwZGF0ZWQgd2l0aCB0aGUgbWV0aG9kcyBgcHVzaCwgcmVtb3ZlLCBwb3BgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEJsb2NraW5nRWxlbWVudHMge1xuICAvKipcbiAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS4gVGhpcyBlbXB0aWVzXG4gICAqIHRoZSBibG9ja2luZyBlbGVtZW50c1xuICAgKi9cbiAgZGVzdHJ1Y3RvcigpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBUaGUgdG9wIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICB0b3A6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGVsZW1lbnQgdG8gdGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgKi9cbiAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmcgZWxlbWVudHMuIFJldHVybnMgdHJ1ZSBpZiB0aGVcbiAgICogZWxlbWVudCB3YXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgdG9wIGJsb2NraW5nIGVsZW1lbnQgYW5kIHJldHVybnMgaXQuXG4gICAqL1xuICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBhIGJsb2NraW5nIGVsZW1lbnQuXG4gICAqL1xuICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgZXh0ZW5kcyBEb2N1bWVudCB7XG4gICRibG9ja2luZ0VsZW1lbnRzOiBCbG9ja2luZ0VsZW1lbnRzO1xufVxuXG4oKCkgPT4ge1xuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHByb3BlcnRpZXMgKi9cbiAgY29uc3QgX2Jsb2NraW5nRWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2FscmVhZHlJbmVydEVsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF90b3BFbFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3NpYmxpbmdzVG9SZXN0b3JlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9wYXJlbnRNTyA9IFN5bWJvbCgpO1xuXG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgc3RhdGljIG1ldGhvZHMgKi9cbiAgY29uc3QgX3RvcENoYW5nZWQgPSBTeW1ib2woKTtcbiAgY29uc3QgX3N3YXBJbmVydGVkU2libGluZyA9IFN5bWJvbCgpO1xuICBjb25zdCBfaW5lcnRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfcmVzdG9yZUluZXJ0ZWRTaWJsaW5ncyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0UGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbiA9IFN5bWJvbCgpO1xuICBjb25zdCBfaXNJbmVydGFibGUgPSBTeW1ib2woKTtcbiAgY29uc3QgX2hhbmRsZU11dGF0aW9ucyA9IFN5bWJvbCgpO1xuXG4gIGludGVyZmFjZSBJbmVydGFibGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgaW5lcnQ/OiBib29sZWFuO1xuICB9XG5cbiAgaW50ZXJmYWNlIEludGVybmFsU3RhdGUge1xuICAgIFtfc2libGluZ3NUb1Jlc3RvcmVdOiBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPjtcbiAgICBbX3BhcmVudE1PXTogTXV0YXRpb25PYnNlcnZlcjtcbiAgfVxuICBpbnRlcmZhY2UgSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgSW50ZXJuYWxTdGF0ZSB7fVxuICBpbnRlcmZhY2UgTWF5YmVIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBQYXJ0aWFsPEludGVybmFsU3RhdGU+IHt9XG5cbiAgLyoqXG4gICAqIFNoYWR5RE9NIHNoYWR5IHJvb3RzIGxvb2sgYSBsb3QgbGlrZSByZWFsIFNoYWRvd1Jvb3RzLiBUaGUgX19zaGFkeSBwcm9wZXJ0eVxuICAgKiBnaXZlcyB0aGVtIGF3YXksIHRob3VnaC5cbiAgICovXG4gIGludGVyZmFjZSBNYXliZVNoYWR5Um9vdCBleHRlbmRzIEVsZW1lbnQge1xuICAgIF9fc2hhZHk6IHVua25vd247XG4gICAgaG9zdDogRWxlbWVudDtcbiAgfVxuXG4gIGNsYXNzIEJsb2NraW5nRWxlbWVudHNJbXBsIGltcGxlbWVudHMgQmxvY2tpbmdFbGVtZW50cyB7XG4gICAgLyoqXG4gICAgICogVGhlIGJsb2NraW5nIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2Jsb2NraW5nRWxlbWVudHNdOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBwYXJlbnRzIG9mIHRoZSB0b3AgZWxlbWVudCwgZnJvbSB0aGUgZWxlbWVudFxuICAgICAqIGl0c2VsZiB1cCB0byBib2R5LiBXaGVuIHRvcCBjaGFuZ2VzLCB0aGUgb2xkIHRvcCBtaWdodCBoYXZlIGJlZW4gcmVtb3ZlZFxuICAgICAqIGZyb20gdGhlIGRvY3VtZW50LCBzbyB3ZSBuZWVkIHRvIG1lbW9pemUgdGhlIGluZXJ0ZWQgcGFyZW50cycgc2libGluZ3NcbiAgICAgKiBpbiBvcmRlciB0byByZXN0b3JlIHRoZWlyIGluZXJ0ZW5lc3Mgd2hlbiB0b3AgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BFbFBhcmVudHNdOiBIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEVsZW1lbnRzIHRoYXQgYXJlIGFscmVhZHkgaW5lcnQgYmVmb3JlIHRoZSBmaXJzdCBibG9ja2luZyBlbGVtZW50IGlzXG4gICAgICogcHVzaGVkLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG5ldyBTZXQ8TWF5YmVIYXNJbnRlcm5hbFN0YXRlPigpO1xuXG4gICAgZGVzdHJ1Y3RvcigpOiB2b2lkIHtcbiAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgaW5lcnRuZXNzLlxuICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10odGhpc1tfdG9wRWxQYXJlbnRzXSk7XG4gICAgICAvLyBOb3RlIHdlIGRvbid0IHdhbnQgdG8gbWFrZSB0aGVzZSBwcm9wZXJ0aWVzIG51bGxhYmxlIG9uIHRoZSBjbGFzcyxcbiAgICAgIC8vIHNpbmNlIHRoZW4gd2UnZCBuZWVkIG5vbi1udWxsIGNhc3RzIGluIG1hbnkgcGxhY2VzLiBDYWxsaW5nIGEgbWV0aG9kIG9uXG4gICAgICAvLyBhIEJsb2NraW5nRWxlbWVudHMgaW5zdGFuY2UgYWZ0ZXIgY2FsbGluZyBkZXN0cnVjdG9yIHdpbGwgcmVzdWx0IGluIGFuXG4gICAgICAvLyBleGNlcHRpb24uXG4gICAgICBjb25zdCBudWxsYWJsZSA9IHRoaXMgYXMgdW5rbm93biBhcyB7XG4gICAgICAgIFtfYmxvY2tpbmdFbGVtZW50c106IG51bGw7XG4gICAgICAgIFtfdG9wRWxQYXJlbnRzXTogbnVsbDtcbiAgICAgICAgW19hbHJlYWR5SW5lcnRFbGVtZW50c106IG51bGw7XG4gICAgICB9O1xuICAgICAgbnVsbGFibGVbX2Jsb2NraW5nRWxlbWVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW190b3BFbFBhcmVudHNdID0gbnVsbDtcbiAgICAgIG51bGxhYmxlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBudWxsO1xuICAgIH1cblxuICAgIGdldCB0b3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCBlbGVtcyA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdO1xuICAgICAgcmV0dXJuIGVsZW1zW2VsZW1zLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgfVxuXG4gICAgcHVzaChlbGVtZW50OiBIVE1MRWxlbWVudCk6IHZvaWQge1xuICAgICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQgPT09IHRoaXMudG9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIFJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgd2UnbGwgYnJpbmcgaXQgdG8gdGhlIHRvcC5cbiAgICAgIHRoaXMucmVtb3ZlKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0oZWxlbWVudCk7XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJlbW92ZShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgY29uc3QgaSA9IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCk7XG4gICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uc3BsaWNlKGksIDEpO1xuICAgICAgLy8gVG9wIGNoYW5nZWQgb25seSBpZiB0aGUgcmVtb3ZlZCBlbGVtZW50IHdhcyB0aGUgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoaSA9PT0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX3RvcENoYW5nZWRdKHRoaXMudG9wKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IHRvcCA9IHRoaXMudG9wO1xuICAgICAgdG9wICYmIHRoaXMucmVtb3ZlKHRvcCk7XG4gICAgICByZXR1cm4gdG9wO1xuICAgIH1cblxuICAgIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmluZGV4T2YoZWxlbWVudCkgIT09IC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYGluZXJ0YCB0byBhbGwgZG9jdW1lbnQgZWxlbWVudHMgZXhjZXB0IHRoZSBuZXcgdG9wIGVsZW1lbnQsIGl0c1xuICAgICAqIHBhcmVudHMsIGFuZCBpdHMgZGlzdHJpYnV0ZWQgY29udGVudC5cbiAgICAgKi9cbiAgICBwcml2YXRlW190b3BDaGFuZ2VkXShuZXdUb3A6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZXxudWxsKTogdm9pZCB7XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGNvbnN0IG9sZFBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgLy8gTm8gbmV3IHRvcCwgcmVzZXQgb2xkIHRvcCBpZiBhbnkuXG4gICAgICBpZiAoIW5ld1RvcCkge1xuICAgICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzKTtcbiAgICAgICAgdG9LZWVwSW5lcnQuY2xlYXIoKTtcbiAgICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IFtdO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5ld1BhcmVudHMgPSB0aGlzW19nZXRQYXJlbnRzXShuZXdUb3ApO1xuICAgICAgLy8gTmV3IHRvcCBpcyBub3QgY29udGFpbmVkIGluIHRoZSBtYWluIGRvY3VtZW50IVxuICAgICAgaWYgKG5ld1BhcmVudHNbbmV3UGFyZW50cy5sZW5ndGggLSAxXS5wYXJlbnROb2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdOb24tY29ubmVjdGVkIGVsZW1lbnQgY2Fubm90IGJlIGEgYmxvY2tpbmcgZWxlbWVudCcpO1xuICAgICAgfVxuICAgICAgLy8gQ2FzdCBoZXJlIGJlY2F1c2Ugd2Uga25vdyB3ZSdsbCBjYWxsIF9pbmVydFNpYmxpbmdzIG9uIG5ld1BhcmVudHNcbiAgICAgIC8vIGJlbG93LlxuICAgICAgdGhpc1tfdG9wRWxQYXJlbnRzXSA9IG5ld1BhcmVudHMgYXMgQXJyYXk8SGFzSW50ZXJuYWxTdGF0ZT47XG5cbiAgICAgIGNvbnN0IHRvU2tpcCA9IHRoaXNbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKG5ld1RvcCk7XG5cbiAgICAgIC8vIE5vIHByZXZpb3VzIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKCFvbGRQYXJlbnRzLmxlbmd0aCkge1xuICAgICAgICB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLCB0b1NraXAsIHRvS2VlcEluZXJ0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgaSA9IG9sZFBhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBqID0gbmV3UGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgLy8gRmluZCBjb21tb24gcGFyZW50LiBJbmRleCAwIGlzIHRoZSBlbGVtZW50IGl0c2VsZiAoc28gc3RvcCBiZWZvcmUgaXQpLlxuICAgICAgd2hpbGUgKGkgPiAwICYmIGogPiAwICYmIG9sZFBhcmVudHNbaV0gPT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgaS0tO1xuICAgICAgICBqLS07XG4gICAgICB9XG4gICAgICAvLyBJZiB1cCB0aGUgcGFyZW50cyB0cmVlIHRoZXJlIGFyZSAyIGVsZW1lbnRzIHRoYXQgYXJlIHNpYmxpbmdzLCBzd2FwXG4gICAgICAvLyB0aGUgaW5lcnRlZCBzaWJsaW5nLlxuICAgICAgaWYgKG9sZFBhcmVudHNbaV0gIT09IG5ld1BhcmVudHNbal0pIHtcbiAgICAgICAgdGhpc1tfc3dhcEluZXJ0ZWRTaWJsaW5nXShvbGRQYXJlbnRzW2ldLCBuZXdQYXJlbnRzW2pdKTtcbiAgICAgIH1cbiAgICAgIC8vIFJlc3RvcmUgb2xkIHBhcmVudHMgc2libGluZ3MgaW5lcnRuZXNzLlxuICAgICAgaSA+IDAgJiYgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cy5zbGljZSgwLCBpKSk7XG4gICAgICAvLyBNYWtlIG5ldyBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0LlxuICAgICAgaiA+IDAgJiYgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cy5zbGljZSgwLCBqKSwgdG9Ta2lwLCBudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTd2FwcyBpbmVydG5lc3MgYmV0d2VlbiB0d28gc2libGluZyBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19zd2FwSW5lcnRlZFNpYmxpbmddKFxuICAgICAgICBvbGRJbmVydDogSGFzSW50ZXJuYWxTdGF0ZSwgbmV3SW5lcnQ6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2libGluZ3NUb1Jlc3RvcmUgPSBvbGRJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgLy8gb2xkSW5lcnQgaXMgbm90IGNvbnRhaW5lZCBpbiBzaWJsaW5ncyB0byByZXN0b3JlLCBzbyB3ZSBoYXZlIHRvIGNoZWNrXG4gICAgICAvLyBpZiBpdCdzIGluZXJ0YWJsZSBhbmQgaWYgYWxyZWFkeSBpbmVydC5cbiAgICAgIGlmICh0aGlzW19pc0luZXJ0YWJsZV0ob2xkSW5lcnQpICYmICFvbGRJbmVydC5pbmVydCkge1xuICAgICAgICBvbGRJbmVydC5pbmVydCA9IHRydWU7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmFkZChvbGRJbmVydCk7XG4gICAgICB9XG4gICAgICAvLyBJZiBuZXdJbmVydCB3YXMgYWxyZWFkeSBiZXR3ZWVuIHRoZSBzaWJsaW5ncyB0byByZXN0b3JlLCBpdCBtZWFucyBpdCBpc1xuICAgICAgLy8gaW5lcnRhYmxlIGFuZCBtdXN0IGJlIHJlc3RvcmVkLlxuICAgICAgaWYgKHNpYmxpbmdzVG9SZXN0b3JlLmhhcyhuZXdJbmVydCkpIHtcbiAgICAgICAgbmV3SW5lcnQuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuZGVsZXRlKG5ld0luZXJ0KTtcbiAgICAgIH1cbiAgICAgIG5ld0luZXJ0W19wYXJlbnRNT10gPSBvbGRJbmVydFtfcGFyZW50TU9dO1xuICAgICAgbmV3SW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHNpYmxpbmdzVG9SZXN0b3JlO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVzdG9yZXMgb3JpZ2luYWwgaW5lcnRuZXNzIHRvIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10oZWxlbWVudHM6IEhhc0ludGVybmFsU3RhdGVbXSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IG1vID0gZWxlbWVudFtfcGFyZW50TU9dO1xuICAgICAgICBtby5kaXNjb25uZWN0KCk7XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3BhcmVudE1PXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc2libGluZ3MgPSBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAgIGZvciAoY29uc3Qgc2libGluZyBvZiBzaWJsaW5ncykge1xuICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19zaWJsaW5nc1RvUmVzdG9yZV0gPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5lcnRzIHRoZSBzaWJsaW5ncyBvZiB0aGUgZWxlbWVudHMgZXhjZXB0IHRoZSBlbGVtZW50cyB0byBza2lwLiBTdG9yZXNcbiAgICAgKiB0aGUgaW5lcnRlZCBzaWJsaW5ncyBpbnRvIHRoZSBlbGVtZW50J3Mgc3ltYm9sIGBfc2libGluZ3NUb1Jlc3RvcmVgLlxuICAgICAqIFBhc3MgYHRvS2VlcEluZXJ0YCB0byBjb2xsZWN0IHRoZSBhbHJlYWR5IGluZXJ0IGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX2luZXJ0U2libGluZ3NdKFxuICAgICAgICBlbGVtZW50czogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10sIHRvU2tpcDogU2V0PEhUTUxFbGVtZW50PnxudWxsLFxuICAgICAgICB0b0tlZXBJbmVydDogU2V0PEhUTUxFbGVtZW50PnxudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgLy8gQXNzdW1lIGVsZW1lbnQgaXMgbm90IGEgRG9jdW1lbnQsIHNvIGl0IG11c3QgaGF2ZSBhIHBhcmVudE5vZGUuXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSE7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gcGFyZW50LmNoaWxkcmVuO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGNoaWxkcmVuW2pdIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICAvLyBTa2lwIHRoZSBpbnB1dCBlbGVtZW50LCBpZiBub3QgaW5lcnRhYmxlIG9yIHRvIGJlIHNraXBwZWQuXG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGVsZW1lbnQgfHwgIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSB8fFxuICAgICAgICAgICAgICAodG9Ta2lwICYmIHRvU2tpcC5oYXMoc2libGluZykpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gU2hvdWxkIGJlIGNvbGxlY3RlZCBzaW5jZSBhbHJlYWR5IGluZXJ0ZWQuXG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSB0aGUgc2libGluZ3MgdGhhdCB3ZXJlIGluZXJ0ZWQuXG4gICAgICAgIGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IGluZXJ0ZWRTaWJsaW5ncztcbiAgICAgICAgLy8gT2JzZXJ2ZSBvbmx5IGltbWVkaWF0ZSBjaGlsZHJlbiBtdXRhdGlvbnMgb24gdGhlIHBhcmVudC5cbiAgICAgICAgY29uc3QgbW8gPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzW19oYW5kbGVNdXRhdGlvbnNdLmJpbmQodGhpcykpO1xuICAgICAgICBlbGVtZW50W19wYXJlbnRNT10gPSBtbztcbiAgICAgICAgbGV0IHBhcmVudFRvT2JzZXJ2ZSA9IHBhcmVudDtcbiAgICAgICAgLy8gSWYgd2UncmUgdXNpbmcgdGhlIFNoYWR5RE9NIHBvbHlmaWxsLCB0aGVuIG91ciBwYXJlbnQgY291bGQgYmUgYVxuICAgICAgICAvLyBzaGFkeSByb290LCB3aGljaCBpcyBhbiBvYmplY3QgdGhhdCBhY3RzIGxpa2UgYSBTaGFkb3dSb290LCBidXQgaXNuJ3RcbiAgICAgICAgLy8gYWN0dWFsbHkgYSBub2RlIGluIHRoZSByZWFsIERPTS4gT2JzZXJ2ZSB0aGUgcmVhbCBET00gcGFyZW50IGluc3RlYWQuXG4gICAgICAgIGNvbnN0IG1heWJlU2hhZHlSb290ID0gcGFyZW50VG9PYnNlcnZlIGFzIE1heWJlU2hhZHlSb290O1xuICAgICAgICBpZiAobWF5YmVTaGFkeVJvb3QuX19zaGFkeSAmJiBtYXliZVNoYWR5Um9vdC5ob3N0KSB7XG4gICAgICAgICAgcGFyZW50VG9PYnNlcnZlID0gbWF5YmVTaGFkeVJvb3QuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBtby5vYnNlcnZlKHBhcmVudFRvT2JzZXJ2ZSwge1xuICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBuZXdseSBhZGRlZC9yZW1vdmVkIG5vZGVzIGJ5IHRvZ2dsaW5nIHRoZWlyIGluZXJ0bmVzcy5cbiAgICAgKiBJdCBhbHNvIGNoZWNrcyBpZiB0aGUgY3VycmVudCB0b3AgQmxvY2tpbmcgRWxlbWVudCBoYXMgYmVlbiByZW1vdmVkLFxuICAgICAqIG5vdGlmeWluZyBhbmQgcmVtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaGFuZGxlTXV0YXRpb25zXShtdXRhdGlvbnM6IE11dGF0aW9uUmVjb3JkW10pOiB2b2lkIHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSB0aGlzW190b3BFbFBhcmVudHNdO1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgc2hhZG93Um9vdCwgZ2V0IGl0cyBob3N0IGFzIHdlIHNraXAgc2hhZG93Um9vdHMgd2hlblxuICAgICAgICAvLyBjb21wdXRpbmcgX3RvcEVsUGFyZW50cy5cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gKG11dGF0aW9uLnRhcmdldCBhcyBTaGFkb3dSb290KS5ob3N0IHx8IG11dGF0aW9uLnRhcmdldDtcbiAgICAgICAgY29uc3QgaWR4ID0gdGFyZ2V0ID09PSBkb2N1bWVudC5ib2R5ID9cbiAgICAgICAgICAgIHBhcmVudHMubGVuZ3RoIDpcbiAgICAgICAgICAgIHBhcmVudHMuaW5kZXhPZih0YXJnZXQgYXMgSGFzSW50ZXJuYWxTdGF0ZSk7XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRDaGlsZCA9IHBhcmVudHNbaWR4IC0gMV07XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IGluZXJ0ZWRDaGlsZFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuXG4gICAgICAgIC8vIFRvIHJlc3RvcmUuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24ucmVtb3ZlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLnJlbW92ZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKHNpYmxpbmcgPT09IGluZXJ0ZWRDaGlsZCkge1xuICAgICAgICAgICAgY29uc29sZS5pbmZvKCdEZXRlY3RlZCByZW1vdmFsIG9mIHRoZSB0b3AgQmxvY2tpbmcgRWxlbWVudC4nKTtcbiAgICAgICAgICAgIHRoaXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbmVydGVkU2libGluZ3MuaGFzKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuZGVsZXRlKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRvIGluZXJ0LlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24uYWRkZWROb2Rlc1tpXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgaWYgKCF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBpZiB0aGUgZWxlbWVudCBpcyBpbmVydGFibGUuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfaXNJbmVydGFibGVdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gZmFsc2UgPT09IC9eKHN0eWxlfHRlbXBsYXRlfHNjcmlwdCkkLy50ZXN0KGVsZW1lbnQubG9jYWxOYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIG5ld1BhcmVudHMgb2YgYW4gZWxlbWVudCwgc3RhcnRpbmcgZnJvbSBlbGVtZW50XG4gICAgICogKGluY2x1ZGVkKSB1cCB0byBgZG9jdW1lbnQuYm9keWAgKGV4Y2x1ZGVkKS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXRQYXJlbnRzXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IEFycmF5PEhUTUxFbGVtZW50PiB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XG4gICAgICBsZXQgY3VycmVudDogSFRNTEVsZW1lbnR8bnVsbHx1bmRlZmluZWQgPSBlbGVtZW50O1xuICAgICAgLy8gU3RvcCB0byBib2R5LlxuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAvLyBTa2lwIHNoYWRvdyByb290cy5cbiAgICAgICAgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNoYWRvd0RvbSB2MVxuICAgICAgICBpZiAoY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBDb2xsZWN0IHNsb3RzIGZyb20gZGVlcGVzdCBzbG90IHRvIHRvcC5cbiAgICAgICAgICB3aGlsZSAoY3VycmVudCA9IGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENvbnRpbnVlIHRoZSBzZWFyY2ggb24gdGhlIHRvcCBzbG90LlxuICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQgfHxcbiAgICAgICAgICAgIChjdXJyZW50IGFzIE5vZGUgYXMgU2hhZG93Um9vdCkuaG9zdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRpc3RyaWJ1dGVkIGNoaWxkcmVuIG9mIHRoZSBlbGVtZW50J3Mgc2hhZG93IHJvb3QuXG4gICAgICogUmV0dXJucyBudWxsIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhIHNoYWRvdyByb290LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW5dKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTpcbiAgICAgICAgU2V0PEhUTUxFbGVtZW50PnxudWxsIHtcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAoIXNoYWRvd1Jvb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgU2V0PEhUTUxFbGVtZW50PigpO1xuICAgICAgbGV0IGk7XG4gICAgICBsZXQgajtcbiAgICAgIGxldCBub2RlcztcbiAgICAgIGNvbnN0IHNsb3RzID0gc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdzbG90Jyk7XG4gICAgICBpZiAoc2xvdHMubGVuZ3RoICYmIHNsb3RzWzBdLmFzc2lnbmVkTm9kZXMpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbm9kZXMgPSBzbG90c1tpXS5hc3NpZ25lZE5vZGVzKHtcbiAgICAgICAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobm9kZXNbal0ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgIHJlc3VsdC5hZGQobm9kZXNbal0gYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBObyBuZWVkIHRvIHNlYXJjaCBmb3IgPGNvbnRlbnQ+LlxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cblxuICAoZG9jdW1lbnQgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgPVxuICAgICAgbmV3IEJsb2NraW5nRWxlbWVudHNJbXBsKCk7XG59KSgpO1xuIiwiaW1wb3J0IFwid2ljZy1pbmVydFwiO1xuaW1wb3J0IFwiYmxvY2tpbmctZWxlbWVudHNcIjtcbmltcG9ydCB7IERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMgfSBmcm9tIFwiYmxvY2tpbmctZWxlbWVudHNcIjtcbmltcG9ydCB7IHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuZnVuY3Rpb24gYmxvY2tpbmdFbGVtZW50cygpIHsgcmV0dXJuIChnZXREb2N1bWVudCgpIGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzIH1cbi8qKlxuICogQWxsb3dzIGFuIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBieSBhcHBseWluZyB0aGUgXCJpbmVydFwiIGF0dHJpYnV0ZSB0byBhbGwgc2libGluZywgYXVudCwgYW5kIHVuY2xlIG5vZGVzLlxuICogXG4gKiBBdXRvbWF0aWNhbGx5IGhhbmRsZXMgY29uc2VjdXRpdmUgY2FsbHMgd2l0aCBhIGxvb3NlbHkgYXBwbGllZCBzdGFjayBvcGVyYXRpb24gXG4gKiAoc3BlY2lmaWNhbGx5IHZpYSBgYmxvY2tpbmdFbGVtZW50c2AsIHdpdGggYSBzbWFsbCBwb2x5ZmlsbCBiZWNhdXNlIEknbSBub3Qgc3VyZSBob3cgbG9uZ1xuICogaXQnbGwgdGFrZSB0byBmaW5kIGl0cyB3YXkgaW50byB0aGUgc3BlYywgaWYgZXZlcilcbiAqIEBwYXJhbSB0YXJnZXQgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VCbG9ja2luZ0VsZW1lbnQ8RSBleHRlbmRzIEVsZW1lbnQ+KGVuYWJsZWQ6IGJvb2xlYW4sIGdldFRhcmdldDogKCkgPT4gKEUgfCBudWxsKSkge1xuXG4gICAgY29uc3Qgc3RhYmxlR2V0VGFyZ2V0ID0gdXNlU3RhYmxlQ2FsbGJhY2soZ2V0VGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIFB1c2gvcG9wIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nRWxlbWVudHMgc3RhY2suXG4gICAgICovXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gc3RhYmxlR2V0VGFyZ2V0KCk7XG5cbiAgICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lcyBibG9ja2luZ0VsZW1lbnRzIHdpbGwgZmFpbCBpZiwgZm9yIGV4YW1wbGUsXG4gICAgICAgICAgICAvLyB0aGUgdGFyZ2V0IGVsZW1lbnQgaXNuJ3QgY29ubmVjdGVkIHRvIGRvY3VtZW50LmJvZHkuXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHJhcmUsIGJ1dCBpdCdzIGJldHRlciB0byBmYWlsIHNpbGVudGx5IHdpdGggd2VpcmQgdGFiYmluZyBiZWhhdmlvclxuICAgICAgICAgICAgLy8gdGhhbiB0byBjcmFzaCB0aGUgZW50aXJlIGFwcGxpY2F0aW9uLlxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucHVzaCh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnJlbW92ZSh0YXJnZXQgYXMgRWxlbWVudCBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIC8vIFdlbGwsIHNlbWktc2lsZW50bHkuXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbZW5hYmxlZF0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wRWxlbWVudCgpIHtcbiAgICByZXR1cm4gYmxvY2tpbmdFbGVtZW50cygpLnRvcDtcbn1cblxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBpc0ZvY3VzYWJsZSB9IGZyb20gXCJ0YWJiYWJsZVwiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XHJcbmltcG9ydCB7IGdldFRvcEVsZW1lbnQsIHVzZUJsb2NraW5nRWxlbWVudCB9IGZyb20gXCIuL3VzZS1ibG9ja2luZy1lbGVtZW50XCI7XHJcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUGFyYW1ldGVycyB7IHRyYXBBY3RpdmU6IGJvb2xlYW47IH1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAocmVsaWVzIG9uIHRoZSBgdHJhcEFjdGl2ZWAgcHJvcCkgKi9cclxuICAgIHVzZUZvY3VzVHJhcFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxufVxyXG5cclxuY29uc3QgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvID0gbmV3IE1hcDxFbGVtZW50IHwgbnVsbCwgKE5vZGUgJiBIVE1MT3JTVkdFbGVtZW50KT4oKTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1RyYXA8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IHRyYXBBY3RpdmUgfTogVXNlRm9jdXNUcmFwUGFyYW1ldGVycyk6IFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RT4ge1xyXG4gICAgXHJcbiAgICBjb25zdCBoYW5kbGVBY3RpdmVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodHJhcEFjdGl2ZTogYm9vbGVhbiwgZWxlbWVudDogRSB8IG51bGwpID0+IHtcclxuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XHJcblxyXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgZXh0cmEgcXVldWVNaWNyb3Rhc2sgaXMgbmVlZGVkIGZvclxyXG4gICAgICAgICAgICAgICAgLy8gLi4ucmVhc29ucz9cclxuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBmaW5kRmlyc3RGb2N1c2FibGUoZWxlbWVudCk/LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbGVtZW50KSB7XHJcblxyXG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBmb2N1cyB0byB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyB0aGF0IGhhcyByZXR1cm5lZCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBsZXQgcmFmSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uZ2V0KGdldFRvcEVsZW1lbnQoKSk/LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IGdldExhc3RBY3RpdmVFbGVtZW50LCB1c2VBY3RpdmVFbGVtZW50UHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUFjdGl2ZUVsZW1lbnQ8RT4oeyBvbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwpID0+IGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBlbGVtZW50KSkgfSk7XHJcblxyXG5cclxuICAgIC8vIFdoZW4gdGhlIHRyYXAgYmVjb21lcyBhY3RpdmUsIGJlZm9yZSB3ZSBsZXQgdGhlIGJsb2NraW5nRWxlbWVudHMgaG9vayBydW4sXHJcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXRldmVyJ3MgY3VycmVudGx5IGZvY3VzZWQgYW5kIHNhdmUgaXQuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyB0byB3aGF0ZXZlcidzIGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uc2V0KGdldFRvcEVsZW1lbnQoKSwgKGdldExhc3RBY3RpdmVFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSkgPz8gZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RyYXBBY3RpdmVdKTtcclxuXHJcbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxyXG4gICAgICogY2hhbmdlIGZvY3VzIHRvIHNvbWV0aGluZyBlbHNlIChzb21ldGhpbmcgaW5cclxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxyXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxyXG4gICAgICovXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KCkpO1xyXG4gICAgfSwgW3RyYXBBY3RpdmVdKTtcclxuXHJcbiAgICBjb25zdCB1c2VGb2N1c1RyYXBQcm9wcyA9ICgocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcDEgPSB1c2VBY3RpdmVFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IHAyID0geyBcImFyaWEtbW9kYWxcIjogdHJhcEFjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHAxLCBwMik7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VGb2N1c1RyYXBQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSwgb3IgbnVsbCBpZiBub25lIGFyZSBmb3VuZC5cclxuICogQHBhcmFtIGVsZW1lbnQgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50OiBOb2RlKSB7XHJcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSlcclxuICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSB8IG51bGw7XHJcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCwgd2hlbiBjYWxsZWQsIGZvcmNlIHRoZSBjb21wb25lbnRcbiAqIHRoYXQgdXNlcyB0aGlzIGhvb2sgdG8gcmUtcmVuZGVyIGl0c2VsZi5cbiAqIFxuICogSXQncyBhIGJpdCBzbWVsbHksIHNvIGJlc3QgdG8gdXNlIHNwYXJpbmdseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgICByZXR1cm4gdXNlUmVmKCgpID0+IHNldChpID0+ICsraSkpLmN1cnJlbnQ7XG59IiwiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAqL1xyXG4gICAgb25Gb2N1c2VkQ2hhbmdlZD8oZm9jdXNlZDogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGBmb2N1c2VkYCwgYnV0IGFsc28gKmFkZGl0aW9uYWxseSogaWYgYW55IGNoaWxkIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIHNldEZvY3VzZWRcclxuICAgICAqL1xyXG4gICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbWlsYXIgdG8gYHNldEZvY3VzZWRgLCBidXQgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgaXMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCB0aGF0ICpkaWQqIGhhdmUgZm9jdXMgbGFzdC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoaWxlIGBmb2N1c2VkYCBpcyBgdHJ1ZWAuIElmIGBmb2N1c2VkYCBpcyBgZmFsc2VgLCB0aGlzIG1heSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZXMgdGhlIGltcGxpY2F0aW9ucyBvZiBgc2V0TGFzdEZvY3VzZWRgIGFuZCBgc2V0Rm9jdXNlZElubmVyYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8oZm9jdXNlZDogYm9vbGVhbik6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlSGFzRm9jdXNSZXR1cm5UeXBlPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+LCBPbWl0PFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQ+LCBcInVzZUFjdGl2ZUVsZW1lbnRQcm9wc1wiPiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNb2RpZmllcyB0aGUgZWxlbWVudCB0byBiZSBhYmxlIHRvIHRyYWNrIGl0cyBvd24gZm9jdXMgc3RhdGVcclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICB1c2VIYXNGb2N1c1Byb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxuXHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRGb2N1c2VkKCk6IGJvb2xlYW47XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkKCk6IGJvb2xlYW47XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRMYXN0Rm9jdXNlZElubmVyKCk6IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VIYXNGb2N1czxUIGV4dGVuZHMgTm9kZT4oeyBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSB9OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNGb2N1c1JldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRJbm5lckNoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0QWN0aXZlRWxlbWVudCwgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIGdldFdpbmRvd0ZvY3VzZWQsIHVzZUFjdGl2ZUVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudDxUPih7XHJcbiAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyczxUPltcIm9uQWN0aXZlRWxlbWVudENoYW5nZVwiXT4+KChhY3RpdmVFbGVtZW50LCBwcmV2QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBhY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRJbm5lciA9ICghIXNlbGZFbGVtZW50Py5jb250YWlucyhhY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldEZvY3VzZWRJbm5lcihmb2N1c2VkSW5uZXIpO1xyXG4gICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/LihhY3RpdmVFbGVtZW50LCBwcmV2QWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfSwgW10pLFxyXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE5vbk51bGxhYmxlPFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25MYXN0QWN0aXZlRWxlbWVudENoYW5nZVwiXT4+KChsYXN0QWN0aXZlRWxlbWVudCwgcHJldkxhc3RBY3RpdmVFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZFbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkID0gKHNlbGZFbGVtZW50ICE9IG51bGwgJiYgKHNlbGZFbGVtZW50ID09IGxhc3RBY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWRJbm5lciA9ICghIXNlbGZFbGVtZW50Py5jb250YWlucyhsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRMYXN0Rm9jdXNlZChmb2N1c2VkKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWRJbm5lcihmb2N1c2VkSW5uZXIpO1xyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPy4obGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfSwgW10pLFxyXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlSGFzRm9jdXNQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IHsgcmV0dXJuIHVzZUFjdGl2ZUVsZW1lbnRQcm9wcyhwcm9wcyk7IH0sIFtdKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHsgXHJcbiAgICAgICAgdXNlSGFzRm9jdXNQcm9wcywgXHJcbiAgICAgICAgZ2V0RWxlbWVudCwgXHJcbiAgICAgICAgZ2V0Rm9jdXNlZCwgXHJcbiAgICAgICAgZ2V0Rm9jdXNlZElubmVyLCBcclxuICAgICAgICBnZXRMYXN0Rm9jdXNlZCwgXHJcbiAgICAgICAgZ2V0TGFzdEZvY3VzZWRJbm5lciwgXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudCwgXHJcbiAgICAgICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIFxyXG4gICAgICAgIGdldFdpbmRvd0ZvY3VzZWQgXHJcbiAgICB9O1xyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBFbGVtZW50U2l6ZSwgdXNlRWxlbWVudFNpemUgfSBmcm9tIFwiLi91c2UtZWxlbWVudC1zaXplXCI7XHJcbmltcG9ydCB7IHJldHVybk51bGwsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuLy9leHBvcnQgdHlwZSBCbG9ja0Zsb3dEaXJlY3Rpb24gPSBcImRvd253YXJkc1wiIHwgXCJsZWZ0d2FyZHNcIiB8IFwicmlnaHR3YXJkc1wiO1xyXG5leHBvcnQgdHlwZSBQaHlzaWNhbERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiIHwgXCJ0dGJcIiB8IFwiYnR0XCI7XHJcbmV4cG9ydCB0eXBlIFBoeXNpY2FsT3JpZW50YXRpb24gPSBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcclxuZXhwb3J0IHR5cGUgUGh5c2ljYWxTaXplID0gXCJ3aWR0aFwiIHwgXCJoZWlnaHRcIjtcclxuXHJcbmV4cG9ydCB0eXBlIExvZ2ljYWxPcmllbnRhdGlvbiA9IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XHJcblxyXG4vL2V4cG9ydCB0eXBlIExpbmVPcmllbnRhdGlvbiA9IFwidXByaWdodFwiIHwgXCJsZWZ0cmlnaHRcIiB8IFwiZG93bnJpZ2h0XCIgfCBcInJpZ2h0cmlnaHRcIjtcclxuXHJcbnR5cGUgV3JpdGluZ01vZGUgPSBcImhvcml6b250YWwtdGJcIiB8IFwidmVydGljYWwtbHJcIiB8IFwic2lkZXdheXMtcmxcIiB8IFwidmVydGljYWwtcmxcIiB8IFwic2lkZXdheXMtbHJcIjtcclxudHlwZSBEaXJlY3Rpb24gPSBcImx0clwiIHwgXCJydGxcIjtcclxudHlwZSBUZXh0T3JpZW50YXRpb24gPSBcIm1peGVkXCIgfCBcInVwcmlnaHRcIiB8IFwic2lkZXdheXNcIjtcclxuXHJcbmZ1bmN0aW9uIGNhcGl0YWxpemU8VCBleHRlbmRzIHN0cmluZz4oc3RyOiBUKTogQ2FwaXRhbGl6ZTxUPiB7XHJcbiAgICByZXR1cm4gKHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKSkgYXMgQ2FwaXRhbGl6ZTxUPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyB7XHJcbiAgICBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2U/KGluZm86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCk6IHZvaWQ7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9naWNhbEVsZW1lbnRTaXplIHtcclxuICAgIGNsaWVudElubGluZVNpemU6IG51bWJlcjtcclxuICAgIHNjcm9sbElubGluZVNpemU6IG51bWJlcjtcclxuICAgIG9mZnNldElubGluZVNpemU6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNsaWVudEJsb2NrU2l6ZTogbnVtYmVyO1xyXG4gICAgc2Nyb2xsQmxvY2tTaXplOiBudW1iZXI7XHJcbiAgICBvZmZzZXRCbG9ja1NpemU6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNsaWVudElubGluZUluc2V0OiBudW1iZXI7XHJcbiAgICBzY3JvbGxJbmxpbmVJbnNldDogbnVtYmVyO1xyXG4gICAgb2Zmc2V0SW5saW5lSW5zZXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxuICAgIGNsaWVudEJsb2NrSW5zZXQ6IG51bWJlcjtcclxuICAgIHNjcm9sbEJsb2NrSW5zZXQ6IG51bWJlcjtcclxuICAgIG9mZnNldEJsb2NrSW5zZXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluc3BlY3RzIHRoZSBlbGVtZW50J3Mgc3R5bGUgYW5kIGRldGVybWluZXMgdGhlIGxvZ2ljYWwgZGlyZWN0aW9uIHRoYXQgdGV4dCBmbG93cy5cclxuICogXHJcbiAqIENlcnRhaW4gQ1NTIHByb3BlcnRpZXMsIGxpa2UgYGJsb2NrLXNpemVgLCByZXNwZWN0IHRoZSBjdXJyZW50IHdyaXRpbmcgbW9kZSBhbmQgdGV4dCBkaXJlY3Rpb24uXHJcbiAqIEJ1dCBgdHJhbnNmb3JtYCwgYGNsaXBgLCBldGMuIGRvbid0LlxyXG4gKiBcclxuICogVGhpcyBpcyBwcm92aWRlZCBzbyB0aGF0IENTUyBwcm9wZXJ0aWVzIGNhbiBjb25zaXN0ZW50bHkgdXNlIHRob3NlIGxvZ2ljYWwgcHJvcGVydGllcy5cclxuICogXHJcbiAqIFNlZSBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLXdyaXRpbmctbW9kZXMvI2xvZ2ljYWwtdG8tcGh5c2ljYWxcclxuICogXHJcbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxyXG4gKiAqIGBnZXRMb2dpY2FsRGlyZWN0aW9uYDogcmV0cmlldmVzIGEgYExvZ2ljYWxEaXJlY3Rpb25JbmZvYCByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGVsZW1lbnQuIChGdW5jdGlvbiBpcyBjb25zdGFudCBiZXR3ZWVuIHJlbmRlcnMpXHJcbiAqICogYGNvbnZlcnRFbGVtZW50U2l6ZWA6IFdoZW4gdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VFbGVtZW50U2l6ZWAsIGFsbG93cyB5b3UgdG8gcmV0cmlldmUgdGhlIGxvZ2ljYWwgc2l6ZSBvZiBhbiBlbGVtZW50IGluc3RlYWQgb2YgdGhlIHBoeXNpY2FsIHNpemUuIFxyXG4gKiAqIGBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb25gOiBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIiB0byBcImlubGluZVwiIG9yIFwiYmxvY2tcIi5cclxuICogKiBgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbmA6ICBCYXNlZCBvbiB0aGUgY3VycmVudCBkaXJlY3Rpb24sIGNvbnZlcnRzIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiIHRvIFwiaG9yaXpvbnRhbFwiIG9yIFwidmVydGljYWxcIi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2dpY2FsRGlyZWN0aW9uPFQgZXh0ZW5kcyBFbGVtZW50Pih7IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSB9OiBVc2VMb2dpY2FsRGlyZWN0aW9uUGFyYW1ldGVycyk6IFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQ+IHtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VMb2dpY2FsRGlyZWN0aW9uXCIsIG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSk7XHJcblxyXG4gICAgY29uc3QgW2dldENvbXB1dGVkU3R5bGVzLCBzZXRDb21wdXRlZFN0eWxlc10gPSB1c2VQYXNzaXZlU3RhdGU8Q1NTU3R5bGVEZWNsYXJhdGlvbiB8IG51bGw+KG51bGwsIHJldHVybk51bGwpO1xyXG5cclxuXHJcbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHVzZVJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxUPih7XHJcbiAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZWxlbWVudDogVCB8IG51bGwpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHNldENvbXB1dGVkU3R5bGVzKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKVxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gcmVmcmVzaCB3aGljaCB3cml0aW5nIG1vZGUgd2UgaGF2ZSBvbmNlIG1vdW50ZWQuXHJcbiAgICAvLyAgIEEuIFRoZXJlJ3Mgbm8gd2F5IHRvIHdhdGNoIGZvciBDU1Mgc3R5bGUgY2hhbmdlc1xyXG4gICAgLy8gICBCLiBDYWxsaW5nIGdldENvbXB1dGVkU3R5bGUgYWZ0ZXIgZXZlcnkgcmVuZGVyIGZvciBldmVyeSBlbGVtZW50IGdldHMgZXhwZW5zaXZlIGZhc3QgYW5kXHJcbiAgICAvLyAgIEMuIElzIG5vdCBuZWNlc3NhcnkgZm9yIG1vc3QgdXNlIGNhc2VzIHRoYXQgd2lsbCBuZXZlciBzd2l0Y2ggd3JpdGluZy1tb2RlIHdpdGhpbiBhIHNpbmdsZSBjb21wb25lbnRcclxuICAgIC8vICAgICAgKFRob3NlIHRoYXQgZG8gd2lsbCBuZWVkIHRvIG1vdW50IGFuZCB1bm1vdW50IHRoZSBjb21wb25lbnQgdGhhdCB1c2VzIGl0KVxyXG4gICAgLy9cclxuICAgIC8vIEFzIGEgc29sdXRpb24sIGhlcmUncyBhIGNoZWFwIHdvcmthcm91bmQgdGhhdCBjaGVja3Mgd2hlbiB0aGUgZWxlbWVudCdzIHNpemUgaGFzIGNoYW5nZWQsXHJcbiAgICAvLyBhbmQgaWYgc28sIHRlc3RzIGlmIHRoZSB3cml0aW5nIG1vZGUgaGFzIGNoYW5nZWQgdG9vLlxyXG4gICAgLy9cclxuICAgIC8vIFRoaXMgd2lsbCB3b3JrIGZvciBhdCBsZWFzdCBzb21lIG51bWJlciBvZiBjYXNlcywgYnV0IGEgYmV0dGVyIHNvbHV0aW9uIGlzIHN0aWxsIG5lZWRlZC5cclxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcyB9ID0gdXNlRWxlbWVudFNpemU8VD4oeyBvblNpemVDaGFuZ2U6IHVzZUNhbGxiYWNrKF8gPT4gb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPy4oZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKSksIFtdKSB9KVxyXG5cclxuICAgIGNvbnN0IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbXB1dGVkU3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZXMoKTtcclxuICAgICAgICBpZiAoY29tcHV0ZWRTdHlsZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgdyA9IGNvbXB1dGVkU3R5bGVzLndyaXRpbmdNb2RlIGFzIFdyaXRpbmdNb2RlO1xyXG4gICAgICAgICAgICBsZXQgZCA9IGNvbXB1dGVkU3R5bGVzLmRpcmVjdGlvbiBhcyBEaXJlY3Rpb247XHJcbiAgICAgICAgICAgIGNvbnN0IHQgPSBjb21wdXRlZFN0eWxlcy50ZXh0T3JpZW50YXRpb24gYXMgVGV4dE9yaWVudGF0aW9uO1xyXG5cclxuICAgICAgICAgICAgaWYgKHQgPT0gXCJ1cHJpZ2h0XCIpXHJcbiAgICAgICAgICAgICAgICBkID0gXCJsdHJcIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoeyAuLi5Xcml0aW5nTW9kZXNbdyB8fCBcImhvcml6b250YWwtdGJcIl1bZCB8fCBcImx0clwiXSB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSwgW10pXHJcblxyXG4gICAgLy9jb25zdCBbZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHNldExvZ2ljYWxEaXJlY3Rpb25JbmZvXSA9IHVzZVBhc3NpdmVTdGF0ZTxMb2dpY2FsRGlyZWN0aW9uSW5mbz4ob25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IGVsZW1lbnRPcmllbnRhdGlvbilcclxuICAgICAgICAgICAgcmV0dXJuIFwiaW5saW5lXCI7XHJcbiAgICAgICAgcmV0dXJuIFwiYmxvY2tcIjtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjb252ZXJ0VG9QaHlzaWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiA9PiB7XHJcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG5cclxuICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLXN0YXJ0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVswXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1lbmRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmJsb2NrRGlyZWN0aW9uID8/IFwidHRiXCIpWzJdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcclxuXHJcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtc3RhcnRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmlubGluZURpcmVjdGlvbiA/PyBcImx0clwiKVswXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XHJcbiAgICAgICAgICAgIGNhc2UgXCJpbmxpbmUtZW5kXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5pbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxTaWRlID0gdXNlQ2FsbGJhY2soKHNpZGU6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcInR0YlwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcInJ0bFwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcInR0YlwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcImJ0dFwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcImx0clwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgZGVidWdnZXI7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoZmFsc2UpO1xyXG4gICAgICAgIHJldHVybiBcImlubGluZS1zdGFydFwiO1xyXG5cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24gPSB1c2VDYWxsYmFjaygoZWxlbWVudE9yaWVudGF0aW9uOiBMb2dpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcclxuICAgICAgICBpZiAoZWxlbWVudE9yaWVudGF0aW9uID09IFwiaW5saW5lXCIpIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT0gXCJob3Jpem9udGFsXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XHJcbiAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5ibG9ja09yaWVudGF0aW9uID09IFwidmVydGljYWxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcInZlcnRpY2FsXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gXCJob3Jpem9udGFsXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNvbnZlcnRFbGVtZW50U2l6ZSA9IHVzZUNhbGxiYWNrKChlbGVtZW50U2l6ZTogRWxlbWVudFNpemUsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IExvZ2ljYWxFbGVtZW50U2l6ZSB8IG51bGwgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgaW5saW5lU2l6ZSwgYmxvY2tTaXplLCBpbmxpbmVEaXJlY3Rpb24sIGJsb2NrRGlyZWN0aW9uIH0gPSBkaXJlY3Rpb247XHJcblxyXG4gICAgICAgICAgICAvLyBTaXplIGlzIHJlbGF0aXZlbHkgc2ltcGxlXHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tTaXplID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsSW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcclxuXHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGYxID0gZ2V0UGh5c2ljYWxMZWZ0VG9wKGlubGluZURpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGYyID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShpbmxpbmVEaXJlY3Rpb24pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZjMgPSBnZXRQaHlzaWNhbExlZnRUb3AoYmxvY2tEaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBmNCA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oYmxvY2tEaXJlY3Rpb24pO1xyXG5cclxuXHJcbiAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xyXG4gICAgICAgICAgIGNvbnN0IHNjcm9sbElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjIpfWBdKTtcclxuICAgICAgICAgICBjb25zdCBvZmZzZXRJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjEpfWBdID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IChlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYxKX1gXSEgKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjIpfWBdISkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjQpfWBdKTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjMpfWBdID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IChlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSEgKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjQpfWBdISkpO1xyXG5cclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBjbGllbnRJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lU2l6ZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZVNpemUsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRCbG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja1NpemUsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZUluc2V0LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBjbGllbnRCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tJbnNldCxcclxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrSW5zZXQsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gdXNlUmVmRWxlbWVudFByb3BzKHVzZUVsZW1lbnRTaXplUHJvcHMocHJvcHMpKSwgW10pLFxyXG4gICAgICAgIGdldEVsZW1lbnQsXHJcbiAgICAgICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sXHJcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpemU6IGNvbnZlcnRFbGVtZW50U2l6ZSxcclxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb24sXHJcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbixcclxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZSxcclxuICAgICAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGVcclxuICAgIH07XHJcbn1cclxuXHJcbi8vIFBvc2l0aW9uIHJlcXVpcmVzIHVzIHRvIHNvbWV0aW1lcyB1c2Ugb25lIHByb3BlcnR5IChsaWtlIGBsZWZ0YClcclxuLy8gb3Igc29tZXRpbWVzIHR3byAobGlrZSBgbGVmdGAgKyBgd2lkdGhgKVxyXG5mdW5jdGlvbiBnZXRQaHlzaWNhbExlZnRUb3AoZGlyOiBQaHlzaWNhbERpcmVjdGlvbikgeyBpZiAoZGlyID09PSBcImx0clwiIHx8IGRpciA9PSBcInJ0bFwiKSByZXR1cm4gXCJsZWZ0XCI7IHJldHVybiBcInRvcFwiOyB9XHJcbmZ1bmN0aW9uIGdldFBoeXNpY2FsUmlnaHRCb3R0b20oZGlyOiBQaHlzaWNhbERpcmVjdGlvbikgeyBpZiAoZGlyID09PSBcInJ0bFwiKSByZXR1cm4gXCJ3aWR0aFwiOyBpZiAoZGlyID09PSBcImJ0dFwiKSByZXR1cm4gXCJoZWlnaHRcIjsgcmV0dXJuIG51bGw7IH1cclxuXHJcbi8vIEhlbHBlciBmb3IgZXh0cmFjdGluZyBpbmZvIGZyb20gXCJsdHJcIiwgXCJ0dGJcIiwgZXRjLlxyXG5jb25zdCBNID0ge1xyXG4gICAgdDogXCJ0b3BcIixcclxuICAgIGI6IFwiYm90dG9tXCIsXHJcbiAgICBsOiBcImxlZnRcIixcclxuICAgIHI6IFwicmlnaHRcIlxyXG59IGFzIGNvbnN0O1xyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9naWNhbERpcmVjdGlvblJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTG9naWNhbERpcmVjdGlvblByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRFbGVtZW50OiAoKSA9PiBUIHwgbnVsbDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbzogKCkgPT4gTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gdGhlIEVsZW1lbnRTaXplIGluZm8gZnJvbSB1c2VFbGVtZW50U2l6ZSwgY29udmVydHMgYWxsIHRob3NlIHBoeXNpY2FsIHByb3BlcnRpZXMgdG8gdGhlaXIgbG9naWNhbCBjb3VudGVycGFydHMuXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgY29udmVydFRvTG9naWNhbFNpemU6IChlbGVtZW50U2l6ZTogRWxlbWVudFNpemUsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm5zIGBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcImAgaW50byBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImBcclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Mb2dpY2FsT3JpZW50YXRpb246IChlbGVtZW50T3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJpbmxpbmVcIiB8IFwiYmxvY2tcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm5zIGBcImlubGluZVwiIHwgXCJibG9ja1wiYCBpbnRvIGBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcImBcclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBMb2dpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJucyBgXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcImAgaW50byBgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiB8IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcImBcclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Mb2dpY2FsU2lkZTogKHNpZGU6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm5zIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYCBpbnRvIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYFxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1BoeXNpY2FsU2lkZTogKHNpZGU6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4gXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIjtcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxEaXJlY3Rpb25JbmZvIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyB0aGUgZGlyZWN0aW9uIHRleHQgZmxvd3MsIGdseXBoIGJ5IGdseXBoLiAgQnkgZmFyIHRoZSBtb3N0IGNvbXBsZXggcHJvcGVydHkuXHJcbiAgICAgKiBcclxuICAgICAqIHxgd3JpdGluZy1tb2RlYHxgZGlyZWN0aW9uYHxSZXN1bHR8XHJcbiAgICAgKiB8LS0tLS18LS0tLS18LS0tLS18XHJcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBsdHJgfGBsdHJgfFxyXG4gICAgICogfGBob3Jpem9udGFsLXRiYHxgcnRsYHxgcnRsYHxcclxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgbHRyYHxgdHRiYHxcclxuICAgICAqIHxgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYHxgcnRsYHxgYnR0YHxcclxuICAgICAqIHxgdmVydGljYWwtbHJgfGBsdHJgfGB0dGJgfFxyXG4gICAgICogfGB2ZXJ0aWNhbC1scmB8YHJ0bGB8YGJ0dGB8XHJcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgbHRyYHxgYnR0YHxcclxuICAgICAqIHxgc2lkZXdheXMtbHJgfGBydGxgfGB0dGJgfFxyXG4gICAgICovXHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBpbmxpbmVEaXJlY3Rpb25gOlxyXG4gICAgICogXHJcbiAgICAgKiAqIGBob3Jpem9udGFsYCBmb3IgYGhvcml6b250YWwtdGJgXHJcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGFsbCBvdGhlcnNcclxuICAgICAqL1xyXG4gICAgaW5saW5lT3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgbGluZSBieSBsaW5lLlxyXG4gICAgICogXHJcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXHJcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgICYgYHNpZGV3YXlzLXJsYCwgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb25cclxuICAgICAqICogYGx0cmAgZm9yIGB2ZXJ0aWNhbC1scmAgJiBgc2lkZXdheXMtbHJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBibG9ja0RpcmVjdGlvbjogUGh5c2ljYWxEaXJlY3Rpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGlmaWVkIHZlcnNpb24gb2YgYGJsb2NrRGlyZWN0aW9uYDpcclxuICAgICAqIFxyXG4gICAgICogKiBgdmVydGljYWxgIGZvciBgaG9yaXpvbnRhbC10YmBcclxuICAgICAqICogYGhvcml6b250YWxgIGZvciBhbGwgb3RoZXJzXHJcbiAgICAgKi9cclxuICAgIGJsb2NrT3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGhvdyB5b3UgY2FuICpwaHlzaWNhbGx5KiByZWZlciB0byB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCBpbiB0aGUgKmlubGluZSogc2l6ZS5cclxuICAgICAqIFxyXG4gICAgICogKiBgd2lkdGhgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXHJcbiAgICAgKiAqIGBoZWlnaHRgIGZvciBhbGwgb3RoZXJzXHJcbiAgICAgKi9cclxuICAgIGlubGluZVNpemU6IFBoeXNpY2FsU2l6ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqYmxvY2sqIHNpemUuXHJcbiAgICAgKiBcclxuICAgICAqICogYGhlaWdodGAgZm9yIGBob3Jpem9udGFsLXRiYCwgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb25cclxuICAgICAqICogYHdpZHRoYCBmb3IgYWxsIG90aGVyc1xyXG4gICAgICovXHJcbiAgICBibG9ja1NpemU6IFBoeXNpY2FsU2l6ZTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGdseXBoLCBhc2NlbmRlcnMgdG8gZGVzY2VuZGVycyAqcGh5c2ljYWxseSogZ286XHJcbiAgICAgKiBcclxuICAgICAqICogYHR0YmAgZm9yIGBob3Jpem9udGFsLXRiYFxyXG4gICAgICogKiBgcnRsYCBmb3IgYHZlcnRpY2FsLXJsYCwgYHZlcnRpY2FsLWxyYCwgJiBgc2lkZXdheXMtcmxgXHJcbiAgICAgKiAqIGBsdHJgIGZvciBgc2lkZXdheXMtbHJgXHJcbiAgICAgKi9cclxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogUGh5c2ljYWxEaXJlY3Rpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBnbHlwaCwgaXRzIFwibGVmdFwiIHNpZGUgKHRoaW5rIG9mIHRoaXMgcmVsYXRpdmUgdG8gYHdyaXRpbmctbW9kZWAgYnV0ICpub3QqIHJlbGF0aXZlIHRvIGBkaXJlY3Rpb25gLCBvciBhbHRlcm5hdGl2ZWx5IHdoYXQgYHRleHQtYWxpZ246IGxlZnRgIG1lYW5zKSB0byBpdHMgXCJyaWdodFwiIHNpZGUgKnBoeXNpY2FsbHkqIGdvZXMgZnJvbTpcclxuICAgICAqIFxyXG4gICAgICogKiBgbHRyYCBmb3IgYGhvcml6b250YWwtdGJgXHJcbiAgICAgKiAqIGB0dGJgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcclxuICAgICAqICogYGJ0dGAgZm9yIGBzaWRld2F5cy1scmBcclxuICAgICAqL1xyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcclxufVxyXG5cclxuY29uc3QgSG9yaXpvbnRhbFRiTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJsdHJcIixcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInR0YlwiLFxyXG5cclxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcclxuICAgIGJsb2NrT3JpZW50YXRpb246IFwidmVydGljYWxcIixcclxuXHJcbiAgICBpbmxpbmVTaXplOiBcIndpZHRoXCIsXHJcbiAgICBibG9ja1NpemU6IFwiaGVpZ2h0XCIsXHJcblxyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImx0clwiLFxyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInR0YlwiXHJcbn07XHJcblxyXG5jb25zdCBIb3Jpem9udGFsVGJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgLi4uSG9yaXpvbnRhbFRiTHRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInJ0bFwiLFxyXG59O1xyXG5cclxuY29uc3QgVmVydGljYWxSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwidHRiXCIsXHJcbiAgICBibG9ja0RpcmVjdGlvbjogXCJydGxcIixcclxuXHJcbiAgICBpbmxpbmVPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxyXG4gICAgYmxvY2tPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXHJcblxyXG4gICAgaW5saW5lU2l6ZTogXCJoZWlnaHRcIixcclxuICAgIGJsb2NrU2l6ZTogXCJ3aWR0aFwiLFxyXG5cclxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJ0dGJcIixcclxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJydGxcIlxyXG59O1xyXG5cclxuY29uc3QgVmVydGljYWxSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImJ0dFwiXHJcbn07XHJcblxyXG5cclxuY29uc3QgU2lkZXdheXNSbEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxMdHIgfTtcclxuY29uc3QgU2lkZXdheXNSbFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7IC4uLlZlcnRpY2FsUmxSdGwgfTtcclxuXHJcbmNvbnN0IFZlcnRpY2FsTHJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgLi4uVmVydGljYWxSbEx0cixcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcImx0clwiLFxyXG59O1xyXG5cclxuY29uc3QgVmVydGljYWxMclJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICAuLi5WZXJ0aWNhbFJsUnRsLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXHJcbn07XHJcblxyXG5jb25zdCBTaWRld2F5c0x0THRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIC4uLlZlcnRpY2FsTHJMdHIsXHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwiYnR0XCIsXHJcblxyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcImJ0dFwiLFxyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcImx0clwiXHJcbn07XHJcblxyXG5jb25zdCBTaWRld2F5c0x0UnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIC4uLlNpZGV3YXlzTHRMdHIsXHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwidHRiXCJcclxufTtcclxuXHJcblxyXG5cclxuY29uc3QgSG9yaXpvbnRhbFRiID0ge1xyXG4gICAgbHRyOiBIb3Jpem9udGFsVGJMdHIsXHJcbiAgICBydGw6IEhvcml6b250YWxUYlJ0bFxyXG59IGFzIGNvbnN0O1xyXG5cclxuY29uc3QgVmVydGljYWxSbCA9IHtcclxuICAgIGx0cjogVmVydGljYWxSbEx0cixcclxuICAgIHJ0bDogVmVydGljYWxSbFJ0bFxyXG59IGFzIGNvbnN0O1xyXG5cclxuY29uc3QgVmVydGljYWxMciA9IHtcclxuICAgIGx0cjogVmVydGljYWxMckx0cixcclxuICAgIHJ0bDogVmVydGljYWxMclJ0bFxyXG59IGFzIGNvbnN0O1xyXG5cclxuY29uc3QgU2lkZXdheXNSbCA9IHtcclxuICAgIGx0cjogU2lkZXdheXNSbEx0cixcclxuICAgIHJ0bDogU2lkZXdheXNSbFJ0bFxyXG59IGFzIGNvbnN0O1xyXG5cclxuY29uc3QgU2lkZXdheXNMciA9IHtcclxuICAgIGx0cjogU2lkZXdheXNMdEx0cixcclxuICAgIHJ0bDogU2lkZXdheXNMdFJ0bFxyXG59IGFzIGNvbnN0O1xyXG5cclxuY29uc3QgV3JpdGluZ01vZGVzID0ge1xyXG4gICAgXCJob3Jpem9udGFsLXRiXCI6IEhvcml6b250YWxUYixcclxuICAgIFwidmVydGljYWwtbHJcIjogVmVydGljYWxMcixcclxuICAgIFwidmVydGljYWwtcmxcIjogVmVydGljYWxSbCxcclxuICAgIFwic2lkZXdheXMtbHJcIjogU2lkZXdheXNMcixcclxuICAgIFwic2lkZXdheXMtcmxcIjogU2lkZXdheXNSbFxyXG59IGFzIGNvbnN0O1xyXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGltZW91dCB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtcyB0byB3YWl0IGJlZm9yZSBpbnZva2luZyBgY2FsbGJhY2tgLiAgXG4gICAgICogSWYgYG51bGxgLCBjYW5jZWxzIHRoZSB0aW1lb3V0IGltbWVkaWF0ZWx5LlxuICAgICAqL1xuICAgIHRpbWVvdXQ6IG51bWJlciB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2VzIHRvIHRoaXMgcHJvcCBiZXR3ZWVuIHJlbmRlcnMgY2FuIGJlIHVzZWQgdG8gY2xlYXIgdGhlIGN1cnJlbnQgdGltZW91dCBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKi9cbiAgICB0cmlnZ2VySW5kZXg/OiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGB0aW1lb3V0YCBtcyBhZnRlciBtb3VudCwgb3IgdGhlIGxhc3QgY2hhbmdlIHRvIGB0cmlnZ2VySW5kZXhgLlxuICAgICAqIFxuICAgICAqIERvZXMgKm5vdCogbmVlZCB0byBiZSBzdGFibGUuIEdvIGFoZWFkIGFuZCBwYXNzIGFuIGFub255bW91cyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRpbWVvdXQoeyB0aW1lb3V0LCBjYWxsYmFjaywgdHJpZ2dlckluZGV4IH06IFVzZVRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHsgc3RhcnRUaW1lUmVmLmN1cnJlbnQgPSBudWxsOyBjYWxsYmFjaygpOyB9KTtcbiAgICBjb25zdCBnZXRUaW1lb3V0ID0gdXNlU3RhYmxlR2V0dGVyKHRpbWVvdXQpO1xuXG4gICAgLy8gU2V0IGFueSB0aW1lIHdlIHN0YXJ0IHRpbWVvdXQuXG4gICAgLy8gVW5zZXQgYW55IHRpbWUgdGhlIHRpbWVvdXQgY29tcGxldGVzXG4gICAgY29uc3Qgc3RhcnRUaW1lUmVmID0gdXNlUmVmPG51bWJlciB8IG51bGw+KG51bGwpO1xuXG4gICAgY29uc3QgdGltZW91dElzTnVsbCA9ICh0aW1lb3V0ID09IG51bGwpO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRyaWdnZXJJbmRleCBjaGFuZ2VzIChpbmNsdWRpbmcgb24gbW91bnQpXG4gICAgLy8gcmVzdGFydCB0aGUgdGltZW91dC4gIFRoZSB0aW1lb3V0IGRvZXMgTk9UIHJlc2V0XG4gICAgLy8gd2hlbiB0aGUgZHVyYXRpb24gb3IgY2FsbGJhY2sgY2hhbmdlcywgb25seSB0cmlnZ2VySW5kZXguXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCF0aW1lb3V0SXNOdWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0VGltZW91dCgpO1xuICAgICAgICAgICAgY29uc29sZS5hc3NlcnQodGltZW91dElzTnVsbCA9PSAodGltZW91dCA9PSBudWxsKSk7XG4gICAgXG4gICAgICAgICAgICBpZiAodGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRUaW1lUmVmLmN1cnJlbnQgPSArKG5ldyBEYXRlKCkpO1xuICAgIFxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHNldFRpbWVvdXQoc3RhYmxlQ2FsbGJhY2ssIHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LCBbdHJpZ2dlckluZGV4LCB0aW1lb3V0SXNOdWxsXSlcblxuICAgIGNvbnN0IGdldEVsYXBzZWRUaW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCsobmV3IERhdGUoKSkpIC0gKCsoc3RhcnRUaW1lUmVmLmN1cnJlbnQgPz8gbmV3IERhdGUoKSkpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFJlbWFpbmluZ1RpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgIHJldHVybiB0aW1lb3V0ID09IG51bGwgPyBudWxsIDogTWF0aC5tYXgoMCwgdGltZW91dCAtIGdldEVsYXBzZWRUaW1lKCkpXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgZ2V0RWxhcHNlZFRpbWUsIGdldFJlbWFpbmluZ1RpbWUgfTtcbn1cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcclxuaW1wb3J0IHsgdXNlTG9naWNhbERpcmVjdGlvbiB9IGZyb20gXCIuL3VzZS1sb2dpY2FsLWRpcmVjdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwiLi91c2UtdGltZW91dFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgbGluZWFyTmF2aWdhdGlvbjoge31cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIC8qKiBcclxuICAgICAqIFRoZXNlIHByb3BzIGNhbiBiZSBhdHRhdGNoZWQgZWl0aGVyIHRvIHRoZSBwYXJlbnQgb3IgdG8gZWFjaCBpbmRpdmlkdWFsIGNoaWxkLlxyXG4gICAgICogV2hpY2hldmVyIHdvcmtzIGJldHRlciBmb3IgeW91ciBzY2VuYXJpby5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKiBcclxuICAgICAqICovXHJcbiAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XHJcbn1cclxuXHJcbmludGVyZmFjZSBMTlAge1xyXG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcclxuICAgIG5hdmlnYXRlVG9QcmV2KCk6IHZvaWQ7XHJcbiAgICBuYXZpZ2F0ZVRvRmlyc3QoKTogdm9pZDtcclxuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIENvbnRyb2xzIHdoaWNoIGFycm93IGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgY29tcG9uZW50LlxyXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSwgc28gaW4gRW5nbGlzaCwgXCJpbmxpbmVcIiBjb3JyZXNwb25kc1xyXG4gICAgICogdG8gdGhlIGxlZnQgJiByaWdodCBhcnJvdyBrZXlzLCBhbmQgXCJibG9ja1wiIHRvIHRoZSB1cCAmIGRvd24gYXJyb3cga2V5cy5cclxuICAgICAqIFxyXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBVc2UgXCJub25lXCIgdG8gZGlzYWxsb3cgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIGluIGFueSBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24/OiBcImlubGluZVwiIHwgXCJibG9ja1wiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxyXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXHJcbiAgICAgKiBiZSB1bmFmZmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXHJcbiAgICAgKiBiZSBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlXHJcbiAgICAgKiB1bmFmZmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXM/OiBib29sZWFuO1xyXG59XHJcbmV4cG9ydCB0eXBlIExpbmVhck5hdmlnYXRpb25PbWl0cyA9IGtleW9mIExOUDtcclxuXHJcbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHM+IHtcclxuICAgIGxpbmVhck5hdmlnYXRpb246IE9taXQ8TE5QLCBPbWl0cz5cclxufVxyXG5cclxuXHJcbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkYCAqL1xyXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cclxuXHJcbi8qKlxyXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcclxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0ZpcnN0OiBudGYsIG5hdmlnYXRlVG9MYXN0OiBudGwsIG5hdmlnYXRlVG9OZXh0OiBudG4sIG5hdmlnYXRlVG9QcmV2OiBudHAsIG5hdmlnYXRpb25EaXJlY3Rpb246IG5kLCBkaXNhYmxlQXJyb3dLZXlzOiBkYWssIGRpc2FibGVIb21lRW5kS2V5czogZGhlayB9IH06IFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyPik6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XHJcblxyXG4gICAgbmQgPz89IFwiZWl0aGVyXCI7XHJcblxyXG4gICAgY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbywgdXNlTG9naWNhbERpcmVjdGlvblByb3BzIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7fSk7XHJcblxyXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRmKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRsKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRuKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRwKTtcclxuICAgIGNvbnN0IGdldERpc2FibGVBcnJvd0tleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGFrKTtcclxuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihkaGVrKTtcclxuICAgIGNvbnN0IGdldE5hdmlnYXRpb25EaXJlY3Rpb24gPSB1c2VTdGFibGVHZXR0ZXIobmQpO1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmF2aWdhdGlvbkRpcmVjdGlvbiA9IGdldE5hdmlnYXRpb25EaXJlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBcnJvd0tleXMgPSBnZXREaXNhYmxlQXJyb3dLZXlzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlSG9tZUVuZEtleXMgPSBnZXREaXNhYmxlSG9tZUVuZEtleXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NCbG9ja05hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImJsb2NrXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c0lubGluZU5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImlubGluZVwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHModXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIHByb3BzKSlcclxuICAgICAgICB9LCBbXSksXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkOiBzdHJpbmcgfCBudWxsO1xyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSB1c2VkIG9uIGVpdGhlciB0aGUgcGFyZW50IG9yIGVhY2ggY2hpbGQgZWxlbWVudC5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD47XHJcblxyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcclxuXHJcbmludGVyZmFjZSBUTlAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbGxhdG9yIHRvIHVzZSB3aGVuIGNvbXBhcmluZy4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdXNlcyBgbG9jYWxlQ29tcGFyZWAgYWZ0ZXIgdHJhbnNmb3JtaW5nIGVhY2ggdG8gbG93ZXJjYXNlLCB3aGljaCB3aWxsLCBhdCBiZXN0LCB3b3JrIG9rYXkgaW4gRW5nbGlzaC5cclxuICAgICAqL1xyXG4gICAgY29sbGF0b3I/OiBJbnRsLkNvbGxhdG9yO1xyXG5cclxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcclxuXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0PzogbnVtYmVyO1xyXG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcclxuICAgIHNldEluZGV4KHZhbHVlOiBudW1iZXIgfCBudWxsIHwgKChwcmV2aW91c1ZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgVE5QO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cz4ge1xyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogT21pdDxUTlAsIE9taXRzPlxyXG59XHJcblxyXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZGAgKi9cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxyXG4gICAgICogSXQgc2hvdWxkIGJlIHRoZSBzYW1lIHRleHQgY29udGVudCBhcyB3aGF0ZXZlcidzIGRpc3BsYXllZCwgaWRlYWxseS5cclxuICAgICAqL1xyXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcclxuXHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG59XHJcblxyXG4vKiogVHlwZSBvZiB0aGUgY2hpbGQncyBzdWItaG9vayAqL1xyXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSAoYXJnczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycykgPT4gVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTtcclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGZvciB0aGUgc2VsZWN0aW9uIG9mIGEgbWFuYWdlZCBjaGlsZCBieSB0eXBpbmcgdGhlIGdpdmVuIHRleHQgYXNzb2NpYXRlZCB3aXRoIGl0LlxyXG4gKiBcclxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXgsIG5vVHlwZWFoZWFkIH0gfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcclxuXHJcblxyXG4gICAgLy8gRm9yIHR5cGVhaGVhZCwga2VlcCB0cmFjayBvZiB3aGF0IG91ciBjdXJyZW50IFwic2VhcmNoXCIgc3RyaW5nIGlzIChpZiB3ZSBoYXZlIG9uZSlcclxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxyXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxyXG4gICAgLy8gQW5kLCBmb3IgdGhlIHVzZXIncyBzYWtlLCBsZXQgdGhlbSBrbm93IHdoZW4gdGhlaXIgdHlwZWFoZWFkIGNhbid0IG1hdGNoIGFueXRoaW5nIGFueW1vcmVcclxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xyXG4gICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5mbyA9IHVzZVJlZjx7IHRleHQ6IHN0cmluZywgdW5zb3J0ZWRJbmRleDogbnVtYmVyIH1bXT4oW10pO1xyXG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXHJcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXHJcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHdhaXRpbmcgZm9yIGEgQ29tcG9zaXRpb25FbmQgZXZlbnRcclxuICAgIGNvbnN0IFssIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBCZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlICphZnRlcioga2V5ZG93biBldmVudHMgXHJcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxyXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cclxuICAgIGNvbnN0IFtuZXh0VHlwZWFoZWFkQ2hhciwgc2V0TmV4dFR5cGVhaGVhZENoYXJdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHR5cGVhaGVhZCA9PiAoKHR5cGVhaGVhZCA/PyBcIlwiKSArIG5leHRUeXBlYWhlYWRDaGFyKSk7XHJcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtuZXh0VHlwZWFoZWFkQ2hhcl0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBjb21wYXJhdG9yU2hhcmVkID0gdXNlU3RhYmxlQ2FsbGJhY2soKHNhZmVMaHM6IHN0cmluZywgc2FmZVJoczogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IGNvbXBhcmU6IG51bWJlcjtcclxuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXHJcbiAgICAgICAgLy8gQnkgbm9ybWFsaXppbmcgdGhlbSBmaXJzdCwgd2UgZW5zdXJlIHRoaXMgYnl0ZS1ieS1ieXRlIGhhbmRsaW5nIG9mIHJhdyBjaGFyYWN0ZXIgZGF0YSB3b3JrcyBvdXQgb2theS5cclxuICAgICAgICBzYWZlTGhzID0gc2FmZUxocy5ub3JtYWxpemUoXCJORkRcIik7XHJcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXHJcblxyXG4gICAgICAgIGlmIChjb2xsYXRvcilcclxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaW5zZXJ0aW5nQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdHlwZWFoZWFkQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcclxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5J3JlIGFsbCBjb25zaWRlcmVkIGVxdWFsbHkgYnkgdGhhdCBwb2ludC5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dC5zdWJzdHJpbmcoMCwgbGhzLmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gdXNlU3RhYmxlR2V0dGVyKG5vVHlwZWFoZWFkKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvblN0YXJ0ID0gKF9lOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKSB9O1xyXG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25FbmQgPSAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihlLmRhdGEpO1xyXG4gICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbWVBY3RpdmUgPSBnZXRJbWVBY3RpdmUoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xyXG5cclxuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXHJcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IHNwbGl0IFVURi0xNiBzdXJyb2dhdGVzLlxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0ID0+IHQgPT09IG51bGwgPyBudWxsIDogWy4uLnRdLnJldmVyc2UoKS5zbGljZSgxKS5yZXZlcnNlKCkuam9pbihcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUga2V5IHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHR5cGVkIGNoYXJhY3RlciBPUiB0aGUgXCJuYW1lZCBrZXkgYXR0cmlidXRlXCIgb2YgdGhlIGtleSBwcmVzc2VkLlxyXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gb25lLWNoYXJhY3RlciBuYW1lcywgYW5kIHRoZXJlIGFyZSBubyBub24tQVNDSUktYWxwaGEgbmFtZXMuXHJcbiAgICAgICAgICAgIC8vIFRodXMsIGFueSBvbmUtY2hhcmFjdGVyIG9yIG5vbi1BU0NJSSB2YWx1ZSBmb3IgYGtleWAgaXMgKmFsbW9zdCBjZXJ0YWlubHkqIGEgdHlwZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJLZXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYSB0eXBlYWhlYWQsIG9ubHkgY29udGludWUgb25lLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV29uJ3QgYmUgdHJ1ZSBmb3IgdGhlIGZpcnN0IGtleWRvd25cclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25FbmQsIH0sIHByb3BzKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgY2hhbmdlcyBpbiB0eXBlYWhlYWQgdGhhdCBjYXVzZSBjaGFuZ2VzIHRvIHRoZSB0YWJiYWJsZSBpbmRleFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgdHlwZWFoZWFkQ29tcGFyYXRvcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAvLyAob3IgbW9yZSBzcGVjaWZpY2FsbHkgXCJmb3Igd2hpY2ggdGhlcmUgaXMgbm8gZW50cnkgdGhhdCBzdGFydHMgd2l0aCB0aGF0IGlucHV0XCIpXHJcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cclxuICAgICAgICAgICAgICAgICAgQnV0IHJvdWdobHkgaXNuJ3QgZ29vZCBlbm91Z2ggaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMuXHJcbiAgICAgICAgICAgICAgICAgIFRvIGNvbnZlcnQgb3VyIHNvcnRlZCBpbmRleCB0byB0aGUgdW5zb3J0ZWQgaW5kZXggd2UgbmVlZCwgd2UgaGF2ZSB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBvbmx5IHdheSB0eXBlYWhlYWQgbW92ZXMgYmFja3dhcmRzIHJlbGF0aXZlIHRvIG91ciBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXHJcblxyXG4gICAgICAgICAgICAgICAgICBJdCdzIG5vdCBzcGVjaWZpZWQgaW4gV0FJLUFSSUEgd2hhdCB0byBkbyBpbiB0aGF0IGNhc2UuICBJIHN1cHBvc2Ugd3JhcCBiYWNrIHRvIHRoZSBzdGFydD9cclxuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cclxuICAgICAgICAgICAgICAgICAgQnV0IGlmIHlvdSdyZSBhbHJlYWR5IGRvaW5nIHR5cGVhaGVhZCBvbiBhbiB1bnNvcnRlZCBsaXN0LCBsaWtlLCBqdW1waW5lc3MgY2FuJ3QgYmUgYXZvaWRlZC5cclxuICAgICAgICAgICAgICAgICAgSSBkdW5uby4gR29pbmcgYmFjayB0byB0aGUgc3RhcnQgaXMgdGhlIHNpbXBsaXN0IHRob3VnaC5cclxuXHJcbiAgICAgICAgICAgICAgICAgIEJhc2ljYWxseSB3aGF0IHRoaXMgZG9lczogU3RhcnRpbmcgZnJvbSB3aGVyZSB3ZSBmb3VuZCBvdXJzZWx2ZXMgYWZ0ZXIgb3VyIGJpbmFyeSBzZWFyY2gsXHJcbiAgICAgICAgICAgICAgICAgIHNjYW4gYmFja3dhcmRzIGFuZCBmb3J3YXJkcyB0aHJvdWdoIGFsbCBhZGphY2VudCBlbnRyaWVzIHRoYXQgYWxzbyBjb21wYXJlIGVxdWFsbHkgc28gdGhhdFxyXG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgKGFuZCBhbHNvIHRoZSBsb3dlc3QgYHVuc29ydGVkSW5kZXhgIHlhZGRhIHlhZGRhIGV4Y2VwdCB0aGF0IGl0IGNvbWVzIGFmdGVyIHVzKS5cclxuXHJcbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxyXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZSBcclxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW4gXHJcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXHJcbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCZXN0Rml0ID0gKHU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRUeXBlYWhlYWRdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ+KCh7IGluZGV4LCB0ZXh0IH0pID0+IHtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIGluc2VydCB0aGlzIGl0ZW0uXHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGFsbCBpbmRleCB2YWx1ZXMgc2hvdWxkIGJlIHVuaXF1ZSwgdGhlIHJldHVybmVkIHNvcnRlZEluZGV4XHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5tb3VudGluZywgZmluZCB3aGVyZSB3ZSB3ZXJlIGFuZCByZW1vdmUgb3Vyc2VsdmVzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0ZXh0XSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxyXG5cclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cclxuICogXHJcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcclxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxyXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuIFxyXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQsIFUsIEYgZXh0ZW5kcyAobGhzOiBVLCByaHM6IFQpID0+IG51bWJlcj4oYXJyYXk6IFRbXSwgd2FudGVkOiBVLCBjb21wYXJhdG9yOiBGKTogbnVtYmVyIHtcclxuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcclxuICAgIGxldCBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xyXG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPD0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XHJcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xyXG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgcmV0dXJuWmVybywgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+ID0gUmVxdWlyZWQ8ST4gJiBGbGFnZ2FibGVDaGlsZEluZm88XCJ0YWJiYWJsZVwiPiAmIHtcclxuLy99O1xyXG5cclxuZXhwb3J0IHR5cGUgT25UYWJiYWJsZUluZGV4Q2hhbmdlID0gKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxFIGV4dGVuZHMgRWxlbWVudCwgQz4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB0YWJiaW5nIHRocm91Z2ggdGhpcyBjb21wb25lbnQgd2lsbCBjYXVzZSB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IHRvIGJlIGZvY3VzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50IGlmIHlvdSdkIGxpa2UuXHJcbiAgICAgKi9cclxuICAgIGZvY3VzU2VsZigpOiB2b2lkO1xyXG5cclxuICAgIGJsdXJTZWxmKCk6IHZvaWQ7XHJcblxyXG4gICAgZ2V0RWxlbWVudCgpOiBFIHwgbnVsbDtcclxuXHJcbiAgICBoaWRkZW46IGJvb2xlYW47XHJcblxyXG4gICAgc3ViSW5mbzogQztcclxufVxyXG5cclxuaW50ZXJmYWNlIFJUSVAge1xyXG4gICAgLy8gQ2FsbGVkIGR1cmluZyBhbiBlZmZlY3QgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgcmVuZGVyZWQgaXRzZWxmIGluIGEgdGFiYmFibGUgc3RhdGVcclxuICAgIG9uVGFiYmFibGVSZW5kZXI/OiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcclxuXHJcbiAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U/OiBPblRhYmJhYmxlSW5kZXhDaGFuZ2U7XHJcblxyXG4gICAgb25UYWJiZWRJblRvPzogKCkgPT4gdm9pZDtcclxuICAgIG9uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIGluaXRpYWxJbmRleD86IG51bWJlcjtcclxufVxyXG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIFJUSVA7XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPG51bWJlciwgTWNPbWl0cz4ge1xyXG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcclxuICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGZvY3VzU2VsZjogKCkgPT4gdm9pZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xyXG4gICAgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj5cclxue1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgUnRpY09taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXHJcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIj4ge1xyXG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UGFydGlhbDxPbWl0PFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxhbnksIGFueT4sIFwiZ2V0RWxlbWVudFwiIHwgXCJzdWJJbmZvXCI+PiwgUnRpY09taXRzPjtcclxuICAgIHN1YkluZm86IFN1YmJlc3RJbmZvO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMsIG5ldmVyLCBuZXZlciwgUnRpU3ViSW5mbz4pID0+IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0VGFiYmFibGUoKTogYm9vbGVhbjtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGdldEVsZW1lbnQoKTogQ2hpbGRFbGVtZW50IHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgLyoqICpVbnN0YWJsZSogKi9cclxuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSByb3ZpbmcgdGFiaW5kZXggc3lzdGVtIHdoZXJlIG9ubHkgb25lIFwiZm9jdXNhYmxlXCJcclxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxyXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcclxuICogcmVjb21tZW5kZWQgdG8gb2ZmbG9hZCB0aGF0IGxvZ2ljIHRoZW4gdG8gYW5vdGhlciBob29rLCBsaWtlXHJcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxyXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcclxuICogbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHR5cGVhaGVhZCwgb3JcclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cclxuICogXHJcbiAqIE5vdGUgdGhhdCB0aGUgY2hpbGQgaG9vayByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZFxyXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcclxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcclxuICogb24gdGhlIGNoaWxkJ3MgZWxlbWVudCwgYXMgd2VsbCBhcyBhbnkgb3RoZXIgZWxlbWVudHMgeW91J2QgbGlrZVxyXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXHJcbiAqIFxyXG4gKiBgc2hvdWxkRm9jdXNPbkNoYW5nZWAgc2hvdWxkIHJldHVybiB0cnVlIGlmIGZvY3VzIGlzIFxyXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXHJcbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcclxuICogYGBgXHJcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAqIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oeyBzZXRGb2N1c2VkSW5uZXIgfSk7XHJcbiAqIGNvbnN0IGZvY3VzT25DaGFuZ2UgPSAoZm9jdXNlZElubmVyICE9IGZhbHNlKTtcclxuICogYGBgXHJcbiAqIEl0J3Mgbm90IGluY2x1ZGVkIGhlcmUgYmVjYXVzZSBgdXNlUm92aW5nVGFiSW5kZXhgIGRvZXNuJ3Qga25vdyBcclxuICogYW55dGhpbmcgYWJvdXQgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBvbmx5IGNoaWxkcmVuIGVsZW1lbnRzLlxyXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXHJcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcblxyXG4gICAgbGV0IHsgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJlZEluVG8sIG9uVGFiYmVkT3V0T2YsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmFibGVJbmRleENoYW5nZSB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcclxuXHJcbiAgICBpbml0aWFsSW5kZXggPz89IDA7XHJcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XHJcbiAgICBjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBpZiAob2xkQ291bnQgPT0gMCAmJiBuZXdDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgb25UYWJiZWRJblRvPy4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdDb3VudCA9PSAwICYmIChvbGRDb3VudCA/PyAwKSA+IDApIHtcclxuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVyblplcm8pO1xyXG5cclxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XHJcbiAgICAvLyBXaGF0IGl0IGlzLCBhbmQgd2hldGhlciwgd2hlbiB3ZSByZW5kZXIgdGhpcyBjb21wb25lbnQgYW5kIGl0J3MgY2hhbmdlZCwgdG8gYWxzbyBmb2N1cyB0aGUgZWxlbWVudCB0aGF0IHdhcyBtYWRlIHRhYmJhYmxlLlxyXG4gICAgY29uc3QgW2dldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXgyXSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXIgfCBudWxsPihvblRhYmJhYmxlSW5kZXhDaGFuZ2UsIHVzZUNhbGxiYWNrKCgpID0+IHsgcmV0dXJuIGluaXRpYWxJbmRleCA/PyAwIH0sIFtdKSk7XHJcbiAgICBjb25zdCBzZXRUYWJiYWJsZUluZGV4ID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXgyKChwcmV2SW5kZXgpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5leHRJbmRleCA9IHByZXZJbmRleDtcclxuXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXBkYXRlciA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gdXBkYXRlcihwcmV2SW5kZXggPz8gbnVsbCk7XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHVwZGF0ZXI7XHJcblxyXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBjaGFuZ2VJbmRleChuZXh0SW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgaWYgKHByZXZJbmRleCAhPSBuZXh0SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KG5leHRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChwcmV2Q2hpbGQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBwcmV2Q2hpbGQuc3ViSW5mby5ibHVyU2VsZigpO1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5zdWJJbmZvLmZvY3VzU2VsZigpO1xyXG5cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG5leHRJbmRleDtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gQW55IHRpbWUgdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMsXHJcbiAgICAvLyBub3RpZnkgdGhlIHByZXZpb3VzIGNoaWxkIHRoYXQgaXQncyBubyBsb25nZXIgdGFiYmFibGUsXHJcbiAgICAvLyBhbmQgbm90aWZ5IHRoZSBuZXh0IGNoaWxkIHRoYXQgaXMgYWxsb3dlZCB0byBiZSB0YWJiZWQgdG8uXHJcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcclxuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LFxyXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG1vdW50ZWQsIHVubW91bnRlZCk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZU1hbmFnZWRDaGlsZCB9ID0gcGFyZW50UmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7IGluaXRpYWxJbmRleCwgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiB0cnVlLCBrZXk6IFwidGFiYmFibGVcIiB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlUm92aW5nVGFiSW5kZXhDaGlsZDxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+PigoY2hpbGRQYXJhbWV0ZXJzKSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgc3ViSW5mbywgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW4sIGJsdXJTZWxmOiBibHVyU2VsZk92ZXJyaWRlLCBmb2N1c1NlbGY6IGZvY3VzU2VsZk92ZXJyaWRlIH0gfSA9IGNoaWxkUGFyYW1ldGVycztcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTtcclxuICAgICAgICB9LCBbISFoaWRkZW5dKVxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgYnNPdmVycmlkZSA9IHVzZVN0YWJsZUdldHRlcihibHVyU2VsZk92ZXJyaWRlKTtcclxuICAgICAgICBjb25zdCBmc092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGZvY3VzU2VsZk92ZXJyaWRlKTtcclxuICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZzID0gZnNPdmVycmlkZSgpO1xyXG4gICAgICAgICAgICBpZiAoZnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB1c2VSb3ZpbmdUYWJJbmRleENoaWxkWyR7aW5kZXh9XS5mb2N1c1NlbGYgKG92ZXJyaWRlKWApO1xyXG4gICAgICAgICAgICAgICAgZnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB1c2VSb3ZpbmdUYWJJbmRleENoaWxkWyR7aW5kZXh9XS5mb2N1c1NlbGYgKGRlZmF1bHQpYCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpIGFzIChFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cz8uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSk7XHJcbiAgICAgICAgY29uc3QgYmx1clNlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJzID0gYnNPdmVycmlkZSgpO1xyXG4gICAgICAgICAgICBpZiAoYnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGB1c2VSb3ZpbmdUYWJJbmRleENoaWxkWyR7aW5kZXh9XS5ibHVyU2VsZiAob3ZlcnJpZGUpYCk7XHJcbiAgICAgICAgICAgICAgICBicygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmJsdXJTZWxmIChkZWZhdWx0KWApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYmx1cj8uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uRm9jdXNlZElubmVyQ2hhbmdlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgIHNldEFueUZvY3VzZWQocHJldiA9PiAoZm9jdXNlZCA/ICgocHJldiA/PyAwKSArIDEpIDogKChwcmV2ID8/IDApIC0gMSkpKTtcclxuICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDaGlsZCAke2luZGV4fSBoYXMgYmVlbiBmb2N1c2VkIGFuZCB3aWxsIHNldCBpdHNlbGYgYXMgdGhlIHRhYmJhYmxlIGNoaWxkYCk7XHJcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8Q2hpbGRFbGVtZW50Pih7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgW3RhYmJhYmxlLCBzZXRUYWJiYWJsZSwgZ2V0VGFiYmFibGVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHRhYmJhYmxlRmxhZ3MgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFRhYmJhYmxlLCBzZXQ6IHNldFRhYmJhYmxlLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhaGlkZGVuKSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xyXG4gICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmbGFnczogeyAuLi5mbGFncywgdGFiYmFibGU6IHRhYmJhYmxlRmxhZ3MuY3VycmVudCB9IGFzIFBhcnRpYWw8UmVjb3JkPEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIENoaWxkRmxhZ09wZXJhdGlvbnM+PixcclxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcclxuICAgICAgICAgICAgICAgICAgICBibHVyU2VsZixcclxuICAgICAgICAgICAgICAgICAgICBmb2N1c1NlbGYsXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgICAgICBoaWRkZW46ICEhaGlkZGVuLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YkluZm9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0YWJiYWJsZSlcclxuICAgICAgICAgICAgICAgIHN0YWJsZU9uVGFiYmFibGVSZW5kZXIoaW5kZXgpO1xyXG4gICAgICAgIH0sIFt0YWJiYWJsZSwgaW5kZXhdKVxyXG4gICAgICAgIGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChwcm9wcy50YWJJbmRleCA9PSBudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENoaWxkRWxlbWVudD4odXNlSGFzRm9jdXNQcm9wcyh7IHRhYkluZGV4OiB0YWJiYWJsZSA/IDAgOiAtMSB9KSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudCxcclxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZmApO1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0VGFiYmFibGVJbmRleCgpO1xyXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKVxyXG4gICAgICAgICAgICBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChpbmRleCk/LnN1YkluZm8uZm9jdXNTZWxmPy4oKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgdHJ1ZSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4gfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4LFxyXG4gICAgICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxyXG4gICAgICAgICAgICBmb2N1c1NlbGYsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuLypmdW5jdGlvbiB0ZXN0KCkge1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4LCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTERpdkVsZW1lbnQsIHsgXCJmb29cIjogXCJiYXJcIiB9LCBcImZsYWcyXCI+KHsgbWFuYWdlZENoaWxkcmVuOiB7fSwgcm92aW5nVGFiSW5kZXg6IHt9IH0pO1xyXG4gICAgY29uc3QgeyB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7IG1hbmFnZWRDaGlsZHJlbjogeyBpbmRleDogMCwgZmxhZ3M6IHt9IH0sIHJ0aTogeyBpbmZvMzogeyBmb286IFwiYmFyXCIgfSB9IH0pO1xyXG59Ki9cclxuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmFuZG9tO1xuIiwiaW1wb3J0IGJhc2VSYW5kb20gZnJvbSAnLi9fYmFzZVJhbmRvbS5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlU2VsZjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U2h1ZmZsZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XHJcbmltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBNdXRhYmxlUmVmLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIE1hbmFnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSBcIi4vdXNlLWZvcmNlLXVwZGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IGxvZGFzaFNodWZmbGUgZnJvbSBcImxvZGFzaC1lcy9zaHVmZmxlXCI7XHJcblxyXG5leHBvcnQgdHlwZSBHZXRJbmRleDxDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPikgPT4gKG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpO1xyXG5leHBvcnQgdHlwZSBHZXRWYWx1ZTxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+ID0gKHJvdzogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+LCAuLi5hcmdzOiBHKSA9PiBWO1xyXG5leHBvcnQgdHlwZSBDb21wYXJlPFY+ID0gKGxoczogViwgcmhzOiBWKSA9PiBudW1iZXI7XHJcblxyXG4vKipcclxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogTXVzdCByZXR1cm4sIGUuZy4sIHRoZSByb3cgaW5kZXggb2YgdGhpcyBjaGlsZFxyXG4gICAgICogKFVzdWFsbHkganVzdCBhbiBgaW5kZXhgIHByb3ApXHJcbiAgICAgKi9cclxuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogR2V0SW5kZXg8QywgSz47IH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgKipNVVNUKiogYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10sIFY+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPiB7XHJcbiAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTXVzdCByZXR1cm4gdGhlIHZhbHVlIHRoaXMgY2hpbGQgdXNlcyBSRTogc29ydGluZy5cclxuICAgICAgICAgKiBJZiB5b3UgZG9uJ3QgY2FyZSBhYm91dCBzb3J0aW5nICh5b3UganVzdCB1c2UgXHJcbiAgICAgICAgICogeW91ciBvd25hcmJpdHJhcnkgcmVvcmRlcmluZyksIHRoaXMgd2lsbCBuZXZlclxyXG4gICAgICAgICAqIGJlIHVzZWQsIHNvIGl0IGNhbiByZXR1cm4gYW55dGhpbmcuXHJcbiAgICAgICAgICogQHBhcmFtIHJvdyBcclxuICAgICAgICAgKiBAcGFyYW0gYXJncyBcclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXRWYWx1ZTogR2V0VmFsdWU8QywgSywgRywgVj47XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbnRyb2xzIGhvdyB2YWx1ZXMgY29tcGFyZSBhZ2FpbnN0IGVhY2ggb3RoZXIuXHJcbiAgICAgICAgICogQHBhcmFtIGxocyBcclxuICAgICAgICAgKiBAcGFyYW0gcmhzIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNvbXBhcmU6IENvbXBhcmU8Vj47XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxyXG4gKiBcclxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKlxyXG4gKiBcclxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxyXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXHJcbiAqIHRoaXMgaG9vayBpbXBvc2VzIHNlcmlvdXMgcmVzdHJpY3Rpb25zIG9uIGNoaWxkIHN0cnVjdHVyZSwgd2hpbGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBhbGxvd3MgYW55dGhpbmcuXHJcbiAqIFxyXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxyXG4gKiBzb3J0IGFsbCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlaXIgdmFsdWUgZnJvbSB0aGUgYGdldFZhbHVlYCBhcmd1bWVudCB5b3UgcGFzcyBpbi5cclxuICogXHJcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxyXG4gKiByZS1tYXAgZWFjaCBjaGlsZCdzIHBvc2l0aW9uIHVzaW5nIGBtYW5nbGVNYXBgIGFuZCBgZGVtYW5nbGVNYXBgLCB3aGljaCBjb252ZXJ0IGJldHdlZW5cclxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXHJcbiAqIFxyXG4gKiBBZ2FpbiwgdW5saWtlIHNvbWUgb3RoZXIgaG9va3MsICoqdGhlc2UgY2hpbGRyZW4gbXVzdCBiZSBkaXJlY3QgZGVzY2VuZGFudHMqKi4gVGhpcyBpcyBiZWNhdXNlXHJcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxyXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XHJcbiAqIHRoZXJlJ3Mgbm8gb3RoZXIgdGltZSBvciBwbGFjZSB0aGlzIGNhbiBoYXBwZW4gb3RoZXIgdGhhbiBleGFjdGx5IHdpdGhpbiB0aGUgcGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPik6IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSz4ge1xyXG5cclxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYSBtYXBwaW5nIGJldHdlZW4gdW5zb3J0ZWQgaW5kZXggPC0tLT4gc29ydGVkIGluZGV4LlxyXG4gICAgLy8gVGhlc2UgYXJlIG5lZWRlZCBmb3IgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzLlxyXG4gICAgY29uc3QgbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xyXG4gICAgY29uc3QgZGVtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XHJcbiAgICBjb25zdCBpbmRleE1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAobWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XHJcbiAgICBjb25zdCBpbmRleERlbWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChkZW1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xyXG5cclxuICAgIC8vIFRoZSBzb3J0IGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGFibGUgdG8gdXBkYXRlIHdob2V2ZXIgaGFzIGFsbCB0aGUgc29ydGFibGUgY2hpbGRyZW4uXHJcbiAgICAvLyBCZWNhdXNlIHRoYXQgbWlnaHQgbm90IGJlIHRoZSBjb25zdW1lciBvZiAqdGhpcyogaG9vayBkaXJlY3RseSAoZS5nLiBhIHRhYmxlIHVzZXNcclxuICAgIC8vIHRoaXMgaG9vaywgYnV0IGl0J3MgdGJvZHkgdGhhdCBhY3R1YWxseSBuZWVkcyB1cGRhdGluZyksIHdlIG5lZWQgdG8gcmVtb3RlbHlcclxuICAgIC8vIGdldCBhbmQgc2V0IGEgZm9yY2VVcGRhdGUgZnVuY3Rpb24uXHJcbiAgICAvL2NvbnN0IFtnZXRGb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwsIHJldHVybk51bGwpO1xyXG4gICAgY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XHJcblxyXG4gICAgY29uc3QgcmVhcnJhbmdlID0gdXNlQ2FsbGJhY2soKHNvcnRlZFJvd3M6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc29ydGVkIDwtLT4gdW5zb3J0ZWQgaW5kaWNlcyBtYXAgXHJcbiAgICAgICAgLy8gYW5kIHJlcmVuZGVyIHRoZSB3aG9sZSB0YWJsZSwgYmFzaWNhbGx5XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXhBc1NvcnRlZCA9IDA7IGluZGV4QXNTb3J0ZWQgPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytpbmRleEFzU29ydGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNVbnNvcnRlZCA9IHNvcnRlZFJvd3NbaW5kZXhBc1NvcnRlZF0uaW5kZXg7XHJcblxyXG4gICAgICAgICAgICBtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1Vuc29ydGVkLCBpbmRleEFzU29ydGVkKTtcclxuICAgICAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1NvcnRlZCwgaW5kZXhBc1Vuc29ydGVkKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBnZXRGb3JjZVVwZGF0ZSgpPy4oKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VSZWFycmFuZ2VhYmxlUHJvcHMgPSB1c2VDYWxsYmFjaygoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfSkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0Rm9yY2VVcGRhdGUoX3ByZXYgPT4gZm9yY2VVcGRhdGUpOyB9LCBbZm9yY2VVcGRhdGVdKVxyXG5cclxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcclxuICAgICAgICAgICAgY2hpbGRyZW46XHJcbiAgICAgICAgICAgICAgICAoY2hpbGRyZW4gYXMgVk5vZGU8TWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+PltdKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChjaGlsZCA9PiAoeyBjaGlsZCwgbWFuZ2xlZEluZGV4OiBpbmRleE1hbmdsZXIoZ2V0SW5kZXgoY2hpbGQucHJvcHMhKSEpLCBkZW1hbmdsZWRJbmRleDogZ2V0SW5kZXgoY2hpbGQucHJvcHMpIH0pKVxyXG4gICAgICAgICAgICAgICAgICAgIC5zb3J0KChsaHMsIHJocykgPT4geyByZXR1cm4gbGhzLm1hbmdsZWRJbmRleCAtIHJocy5tYW5nbGVkSW5kZXggfSlcclxuICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGNoaWxkLCBtYW5nbGVkSW5kZXgsIGRlbWFuZ2xlZEluZGV4IH0pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGgoY2hpbGQudHlwZSBhcyBhbnksIHsgLi4uY2hpbGQucHJvcHMsIGtleTogZGVtYW5nbGVkSW5kZXgsIFwiZGF0YS1tYW5nbGVkLWluZGV4XCI6IG1hbmdsZWRJbmRleCwgXCJkYXRhLXVubWFuZ2xlZC1pbmRleFwiOiBkZW1hbmdsZWRJbmRleCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sIHByb3BzKSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlciwgbWFuZ2xlTWFwLCBkZW1hbmdsZU1hcCwgcmVhcnJhbmdlIH0gfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cclxuICogXHJcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISogXHJcbiAqIFxyXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXHJcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcclxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cclxuICogXHJcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXHJcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxyXG4gKiBcclxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XHJcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxyXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cclxuICogXHJcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcclxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXHJcbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcclxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSwgc29ydGFibGVDaGlsZHJlbjogeyBjb21wYXJlOiB1c2VyQ29tcGFyZSwgZ2V0VmFsdWUgfSB9OiBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLLCBHLCBWPik6IFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIEMsIEssIEc+IHtcclxuXHJcbiAgICBjb25zdCBjb21wYXJlID0gKHVzZXJDb21wYXJlID8/IGRlZmF1bHRDb21wYXJlKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZVJlYXJyYW5nZWFibGVQcm9wczogdXNlU29ydGFibGVQcm9wcywgLi4ucmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZSB9ID0gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEs+KHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4IH0gfSk7XHJcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyByZWFycmFuZ2UgfSB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcclxuICAgIC8vIFRoZSBhY3R1YWwgc29ydCBmdW5jdGlvbi5cclxuICAgIGNvbnN0IHNvcnQgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRyk6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc29ydGVkUm93cyA9IG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKS5zb3J0KChsaHNSb3csIHJoc1JvdykgPT4ge1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBnZXRWYWx1ZShsaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcclxuICAgICAgICAgICAgY29uc3QgcmhzVmFsdWUgPSBnZXRWYWx1ZShyaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZShsaHNWYWx1ZSwgcmhzVmFsdWUpIC8vIGxoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlLCByaHNSb3cuZ2V0TWFuYWdlZENlbGxzKCk/Lltjb2x1bW5dPy52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc29ydGVkUm93cyk7XHJcblxyXG4gICAgfSwgWyAvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcbiAgICBjb25zdCBzaHVmZmxlID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPik6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcclxuICAgICAgICBjb25zdCBzaHVmZmxlZFJvd3MgPSBsb2Rhc2hTaHVmZmxlKG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKSlcclxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XHJcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxyXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsgc29ydCwgc2h1ZmZsZSB9LFxyXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSyBleHRlbmRzIHN0cmluZz4ge1xyXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGFzcyBhbiBhcnJheSBvZiBub3Qtc29ydGVkIGNoaWxkIGluZm9ybWF0aW9uIHRvIHRoaXMgZnVuY3Rpb25cclxuICAgICAgICAgKiBhbmQgdGhlIGNoaWxkcmVuIHdpbGwgcmUtYXJyYW5nZSB0aGVtc2VsdmVzIHRvIG1hdGNoLlxyXG4gICAgICAgICAqICBcclxuICAgICAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgICAgICogIFxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHJlYXJyYW5nZTogKHJvd3NJbk9yZGVyOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4gdm9pZDtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIG1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGRlbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJlYXJyYW5nZWFibGVQcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB8IHVuZGVmaW5lZDsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xyXG4gICAgc29ydGFibGVDaGlsZHJlbjogey8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgc29ydDogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPiwgZGlyZWN0aW9uOiBcImFzY2VuZGluZ1wiIHwgXCJkZXNjZW5kaW5nXCIsIC4uLmFyZ3M6IEcpID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgc2h1ZmZsZTogKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXHJcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVNvcnRhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZTEobGhzLCByaHMpO1xyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUzKGxoczogc3RyaW5nIHwgbnVtYmVyLCByaHM6IHN0cmluZyB8IG51bWJlcikge1xyXG5cclxuICAgICAgICAvLyBDb2VyY2Ugc3RyaW5ncyB0byBudW1iZXJzIGlmIHRoZXkgc2VlbSB0byBzdGF5IHRoZSBzYW1lIHdoZW4gc2VyaWFsaXplZFxyXG4gICAgICAgIGlmIChgJHsrbGhzfWAgPT09IGxocylcclxuICAgICAgICAgICAgbGhzID0gK2xocztcclxuICAgICAgICBpZiAoYCR7K3Joc31gID09PSByaHMpXHJcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XHJcblxyXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIGlmIGVpdGhlciBhcmd1bWVudCBpcyBhIHN0cmluZywgdHVybiB0aGUgb3RoZXIgb25lIGludG8gb25lIHRvb1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICByaHMgPSBgJHtyaHN9YDtcclxuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgbGhzID0gYCR7bGhzfWA7XHJcblxyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KHR5cGVvZiBsaHMgPT09IHR5cGVvZiByaHMpO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5sb2NhbGVDb21wYXJlKHJocyBhcyBzdHJpbmcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICByZXR1cm4gK2xocyAtICtyaHM7XHJcblxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGFyZTIobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcImJvb2xlYW5cIiB8fCBsaHMgaW5zdGFuY2VvZiBEYXRlKVxyXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcImJvb2xlYW5cIiB8fCByaHMgaW5zdGFuY2VvZiBEYXRlKVxyXG4gICAgICAgICAgICByaHMgPSArcmhzO1xyXG4gICAgICAgIHJldHVybiBjb21wYXJlMyhsaHMsIHJocyk7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlMShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuICAgICAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gVGhleSdyZSBib3RoIG51bGxcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxocyA9PSBudWxsIHx8IHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIE9uZSBvZiB0aGUgdHdvIGlzIG51bGwgLS0gZWFzeSBjYXNlXHJcbiAgICAgICAgICAgIHJldHVybiBsaHMgIT0gbnVsbCA/IDEgOiAtMVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29tcGFyZTIobGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW4sIE1hbmFnZWRDaGlsZHJlbk9taXRzLCB1c2VDaGlsZHJlbkZsYWcgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XHJcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIHVzZVJvdmluZ1RhYkluZGV4LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcclxuaW1wb3J0IHsgdXNlU29ydGFibGVDaGlsZHJlbiwgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcblxyXG4vKipcclxuICogXHJcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxyXG4gKiBidXQgaXQncyBub3QgYmFkIGZvciBhIGNvbGxhdGlvbiBjcmFzaCBjb3Vyc2UgYW5kIEkgbWlnaHQgdXNlIGl0IGFnYWluLlxyXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cclxuICogXHJcbiAqIHxMYW5nLnxUYXJnZXR8VXNlciBpbnB1dHxgYmFzZWB8YGFjY2VudGB8YGNhc2VgfGB2YXJpYW50YHxcclxuICogfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18XHJcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8RU58SGl8SGl84pyFfOKchXzinIV84pyFfFxyXG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcclxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcclxuICogfEVOfEhpfEjDr3zinIV84p2MfOKdjHzinYx8XHJcbiAqIHxFTnzDpXxhYXzinYx84p2MfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XHJcbiAqIHxEQXzDpXxBQXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XHJcbiAqIHxFTnzDpXxhfOKchXzinIV84p2MfOKdjHxcclxuICogfERBfMOlfGF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XHJcbiAqIHxKUHzjgqt87722fOKchXzinIV84pyFfOKchXxcclxuICogfEpQfOOCq3zjgYt84pyFfOKchXzinIV84p2MfFxyXG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XHJcbiAqIHxKUHzjgqt844uVfOKchXzinIV84p2MfOKdjHxcclxuICogfEpQfOOCq3zjgqx84pyFfOKdjHzinYx84p2MfFxyXG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XHJcbiAqIHxaSHzntIV857qifOKdjHzinYx84p2MfOKdjHxcclxuICogXHJcbiAqIFxyXG4gKiAoTm90ZSB0byBzZWxmOiBBdCBzb21lIHBvaW50LCB0aGlzIGZpbGUgd2lsbCBwcm9iYWJseSBiZSBub3JtYWxpemVkXHJcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxyXG4gKiBcclxuICovXHJcbmNvbnN0IF9kdW1teTogYW55ID0gbnVsbDtcclxuXHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XHJcbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPiB7XHJcbiAgICB0ZXh0OiBzdHJpbmc7XHJcblxyXG4gICAgc3ViSW5mbzogQztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBmcm9tVXNlckludGVyYWN0aW9uIFdoZXRoZXIgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoaXMgY2hpbGQgYXMgYSBtZWFucyBvZiBuYXZpZ2F0aW5nIHRvIGl0LiAgSW4gdGhhdCB3YXMgdGhlIGNhc2UsIHRoZSBjaGlsZCBpcyBhbHNvIGZvY3VzZWQuIE90aGVyd2lzZSwgZm9jdXMgbW92ZXMgYXMgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lcy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xyXG5cclxuXHJcbmludGVyZmFjZSBMU1Age1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBhbmQgaW5kZXhEZW1hbmdsZXIgYXJlIHVzZWQgdG8gYWxsb3cgY2hpbGRyZW4gdG8gYmUgbmF2aWdhdGVkIGluIGFuIG9yZGVyXHJcbiAgICAgKiB0aGF0IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWF0Y2ggdGhlaXIgY2hpbGQgb3JkZXIsIGxpa2UgaWYgYSBsaXN0IGlzIHNvcnRlZC5cclxuICAgICAqIFxyXG4gICAgICogVXNlZCB0byB0dXJuIGFuIFwiYWJzb2x1dGVcIiBpbmRleCBpbnRvIGEgXCJzb3J0ZWQvZmlsdGVyZWQvbWFuZ2xlZFwiIG9uZS5cclxuICAgICAqIFxyXG4gICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXHJcbiAgICAgKiBAcGFyYW0gcmF3SW5kZXggXHJcbiAgICAgKi9cclxuICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gdHVybiBhIFwibWFuZ2xlZFwiIGluZGV4IGludG8gaXQncyBcInVuc29ydGVkXCIgb3IgXCJ1bm1hbmdsZWRcIiBpbmRleC5cclxuICAgICAqIFxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4LFxyXG4gICAgICogaXQgbmVlZHMgdG8gYmUgZGVtYW5nbGVkIHRvIGRvIFwibm9ybWFsXCIgbWF0aCBvbiBpdCwgYW5kIHRoZW4gcmUtbWFuZ2xlZCAoYWJvdmUpXHJcbiAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxyXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWVkSW5kZXggXHJcbiAgICAgKi9cclxuICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzID0ga2V5b2YgTFNQO1xyXG5cclxuLy8gKioqIFBhcmFtZXRlcnMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcclxuICAgIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxSdGlPbWl0cywgTWNPbWl0cz4sXHJcbiAgICBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxUbk9taXRzIHwgXCJnZXRJbmRleFwiIHwgXCJzZXRJbmRleFwiPixcclxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPExuT21pdHMgfCBcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiB7XHJcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxMU1AsIExzT21pdHM+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NQIHtcclxuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XHJcbn1cclxuZXhwb3J0IHR5cGUgU2luZ2xlU2VsZWN0aW9uT21pdHMgPSBrZXlvZiBTU1A7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBPbWl0PFNTUCwgU1NPbWl0cz47XHJcbn1cclxuZXhwb3J0IHR5cGUgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzID0ga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPGFueT47XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8THNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzPiBleHRlbmRzXHJcbiAgICBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgUnRpT21pdHMsIE1jT21pdHMsIExzU3ViSW5mbz4ge1xyXG4gICAgLy9yb3ZpbmdUYWJJbmRleDogT21pdDxVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl0sIFwic3ViSW5mb1wiPjtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBMc09taXRzIHwgXCJzdWJJbmZvXCI+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyB8IFwic2VsZWN0ZWRcIiwgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHM+IHtcclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+PiwgXCJ0YWJiYWJsZVwiIHwgRXh0cmFGbGFnS2V5cz4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleDogTmF2aWdhdGVUb0luZGV4IH07XHJcbn1cclxuXHJcbi8vICoqKiBSZXR1cm4gdHlwZXMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcclxuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcclxuXHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcbiAgICBzaW5nbGVTZWxlY3Rpb246IHt9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xyXG4gICAgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+W1widXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XHJcbiAgICBzaW5nbGVTZWxlY3Rpb246IHtcclxuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbjtcclxuICAgICAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+W1widXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXCJdO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIHByb3BlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBjb21wb25lbnRzIGxpa2UgbGlzdGJveGVzLCBidXR0b24gZ3JvdXBzLCBtZW51cywgZXRjLlxyXG4gKiBcclxuICogSW4gdGhlIGRvY3VtZW50IG9yZGVyLCB0aGVyZSB3aWxsIGJlIG9ubHkgb25lIFwiZm9jdXNlZFwiIG9yIFwidGFiYmFibGVcIiBlbGVtZW50LCBtYWtpbmcgaXQgYWN0IG1vcmUgbGlrZSBvbmUgY29tcGxldGUgdW5pdCBpbiBjb21wYXJpc29uIHRvIGV2ZXJ5dGhpbmcgYXJvdW5kIGl0LlxyXG4gKiBOYXZpZ2F0aW5nIGZvcndhcmRzL2JhY2t3YXJkcyBjYW4gYmUgZG9uZSB3aXRoIHRoZSBhcnJvdyBrZXlzLCBIb21lL0VuZCBrZXlzLCBvciBhbnkgYW55IHRleHQgZm9yIHR5cGVhaGVhZCB0byBmb2N1cyB0aGUgbmV4dCBpdGVtIHRoYXQgbWF0Y2hlcy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4oe1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcclxuICAgIHJvdmluZ1RhYkluZGV4LFxyXG4gICAgbGlzdE5hdmlnYXRpb246IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9LFxyXG4gICAgbGluZWFyTmF2aWdhdGlvbixcclxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cclxufTogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcbiAgICBpbmRleE1hbmdsZXIgPz89IGlkZW50aXR5O1xyXG4gICAgaW5kZXhEZW1hbmdsZXIgPz89IGlkZW50aXR5O1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxpc3ROYXZpZ2F0aW9uXCIsIGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIpO1xyXG5cclxuXHJcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXhcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sIHJvdmluZ1RhYkluZGV4OiB7IGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSB9ID0gcGFyZW50UmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGlmIChpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdHJ5TmF2aWdhdGVUb0luZGV4KHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGksXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXHJcbiAgICAgICAgICAgICAgICBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSxcclxuICAgICAgICAgICAgICAgIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4LCBmcm9tVXNlckludGVyYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZFxyXG4gICAgICAgIH1cclxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCxcclxuICAgICAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgfSwgW10pLFxyXG4gICAgICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXY6IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoKGMgPz8gMCkpIC0gMSksIHNlYXJjaERpcmVjdGlvbjogLTEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSlcclxuICAgICAgICAgICAgICAgIH0sIHRydWUpXHJcbiAgICAgICAgICAgIH0sIFtdKSxcclxuICAgICAgICAgICAgbmF2aWdhdGVUb05leHQ6IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoYyA/PyAwKSArIDEpLCBzZWFyY2hEaXJlY3Rpb246IDEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKVxyXG4gICAgICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKDApLCB0cnVlKTsgfSwgW10pLFxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpKSwgdHJ1ZSk7IH0sIFtdKSxcclxuICAgICAgICAgICAgLi4ubGluZWFyTmF2aWdhdGlvblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyh1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMocHJvcHMpKTtcclxuICAgIH0sIFt1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMsIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wc10pO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuIH0sIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQgfSwgc3ViSW5mbyB9KSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkKHsgdGV4dCwgaW5kZXggfSk7XHJcbiAgICAgICAgY29uc3QgZ2V0SW5kZXggPSB1c2VTdGFibGVHZXR0ZXIoaW5kZXgpO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGdldFRhYmJhYmxlSW5kZXgoKSA9PSBnZXRJbmRleCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZGV4LCBmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSwgW10pO1xyXG5cclxuICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcclxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGYsIGZvY3VzU2VsZiwgaGlkZGVuOiAhIWhpZGRlbiB9LFxyXG4gICAgICAgICAgICBzdWJJbmZvOiB7IHRleHQsIHN1YkluZm8gfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+ID0gZnVuY3Rpb24gKHsgLi4ucHJvcHMgfSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMoKCh7IGluZXJ0OiBoaWRkZW4gfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSkpLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICB0YWJiYWJsZSxcclxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbmF2aWdhdGVUb0luZGV4XSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXHJcblxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHBhcmVudFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH1cclxuICAgICAgICAvKmxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCB9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9Ki9cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogSXQncyB2ZXJ5IGNvbW1vbiB0byBjb21iaW5lIGEgdGFiYmFibGUgbGlzdCBvZiB0aGluZ3MgYW5kIFwic2VsZWN0aW9uXCIgb2Ygb25lIG9mIHRob3NlIHRoaW5ncy5cclxuICogXHJcbiAqIExpc3RzLCByYWRpbyBidXR0b25zLCB0YWJzLCBldGMuIGV0Yy5cclxuICogXHJcbiAqIFRoaXMgaXMgYSBzaG9ydGN1dCB0aGF0IGNvbWJpbmVzIHRoZSB0d28gd2l0aCB0aGUgY29ycmVjdCB0eXBpbmcuXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oe1xyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXggfSxcclxuICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IC8qb25DaGlsZHJlbk1vdW50Q2hhbmdlOiBvY21jLCovIC4uLm1jIH0sXHJcbiAgICByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIC4uLnJvdmluZ1RhYkluZGV4IH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblxyXG59OiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4ge1xyXG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+KHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcclxuICAgICAgICAgICAgLi4ubWMsXHJcbiAgICAgICAgICAgIC8qb25DaGlsZHJlbk1vdW50Q2hhbmdlOiB1c2VTdGFibGVDYWxsYmFjazxPbkNoaWxkcmVuTW91bnRDaGFuZ2U8bnVtYmVyPj4oKG1vdW50ZWQsIHVubW91bnRlZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTtcclxuICAgICAgICAgICAgICAgIG9jbWM/Lihtb3VudGVkLCB1bm1vdW50ZWQpO1xyXG4gICAgICAgICAgICB9KSovXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICBpbml0aWFsSW5kZXg6IChpbml0aWFsSW5kZXggPz8gc2VsZWN0ZWRJbmRleCA/PyB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAuLi5yb3ZpbmdUYWJJbmRleFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmxpc3RSZXN0XHJcbiAgICB9ID0gcGFyZW50UmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9IH0gPSBsaXN0UmVzdDtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgY2hhbmdlSW5kZXg6IGNoYW5nZVNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAgZ2V0Q3VycmVudEluZGV4OiBnZXRTZWxlY3RlZEluZGV4LFxyXG4gICAgICAgIC8vcmVldmFsdWF0ZUNsb3Nlc3RGaXRcclxuICAgIH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSyB8IFwic2VsZWN0ZWRcIj4oe1xyXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICBpbml0aWFsSW5kZXg6IHNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAga2V5OiBcInNlbGVjdGVkXCIsXHJcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcclxuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aSwgbGlzdE5hdmlnYXRpb246IGxzLCBzdWJJbmZvIH0pID0+IHtcclxuICAgICAgICAgICAgY29uc3QgW2lzU2VsZWN0ZWQsIHNldElzU2VsZWN0ZWQsIGdldElzU2VsZWN0ZWRdID0gdXNlU3RhdGUoZ2V0U2VsZWN0ZWRJbmRleCgpID09IGluZGV4KTtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWYgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldElzU2VsZWN0ZWQsIHNldDogc2V0SXNTZWxlY3RlZCwgaXNWYWxpZDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gIXJ0aS5oaWRkZW4pIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXHJcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNcclxuICAgICAgICAgICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsYWdzXHJcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBQYXJ0aWFsPFJlY29yZDxLIHwgXCJzZWxlY3RlZFwiIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxyXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IGxzLFxyXG4gICAgICAgICAgICAgICAgc3ViSW5mb1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxyXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXHJcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQ6IGlzU2VsZWN0ZWQsIGdldFNlbGVjdGVkOiBnZXRJc1NlbGVjdGVkIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogdXNlQ2FsbGJhY2soKC4uLnA6IFBhcmFtZXRlcnM8dHlwZW9mIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM+KSA9PiB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblByb3BzKC4uLnApIH0sIFtdKSxcclxuICAgICAgICAuLi5saXN0UmVzdCxcclxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHt9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgViwgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcclxuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+LFxyXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSywgRywgVj4ge1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+ID0gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSywgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHM+O1xyXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4sXHJcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSywgRz4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcclxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxyXG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiwgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLCBzb3J0YWJsZUNoaWxkcmVuIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPEMsIEssIEcsIFYsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIEc+IHtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcclxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxyXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSywgRywgVj4oe1xyXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbixcclxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzID0gKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuICh1c2VMaXN0TmF2aWdhdGlvblByb3BzKHVzZVNvcnRhYmxlUHJvcHMocHJvcHMpKSlcclxuICAgIH1cclxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZCA9IChwOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyPikgPT4ge1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHApXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICh7XHJcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZSxcclxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxyXG4gICAgICAgIC8qbWFuYWdlZENoaWxkcmVuOiBsaXN0TmF2UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IGxpc3ROYXZSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IGxpc3ROYXZSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogc29ydGFibGVDaGlsZHJlblJldHVyblR5cGUuc29ydGFibGVDaGlsZHJlbixcclxuICAgICAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnJlYXJyYW5nZWFibGVDaGlsZHJlbiovXHJcbiAgICB9KTtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhcmdzOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cywgTHNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXHJcbiAgICBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XHJcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cclxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIFtdPiB7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXHJcbiAgICAgICAgLi4uc29ydGFibGVSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBbXSwgbnVtYmVyPih7XHJcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSB9LFxyXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcclxuICAgICAgICAgICAgZ2V0VmFsdWU6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxyXG4gICAgICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjaygobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocyAtIHJoczsgfSwgW10pLFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIgfSB9ID0gc29ydGFibGVSZXR1cm5UeXBlO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiBzaW5nbGVTZWxlY3Rpb25cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xyXG4gICAgICAgIHJldHVybiAodXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh1c2VTb3J0YWJsZVByb3BzKHByb3BzKSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkID0gKHA6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQocCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuICh7XHJcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICAvL3NvcnRhYmxlOiB7IHNvcnQsIHNodWZmbGUsIHJlYXJyYW5nZSwgZGVtYW5nbGVNYXAsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIG1hbmdsZU1hcCB9LFxyXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZSxcclxuICAgICAgICAuLi5saXN0TmF2UmV0dXJuVHlwZVxyXG4gICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSz47XHJcbiAgICBkZWZhdWx0OiBudW1iZXI7XHJcbiAgICB0YXJnZXQ6IG51bWJlcjtcclxuICAgIHNlYXJjaERpcmVjdGlvbjogMSB8IC0xO1xyXG4gICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XHJcbiAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRyeU5hdmlnYXRlVG9JbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBzZWFyY2hEaXJlY3Rpb24sIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHRhcmdldCB9OiBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSz4pIHtcclxuICAgIGNvbnN0IHVwcGVyID0gY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCk7XHJcbiAgICBjb25zdCBsb3dlciA9IDA7XHJcblxyXG4gICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICB3aGlsZSAoKHRhcmdldCA+PSBsb3dlciAmJiAoY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKSlcclxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgLSAxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCA8IGxvd2VyID8gaW5kZXhEZW1hbmdsZXIobG93ZXIpIDogdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAxKSB7XHJcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPD0gdXBwZXIgJiYgY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKVxyXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSArIDEpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0ID4gdXBwZXIgPyBpbmRleERlbWFuZ2xlcih1cHBlcikgOiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG93ZXI7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyB9IGZyb20gXCJ1c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyB9IGZyb20gXCJ1c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzIH0gZnJvbSBcInVzZS1yb3ZpbmctdGFiaW5kZXhcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5cclxuLyoqXHJcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXHJcbiAqIFxyXG4gKiBUaGlzIHJlc3VsdHMgaW4gYSBsb3Qgb2YgdGhpbmdzIHdpdGggdmVyeSBzaW1pbGFyIG5hbWVzIGFuZCBqdXN0IGNvbmZ1c2lvbiBhbGwgYXJvdW5kLiBQbGVhc2UgdXNlIGNhdXRpb24uXHJcbiAqL1xyXG5cclxuLy8gUGFyYW1ldGVycyAocGFyZW50LCByb3csIGNlbGwpXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxcclxuICAgIENSLFxyXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXHJcbiAgICBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsXHJcbiAgICBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLFxyXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcclxuICAgIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsXHJcbiAgICBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHMsXHJcblxyXG4gICAgTHNDaGlsZE9taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLFxyXG4gICAgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cyxcclxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzXHJcblxyXG4gICAgPiB7XHJcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPjtcclxuICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENSLCBLUiwgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHM+XHJcblxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDQywgS0MgZXh0ZW5kcyBzdHJpbmcsIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHM+IGV4dGVuZHNcclxuICAgIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENDLCBLQywgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHM+IHtcclxuXHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcbiAgICBncmlkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcclxuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XHJcbiAgICB1c2VHcmlkTmF2aWdhdGlvblJvdzogVXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENSLCBDQywgS1IsIEtDPjtcclxuICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAgIGFzQ2hpbGRSb3c6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxSb3c+O1xyXG4gICAgYXNQYXJlbnRPZkNlbGxzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENlbGwsIENDLCBLQz47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbzxSb3csIENlbGwsIENDLCBLQz4ge1xyXG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCwgQ0MsIEtDPjtcclxuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xyXG4gICAgZ3JpZE5hdmlnYXRpb246IHtcclxuICAgICAgICAvL3Jvd0lzVGFiYmFibGU6IGJvb2xlYW47XHJcbiAgICAgICAgLy9nZXRSb3dJc1RhYmJhYmxlKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xyXG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Q1IsIEtSLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93LCBDZWxsLCBDQywgS0M+O1xyXG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDQywgS0MsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGw+O1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvbjxcclxuICAgIFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcclxuICAgIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcclxuICAgIFJvd1N1YkluZm8sXHJcbiAgICBDZWxsU3ViSW5mbyxcclxuICAgIFJvd0V4dHJhRmxhZ3MgZXh0ZW5kcyBzdHJpbmcsXHJcbiAgICBDZWxsRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZ1xyXG4+KHtcclxuICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXHJcbiAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxyXG4gICAgbGlzdE5hdmlnYXRpb246IGxzLFxyXG4gICAgbGluZWFyTmF2aWdhdGlvbjogbG4sXHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0blxyXG59OiBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+IHtcclxuICAgIGNvbnN0IFtjdXJyZW50Q29sdW1uLCBzZXRDdXJyZW50Q29sdW1uLCBnZXRDdXJyZW50Q29sdW1uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KHJ0aS5pbml0aWFsSW5kZXggPz8gMCk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3csXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcclxuICAgICAgICAuLi5wYXJlbnRMc1JldHVyblR5cGVcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIFJvd1N1YkluZm8sIFJvd0V4dHJhRmxhZ3M+KHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGksXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IGxzLFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHsgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJibG9ja1wiLCAuLi5sbiB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuLFxyXG4gICAgfSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uUm93ID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb246IGFzQ2hpbGQsIGFzUGFyZW50Um93T2ZDZWxsczogYXNQYXJlbnQgfSkgPT4ge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIHRoZSBmb2N1c1NlbGYgdGhhdCByb3ZpbmdUYWJJbmRleCBkb2VzLlxyXG4gICAgICAgIC8vIEluc3RlYWQgb2YgZm9jdXNpbmcgdGhlIGVudGlyZSByb3csIHdlIGFzayB0aGUgY2VsbCB0aGF0IGNvcnJlc3BvbmRzXHJcbiAgICAgICAgLy8gdG8gb3VyIGN1cnJlbnQgY29sdW1uIHRvIGZvY3VzIGl0c2VsZi5cclxuICAgICAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZ2V0Q3VycmVudENvbHVtbigpO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgcm93ICMke2FzQ2hpbGQubWFuYWdlZENoaWxkLmluZGV4fSwke2MyfSBmb2N1c1NlbGZgKTtcclxuICAgICAgICAgICAgaWYgKGFzQ2hpbGQucm92aW5nVGFiSW5kZXguZm9jdXNTZWxmKSB7XHJcbiAgICAgICAgICAgICAgICBhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGMyID8/IDAsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJvd0xzQ2hpbGRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogYXNDaGlsZC5tYW5hZ2VkQ2hpbGQsXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzQ2hpbGQubGlzdE5hdmlnYXRpb24gfSxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgLi4uYXNDaGlsZC5yb3ZpbmdUYWJJbmRleCwgZm9jdXNTZWxmIH0sXHJcbiAgICAgICAgICAgIHN1YkluZm86IGFzQ2hpbGQuc3ViSW5mbyxcclxuICAgICAgICB9KTtcclxuICAgICAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlIH0sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gcm93THNDaGlsZFJldHVyblR5cGU7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0YWJiYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KG51bGwsIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xyXG5cclxuICAgICAgICBjb25zdCByb3dMc1JldHVyblR5cGUgPSB1c2VMaXN0TmF2aWdhdGlvbjxDZWxsRWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4oe1xyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLi4uYXNQYXJlbnQubWFuYWdlZENoaWxkcmVuIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzUGFyZW50LnJvdmluZ1RhYkluZGV4IH0sXHJcbiAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgICAgIC4uLmFzUGFyZW50LmxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImlubGluZVwiLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50LnR5cGVhaGVhZE5hdmlnYXRpb24sIG5vVHlwZWFoZWFkOiB0cnVlIH0sXHJcbiAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50Lmxpc3ROYXZpZ2F0aW9uIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyBzZXRUYWJiYWJsZUluZGV4IH0sIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMiwgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogdXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcywgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0gfSA9IHJvd0xzUmV0dXJuVHlwZTtcclxuXHJcbiAgICAgICAgLy9jb25zdCByb3dIaWRkZW4gPSAhIWFzQ2hpbGQucm92aW5nVGFiSW5kZXguaGlkZGVuO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvbkNlbGwgPSB1c2VDYWxsYmFjazxVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4+KCh7IHN1YkluZm8sIG1hbmFnZWRDaGlsZCwgbGlzdE5hdmlnYXRpb246IGxzLCByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZjogYnMsIGZvY3VzU2VsZjogZnMsIC4uLnJ0aSB9IH0pID0+IHtcclxuICAgICAgICAgICAgLy9ydGkuaGlkZGVuIHx8IHJvd0hpZGRlbjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjZWxsICMke21hbmFnZWRDaGlsZC5pbmRleH0gZm9jdXNTZWxmYCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sdW1uKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZzKVxyXG4gICAgICAgICAgICAgICAgICAgIGZzKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKHJ0aV9jZWxsX3JldC5nZXRFbGVtZW50KCkgYXMgRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KT8uZm9jdXM/LigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgYmx1clNlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnMpXHJcbiAgICAgICAgICAgICAgICAgICAgYnMoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5ibHVyPy4oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfY2VsbF9yZXRcclxuICAgICAgICAgICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMih7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IG1hbmFnZWRDaGlsZCxcclxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzIH0sXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCAuLi5ydGkgfSxcclxuICAgICAgICAgICAgICAgIHN1YkluZm9cclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENlbGxFbGVtZW50Pih7XHJcbiAgICAgICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRDb2x1bW4obWFuYWdlZENoaWxkLmluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGxFbGVtZW50PiA9IHtcclxuICAgICAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7IGdldEN1cnJlbnRDb2x1bW4gfSxcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfY2VsbF9yZXQsXHJcbiAgICAgICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wczogZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsRWxlbWVudD4+KHByb3BzOiBQKSB7IHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHModXNlR3JpZE5hdmlnYXRpb25Db2x1bW5Qcm9wcyh1c2VIYXNGb2N1c1Byb3BzKHByb3BzKSkpOyB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJldHVybiByZXQ7XHJcblxyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgY29uc3QgcmV0OiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENlbGxTdWJJbmZvLCBDZWxsRXh0cmFGbGFncz4gPSB7XHJcbiAgICAgICAgICAgIGFzUGFyZW50T2ZDZWxsczoge1xyXG4gICAgICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiByb3dMc1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvd0xzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICAgICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG5cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYXNDaGlsZFJvdzogcm93THNDaGlsZFJldHVyblR5cGUsXHJcblxyXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXHJcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93RWxlbWVudD4+KHByb3BzOiBQKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMocHJvcHMpO1xyXG4gICAgICAgICAgICAgICAgcmV0LnRhYkluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcmV0O1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgZ2V0Q3VycmVudENvbHVtbixcclxuICAgICAgICAgICAgY3VycmVudENvbHVtblxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcGFyZW50THNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvdyxcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlSW50ZXJ2YWwge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBpbnRlcnZhbDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVydmFsKHsgaW50ZXJ2YWwsIGNhbGxiYWNrIH06IFVzZUludGVydmFsKSB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICBjb25zdCBnZXRJbnRlcnZhbCA9IHVzZVN0YWJsZUdldHRlcihpbnRlcnZhbCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGdldEludGVydmFsKCk7XG4gICAgICAgIGxldCBsYXN0RGVsYXlVc2VkID0gaW50ZXJ2YWw7XG5cbiAgICAgICAgaWYgKGludGVydmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG5cblxuICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgIC8vIHRoYXQgY2xlYXJzIGFuZCByZXNldHMgdGhlIGludGVydmFsIGlmIGl0IGNoYW5nZXMuXG4gICAgICAgIGNvbnN0IGFkanVzdGFibGVDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0YWJsZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50SW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnRlcnZhbCAhPSBsYXN0RGVsYXlVc2VkKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gc2V0SW50ZXJ2YWwoYWRqdXN0YWJsZUNhbGxiYWNrLCBsYXN0RGVsYXlVc2VkID0gY3VycmVudEludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFuZGxlID0gc2V0SW50ZXJ2YWwoYWRqdXN0YWJsZUNhbGxiYWNrLCBpbnRlcnZhbCk7XG4gICAgICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGhhbmRsZSk7XG4gICAgfSwgW10pO1xufVxuXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VJbnRlcnZhbCB9IGZyb20gXCIuLi8uLlwiO1xuXG5cbmV4cG9ydCBjb25zdCBEZW1vVXNlSW50ZXJ2YWwgPSAoKSA9PiB7XG4gICAgY29uc3QgW2ludGVydmFsLCBzZXRJbnRlcnZhbF0gPSB1c2VTdGF0ZSgxMDAwKTtcblxuICAgIGNvbnN0IFtmaXJlQ291bnQsIHNldEZpcmVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIHVzZUludGVydmFsKHsgaW50ZXJ2YWwsIGNhbGxiYWNrOiAoKSA9PiBzZXRGaXJlQ291bnQoaSA9PiArK2kpIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxsYWJlbD5JbnRlcnZhbCBkdXJhdGlvbjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17aW50ZXJ2YWx9IG9uSW5wdXQ9e2UgPT4gc2V0SW50ZXJ2YWwoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlRoZSBjYWxsYmFjayBoYXMgYmVlbiBjYWxsZWQge2ZpcmVDb3VudH0gdGltZXtmaXJlQ291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9LjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBtZW1vLCBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi4vLi5cIjtcclxuaW1wb3J0IHsgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbiwgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkIH0gZnJvbSBcIi4uLy4uL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi4vLi4vdXNlLXN0YXRlXCI7XHJcblxyXG5cclxuY29uc3QgUmFuZG9tV29yZHMgPSBcIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIi5zcGxpdChcIiBcIik7XHJcblxyXG5cclxuXHJcbmNvbnN0IFJvdmluZ0NoaWxkQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPEhUTUxMSUVsZW1lbnQsIHt9LCBzdHJpbmc+PihudWxsISlcclxuZXhwb3J0IGNvbnN0IERlbW9Vc2VSb3ZpbmdUYWJJbmRleCA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoMTApO1xyXG4gICAgY29uc3QgW19sYXN0Rm9jdXNlZElubmVyLCBzZXRMYXN0Rm9jdXNlZElubmVyLCBfZ2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSlcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8SFRNTFVMaXN0RWxlbWVudD4oeyBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRMYXN0Rm9jdXNlZElubmVyIH0pO1xyXG4gICAgLy9jb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFt0YWJiYWJsZUluZGV4LCBzZXRMb2NhbFRhYmJhYmxlSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgLypjb25zdCB7XHJcbiAgICAgICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICAgICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXHJcbiAgICAgICAgc2h1ZmZsZVxyXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48SFRNTFVMaXN0RWxlbWVudCwge30sIHN0cmluZywgW10sIG51bWJlcj4oe1xyXG4gICAgICAgIGdldEluZGV4OiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSxcclxuICAgICAgICBnZXRWYWx1ZTogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSksXHJcbiAgICAgICAgY29tcGFyZTogdXNlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMgLSByaHM7IH0sIFtdKVxyXG4gICAgfSk7Ki9cclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sXHJcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBzZXRUYWJiYWJsZUluZGV4IH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkIH0sXHJcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzaHVmZmxlIH0sXHJcbiAgICB9ID0gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxIVE1MVUxpc3RFbGVtZW50LCBIVE1MTElFbGVtZW50LCB7fSwgc3RyaW5nPih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge30sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgb25UYWJiYWJsZUluZGV4Q2hhbmdlOiB1c2VDYWxsYmFjaygoaW5kZXg6IG51bWJlciB8IG51bGwpID0+IHsgaWYgKGluZGV4ICE9IG51bGwpIHNldExvY2FsVGFiYmFibGVJbmRleChpbmRleCk7IH0sIFtdKSB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4IH1cclxuICAgIH0pO1xyXG5cclxuXHJcblxyXG5cclxuICAgIC8vY29uc3QgeyB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCB1c2VSb3ZpbmdUYWJJbmRleFByb3BzIH0gPSB1c2VSb3ZpbmdUYWJJbmRleDxIVE1MVUxpc3RFbGVtZW50LCBSb3ZpbmdUYWJJbmRleENoaWxkSW5mbz4oeyB0YWJiYWJsZUluZGV4LCBmb2N1c09uQ2hhbmdlOiBmYWxzZSB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8aDI+S2V5Ym9hcmQgJmFtcDsgTGlzdCBOYXZpZ2F0aW9uPC9oMj5cclxuICAgICAgICAgICAgPGgzPjxjb2RlPnVzZVJvdmluZ1RhYkluZGV4PC9jb2RlPjwvaDM+XHJcblxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIE5hdGl2ZSBIVE1MIGVsZW1lbnRzIG9mZmVyIGZhbnRhc3RpYyBrZXlib2FyZCBhY2Nlc3NhYmlsaXR5LCBidXQgY292ZXIgYSByZWxhdGl2ZWx5IGxpbWl0ZWQgbnVtYmVyIG9mIHVzZSBjYXNlcy5cclxuICAgICAgICAgICAgICAgIFRoZXJlIGlzIG5vIG5hdGl2ZSBIVE1MIHRyZWUgZWxlbWVudCwgZm9yIGV4YW1wbGUsIHRoYXQgYWxsb3dzIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgaXRzIGl0ZW1zLFxyXG4gICAgICAgICAgICAgICAgbm9yIGlzIGl0IHBvc3NpYmxlIHRvIGNvbWJpbmUgdGhlIGtleWJvYXJkIG5hdmlnYXRpb24gYmVoYXZpb3Igb2YgYSA8Y29kZT57XCI8c2VsZWN0PlwifTwvY29kZT4gbWVudSB3aXRoIHRoZSBtZW51IGluIGEgZHJhd2VyIGNvbXBvbmVudC48L3A+XHJcblxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIFdoZW4gY29taW5nIGFjcm9zcyBhIExpc3Qgb3IgYSBNZW51IG9yIGEgUmFkaW9Hcm91cCBvciBhIFRvZ2dsZUJ1dHRvbkdyb3VwIG9yIGFueSBvdGhlciBcIm9uZSBjb21wb25lbnQgbWFkZSB1cCBvZiBjaGlsZCBjb21wb25lbnRzXCIsIHRoZSB1c3VhbCBleHBlY3RlZCBiZWhhdmlvcixcclxuICAgICAgICAgICAgICAgIGF0IGxlYXN0IG5hdGl2ZWx5LCBpcyB0aGF0IHRhYmJpbmcgaW50byB0aGUgY29tcG9uZW50IGlzIG9uZSBhY3Rpb24sIGFuZCB0YWJiaW5nIG91dCBpcyBhbm90aGVyLiAgTmF2aWdhdGluZyA8ZW0+d2l0aGluPC9lbT4gdGhlIGNvbXBvbmVudCBpcyBkb25lIHdpdGggdGhlIGFycm93IGtleXMgb3Igb3RoZXIgbWV0aG9kcy5cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIFRoaXMgaXMgaW1wb3J0YW50IGJvdGggZm9yIGFjY2Vzc2FiaWxpdHksIGJ1dCBhbHNvIGp1c3QgZm9yIGdlbmVyYWwgdXNhYmlsaXR5LiAgV2hlbiB0YWJiaW5nIGJhY2sgYW5kIGZvcnRoLCB0aGUgYWJpbGl0eSB0byBza2lwIGEgbG9uZyBsaXN0IHdpdGhvdXQgbmVlZGluZyB0byB0cnVkZ2UgdGhyb3VnaCA8ZW0+ZXZlcnkgb25lPC9lbT4gb2YgaXRzIGNoaWxkIGVsZW1lbnRzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQuXHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb248L2NvZGU+IHdyYXBzIHVwIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGEgZmV3IGhvb2tzICg8Y29kZT51c2VSb3ZpbmdUYWJJbmRleDwvY29kZT4sIDxjb2RlPnVzZUxpbmVhck5hdmlnYXRpb248L2NvZGU+LCA8Y29kZT51c2VUeXBlYWhlYWROYXZpZ2F0aW9uPC9jb2RlPilcclxuICAgICAgICAgICAgICAgIHRvIGFsbG93IGZvciBBUklBLWNvbXBsaWFudCBuYXZpZ2F0aW9uIG9mIGxpc3RzIGFuZCBvdGhlciBzaW1pbGFyIGNvbXBvbmVudHMuICBGb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIHlvdSBjYW4gdXNlIHRoZSBvdGhlciBob29rcyBpbmRpdmlkdWFsbHkuXHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb248L2NvZGU+IChhbmQgPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+KSBpbnRlcm5hbGx5IHVzZSA8Y29kZT51c2VDaGlsZE1hbmFnZXI8L2NvZGU+LCB3aGljaCBpcyBob3cgdGhlIGNoaWxkIGVsZW1lbnRzIGFuZCB0aGUgcGFyZW50IGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cclxuICAgICAgICAgICAgICAgIFRoaXMgbWVhbnMgdGhlcmUgYXJlIHZpcnR1YWxseSBubyByZXN0cmljdGlvbnMgb24gaG93IHRoZSBET00gaXMgc2V0IHVwIGFzIGxvbmcgYXMgeW91IGNhbiBwcm92aWRlIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSA8Y29kZT51c2VMaXN0TmF2aWdhdGlvbkNoaWxkPC9jb2RlPiBob29rIHRoYXQncyByZXR1cm5lZCwgdXN1YWxseSB3aXRoIGEgc2ltcGxlIDxjb2RlPkNvbnRleHQ8L2NvZGU+LlxyXG4gICAgICAgICAgICAgICAgSWYgdGhlIGNoaWxkIGVsZW1lbnQgaXRzZWxmIGhhcyBhIGZvY3VzYWJsZSBlbGVtZW50LCBsaWtlIGEgYnV0dG9uLCBpdCBjYW4gYWxzbyBiZSB3aXJlZCB1cCB0byBkaXNhYmxlIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgRmVlbCBmcmVlIHRvIG5lc3QgdGhlbSB0b28sIGFzIGxvbmcgYXMgeW91IGFyZSBhd2FyZSBvZiB5b3VyIDxjb2RlPkNvbnRleHQ8L2NvZGU+IG1hbmFnZW1lbnQgKGkuZS4gcmVtZW1iZXIgdGhhdCB5b3UgbmVlZCB0byBjcmVhdGUgYSBuZXcgPGNvZGU+Q29udGV4dDwvY29kZT4gZm9yIGVhY2ggdXNlIGNhc2UpLlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDxsYWJlbD4jIG9mIGl0ZW1zPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17Y291bnR9IG1pbj17MH0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpIH19IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzaHVmZmxlKGNoaWxkcmVuKX0+U2h1ZmZsZTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8bGFiZWw+VGFiYmFibGUgaW5kZXg6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RhYmJhYmxlSW5kZXggPz8gdW5kZWZpbmVkfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRUYWJiYWJsZUluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyLCBmYWxzZSk7IH19IC8+PC9sYWJlbD5cclxuXHJcbiAgICAgICAgICAgIDxSb3ZpbmdDaGlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZH0+XHJcbiAgICAgICAgICAgICAgICA8dWwgey4uLnVzZUhhc0ZvY3VzUHJvcHModXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHtcclxuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogQXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZVJvdmluZ1RhYkluZGV4Q2hpbGQgaW5kZXg9e2l9IGtleT17aX0gc2V0U2VsZWN0ZWRJbmRleD17c2V0U2VsZWN0ZWRJbmRleH0gLz5cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0pKCkpXHJcbiAgICAgICAgICAgICAgICB9KSl9PjwvdWw+XHJcbiAgICAgICAgICAgIDwvUm92aW5nQ2hpbGRDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgICAgICB7Y3VycmVudFR5cGVhaGVhZCAmJiA8ZGl2PlR5cGVhaGVhZDoge2N1cnJlbnRUeXBlYWhlYWR9PC9kaXY+fVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSlcclxuXHJcbmNvbnN0IF9QcmVmaXggPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XHJcbmNvbnN0IERlbW9Vc2VSb3ZpbmdUYWJJbmRleENoaWxkID0gbWVtbygoKHsgaW5kZXgsIHNldFNlbGVjdGVkSW5kZXggfTogeyBpbmRleDogbnVtYmVyLCBzZXRTZWxlY3RlZEluZGV4OiBTdGF0ZVVwZGF0ZXI8bnVtYmVyPiB9KSA9PiB7XHJcbiAgICBjb25zdCBoaWRkZW4gPSAoaW5kZXggPT0gNyk7XHJcbiAgICBjb25zdCBbcmFuZG9tV29yZF0gPSB1c2VTdGF0ZSgoKSA9PiBSYW5kb21Xb3Jkc1tpbmRleC8qTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKFJhbmRvbVdvcmRzLmxlbmd0aCAtIDEpKSovXSk7XHJcbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ29udGV4dChSb3ZpbmdDaGlsZENvbnRleHQpO1xyXG4gICAgY29uc3QgdGV4dCA9IGAke3JhbmRvbVdvcmR9IFRoaXMgaXMgaXRlbSAjJHtpbmRleH0ke2hpZGRlbiA/IFwiIChoaWRkZW4pXCIgOiBcIlwifWA7XHJcbiAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSwgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkIH0gfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW4gfSwgc3ViSW5mbzoge30gfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMoe30pO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8bGkgey4uLnByb3BzfSBvbkNsaWNrPXsoKSA9PiBzZXRTZWxlY3RlZEluZGV4KGluZGV4KX0+e3RleHR9ICh7dGFiYmFibGUgPyBcIlRhYmJhYmxlXCIgOiBcIk5vdCB0YWJiYWJsZVwifSwge3NlbGVjdGVkID8gXCJTZWxlY3RlZFwiIDogXCJOb3Qgc2VsZWN0ZWRcIn0pPGlucHV0IHsuLi51c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMoeyB0eXBlOiBcIm51bWJlclwiIH0pIGFzIGFueX0gc3R5bGU9e3sgd2lkdGg6IFwiNWNoXCIgfX0gLz48L2xpPlxyXG4gICAgKVxyXG59KSk7IiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuLi8uLlwiO1xuXG5cbmV4cG9ydCBjb25zdCBEZW1vVXNlVGltZW91dCA9ICgpID0+IHtcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbdHJpZ2dlckluZGV4LCBzZXRUcmlnZ2VySW5kZXhdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBbZmlyZUNvdW50LCBzZXRGaXJlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dCwgdHJpZ2dlckluZGV4LCBjYWxsYmFjazogKCkgPT4gc2V0RmlyZUNvdW50KGkgPT4gKytpKSB9KVxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIDxsYWJlbD5UaW1lb3V0IGR1cmF0aW9uOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aW1lb3V0fSBvbklucHV0PXtlID0+IHNldFRpbWVvdXQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+UmVmcmVzaCBrZXk6IDxpbnB1dCB0eXBlPVwidGV4dFwiIHZhbHVlPXt0cmlnZ2VySW5kZXh9IG9uSW5wdXQ9e2UgPT4gc2V0VHJpZ2dlckluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZSl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+VGhlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZCB7ZmlyZUNvdW50fSB0aW1le2ZpcmVDb3VudCA9PT0gMSA/IFwiXCIgOiBcInNcIn0uPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQsIGgsIHJlbmRlciB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgbWVtbyB9IGZyb20gXCJwcmVhY3QvY29tcGF0XCI7XHJcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlQW5pbWF0aW9uRnJhbWUsIHVzZUFzeW5jSGFuZGxlciwgdXNlRHJhZ2dhYmxlLCB1c2VEcm9wcGFibGUsIHVzZUVsZW1lbnRTaXplLCB1c2VGb2N1c1RyYXAsIHVzZU1lcmdlZFByb3BzLCB1c2VTdGF0ZSB9IGZyb20gXCIuLlwiO1xyXG5pbXBvcnQgeyBFbGVtZW50U2l6ZSB9IGZyb20gXCIuLi91c2UtZWxlbWVudC1zaXplXCI7XHJcbmltcG9ydCB7IHVzZUdyaWROYXZpZ2F0aW9uLCBVc2VHcmlkTmF2aWdhdGlvbkNlbGwsIFVzZUdyaWROYXZpZ2F0aW9uUm93IH0gZnJvbSBcIi4uL3VzZS1ncmlkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi4vdXNlLWhhcy1mb2N1c1wiO1xyXG5pbXBvcnQgeyBEZW1vVXNlSW50ZXJ2YWwgfSBmcm9tIFwiLi9kZW1vcy91c2UtaW50ZXJ2YWxcIjtcclxuaW1wb3J0IHsgRGVtb1VzZVJvdmluZ1RhYkluZGV4IH0gZnJvbSBcIi4vZGVtb3MvdXNlLXJvdmluZy10YWItaW5kZXhcIjtcclxuaW1wb3J0IHsgRGVtb1VzZVRpbWVvdXQgfSBmcm9tIFwiLi9kZW1vcy91c2UtdGltZW91dFwiO1xyXG5pbXBvcnQgeyBQZXJzaXN0ZW50U3RhdGVzIH0gZnJvbSBcIi4uXCJcclxuXHJcbmNvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xyXG5cclxuZGVjbGFyZSBtb2R1bGUgJ3ByZWFjdC1wcm9wLWhlbHBlcnMnIHtcclxuXHJcbn1cclxuXHJcbmNvbnN0IERlbW9Vc2VEcm9wcGFibGUgPSAoKSA9PiB7XHJcbiAgICBjb25zdCB7IGRyb3BwZWRGaWxlcywgZHJvcHBlZFN0cmluZ3MsIGZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHVzZURyb3BwYWJsZVByb3BzLCBkcm9wRXJyb3IgfSA9IHVzZURyb3BwYWJsZTxIVE1MRGl2RWxlbWVudD4oeyBlZmZlY3Q6IFwiY29weVwiIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgcmVmOiBfcmVmIH0gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50Pih7fSwgeyByZWY6IHVzZVJlZjxIVE1MSW5wdXRFbGVtZW50PihudWxsISkgfSlcclxuXHJcbiAgICBjb25zdCBwID0gdXNlRHJvcHBhYmxlUHJvcHMoeyBjbGFzc05hbWU6IFwiZGVtbyBkcm9wcGFibGVcIiB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgey4uLnB9PlxyXG5cclxuICAgICAgICAgICAge2Ryb3BwZWRTdHJpbmdzICE9IG51bGwgJiYgPGRpdj5EYXRhIGRyb3BwZWQ6IDx1bD57KE9iamVjdC5lbnRyaWVzKGRyb3BwZWRTdHJpbmdzKSBhcyBba2V5b2YgdHlwZW9mIHN0cmluZ3NGb3JDb25zaWRlcmF0aW9uLCBzdHJpbmddW10pLm1hcCgoW3R5cGUsIHZhbHVlXSkgPT4gPGxpPnt0eXBlfToge3ZhbHVlfTwvbGk+KX08L3VsPjwvZGl2Pn1cclxuICAgICAgICAgICAge2Ryb3BwZWRGaWxlcyAhPSBudWxsICYmIDxkaXY+RmlsZXMgZHJvcHBlZDogPHRhYmxlPlxyXG4gICAgICAgICAgICAgICAgPHRoZWFkPjx0cj48dGg+TmFtZTwvdGg+PHRoPlNpemU8L3RoPjx0aD5UeXBlPC90aD48dGg+TGFzdCBtb2RpZmllZDwvdGg+PC90cj48L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5Pntkcm9wcGVkRmlsZXMubWFwKGYgPT4gPHRyPjx0ZD57Zi5uYW1lfTwvdGQ+e2YuZGF0YS5ieXRlTGVuZ3RofTx0ZD57Zi50eXBlfTwvdGQ+PHRkPntuZXcgRGF0ZShmLmxhc3RNb2RpZmllZCA/PyAwKX08L3RkPjwvdHI+KX08L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPjwvZGl2Pn1cclxuICAgICAgICAgICAgPGhyIC8+XHJcblxyXG4gICAgICAgICAgICB7c3RyaW5nc0ZvckNvbnNpZGVyYXRpb24gIT0gbnVsbCAmJiA8ZGl2PkRhdGEgYmVpbmcgY29uc2lkZXJlZDogPHVsPntBcnJheS5mcm9tKHN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKS5tYXAodHlwZSA9PiA8bGk+e3R5cGV9PC9saT4pfTwvdWw+PC9kaXY+fVxyXG4gICAgICAgICAgICB7ZmlsZXNGb3JDb25zaWRlcmF0aW9uICE9IG51bGwgJiYgPGRpdj5GaWxlcyBiZWluZyBjb25zaWRlcmVkOiA8dWw+e2ZpbGVzRm9yQ29uc2lkZXJhdGlvbi5tYXAoZiA9PiA8bGk+e0pTT04uc3RyaW5naWZ5KGYpfTwvbGk+KX08L3VsPjwvZGl2Pn1cclxuXHJcbiAgICAgICAgICAgIDxociAvPlxyXG4gICAgICAgICAgICB7ZHJvcEVycm9yICYmIDxkaXY+e2Ryb3BFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZHJvcEVycm9yLm1lc3NhZ2UgOiBKU09OLnN0cmluZ2lmeShkcm9wRXJyb3IpfTwvZGl2Pn1cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufVxyXG5cclxuY29uc3QgRGVtb1VzZURyYWdnYWJsZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IHsgdXNlRHJhZ2dhYmxlUHJvcHMgfSA9IHVzZURyYWdnYWJsZTxIVE1MRGl2RWxlbWVudD4oeyBkYXRhOiB7IFwidGV4dC9wbGFpblwiOiBcIlRoaXMgaXMgY3VzdG9tIGRyYWdnYWJsZSBjb250ZW50IG9mIHR5cGUgdGV4dC9wbGFpbi5cIiB9IH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgey4uLnVzZURyYWdnYWJsZVByb3BzKHsgY2xhc3NOYW1lOiBcImRlbW9cIiB9KX0+XHJcbiAgICAgICAgICAgIERyYWdnYWJsZSBjb250ZW50XHJcbiAgICAgICAgPC9kaXY+KVxyXG59XHJcblxyXG5jb25zdCBEZW1vVXNlRWxlbWVudFNpemVBbmltYXRpb24gPSAoKSA9PiB7XHJcbiAgICBjb25zdCBbaGVpZ2h0LCBzZXRIZWlnaHRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbYW5nbGUsIHNldEFuZ2xlXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgdXNlQW5pbWF0aW9uRnJhbWUoe1xyXG4gICAgICAgIGNhbGxiYWNrOiAoX21zKSA9PiB7XHJcbiAgICAgICAgICAgIHNldEFuZ2xlKGEgPT4gYSArIDAuMDEpXHJcbiAgICAgICAgICAgIHNldEhlaWdodCgoTWF0aC5zaW4oYW5nbGUpICsgMSkgLyAwLjUpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IFtlbGVtZW50U2l6ZSwgc2V0RWxlbWVudFNpemVdID0gdXNlU3RhdGU8RWxlbWVudFNpemUgfCBudWxsPihudWxsKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUVsZW1lbnRTaXplUHJvcHMgfSA9IHVzZUVsZW1lbnRTaXplPEhUTUxEaXZFbGVtZW50Pih7IG9uU2l6ZUNoYW5nZTogc2V0RWxlbWVudFNpemUgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IHsuLi51c2VFbGVtZW50U2l6ZVByb3BzKHsgcmVmOiB1bmRlZmluZWQsIGNsYXNzTmFtZTogXCJkZW1vXCIsIHN0eWxlOiB7IGhlaWdodDogYCR7KGhlaWdodCAqIDEwMCkgKyAxMDB9cHhgIH0gfSl9PlxyXG4gICAgICAgICAgICA8cHJlPntKU09OLnN0cmluZ2lmeShlbGVtZW50U2l6ZSwgbnVsbCwgMil9PC9wcmU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59XHJcblxyXG5cclxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcCA9IG1lbW8oKHsgZGVwdGggfTogeyBkZXB0aD86IG51bWJlciB9KSA9PiB7XHJcblxyXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUZvY3VzVHJhcFByb3BzIH0gPSB1c2VGb2N1c1RyYXA8SFRNTERpdkVsZW1lbnQ+KHsgdHJhcEFjdGl2ZTogYWN0aXZlIH0pO1xyXG4gICAgLy9jb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4UHJvcHMgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxVTGlzdEVsZW1lbnQsIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPih7IHRhYmJhYmxlSW5kZXgsIGZvY3VzT25DaGFuZ2U6IGZhbHNlIH0pO1xyXG5cclxuICAgIGNvbnN0IGRpdlByb3BzID0gdXNlRm9jdXNUcmFwUHJvcHMoeyByZWY6IHVuZGVmaW5lZCwgY2xhc3NOYW1lOiBcImZvY3VzLXRyYXAtZGVtb1wiIH0pO1xyXG4gICAgaWYgKGRlcHRoID09IDIpXHJcbiAgICAgICAgcmV0dXJuIDxkaXYgLz47XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cclxuICAgICAgICAgICAgPGxhYmVsPkFjdGl2ZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e2FjdGl2ZX0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0QWN0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKTsgfX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8ZGl2IHsuLi5kaXZQcm9wc30gPlxyXG4gICAgICAgICAgICAgICAgPERlbW9Vc2VGb2N1c1RyYXBDaGlsZCBhY3RpdmU9e2FjdGl2ZX0gc2V0QWN0aXZlPXtzZXRBY3RpdmV9IGRlcHRoPXtkZXB0aCA/PyAwfSAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuXHJcbmNvbnN0IERlbW9Vc2VGb2N1c1RyYXBDaGlsZCA9IG1lbW8oKHsgc2V0QWN0aXZlLCBhY3RpdmUgfTogeyBhY3RpdmU6IGJvb2xlYW4sIHNldEFjdGl2ZTogKGFjdGl2ZTogYm9vbGVhbikgPT4gdm9pZCwgZGVwdGg6IG51bWJlciB9KSA9PiB7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPD5cclxuICAgICAgICAgICAgPGJ1dHRvbj5CdXR0b24gMTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAyPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDM8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGxhYmVsPkFjdGl2ZTogPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e2FjdGl2ZX0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0QWN0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKTsgfX0gLz48L2xhYmVsPlxyXG5cclxuICAgICAgICA8Lz5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuY29uc3QgRGVtb1VzZUFzeW5jSGFuZGxlcjEgPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcclxuICAgIGNvbnN0IFtkZWJvdW5jZSwgc2V0RGVib3VuY2VdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2hvdWxkVGhyb3csIHNldFNob3VsZFRocm93LCBnZXRTaG91bGRUaHJvd10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IGFzeW5jT25DbGljayA9ICgoX3Y6IHZvaWQsIF9lOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+KSA9PiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiBnZXRTaG91bGRUaHJvdygpID8gcmVqZWN0KCkgOiByZXNvbHZlKCksIHRpbWVvdXQpKSk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgY2FsbENvdW50LFxyXG4gICAgICAgIHNldHRsZUNvdW50LFxyXG4gICAgICAgIGhhc0NhcHR1cmUsXHJcbiAgICAgICAgc3luY0hhbmRsZXIsXHJcbiAgICAgICAgcGVuZGluZyxcclxuICAgICAgICBoYXNFcnJvcixcclxuICAgICAgICByZWplY3RDb3VudCxcclxuICAgICAgICByZXNvbHZlQ291bnRcclxuICAgIH0gPSB1c2VBc3luY0hhbmRsZXI8aC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50Piwgdm9pZD4oYXN5bmNPbkNsaWNrLCB7IGNhcHR1cmU6ICgpID0+IHsgfSwgZGVib3VuY2U6IGRlYm91bmNlID09IDAgPyB1bmRlZmluZWQgOiBkZWJvdW5jZSB9KTtcclxuXHJcbiAgICBjb25zdCBvbkNsaWNrID0gcGVuZGluZyA/IHVuZGVmaW5lZCA6IHN5bmNIYW5kbGVyO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIDxidXR0b24gZGlzYWJsZWQ9e3BlbmRpbmcgJiYgZGlzYWJsZUNvbnNlY3V0aXZlfSBvbkNsaWNrPXtvbkNsaWNrfT5DbGljayBtZSE8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGxhYmVsPlNsZWVwIGZvcjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGltZW91dH0gb25JbnB1dD17ZSA9PiBzZXRUaW1lb3V0KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8bGFiZWw+VGhyb3cgYW4gZXJyb3IgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e3Nob3VsZFRocm93fSBvbklucHV0PXtlID0+IHNldFNob3VsZFRocm93KGUuY3VycmVudFRhcmdldC5jaGVja2VkKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8bGFiZWw+RGlzYWJsZWQgd2hpbGUgcGVuZGluZyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17ZGlzYWJsZUNvbnNlY3V0aXZlfSBvbklucHV0PXtlID0+IHNldERpc2FibGVDb25zZWN1dGl2ZShlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPkRlYm91bmNlOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtkZWJvdW5jZX0gb25JbnB1dD17ZSA9PiBzZXREZWJvdW5jZShlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPHRhYmxlPlxyXG4gICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkZpZWxkPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPlZhbHVlPC90aD5cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgIDx0Ym9keT5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmNhbGxDb3VudDwvdGQ+PHRkPntjYWxsQ291bnR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+c2V0dGxlQ291bnQ8L3RkPjx0ZD57c2V0dGxlQ291bnR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVzb2x2ZUNvdW50PC90ZD48dGQ+e3Jlc29sdmVDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZWplY3RDb3VudDwvdGQ+PHRkPntyZWplY3RDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5oYXNFcnJvcjwvdGQ+PHRkPntoYXNFcnJvci50b1N0cmluZygpfTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmhhc0NhcHR1cmU8L3RkPjx0ZD57aGFzQ2FwdHVyZS50b1N0cmluZygpfTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XHJcbiAgICAgICAgICAgIDwvdGFibGU+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KTtcclxuXHJcbmNvbnN0IERlbW9Vc2VBc3luY0hhbmRsZXIyID0gbWVtbygoKSA9PiB7XHJcblxyXG4gICAgY29uc3QgW3RpbWVvdXQsIHNldFRpbWVvdXRdID0gdXNlU3RhdGUoMTAwMCk7XHJcbiAgICBjb25zdCBbZGVib3VuY2UsIHNldERlYm91bmNlXSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3Nob3VsZFRocm93LCBzZXRTaG91bGRUaHJvdywgZ2V0U2hvdWxkVGhyb3ddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2Rpc2FibGVDb25zZWN1dGl2ZSwgc2V0RGlzYWJsZUNvbnNlY3V0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBbdGV4dCwgc2V0VGV4dF0gPSB1c2VTdGF0ZShcIlwiKTtcclxuXHJcbiAgICBjb25zdCBvbklucHV0QXN5bmMgPSBhc3luYyAodjogc3RyaW5nLCBfZTogYW55KSA9PiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGdldFNob3VsZFRocm93KCkpIHtcclxuICAgICAgICAgICAgcmVqZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzZXRUZXh0KHYpO1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgdGltZW91dCkpO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjYWxsQ291bnQsXHJcbiAgICAgICAgc2V0dGxlQ291bnQsXHJcbiAgICAgICAgaGFzQ2FwdHVyZSxcclxuICAgICAgICBzeW5jSGFuZGxlcixcclxuICAgICAgICBjdXJyZW50Q2FwdHVyZSxcclxuICAgICAgICBwZW5kaW5nLFxyXG4gICAgICAgIGhhc0Vycm9yLFxyXG4gICAgICAgIHJlamVjdENvdW50LFxyXG4gICAgICAgIHJlc29sdmVDb3VudFxyXG4gICAgfSA9IHVzZUFzeW5jSGFuZGxlcjxoLkpTWC5UYXJnZXRlZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+LCBzdHJpbmc+KG9uSW5wdXRBc3luYywgeyBjYXB0dXJlOiAoZTogaC5KU1guVGFyZ2V0ZWRFdmVudDxIVE1MSW5wdXRFbGVtZW50PikgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IHJldHVybiBlLmN1cnJlbnRUYXJnZXQudmFsdWUgfSwgZGVib3VuY2U6IGRlYm91bmNlID09IDAgPyB1bmRlZmluZWQgOiBkZWJvdW5jZSB9KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cclxuICAgICAgICAgICAgPGxhYmVsPkRlbW8gdGV4dDogPGlucHV0IHZhbHVlPXtoYXNDYXB0dXJlID8gY3VycmVudENhcHR1cmUgOiB0ZXh0fSBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e3N5bmNIYW5kbGVyfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxociAvPlxyXG4gICAgICAgICAgICA8bGFiZWw+U2xlZXAgZm9yOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aW1lb3V0fSBvbklucHV0PXtlID0+IHNldFRpbWVvdXQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5UaHJvdyBhbiBlcnJvciA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17c2hvdWxkVGhyb3d9IG9uSW5wdXQ9e2UgPT4gc2V0U2hvdWxkVGhyb3coZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5EaXNhYmxlZCB3aGlsZSBwZW5kaW5nIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e2UgPT4gc2V0RGlzYWJsZUNvbnNlY3V0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8bGFiZWw+RGVib3VuY2U6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2RlYm91bmNlfSBvbklucHV0PXtlID0+IHNldERlYm91bmNlKGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8dGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+RmllbGQ8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+Y2FsbENvdW50PC90ZD48dGQ+e2NhbGxDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5zZXR0bGVDb3VudDwvdGQ+PHRkPntzZXR0bGVDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZXNvbHZlQ291bnQ8L3RkPjx0ZD57cmVzb2x2ZUNvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnJlamVjdENvdW50PC90ZD48dGQ+e3JlamVjdENvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmhhc0Vycm9yPC90ZD48dGQ+e2hhc0Vycm9yLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+Y3VycmVudENhcHR1cmU8L3RkPjx0ZD57Y3VycmVudENhcHR1cmV9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+XCJTYXZlZFwiIGlucHV0PC90ZD48dGQ+e3RleHR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuXHJcbmNvbnN0IERlbW9Gb2N1cyA9IG1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgW2xhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VTdGF0ZTwoRWxlbWVudCkgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IFthY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVN0YXRlPChFbGVtZW50KSB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgW3dpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtsYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2xhc3RGb2N1c2VkSW5uZXIsIHNldExhc3RGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIVE1MRGl2RWxlbWVudD4oe1xyXG4gICAgICAgIG9uRm9jdXNlZENoYW5nZWQ6IHNldEZvY3VzZWQsXHJcbiAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ6IHNldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiBzZXRBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHNldExhc3RBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZTogc2V0V2luZG93Rm9jdXNlZFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIDxoMj51c2VIYXNGb2N1czwvaDI+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLnVzZUhhc0ZvY3VzUHJvcHMoeyBzdHlsZTogeyBib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCIgfSwgdGFiSW5kZXg6IDAgfSl9ID5PdXRlciA8ZGl2IHRhYkluZGV4PXswfSBzdHlsZT17eyBib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCIgfX0+SW5uZXIgZWxlbWVudDwvZGl2PjwvZGl2PlxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgICAgPHVsPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5TdHJpY3RseSBmb2N1c2VkOiB7Zm9jdXNlZC50b1N0cmluZygpfSwge2xhc3RGb2N1c2VkLnRvU3RyaW5nKCl9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+SW5uZXIgZm9jdXNlZDoge2ZvY3VzZWRJbm5lci50b1N0cmluZygpfSwge2xhc3RGb2N1c2VkSW5uZXIudG9TdHJpbmcoKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5XaW5kb3cgZm9jdXNlZDoge3dpbmRvd0ZvY3VzZWQudG9TdHJpbmcoKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5hY3RpdmVFbGVtZW50OiB7YWN0aXZlRWxlbWVudD8udGV4dENvbnRlbnR9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+bGFzdEFjdGl2ZUVsZW1lbnQ6IHtsYXN0QWN0aXZlRWxlbWVudD8udGV4dENvbnRlbnR9PC9saT5cclxuICAgICAgICAgICAgICAgIDwvdWw+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59KVxyXG5cclxuXHJcbmNvbnN0IEdyaWRSb3dDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkTmF2aWdhdGlvblJvdzxIVE1MVGFibGVSb3dFbGVtZW50LCBIVE1MVGFibGVDZWxsRWxlbWVudCwge30sIHt9LCBzdHJpbmcsIHN0cmluZz4+KG51bGwhKTtcclxuY29uc3QgR3JpZENlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkTmF2aWdhdGlvbkNlbGw8SFRNTFRhYmxlQ2VsbEVsZW1lbnQsIHt9LCBzdHJpbmc+PihudWxsISk7XHJcbmV4cG9ydCBjb25zdCBEZW1vVXNlR3JpZCA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFssIHNldExhc3RGb2N1c2VkSW5uZXIsIF9nZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQ+KHsgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogc2V0TGFzdEZvY3VzZWRJbm5lciB9KTtcclxuICAgIGNvbnN0IHsgdXNlR3JpZE5hdmlnYXRpb25Sb3csIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMsIGdyaWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRDb2x1bW4gfSB9ID0gdXNlR3JpZE5hdmlnYXRpb248SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwge30sIHN0cmluZywgc3RyaW5nPih7XHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHt9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHt9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIHs8ZGl2PkN1cnJlbnQgY29sdW1uOiB7Y3VycmVudENvbHVtbn08L2Rpdj59XHJcbiAgICAgICAgICAgIDx0YWJsZSB7Li4ueyBib3JkZXI6IFwiMlwiIH0gYXMge319IHN0eWxlPXt7IHdoaXRlU3BhY2U6IFwibm93cmFwXCIgfX0+XHJcblxyXG4gICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPlJvdyBpcyB0YWJiYWJsZT88L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Q29sdW1uIDE8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Q29sdW1uIDI8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5IHsuLi51c2VIYXNGb2N1c1Byb3BzKHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMoe30pKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPEdyaWRSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkTmF2aWdhdGlvblJvd30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9Vc2VHcmlkUm93IGluZGV4PXtpfSBrZXk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvR3JpZFJvd0NvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSlcclxuXHJcbmNvbnN0IF9QcmVmaXggPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XHJcbmNvbnN0IERlbW9Vc2VHcmlkUm93ID0gbWVtbygoKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcclxuICAgIGNvbnN0IFtfcmFuZG9tV29yZF0gPSB1c2VTdGF0ZSgoKSA9PiBSYW5kb21Xb3Jkc1tpbmRleC8qTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKFJhbmRvbVdvcmRzLmxlbmd0aCAtIDEpKSovXSk7XHJcbiAgICBjb25zdCB1c2VHcmlkUm93ID0gdXNlQ29udGV4dChHcmlkUm93Q29udGV4dCk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXHJcbiAgICAgICAgYXNDaGlsZFJvdzogeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9IH0sXHJcbiAgICB9ID0gdXNlR3JpZFJvdyh7XHJcbiAgICAgICAgYXNDaGlsZFJvd09mU2VjdGlvbjogeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dDogXCJcIiB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW46IGluZGV4ID09IDMgfSwgc3ViSW5mbzoge30gfSxcclxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHsgbGluZWFyTmF2aWdhdGlvbjoge30sIGxpc3ROYXZpZ2F0aW9uOiB7fSwgcm92aW5nVGFiSW5kZXg6IHt9LCB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzKHt9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxHcmlkQ2VsbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUdyaWROYXZpZ2F0aW9uQ2VsbH0+XHJcbiAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZUdyaWRDZWxsIGluZGV4PXtpfSBrZXk9e2l9IHJvdz17aW5kZXh9IHJvd0lzVGFiYmFibGU9e3RhYmJhYmxlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICA8L0dyaWRDZWxsQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKVxyXG59KSk7XHJcblxyXG5jb25zdCBEZW1vVXNlR3JpZENlbGwgPSAoKHsgaW5kZXgsIHJvdywgcm93SXNUYWJiYWJsZSB9OiB7IGluZGV4OiBudW1iZXIsIHJvdzogbnVtYmVyLCByb3dJc1RhYmJhYmxlOiBib29sZWFuIH0pID0+IHtcclxuICAgIGlmIChyb3cgPj0gNiAmJiByb3cgJSAyID09IDAgJiYgaW5kZXggPiAxKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGxldCBoaWRkZW5UZXh0ID0gKHJvdyA9PT0gMykgPyBcIiAocm93IGhpZGRlbilcIiA6IFwiXCJcclxuXHJcbiAgICBjb25zdCB1c2VHcmlkQ2VsbCA9IHVzZUNvbnRleHQoR3JpZENlbGxDb250ZXh0KTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZTogY2VsbElzVGFiYmFibGUgfVxyXG4gICAgfSA9IHVzZUdyaWRDZWxsKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0OiBcIlwiIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4IH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuOiBmYWxzZSB9LFxyXG4gICAgICAgIHN1YkluZm86IHt9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyh7fSkgYXMgYW55O1xyXG5cclxuICAgIGNvbnN0IHQgPSAoY2VsbElzVGFiYmFibGUgPyBcIihUYWJiYWJsZSlcIiA6IFwiKE5vdCB0YWJiYWJsZSlcIilcclxuXHJcbiAgICBpZiAoaW5kZXggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIDx0ZCB7Li4ucHJvcHN9Pntyb3dJc1RhYmJhYmxlLnRvU3RyaW5nKCl9PC90ZD5cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChyb3cgPCA2IHx8IHJvdyAlIDIgIT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30+R3JpZCBjZWxsICN7aW5kZXggKyAxfSB7dH17aGlkZGVuVGV4dH08L3RkPlxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkPjxsYWJlbD48aW5wdXQgIHsuLi5wcm9wc30gdHlwZT1cImNoZWNrYm94XCIgLz4gVGVzdCBpbnB1dCB7dH17aGlkZGVuVGV4dH08L2xhYmVsPjwvdGQ+XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30gY29sU3Bhbj17Mn0+R3JpZCBjZWxsICN7aW5kZXggKyAxfSwgc3BhbiAyIHt0fXtoaWRkZW5UZXh0fTwvdGQ+XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pXHJcblxyXG5jb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cImZsZXhcIiBzdHlsZT17eyBmbGV4V3JhcDogXCJ3cmFwXCIgfX0+XHJcbiAgICAgICAgPERlbW9Gb2N1cyAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlR3JpZCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlVGltZW91dCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlSW50ZXJ2YWwgLz5cclxuICAgICAgICA8aHIgLz5cclxuICAgICAgICA8RGVtb1VzZVJvdmluZ1RhYkluZGV4IC8+XHJcbiAgICAgICAgPGhyIC8+XHJcblxyXG5cclxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlQXN5bmNIYW5kbGVyMSAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlQXN5bmNIYW5kbGVyMiAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cclxuICAgICAgICA8aHIgLz5cclxuICAgICAgICA8RGVtb1VzZUVsZW1lbnRTaXplQW5pbWF0aW9uIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPGlucHV0IC8+XHJcbiAgICA8L2Rpdj5cclxufVxyXG5cclxucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIHJlbmRlcig8Q29tcG9uZW50IC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJvb3RcIikhKTtcclxufSlcclxuIl0sIm5hbWVzIjpbInNsaWNlIiwib3B0aW9ucyIsInZub2RlSWQiLCJyZXJlbmRlclF1ZXVlIiwicHJldkRlYm91bmNlIiwiaSIsIkVNUFRZX09CSiIsIkVNUFRZX0FSUiIsIklTX05PTl9ESU1FTlNJT05BTCIsImFzc2lnbiIsIm9iaiIsInByb3BzIiwicmVtb3ZlTm9kZSIsIm5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImNoaWxkcmVuIiwia2V5IiwicmVmIiwibm9ybWFsaXplZFByb3BzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2FsbCIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsImNyZWF0ZVZOb2RlIiwib3JpZ2luYWwiLCJ2bm9kZSIsImNvbnN0cnVjdG9yIiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwiZ2V0RG9tU2libGluZyIsImNoaWxkSW5kZXgiLCJpbmRleE9mIiwic2libGluZyIsInVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIiwiY2hpbGQiLCJiYXNlIiwiZW5xdWV1ZVJlbmRlciIsImMiLCJwdXNoIiwicHJvY2VzcyIsImRlYm91bmNlUmVuZGVyaW5nIiwic2V0VGltZW91dCIsInF1ZXVlIiwic29ydCIsImEiLCJiIiwic29tZSIsImNvbXBvbmVudCIsImNvbW1pdFF1ZXVlIiwib2xkVk5vZGUiLCJvbGREb20iLCJwYXJlbnREb20iLCJkaWZmIiwib3duZXJTVkdFbGVtZW50IiwiY29tbWl0Um9vdCIsImRpZmZDaGlsZHJlbiIsInJlbmRlclJlc3VsdCIsIm5ld1BhcmVudFZOb2RlIiwib2xkUGFyZW50Vk5vZGUiLCJnbG9iYWxDb250ZXh0IiwiaXNTdmciLCJleGNlc3NEb21DaGlsZHJlbiIsImlzSHlkcmF0aW5nIiwiaiIsImNoaWxkVk5vZGUiLCJuZXdEb20iLCJmaXJzdENoaWxkRG9tIiwicmVmcyIsIm9sZENoaWxkcmVuIiwib2xkQ2hpbGRyZW5MZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJyZW9yZGVyQ2hpbGRyZW4iLCJwbGFjZUNoaWxkIiwidW5tb3VudCIsImFwcGx5UmVmIiwidG1wIiwidG9DaGlsZEFycmF5Iiwib3V0IiwibmV4dERvbSIsInNpYkRvbSIsIm91dGVyIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImRpZmZQcm9wcyIsImRvbSIsIm5ld1Byb3BzIiwib2xkUHJvcHMiLCJoeWRyYXRlIiwic2V0UHJvcGVydHkiLCJzZXRTdHlsZSIsInN0eWxlIiwidmFsdWUiLCJ0ZXN0IiwibmFtZSIsIm9sZFZhbHVlIiwidXNlQ2FwdHVyZSIsIm8iLCJjc3NUZXh0IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiX2xpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudFByb3h5Q2FwdHVyZSIsImV2ZW50UHJveHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImV2ZW50IiwibmV3Vk5vZGUiLCJpc05ldyIsIm9sZFN0YXRlIiwic25hcHNob3QiLCJjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24iLCJwcm92aWRlciIsImNvbXBvbmVudENvbnRleHQiLCJyZW5kZXJIb29rIiwiY291bnQiLCJuZXdUeXBlIiwiY29udGV4dFR5cGUiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJkb1JlbmRlciIsInN1YiIsInN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiZm9yRWFjaCIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImRpZmZFbGVtZW50Tm9kZXMiLCJkaWZmZWQiLCJyb290IiwiY2IiLCJvbGRIdG1sIiwibmV3SHRtbCIsIm5vZGVUeXBlIiwibG9jYWxOYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsImlzIiwiZGF0YSIsImNoaWxkTm9kZXMiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImF0dHJpYnV0ZXMiLCJpbm5lckhUTUwiLCJjaGVja2VkIiwiY3VycmVudCIsInBhcmVudFZOb2RlIiwic2tpcFJlbW92ZSIsInIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInRoaXMiLCJyZXBsYWNlTm9kZSIsImZpcnN0Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwiY29udGV4dElkIiwiQ29uc3VtZXIiLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInN1YnMiLCJjdHgiLCJfcHJvcHMiLCJvbGQiLCJzcGxpY2UiLCJlcnJvciIsImVycm9ySW5mbyIsImN0b3IiLCJoYW5kbGVkIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwic2V0U3RhdGUiLCJjb21wb25lbnREaWRDYXRjaCIsImlzVmFsaWRFbGVtZW50IiwidXBkYXRlIiwiY2FsbGJhY2siLCJzIiwiZm9yY2VVcGRhdGUiLCJfX3NlbGYiLCJfX3NvdXJjZSIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRDb21wb25lbnQiLCJwcmV2aW91c0NvbXBvbmVudCIsInByZXZSYWYiLCJjdXJyZW50SG9vayIsImFmdGVyUGFpbnRFZmZlY3RzIiwiRU1QVFkiLCJvbGRCZWZvcmVEaWZmIiwib2xkQmVmb3JlUmVuZGVyIiwib2xkQWZ0ZXJEaWZmIiwib2xkQ29tbWl0Iiwib2xkQmVmb3JlVW5tb3VudCIsImdldEhvb2tTdGF0ZSIsImluZGV4IiwiaG9va3MiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJhY3Rpb24iLCJuZXh0VmFsdWUiLCJ1c2VFZmZlY3QiLCJhcmdzIiwiYXJnc0NoYW5nZWQiLCJfcGVuZGluZ0FyZ3MiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwiZmFjdG9yeSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCJzaGlmdCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJob29rSXRlbSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJhZiIsImRvbmUiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiSEFTX1JBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZmlsdGVyIiwiaGFzRXJyb3JlZCIsImhvb2siLCJjb21wIiwiY2xlYW51cCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwiZiIsInNoYWxsb3dEaWZmZXJzIiwiUHVyZUNvbXBvbmVudCIsInAiLCJtZW1vIiwiY29tcGFyZXIiLCJzaG91bGRVcGRhdGUiLCJuZXh0UHJvcHMiLCJ1cGRhdGVSZWYiLCJNZW1vZWQiLCJkaXNwbGF5TmFtZSIsImlzUmVhY3RDb21wb25lbnQiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIm9sZERpZmZIb29rIiwiRm9yd2FyZGVkIiwib2xkQ2F0Y2hFcnJvciIsInRoZW4iLCJvbGRVbm1vdW50IiwiU3VzcGVuc2UiLCJfc3VzcGVuZGVycyIsInN1c3BlbmRlZCIsIlN1c3BlbnNlTGlzdCIsIl9uZXh0IiwiX21hcCIsInByb21pc2UiLCJzdXNwZW5kaW5nVk5vZGUiLCJzdXNwZW5kaW5nQ29tcG9uZW50IiwicmVzb2x2ZSIsInJlc29sdmVkIiwib25SZXNvbHZlZCIsIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwic3VzcGVuZGVkVk5vZGUiLCJyZW1vdmVPcmlnaW5hbCIsImRldGFjaGVkUGFyZW50Iiwib3JpZ2luYWxQYXJlbnQiLCJtYXAiLCJwb3AiLCJ3YXNIeWRyYXRpbmciLCJkZXRhY2hlZENvbXBvbmVudCIsImRldGFjaGVkQ2xvbmUiLCJlZmZlY3QiLCJmYWxsYmFjayIsImxpc3QiLCJkZWxldGUiLCJyZXZlYWxPcmRlciIsInNpemUiLCJkZWxlZ2F0ZWQiLCJnZXQiLCJ1bnN1c3BlbmQiLCJ3cmFwcGVkVW5zdXNwZW5kIiwiTWFwIiwicmV2ZXJzZSIsInNldCIsIl90aGlzIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiQ0FNRUxfUFJPUFMiLCJJU19ET00iLCJvbkNoYW5nZUlucHV0VHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwidiIsIndyaXRhYmxlIiwib2xkRXZlbnRIb29rIiwiZW1wdHkiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwZXJzaXN0IiwibmF0aXZlRXZlbnQiLCJjbGFzc05hbWVEZXNjcmlwdG9yIiwiY2xhc3MiLCJvbGRWTm9kZUhvb2siLCJub25DdXN0b21FbGVtZW50IiwibXVsdGlwbGUiLCJzZWxlY3RlZCIsImNsYXNzTmFtZSIsImVudW1lcmFibGUiLCIkJHR5cGVvZiIsIlVuc2V0Iiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJGVU5DX0VSUk9SX1RFWFQiLCJ1c2VTdGF0ZVAiLCJpZGVudGl0eSIsInVzZUVmZmVjdE5hdGl2ZSIsInVzZUxheW91dEVmZmVjdE5hdGl2ZSIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsIk5vRWxlbWVudCIsIkVsZW1lbnQiLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJnZXRSb290Tm9kZSIsImVsZW1lbnQiLCJvd25lckRvY3VtZW50IiwiaXNJbnB1dCIsInRhZ05hbWUiLCJpc0hpZGRlbklucHV0IiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJhcHBseSIsImlzWmVyb0FyZWEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImlzSGlkZGVuIiwiZGlzcGxheUNoZWNrIiwiZ2V0U2hhZG93Um9vdCIsImdldENvbXB1dGVkU3R5bGUiLCJ2aXNpYmlsaXR5IiwiaXNEaXJlY3RTdW1tYXJ5Iiwibm9kZVVuZGVyRGV0YWlscyIsInBhcmVudEVsZW1lbnQiLCJub2RlUm9vdEhvc3QiLCJob3N0Iiwibm9kZUlzQXR0YWNoZWQiLCJjb250YWlucyIsIm9yaWdpbmFsTm9kZSIsInJvb3ROb2RlIiwic2hhZG93Um9vdCIsImFzc2lnbmVkU2xvdCIsImdldENsaWVudFJlY3RzIiwiaXNEaXNhYmxlZEZyb21GaWVsZHNldCIsImRpc2FibGVkIiwiaXRlbSIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUiLCJmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciIsImNvbmNhdCIsImpvaW4iLCJpc0ZvY3VzYWJsZSIsIkVycm9yIiwiYXJnc1RhZyIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZnVuY1RhZyIsImgiLCJzaHVmZmxlIiwibG9kYXNoU2h1ZmZsZSIsIl9qc3hzIiwiX2pzeCIsIlJhbmRvbVdvcmRzIl0sIm1hcHBpbmdzIjoiOzs7QUEwQmFBLFFBQUFBLENBQUFBLENDZlBDLEdDUkZDLENBQUFBLEdBQUFBLENDdUtBQyxHQUFBQSxDQVdBQyxHQ25MT0MsQ0FBQUEsR0FBQUEsQ0NGRUMsR0FBWSxDQUFBLEVBQUEsQ0FDWkMsR0FBWSxDQUFBLEVBQUEsQ0FDWkMsR0FBcUIsQ0FBQSxvRUxPM0IsU0FBU0MsR0FBQUEsQ0FBT0MsQ0FBS0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFFdEIsSUFBSU4sQ0FBQUEsSUFBS00sQ0FBT0QsQ0FBQUEsQ0FBQUEsQ0FBSUwsQ0FBS00sQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTU4sQ0FDUEssQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FTdkIsU0FBU0UsR0FB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QVMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFFLENBQUEsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQSxNQUFBLEVBQVMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RILE1BQU0saUJBQWlCLEdBQUcsV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQSxDQUFFLENBQUMsSUFBSSxTQUFTLEdBQUcsU0FBUyxJQUFJLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUEsQ0FBRSxDQUFFLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFTLE1BQUEsRUFBQSxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFFLENBQUMsQ0FBQyxDQUFDO0lBRzNMLFlBQUEsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsU0FBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQztJQUNySCxZQUFBLE1BQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLFNBQVMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFFLENBQUEsQ0FBQyxJQUFJLENBQUMsRUFBRSxHQUFHLENBQUMsR0FBRyxXQUFXLENBQUMsQ0FBQSxNQUFBLEVBQVMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFDLENBQUM7Z0JBQ3JILE1BQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQSxDQUFFLENBQUMsSUFBSSxTQUFTLEdBQUcsU0FBUyxJQUFJLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFB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Q0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUU7SUFDNUIsRUFBRSxPQUFPLEtBQUssSUFBSSxJQUFJLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2RTs7SUMxQkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLElBQUksQ0FBQyxNQUFNLEVBQUU7SUFDdEIsRUFBRSxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3hFOztJQy9CQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxNQUFNLENBQUMsTUFBTSxFQUFFO0lBQ3hCLEVBQUUsT0FBTyxNQUFNLElBQUksSUFBSSxHQUFHLEVBQUUsR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQ2hFOztJQzVCQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsV0FBVyxDQUFDLFVBQVUsRUFBRTtJQUNqQyxFQUFFLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQ3pDOztJQ1JBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lB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QUUsS0FBSyxDQUFDLEtBQUtELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBSyxJQUFJLEVBQUksSUFBQSxFQUFBLEtBQUssSUFBTSxDQUFDLEVBQUEsQ0FBTSxJQUFNLEVBQ25NLFlBQVksSUFBSSxJQUFJLElBQUlBLDJDQUFvQkEsR0FDekMsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBT0QsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLE1BQUEsRUFBQSxDQUFhLEVBQUFBLEdBQWEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsTUFBQSxFQUFBLENBQUEsRUFBQUEsK0JBQWEsRUFBQUEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxlQUFBLEVBQUEsQ0FBc0IsSUFBSyxFQUFRLENBQUEsRUFDckZBLHlCQUFRLFlBQVksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJRCx1QkFBSUMsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFDLENBQUMsSUFBSSxHQUFNLEVBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUNBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssQ0FBQyxDQUFDLElBQUksR0FBTSxFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxZQUFZLElBQUksQ0FBQyxDQUFDLEVBQU0sQ0FBQSxDQUFBLEVBQUEsQ0FBSyxDQUFDLEVBQVMsQ0FBQSxDQUFBLEVBQUEsQ0FDMUksSUFBTSxFQUNkQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBTSxFQUVMLHVCQUF1QixJQUFJLElBQUksSUFBSUQsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLHlCQUFBLEVBQTRCQyxzQkFBSyxLQUFLLENBQUMsSUFBSSxDQUFDLHVCQUF1QixDQUFDLENBQUMsR0FBRyxDQUFDLElBQUksSUFBSUEsc0JBQUssSUFBSSxFQUFBLENBQU0sQ0FBQyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQU0sRUFDaEoscUJBQXFCLElBQUksSUFBSSxJQUFJRCxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsMEJBQUEsRUFBNkJDLHNCQUFLLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUlBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsRUFBQSxDQUFNLENBQUMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFNLEVBRTVJQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNMLFNBQVMsSUFBSUEsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFBLFFBQUEsRUFBTSxTQUFTLFlBQVksS0FBSyxHQUFHLFNBQVMsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFBTyxDQUFBLENBQUEsRUFBQSxDQUNuRyxFQUNUO0lBQ0wsQ0FBQyxDQUFBO0lBRUQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFLO0lBQzFCLElBQUEsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEdBQUcsWUFBWSxDQUFpQixFQUFFLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxzREFBc0QsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUcvSSxJQUFBLFFBQ0lBLEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxHQUFTLGlCQUFpQixDQUFDLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDLEVBRTNDLFFBQUEsRUFBQSxtQkFBQSxFQUFBLENBQUEsRUFBQztJQUNmLENBQUMsQ0FBQTtJQUVELE1BQU0sMkJBQTJCLEdBQUcsTUFBSztRQUNyQyxNQUFNLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4QyxNQUFNLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUN0QyxJQUFBLGlCQUFpQixDQUFDO0lBQ2QsUUFBQSxRQUFRLEVBQUUsQ0FBQyxHQUFHLEtBQUk7Z0JBQ2QsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUE7SUFDdkIsWUFBQSxTQUFTLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQzthQUMxQztJQUNKLEtBQUEsQ0FBQyxDQUFDO1FBRUgsTUFBTSxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsR0FBRyxRQUFRLENBQXFCLElBQUksQ0FBQyxDQUFDO0lBRXpFLElBQUEsTUFBTSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsY0FBYyxDQUFpQixFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO1FBRWpHLFFBQ0lBLGdCQUFTLG1CQUFtQixDQUFDLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxFQUFFLE1BQU0sRUFBRSxDQUFBLEVBQUcsQ0FBQyxNQUFNLEdBQUcsR0FBRyxJQUFJLEdBQUcsQ0FBSSxFQUFBLENBQUEsRUFBRSxFQUFFLENBQUMsRUFBQSxRQUFBLEVBQy9HQSx1QkFBTSxJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLEVBQUEsQ0FBTyxFQUMvQyxDQUFBLEVBQ1I7SUFDTixDQUFDLENBQUE7SUFHRCxNQUFNLGdCQUFnQixHQUFHOUksQ0FBSSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQXNCLEtBQUk7UUFFNUQsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFNUMsSUFBQSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxZQUFZLENBQWlCLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUM7O0lBR25GLElBQUEsTUFBTSxRQUFRLEdBQUcsaUJBQWlCLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxDQUFDLENBQUM7UUFDckYsSUFBSSxLQUFLLElBQUksQ0FBQztJQUNWLFFBQUEsT0FBTzhJLGNBQU8sQ0FBQztJQUVuQixJQUFBLFFBQ0lELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBSyxTQUFTLEVBQUMsTUFBTSxFQUFBLFFBQUEsRUFBQSxDQUNqQkEsR0FBZSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLFVBQUEsRUFBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFPLElBQUksRUFBQyxVQUFVLEVBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFNLEVBQUEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxFQUFBLENBQUksQ0FBUSxFQUFBLENBQUEsRUFDNUlBLEdBQVMsQ0FBQSxLQUFBLEVBQUEsRUFBQSxHQUFBLFFBQVEsRUFDYixRQUFBLEVBQUFBLEdBQUEsQ0FBQyxxQkFBcUIsRUFBQyxFQUFBLE1BQU0sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsS0FBSyxJQUFJLENBQUMsRUFBQSxDQUFJLEVBQ2hGLENBQUEsQ0FBQSxFQUFBLENBQ0osRUFDUjtJQUNOLENBQUMsQ0FBQyxDQUFDO0lBR0gsTUFBTSxxQkFBcUIsR0FBRzlJLENBQUksQ0FBQyxDQUFDLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBNEUsS0FBSTtRQUduSSxRQUNJNkksc0JBQ0lDLEdBQXlCLENBQUEsUUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFBLEVBQ3pCQSx1Q0FBeUIsRUFDekJBLEdBQUEsQ0FBQSxRQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsVUFBQSxFQUFBLENBQXlCLEVBQ3pCRCxHQUFlLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsVUFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQU0sRUFBQSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FBUSxDQUU3SSxFQUFBLENBQUEsRUFDTDtJQUNOLENBQUMsQ0FBQyxDQUFDO0lBRUgsTUFBTSxvQkFBb0IsR0FBRzlJLENBQUksQ0FBQyxNQUFLO1FBRW5DLE1BQU0sQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzdDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDLElBQUEsTUFBTSxDQUFDLFdBQVcsRUFBRSxjQUFjLEVBQUUsY0FBYyxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ3RFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxxQkFBcUIsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVwRSxNQUFNLFlBQVksSUFBSSxDQUFDLEVBQVEsRUFBRSxFQUErQyxLQUFLLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQU0sY0FBYyxFQUFFLEdBQUcsTUFBTSxFQUFFLEdBQUcsT0FBTyxFQUFFLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hNLE1BQU0sRUFDRixTQUFTLEVBQ1QsV0FBVyxFQUNYLFVBQVUsRUFDVixXQUFXLEVBQ1gsT0FBTyxFQUNQLFFBQVEsRUFDUixXQUFXLEVBQ1gsWUFBWSxFQUNmLEdBQUcsZUFBZSxDQUFvRCxZQUFZLEVBQUUsRUFBRSxPQUFPLEVBQUUsTUFBSyxHQUFJLEVBQUUsUUFBUSxFQUFFLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxHQUFHLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFFN0osTUFBTSxPQUFPLEdBQUcsT0FBTyxHQUFHLFNBQVMsR0FBRyxXQUFXLENBQUM7UUFFbEQsUUFDSTZJLGFBQUssU0FBUyxFQUFDLE1BQU0sRUFDakIsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxRQUFBLEVBQUEsRUFBUSxRQUFRLEVBQUUsT0FBTyxJQUFJLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxPQUFPLDBCQUFvQixFQUNyRkQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGFBQUEsRUFBa0JDLGVBQU8sSUFBSSxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEVBQUEsQ0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUMxSEQsR0FBc0IsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxpQkFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FBUSxFQUNwSUQsR0FBOEIsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSx5QkFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxxQkFBcUIsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxHQUFJLENBQVEsRUFBQSxDQUFBLEVBQzFKRCx3Q0FBaUJDLEdBQU8sQ0FBQSxPQUFBLEVBQUEsRUFBQSxJQUFJLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUMzSEQsMEJBQ0lDLEdBQ0ksQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUFELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FDSUMsZ0NBQWMsRUFDZEEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxPQUFBLEVBQUEsQ0FBYyxJQUNiLEVBQ0QsQ0FBQSxFQUNSRCwwQkFDSUEsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFdBQUEsRUFBQSxDQUFrQixFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFNBQVMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLEVBQy9DRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUlDLHNDQUFvQixFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLFdBQVcsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLEVBQ25ERCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsY0FBQSxFQUFBLENBQXFCLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsWUFBWSxHQUFNLENBQUssRUFBQSxDQUFBLEVBQ3JERCx1QkFBSUMsR0FBb0IsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsYUFBQSxFQUFBLENBQUEsRUFBQUEsc0JBQUssV0FBVyxFQUFBLENBQU0sQ0FBSyxFQUFBLENBQUEsRUFDbkRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxVQUFBLEVBQUEsQ0FBaUIsRUFBQUEsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxRQUFRLENBQUMsUUFBUSxFQUFFLEdBQU0sQ0FBSyxFQUFBLENBQUEsRUFDeERELHVCQUFJQyxHQUFtQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxZQUFBLEVBQUEsQ0FBQSxFQUFBQSxzQkFBSyxVQUFVLENBQUMsUUFBUSxFQUFFLEVBQUEsQ0FBTSxJQUFLLENBQ3hELEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FDSixDQUNOLEVBQUEsQ0FBQSxFQUNSO0lBQ04sQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLG9CQUFvQixHQUFHOUksQ0FBSSxDQUFDLE1BQUs7UUFFbkMsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0MsTUFBTSxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUMsSUFBQSxNQUFNLENBQUMsV0FBVyxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLHFCQUFxQixDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXBFLE1BQU0sQ0FBQyxJQUFJLEVBQUUsT0FBTyxDQUFDLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBRXJDLE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBUyxFQUFFLEVBQU8sS0FBSyxJQUFJLE9BQU8sQ0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLEtBQUssTUFBTSxDQUFDLFVBQVUsQ0FBQyxNQUFLO1lBQzdHLElBQUksY0FBYyxFQUFFLEVBQUU7SUFDbEIsWUFBQSxNQUFNLEVBQUUsQ0FBQztJQUNaLFNBQUE7SUFDSSxhQUFBO2dCQUNELE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNYLFlBQUEsT0FBTyxFQUFFLENBQUM7SUFDYixTQUFBO0lBQ0wsS0FBQyxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFFYixJQUFBLE1BQU0sRUFDRixTQUFTLEVBQ1QsV0FBVyxFQUNYLFVBQVUsRUFDVixXQUFXLEVBQ1gsY0FBYyxFQUNkLE9BQU8sRUFDUCxRQUFRLEVBQ1IsV0FBVyxFQUNYLFlBQVksRUFDZixHQUFHLGVBQWUsQ0FBZ0QsWUFBWSxFQUFFLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBd0MsS0FBTyxFQUFBLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUEsRUFBRSxFQUFFLFFBQVEsRUFBRSxRQUFRLElBQUksQ0FBQyxHQUFHLFNBQVMsR0FBRyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBR2xQLFFBQ0k2SSxhQUFLLFNBQVMsRUFBQyxNQUFNLEVBQ2pCLFFBQUEsRUFBQSxDQUFBQSxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsYUFBQSxFQUFrQkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLEtBQUssRUFBRSxVQUFVLEdBQUcsY0FBYyxHQUFHLElBQUksRUFBRSxRQUFRLEVBQUUsT0FBTyxJQUFJLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUksQ0FBQSxDQUFBLEVBQUEsQ0FBUSxFQUM3SUEsR0FBTSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQUEsRUFDTkQsR0FBa0IsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxhQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsR0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUMxSEQsR0FBc0IsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxpQkFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksY0FBYyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUEsQ0FBSSxJQUFRLEVBQ3BJRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEseUJBQUEsRUFBOEJDLEdBQU8sQ0FBQSxPQUFBLEVBQUEsRUFBQSxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEVBQUEsQ0FBSSxJQUFRLEVBQzFKRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsWUFBQSxFQUFpQkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLElBQUksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxFQUFBLENBQUksSUFBUSxFQUMzSEQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQyxHQUNJLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQ0lDLEdBQWMsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsT0FBQSxFQUFBLENBQUEsRUFDZEEsZ0NBQWMsQ0FDYixFQUFBLENBQUEsRUFBQSxDQUNELEVBQ1JELEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FDSUEsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFdBQUEsRUFBQSxDQUFrQixFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFNBQVMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLEVBQy9DRCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUlDLHNDQUFvQixFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLFdBQVcsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLEVBQ25ERCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsY0FBQSxFQUFBLENBQXFCLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssWUFBWSxFQUFBLENBQU0sSUFBSyxFQUNyREQsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFJQyxHQUFvQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxhQUFBLEVBQUEsQ0FBQSxFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFdBQVcsR0FBTSxDQUFLLEVBQUEsQ0FBQSxFQUNuREQsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFpQixFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLFFBQVEsQ0FBQyxRQUFRLEVBQUUsRUFBQSxDQUFNLENBQUssRUFBQSxDQUFBLEVBQ3hERCx1QkFBSUMsR0FBdUIsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsZ0JBQUEsRUFBQSxDQUFBLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsY0FBYyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDekRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxpQkFBQSxFQUFBLENBQXNCLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssSUFBSSxFQUFBLENBQU0sSUFBSyxDQUMxQyxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQ0osQ0FDTixFQUFBLENBQUEsRUFDUjtJQUNOLENBQUMsQ0FBQyxDQUFDO0lBR0gsTUFBTSxTQUFTLEdBQUc5SSxDQUFJLENBQUMsTUFBSztRQUN4QixNQUFNLENBQUMsaUJBQWlCLEVBQUUsb0JBQW9CLENBQUMsR0FBRyxRQUFRLENBQW1CLElBQUksQ0FBQyxDQUFDO1FBQ25GLE1BQU0sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQW1CLElBQUksQ0FBQyxDQUFDO1FBQzNFLE1BQU0sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDMUQsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDOUMsTUFBTSxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDeEQsTUFBTSxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEQsTUFBTSxDQUFDLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hFLElBQUEsTUFBTSxFQUFFLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxDQUFpQjtJQUNyRCxRQUFBLGdCQUFnQixFQUFFLFVBQVU7SUFDNUIsUUFBQSxxQkFBcUIsRUFBRSxlQUFlO0lBQ3RDLFFBQUEsb0JBQW9CLEVBQUUsY0FBYztJQUNwQyxRQUFBLHlCQUF5QixFQUFFLG1CQUFtQjtJQUM5QyxRQUFBLHFCQUFxQixFQUFFLGdCQUFnQjtJQUN2QyxRQUFBLHlCQUF5QixFQUFFLG9CQUFvQjtJQUMvQyxRQUFBLHFCQUFxQixFQUFFLGdCQUFnQjtJQUMxQyxLQUFBLENBQUMsQ0FBQztJQUNILElBQUEsUUFDSTZJLEdBQUssQ0FBQSxLQUFBLEVBQUEsRUFBQSxLQUFLLEVBQUMsTUFBTSxFQUFBLFFBQUEsRUFBQSxDQUNiQyxzQ0FBb0IsRUFDcEJELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxHQUFTLGdCQUFnQixDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFFLEVBQUUsUUFBUSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUEsUUFBQSxFQUFBLENBQUEsUUFBQSxFQUFTQyxhQUFLLFFBQVEsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixFQUFFLDhCQUFxQixDQUFNLEVBQUEsQ0FBQSxFQUMxS0EsdUJBQ0lELEdBQ0ksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLG9CQUFBLEVBQXVCLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBQSxJQUFBLEVBQUksV0FBVyxDQUFDLFFBQVEsRUFBRSxDQUFNLEVBQUEsQ0FBQSxFQUN6RUEsMENBQW9CLFlBQVksQ0FBQyxRQUFRLEVBQUUsRUFBQSxJQUFBLEVBQUksZ0JBQWdCLENBQUMsUUFBUSxFQUFFLENBQU0sRUFBQSxDQUFBLEVBQ2hGQSwyQ0FBcUIsYUFBYSxDQUFDLFFBQVEsRUFBRSxDQUFBLEVBQUEsQ0FBTSxFQUNuREEsR0FBb0IsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxpQkFBQSxFQUFBLGFBQWEsRUFBRSxXQUFXLENBQUEsRUFBQSxDQUFNLEVBQ3BEQSxHQUF3QixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLHFCQUFBLEVBQUEsaUJBQWlCLEVBQUUsV0FBVyxDQUFBLEVBQUEsQ0FBTSxJQUMzRCxFQUNILENBQUEsQ0FBQSxFQUFBLENBQ0osRUFDVDtJQUNMLENBQUMsQ0FBQyxDQUFBO0lBR0YsTUFBTSxjQUFjLEdBQUdsTyxDQUFhLENBQTBGLElBQUssQ0FBQyxDQUFDO0lBQ3JJLE1BQU0sZUFBZSxHQUFHQSxDQUFhLENBQTBELElBQUssQ0FBQyxDQUFDO0FBQ3pGLFVBQUEsV0FBVyxHQUFHcUYsQ0FBSSxDQUFDLE1BQUs7UUFFakMsTUFBTSxHQUFHLG1CQUFtQixFQUFFLG9CQUFvQixDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3RFLElBQUEsTUFBTSxFQUFFLGdCQUFnQixFQUFFLEdBQUcsV0FBVyxDQUEwQixFQUFFLHlCQUF5QixFQUFFLG1CQUFtQixFQUFFLENBQUMsQ0FBQztJQUN0SCxJQUFBLE1BQU0sRUFBRSxvQkFBb0IsRUFBRSxzQkFBc0IsRUFBRSxjQUFjLEVBQUUsRUFBRSxhQUFhLEVBQUUsRUFBRSxHQUFHLGlCQUFpQixDQUE2RjtJQUN0TSxRQUFBLGNBQWMsRUFBRSxFQUFFO0lBQ2xCLFFBQUEsZ0JBQWdCLEVBQUUsRUFBRTtJQUNwQixRQUFBLGNBQWMsRUFBRSxFQUFFO0lBQ2xCLFFBQUEsbUJBQW1CLEVBQUUsRUFBRTtJQUN2QixRQUFBLGVBQWUsRUFBRSxFQUFFO0lBQ3RCLEtBQUEsQ0FBQyxDQUFDO1FBRUgsUUFDSTZJLEdBQUssQ0FBQSxLQUFBLEVBQUEsRUFBQSxLQUFLLEVBQUMsTUFBTSxFQUNaLFFBQUEsRUFBQSxDQUFBQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsa0JBQUEsRUFBc0IsYUFBYSxDQUFBLEVBQUEsQ0FBTyxFQUMzQ0EsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLEdBQVcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFRLEVBQUUsS0FBSyxFQUFFLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFBLFFBQUEsRUFBQSxDQUU3REMsR0FDSSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQUQsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQyxHQUF5QixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxrQkFBQSxFQUFBLENBQUEsRUFDekJBLEdBQWlCLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFBLEVBQ2pCQSxHQUFpQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxVQUFBLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FDaEIsRUFDRCxDQUFBLEVBQ1JBLEdBQVcsQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFBLGdCQUFnQixDQUFDLHNCQUFzQixDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ25ELFFBQUEsRUFBQUEsR0FBQSxDQUFDLGNBQWMsQ0FBQyxRQUFRLEVBQUEsRUFBQyxLQUFLLEVBQUUsb0JBQW9CLEVBQUEsUUFBQSxFQUMvQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBUztvQ0FDbEIsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTt3Q0FDekIsTUFBTUEsR0FBQSxDQUFDLGNBQWMsRUFBQyxFQUFBLEtBQUssRUFBRSxDQUFDLEVBQUEsRUFBTyxDQUFDLENBQUksQ0FBQTtJQUM3QyxpQ0FBQTtpQ0FDSixHQUFHLENBQUMsRUFBQSxDQUNpQixHQUN0QixDQUNKLEVBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FDTixFQUNSO0lBQ04sQ0FBQyxFQUFDO0lBR0YsTUFBTSxjQUFjLEdBQUc5SSxDQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBcUIsS0FBSTtJQUMxRCxJQUFzQixRQUFRLENBQUMsTUFBTSxXQUFXLENBQUMsS0FBSywwREFBeUQsRUFBRTtJQUNqSCxJQUFBLE1BQU0sVUFBVSxHQUFHekIsR0FBVSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzlDLElBQUEsTUFBTSxFQUNGLHlCQUF5QixFQUN6QixxQkFBcUIsRUFDckIsVUFBVSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsR0FDL0MsR0FBRyxVQUFVLENBQUM7SUFDWCxRQUFBLG1CQUFtQixFQUFFLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFBRSxFQUFFLE1BQU0sRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRTtZQUNuSSxrQkFBa0IsRUFBRSxFQUFFLGdCQUFnQixFQUFFLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFLGNBQWMsRUFBRSxFQUFFLEVBQUUsbUJBQW1CLEVBQUUsRUFBRSxFQUFFLGVBQWUsRUFBRSxFQUFFLEVBQUU7SUFDckksS0FBQSxDQUFDLENBQUM7SUFFSCxJQUFBLE1BQU0sS0FBSyxHQUFHLHlCQUF5QixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzVDLElBQUEsUUFDSXVLLEdBQVEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxHQUFBLEtBQUssWUFDVEEsR0FBQyxDQUFBLGVBQWUsQ0FBQyxRQUFRLEVBQUEsRUFBQyxLQUFLLEVBQUUscUJBQXFCLFlBQ2pELEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQyxhQUFTO29CQUNsQixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO0lBQ3hCLG9CQUFBLE1BQU1BLElBQUMsZUFBZSxFQUFBLEVBQUMsS0FBSyxFQUFFLENBQUMsRUFBVSxHQUFHLEVBQUUsS0FBSyxFQUFFLGFBQWEsRUFBRSxRQUFRLEVBQXRDLEVBQUEsQ0FBQyxDQUF5QyxDQUFBO0lBQ25GLGlCQUFBO0lBQ0wsYUFBQyxHQUFHLENBQUMsRUFDa0IsQ0FBQSxFQUFBLENBQzFCLEVBQ1I7SUFDTCxDQUFDLEVBQUUsQ0FBQztJQUVKLE1BQU0sZUFBZSxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLGFBQWEsRUFBMEQsS0FBSTtJQUMvRyxJQUFBLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxLQUFLLEdBQUcsQ0FBQztJQUNyQyxRQUFBLE9BQU8sSUFBSSxDQUFDO0lBRWhCLElBQUEsSUFBSSxVQUFVLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLGVBQWUsR0FBRyxFQUFFLENBQUE7SUFFbkQsSUFBQSxNQUFNLFdBQVcsR0FBR3ZLLEdBQVUsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUNoRCxJQUFBLE1BQU0sRUFDRiwwQkFBMEIsRUFDMUIsY0FBYyxFQUFFLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxFQUMvQyxHQUFHLFdBQVcsQ0FBQztJQUNaLFFBQUEsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRTtZQUM1QixZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUU7SUFDdkIsUUFBQSxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFO0lBQ2pDLFFBQUEsT0FBTyxFQUFFLEVBQUU7SUFDZCxLQUFBLENBQUMsQ0FBQztJQUVILElBQUEsTUFBTSxLQUFLLEdBQUcsMEJBQTBCLENBQUMsRUFBRSxDQUFRLENBQUM7SUFFcEQsSUFBQSxNQUFNLENBQUMsSUFBSSxjQUFjLEdBQUcsWUFBWSxHQUFHLGdCQUFnQixDQUFDLENBQUE7UUFFNUQsSUFBSSxLQUFLLEtBQUssQ0FBQztZQUNYLE9BQU91SyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBUSxLQUFLLEVBQUcsUUFBQSxFQUFBLGFBQWEsQ0FBQyxRQUFRLEVBQUUsR0FBTSxDQUFBO0lBQ3BELFNBQUE7WUFDRCxJQUFJLEdBQUcsR0FBRyxDQUFDLElBQUksR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7Z0JBQ3pCLElBQUksS0FBSyxLQUFLLENBQUM7b0JBQ1gsT0FBT0QsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLEdBQVEsS0FBSyxFQUFBLFFBQUEsRUFBQSxDQUFBLGFBQUEsRUFBYyxLQUFLLEdBQUcsQ0FBQyxFQUFBLEdBQUEsRUFBRyxDQUFDLEVBQUUsVUFBVSxDQUFBLEVBQUEsQ0FBTSxDQUFBOztJQUVqRSxnQkFBQSxPQUFPQyxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQU9DLEdBQVksQ0FBQSxPQUFBLEVBQUEsRUFBQSxHQUFBLEtBQUssRUFBRSxJQUFJLEVBQUMsVUFBVSxFQUFBLENBQUcsa0JBQWEsQ0FBQyxFQUFFLFVBQVUsQ0FBQSxFQUFBLENBQVMsR0FBSyxDQUFBO0lBQ3RHLFNBQUE7SUFDSSxhQUFBO2dCQUNELElBQUksS0FBSyxLQUFLLENBQUM7SUFDWCxnQkFBQSxPQUFPRCxHQUFRLENBQUEsSUFBQSxFQUFBLEVBQUEsR0FBQSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBQSxRQUFBLEVBQUEsQ0FBQSxhQUFBLEVBQWMsS0FBSyxHQUFHLENBQUMsRUFBVyxXQUFBLEVBQUEsQ0FBQyxFQUFFLFVBQVUsSUFBTSxDQUFBOztJQUVyRixnQkFBQSxPQUFPLElBQUksQ0FBQztJQUVuQixTQUFBO0lBQ0osS0FBQTtJQUNMLENBQUMsQ0FBQyxDQUFBO0lBRUYsTUFBTSxTQUFTLEdBQUcsTUFBSztJQUNuQixJQUFBLE9BQU9BLGFBQUssS0FBSyxFQUFDLE1BQU0sRUFBQyxLQUFLLEVBQUUsRUFBRSxRQUFRLEVBQUUsTUFBTSxFQUFFLEVBQUEsUUFBQSxFQUFBLENBQ2hEQyxJQUFDLFNBQVMsRUFBQSxFQUFBLENBQUcsRUFDYkEsR0FBTSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQUEsRUFDTkEsR0FBQyxDQUFBLFdBQVcsS0FBRyxFQUNmQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBTSxFQUNOQSxHQUFBLENBQUMsY0FBYyxFQUFHLEVBQUEsQ0FBQSxFQUNsQkEsR0FBTSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQUEsRUFDTkEsSUFBQyxlQUFlLEVBQUEsRUFBQSxDQUFHLEVBQ25CQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNOQSxJQUFDLHFCQUFxQixFQUFBLEVBQUEsQ0FBRyxFQUN6QkEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQU0sRUFHTkEsR0FBQyxDQUFBLGdCQUFnQixFQUFHLEVBQUEsQ0FBQSxFQUNwQkEsYUFBTSxFQUNOQSxHQUFBLENBQUMsb0JBQW9CLEVBQUEsRUFBQSxDQUFHLEVBQ3hCQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNOQSxJQUFDLG9CQUFvQixFQUFBLEVBQUEsQ0FBRyxFQUN4QkEsR0FBTSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQUEsRUFDTkEsR0FBQyxDQUFBLGdCQUFnQixLQUFHLEVBQ3BCQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBTSxFQUNOQSxHQUFDLENBQUEsZ0JBQWdCLEtBQUcsRUFDcEJBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFNLEVBQ05BLEdBQUEsQ0FBQywyQkFBMkIsRUFBRyxFQUFBLENBQUEsRUFDL0JBLGFBQU0sRUFDTkEsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLENBQVMsSUFDUCxDQUFBO0lBQ1YsQ0FBQyxDQUFBO0lBRUQscUJBQXFCLENBQUMsTUFBSztJQUN2QixJQUFBM1EsR0FBTSxDQUFDMlEsR0FBQSxDQUFDLFNBQVMsRUFBQSxFQUFBLENBQUcsRUFBRSxRQUFRLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBRSxDQUFDLENBQUM7SUFDNUQsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7In0=
