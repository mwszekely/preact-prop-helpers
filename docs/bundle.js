var bundle = (function (exports) {
    'use strict';

    var n,l$1,u$1,t$1,o$2,r$2,f$1={},e$2=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$1(n,l){for(var u in l)n[u]=l[u];return n}function a$1(n){var l=n.parentNode;l&&l.removeChild(n);}function h$1(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return v$1(l,f,t,o,null)}function v$1(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u$1:r};return null==r&&null!=l$1.vnode&&l$1.vnode(f),f}function p$1(n){return n.children}function d$1(n,l){this.props=n,this.context=l;}function _$1(n,l){if(null==l)return n.__?_$1(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?_$1(n):null}function k$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k$1(n)}}function b$1(n){(!n.__d&&(n.__d=!0)&&t$1.push(n)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2);}function g$2(){for(var n;g$2.__r=t$1.length;)n=t$1.sort(function(n,l){return n.__v.__b-l.__v.__b}),t$1=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=s$1({},t)).__v=t.__v+1,j$2(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?_$1(t):o,t.__h),z$1(u,t),t.__e!=o&&k$1(t)));});}function w$2(n,l,u,i,t,o,r,c,s,a){var h,y,d,k,b,g,w,x=i&&i.__k||e$2,C=x.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v$1(null,k,null,null,k):Array.isArray(k)?v$1(p$1,{children:k},null,null,null):k.__b>0?v$1(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=x[h])||d&&k.key==d.key&&k.type===d.type)x[h]=void 0;else for(y=0;y<C;y++){if((d=x[y])&&k.key==d.key&&k.type===d.type){x[y]=void 0;break}d=null;}j$2(n,k,d=d||f$1,t,o,r,c,s,a),b=k.__e,(y=k.ref)&&d.ref!=y&&(w||(w=[]),d.ref&&w.push(d.ref,null,k),w.push(y,k.__c||b,k)),null!=b?(null==g&&(g=b),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=m$1(k,s,n):s=A$1(n,k,d,x,b,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_$1(d));}for(u.__e=g,h=C;h--;)null!=x[h]&&("function"==typeof u.type&&null!=x[h].__e&&x[h].__e==u.__d&&(u.__d=_$1(i,h+1)),N(x[h],x[h]));if(w)for(h=0;h<w.length;h++)M$1(w[h],w[++h],w[++h]);}function m$1(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l="function"==typeof i.type?m$1(i,l,u):A$1(u,i,i,t,i.__e,l));return l}function x(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){x(n,l);}):l.push(n)),l}function A$1(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function C$1(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H$1(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H$1(n,o,l[o],u[o],i);}function $$1(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c$1.test(l)?u:u+"px";}function H$1(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$$1(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$$1(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T$2:I,o):n.removeEventListener(l,o?T$2:I,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l));}}function I(n){this.l[n.type+!1](l$1.event?l$1.event(n):n);}function T$2(n){this.l[n.type+!0](l$1.event?l$1.event(n):n);}function j$2(n,u,i,t,o,r,f,e,c){var a,h,v,y,_,k,b,g,m,x,A,C,$,H=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=l$1.__b)&&a(u);try{n:if("function"==typeof H){if(g=u.props,m=(a=H.contextType)&&t[a.__c],x=a?m?m.props.value:a.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in H&&H.prototype.render?u.__c=h=new H(g,x):(u.__c=h=new d$1(g,x),h.constructor=H,h.render=O$1),m&&m.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=H.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s$1({},h.__s)),s$1(h.__s,H.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state,v)null==H.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==H.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,k);});}if(h.context=x,h.props=g,h.__v=u,h.__P=n,A=l$1.__r,C=0,"prototype"in H&&H.prototype.render)h.state=h.__s,h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context);else do{h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++C<25);h.state=h.__s,null!=h.getChildContext&&(t=s$1(s$1({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,_)),$=null!=a&&a.type===p$1&&null==a.key?a.props.children:a,w$2(n,Array.isArray($)?$:[$],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L$1(i.__e,u,i,t,o,r,f,c);(a=l$1.diffed)&&a(u);}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l$1.__e(n,u,i);}}function z$1(n,u){l$1.__c&&l$1.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$1.__e(n,u.__v);}});}function L$1(l,u,i,t,o,r,e,c){var s,h,v,y=i.props,p=u.props,d=u.type,k=0;if("svg"===d&&(o=!0),null!=r)for(;k<r.length;k++)if((s=r[k])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[k]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(r=r&&n.call(l.childNodes),h=(y=i.props||f$1).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},k=0;k<l.attributes.length;k++)y[l.attributes[k].name]=l.attributes[k].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C$1(l,p,y,o,c),v)u.__k=[];else if(k=u.props.children,w$2(l,Array.isArray(k)?k:[k],u,i,t,o&&"foreignObject"!==d,r,e,r?r[0]:i.__k&&_$1(i,0),c),null!=r)for(k=r.length;k--;)null!=r[k]&&a$1(r[k]);c||("value"in p&&void 0!==(k=p.value)&&(k!==l.value||"progress"===d&&!k||"option"===d&&k!==y.value)&&H$1(l,"value",k,y.value,!1),"checked"in p&&void 0!==(k=p.checked)&&k!==l.checked&&H$1(l,"checked",k,y.checked,!1));}return l}function M$1(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$1.__e(n,i);}}function N(n,u,i){var t,o;if(l$1.unmount&&l$1.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M$1(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$1.__e(n,u);}t.base=t.__P=null;}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,"function"!=typeof n.type);i||null==n.__e||a$1(n.__e),n.__e=n.__d=void 0;}function O$1(n,l,u){return this.constructor(n,u)}function P$1(u,i,t){var o,r,e;l$1.__&&l$1.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,e=[],j$2(i,u=(!o&&t||i).__k=h$1(p$1,null,[u]),r||f$1,f$1,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,e,!o&&t?t:r?r.__e:i.firstChild,o),z$1(e,u);}function B(n,l){var u={__c:l="__cC"+r$2++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(b$1);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=e$2.slice,l$1={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l;}throw n}},u$1=0,d$1.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s$1({},this.state),"function"==typeof n&&(n=n(s$1({},u),this.props)),n&&s$1(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),b$1(this));},d$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),b$1(this));},d$1.prototype.render=p$1,t$1=[],g$2.__r=0,r$2=0;

    var o$1=0;function e$1(_,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:_,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--o$1,__source:f,__self:t};if("function"==typeof _&&(l=_.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return l$1.vnode&&l$1.vnode(a),a}

    var t,u,r$1,o,i=0,c=[],f=[],e=l$1.__b,a=l$1.__r,v=l$1.diffed,l=l$1.__c,m=l$1.unmount;function p(t,r){l$1.__h&&l$1.__h(u,t,i||r),i=0;var o=u.__H||(u.__H={__:[],__h:[]});return t>=o.__.length&&o.__.push({__V:f}),o.__[t]}function y(n){return i=1,d(z,n)}function d(n,r,o){var i=p(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):z(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}));}],i.__c=u),i.__}function _(r,o){var i=p(t++,3);!l$1.__s&&w$1(i.__H,o)&&(i.__=r,i.u=o,u.__H.__h.push(i));}function h(r,o){var i=p(t++,4);!l$1.__s&&w$1(i.__H,o)&&(i.__=r,i.u=o,u.__h.push(i));}function s(n){return i=5,F$1(function(){return {current:n}},[])}function F$1(n,u){var r=p(t++,7);return w$1(r.__H,u)?(r.__V=n(),r.u=u,r.__h=n,r.__V):r.__}function T$1(n,t){return i=8,F$1(function(){return n},t)}function q$1(n){var r=u.context[n.__c],o=p(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function b(){for(var t;t=c.shift();)if(t.__P)try{t.__H.__h.forEach(j$1),t.__H.__h.forEach(k),t.__H.__h=[];}catch(u){t.__H.__h=[],l$1.__e(u,t.__v);}}l$1.__b=function(n){u=null,e&&e(n);},l$1.__r=function(n){a&&a(n),t=0;var o=(u=n.__c).__H;o&&(r$1===u?(o.__h=[],u.__h=[],o.__.forEach(function(n){n.__V=f,n.u=void 0;})):(o.__h.forEach(j$1),o.__h.forEach(k),o.__h=[])),r$1=u;},l$1.diffed=function(t){v&&v(t);var i=t.__c;i&&i.__H&&(i.__H.__h.length&&(1!==c.push(i)&&o===l$1.requestAnimationFrame||((o=l$1.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),g$1&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);g$1&&(t=requestAnimationFrame(u));})(b)),i.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.__V!==f&&(n.__=n.__V),n.u=void 0,n.__V=f;})),r$1=u=null;},l$1.__c=function(t,u){u.some(function(t){try{t.__h.forEach(j$1),t.__h=t.__h.filter(function(n){return !n.__||k(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],l$1.__e(r,t.__v);}}),l&&l(t,u);},l$1.unmount=function(t){m&&m(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{j$1(n);}catch(n){u=n;}}),u&&l$1.__e(u,r.__v));};var g$1="function"==typeof requestAnimationFrame;function j$1(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function k(n){var t=u;n.__c=n.__(),u=t;}function w$1(n,t){return !n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function z(n,t){return "function"==typeof t?t(n):t}

    function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return !r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,h$1(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new d$1).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w=l$1.__b;l$1.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w&&w(n);};var A=l$1.__e;l$1.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);A(n,t,e,r);};var O=l$1.unmount;function T(){this.__u=0,this.t=null,this.__b=null;}function L(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function D(){this.u=null,this.o=null;}l$1.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n);},(T.prototype=new d$1).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=L(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate();}},f=!0===t.__h;r.__u++||f||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i);},T.prototype.componentWillUnmount=function(){this.t=[];},T.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__a&&h$1(p$1,null,n.fallback);return u&&(u.__h=null),[h$1(p$1,null,t.__a?null:n.children),u]};var F=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};(D.prototype=new d$1).__a=function(n){var t=this,e=L(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),F(t,n,r)):u();};e?e(o):o();}},D.prototype.render=function(n){this.u=null,this.o=new Map;var t=x(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},D.prototype.componentDidUpdate=D.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){F(n,e,t);});};var W="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|shape|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,$="undefined"!=typeof document,j=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(d$1.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var H=l$1.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}l$1.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var J={configurable:!0,get:function(){return this.class}},K=l$1.vnode;l$1.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];$&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!j(e.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),/^oninput$/i.test(o)&&(o=o.toLowerCase(),r[o]&&(o="oninputCapture")),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=x(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=x(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r,e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J));}n.$$typeof=W,K&&K(n);};var Q=l$1.__r;l$1.__r=function(n){Q&&Q(n),n.__c;};

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */
    function useEnsureStability(parentHookName, ...values) {
        useHelper(values.length, 0);
        values.forEach(useHelper);
        return;
        function useHelper(value, index) {
            // Make sure that the provided functions are perfectly stable across renders
            const helperToEnsureStability = s(value);
            const shownError = s(false);
            if (helperToEnsureStability.current != value) {
                if (!shownError.current) {
                    /* eslint-disable no-debugger */
                    debugger;
                    console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
                    shownError.current = true;
                }
            }
        }
    }
    function debounceRendering(f) {
        (l$1.debounceRendering ?? setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
     * @returns
     */
    function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
        const valueRef = s(Unset$1);
        const warningRef = s(false);
        const cleanupCallbackRef = s(undefined);
        // Make sure that the provided functions are perfectly stable across renders
        useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
        // Shared between "dependency changed" and "component unmounted".
        const onShouldCleanUp = T$1(() => {
            const cleanupCallback = cleanupCallbackRef.current;
            if (cleanupCallback)
                cleanupCallback();
        }, []);
        // There are a couple places where we'd like to use our initial
        // value in place of having no value at all yet.
        // This is the shared code for that, used on mount and whenever
        // getValue is called.
        const tryEnsureValue = T$1(() => {
            if (valueRef.current === Unset$1 && getInitialValue != undefined) {
                try {
                    const initialValue = getInitialValue();
                    valueRef.current = initialValue;
                    cleanupCallbackRef.current = (onChange?.(initialValue, undefined) ?? undefined);
                }
                catch (ex) {
                    // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
                }
            }
        }, [ /* getInitialValue and onChange intentionally omitted */]);
        const getValue = T$1(() => {
            if (warningRef.current)
                console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
            // The first time we call getValue, if we haven't been given a value yet,
            // (and we were given an initial value to use)
            // return the initial value instead of nothing.
            if (valueRef.current === Unset$1)
                tryEnsureValue();
            return (valueRef.current === Unset$1 ? undefined : valueRef.current);
        }, []);
        h(() => {
            // Make sure we've run our effect at least once on mount.
            // (If we have an initial value, of course)
            tryEnsureValue();
        }, []);
        // The actual code the user calls to (possibly) run a new effect.
        const r = s({ prevDep: Unset$1 });
        const setValue = T$1((arg) => {
            // Regardless of anything else, figure out what our next value is about to be.
            const nextValue = (arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg);
            if (r.current.prevDep === Unset$1 && nextValue !== valueRef.current) {
                // This is the first request to change this value.
                // Evaluate the request immediately, then queue up the onChange function
                // Save our current value so that we can compare against it later
                // (if we flip back to this state, then we won't send the onChange function)
                r.current.prevDep = valueRef.current;
                // Schedule the actual check and invocation of onChange later to let effects settle
                (customDebounceRendering ?? debounceRendering)(() => {
                    const nextDep = valueRef.current;
                    const prevDep = r.current.prevDep;
                    if (r.current.prevDep != valueRef.current) {
                        warningRef.current = true;
                        try {
                            // Call any registered cleanup function
                            onShouldCleanUp();
                            cleanupCallbackRef.current = (onChange?.(nextDep, prevDep === Unset$1 ? undefined : prevDep) ?? undefined);
                            valueRef.current = nextDep;
                        }
                        finally {
                            // Allow the user to normally call getValue again
                            warningRef.current = false;
                        }
                    }
                    // We've finished with everything, so mark us as being on a clean slate again.
                    r.current.prevDep = Unset$1;
                });
            }
            // Update the value immediately.
            // This will be checked against prevDep to see if we should actually call onChange
            valueRef.current = nextValue;
        }, []);
        return [getValue, setValue];
    }
    const Unset$1 = Symbol();
    // Easy constants for getInitialValue
    function returnTrue() { return true; }
    function returnFalse() { return false; }
    function returnNull() { return null; }

    /*
    const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
    const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
    const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
    const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/
    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    //const microtasks = new Map<Set<any>, any>();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.
    function forEachUpdater(window, map, value) {
        const updaters = map.get(window);
        if (updaters) {
            //if (!microtasks.has(updatersKey)) {
            //debounceRendering(() => {
            //const updatersKey = map.get(window)!;
            //const value = microtasks.get(updatersKey);
            //microtasks.delete(updatersKey);
            if (updaters) {
                for (const updater of updaters) {
                    const { lastSent, send } = updater;
                    if (value !== lastSent) {
                        send(value);
                        updater.lastSent = value;
                    }
                }
            }
            //});
            //}
            //microtasks.set(updatersKey, value);
        }
    }
    function focusout(e) {
        const window = e.target.ownerDocument.defaultView;
        if (e.relatedTarget == null) {
            forEachUpdater(window, activeElementUpdaters, null);
        }
    }
    function focusin(e) {
        const window = e.target.ownerDocument.defaultView;
        const currentlyFocusedElement = e.target;
        forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
        forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }
    function windowFocus(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, true);
        forEachUpdater(window, windowFocusedUpdaters, true);
    }
    function windowBlur(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, false);
        forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */
    function useActiveElement({ onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow }) {
        useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
        _(() => {
            const document = getDocument();
            const window = (getWindow?.(document) ?? document?.defaultView);
            if ((activeElementUpdaters.get(window)?.size ?? 0) === 0) {
                document?.addEventListener("focusin", focusin, { passive: true });
                document?.addEventListener("focusout", focusout, { passive: true });
                window?.addEventListener("focus", windowFocus, { passive: true });
                window?.addEventListener("blur", windowBlur, { passive: true });
            }
            // Add them even if they're undefined to more easily
            // manage the ">0 means don't add handlers" logic.
            const localActiveElementUpdaters = activeElementUpdaters.get(window) ?? new Set();
            const localLastActiveElementUpdaters = lastActiveElementUpdaters.get(window) ?? new Set();
            const localWindowFocusedUpdaters = windowFocusedUpdaters.get(window) ?? new Set();
            const laeu = { send: setActiveElement, lastSent: undefined };
            const llaeu = { send: setLastActiveElement, lastSent: undefined };
            const lwfu = { send: setWindowFocused, lastSent: undefined };
            localActiveElementUpdaters.add(laeu);
            localLastActiveElementUpdaters.add(llaeu);
            localWindowFocusedUpdaters.add(lwfu);
            activeElementUpdaters.set(window, localActiveElementUpdaters);
            lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
            windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
            return () => {
                activeElementUpdaters.get(window).delete(laeu);
                lastActiveElementUpdaters.get(window).delete(laeu);
                windowFocusedUpdaters.get(window).delete(lwfu);
                if (activeElementUpdaters.size === 0) {
                    document?.removeEventListener("focusin", focusin);
                    document?.removeEventListener("focusout", focusout);
                    window?.removeEventListener("focus", windowFocus);
                    window?.removeEventListener("blur", windowBlur);
                }
            };
        }, []);
        const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
        const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
        const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
        return { getActiveElement, getLastActiveElement, getWindowFocused };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
    function base64(value) {
        return Table[value];
    }
    function random6Bits() {
        return Math.floor(Math.random() * 0b1000000);
    }
    function random64Bits() {
        return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */
    function generateRandomId(prefix) {
        return `${prefix ?? "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map();
    // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.
    const commitName = "diffed";
    const originalCommit = l$1[commitName];
    const newCommit = (...args) => {
        for (const [id, effectInfo] of toRun) {
            const oldInputs = previousInputs.get(id);
            if (argsChanged(oldInputs, effectInfo.inputs)) {
                effectInfo.cleanup?.();
                effectInfo.cleanup = effectInfo.effect();
                previousInputs.set(id, effectInfo.inputs);
            }
        }
        toRun.clear();
        originalCommit?.(...args);
    };
    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */
    function useBeforeLayoutEffect(effect, inputs) {
        /*(() => {
            const cleanup = useRef<void | (() => void) | null>(null);
            const prevArgsRef = useRef<Inputs>(null!);
            if (argsChanged(inputs, prevArgsRef.current)) {
                prevArgsRef.current = inputs!;
                if (cleanup.current)
                    cleanup.current();
                cleanup.current = effect();
            }
        })();*/
        const [id] = y(() => generateRandomId());
        toRun.set(id, { effect, inputs, cleanup: null });
        _(() => {
            return () => {
                toRun.delete(id);
                previousInputs.delete(id);
            };
        }, [id]);
    }
    function argsChanged(oldArgs, newArgs) {
        return !!(!oldArgs ||
            oldArgs.length !== newArgs?.length ||
            newArgs?.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */
    function useStableGetter(value) {
        const ref = s(Unset);
        useBeforeLayoutEffect(() => { ref.current = value; }, [value]);
        return T$1(() => {
            if (ref.current === Unset) {
                throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
            }
            return ref.current;
        }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */
    function useStableCallback(fn) {
        const currentCallbackGetter = useStableGetter(fn);
        return T$1((...args) => {
            return currentCallbackGetter()(...args);
        }, []);
    }

    const SharedAnimationFrameContext = B(null);
    /**
     * The (optionally non-stable) `callback` you provide will start running every frame after the component mounts.
     *
     * Passing `null` is fine and simply stops the effect until you restart it by providing a non-null callback.
     *
     * **This hook does not return anything at all, including no prop-modifying hooks**
     */
    function useAnimationFrame({ callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback ?? noop);
        const hasCallback = (callback != null);
        const sharedAnimationFrameContext = q$1(SharedAnimationFrameContext);
        _(() => {
            if (sharedAnimationFrameContext) {
                if (hasCallback) {
                    sharedAnimationFrameContext.addCallback(stableCallback);
                }
                else {
                    sharedAnimationFrameContext.removeCallback(stableCallback);
                }
            }
            else {
                if (hasCallback) {
                    // Get a wrapper around the wrapper around the callback
                    // that also calls `requestAnimationFrame` again.
                    const rafCallback = (ms) => {
                        handle = requestAnimationFrame(rafCallback);
                        stableCallback(ms);
                    };
                    let handle = requestAnimationFrame(rafCallback);
                    return () => cancelAnimationFrame(handle);
                }
            }
        }, [sharedAnimationFrameContext, hasCallback]);
    }
    // eslint-disable @typescript-eslint/no-empty-function
    function noop() { }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$5.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$4.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */
    function useState(initialState) {
        // We keep both, but overrride the `setState` functionality
        const [state, setStateP] = y(initialState);
        const ref = s(state);
        // Hijack the normal setter function 
        // to also set our ref to the new value
        const setState = T$1(value => {
            if (typeof value === "function") {
                const callback = value;
                setStateP(prevValue => {
                    const nextValue = callback(prevValue);
                    ref.current = nextValue;
                    return nextValue;
                });
            }
            else {
                ref.current = value;
                setStateP(value);
            }
        }, []);
        const getState = () => { return ref.current; };
        console.assert(ref.current === state || (typeof state === "number" && isNaN(state)));
        return [state, setState, getState];
    }

    function identity$1(...t) { return t; }
    function useThrottled(callback, wait, options) {
        const throttled = F$1(() => {
            return callback ? throttle(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.trailing]);
        _(() => {
            return () => throttled?.cancel();
        }, [throttled]);
        return throttled;
    }
    function useDebounced(callback, wait, options) {
        const debounced = F$1(() => {
            return callback ? debounce(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.maxWait, options?.trailing]);
        _(() => {
            return () => debounced?.cancel();
        }, [debounced]);
        return debounced;
    }
    /**
     * Given an async function, returns a function that's suitable for non-async APIs,
     * along with other information about the current run's status.
     *
     * See also `useAsyncHandler` for a version that's specialized for DOM event handlers.
     *
     * When called multiple times in quick succession, (i.e. before the handler has finished),
     * this works like Lodash's `throttle` function with the `wait` option always
     * set to however long the handler takes to complete. A second call to the sync function will be
     * throttled until the first call has finished. The return value of the function is the result
     * of the previous invocation, or `undefined` on the first call.
     *
     * The handler is only ever delayed if one is currently running, so, e.g. for iOS touch events the
     * first call happens in the same event handler (which means things like calls to `element.focus()`
     * will work as intended, since that fails when the event is "split up")
     *
     * Finally, because the sync handler may be invoked on a delay, any property references on the arguments
     * provided might be stale by the time it's actually invoked (e.g. accessing `event.currentTarget.checked`
     * is not stable across time because it's a "live" value -- you almost always want the value that it
     * had at the original time the handler was called). The `capture` option allows you to save that kind of
     * dynamic data at the time it runs; the `AP` and `SP` type parameters likewise control
     * the parameters the async handler and sync handler expect respectively.
     *
     */
    function useAsync(asyncHandler, options) {
        /* eslint-disable prefer-const */
        let { throttle, debounce, capture } = (options ?? {});
        capture ??= identity$1;
        // We keep, like, a lot of render-state, but it only ever triggers a re-render
        // when we start/stop an async action.
        // Keep track of this for the caller's sake -- we don't really care.
        const [currentType, setCurrentType] = useState(null);
        const [runCount, setRunCount] = useState(0);
        const [settleCount, setSettleCount] = useState(0);
        const [resolveCount, setResolveCount] = useState(0);
        const [rejectCount, setRejectCount] = useState(0);
        // Things related to current execution
        // Because we can both return and throw undefined, 
        // we need separate state to track their existance too.
        const [pending, setPending, getPending] = useState(false);
        const [result, setResult, getResult] = useState(undefined);
        const [error, setError, _getError] = useState(undefined);
        const [hasError, setHasError, _getHasError] = useState(false);
        const [hasResult, setHasResult, _getHasResult] = useState(false);
        // We implement our own throttling behavior in regards to waiting until the async handler finishes.
        // These two passive state variables keep track of that, automatically queueing/dequeuing the next handler.
        const [getQueued, setQueued] = usePassiveState(null, returnNull);
        // The actual sync handler.
        // Capture/transform the given parameters if applicable,
        // then run further logic that's debounced/throttled
        const captureArgsAndExecuteDebouncedHandler = useStableCallback(function onNewExecuteRequest(...newArgs2) {
            // Capture the arguments we were given.
            // We might use them immediately, or we might store them to `queued`,
            // but in either case we do need the captured value.
            const captured = capture(...newArgs2);
            // This is all logic that deals with the captured value instead of the raw arguments.
            // It's called in two separate circumstances,
            // and has the debounce/throttle logic already applied
            return executeHandlerWithDebounce(getPending(), ...captured);
        });
        // This is the logic that runs when the handler is *just* about to start.
        // This function itself is further transformed to be throttled/debounced if requested,
        // so this might not be called immediately after 
        const executeHandlerWithoutDebounce = useStableCallback(function onNewExecuteRequest2(enqueue, ...newArgs) {
            const onThen = (value) => { setResult(value); setHasResult(true); setHasError(false); setResolveCount(r => ++r); };
            const onCatch = (ex) => { setError(ex); setHasError(true); setHasResult(false); setRejectCount(r => ++r); };
            const onFinally = () => {
                const queued = getQueued();
                setSettleCount(s => ++s);
                if (queued) {
                    setQueued(null);
                    executeHandlerWithDebounce(false, ...queued);
                }
                else {
                    setPending(false);
                }
            };
            if (!enqueue) {
                // Nothing is pending at the moment, so we can run our function immediately.
                setRunCount(r => ++r);
                setPending(true);
                const result = asyncHandler?.(...newArgs);
                const isPromise = (result != null && typeof result == "object" && "then" in result);
                if (result == null || !isPromise) {
                    // It's synchronous and returned successfully.
                    // Bail out early.
                    onThen(result);
                    onFinally();
                    setCurrentType("sync");
                }
                else {
                    result.then(onThen).catch(onCatch).finally(onFinally);
                    setCurrentType("async");
                }
            }
            else {
                // When we're still running a previous handler,
                // just set ourselves as the next one to run and quit early.
                // Nothing more to do.
                setQueued(newArgs);
            }
            return getResult();
        });
        const executeHandlerWithT = useThrottled(!throttle ? null : executeHandlerWithoutDebounce, throttle ?? 0);
        const executeHandlerWithD = useDebounced(!debounce ? null : (executeHandlerWithT ?? executeHandlerWithoutDebounce), debounce ?? 0);
        const executeHandlerWithDebounce = (executeHandlerWithD ?? executeHandlerWithT ?? executeHandlerWithoutDebounce);
        const flushDebouncedPromise = useStableCallback(() => {
            if (executeHandlerWithDebounce && "flush" in executeHandlerWithDebounce)
                executeHandlerWithDebounce.flush();
        });
        return {
            syncHandler: captureArgsAndExecuteDebouncedHandler,
            currentType,
            pending,
            result,
            error,
            hasError,
            hasResult,
            resolveCount,
            rejectCount,
            settleCount,
            callCount: runCount,
            flushDebouncedPromise
        };
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * Note that because the handler you provide may be called with a delay, and
     * because the value of, e.g., an `<input>` element will likely be stale by the
     * time the delay is over, a `capture` function is necessary in order to
     * capture the relevant information from the DOM. Any other simple event data,
     * like `mouseX` or `shiftKey` can stay on the event itself and don't
     * need to be captured &ndash; it's never stale.
     *
     * ```tsx
     * const asyncOnInput = async (value: number, e: Event) => {
     *     [...] // Ex. send to a server and setState when done
     * };
     * const {
     *     // A sync version of asyncOnInput
     *     syncHandler,
     *     // True while the handler is running
     *     pending,
     *     // The error thrown, if any
     *     error,
     *     // Show this value while the operation's pending
     *     currentCapture,
     *     // And others, see `UseAsyncHandlerReturnType`
     *     ...rest
     * } = useAsyncHandler<HTMLInputElement>()(asyncOnInput, {
     *     // Pass in the capture function that saves event data
     *     // from being stale.
     *     capture: e => {
     *         // `capture` can have side-effects because
     *         // it's called exactly once per invocation
     *         e.preventDefault();
     *
     *         // Save this value so that it's never stale
     *         return e.currentTarget.valueAsNumber;
     *     }
     * });
     *
     * const onInput = pending? null : syncHandler;
     * ```
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     *
     * You may optionally *also* specify debounce and throttle parameters that wait until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * @see useAsync A more general version of this hook that can work with any type of handler, not just DOM event handlers.
     */
    function useAsyncHandler(asyncHandler, { capture: originalCapture, ...restAsyncOptions }) {
        // We need to differentiate between "nothing captured yet" and "`undefined` was captured"
        const [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        const [hasCapture, setHasCapture] = useState(false);
        // Wrap around the normal `useAsync` `capture` function to also
        // keep track of the last value the user actually input.
        // 
        // Without this there's no way to re-render the control with
        // it being both controlled and also having the "correct" value,
        // and at any rate also protects against sudden exceptions reverting
        // your change out from under you.
        const capture = useStableCallback((e) => {
            const captured = originalCapture(e);
            setCurrentCapture(captured);
            setHasCapture(true);
            return [captured, e];
        });
        return {
            getCurrentCapture,
            currentCapture,
            hasCapture,
            ...useAsync(asyncHandler, { capture, ...restAsyncOptions })
        };
    }

    //export type UseManagedChildParameters<I extends {}> = { info: I };
    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */
    function useManagedChildren(parentParameters) {
        const { managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
        const getHighestIndex = T$1(() => {
            return managedChildrenArray.current.highestIndex;
        }, []);
        // All the information we have about our children is stored in this **stable** array.
        // Any mutations to this array **DO NOT** trigger any sort of a re-render.
        const managedChildrenArray = s({ arr: [], rec: {}, highestIndex: 0, lowestIndex: 0 });
        // For indirect access to each child
        // Compare getManagedChildInfo
        // TODO: The primary use for this is flaggable closest fits
        // which needs to search all children for that closest fit.
        // It would be nice if there was something better for that.
        const forEachChild = T$1((f) => {
            for (const child of managedChildrenArray.current.arr) {
                if (child)
                    f(child);
            }
            for (const field in managedChildrenArray.current.rec) {
                const child = managedChildrenArray.current.rec[field];
                if (child)
                    f(child);
            }
        }, []);
        // Retrieves the information associated with the child with the given index.
        // `undefined` if not child there, or it's unmounted.
        const getManagedChildInfo = T$1((index) => {
            if (typeof index == "number")
                return managedChildrenArray.current.arr[index];
            else
                return managedChildrenArray.current.rec[index];
        }, []);
        // tl;dr this is a way to have run useLayoutEffect once after all N children
        // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
        // ourselves because of having a `childCount` state or anything similar.
        //
        // When the child count ref updates, we want the parent to also run an effect
        // to maybe do something with all these children that just mounted.
        // The easiest way would be useEffect(..., [childCount]) but
        // that would require us having a childCount state, then calling
        // setChildCount and re-rendering every time children mount
        // (only one re-render at a time unless children are staggered, but still)
        // 
        // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
        // to emulate running ULE on the parent. Only the first child will actually queue
        // the microtask (by checking hasRemoteULE first) so that the "effect" only
        // runs once. When it's done, hasRemoteULE is reset so it can run again if
        // more children mount/unmount.
        const hasRemoteULEChildMounted = s(null);
        const remoteULEChildChangedCausers = s(new Set());
        const remoteULEChildChanged = T$1((index) => {
            if (remoteULEChildChangedCausers.current.size == 0) {
                debounceRendering(() => {
                    onAfterChildLayoutEffect?.(remoteULEChildChangedCausers.current);
                    remoteULEChildChangedCausers.current.clear();
                });
            }
            remoteULEChildChangedCausers.current.add(index);
            return () => { };
        }, [ /* Must remain stable */]);
        const remoteULEChildMounted = T$1((index, mounted) => {
            if (!hasRemoteULEChildMounted.current) {
                hasRemoteULEChildMounted.current = {
                    mounts: new Set(),
                    unmounts: new Set(),
                };
                debounceRendering(() => {
                    onChildrenMountChange?.(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
                    hasRemoteULEChildMounted.current = null;
                });
            }
            if (mounted) {
                managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
            }
            else {
                if (typeof index == "number") {
                    delete managedChildrenArray.current.arr[index];
                    let shave = 0;
                    while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
                        ++shave;
                    }
                    managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
                }
                else
                    delete managedChildrenArray.current.rec[index];
            }
            hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
        }, [ /* Must remain stable */]);
        const useManagedChild = T$1(({ managedChild: info, }) => {
            // Any time our child props change, make that information available
            // the parent if they need it.
            // The parent can listen for all updates and only act on the ones it cares about,
            // and multiple children updating in the same tick will all be sent at once.
            h(() => {
                // Insert this information in-place
                if (typeof info.index == "number") {
                    managedChildrenArray.current.arr[info.index] = { index: info.index, flags: info.flags ?? {}, subInfo: info.subInfo };
                }
                else {
                    managedChildrenArray.current.rec[info.index] = { index: info.index, flags: info.flags ?? {}, subInfo: info.subInfo };
                }
                return remoteULEChildChanged(info.index);
            }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
            // When we mount, notify the parent via queueMicrotask
            // (every child does this, so everything's coordinated to only queue a single microtask per tick)
            // Do the same on unmount.
            // Note: It's important that this comes AFTER remoteULEChildChanged
            // so that remoteULEChildMounted has access to all the info on mount.
            h(() => {
                remoteULEChildMounted?.(info.index, true);
                return () => remoteULEChildMounted?.(info.index, false);
            }, [info.index]);
        }, [ /* Must remain stable */]);
        const managedChildren = s({
            ...{ _: managedChildrenArray.current },
            forEach: forEachChild,
            getAt: getManagedChildInfo,
            getHighestIndex: getHighestIndex,
            arraySlice: () => {
                return managedChildrenArray.current.arr.slice();
            }
        });
        return {
            useManagedChild,
            managedChildren: { children: managedChildren.current }
        };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */
    function useChildrenFlag({ children, initialIndex, closestFit, onIndexChange, key }) {
        useEnsureStability("useChildrenFlag", onIndexChange, key);
        const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, T$1(() => (initialIndex ?? (null)), []));
        const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, T$1(() => (initialIndex ?? (null)), []));
        //    const getFitNullToZero = useStableGetter(fitNullToZero);
        // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
        const getClosestFit = T$1((requestedIndex) => {
            let closestDistance = Infinity;
            let closestIndex = null;
            children.forEach(child => {
                if (child.flags?.[key]?.isValid()) {
                    const newDistance = Math.abs(child.index - requestedIndex);
                    if (newDistance < closestDistance || (newDistance == closestDistance && child.index < requestedIndex)) {
                        closestDistance = newDistance;
                        closestIndex = child.index;
                    }
                }
            });
            return closestIndex;
        }, [ /* Must remain stable! */]);
        // Any time a child mounts/unmounts, we need to double-check to see if that affects 
        // the "currently selected" (or whatever) index.  The two cases we're looking for:
        // 1. The currently selected child unmounted
        // 2. A child mounted, and it mounts with the index we're looking for
        const reevaluateClosestFit = useStableCallback(() => {
            const requestedIndex = getRequestedIndex();
            const currentIndex = getCurrentIndex();
            const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
            if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !currentChild.flags?.[key]?.isValid())) {
                currentChild?.flags?.[key].set(false);
                const closestFitIndex = getClosestFit(requestedIndex);
                setCurrentIndex(closestFitIndex);
                if (closestFitIndex != null) {
                    const closestFitChild = children.getAt(closestFitIndex);
                    console.assert(closestFitChild != null, "Internal logic???");
                    closestFitChild.flags?.[key].set(true);
                }
            }
        });
        const changeIndex = T$1((arg) => {
            const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
            //if (requestedIndex == null && getFitNullToZero())
            //    requestedIndex = 0;
            setRequestedIndex(requestedIndex);
            const currentIndex = getCurrentIndex();
            if (currentIndex == requestedIndex)
                return requestedIndex;
            let newMatchingChild = (requestedIndex == null ? null : children.getAt(requestedIndex));
            const oldMatchingChild = (currentIndex == null ? null : children.getAt(currentIndex));
            if (requestedIndex == null) {
                // Easy case
                setCurrentIndex(null);
                oldMatchingChild?.flags?.[key].set(false);
                return null;
            }
            else {
                if (newMatchingChild && newMatchingChild.flags?.[key].isValid()) {
                    setCurrentIndex(requestedIndex);
                    oldMatchingChild?.flags?.[key].set(false);
                    newMatchingChild.flags?.[key].set(true);
                    return requestedIndex;
                }
                else {
                    const closestFitIndex = getClosestFit(requestedIndex);
                    setCurrentIndex(closestFitIndex);
                    if (closestFitIndex != null) {
                        newMatchingChild = children.getAt(closestFitIndex);
                        console.assert(newMatchingChild != null, "Internal logic???");
                        oldMatchingChild?.flags?.[key].set(false);
                        newMatchingChild.flags?.[key].set(true);
                        return closestFitIndex;
                    }
                    else {
                        oldMatchingChild?.flags?.[key].set(false);
                        return null;
                    }
                }
            }
        }, []);
        h(() => {
            if (initialIndex != null)
                children.getAt(initialIndex)?.flags?.[key]?.set(true);
        }, []);
        return { changeIndex, reevaluateClosestFit, getCurrentIndex };
    }

    function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

    function getDocument$2(element) { return (element?.ownerDocument ?? document ?? window.document ?? globalThis.document); }

    function useMergedChildren({ children: lhs }, { children: rhs }) {
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return h$1(p$1, {}, lhs, rhs);
        }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */
    function useMergedClasses({ class: lhsClass, className: lhsClassName }, { class: rhsClass, className: rhsClassName }) {
        // Note: For the sake of forward compatibility, this function is labelled as
        // a hook, but as it uses no other hooks it technically isn't one.
        if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
            const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
            const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
            const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
            return Array.from(allClasses).join(" ");
        }
        else {
            return undefined;
        }
    }

    function processRef(instance, ref) {
        if (typeof ref === "function") {
            ref(instance);
        }
        else if (ref != null) {
            ref.current = instance;
        }
        else {
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
        }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */
    function useMergedRefs({ ref: rhs }, { ref: lhs }) {
        const combined = T$1((current) => {
            processRef(current, lhs);
            processRef(current, rhs);
        }, [lhs, rhs]);
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return combined;
        }
    }

    function styleStringToObject(style) {
        // TODO: This sucks D:
        return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
        // Easy case, when there are no styles to merge return nothing.
        if (!lhs?.style && !rhs?.style)
            return undefined;
        if (typeof lhs != typeof rhs) {
            // Easy cases, when one is null and the other isn't.
            if (lhs?.style && !rhs?.style)
                return lhs.style;
            if (!lhs?.style && rhs?.style)
                return rhs.style;
            // They're both non-null but different types.
            // Convert the string type to an object bag type and run it again.
            if (lhs?.style && rhs?.style) {
                // (useMergedStyles isn't a true hook -- this isn't a violation)
                if (typeof lhs?.style == "string")
                    return useMergedStyles({ style: styleStringToObject(lhs?.style) }, rhs);
                if (typeof rhs?.style == "string")
                    return useMergedStyles(lhs, { style: styleStringToObject(rhs?.style) });
            }
            // Logic???
            return undefined;
        }
        // They're both strings, just concatenate them.
        if (typeof lhs?.style == "string") {
            return `${lhs.style};${rhs?.style ?? ""}`;
        }
        // They're both objects, just merge them.
        return {
            ...(lhs?.style ?? {}),
            ...(rhs?.style ?? {})
        };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */
    function useMergedProps(lhsAll, rhsAll) {
        // First, separate the props we were given into two groups:
        // lhsAll and rhsAll contain all the props we were given, and
        // lhsMisc and rhsMisc contain all props *except* for the easy ones
        // like className and style that we already know how to merge.
        const { children: _lhsChildren, class: _lhsClass, className: _lhsClassName, style: _lhsStyle, ref: _lhsRef, ...lhsMisc } = lhsAll;
        const { children: _rhsChildren, class: _rhsClass, className: _rhsClassName, style: _rhsStyle, ref: _rhsRef, ...rhsMisc } = rhsAll;
        const ret = {
            ...lhsMisc,
            ref: useMergedRefs(lhsAll, rhsAll),
            style: useMergedStyles(lhsAll, rhsAll),
            className: useMergedClasses(lhsAll, rhsAll),
            children: useMergedChildren(lhsAll, rhsAll),
        };
        if (ret.ref === undefined)
            delete ret.ref;
        if (ret.style === undefined)
            delete ret.style;
        if (ret.className === undefined)
            delete ret.className;
        if (ret.children === undefined)
            delete ret.children;
        // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];
        const rhsEntries = Object.entries(rhsMisc);
        for (const [rhsKeyU, rhsValue] of rhsEntries) {
            const rhsKey = rhsKeyU;
            const lhsValue = lhsMisc[rhsKey];
            if (typeof lhsValue === "function" || typeof rhsValue === "function") {
                // They're both functions that can be merged (or one's a function and the other's null).
                // Not an *easy* case, but a well-defined one.
                const merged = mergeFunctions(lhsValue, rhsValue);
                ret[rhsKey] = merged;
            }
            else {
                // Uh...we're here because one of them's null, right?
                if (lhsValue == null && rhsValue == null) {
                    if (rhsValue === null && lhsValue === undefined)
                        ret[rhsKey] = rhsValue;
                    else
                        ret[rhsKey] = lhsValue;
                }
                if (lhsValue == null)
                    ret[rhsKey] = rhsValue;
                else if (rhsValue == null)
                    ret[rhsKey] = lhsValue;
                else if (rhsValue == lhsValue) ;
                else {
                    // Ugh.
                    // No good strategies here, just log it if requested
                    log?.(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
                    ret[rhsKey] = rhsValue;
                }
            }
        }
        return ret;
    }
    function mergeFunctions(lhs, rhs) {
        if (!lhs)
            return rhs;
        if (!rhs)
            return lhs;
        return (...args) => {
            const lv = lhs(...args);
            const rv = rhs(...args);
            if (lv instanceof Promise || rv instanceof Promise)
                return Promise.all([lv, rv]);
        };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    function useDraggable({ effectAllowed, data, dragImage, dragImageXOffset, dragImageYOffset }) {
        const [dragging, setDragging, getDragging] = useState(false);
        const [lastDropEffect, setLastDropEffect, getLastDropEffect] = useState(null);
        const useDraggableProps = T$1((p) => {
            const ref = s(null);
            const onDragStart = (e) => {
                //e.preventDefault();
                setDragging(true);
                if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = (effectAllowed ?? "all");
                    if (dragImage)
                        e.dataTransfer.setDragImage(dragImage, dragImageXOffset ?? 0, dragImageYOffset ?? 0);
                    const entries = Object.entries(data);
                    for (const [mimeType, data] of entries) {
                        e.dataTransfer.setData(mimeType, data);
                    }
                }
            };
            const onDragEnd = (e) => {
                e.preventDefault();
                setDragging(false);
                if (e.dataTransfer) {
                    if (e.dataTransfer.dropEffect != "none") {
                        setLastDropEffect(e.dataTransfer.dropEffect);
                    }
                    else {
                        setLastDropEffect(null);
                    }
                }
            };
            return useMergedProps({
                draggable: true,
                onDragStart,
                onDragEnd,
                ref
            }, p);
        }, [effectAllowed, dragImage, dragImageXOffset, dragImageYOffset, ...Object.entries(data).flat()]);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        const ret = {
            useDraggableProps,
            dragging,
            getDragging,
            lastDropEffect,
            getLastDropEffect
        };
        return ret;
    }

    class DroppableFileError extends Error {
        fileName;
        errorType;
        constructor(fileName, base) {
            super(base?.message ?? "An unspecified error occurred reading the file.");
            this.fileName = fileName;
            this.errorType = base?.name;
        }
    }
    function useDroppable({ effect }) {
        const [filesForConsideration, setFilesForConsideration] = useState(null);
        const [stringsForConsideration, setStringsForConsideration] = useState(null);
        const [droppedFiles, setDroppedFiles] = useState(null);
        const [droppedStrings, setDroppedStrings] = useState(null);
        const [dropError, setDropError] = useState(undefined);
        // All the promises generated from the drop events.
        // Used to process multiple drop events in succession
        const dropPromisesRef = s([]);
        const [currentPromiseIndex, setCurrentPromiseIndex, getCurrentPromiseIndex] = useState(-1);
        const [promiseCount, setPromiseCount, getPromiseCount] = useState(0);
        // Any time we add a new promise, if there's no current promise running, we need to start one.
        // If there is one, then we don't need to do anything, since it runs the same check.
        _(() => {
            const currentPromiseIndex = getCurrentPromiseIndex();
            const promiseCount = getPromiseCount();
            if (promiseCount > 0) {
                if ((currentPromiseIndex + 1) < promiseCount) {
                    setCurrentPromiseIndex(i => ++i);
                }
            }
        }, [promiseCount]);
        // Anytime our current promise changes,
        // wait for it to finish, then set our state to its result.
        // Finally, check to see if there are anymore promises.
        // If there are, then increase currentPromiseCount,
        // which will trigger this again.
        //
        // This shouldn't happen *often*, but maybe in the case of
        // individually dropping a bunch of large files or something.
        _(() => {
            if (currentPromiseIndex >= 0) {
                const currentPromise = dropPromisesRef.current[currentPromiseIndex];
                currentPromise.then((info) => {
                    if (info !== null) {
                        const { files, strings } = info;
                        setDroppedFiles(files);
                        setDroppedStrings(strings);
                    }
                    // Now that we're done, are there more promises in the queue?
                    const currentPromiseIndex = getCurrentPromiseIndex();
                    const promiseCount = getPromiseCount();
                    if ((currentPromiseIndex + 1) < promiseCount) {
                        // Since this promise has started, more have been added.
                        // Run this effect again.
                        setCurrentPromiseIndex(i => ++i);
                    }
                });
            }
        }, [currentPromiseIndex]);
        const useDroppableProps = (p) => {
            //const ref = useRef<E>(null);
            // Handle collecting the current file metadata or MIME types.
            const onDragEnter = (e) => {
                e.preventDefault();
                if (e.dataTransfer) {
                    // Is there a default? I can't find one anywhere.
                    e.dataTransfer.dropEffect = (effect ?? "move");
                    const newMimeTypes = new Set();
                    const newFiles = new Array();
                    for (const item of e.dataTransfer?.items ?? []) {
                        const { kind, type } = item;
                        if (kind === "string") {
                            newMimeTypes.add(type);
                        }
                        else if (kind === "file") {
                            newFiles.push({ type: item.type });
                        }
                    }
                    setFilesForConsideration(newFiles);
                    setStringsForConsideration(newMimeTypes);
                }
            };
            // Handle resetting the current file metadata or MIME types
            const onDragLeave = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
            };
            // Boilerplate, I guess
            const onDragOver = (e) => {
                e.preventDefault();
            };
            // Handle getting the drop data asynchronously
            const onDrop = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
                const allPromises = new Array();
                const dropData = {};
                const dropFile = [];
                for (const item of e.dataTransfer?.items ?? []) {
                    const { kind, type } = item;
                    if (kind === "string") {
                        allPromises.push((new Promise((resolve, _reject) => item.getAsString(resolve))).then(str => dropData[type] = str));
                    }
                    else if (kind === "file") {
                        const file = item.getAsFile();
                        if (file) {
                            allPromises.push(new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (_) => {
                                    resolve();
                                    const data = reader.result;
                                    dropFile.push({ data, name: file.name, type: file.type, size: data.byteLength, lastModified: file.lastModified });
                                };
                                reader.onerror = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.onabort = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.readAsArrayBuffer(file);
                            }));
                            dropFile.push();
                        }
                    }
                }
                dropPromisesRef.current.push(Promise.all(allPromises).then(() => {
                    setPromiseCount(i => ++i);
                    setDropError(null);
                    return {
                        strings: dropData,
                        files: dropFile
                    };
                }).catch(ex => {
                    /* eslint-disable no-debugger */
                    debugger;
                    setPromiseCount(i => ++i);
                    setDropError(ex);
                    return null;
                }));
            };
            return useMergedProps({ onDragEnter, onDragLeave, onDragOver, onDrop }, p);
        };
        return {
            useDroppableProps,
            filesForConsideration,
            stringsForConsideration,
            droppedFiles,
            droppedStrings,
            dropError
        };
    }

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */
    function useRefElement(args) {
        const { onElementChange, onMount, onUnmount } = (args ?? {});
        useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
        // Called (indirectly) by the ref that the element receives.
        const handler = T$1((e, prevValue) => {
            const cleanup = onElementChange?.(e, prevValue);
            if (prevValue)
                onUnmount?.(prevValue);
            if (e)
                onMount?.(e);
            return cleanup;
        }, []);
        // Let us store the actual (reference to) the element we capture
        const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
        const useRefElementProps = T$1((props) => useMergedProps({ ref: setElement }, props), []);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        return {
            useRefElementProps,
            getElement
        };
    }
    function runImmediately(f) {
        f();
    }

    function useElementSize({ getObserveBox, onSizeChange }) {
        useEnsureStability("useElementSize", getObserveBox, onSizeChange);
        const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
        const currentObserveBox = s(undefined);
        const needANewObserver = T$1((element, observeBox) => {
            if (element) {
                const document = getDocument$2(element);
                const window = document.defaultView;
                const handleUpdate = () => {
                    if (element.isConnected) {
                        const { clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop } = element;
                        setSize({ clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop });
                    }
                };
                if (window && ("ResizeObserver" in window)) {
                    const observer = new ResizeObserver((_entries) => { handleUpdate(); });
                    observer.observe(element, { box: observeBox });
                    return () => observer.disconnect();
                }
                else {
                    document.addEventListener("resize", handleUpdate, { passive: true });
                    return () => document.removeEventListener("resize", handleUpdate);
                }
            }
        }, []);
        const { getElement, useRefElementProps } = useRefElement({ onElementChange: T$1((e) => needANewObserver(e, getObserveBox?.()), []) });
        _(() => {
            if (getObserveBox) {
                if (currentObserveBox.current !== getObserveBox())
                    needANewObserver(getElement(), getObserveBox());
            }
        });
        return {
            getElement,
            getSize,
            useElementSizeProps: useRefElementProps
        };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */
    function useGlobalHandler(target, type, handler, options) {
        // Note to self: The typing doesn't improve even if this is split up into a sub-function.
        // No matter what, it seems impossible to get the handler's event object typed perfectly.
        // It seems like it's guaranteed to always be a union of all available tupes.
        // Again, no matter what combination of sub- or sub-sub-functions used.
        let stableHandler = useStableCallback(handler ?? (() => { }));
        if (handler == null)
            stableHandler = null;
        _(() => {
            if (stableHandler) {
                target.addEventListener(type, stableHandler, options);
                return () => target.removeEventListener(type, stableHandler, options);
            }
        }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot;

      // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);

      if (!displayCheck || displayCheck === 'full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (nodeIsAttached) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck` mode


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
    	(function (global, factory) {
    	  factory() ;
    	}(commonjsGlobal, (function () {
    	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	  /**
    	   * This work is licensed under the W3C Software and Document License
    	   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
    	   */

    	  (function () {
    	    // Return early if we're not running inside of the browser.
    	    if (typeof window === 'undefined') {
    	      return;
    	    }

    	    // Convenience function for converting NodeLists.
    	    /** @type {typeof Array.prototype.slice} */
    	    var slice = Array.prototype.slice;

    	    /**
    	     * IE has a non-standard name for "matches".
    	     * @type {typeof Element.prototype.matches}
    	     */
    	    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    	    /** @type {string} */
    	    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    	    /**
    	     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
    	     * attribute.
    	     *
    	     * Its main functions are:
    	     *
    	     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
    	     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
    	     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
    	     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
    	     *   instance exists for each focusable node which has at least one inert root as an ancestor.
    	     *
    	     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
    	     *   attribute is removed from the root node). This is handled in the destructor, which calls the
    	     *   `deregister` method on `InertManager` for each managed inert node.
    	     */

    	    var InertRoot = function () {
    	      /**
    	       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
    	       * @param {!InertManager} inertManager The global singleton InertManager object.
    	       */
    	      function InertRoot(rootElement, inertManager) {
    	        _classCallCheck(this, InertRoot);

    	        /** @type {!InertManager} */
    	        this._inertManager = inertManager;

    	        /** @type {!HTMLElement} */
    	        this._rootElement = rootElement;

    	        /**
    	         * @type {!Set<!InertNode>}
    	         * All managed focusable nodes in this InertRoot's subtree.
    	         */
    	        this._managedNodes = new Set();

    	        // Make the subtree hidden from assistive technology
    	        if (this._rootElement.hasAttribute('aria-hidden')) {
    	          /** @type {?string} */
    	          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
    	        } else {
    	          this._savedAriaHidden = null;
    	        }
    	        this._rootElement.setAttribute('aria-hidden', 'true');

    	        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
    	        this._makeSubtreeUnfocusable(this._rootElement);

    	        // Watch for:
    	        // - any additions in the subtree: make them unfocusable too
    	        // - any removals from the subtree: remove them from this inert root's managed nodes
    	        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
    	        //   element, make that node a managed node.
    	        this._observer = new MutationObserver(this._onMutation.bind(this));
    	        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
    	       * stored in this object and updates the state of all of the managed nodes.
    	       */


    	      _createClass(InertRoot, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._observer.disconnect();

    	          if (this._rootElement) {
    	            if (this._savedAriaHidden !== null) {
    	              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
    	            } else {
    	              this._rootElement.removeAttribute('aria-hidden');
    	            }
    	          }

    	          this._managedNodes.forEach(function (inertNode) {
    	            this._unmanageNode(inertNode.node);
    	          }, this);

    	          // Note we cast the nulls to the ANY type here because:
    	          // 1) We want the class properties to be declared as non-null, or else we
    	          //    need even more casts throughout this code. All bets are off if an
    	          //    instance has been destroyed and a method is called.
    	          // 2) We don't want to cast "this", because we want type-aware optimizations
    	          //    to know which properties we're setting.
    	          this._observer = /** @type {?} */null;
    	          this._rootElement = /** @type {?} */null;
    	          this._managedNodes = /** @type {?} */null;
    	          this._inertManager = /** @type {?} */null;
    	        }

    	        /**
    	         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
    	         */

    	      }, {
    	        key: '_makeSubtreeUnfocusable',


    	        /**
    	         * @param {!Node} startNode
    	         */
    	        value: function _makeSubtreeUnfocusable(startNode) {
    	          var _this2 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this2._visitNode(node);
    	          });

    	          var activeElement = document.activeElement;

    	          if (!document.body.contains(startNode)) {
    	            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
    	            var node = startNode;
    	            /** @type {!ShadowRoot|undefined} */
    	            var root = undefined;
    	            while (node) {
    	              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    	                root = /** @type {!ShadowRoot} */node;
    	                break;
    	              }
    	              node = node.parentNode;
    	            }
    	            if (root) {
    	              activeElement = root.activeElement;
    	            }
    	          }
    	          if (startNode.contains(activeElement)) {
    	            activeElement.blur();
    	            // In IE11, if an element is already focused, and then set to tabindex=-1
    	            // calling blur() will not actually move the focus.
    	            // To work around this we call focus() on the body instead.
    	            if (activeElement === document.activeElement) {
    	              document.body.focus();
    	            }
    	          }
    	        }

    	        /**
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_visitNode',
    	        value: function _visitNode(node) {
    	          if (node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */node;

    	          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
    	          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
    	          if (element !== this._rootElement && element.hasAttribute('inert')) {
    	            this._adoptInertRoot(element);
    	          }

    	          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
    	            this._manageNode(element);
    	          }
    	        }

    	        /**
    	         * Register the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_manageNode',
    	        value: function _manageNode(node) {
    	          var inertNode = this._inertManager.register(node, this);
    	          this._managedNodes.add(inertNode);
    	        }

    	        /**
    	         * Unregister the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_unmanageNode',
    	        value: function _unmanageNode(node) {
    	          var inertNode = this._inertManager.deregister(node, this);
    	          if (inertNode) {
    	            this._managedNodes['delete'](inertNode);
    	          }
    	        }

    	        /**
    	         * Unregister the entire subtree starting at `startNode`.
    	         * @param {!Node} startNode
    	         */

    	      }, {
    	        key: '_unmanageSubtree',
    	        value: function _unmanageSubtree(startNode) {
    	          var _this3 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this3._unmanageNode(node);
    	          });
    	        }

    	        /**
    	         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
    	         * @param {!HTMLElement} node
    	         */

    	      }, {
    	        key: '_adoptInertRoot',
    	        value: function _adoptInertRoot(node) {
    	          var inertSubroot = this._inertManager.getInertRoot(node);

    	          // During initialisation this inert root may not have been registered yet,
    	          // so register it now if need be.
    	          if (!inertSubroot) {
    	            this._inertManager.setInert(node, true);
    	            inertSubroot = this._inertManager.getInertRoot(node);
    	          }

    	          inertSubroot.managedNodes.forEach(function (savedInertNode) {
    	            this._manageNode(savedInertNode.node);
    	          }, this);
    	        }

    	        /**
    	         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_onMutation',
    	        value: function _onMutation(records, self) {
    	          records.forEach(function (record) {
    	            var target = /** @type {!HTMLElement} */record.target;
    	            if (record.type === 'childList') {
    	              // Manage added nodes
    	              slice.call(record.addedNodes).forEach(function (node) {
    	                this._makeSubtreeUnfocusable(node);
    	              }, this);

    	              // Un-manage removed nodes
    	              slice.call(record.removedNodes).forEach(function (node) {
    	                this._unmanageSubtree(node);
    	              }, this);
    	            } else if (record.type === 'attributes') {
    	              if (record.attributeName === 'tabindex') {
    	                // Re-initialise inert node if tabindex changes
    	                this._manageNode(target);
    	              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
    	                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
    	                // already managed nodes from this inert subroot.
    	                this._adoptInertRoot(target);
    	                var inertSubroot = this._inertManager.getInertRoot(target);
    	                this._managedNodes.forEach(function (managedNode) {
    	                  if (target.contains(managedNode.node)) {
    	                    inertSubroot._manageNode(managedNode.node);
    	                  }
    	                });
    	              }
    	            }
    	          }, this);
    	        }
    	      }, {
    	        key: 'managedNodes',
    	        get: function get() {
    	          return new Set(this._managedNodes);
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'hasSavedAriaHidden',
    	        get: function get() {
    	          return this._savedAriaHidden !== null;
    	        }

    	        /** @param {?string} ariaHidden */

    	      }, {
    	        key: 'savedAriaHidden',
    	        set: function set(ariaHidden) {
    	          this._savedAriaHidden = ariaHidden;
    	        }

    	        /** @return {?string} */
    	        ,
    	        get: function get() {
    	          return this._savedAriaHidden;
    	        }
    	      }]);

    	      return InertRoot;
    	    }();

    	    /**
    	     * `InertNode` initialises and manages a single inert node.
    	     * A node is inert if it is a descendant of one or more inert root elements.
    	     *
    	     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
    	     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
    	     * is intrinsically focusable or not.
    	     *
    	     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
    	     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
    	     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
    	     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
    	     * or removes the `tabindex` attribute if the element is intrinsically focusable.
    	     */


    	    var InertNode = function () {
    	      /**
    	       * @param {!Node} node A focusable element to be made inert.
    	       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
    	       */
    	      function InertNode(node, inertRoot) {
    	        _classCallCheck(this, InertNode);

    	        /** @type {!Node} */
    	        this._node = node;

    	        /** @type {boolean} */
    	        this._overrodeFocusMethod = false;

    	        /**
    	         * @type {!Set<!InertRoot>} The set of descendant inert roots.
    	         *    If and only if this set becomes empty, this node is no longer inert.
    	         */
    	        this._inertRoots = new Set([inertRoot]);

    	        /** @type {?number} */
    	        this._savedTabIndex = null;

    	        /** @type {boolean} */
    	        this._destroyed = false;

    	        // Save any prior tabindex info and make this node untabbable
    	        this.ensureUntabbable();
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.
    	       * This makes the managed node focusable again and deletes all of the previously stored state.
    	       */


    	      _createClass(InertNode, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._throwIfDestroyed();

    	          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
    	            var element = /** @type {!HTMLElement} */this._node;
    	            if (this._savedTabIndex !== null) {
    	              element.setAttribute('tabindex', this._savedTabIndex);
    	            } else {
    	              element.removeAttribute('tabindex');
    	            }

    	            // Use `delete` to restore native focus method.
    	            if (this._overrodeFocusMethod) {
    	              delete element.focus;
    	            }
    	          }

    	          // See note in InertRoot.destructor for why we cast these nulls to ANY.
    	          this._node = /** @type {?} */null;
    	          this._inertRoots = /** @type {?} */null;
    	          this._destroyed = true;
    	        }

    	        /**
    	         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
    	         * If the object has been destroyed, any attempt to access it will cause an exception.
    	         */

    	      }, {
    	        key: '_throwIfDestroyed',


    	        /**
    	         * Throw if user tries to access destroyed InertNode.
    	         */
    	        value: function _throwIfDestroyed() {
    	          if (this.destroyed) {
    	            throw new Error('Trying to access destroyed InertNode');
    	          }
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'ensureUntabbable',


    	        /** Save the existing tabindex value and make the node untabbable and unfocusable */
    	        value: function ensureUntabbable() {
    	          if (this.node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */this.node;
    	          if (matches.call(element, _focusableElementsString)) {
    	            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
    	              return;
    	            }

    	            if (element.hasAttribute('tabindex')) {
    	              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            }
    	            element.setAttribute('tabindex', '-1');
    	            if (element.nodeType === Node.ELEMENT_NODE) {
    	              element.focus = function () {};
    	              this._overrodeFocusMethod = true;
    	            }
    	          } else if (element.hasAttribute('tabindex')) {
    	            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            element.removeAttribute('tabindex');
    	          }
    	        }

    	        /**
    	         * Add another inert root to this inert node's set of managing inert roots.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'addInertRoot',
    	        value: function addInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots.add(inertRoot);
    	        }

    	        /**
    	         * Remove the given inert root from this inert node's set of managing inert roots.
    	         * If the set of managing inert roots becomes empty, this node is no longer inert,
    	         * so the object should be destroyed.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'removeInertRoot',
    	        value: function removeInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots['delete'](inertRoot);
    	          if (this._inertRoots.size === 0) {
    	            this.destructor();
    	          }
    	        }
    	      }, {
    	        key: 'destroyed',
    	        get: function get() {
    	          return (/** @type {!InertNode} */this._destroyed
    	          );
    	        }
    	      }, {
    	        key: 'hasSavedTabIndex',
    	        get: function get() {
    	          return this._savedTabIndex !== null;
    	        }

    	        /** @return {!Node} */

    	      }, {
    	        key: 'node',
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._node;
    	        }

    	        /** @param {?number} tabIndex */

    	      }, {
    	        key: 'savedTabIndex',
    	        set: function set(tabIndex) {
    	          this._throwIfDestroyed();
    	          this._savedTabIndex = tabIndex;
    	        }

    	        /** @return {?number} */
    	        ,
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._savedTabIndex;
    	        }
    	      }]);

    	      return InertNode;
    	    }();

    	    /**
    	     * InertManager is a per-document singleton object which manages all inert roots and nodes.
    	     *
    	     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
    	     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
    	     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
    	     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
    	     * is created for each such node, via the `_managedNodes` map.
    	     */


    	    var InertManager = function () {
    	      /**
    	       * @param {!Document} document
    	       */
    	      function InertManager(document) {
    	        _classCallCheck(this, InertManager);

    	        if (!document) {
    	          throw new Error('Missing required argument; InertManager needs to wrap a document.');
    	        }

    	        /** @type {!Document} */
    	        this._document = document;

    	        /**
    	         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertNode>}
    	         */
    	        this._managedNodes = new Map();

    	        /**
    	         * All inert roots known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertRoot>}
    	         */
    	        this._inertRoots = new Map();

    	        /**
    	         * Observer for mutations on `document.body`.
    	         * @type {!MutationObserver}
    	         */
    	        this._observer = new MutationObserver(this._watchForInert.bind(this));

    	        // Add inert style.
    	        addInertStyle(document.head || document.body || document.documentElement);

    	        // Wait for document to be loaded.
    	        if (document.readyState === 'loading') {
    	          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
    	        } else {
    	          this._onDocumentLoaded();
    	        }
    	      }

    	      /**
    	       * Set whether the given element should be an inert root or not.
    	       * @param {!HTMLElement} root
    	       * @param {boolean} inert
    	       */


    	      _createClass(InertManager, [{
    	        key: 'setInert',
    	        value: function setInert(root, inert) {
    	          if (inert) {
    	            if (this._inertRoots.has(root)) {
    	              // element is already inert
    	              return;
    	            }

    	            var inertRoot = new InertRoot(root, this);
    	            root.setAttribute('inert', '');
    	            this._inertRoots.set(root, inertRoot);
    	            // If not contained in the document, it must be in a shadowRoot.
    	            // Ensure inert styles are added there.
    	            if (!this._document.body.contains(root)) {
    	              var parent = root.parentNode;
    	              while (parent) {
    	                if (parent.nodeType === 11) {
    	                  addInertStyle(parent);
    	                }
    	                parent = parent.parentNode;
    	              }
    	            }
    	          } else {
    	            if (!this._inertRoots.has(root)) {
    	              // element is already non-inert
    	              return;
    	            }

    	            var _inertRoot = this._inertRoots.get(root);
    	            _inertRoot.destructor();
    	            this._inertRoots['delete'](root);
    	            root.removeAttribute('inert');
    	          }
    	        }

    	        /**
    	         * Get the InertRoot object corresponding to the given inert root element, if any.
    	         * @param {!Node} element
    	         * @return {!InertRoot|undefined}
    	         */

    	      }, {
    	        key: 'getInertRoot',
    	        value: function getInertRoot(element) {
    	          return this._inertRoots.get(element);
    	        }

    	        /**
    	         * Register the given InertRoot as managing the given node.
    	         * In the case where the node has a previously existing inert root, this inert root will
    	         * be added to its set of inert roots.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {!InertNode} inertNode
    	         */

    	      }, {
    	        key: 'register',
    	        value: function register(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (inertNode !== undefined) {
    	            // node was already in an inert subtree
    	            inertNode.addInertRoot(inertRoot);
    	          } else {
    	            inertNode = new InertNode(node, inertRoot);
    	          }

    	          this._managedNodes.set(node, inertNode);

    	          return inertNode;
    	        }

    	        /**
    	         * De-register the given InertRoot as managing the given inert node.
    	         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
    	         * node from the InertManager's set of managed nodes if it is destroyed.
    	         * If the node is not currently managed, this is essentially a no-op.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
    	         */

    	      }, {
    	        key: 'deregister',
    	        value: function deregister(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (!inertNode) {
    	            return null;
    	          }

    	          inertNode.removeInertRoot(inertRoot);
    	          if (inertNode.destroyed) {
    	            this._managedNodes['delete'](node);
    	          }

    	          return inertNode;
    	        }

    	        /**
    	         * Callback used when document has finished loading.
    	         */

    	      }, {
    	        key: '_onDocumentLoaded',
    	        value: function _onDocumentLoaded() {
    	          // Find all inert roots in document and make them actually inert.
    	          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
    	          inertElements.forEach(function (inertElement) {
    	            this.setInert(inertElement, true);
    	          }, this);

    	          // Comment this out to use programmatic API only.
    	          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });
    	        }

    	        /**
    	         * Callback used when mutation observer detects attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_watchForInert',
    	        value: function _watchForInert(records, self) {
    	          var _this = this;
    	          records.forEach(function (record) {
    	            switch (record.type) {
    	              case 'childList':
    	                slice.call(record.addedNodes).forEach(function (node) {
    	                  if (node.nodeType !== Node.ELEMENT_NODE) {
    	                    return;
    	                  }
    	                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
    	                  if (matches.call(node, '[inert]')) {
    	                    inertElements.unshift(node);
    	                  }
    	                  inertElements.forEach(function (inertElement) {
    	                    this.setInert(inertElement, true);
    	                  }, _this);
    	                }, _this);
    	                break;
    	              case 'attributes':
    	                if (record.attributeName !== 'inert') {
    	                  return;
    	                }
    	                var target = /** @type {!HTMLElement} */record.target;
    	                var inert = target.hasAttribute('inert');
    	                _this.setInert(target, inert);
    	                break;
    	            }
    	          }, this);
    	        }
    	      }]);

    	      return InertManager;
    	    }();

    	    /**
    	     * Recursively walk the composed tree from |node|.
    	     * @param {!Node} node
    	     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
    	     *     before descending into child nodes.
    	     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
    	     */


    	    function composedTreeWalk(node, callback, shadowRootAncestor) {
    	      if (node.nodeType == Node.ELEMENT_NODE) {
    	        var element = /** @type {!HTMLElement} */node;
    	        if (callback) {
    	          callback(element);
    	        }

    	        // Descend into node:
    	        // If it has a ShadowRoot, ignore all child elements - these will be picked
    	        // up by the <content> or <shadow> elements. Descend straight into the
    	        // ShadowRoot.
    	        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
    	        if (shadowRoot) {
    	          composedTreeWalk(shadowRoot, callback);
    	          return;
    	        }

    	        // If it is a <content> element, descend into distributed elements - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'content') {
    	          var content = /** @type {!HTMLContentElement} */element;
    	          // Verifies if ShadowDom v0 is supported.
    	          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
    	          for (var i = 0; i < distributedNodes.length; i++) {
    	            composedTreeWalk(distributedNodes[i], callback);
    	          }
    	          return;
    	        }

    	        // If it is a <slot> element, descend into assigned nodes - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'slot') {
    	          var slot = /** @type {!HTMLSlotElement} */element;
    	          // Verify if ShadowDom v1 is supported.
    	          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];
    	          for (var _i = 0; _i < _distributedNodes.length; _i++) {
    	            composedTreeWalk(_distributedNodes[_i], callback);
    	          }
    	          return;
    	        }
    	      }

    	      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
    	      // element, nor a <shadow> element recurse normally.
    	      var child = node.firstChild;
    	      while (child != null) {
    	        composedTreeWalk(child, callback);
    	        child = child.nextSibling;
    	      }
    	    }

    	    /**
    	     * Adds a style element to the node containing the inert specific styles
    	     * @param {!Node} node
    	     */
    	    function addInertStyle(node) {
    	      if (node.querySelector('style#inert-style, link#inert-style')) {
    	        return;
    	      }
    	      var style = document.createElement('style');
    	      style.setAttribute('id', 'inert-style');
    	      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
    	      node.appendChild(style);
    	    }

    	    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
    	      /** @type {!InertManager} */
    	      var inertManager = new InertManager(document);

    	      Object.defineProperty(HTMLElement.prototype, 'inert', {
    	        enumerable: true,
    	        /** @this {!HTMLElement} */
    	        get: function get() {
    	          return this.hasAttribute('inert');
    	        },
    	        /** @this {!HTMLElement} */
    	        set: function set(inert) {
    	          inertManager.setInert(this, inert);
    	        }
    	      });
    	    }
    	  })();

    	})));
    } ());

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
        var _a, _b, _c;
        /* Symbols for private properties */
        const _blockingElements = Symbol();
        const _alreadyInertElements = Symbol();
        const _topElParents = Symbol();
        const _siblingsToRestore = Symbol();
        const _parentMO = Symbol();
        /* Symbols for private static methods */
        const _topChanged = Symbol();
        const _swapInertedSibling = Symbol();
        const _inertSiblings = Symbol();
        const _restoreInertedSiblings = Symbol();
        const _getParents = Symbol();
        const _getDistributedChildren = Symbol();
        const _isInertable = Symbol();
        const _handleMutations = Symbol();
        class BlockingElementsImpl {
            constructor() {
                /**
                 * The blocking elements.
                 */
                this[_a] = [];
                /**
                 * Used to keep track of the parents of the top element, from the element
                 * itself up to body. When top changes, the old top might have been removed
                 * from the document, so we need to memoize the inerted parents' siblings
                 * in order to restore their inerteness when top changes.
                 */
                this[_b] = [];
                /**
                 * Elements that are already inert before the first blocking element is
                 * pushed.
                 */
                this[_c] = new Set();
            }
            destructor() {
                // Restore original inertness.
                this[_restoreInertedSiblings](this[_topElParents]);
                // Note we don't want to make these properties nullable on the class,
                // since then we'd need non-null casts in many places. Calling a method on
                // a BlockingElements instance after calling destructor will result in an
                // exception.
                const nullable = this;
                nullable[_blockingElements] = null;
                nullable[_topElParents] = null;
                nullable[_alreadyInertElements] = null;
            }
            get top() {
                const elems = this[_blockingElements];
                return elems[elems.length - 1] || null;
            }
            push(element) {
                if (!element || element === this.top) {
                    return;
                }
                // Remove it from the stack, we'll bring it to the top.
                this.remove(element);
                this[_topChanged](element);
                this[_blockingElements].push(element);
            }
            remove(element) {
                const i = this[_blockingElements].indexOf(element);
                if (i === -1) {
                    return false;
                }
                this[_blockingElements].splice(i, 1);
                // Top changed only if the removed element was the top element.
                if (i === this[_blockingElements].length) {
                    this[_topChanged](this.top);
                }
                return true;
            }
            pop() {
                const top = this.top;
                top && this.remove(top);
                return top;
            }
            has(element) {
                return this[_blockingElements].indexOf(element) !== -1;
            }
            /**
             * Sets `inert` to all document elements except the new top element, its
             * parents, and its distributed content.
             */
            [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
                const toKeepInert = this[_alreadyInertElements];
                const oldParents = this[_topElParents];
                // No new top, reset old top if any.
                if (!newTop) {
                    this[_restoreInertedSiblings](oldParents);
                    toKeepInert.clear();
                    this[_topElParents] = [];
                    return;
                }
                const newParents = this[_getParents](newTop);
                // New top is not contained in the main document!
                if (newParents[newParents.length - 1].parentNode !== document.body) {
                    throw Error('Non-connected element cannot be a blocking element');
                }
                // Cast here because we know we'll call _inertSiblings on newParents
                // below.
                this[_topElParents] = newParents;
                const toSkip = this[_getDistributedChildren](newTop);
                // No previous top element.
                if (!oldParents.length) {
                    this[_inertSiblings](newParents, toSkip, toKeepInert);
                    return;
                }
                let i = oldParents.length - 1;
                let j = newParents.length - 1;
                // Find common parent. Index 0 is the element itself (so stop before it).
                while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
                    i--;
                    j--;
                }
                // If up the parents tree there are 2 elements that are siblings, swap
                // the inerted sibling.
                if (oldParents[i] !== newParents[j]) {
                    this[_swapInertedSibling](oldParents[i], newParents[j]);
                }
                // Restore old parents siblings inertness.
                i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
                // Make new parents siblings inert.
                j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
            }
            /**
             * Swaps inertness between two sibling elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_swapInertedSibling](oldInert, newInert) {
                const siblingsToRestore = oldInert[_siblingsToRestore];
                // oldInert is not contained in siblings to restore, so we have to check
                // if it's inertable and if already inert.
                if (this[_isInertable](oldInert) && !oldInert.inert) {
                    oldInert.inert = true;
                    siblingsToRestore.add(oldInert);
                }
                // If newInert was already between the siblings to restore, it means it is
                // inertable and must be restored.
                if (siblingsToRestore.has(newInert)) {
                    newInert.inert = false;
                    siblingsToRestore.delete(newInert);
                }
                newInert[_parentMO] = oldInert[_parentMO];
                newInert[_siblingsToRestore] = siblingsToRestore;
                oldInert[_parentMO] = undefined;
                oldInert[_siblingsToRestore] = undefined;
            }
            /**
             * Restores original inertness to the siblings of the elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_restoreInertedSiblings](elements) {
                for (const element of elements) {
                    const mo = element[_parentMO];
                    mo.disconnect();
                    element[_parentMO] = undefined;
                    const siblings = element[_siblingsToRestore];
                    for (const sibling of siblings) {
                        sibling.inert = false;
                    }
                    element[_siblingsToRestore] = undefined;
                }
            }
            /**
             * Inerts the siblings of the elements except the elements to skip. Stores
             * the inerted siblings into the element's symbol `_siblingsToRestore`.
             * Pass `toKeepInert` to collect the already inert elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_inertSiblings](elements, toSkip, toKeepInert) {
                for (const element of elements) {
                    // Assume element is not a Document, so it must have a parentNode.
                    const parent = element.parentNode;
                    const children = parent.children;
                    const inertedSiblings = new Set();
                    for (let j = 0; j < children.length; j++) {
                        const sibling = children[j];
                        // Skip the input element, if not inertable or to be skipped.
                        if (sibling === element || !this[_isInertable](sibling) ||
                            (toSkip && toSkip.has(sibling))) {
                            continue;
                        }
                        // Should be collected since already inerted.
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                    // Store the siblings that were inerted.
                    element[_siblingsToRestore] = inertedSiblings;
                    // Observe only immediate children mutations on the parent.
                    const mo = new MutationObserver(this[_handleMutations].bind(this));
                    element[_parentMO] = mo;
                    let parentToObserve = parent;
                    // If we're using the ShadyDOM polyfill, then our parent could be a
                    // shady root, which is an object that acts like a ShadowRoot, but isn't
                    // actually a node in the real DOM. Observe the real DOM parent instead.
                    const maybeShadyRoot = parentToObserve;
                    if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
                        parentToObserve = maybeShadyRoot.host;
                    }
                    mo.observe(parentToObserve, {
                        childList: true,
                    });
                }
            }
            /**
             * Handles newly added/removed nodes by toggling their inertness.
             * It also checks if the current top Blocking Element has been removed,
             * notifying and removing it.
             */
            [_handleMutations](mutations) {
                const parents = this[_topElParents];
                const toKeepInert = this[_alreadyInertElements];
                for (const mutation of mutations) {
                    // If the target is a shadowRoot, get its host as we skip shadowRoots when
                    // computing _topElParents.
                    const target = mutation.target.host || mutation.target;
                    const idx = target === document.body ?
                        parents.length :
                        parents.indexOf(target);
                    const inertedChild = parents[idx - 1];
                    const inertedSiblings = inertedChild[_siblingsToRestore];
                    // To restore.
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        const sibling = mutation.removedNodes[i];
                        if (sibling === inertedChild) {
                            console.info('Detected removal of the top Blocking Element.');
                            this.pop();
                            return;
                        }
                        if (inertedSiblings.has(sibling)) {
                            sibling.inert = false;
                            inertedSiblings.delete(sibling);
                        }
                    }
                    // To inert.
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        const sibling = mutation.addedNodes[i];
                        if (!this[_isInertable](sibling)) {
                            continue;
                        }
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                }
            }
            /**
             * Returns if the element is inertable.
             */
            [_isInertable](element) {
                return false === /^(style|template|script)$/.test(element.localName);
            }
            /**
             * Returns the list of newParents of an element, starting from element
             * (included) up to `document.body` (excluded).
             */
            [_getParents](element) {
                const parents = [];
                let current = element;
                // Stop to body.
                while (current && current !== document.body) {
                    // Skip shadow roots.
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        parents.push(current);
                    }
                    // ShadowDom v1
                    if (current.assignedSlot) {
                        // Collect slots from deepest slot to top.
                        while (current = current.assignedSlot) {
                            parents.push(current);
                        }
                        // Continue the search on the top slot.
                        current = parents.pop();
                        continue;
                    }
                    current = current.parentNode ||
                        current.host;
                }
                return parents;
            }
            /**
             * Returns the distributed children of the element's shadow root.
             * Returns null if the element doesn't have a shadow root.
             */
            [_getDistributedChildren](element) {
                const shadowRoot = element.shadowRoot;
                if (!shadowRoot) {
                    return null;
                }
                const result = new Set();
                let i;
                let j;
                let nodes;
                const slots = shadowRoot.querySelectorAll('slot');
                if (slots.length && slots[0].assignedNodes) {
                    for (i = 0; i < slots.length; i++) {
                        nodes = slots[i].assignedNodes({
                            flatten: true,
                        });
                        for (j = 0; j < nodes.length; j++) {
                            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                                result.add(nodes[j]);
                            }
                        }
                    }
                    // No need to search for <content>.
                }
                return result;
            }
        }
        document.$blockingElements =
            new BlockingElementsImpl();
    })();

    function blockingElements() { return getDocument$2().$blockingElements; }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */
    function useBlockingElement(enabled, getTarget) {
        const stableGetTarget = useStableCallback(getTarget);
        /**
         * Push/pop the element from the blockingElements stack.
         */
        h(() => {
            const target = stableGetTarget();
            if (enabled) {
                // Sometimes blockingElements will fail if, for example,
                // the target element isn't connected to document.body.
                // This is rare, but it's better to fail silently with weird tabbing behavior
                // than to crash the entire application.
                try {
                    blockingElements().push(target);
                    return () => {
                        blockingElements().remove(target);
                    };
                }
                catch (ex) {
                    // Well, semi-silently.
                    console.error(ex);
                }
            }
        }, [enabled]);
    }
    function getTopElement() {
        return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap({ trapActive }) {
        const handleActiveChange = T$1((trapActive, element) => {
            if (trapActive && element) {
                let rafHandle = requestAnimationFrame(() => {
                    // TODO: This extra queueMicrotask is needed for
                    // ...reasons?
                    queueMicrotask(() => {
                        findFirstFocusable(element)?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
            else if (element) {
                // Restore the focus to the element
                // that has returned to the top of the stack
                let rafHandle = requestAnimationFrame(() => {
                    queueMicrotask(() => {
                        elementsToRestoreFocusTo.get(getTopElement())?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
        }, []);
        const { getElement, useRefElementProps } = useRefElement({ onElementChange: useStableCallback((element) => handleActiveChange(trapActive, element)) });
        const { getLastActiveElement } = useActiveElement({ getDocument: useStableCallback(() => getElement()?.ownerDocument ?? window.document) });
        // When the trap becomes active, before we let the blockingElements hook run,
        // keep track of whatever's currently focused and save it.
        h(() => {
            const element = getElement();
            if (trapActive && element) {
                const document = getDocument$2(element);
                // Save the currently focused element
                // to whatever's currently at the top of the stack
                elementsToRestoreFocusTo.set(getTopElement(), getLastActiveElement() ?? document.body);
            }
        }, [trapActive]);
        useBlockingElement(trapActive, getElement);
        /**
         * Any time we activate or deactivate the trap,
         * change focus to something else (something in
         * the trap if it's active, or whatever we've
         * tracked in elementsToRestoreFocusTo if not)
         */
        h(() => {
            handleActiveChange(trapActive, getElement());
        }, [trapActive]);
        const useFocusTrapProps = ((props) => {
            const p1 = useRefElementProps(props);
            const p2 = { "aria-modal": trapActive ? "true" : undefined };
            return useMergedProps(p1, p2);
        });
        return {
            useFocusTrapProps,
            getElement
        };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */
    function findFirstFocusable(element) {
        const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => (node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP) });
        const firstFocusable = treeWalker.firstChild();
        return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */
    function useForceUpdate() {
        const [, set] = y(0);
        return s(() => set(i => ++i)).current;
    }

    function useHasFocus({ onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange, getDocument, getWindow, onElementChange, onMount, onUnmount }) {
        useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
        const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
        const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
        const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse);
        const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse);
        const { getElement, useRefElementProps } = useRefElement({ onElementChange, onMount, onUnmount });
        const { getActiveElement, getLastActiveElement, getWindowFocused } = useActiveElement({
            getDocument,
            getWindow,
            onActiveElementChange: T$1((activeElement, prevActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == activeElement));
                const focusedInner = (!!selfElement?.contains(activeElement));
                setFocused(focused);
                setFocusedInner(focusedInner);
                onActiveElementChange?.(activeElement, prevActiveElement);
            }, []),
            onLastActiveElementChange: T$1((lastActiveElement, prevLastActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == lastActiveElement));
                const focusedInner = (!!selfElement?.contains(lastActiveElement));
                setLastFocused(focused);
                setLastFocusedInner(focusedInner);
                onLastActiveElementChange?.(lastActiveElement, prevLastActiveElement);
            }, []),
            onWindowFocusedChange
        });
        const useHasFocusProps = T$1((props) => { return useRefElementProps(props); }, []);
        return {
            useHasFocusProps,
            getElement,
            getFocused,
            getFocusedInner,
            getLastFocused,
            getLastFocusedInner,
            getActiveElement,
            getLastActiveElement,
            getWindowFocused
        };
    }
    function useChildrenHaveFocus({ childrenHaveFocus: { onAllLostFocus, onAnyGainedFocus }, managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } }) {
        const { managedChildren, useManagedChild } = useManagedChildren({ managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } });
        const allElementsRef = s(new Set());
        const [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
            console.log(`Changing focus count from ${anyPreviouslyFocused} to ${anyFocused}`);
            console.assert(anyFocused >= 0 && anyFocused <= 1);
            if (anyFocused && !anyPreviouslyFocused)
                onAnyGainedFocus?.();
            if (!anyFocused && anyPreviouslyFocused)
                onAllLostFocus?.();
        }));
        const useChildrenHaveFocusChild = T$1(({ onElementChange, onMount, onUnmount, getDocument, getWindow, onActiveElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onWindowFocusedChange, managedChild: { index, flags } }) => {
            useManagedChild({ managedChild: { index, subInfo: {}, flags } });
            const { useHasFocusProps, ...hasFocus } = useHasFocus({
                getDocument,
                getWindow,
                onActiveElementChange,
                onElementChange: T$1((e, prev) => {
                    let r = onElementChange?.(e, prev);
                    if (e) {
                        allElementsRef.current.add(e);
                        return () => {
                            r?.();
                            allElementsRef.current.delete(e);
                        };
                    }
                }, [onElementChange]),
                onMount,
                onUnmount,
                onFocusedChanged,
                onFocusedInnerChanged,
                onLastActiveElementChange,
                onLastFocusedChanged,
                onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
                    if (focused) {
                        console.log(`Child ${index} is focused`);
                        setFocusCount(p => (p ?? 0) + 1);
                    }
                    else if (!focused && prev) {
                        console.log(`Child ${index} is unfocused`);
                        setFocusCount(p => (p ?? 0) - 1);
                    }
                    onLastFocusedInnerChanged?.(focused, prev);
                }),
                onWindowFocusedChange
            });
            return {
                useChildrenHaveFocusChildProps: useHasFocusProps,
                ...hasFocus
            };
        }, []);
        return {
            managedChildren,
            useChildrenHaveFocusChild
        };
    }

    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * any element, whether it's a native <BUTTON> or regular <DIV>.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */
    function usePress({ exclude, hasFocus: { onFocusedInnerChanged, ...hasFocus }, onClickSync }) {
        // A button can be activated in multiple ways, so on the off chance
        // that multiple are triggered at once, we only *actually* register
        // a press once all of our "on" signals have turned back to "off".
        // We approximate this by just incrementing when active, and
        // decrementing when deactivated.
        //
        // As an emergency failsafe, when the element loses focus,
        // this is reset back to 0.
        const [active, setActive, getActive] = useState(0);
        const forceUpdate = useForceUpdate();
        const { useHasFocusProps, getElement } = useHasFocus({
            ...hasFocus,
            onFocusedInnerChanged: useStableCallback((f, p) => {
                onFocusedInnerChanged?.(f, p);
                if (!f) {
                    setActive(0);
                }
            })
        });
        // If we the current text selection changes to include this element
        // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
        // because its only purpose was selecting text, not clicking buttons.
        //
        // To catch this, any time the text selection includes us while in the middle
        // of a click, this flag is set, which cancels the activation of a press.
        // The flag is reset any time the selection is empty or the button is
        // no longer active.
        const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
        const pseudoActive = (active && (textSelectedDuringActivationStartTime == null));
        useGlobalHandler(document, "selectionchange", _ => {
            setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
        });
        _(() => {
            if (active == 0)
                setTextSelectedDuringActivationStartTime(null);
        }, [active == 0]);
        const onActiveStart = useStableCallback((_) => {
            setActive(a => ++a);
        });
        const onActiveStop = useStableCallback((e) => {
            setActive(a => Math.max(0, --a));
            const currentTime = new Date();
            const timeDifference = (textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime);
            const charactersSelected = nodeSelectedTextLength(getElement());
            // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
            // then this isn't a press event.
            // TODO: This should measure glyphs instead of characters.
            if (charactersSelected > 1 || ((timeDifference ?? 0) > 250 && charactersSelected >= 1)) {
                e.preventDefault();
                return;
            }
            if (getActive() <= 0) {
                handlePress(e);
                forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
            }
        });
        const handlePress = useStableCallback((e) => {
            if (onClickSync) {
                // Note: The element is focused here because of iOS Safari.
                //
                // It's always iOS Safari.
                //
                // iOS Safari (tested on 12) downright refuses to allow 
                // elements to be manually focused UNLESS it happens within
                // an event handler like this.  It also doesn't focus
                // buttons by default when clicked, tapped, etc.
                //
                // If it becomes problematic that button-likes explicitly become
                // focused when they are pressed, then an alternative solution for
                // the question of "how do menu buttons keep their menus open"
                // and other focus-related nonsense needs to be figured out.
                //
                // For iOS Safari.
                //
                const element = getElement();
                if (element && "focus" in element)
                    element?.focus();
                // Whatever the browser was going to do with this event,
                // forget it. We're turning it into a "press" event.
                e.preventDefault();
                // Also stop anyone else from listening to this event,
                // since we're explicitly handling it.
                // (Notably, this allows labels to wrap inputs, with them
                // both having press event handlers, without double-firing)
                e.stopPropagation();
                // Haptic feedback for this press event
                try {
                    // The default implementation doesn't throw,
                    // but we should guard against user implementations that could.
                    pulse();
                }
                finally {
                    // Actually call our handler.
                    onClickSync(e);
                }
            }
        });
        const onMouseDown = excludes("click", exclude) ? undefined : (e) => {
            // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
            // but also don't prevent the user from selecting that text manually if they really want to
            // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
            if (e.detail > 1)
                e.preventDefault();
            if (e.button === 0)
                onActiveStart(e);
        };
        const onMouseUp = excludes("click", exclude) ? undefined : (e) => {
            if (e.button === 0 && active > 0)
                onActiveStop(e);
        };
        const onMouseLeave = useStableCallback(() => {
            if (!excludes("click", exclude))
                setActive(0);
        });
        const onKeyDown = excludes("space", exclude) && excludes("enter", exclude) ? undefined : (e) => {
            if (e.key == " " && onClickSync && !excludes("space", exclude)) {
                // We don't actually activate it on a space keydown
                // but we do preventDefault to stop the page from scrolling.
                onActiveStart(e);
                e.preventDefault();
            }
            if (e.key == "Enter" && !excludes("enter", exclude)) {
                e.preventDefault();
                onActiveStart(e);
                onActiveStop(e);
            }
        };
        const onKeyUp = excludes("space", exclude) ? undefined : (e) => {
            if (e.key == " " && !excludes("space", exclude))
                onActiveStop(e);
        };
        const onClick = (e) => {
            e.preventDefault();
            if (e.detail > 1) {
                e.stopImmediatePropagation();
                e.stopPropagation();
            }
        };
        return function usePressProps(props) {
            return useMergedProps(props, useHasFocusProps(({
                onKeyDown,
                onKeyUp,
                onMouseDown,
                onMouseUp,
                onMouseLeave,
                onClick,
                style: (textSelectedDuringActivationStartTime != null) ? { cursor: "text" } : undefined,
                ...{ "data-pseudo-active": pseudoActive ? "true" : undefined }
            })));
        };
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */
    function nodeSelectedTextLength(element) {
        if (element && element instanceof Node) {
            const selection = window.getSelection();
            for (let i = 0; i < (selection?.rangeCount ?? 0); ++i) {
                const range = selection.getRangeAt(i);
                if (element.contains(range.endContainer) && !selection?.isCollapsed) {
                    return selection.toString().length;
                }
            }
        }
        return 0;
    }
    let pulse = (("vibrate" in navigator) && (navigator.vibrate instanceof Function)) ? (() => navigator.vibrate(10)) : (() => { });
    function excludes(target, exclude) {
        if (exclude?.[target])
            return true;
        return false;
    }

    function capitalize(str) {
        return (str[0].toUpperCase() + str.substring(1));
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */
    function useLogicalDirection({ onLogicalDirectionChange }) {
        useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
        const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
        const { getElement, useRefElementProps } = useRefElement({
            onElementChange: T$1((element) => {
                if (element) {
                    setComputedStyles(window.getComputedStyle(element));
                }
            }, [])
        });
        // TODO: There's no way to refresh which writing mode we have once mounted.
        //   A. There's no way to watch for CSS style changes
        //   B. Calling getComputedStyle after every render for every element gets expensive fast and
        //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
        //      (Those that do will need to mount and unmount the component that uses it)
        //
        // As a solution, here's a cheap workaround that checks when the element's size has changed,
        // and if so, tests if the writing mode has changed too.
        //
        // This will work for at least some number of cases, but a better solution is still needed.
        const { useElementSizeProps } = useElementSize({ onSizeChange: T$1(_ => onLogicalDirectionChange?.(getLogicalDirectionInfo()), []) });
        const getLogicalDirectionInfo = T$1(() => {
            const computedStyles = getComputedStyles();
            if (computedStyles) {
                const w = computedStyles.writingMode;
                let d = computedStyles.direction;
                const t = computedStyles.textOrientation;
                if (t == "upright")
                    d = "ltr";
                return ({ ...WritingModes[w || "horizontal-tb"][d || "ltr"] });
            }
            return null;
        }, []);
        //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);
        const convertToLogicalOrientation = T$1((elementOrientation, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction?.inlineOrientation === elementOrientation)
                return "inline";
            return "block";
        }, []);
        const convertToPhysicalSide = T$1((side, direction) => {
            direction ??= getLogicalDirectionInfo();
            switch (side) {
                case "block-start":
                    return M[(direction?.blockDirection ?? "ttb")[0]];
                case "block-end":
                    return M[(direction?.blockDirection ?? "ttb")[2]];
                case "inline-start":
                    return M[(direction?.inlineDirection ?? "ltr")[0]];
                case "inline-end":
                    return M[(direction?.inlineDirection ?? "ltr")[2]];
            }
        }, []);
        const convertToLogicalSide = T$1((side, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction?.inlineOrientation === "vertical") {
                switch (side) {
                    case "top":
                        return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";
                    case "bottom":
                        return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";
                    case "left":
                        return direction.blockDirection === "ltr" ? "block-start" : "block-end";
                    case "right":
                        return direction.blockDirection === "rtl" ? "block-start" : "block-end";
                }
            }
            else if (direction?.inlineOrientation === "horizontal") {
                switch (side) {
                    case "top":
                        return direction.blockDirection === "ttb" ? "block-start" : "block-end";
                    case "bottom":
                        return direction.blockDirection === "btt" ? "block-start" : "block-end";
                    case "left":
                        return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";
                    case "right":
                        return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
                }
            }
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false);
            return "inline-start";
        }, []);
        const convertToPhysicalOrientation = T$1((elementOrientation, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (elementOrientation == "inline") {
                if (direction?.inlineOrientation == "horizontal")
                    return "horizontal";
                return "vertical";
            }
            else {
                if (direction?.blockOrientation == "vertical")
                    return "vertical";
                return "horizontal";
            }
        }, []);
        const convertElementSize = T$1((elementSize, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction) {
                const { inlineSize, blockSize, inlineDirection, blockDirection } = direction;
                // Size is relatively simple
                const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
                const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
                const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
                const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
                const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
                const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
                const f1 = getPhysicalLeftTop(inlineDirection);
                const f2 = getPhysicalRightBottom(inlineDirection);
                const f3 = getPhysicalLeftTop(blockDirection);
                const f4 = getPhysicalRightBottom(blockDirection);
                const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
                const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
                const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : (elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]));
                const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
                const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
                const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : (elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]));
                return {
                    clientInlineSize,
                    scrollInlineSize,
                    offsetInlineSize,
                    clientBlockSize,
                    scrollBlockSize,
                    offsetBlockSize,
                    clientInlineInset,
                    scrollInlineInset,
                    offsetInlineInset,
                    clientBlockInset,
                    scrollBlockInset,
                    offsetBlockInset,
                };
            }
            return null;
        }, []);
        return {
            useLogicalDirectionProps: T$1((props) => useRefElementProps(useElementSizeProps(props)), []),
            getElement,
            getLogicalDirectionInfo,
            convertToLogicalSize: convertElementSize,
            convertToLogicalOrientation,
            convertToPhysicalOrientation,
            convertToLogicalSide,
            convertToPhysicalSide
        };
    }
    // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)
    function getPhysicalLeftTop(dir) { if (dir === "ltr" || dir == "rtl")
        return "left"; return "top"; }
    function getPhysicalRightBottom(dir) { if (dir === "rtl")
        return "width"; if (dir === "btt")
        return "height"; return null; }
    // Helper for extracting info from "ltr", "ttb", etc.
    const M = {
        t: "top",
        b: "bottom",
        l: "left",
        r: "right"
    };
    const HorizontalTbLtr = {
        inlineDirection: "ltr",
        blockDirection: "ttb",
        inlineOrientation: "horizontal",
        blockOrientation: "vertical",
        inlineSize: "width",
        blockSize: "height",
        leftRightDirection: "ltr",
        overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = {
        ...HorizontalTbLtr,
        inlineDirection: "rtl",
    };
    const VerticalRlLtr = {
        inlineDirection: "ttb",
        blockDirection: "rtl",
        inlineOrientation: "vertical",
        blockOrientation: "horizontal",
        inlineSize: "height",
        blockSize: "width",
        leftRightDirection: "ttb",
        overUnderDirection: "rtl"
    };
    const VerticalRlRtl = {
        ...VerticalRlLtr,
        inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr };
    const SidewaysRlRtl = { ...VerticalRlRtl };
    const VerticalLrLtr = {
        ...VerticalRlLtr,
        blockDirection: "ltr",
    };
    const VerticalLrRtl = {
        ...VerticalRlRtl,
        blockDirection: "ltr",
    };
    const SidewaysLtLtr = {
        ...VerticalLrLtr,
        inlineDirection: "btt",
        leftRightDirection: "btt",
        overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = {
        ...SidewaysLtLtr,
        inlineDirection: "ttb"
    };
    const HorizontalTb = {
        ltr: HorizontalTbLtr,
        rtl: HorizontalTbRtl
    };
    const VerticalRl = {
        ltr: VerticalRlLtr,
        rtl: VerticalRlRtl
    };
    const VerticalLr = {
        ltr: VerticalLrLtr,
        rtl: VerticalLrRtl
    };
    const SidewaysRl = {
        ltr: SidewaysRlLtr,
        rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
        ltr: SidewaysLtLtr,
        rtl: SidewaysLtRtl
    };
    const WritingModes = {
        "horizontal-tb": HorizontalTb,
        "vertical-lr": VerticalLr,
        "vertical-rl": VerticalRl,
        "sideways-lr": SidewaysLr,
        "sideways-rl": SidewaysRl
    };

    function useTimeout({ timeout, callback, triggerIndex }) {
        const stableCallback = useStableCallback(() => { startTimeRef.current = null; callback(); });
        const getTimeout = useStableGetter(timeout);
        // Set any time we start timeout.
        // Unset any time the timeout completes
        const startTimeRef = s(null);
        const timeoutIsNull = (timeout == null);
        // Any time the triggerIndex changes (including on mount)
        // restart the timeout.  The timeout does NOT reset
        // when the duration or callback changes, only triggerIndex.
        _(() => {
            if (!timeoutIsNull) {
                const timeout = getTimeout();
                console.assert(timeoutIsNull == (timeout == null));
                if (timeout != null) {
                    startTimeRef.current = +(new Date());
                    const handle = setTimeout(stableCallback, timeout);
                    return () => clearTimeout(handle);
                }
            }
        }, [triggerIndex, timeoutIsNull]);
        const getElapsedTime = T$1(() => {
            return (+(new Date())) - (+(startTimeRef.current ?? new Date()));
        }, []);
        const getRemainingTime = T$1(() => {
            const timeout = getTimeout();
            return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
        }, []);
        return { getElapsedTime, getRemainingTime };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useLinearNavigation({ linearNavigation: { navigateToFirst: ntf, navigateToLast: ntl, navigateToNext: ntn, navigateToPrev: ntp, navigationDirection: nd, disableArrowKeys: dak, disableHomeEndKeys: dhek } }) {
        nd ??= "either";
        const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection({});
        const navigateToFirst = useStableCallback(ntf);
        const navigateToLast = useStableCallback(ntl);
        const navigateToNext = useStableCallback(ntn);
        const navigateToPrev = useStableCallback(ntp);
        const getDisableArrowKeys = useStableGetter(dak);
        const getDisableHomeEndKeys = useStableGetter(dhek);
        const getNavigationDirection = useStableGetter(nd);
        return {
            linearNavigation: {},
            useLinearNavigationProps: T$1((props) => {
                const onKeyDown = (e) => {
                    // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                    if (e.ctrlKey || e.metaKey)
                        return;
                    const info = getLogicalDirectionInfo();
                    const navigationDirection = getNavigationDirection();
                    const disableArrowKeys = getDisableArrowKeys();
                    const disableHomeEndKeys = getDisableHomeEndKeys();
                    const allowsBlockNavigation = (navigationDirection == "block" || navigationDirection == "either");
                    const allowsInlineNavigation = (navigationDirection == "inline" || navigationDirection == "either");
                    switch (e.key) {
                        case "ArrowUp": {
                            const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.blockOrientation === "vertical" ? allowsBlockNavigation : allowsInlineNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "btt") {
                                    navigateToNext();
                                }
                                else {
                                    navigateToPrev();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowDown": {
                            const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.blockOrientation === "vertical" ? allowsBlockNavigation : allowsInlineNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "btt") {
                                    navigateToPrev();
                                }
                                else {
                                    navigateToNext();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowLeft": {
                            const propName = (info?.inlineOrientation === "horizontal" ? "inlineDirection" : "blockDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.inlineOrientation === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "rtl") {
                                    navigateToNext();
                                }
                                else {
                                    navigateToPrev();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowRight": {
                            const propName = (info?.inlineOrientation === "horizontal" ? "inlineDirection" : "blockDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.inlineOrientation === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "rtl") {
                                    navigateToPrev();
                                }
                                else {
                                    navigateToNext();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                        case "Home":
                            if (!disableHomeEndKeys) {
                                navigateToFirst();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        case "End":
                            if (!disableHomeEndKeys) {
                                navigateToLast();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                    }
                };
                return useLogicalDirectionProps(useMergedProps({ onKeyDown }, props));
            }, []),
        };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useTypeaheadNavigation({ typeaheadNavigation: { collator, getIndex, typeaheadTimeout, setIndex, noTypeahead } }) {
        // For typeahead, keep track of what our current "search" string is (if we have one)
        // and also clear it every 1000 ms since the last time it changed.
        // Next, keep a mapping of typeahead values to indices for faster searching.
        // And, for the user's sake, let them know when their typeahead can't match anything anymore
        const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
        useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
        const sortedTypeaheadInfo = s([]);
        const [invalidTypeahead, setInvalidTypeahead] = useState(false);
        // Handle typeahead for input method editors as well
        // Essentially, when active, ignore further keys 
        // because we're waiting for a CompositionEnd event
        const [, setImeActive, getImeActive] = useState(false);
        // Because composition events fire *after* keydown events 
        // (but within the same task, which, TODO, could be browser-dependent),
        // we can use this to keep track of which event we're listening for on the first keydown.
        const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
        h(() => {
            if (nextTypeaheadChar !== null) {
                setCurrentTypeahead(typeahead => ((typeahead ?? "") + nextTypeaheadChar));
                setNextTypeaheadChar(null);
            }
        }, [nextTypeaheadChar]);
        const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
            let compare;
            // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
            // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
            safeLhs = safeLhs.normalize("NFD");
            safeRhs = safeRhs.normalize("NFD");
            if (collator)
                compare = collator.compare(safeLhs, safeRhs);
            else
                compare = safeLhs.toLowerCase().localeCompare(safeRhs.toLowerCase() ?? "");
            return compare;
        });
        const insertingComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                return comparatorShared(lhs, rhs.text);
            }
            return lhs - rhs;
        });
        const typeaheadComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                // During typeahead, all strings longer than ours should be truncated
                // so that they're all considered equally by that point.
                return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
            }
            return lhs - rhs;
        });
        const isDisabled = useStableGetter(noTypeahead);
        const useTypeaheadNavigationProps = T$1(function ({ ...props }) {
            const onCompositionStart = (_e) => { setImeActive(true); };
            const onCompositionEnd = (e) => {
                setNextTypeaheadChar(e.data);
                setImeActive(false);
            };
            const onKeyDown = (e) => {
                if (isDisabled())
                    return;
                const imeActive = getImeActive();
                const key = e.key;
                // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                if (e.ctrlKey || e.metaKey)
                    return;
                if (!imeActive && e.key === "Backspace") {
                    // Remove the last character in a way that doesn't split UTF-16 surrogates.
                    setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                // The key property represents the typed character OR the "named key attribute" of the key pressed.
                // There's no definite way to tell the difference, but for all intents and purposes
                // there are no one-character names, and there are no non-ASCII-alpha names.
                // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
                const isCharacterKey = (key.length === 1 || !/^[A-Za-z]/.test(key));
                if (isCharacterKey) {
                    if (key == " " && (getCurrentTypeahead() ?? "").trim().length == 0) ;
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        // Note: Won't be true for the first keydown
                        // but will be overwritten before useLayoutEffect is called
                        // to actually apply the change
                        if (!imeActive)
                            setNextTypeaheadChar(key);
                    }
                }
            };
            return useMergedProps({ onKeyDown, onCompositionStart, onCompositionEnd, }, props);
        }, []);
        // Handle changes in typeahead that cause changes to the tabbable index
        _(() => {
            if (currentTypeahead && sortedTypeaheadInfo.current.length) {
                const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
                if (sortedTypeaheadIndex < 0) {
                    // The user has typed an entry that doesn't exist in the list
                    // (or more specifically "for which there is no entry that starts with that input")
                    setInvalidTypeahead(true);
                }
                else {
                    setInvalidTypeahead(false);
                    /*
                      We know roughly where, in the sorted array of strings, our next typeahead location is.
                      But roughly isn't good enough if there are multiple matches.
                      To convert our sorted index to the unsorted index we need, we have to find the first
                      element that matches us *and* (if any such exist) is *after* our current selection.

                      In other words, the only way typeahead moves backwards relative to our current
                      position is if the only other option is behind us.

                      It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
                      Though there's also a case for just going upwards to the nearest to prevent jumpiness.
                      But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
                      I dunno. Going back to the start is the simplist though.

                      Basically what this does: Starting from where we found ourselves after our binary search,
                      scan backwards and forwards through all adjacent entries that also compare equally so that
                      we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
                      (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).

                      TODO: The binary search starts this off with a solid O(log n), but one-character
                      searches are, thanks to pigeonhole principal, eventually guaranteed to become
                      O(n*log n). This is annoying but probably not easily solvable? There could be an
                      exception for one-character strings, but that's just kicking the can down
                      the road. Maybe one or two characters would be good enough though.
                    */
                    // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
                    let lowestUnsortedIndexAll = null;
                    let lowestSortedIndexAll = sortedTypeaheadIndex;
                    // These two are only set for elements that are ahead of us, but the principle's the same otherwise
                    let lowestUnsortedIndexNext = null;
                    let lowestSortedIndexNext = sortedTypeaheadIndex;
                    const updateBestFit = (u) => {
                        if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                            lowestUnsortedIndexAll = u;
                            lowestSortedIndexAll = i;
                        }
                        if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > (getIndex() ?? -Infinity)) {
                            lowestUnsortedIndexNext = u;
                            lowestSortedIndexNext = i;
                        }
                    };
                    let i = sortedTypeaheadIndex;
                    while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        --i;
                    }
                    i = sortedTypeaheadIndex;
                    while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        ++i;
                    }
                    if (lowestUnsortedIndexNext !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);
                    else if (lowestUnsortedIndexAll !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
                }
            }
        }, [currentTypeahead]);
        const useTypeaheadNavigationChild = T$1(({ index, text }) => {
            _(() => {
                if (text) {
                    // Find where to insert this item.
                    // Because all index values should be unique, the returned sortedIndex
                    // should always refer to a new location (i.e. be negative)                
                    const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                    console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                    if (sortedIndex < 0) {
                        sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, { text, unsortedIndex: index });
                    }
                    else {
                        sortedTypeaheadInfo.current.splice(sortedIndex, 0, { text, unsortedIndex: index });
                    }
                    return () => {
                        // When unmounting, find where we were and remove ourselves.
                        // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
                        const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                        console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                        if (sortedIndex >= 0) {
                            sortedTypeaheadInfo.current.splice(sortedIndex, 1);
                        }
                    };
                }
            }, [text]);
            return;
        }, []);
        return {
            useTypeaheadNavigationChild,
            useTypeaheadNavigationProps,
            typeaheadNavigation: {
                currentTypeahead,
                invalidTypeahead,
            }
        };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */
    function binarySearch(array, wanted, comparator) {
        let firstIndex = 0;
        let lastIndex = array.length - 1;
        while (firstIndex <= lastIndex) {
            const testIndex = (lastIndex + firstIndex) >> 1;
            const comparisonResult = comparator(wanted, array[testIndex]);
            if (comparisonResult > 0) {
                firstIndex = testIndex + 1;
            }
            else if (comparisonResult < 0) {
                lastIndex = testIndex - 1;
            }
            else {
                return testIndex;
            }
        }
        return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */
    function useRovingTabIndex(parentParameters) {
        let { rovingTabIndex: { initialIndex, onTabbableRender, onTabbableIndexChange }, managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        initialIndex ??= 0;
        const stableOnTabbableRender = useStableCallback(onTabbableRender ?? (() => { }));
        /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
            if (oldCount == 0 && newCount > 0) {
                onTabbedInTo?.();
            }

            if (newCount == 0 && (oldCount ?? 0) > 0) {
                onTabbedOutOf?.();
            }
        }), returnZero);*/
        // Keep track of three things related to the currently tabbable element's index:
        // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.
        const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, T$1(() => { return initialIndex ?? 0; }, []));
        const setTabbableIndex = T$1((updater, fromUserInteraction) => {
            setTabbableIndex2((prevIndex) => {
                let nextIndex = prevIndex;
                if (typeof updater === "function")
                    nextIndex = updater(prevIndex ?? null);
                else
                    nextIndex = updater;
                nextIndex = changeIndex(nextIndex);
                if (prevIndex != nextIndex) {
                    const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
                    //const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
                    //if (prevChild != null)
                    //    prevChild.subInfo.blurSelf();
                    if (nextChild != null && fromUserInteraction)
                        nextChild.subInfo.focusSelf();
                }
                return nextIndex;
            });
        }, []);
        // Any time the tabbable index changes,
        // notify the previous child that it's no longer tabbable,
        // and notify the next child that is allowed to be tabbed to.
        const parentReturnType = useManagedChildren({
            managedChildren: {
                onAfterChildLayoutEffect,
                onChildrenMountChange: useStableCallback((mounted, unmounted) => { onChildrenMountChange?.(mounted, unmounted); reevaluateClosestFit(); }),
            },
        });
        const { useManagedChild } = parentReturnType;
        const { changeIndex, reevaluateClosestFit } = useChildrenFlag({ initialIndex, children: parentReturnType.managedChildren.children, closestFit: true, key: "tabbable" });
        const useRovingTabIndexChild = T$1((childParameters) => {
            const { subInfo, managedChild: { index, flags }, rovingTabIndex: { hidden, focusSelf: focusSelfOverride } } = childParameters;
            _(() => {
                reevaluateClosestFit();
            }, [!!hidden]);
            const fsOverride = useStableGetter(focusSelfOverride);
            const focusSelf = T$1(() => {
                const fs = fsOverride();
                if (fs) {
                    fs();
                }
                else {
                    const element = getElement();
                    if (element)
                        element.focus?.();
                }
            }, []);
            /*const blurSelf = useCallback(() => {
                const bs = bsOverride();
                if (bs) {
                    bs();
                }
                else {
                    const element = getElement() as (Element & Partial<HTMLElement>);
                    if (element)
                        element.blur?.();
                }
            }, []);*/
            const onFocusedInnerChanged = useStableCallback((focused, _prevFocused) => {
                if (focused) {
                    setTabbableIndex(index, false);
                }
            });
            const { getElement, useHasFocusProps } = useHasFocus({ onFocusedInnerChanged, getDocument: T$1(() => { return (getElement()?.ownerDocument) ?? (window.document); }, []) });
            const [tabbable, setTabbable, getTabbable] = useState(false);
            const tabbableFlags = s({ get: getTabbable, set: setTabbable, isValid: useStableCallback(() => !hidden) });
            useManagedChild({
                managedChild: {
                    index,
                    flags: { ...flags, tabbable: tabbableFlags.current },
                    subInfo: {
                        //blurSelf,
                        focusSelf,
                        getElement,
                        hidden: !!hidden,
                        subInfo
                    }
                }
            });
            _(() => {
                if (tabbable)
                    stableOnTabbableRender(index);
            }, [tabbable, index]);
            function useRovingTabIndexChildProps(props) {
                console.assert(props.tabIndex == null);
                return useMergedProps(useHasFocusProps({ tabIndex: tabbable ? 0 : -1 }), props);
            }
            return {
                useRovingTabIndexChildProps,
                rovingTabIndex: {
                    getElement,
                    tabbable,
                    getTabbable
                }
            };
        }, [ /* Must remain stable */]);
        const focusSelf = T$1(() => {
            console.log(`useRovingTabIndex.focusSelf`);
            const index = getTabbableIndex();
            if (index != null)
                parentReturnType.managedChildren.children.getAt(index)?.subInfo.focusSelf?.();
            else
                setTabbableIndex(null, true);
        }, []);
        return {
            useRovingTabIndexChild,
            managedChildren: { children: parentReturnType.managedChildren.children },
            rovingTabIndex: {
                setTabbableIndex,
                getTabbableIndex,
                focusSelf,
            }
        };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Built-in value references. */
    var Buffer = moduleExports$1 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$1;

      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useRearrangeableChildren({ rearrangeableChildren: { getIndex } }) {
        // These are used to keep track of a mapping between unsorted index <---> sorted index.
        // These are needed for navigation with the arrow keys.
        const mangleMap = s(new Map());
        const demangleMap = s(new Map());
        const indexMangler = T$1((n) => (mangleMap.current.get(n) ?? n), []);
        const indexDemangler = T$1((n) => (demangleMap.current.get(n) ?? n), []);
        // The sort function needs to be able to update whoever has all the sortable children.
        // Because that might not be the consumer of *this* hook directly (e.g. a table uses
        // this hook, but it's tbody that actually needs updating), we need to remotely
        // get and set a forceUpdate function.
        //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
        const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
        const rearrange = T$1((sortedRows) => {
            // Update our sorted <--> unsorted indices map 
            // and rerender the whole table, basically
            for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
                const indexAsUnsorted = sortedRows[indexAsSorted].index;
                mangleMap.current.set(indexAsUnsorted, indexAsSorted);
                demangleMap.current.set(indexAsSorted, indexAsUnsorted);
            }
            getForceUpdate()?.();
        }, []);
        const useRearrangeableProps = T$1(({ children, ...props }) => {
            const forceUpdate = useForceUpdate();
            h(() => { setForceUpdate(_prev => forceUpdate); }, [forceUpdate]);
            return (useMergedProps({
                children: children
                    .slice()
                    .map(child => ({ child, mangledIndex: indexMangler(getIndex(child.props)), demangledIndex: getIndex(child.props) }))
                    .sort((lhs, rhs) => { return lhs.mangledIndex - rhs.mangledIndex; })
                    .map(({ child, mangledIndex, demangledIndex }) => {
                    return h$1(child.type, { ...child.props, key: demangledIndex, "data-mangled-index": mangledIndex, "data-unmangled-index": demangledIndex });
                })
            }, props));
        }, []);
        return { useRearrangeableProps, rearrangeableChildren: { indexMangler, indexDemangler, mangleMap, demangleMap, rearrange } };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useSortableChildren({ rearrangeableChildren: { getIndex }, sortableChildren: { compare: userCompare, getValue } }) {
        const compare = (userCompare ?? defaultCompare);
        const { useRearrangeableProps: useSortableProps, ...rearrangeableChildrenReturnType } = useRearrangeableChildren({ rearrangeableChildren: { getIndex } });
        const { rearrangeableChildren: { rearrange } } = rearrangeableChildrenReturnType;
        // The actual sort function.
        const sort = T$1((managedRows, direction, ...args) => {
            const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
                const lhsValue = getValue(lhsRow, ...args);
                const rhsValue = getValue(rhsRow, ...args);
                const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);
                if (direction[0] == "d")
                    return -result;
                return result;
            });
            return rearrange(sortedRows);
        }, [ /* Must remain stable */]);
        const shuffle$1 = T$1((managedRows) => {
            const shuffledRows = shuffle(managedRows.arraySlice());
            return rearrange(shuffledRows);
        }, [ /* Must remain stable */]);
        return {
            useSortableProps,
            sortableChildren: { sort, shuffle: shuffle$1 },
            rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
        };
    }
    function defaultCompare(lhs, rhs) {
        return compare1(lhs, rhs);
        function compare3(lhs, rhs) {
            // Coerce strings to numbers if they seem to stay the same when serialized
            if (`${+lhs}` === lhs)
                lhs = +lhs;
            if (`${+rhs}` === rhs)
                rhs = +rhs;
            // At this point, if either argument is a string, turn the other one into one too
            if (typeof lhs === "string")
                rhs = `${rhs}`;
            if (typeof rhs === "string")
                lhs = `${lhs}`;
            console.assert(typeof lhs === typeof rhs);
            if (typeof lhs === "string")
                return lhs.localeCompare(rhs);
            if (typeof lhs === "number")
                return +lhs - +rhs;
            return 0;
        }
        function compare2(lhs, rhs) {
            if (typeof lhs === "boolean" || lhs instanceof Date)
                lhs = +lhs;
            if (typeof rhs === "boolean" || rhs instanceof Date)
                rhs = +rhs;
            return compare3(lhs, rhs);
        }
        function compare1(lhs, rhs) {
            if (lhs == null && rhs == null) {
                // They're both null
                return 0;
            }
            else if (lhs == null || rhs == null) {
                // One of the two is null -- easy case
                return lhs != null ? 1 : -1;
            }
            return compare2(lhs, rhs);
        }
    }

    function identity(t) { return t; }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */
    function useListNavigation({ managedChildren: { onChildrenMountChange, ...mc }, rovingTabIndex, listNavigation: { indexDemangler, indexMangler }, linearNavigation, typeaheadNavigation }) {
        indexMangler ??= identity;
        indexDemangler ??= identity;
        useEnsureStability("useListNavigation", indexMangler, indexDemangler);
        const parentReturnType = useRovingTabIndex({
            managedChildren: {
                ...mc, onChildrenMountChange: T$1((m, u) => {
                    onChildrenMountChange?.(m, u);
                }, [])
            },
            rovingTabIndex
        });
        const { useRovingTabIndexChild, managedChildren: { children }, rovingTabIndex: { getTabbableIndex, setTabbableIndex } } = parentReturnType;
        const navigateToIndex = T$1((i, fromUserInteraction) => {
            if (i != null) {
                const nextIndex = tryNavigateToIndex({
                    children: children,
                    default: 0,
                    target: i,
                    searchDirection: 1,
                    indexMangler: indexMangler ?? identity,
                    indexDemangler: indexDemangler ?? identity
                });
                setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
            }
            else {
                setTabbableIndex(null, fromUserInteraction);
            }
        }, []);
        const { useTypeaheadNavigationChild, useTypeaheadNavigationProps, typeaheadNavigation: { currentTypeahead, invalidTypeahead } } = useTypeaheadNavigation({
            typeaheadNavigation: {
                getIndex: getTabbableIndex,
                setIndex: T$1((index) => {
                    setTabbableIndex(index, true);
                }, []),
                ...typeaheadNavigation
            }
        });
        const { useLinearNavigationProps } = useLinearNavigation({
            linearNavigation: {
                navigateToPrev: T$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler((c ?? 0)) - 1), searchDirection: -1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToNext: T$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler(c ?? 0) + 1), searchDirection: 1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToFirst: T$1(() => { navigateToIndex(indexDemangler(0), true); }, []),
                navigateToLast: T$1(() => { navigateToIndex(indexDemangler(children.getHighestIndex()), true); }, []),
                ...linearNavigation
            }
        });
        const useListNavigationProps = T$1((props) => {
            return useLinearNavigationProps(useTypeaheadNavigationProps(props));
        }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
        const useListNavigationChild = T$1(({ managedChild: { index, flags }, rovingTabIndex: { focusSelf, hidden }, listNavigation: { text }, subInfo }) => {
            useTypeaheadNavigationChild({ text, index });
            const getIndex = useStableGetter(index);
            _(() => {
                return () => {
                    if (getTabbableIndex() == getIndex()) {
                        navigateToIndex(index, false);
                    }
                };
            }, []);
            const { useRovingTabIndexChildProps, rovingTabIndex: { tabbable, getTabbable, getElement } } = useRovingTabIndexChild({
                managedChild: { index, flags },
                rovingTabIndex: { focusSelf, hidden: !!hidden },
                subInfo: { text, subInfo }
            });
            const useListNavigationChildProps = function ({ ...props }) {
                return useMergedProps(useRovingTabIndexChildProps({ inert: hidden }), props);
            };
            return {
                useListNavigationChildProps,
                rovingTabIndex: {
                    tabbable,
                    getTabbable,
                    getElement
                }
            };
        }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
        return {
            useListNavigationChild,
            useListNavigationProps,
            listNavigation: { navigateToIndex },
            managedChildren: parentReturnType.managedChildren,
            rovingTabIndex: parentReturnType.rovingTabIndex,
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }
            /*listNavigation: { navigateToIndex },
            rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/
        };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */
    function useListNavigationSingleSelection({ singleSelection: { selectedIndex, selectionMode, onSelectedIndexChange }, listNavigation, managedChildren, rovingTabIndex: { ...rovingTabIndex }, linearNavigation, typeaheadNavigation, childrenHaveFocus: { onAllLostFocus, onAnyGainedFocus } }) {
        const parentReturnType = useListNavigation({
            listNavigation,
            managedChildren,
            rovingTabIndex: {
                initialIndex: (selectedIndex ?? undefined),
                ...rovingTabIndex
            },
            linearNavigation,
            typeaheadNavigation
        });
        const { useChildrenHaveFocusChild } = useChildrenHaveFocus({
            childrenHaveFocus: {
                onAllLostFocus: useStableCallback(() => {
                    onAllLostFocus?.();
                    if (selectedIndex != null)
                        setTabbableIndex(selectedIndex, false);
                }),
                onAnyGainedFocus
            }, managedChildren: {
                onAfterChildLayoutEffect: null,
                onChildrenMountChange: null
            }
        });
        const stableOnChange = useStableCallback(onSelectedIndexChange);
        const { useListNavigationChild, useListNavigationProps, ...listRest } = parentReturnType;
        const { managedChildren: { children }, rovingTabIndex: { setTabbableIndex } } = listRest;
        const { changeIndex: changeSelectedIndex, getCurrentIndex: getSelectedIndex,
        //reevaluateClosestFit
         } = useChildrenFlag({
            children: children,
            initialIndex: selectedIndex,
            key: "selected",
            closestFit: false
        });
        h(() => {
            changeSelectedIndex(selectedIndex);
        }, [selectedIndex]);
        return {
            useListNavigationSingleSelectionChild: T$1(({ managedChild: { index, flags }, rovingTabIndex: rti, listNavigation: ls, hasFocus: { onFocusedInnerChanged, ...hasFocus }, subInfo }) => {
                const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
                const selectedRef = s({ get: getIsSelected, set: setIsSelected, isValid: useStableCallback(() => !rti.hidden) });
                const { useChildrenHaveFocusChildProps, getElement } = useChildrenHaveFocusChild({
                    onFocusedInnerChanged: useStableCallback((focused, prev) => {
                        onFocusedInnerChanged?.(focused, prev);
                        if (selectionMode == 'focus' && focused) {
                            stableOnChange({ target: getElement(), currentTarget: getElement() }, getIndex());
                        }
                    }),
                    ...hasFocus,
                    managedChild: { index }
                });
                const { rovingTabIndex: rti_ret, useListNavigationChildProps } = useListNavigationChild({
                    managedChild: {
                        index,
                        flags: {
                            selected: selectedRef.current,
                            ...flags
                        }
                    },
                    rovingTabIndex: rti,
                    listNavigation: ls,
                    subInfo,
                });
                const getIndex = useStableGetter(index);
                const usePressProps = usePress({ onClickSync: (e) => { stableOnChange(e, getIndex()); }, exclude: {}, hasFocus });
                return {
                    useListNavigationSingleSelectionChildProps: (props) => usePressProps(useChildrenHaveFocusChildProps(useListNavigationChildProps(props))),
                    rovingTabIndex: rti_ret,
                    singleSelection: { selected: isSelected, getSelected: getIsSelected }
                };
            }, [selectionMode]),
            useListNavigationSingleSelectionProps: T$1((...p) => { return useListNavigationProps(...p); }, []),
            ...listRest,
            singleSelection: {}
        };
    }
    function useSortableListNavigationSingleSelection({ linearNavigation, listNavigation, managedChildren, rovingTabIndex, singleSelection, typeaheadNavigation, childrenHaveFocus }) {
        const { useSortableProps, ...sortableReturnType } = useSortableChildren({
            rearrangeableChildren: { getIndex: T$1((row) => row.index, []) },
            sortableChildren: {
                getValue: T$1((row) => row.index, []),
                compare: T$1((lhs, rhs) => { return lhs - rhs; }, []),
            }
        });
        const { rearrangeableChildren: { indexDemangler, indexMangler } } = sortableReturnType;
        const { useListNavigationSingleSelectionChild, useListNavigationSingleSelectionProps, ...listNavReturnType } = useListNavigationSingleSelection({
            linearNavigation: linearNavigation,
            listNavigation: { indexDemangler, indexMangler, ...listNavigation },
            managedChildren: managedChildren,
            rovingTabIndex: rovingTabIndex,
            typeaheadNavigation: typeaheadNavigation,
            singleSelection: singleSelection,
            childrenHaveFocus: childrenHaveFocus
        });
        const useSortableListNavigationSingleSelectionProps = (props) => {
            return (useListNavigationSingleSelectionProps(useSortableProps(props)));
        };
        const useSortableListNavigationSingleSelectionChild = (p) => {
            return useListNavigationSingleSelectionChild(p);
        };
        return ({
            useSortableListNavigationSingleSelectionChild,
            useSortableListNavigationSingleSelectionProps,
            //sortable: { sort, shuffle, rearrange, demangleMap, indexDemangler, indexMangler, mangleMap },
            ...sortableReturnType,
            ...listNavReturnType
        });
    }
    function tryNavigateToIndex({ children, searchDirection, indexDemangler, indexMangler, target }) {
        const upper = children.getHighestIndex();
        const lower = 0;
        if (searchDirection === -1) {
            while ((target >= lower && (children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden))
                target = indexDemangler(indexMangler(target) - 1);
            return target < lower ? indexDemangler(lower) : target;
        }
        else if (searchDirection === 1) {
            while ((target <= upper && children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden)
                target = indexDemangler(indexMangler(target) + 1);
            return target > upper ? indexDemangler(upper) : target;
        }
        else {
            return lower;
        }
    }

    function useGridNavigation({ managedChildren: mc, rovingTabIndex: rti, listNavigation: ls, linearNavigation: ln, typeaheadNavigation: tn }) {
        const [currentColumn, setCurrentColumn, getCurrentColumn] = useState(rti.initialIndex ?? 0);
        const { useListNavigationChild: useListNavigationChildAsGridRow, useListNavigationProps: useListNavigationPropsAsGridParent, ...parentLsReturnType } = useListNavigation({
            managedChildren: mc,
            rovingTabIndex: rti,
            listNavigation: ls,
            linearNavigation: { navigationDirection: "block", ...ln },
            typeaheadNavigation: tn,
        });
        const useGridNavigationRow = T$1(({ asChildRowOfSection: asChild, asParentRowOfCells: asParent }) => {
            // Override the focusSelf that rovingTabIndex does.
            // Instead of focusing the entire row, we ask the cell that corresponds
            // to our current column to focus itself.
            const focusSelf = useStableCallback(() => {
                const c2 = getCurrentColumn();
                if (asChild.rovingTabIndex.focusSelf) {
                    asChild.rovingTabIndex.focusSelf();
                }
                else {
                    navigateToIndex(c2 ?? 0, true);
                }
            });
            const rowLsChildReturnType = useListNavigationChildAsGridRow({
                managedChild: asChild.managedChild,
                listNavigation: { ...asChild.listNavigation },
                rovingTabIndex: { ...asChild.rovingTabIndex, focusSelf },
                subInfo: asChild.subInfo,
            });
            const { rovingTabIndex: { tabbable }, useListNavigationChildProps } = rowLsChildReturnType;
            _(() => {
                if (!tabbable) {
                    navigateToIndex(null, false);
                }
            }, [tabbable]);
            const rowLsReturnType = useListNavigation({
                managedChildren: { ...asParent.managedChildren },
                rovingTabIndex: { ...asParent.rovingTabIndex },
                linearNavigation: {
                    ...asParent.linearNavigation,
                    navigationDirection: "inline",
                },
                typeaheadNavigation: { ...asParent.typeaheadNavigation, noTypeahead: true },
                listNavigation: { ...asParent.listNavigation }
            });
            const { rovingTabIndex: { setTabbableIndex }, useListNavigationChild: useGridNavigationColumn2, useListNavigationProps: useGridNavigationColumnProps, listNavigation: { navigateToIndex } } = rowLsReturnType;
            //const rowHidden = !!asChild.rovingTabIndex.hidden;
            const useGridNavigationCell = T$1(({ subInfo, hasFocus: { onLastFocusedInnerChanged, ...hasFocus }, managedChild, listNavigation: ls, rovingTabIndex: { focusSelf: fs, ...rti } }) => {
                //rti.hidden || rowHidden;
                const focusSelf = useStableCallback(() => {
                    setCurrentColumn(managedChild.index);
                    setTabbableIndex(managedChild.index, false);
                    if (fs)
                        fs();
                    else
                        rti_cell_ret.getElement()?.focus?.();
                });
                /*const blurSelf = useStableCallback(() => {
                    if (bs)
                        bs();
                    else
                        (rti_cell_ret.getElement() as Element & Partial<HTMLElement>)?.blur?.();
                });*/
                const { useListNavigationChildProps, rovingTabIndex: rti_cell_ret } = useGridNavigationColumn2({
                    managedChild: managedChild,
                    listNavigation: { ...ls },
                    rovingTabIndex: { focusSelf, ...rti },
                    subInfo
                });
                const { useHasFocusProps } = useHasFocus({
                    onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
                        onLastFocusedInnerChanged?.(focused, prev);
                        if (focused) {
                            setCurrentColumn(managedChild.index);
                            setTabbableIndex(managedChild.index, false);
                        }
                    }),
                    ...hasFocus
                });
                const ret = {
                    gridNavigation: { getCurrentColumn },
                    rovingTabIndex: rti_cell_ret,
                    useGridNavigationCellProps: function (props) { return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props))); }
                };
                return ret;
            }, []);
            const ret = {
                asParentOfCells: {
                    linearNavigation: rowLsReturnType.linearNavigation,
                    listNavigation: rowLsReturnType.listNavigation,
                    managedChildren: rowLsReturnType.managedChildren,
                    rovingTabIndex: rowLsReturnType.rovingTabIndex,
                    typeaheadNavigation: rowLsReturnType.typeaheadNavigation,
                },
                asChildRow: rowLsChildReturnType,
                useGridNavigationCell,
                useGridNavigationRowProps: function (props) {
                    const ret = useListNavigationChildProps(props);
                    ret.tabIndex = -1;
                    return ret;
                }
            };
            return ret;
        }, []);
        return {
            gridNavigation: {
                getCurrentColumn,
                currentColumn
            },
            linearNavigation: parentLsReturnType.linearNavigation,
            listNavigation: parentLsReturnType.listNavigation,
            rovingTabIndex: parentLsReturnType.rovingTabIndex,
            typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
            managedChildren: parentLsReturnType.managedChildren,
            useGridNavigationRow,
            useGridNavigationProps: useListNavigationPropsAsGridParent,
        };
    }

    function useInterval({ interval, callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback);
        const getInterval = useStableGetter(interval);
        _(() => {
            const interval = getInterval();
            let lastDelayUsed = interval;
            if (interval == null)
                return;
            // Get a wrapper around the wrapper around the callback
            // that clears and resets the interval if it changes.
            const adjustableCallback = () => {
                stableCallback();
                const currentInterval = getInterval();
                if (currentInterval != lastDelayUsed) {
                    clearInterval(handle);
                    if (currentInterval != null)
                        handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
                }
            };
            let handle = setInterval(adjustableCallback, interval);
            return () => clearInterval(handle);
        }, []);
    }

    const DemoUseInterval = () => {
        const [interval, setInterval] = y(1000);
        const [fireCount, setFireCount] = y(0);
        useInterval({ interval, callback: () => setFireCount(i => ++i) });
        return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Interval duration: ", e$1("input", { type: "number", value: interval, onInput: e => setInterval(e.currentTarget.valueAsNumber) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    function getDocument$1() {
        return window.document;
    }
    const RovingChildContext = B(null);
    const DemoUseRovingTabIndex = g(() => {
        const [selectionMode, setSelectionMode] = useState("focus");
        const [count, setCount] = useState(10);
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [tabbableIndex, setLocalTabbableIndex] = useState(0);
        const { managedChildren: { children }, useSortableListNavigationSingleSelectionChild, useSortableListNavigationSingleSelectionProps, rovingTabIndex: { setTabbableIndex }, typeaheadNavigation: { currentTypeahead }, sortableChildren: { shuffle }, } = useSortableListNavigationSingleSelection({
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: { onTabbableIndexChange: T$1((index) => { if (index != null)
                    setLocalTabbableIndex(index); }, []) },
            typeaheadNavigation: {},
            singleSelection: { selectedIndex, selectionMode, onSelectedIndexChange: (e, i) => setSelectedIndex(i) },
            childrenHaveFocus: {}
        });
        return (e$1("div", { className: "demo", children: [e$1("h2", { children: "Keyboard & List Navigation" }), e$1("h3", { children: e$1("code", { children: "useRovingTabIndex" }) }), e$1("p", { children: ["Native HTML elements offer fantastic keyboard accessability, but cover a relatively limited number of use cases. There is no native HTML tree element, for example, that allows keyboard navigation of its items, nor is it possible to combine the keyboard navigation behavior of a ", e$1("code", { children: "<select>" }), " menu with the menu in a drawer component."] }), e$1("p", { children: ["When coming across a List or a Menu or a RadioGroup or a ToggleButtonGroup or any other \"one component made up of child components\", the usual expected behavior, at least natively, is that tabbing into the component is one action, and tabbing out is another.  Navigating ", e$1("em", { children: "within" }), " the component is done with the arrow keys or other methods."] }), e$1("p", { children: ["This is important both for accessability, but also just for general usability.  When tabbing back and forth, the ability to skip a long list without needing to trudge through ", e$1("em", { children: "every one" }), " of its child elements is extremely important."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " wraps up the functionality of a few hooks (", e$1("code", { children: "useRovingTabIndex" }), ", ", e$1("code", { children: "useLinearNavigation" }), ", ", e$1("code", { children: "useTypeaheadNavigation" }), ") to allow for ARIA-compliant navigation of lists and other similar components.  For more advanced use cases, you can use the other hooks individually."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " (and ", e$1("code", { children: "useRovingTabIndex" }), ") internally use ", e$1("code", { children: "useChildManager" }), ", which is how the child elements and the parent communicate with each other. This means there are virtually no restrictions on how the DOM is set up as long as you can provide the children with the ", e$1("code", { children: "useListNavigationChild" }), " hook that's returned, usually with a simple ", e$1("code", { children: "Context" }), ". If the child element itself has a focusable element, like a button, it can also be wired up to disable itself Feel free to nest them too, as long as you are aware of your ", e$1("code", { children: "Context" }), " management (i.e. remember that you need to create a new ", e$1("code", { children: "Context" }), " for each use case)."] }), e$1("label", { children: ["# of items", e$1("input", { type: "number", value: count, min: 0, onInput: e => { e.preventDefault(); setCount(e.currentTarget.valueAsNumber); } })] }), e$1("button", { onClick: () => shuffle(children), children: "Shuffle" }), e$1("label", { children: ["Tabbable index: ", e$1("input", { type: "number", value: tabbableIndex ?? undefined, onInput: e => { e.preventDefault(); setTabbableIndex(e.currentTarget.valueAsNumber, false); } })] }), e$1("label", { children: ["Selected index: ", e$1("input", { type: "number", value: selectedIndex ?? undefined, onInput: e => { e.preventDefault(); setSelectedIndex(e.currentTarget.valueAsNumber); } })] }), e$1("label", { children: ["Selection mode:", e$1("label", { children: [e$1("input", { name: "rti-demo-selection-mode", type: "radio", checked: selectionMode == 'focus', onInput: e => { e.preventDefault(); setSelectionMode("focus"); } }), " On focus"] }), e$1("label", { children: [e$1("input", { name: "rti-demo-selection-mode", type: "radio", checked: selectionMode == 'activation', onInput: e => { e.preventDefault(); setSelectionMode("activation"); } }), " On activation (click, tap, Enter, Space, etc.)"] })] }), e$1(RovingChildContext.Provider, { value: useSortableListNavigationSingleSelectionChild, children: e$1("ul", { ...(useSortableListNavigationSingleSelectionProps({
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield e$1(DemoUseRovingTabIndexChild, { index: i }, i);
                                }
                            })())
                        })) }) }), currentTypeahead && e$1("div", { children: ["Typeahead: ", currentTypeahead] })] }));
    });
    const DemoUseRovingTabIndexChild = g((({ index }) => {
        const hidden = (index == 7);
        const [randomWord] = useState(() => RandomWords$1[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useRovingTabIndexChild = q$1(RovingChildContext);
        const text = `${randomWord} This is item #${index}${hidden ? " (hidden)" : ""}`;
        const { useListNavigationSingleSelectionChildProps, rovingTabIndex: { tabbable }, singleSelection: { selected } } = useRovingTabIndexChild({ managedChild: { index }, listNavigation: { text }, rovingTabIndex: { hidden }, subInfo: {}, hasFocus: { getDocument: getDocument$1 } });
        const props = useListNavigationSingleSelectionChildProps({});
        return (e$1("li", { ...props, children: [text, " (", tabbable ? "Tabbable" : "Not tabbable", ", ", selected ? "Selected" : "Not selected", ")", e$1("input", { ...useListNavigationSingleSelectionChildProps({ type: "number" }), style: { width: "5ch" } })] }));
    }));

    const DemoUseTimeout = () => {
        const [timeout, setTimeout] = y(1000);
        const [triggerIndex, setTriggerIndex] = y("");
        const [fireCount, setFireCount] = y(0);
        useTimeout({ timeout, triggerIndex, callback: () => setFireCount(i => ++i) });
        return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Timeout duration: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Refresh key: ", e$1("input", { type: "text", value: triggerIndex, onInput: e => setTriggerIndex(e.currentTarget.value) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const DemoUseDroppable = () => {
        const { droppedFiles, droppedStrings, filesForConsideration, stringsForConsideration, useDroppableProps, dropError } = useDroppable({ effect: "copy" });
        useMergedProps({}, { ref: s(null) });
        const p = useDroppableProps({ className: "demo droppable" });
        return (e$1("div", { ...p, children: [droppedStrings != null && e$1("div", { children: ["Data dropped: ", e$1("ul", { children: Object.entries(droppedStrings).map(([type, value]) => e$1("li", { children: [type, ": ", value] })) })] }), droppedFiles != null && e$1("div", { children: ["Files dropped: ", e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Name" }), e$1("th", { children: "Size" }), e$1("th", { children: "Type" }), e$1("th", { children: "Last modified" })] }) }), e$1("tbody", { children: droppedFiles.map(f => e$1("tr", { children: [e$1("td", { children: f.name }), f.data.byteLength, e$1("td", { children: f.type }), e$1("td", { children: new Date(f.lastModified ?? 0) })] })) })] })] }), e$1("hr", {}), stringsForConsideration != null && e$1("div", { children: ["Data being considered: ", e$1("ul", { children: Array.from(stringsForConsideration).map(type => e$1("li", { children: type })) })] }), filesForConsideration != null && e$1("div", { children: ["Files being considered: ", e$1("ul", { children: filesForConsideration.map(f => e$1("li", { children: JSON.stringify(f) })) })] }), e$1("hr", {}), dropError && e$1("div", { children: dropError instanceof Error ? dropError.message : JSON.stringify(dropError) })] }));
    };
    const DemoUseDraggable = () => {
        const { useDraggableProps } = useDraggable({ data: { "text/plain": "This is custom draggable content of type text/plain." } });
        return (e$1("div", { ...useDraggableProps({ className: "demo" }), children: "Draggable content" }));
    };
    const DemoUseElementSizeAnimation = () => {
        const [height, setHeight] = useState(0);
        const [angle, setAngle] = useState(0);
        useAnimationFrame({
            callback: (_ms) => {
                setAngle(a => a + 0.01);
                setHeight((Math.sin(angle) + 1) / 0.5);
            }
        });
        const [elementSize, setElementSize] = useState(null);
        const { useElementSizeProps } = useElementSize({ onSizeChange: setElementSize });
        return (e$1("div", { ...useElementSizeProps({ ref: undefined, className: "demo", style: { height: `${(height * 100) + 100}px` } }), children: e$1("pre", { children: JSON.stringify(elementSize, null, 2) }) }));
    };
    const DemoUseFocusTrap = g(({ depth }) => {
        const [active, setActive] = useState(false);
        const { useFocusTrapProps } = useFocusTrap({ trapActive: active });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        const divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return e$1("div", {});
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), e$1("div", { ...divProps, children: e$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
    });
    const DemoUseFocusTrapChild = g(({ setActive, active }) => {
        return (e$1(p$1, { children: [e$1("button", { children: "Button 1" }), e$1("button", { children: "Button 2" }), e$1("button", { children: "Button 3" }), e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
    });
    const DemoUseAsyncHandler1 = g(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const asyncOnClick = ((_v, _e) => new Promise((resolve, reject) => window.setTimeout(() => getShouldThrow() ? reject() : resolve(), timeout)));
        const { callCount, settleCount, hasCapture, syncHandler, pending, hasError, rejectCount, resolveCount } = useAsyncHandler(asyncOnClick, { capture: () => { }, debounce: debounce == 0 ? undefined : debounce });
        const onClick = pending ? undefined : syncHandler;
        return (e$1("div", { className: "demo", children: [e$1("button", { disabled: pending && disableConsecutive, onClick: onClick, children: "Click me!" }), e$1("label", { children: ["Sleep for: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Throw an error ", e$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), e$1("label", { children: ["Disabled while pending ", e$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), e$1("label", { children: ["Debounce: ", e$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Field" }), e$1("th", { children: "Value" })] }) }), e$1("tbody", { children: [e$1("tr", { children: [e$1("td", { children: "callCount" }), e$1("td", { children: callCount })] }), e$1("tr", { children: [e$1("td", { children: "settleCount" }), e$1("td", { children: settleCount })] }), e$1("tr", { children: [e$1("td", { children: "resolveCount" }), e$1("td", { children: resolveCount })] }), e$1("tr", { children: [e$1("td", { children: "rejectCount" }), e$1("td", { children: rejectCount })] }), e$1("tr", { children: [e$1("td", { children: "hasError" }), e$1("td", { children: hasError.toString() })] }), e$1("tr", { children: [e$1("td", { children: "hasCapture" }), e$1("td", { children: hasCapture.toString() })] })] })] })] }));
    });
    const DemoUseAsyncHandler2 = g(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const [text, setText] = useState("");
        const onInputAsync = async (v, _e) => new Promise((resolve, reject) => window.setTimeout(() => {
            if (getShouldThrow()) {
                reject();
            }
            else {
                setText(v);
                resolve();
            }
        }, timeout));
        const { callCount, settleCount, hasCapture, syncHandler, currentCapture, pending, hasError, rejectCount, resolveCount } = useAsyncHandler(onInputAsync, { capture: (e) => { e.preventDefault(); return e.currentTarget.value; }, debounce: debounce == 0 ? undefined : debounce });
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Demo text: ", e$1("input", { value: hasCapture ? currentCapture : text, disabled: pending && disableConsecutive, onInput: syncHandler })] }), e$1("hr", {}), e$1("label", { children: ["Sleep for: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Throw an error ", e$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), e$1("label", { children: ["Disabled while pending ", e$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), e$1("label", { children: ["Debounce: ", e$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Field" }), e$1("th", { children: "Value" })] }) }), e$1("tbody", { children: [e$1("tr", { children: [e$1("td", { children: "callCount" }), e$1("td", { children: callCount })] }), e$1("tr", { children: [e$1("td", { children: "settleCount" }), e$1("td", { children: settleCount })] }), e$1("tr", { children: [e$1("td", { children: "resolveCount" }), e$1("td", { children: resolveCount })] }), e$1("tr", { children: [e$1("td", { children: "rejectCount" }), e$1("td", { children: rejectCount })] }), e$1("tr", { children: [e$1("td", { children: "hasError" }), e$1("td", { children: hasError.toString() })] }), e$1("tr", { children: [e$1("td", { children: "currentCapture" }), e$1("td", { children: currentCapture })] }), e$1("tr", { children: [e$1("td", { children: "\"Saved\" input" }), e$1("td", { children: text })] })] })] })] }));
    });
    function getDocument() {
        return window.document;
    }
    const DemoFocus = g(() => {
        const [lastActiveElement, setLastActiveElement] = useState(null);
        const [activeElement, setActiveElement] = useState(null);
        const [windowFocused, setWindowFocused] = useState(false);
        const [focused, setFocused] = useState(false);
        const [focusedInner, setFocusedInner] = useState(false);
        const [lastFocused, setLastFocused] = useState(false);
        const [lastFocusedInner, setLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({
            getDocument,
            onFocusedChanged: setFocused,
            onFocusedInnerChanged: setFocusedInner,
            onLastFocusedChanged: setLastFocused,
            onLastFocusedInnerChanged: setLastFocusedInner,
            onActiveElementChange: setActiveElement,
            onLastActiveElementChange: setLastActiveElement,
            onWindowFocusedChange: setWindowFocused
        });
        return (e$1("div", { class: "demo", children: [e$1("h2", { children: "useHasFocus" }), e$1("div", { ...useHasFocusProps({ style: { border: "1px solid black" }, tabIndex: 0 }), children: ["Outer ", e$1("div", { tabIndex: 0, style: { border: "1px solid black" }, children: "Inner element" })] }), e$1("div", { children: e$1("ul", { children: [e$1("li", { children: ["Strictly focused: ", focused.toString(), ", ", lastFocused.toString()] }), e$1("li", { children: ["Inner focused: ", focusedInner.toString(), ", ", lastFocusedInner.toString()] }), e$1("li", { children: ["Window focused: ", windowFocused.toString()] }), e$1("li", { children: ["activeElement: ", activeElement?.textContent] }), e$1("li", { children: ["lastActiveElement: ", lastActiveElement?.textContent] })] }) })] }));
    });
    const GridRowContext = B(null);
    const GridCellContext = B(null);
    const DemoUseGrid = g(() => {
        const [, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner, getDocument });
        const { useGridNavigationRow, useGridNavigationProps, gridNavigation: { currentColumn } } = useGridNavigation({
            rovingTabIndex: {},
            linearNavigation: {},
            listNavigation: {},
            typeaheadNavigation: {},
            managedChildren: {}
        });
        return (e$1("div", { class: "demo", children: [e$1("div", { children: ["Current column: ", currentColumn] }), e$1("table", { ...{ border: "2" }, style: { whiteSpace: "nowrap" }, children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Row is tabbable?" }), e$1("th", { children: "Column 1" }), e$1("th", { children: "Column 2" })] }) }), e$1("tbody", { ...useHasFocusProps(useGridNavigationProps({})), children: e$1(GridRowContext.Provider, { value: useGridNavigationRow, children: Array.from((function* () {
                                    for (let i = 0; i < 10; ++i) {
                                        yield e$1(DemoUseGridRow, { index: i }, i);
                                    }
                                })()) }) })] })] }));
    });
    const DemoUseGridRow = g((({ index }) => {
        useState(() => RandomWords[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useGridRow = q$1(GridRowContext);
        const { useGridNavigationRowProps, useGridNavigationCell, asChildRow: { rovingTabIndex: { tabbable } }, } = useGridRow({
            asChildRowOfSection: { managedChild: { index }, listNavigation: { text: "" }, rovingTabIndex: { hidden: index == 3 }, subInfo: {} },
            asParentRowOfCells: { linearNavigation: {}, listNavigation: {}, rovingTabIndex: {}, typeaheadNavigation: {}, managedChildren: {} },
        });
        const props = useGridNavigationRowProps({});
        return (e$1("tr", { ...props, children: e$1(GridCellContext.Provider, { value: useGridNavigationCell, children: Array.from((function* () {
                    for (let i = 0; i < 3; ++i) {
                        yield e$1(DemoUseGridCell, { index: i, row: index, rowIsTabbable: tabbable }, i);
                    }
                })()) }) }));
    }));
    const DemoUseGridCell = (({ index, row, rowIsTabbable }) => {
        if (row >= 6 && row % 2 == 0 && index > 1)
            return null;
        let hiddenText = (row === 3) ? " (row hidden)" : "";
        const useGridCell = q$1(GridCellContext);
        const { useGridNavigationCellProps, rovingTabIndex: { tabbable: cellIsTabbable } } = useGridCell({
            listNavigation: { text: "" },
            managedChild: { index },
            rovingTabIndex: { hidden: false },
            hasFocus: { getDocument },
            subInfo: {},
        });
        const props = useGridNavigationCellProps({});
        const t = (cellIsTabbable ? "(Tabbable)" : "(Not tabbable)");
        if (index === 0)
            return e$1("td", { ...props, children: rowIsTabbable.toString() });
        else {
            if (row < 6 || row % 2 != 0) {
                if (index === 1)
                    return e$1("td", { ...props, children: ["Grid cell #", index + 1, " ", t, hiddenText] });
                else
                    return e$1("td", { children: e$1("label", { children: [e$1("input", { ...props, type: "checkbox" }), " Test input ", t, hiddenText] }) });
            }
            else {
                if (index === 1)
                    return e$1("td", { ...props, colSpan: 2, children: ["Grid cell #", index + 1, ", span 2 ", t, hiddenText] });
                else
                    return null;
            }
        }
    });
    const Component = () => {
        return e$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [e$1(DemoFocus, {}), e$1("hr", {}), e$1(DemoUseGrid, {}), e$1("hr", {}), e$1(DemoUseTimeout, {}), e$1("hr", {}), e$1(DemoUseInterval, {}), e$1("hr", {}), e$1(DemoUseRovingTabIndex, {}), e$1("hr", {}), e$1(DemoUseFocusTrap, {}), e$1("hr", {}), e$1(DemoUseAsyncHandler1, {}), e$1("hr", {}), e$1(DemoUseAsyncHandler2, {}), e$1("hr", {}), e$1(DemoUseDroppable, {}), e$1("hr", {}), e$1(DemoUseDraggable, {}), e$1("hr", {}), e$1(DemoUseElementSizeAnimation, {}), e$1("hr", {}), e$1("input", {})] });
    };
    requestAnimationFrame(() => {
        P$1(e$1(Component, {}), document.getElementById("root"));
    });

    exports.DemoUseGrid = DemoUseGrid;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwiLi4vc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub3cuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190cmltbWVkRW5kSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVHJpbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9OdW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2RlYm91bmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90aHJvdHRsZS5qcyIsIi4uL3NyYy91c2Utc3RhdGUudHN4IiwiLi4vc3JjL3VzZS1hc3luYy50c3giLCIuLi9zcmMvdXNlLWFzeW5jLWhhbmRsZXIudHN4IiwiLi4vc3JjL3VzZS1jaGlsZC1tYW5hZ2VyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vc3JjL3VzZS1kb2N1bWVudC1jbGFzcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1jaGlsZHJlbi50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1jbGFzc2VzLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLXJlZnMudHN4IiwiLi4vc3JjL3VzZS1tZXJnZWQtc3R5bGVzLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLXByb3BzLnRzeCIsIi4uL3NyYy91c2UtZHJhZ2dhYmxlLnRzeCIsIi4uL3NyYy91c2UtZHJvcHBhYmxlLnRzeCIsIi4uL3NyYy91c2UtcmVmLWVsZW1lbnQudHN4IiwiLi4vc3JjL3VzZS1lbGVtZW50LXNpemUudHN4IiwiLi4vc3JjL3VzZS1ldmVudC1oYW5kbGVyLnRzeCIsIi4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL3NyYy91c2UtYmxvY2tpbmctZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWZvY3VzLXRyYXAudHN4IiwiLi4vc3JjL3VzZS1mb3JjZS11cGRhdGUudHN4IiwiLi4vc3JjL3VzZS1oYXMtZm9jdXMudHN4IiwiLi4vc3JjL3VzZS1wcmVzcy50c3giLCIuLi9zcmMvdXNlLWxvZ2ljYWwtZGlyZWN0aW9uLnRzeCIsIi4uL3NyYy91c2UtdGltZW91dC50c3giLCIuLi9zcmMvdXNlLWtleWJvYXJkLW5hdmlnYXRpb24udHN4IiwiLi4vc3JjL3VzZS1yb3ZpbmctdGFiaW5kZXgudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NodWZmbGUuanMiLCIuLi9zcmMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuLnRzeCIsIi4uL3NyYy91c2UtbGlzdC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2UtZ3JpZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2UtaW50ZXJ2YWwudHN4IiwiZGVtb3MvdXNlLWludGVydmFsLnRzeCIsImRlbW9zL3VzZS1yb3ZpbmctdGFiLWluZGV4LnRzeCIsImRlbW9zL3VzZS10aW1lb3V0LnRzeCIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTVBUWV9BUlIgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHQvLyBAdHMtaWdub3JlIFdlIGNoYW5nZSB0aGUgdHlwZSBvZiBgb2JqYCB0byBiZSBgTyAmIFBgXG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvclxuICogSUUxMSB3aGljaCBkb2Vzbid0IHN1cHBvcnQgYEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSgpYC4gVXNpbmcgdGhpcyBmdW5jdGlvblxuICogaXMgc21hbGxlciB0aGFuIGluY2x1ZGluZyBhIGRlZGljYXRlZCBwb2x5ZmlsbC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IEVNUFRZX0FSUi5zbGljZTtcbiIsImltcG9ydCB7IF9jYXRjaEVycm9yIH0gZnJvbSAnLi9kaWZmL2NhdGNoLWVycm9yJztcblxuLyoqXG4gKiBUaGUgYG9wdGlvbmAgb2JqZWN0IGNhbiBwb3RlbnRpYWxseSBjb250YWluIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICogdGhhdCBhcmUgY2FsbGVkIGR1cmluZyB2YXJpb3VzIHN0YWdlcyBvZiBvdXIgcmVuZGVyZXIuIFRoaXMgaXMgdGhlXG4gKiBmb3VuZGF0aW9uIG9uIHdoaWNoIGFsbCBvdXIgYWRkb25zIGxpa2UgYHByZWFjdC9kZWJ1Z2AsIGBwcmVhY3QvY29tcGF0YCxcbiAqIGFuZCBgcHJlYWN0L2hvb2tzYCBhcmUgYmFzZWQgb24uIFNlZSB0aGUgYE9wdGlvbnNgIHR5cGUgaW4gYGludGVybmFsLmQudHNgXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbiBob29rcyAobW9zdCBlZGl0b3JzL0lERXMgYWxsb3cgeW91IHRvXG4gKiBjdHJsK2NsaWNrIG9yIGNtZCtjbGljayBvbiBtYWMgdGhlIHR5cGUgZGVmaW5pdGlvbiBiZWxvdykuXG4gKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuT3B0aW9uc31cbiAqL1xuY29uc3Qgb3B0aW9ucyA9IHtcblx0X2NhdGNoRXJyb3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9wdGlvbnM7XG4iLCJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5cbi8qKlxuICogQmFzZSBDb21wb25lbnQgY2xhc3MuIFByb3ZpZGVzIGBzZXRTdGF0ZSgpYCBhbmQgYGZvcmNlVXBkYXRlKClgLCB3aGljaFxuICogdHJpZ2dlciByZW5kZXJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgaW5pdGlhbCBjb21wb25lbnQgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IFRoZSBpbml0aWFsIGNvbnRleHQgZnJvbSBwYXJlbnQgY29tcG9uZW50cydcbiAqIGdldENoaWxkQ29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdHRoaXMucHJvcHMgPSBwcm9wcztcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGFuZCBzY2hlZHVsZSBhIHJlLXJlbmRlci5cbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8ICgoczogb2JqZWN0LCBwOiBvYmplY3QpID0+IG9iamVjdCl9IHVwZGF0ZSBBIGhhc2ggb2Ygc3RhdGVcbiAqIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlcyBvciBhIGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAqIHN0YXRlIGFuZCBwcm9wcyByZXR1cm5zIGEgbmV3IHBhcnRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGNvbXBvbmVudCBzdGF0ZSBpc1xuICogdXBkYXRlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHQvLyBvbmx5IGNsb25lIHN0YXRlIHdoZW4gY29weWluZyB0byBuZXh0U3RhdGUgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBzO1xuXHRpZiAodGhpcy5fbmV4dFN0YXRlICE9IG51bGwgJiYgdGhpcy5fbmV4dFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZTtcblx0fSBlbHNlIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXBkYXRlID09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBTb21lIGxpYnJhcmllcyBsaWtlIGBpbW1lcmAgbWFyayB0aGUgY3VycmVudCBzdGF0ZSBhcyByZWFkb25seSxcblx0XHQvLyBwcmV2ZW50aW5nIHVzIGZyb20gbXV0YXRpbmcgaXQsIHNvIHdlIG5lZWQgdG8gY2xvbmUgaXQuIFNlZSAjMjcxNlxuXHRcdHVwZGF0ZSA9IHVwZGF0ZShhc3NpZ24oe30sIHMpLCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdGlmICh1cGRhdGUpIHtcblx0XHRhc3NpZ24ocywgdXBkYXRlKTtcblx0fVxuXG5cdC8vIFNraXAgdXBkYXRlIGlmIHVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgbnVsbFxuXHRpZiAodXBkYXRlID09IG51bGwpIHJldHVybjtcblxuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHRoaXMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBjb21wb25lbnQgaXNcbiAqIHJlLXJlbmRlcmVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHQvLyBTZXQgcmVuZGVyIG1vZGUgc28gdGhhdCB3ZSBjYW4gZGlmZmVyZW50aWF0ZSB3aGVyZSB0aGUgcmVuZGVyIHJlcXVlc3Rcblx0XHQvLyBpcyBjb21pbmcgZnJvbS4gV2UgbmVlZCB0aGlzIGJlY2F1c2UgZm9yY2VVcGRhdGUgc2hvdWxkIG5ldmVyIGNhbGxcblx0XHQvLyBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0XHR0aGlzLl9mb3JjZSA9IHRydWU7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gKiBWaXJ0dWFsIERPTSBpcyBnZW5lcmFsbHkgY29uc3RydWN0ZWQgdmlhIFtKU1hdKGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeCkuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnRcbiAqIGVsZW1lbnQvY29tcG9uZW50XG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIGNvbXBvbmVudCdzIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IENvbnRleHQgb2JqZWN0LCBhcyByZXR1cm5lZCBieSB0aGUgbmVhcmVzdFxuICogYW5jZXN0b3IncyBgZ2V0Q2hpbGRDb250ZXh0KClgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW4gfCB2b2lkfVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IEZyYWdtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFtjaGlsZEluZGV4XVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tU2libGluZyh2bm9kZSwgY2hpbGRJbmRleCkge1xuXHRpZiAoY2hpbGRJbmRleCA9PSBudWxsKSB7XG5cdFx0Ly8gVXNlIGNoaWxkSW5kZXg9PW51bGwgYXMgYSBzaWduYWwgdG8gcmVzdW1lIHRoZSBzZWFyY2ggZnJvbSB0aGUgdm5vZGUncyBzaWJsaW5nXG5cdFx0cmV0dXJuIHZub2RlLl9wYXJlbnRcblx0XHRcdD8gZ2V0RG9tU2libGluZyh2bm9kZS5fcGFyZW50LCB2bm9kZS5fcGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHZub2RlKSArIDEpXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHRsZXQgc2libGluZztcblx0Zm9yICg7IGNoaWxkSW5kZXggPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZEluZGV4KyspIHtcblx0XHRzaWJsaW5nID0gdm5vZGUuX2NoaWxkcmVuW2NoaWxkSW5kZXhdO1xuXG5cdFx0aWYgKHNpYmxpbmcgIT0gbnVsbCAmJiBzaWJsaW5nLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0Ly8gU2luY2UgdXBkYXRlUGFyZW50RG9tUG9pbnRlcnMga2VlcHMgX2RvbSBwb2ludGVyIGNvcnJlY3QsXG5cdFx0XHQvLyB3ZSBjYW4gcmVseSBvbiBfZG9tIHRvIHRlbGwgdXMgaWYgdGhpcyBzdWJ0cmVlIGNvbnRhaW5zIGFcblx0XHRcdC8vIHJlbmRlcmVkIERPTSBub2RlLCBhbmQgd2hhdCB0aGUgZmlyc3QgcmVuZGVyZWQgRE9NIG5vZGUgaXNcblx0XHRcdHJldHVybiBzaWJsaW5nLl9kb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgbm90IGZvdW5kIGEgRE9NIG5vZGUgaW4gdGhpcyB2bm9kZSdzIGNoaWxkcmVuLlxuXHQvLyBXZSBtdXN0IHJlc3VtZSBmcm9tIHRoaXMgdm5vZGUncyBzaWJsaW5nIChpbiBpdCdzIHBhcmVudCBfY2hpbGRyZW4gYXJyYXkpXG5cdC8vIE9ubHkgY2xpbWIgdXAgYW5kIHNlYXJjaCB0aGUgcGFyZW50IGlmIHdlIGFyZW4ndCBzZWFyY2hpbmcgdGhyb3VnaCBhIERPTVxuXHQvLyBWTm9kZSAobWVhbmluZyB3ZSByZWFjaGVkIHRoZSBET00gcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB2bm9kZSB0aGF0IGJlZ2FuXG5cdC8vIHRoZSBzZWFyY2gpXG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgaW4tcGxhY2UgcmUtcmVuZGVyaW5nIG9mIGEgY29tcG9uZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQpIHtcblx0bGV0IHZub2RlID0gY29tcG9uZW50Ll92bm9kZSxcblx0XHRvbGREb20gPSB2bm9kZS5fZG9tLFxuXHRcdHBhcmVudERvbSA9IGNvbXBvbmVudC5fcGFyZW50RG9tO1xuXG5cdGlmIChwYXJlbnREb20pIHtcblx0XHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0XHRjb25zdCBvbGRWTm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdG9sZFZOb2RlLl9vcmlnaW5hbCA9IHZub2RlLl9vcmlnaW5hbCArIDE7XG5cblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmcgIT0gbnVsbCA/IFtvbGREb21dIDogbnVsbCxcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tID09IG51bGwgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG9sZERvbSxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmdcblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmICh2bm9kZS5fZG9tICE9IG9sZERvbSkge1xuXHRcdFx0dXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKSB7XG5cdGlmICgodm5vZGUgPSB2bm9kZS5fcGFyZW50KSAhPSBudWxsICYmIHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5fZG9tICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IGNoaWxkLl9kb207XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVuZGVyIHF1ZXVlXG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn1cbiAqL1xubGV0IHJlcmVuZGVyUXVldWUgPSBbXTtcblxuLypcbiAqIFRoZSB2YWx1ZSBvZiBgQ29tcG9uZW50LmRlYm91bmNlYCBtdXN0IGFzeW5jaHJvbm91c2x5IGludm9rZSB0aGUgcGFzc2VkIGluIGNhbGxiYWNrLiBJdCBpc1xuICogaW1wb3J0YW50IHRoYXQgY29udHJpYnV0b3JzIHRvIFByZWFjdCBjYW4gY29uc2lzdGVudGx5IHJlYXNvbiBhYm91dCB3aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAsIGV0Yy5cbiAqIGRvLCBhbmQgd2hlbiB0aGVpciBlZmZlY3RzIHdpbGwgYmUgYXBwbGllZC4gU2VlIHRoZSBsaW5rcyBiZWxvdyBmb3Igc29tZSBmdXJ0aGVyIHJlYWRpbmcgb24gZGVzaWduaW5nXG4gKiBhc3luY2hyb25vdXMgQVBJcy5cbiAqICogW0Rlc2lnbmluZyBBUElzIGZvciBBc3luY2hyb255XShodHRwczovL2Jsb2cuaXpzLm1lLzIwMTMvMDgvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiAqIFtDYWxsYmFja3Mgc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91c10oaHR0cHM6Ly9ibG9nLm9tZXRlci5jb20vMjAxMS8wNy8yNC9jYWxsYmFja3Mtc3luY2hyb25vdXMtYW5kLWFzeW5jaHJvbm91cy8pXG4gKi9cblxubGV0IHByZXZEZWJvdW5jZTtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IHNldFRpbWVvdXQpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cbnByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSAwO1xuIiwiaW1wb3J0IHsgZW5xdWV1ZVJlbmRlciB9IGZyb20gJy4vY29tcG9uZW50JztcblxuZXhwb3J0IGxldCBpID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbnRleHQoZGVmYXVsdFZhbHVlLCBjb250ZXh0SWQpIHtcblx0Y29udGV4dElkID0gJ19fY0MnICsgaSsrO1xuXG5cdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0X2lkOiBjb250ZXh0SWQsXG5cdFx0X2RlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlLFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0Q29uc3VtZXIocHJvcHMsIGNvbnRleHRWYWx1ZSkge1xuXHRcdFx0Ly8gcmV0dXJuIHByb3BzLmNoaWxkcmVuKFxuXHRcdFx0Ly8gXHRjb250ZXh0W2NvbnRleHRJZF0gPyBjb250ZXh0W2NvbnRleHRJZF0ucHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWVcblx0XHRcdC8vICk7XG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW4oY29udGV4dFZhbHVlKTtcblx0XHR9LFxuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9ICovXG5cdFx0UHJvdmlkZXIocHJvcHMpIHtcblx0XHRcdGlmICghdGhpcy5nZXRDaGlsZENvbnRleHQpIHtcblx0XHRcdFx0bGV0IHN1YnMgPSBbXTtcblx0XHRcdFx0bGV0IGN0eCA9IHt9O1xuXHRcdFx0XHRjdHhbY29udGV4dElkXSA9IHRoaXM7XG5cblx0XHRcdFx0dGhpcy5nZXRDaGlsZENvbnRleHQgPSAoKSA9PiBjdHg7XG5cblx0XHRcdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihfcHJvcHMpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5wcm9wcy52YWx1ZSAhPT0gX3Byb3BzLnZhbHVlKSB7XG5cdFx0XHRcdFx0XHQvLyBJIHRoaW5rIHRoZSBmb3JjZWQgdmFsdWUgcHJvcGFnYXRpb24gaGVyZSB3YXMgb25seSBuZWVkZWQgd2hlbiBgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZ2Agd2FzIGJlaW5nIGJ5cGFzc2VkOlxuXHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9jb21taXQvNGQzMzlmYjgwM2JlYTA5ZTlmMTk4YWJmMzhjYTFiZjhlYTRiNzc3MSNkaWZmLTU0NjgyY2UzODA5MzVhNzE3ZTQxYjhiZmM1NDczN2Y2UjM1OFxuXHRcdFx0XHRcdFx0Ly8gSW4gdGhvc2UgY2FzZXMgdGhvdWdoLCBldmVuIHdpdGggdGhlIHZhbHVlIGNvcnJlY3RlZCwgd2UncmUgZG91YmxlLXJlbmRlcmluZyBhbGwgbm9kZXMuXG5cdFx0XHRcdFx0XHQvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCB0ZWxsIGZvbGtzIG5vdCB0byB1c2UgZm9yY2Utc3luYyBtb2RlLlxuXHRcdFx0XHRcdFx0Ly8gQ3VycmVudGx5LCB1c2luZyBgdXNlQ29udGV4dCgpYCBpbiBhIGNsYXNzIGNvbXBvbmVudCB3aWxsIG92ZXJ3cml0ZSBpdHMgYHRoaXMuY29udGV4dGAgdmFsdWUuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dCA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXG5cdFx0XHRcdFx0XHQvLyBzdWJzLnNvbWUoYyA9PiB7XG5cdFx0XHRcdFx0XHQvLyBcdGMuY29udGV4dFtjb250ZXh0SWRdID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cdFx0XHRcdFx0XHRzdWJzLnNvbWUoZW5xdWV1ZVJlbmRlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdHRoaXMuc3ViID0gYyA9PiB7XG5cdFx0XHRcdFx0c3Vicy5wdXNoKGMpO1xuXHRcdFx0XHRcdGxldCBvbGQgPSBjLmNvbXBvbmVudFdpbGxVbm1vdW50O1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVubW91bnQgPSAoKSA9PiB7XG5cdFx0XHRcdFx0XHRzdWJzLnNwbGljZShzdWJzLmluZGV4T2YoYyksIDEpO1xuXHRcdFx0XHRcdFx0aWYgKG9sZCkgb2xkLmNhbGwoYyk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuXHRcdH1cblx0fTtcblxuXHQvLyBEZXZ0b29scyBuZWVkcyBhY2Nlc3MgdG8gdGhlIGNvbnRleHQgb2JqZWN0IHdoZW4gaXRcblx0Ly8gZW5jb3VudGVycyBhIFByb3ZpZGVyLiBUaGlzIGlzIG5lY2Vzc2FyeSB0byBzdXBwb3J0XG5cdC8vIHNldHRpbmcgYGRpc3BsYXlOYW1lYCBvbiB0aGUgY29udGV4dCBvYmplY3QgaW5zdGVhZFxuXHQvLyBvZiBvbiB0aGUgY29tcG9uZW50IGl0c2VsZi4gU2VlOlxuXHQvLyBodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sI2NvbnRleHRkaXNwbGF5bmFtZVxuXG5cdHJldHVybiAoY29udGV4dC5Qcm92aWRlci5fY29udGV4dFJlZiA9IGNvbnRleHQuQ29uc3VtZXIuY29udGV4dFR5cGUgPSBjb250ZXh0KTtcbn1cbiIsImV4cG9ydCBjb25zdCBFTVBUWV9PQkogPSB7fTtcbmV4cG9ydCBjb25zdCBFTVBUWV9BUlIgPSBbXTtcbmV4cG9ydCBjb25zdCBJU19OT05fRElNRU5TSU9OQUwgPSAvYWNpdHxleCg/OnN8Z3xufHB8JCl8cnBofGdyaWR8b3dzfG1uY3xudHd8aW5lW2NoXXx6b298Xm9yZHxpdGVyYS9pO1xuIiwiaW1wb3J0IHsgZGlmZiwgdW5tb3VudCwgYXBwbHlSZWYgfSBmcm9tICcuL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZVZOb2RlLCBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IEVNUFRZX09CSiwgRU1QVFlfQVJSIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuXG4vKipcbiAqIERpZmYgdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHdob3NlXG4gKiBjaGlsZHJlbiBhcmUgYmVpbmcgZGlmZmVkXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZHJlbltdfSByZW5kZXJSZXN1bHRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdQYXJlbnRWTm9kZSBUaGUgbmV3IHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBvbGRQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFBhcmVudFZOb2RlIFRoZSBvbGQgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG5ld1BhcmVudFZOb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdCAtIG1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0h5ZHJhdGluZyBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmQ2hpbGRyZW4oXG5cdHBhcmVudERvbSxcblx0cmVuZGVyUmVzdWx0LFxuXHRuZXdQYXJlbnRWTm9kZSxcblx0b2xkUGFyZW50Vk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgaSwgaiwgb2xkVk5vZGUsIGNoaWxkVk5vZGUsIG5ld0RvbSwgZmlyc3RDaGlsZERvbSwgcmVmcztcblxuXHQvLyBUaGlzIGlzIGEgY29tcHJlc3Npb24gb2Ygb2xkUGFyZW50Vk5vZGUhPW51bGwgJiYgb2xkUGFyZW50Vk5vZGUgIT0gRU1QVFlfT0JKICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbiB8fCBFTVBUWV9BUlJcblx0Ly8gYXMgRU1QVFlfT0JKLl9jaGlsZHJlbiBzaG91bGQgYmUgYHVuZGVmaW5lZGAuXG5cdGxldCBvbGRDaGlsZHJlbiA9IChvbGRQYXJlbnRWTm9kZSAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4pIHx8IEVNUFRZX0FSUjtcblxuXHRsZXQgb2xkQ2hpbGRyZW5MZW5ndGggPSBvbGRDaGlsZHJlbi5sZW5ndGg7XG5cblx0bmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdGZvciAoaSA9IDA7IGkgPCByZW5kZXJSZXN1bHQubGVuZ3RoOyBpKyspIHtcblx0XHRjaGlsZFZOb2RlID0gcmVuZGVyUmVzdWx0W2ldO1xuXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYm9vbGVhbicpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdH1cblx0XHQvLyBJZiB0aGlzIG5ld1ZOb2RlIGlzIGJlaW5nIHJldXNlZCAoZS5nLiA8ZGl2PntyZXVzZX17cmV1c2V9PC9kaXY+KSBpbiB0aGUgc2FtZSBkaWZmLFxuXHRcdC8vIG9yIHdlIGFyZSByZW5kZXJpbmcgYSBjb21wb25lbnQgKGUuZy4gc2V0U3RhdGUpIGNvcHkgdGhlIG9sZFZOb2RlcyBzbyBpdCBjYW4gaGF2ZVxuXHRcdC8vIGl0J3Mgb3duIERPTSAmIGV0Yy4gcG9pbnRlcnNcblx0XHRlbHNlIGlmIChcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdzdHJpbmcnIHx8XG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnbnVtYmVyJyB8fFxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHZhbGlkLXR5cGVvZlxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2JpZ2ludCdcblx0XHQpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZVxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRWTm9kZSkpIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0RnJhZ21lbnQsXG5cdFx0XHRcdHsgY2hpbGRyZW46IGNoaWxkVk5vZGUgfSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0bnVsbFxuXHRcdFx0KTtcblx0XHR9IGVsc2UgaWYgKGNoaWxkVk5vZGUuX2RlcHRoID4gMCkge1xuXHRcdFx0Ly8gVk5vZGUgaXMgYWxyZWFkeSBpbiB1c2UsIGNsb25lIGl0LiBUaGlzIGNhbiBoYXBwZW4gaW4gdGhlIGZvbGxvd2luZ1xuXHRcdFx0Ly8gc2NlbmFyaW86XG5cdFx0XHQvLyAgIGNvbnN0IHJldXNlID0gPGRpdiAvPlxuXHRcdFx0Ly8gICA8ZGl2PntyZXVzZX08c3BhbiAvPntyZXVzZX08L2Rpdj5cblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjcmVhdGVWTm9kZShcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlLFxuXHRcdFx0XHRjaGlsZFZOb2RlLnByb3BzLFxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSxcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjaGlsZFZOb2RlO1xuXHRcdH1cblxuXHRcdC8vIFRlcnNlciByZW1vdmVzIHRoZSBgY29udGludWVgIGhlcmUgYW5kIHdyYXBzIHRoZSBsb29wIGJvZHlcblx0XHQvLyBpbiBhIGBpZiAoY2hpbGRWTm9kZSkgeyAuLi4gfSBjb25kaXRpb25cblx0XHRpZiAoY2hpbGRWTm9kZSA9PSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjaGlsZFZOb2RlLl9wYXJlbnQgPSBuZXdQYXJlbnRWTm9kZTtcblx0XHRjaGlsZFZOb2RlLl9kZXB0aCA9IG5ld1BhcmVudFZOb2RlLl9kZXB0aCArIDE7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBmaW5kIGEgY29ycmVzcG9uZGluZyBlbGVtZW50IGluIG9sZENoaWxkcmVuLlxuXHRcdC8vIElmIGZvdW5kLCBkZWxldGUgdGhlIGFycmF5IGl0ZW0gYnkgc2V0dGluZyB0byBgdW5kZWZpbmVkYC5cblx0XHQvLyBXZSB1c2UgYHVuZGVmaW5lZGAsIGFzIGBudWxsYCBpcyByZXNlcnZlZCBmb3IgZW1wdHkgcGxhY2Vob2xkZXJzXG5cdFx0Ly8gKGhvbGVzKS5cblx0XHRvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuXG5cdFx0aWYgKFxuXHRcdFx0b2xkVk5vZGUgPT09IG51bGwgfHxcblx0XHRcdChvbGRWTm9kZSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlKVxuXHRcdCkge1xuXHRcdFx0b2xkQ2hpbGRyZW5baV0gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVpdGhlciBvbGRWTm9kZSA9PT0gdW5kZWZpbmVkIG9yIG9sZENoaWxkcmVuTGVuZ3RoID4gMCxcblx0XHRcdC8vIHNvIGFmdGVyIHRoaXMgbG9vcCBvbGRWTm9kZSA9PSBudWxsIG9yIG9sZFZOb2RlIGlzIGEgdmFsaWQgdmFsdWUuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgb2xkQ2hpbGRyZW5MZW5ndGg7IGorKykge1xuXHRcdFx0XHRvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2pdO1xuXHRcdFx0XHQvLyBJZiBjaGlsZFZOb2RlIGlzIHVua2V5ZWQsIHdlIG9ubHkgbWF0Y2ggc2ltaWxhcmx5IHVua2V5ZWQgbm9kZXMsIG90aGVyd2lzZSB3ZSBtYXRjaCBieSBrZXkuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBtYXRjaCBieSB0eXBlIChpbiBlaXRoZXIgY2FzZSkuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRvbGRWTm9kZSAmJlxuXHRcdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRvbGRDaGlsZHJlbltqXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRvbGRWTm9kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b2xkVk5vZGUgPSBvbGRWTm9kZSB8fCBFTVBUWV9PQko7XG5cblx0XHQvLyBNb3JwaCB0aGUgb2xkIGVsZW1lbnQgaW50byB0aGUgbmV3IG9uZSwgYnV0IGRvbid0IGFwcGVuZCBpdCB0byB0aGUgZG9tIHlldFxuXHRcdGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0aXNTdmcsXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tLFxuXHRcdFx0aXNIeWRyYXRpbmdcblx0XHQpO1xuXG5cdFx0bmV3RG9tID0gY2hpbGRWTm9kZS5fZG9tO1xuXG5cdFx0aWYgKChqID0gY2hpbGRWTm9kZS5yZWYpICYmIG9sZFZOb2RlLnJlZiAhPSBqKSB7XG5cdFx0XHRpZiAoIXJlZnMpIHJlZnMgPSBbXTtcblx0XHRcdGlmIChvbGRWTm9kZS5yZWYpIHJlZnMucHVzaChvbGRWTm9kZS5yZWYsIG51bGwsIGNoaWxkVk5vZGUpO1xuXHRcdFx0cmVmcy5wdXNoKGosIGNoaWxkVk5vZGUuX2NvbXBvbmVudCB8fCBuZXdEb20sIGNoaWxkVk5vZGUpO1xuXHRcdH1cblxuXHRcdGlmIChuZXdEb20gIT0gbnVsbCkge1xuXHRcdFx0aWYgKGZpcnN0Q2hpbGREb20gPT0gbnVsbCkge1xuXHRcdFx0XHRmaXJzdENoaWxkRG9tID0gbmV3RG9tO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLl9jaGlsZHJlbiA9PT0gb2xkVk5vZGUuX2NoaWxkcmVuXG5cdFx0XHQpIHtcblx0XHRcdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbihcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0XHRwYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZERvbSA9IHBsYWNlQ2hpbGQoXG5cdFx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW4sXG5cdFx0XHRcdFx0bmV3RG9tLFxuXHRcdFx0XHRcdG9sZERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvLyBCZWNhdXNlIHRoZSBuZXdQYXJlbnRWTm9kZSBpcyBGcmFnbWVudC1saWtlLCB3ZSBuZWVkIHRvIHNldCBpdCdzXG5cdFx0XHRcdC8vIF9uZXh0RG9tIHByb3BlcnR5IHRvIHRoZSBuZXh0U2libGluZyBvZiBpdHMgbGFzdCBjaGlsZCBET00gbm9kZS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gYG9sZERvbWAgY29udGFpbnMgdGhlIGNvcnJlY3QgdmFsdWUgaGVyZSBiZWNhdXNlIGlmIHRoZSBsYXN0IGNoaWxkXG5cdFx0XHRcdC8vIGlzIGEgRnJhZ21lbnQtbGlrZSwgdGhlbiBvbGREb20gaGFzIGFscmVhZHkgYmVlbiBzZXQgdG8gdGhhdCBjaGlsZCdzIF9uZXh0RG9tLlxuXHRcdFx0XHQvLyBJZiB0aGUgbGFzdCBjaGlsZCBpcyBhIERPTSBWTm9kZSwgdGhlbiBvbGREb20gd2lsbCBiZSBzZXQgdG8gdGhhdCBET01cblx0XHRcdFx0Ly8gbm9kZSdzIG5leHRTaWJsaW5nLlxuXHRcdFx0XHRuZXdQYXJlbnRWTm9kZS5fbmV4dERvbSA9IG9sZERvbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0b2xkRG9tICYmXG5cdFx0XHRvbGRWTm9kZS5fZG9tID09IG9sZERvbSAmJlxuXHRcdFx0b2xkRG9tLnBhcmVudE5vZGUgIT0gcGFyZW50RG9tXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGUgYWJvdmUgY29uZGl0aW9uIGlzIHRvIGhhbmRsZSBudWxsIHBsYWNlaG9sZGVycy4gU2VlIHRlc3QgaW4gcGxhY2Vob2xkZXIudGVzdC5qczpcblx0XHRcdC8vIGBlZmZpY2llbnRseSByZXBsYWNlIG51bGwgcGxhY2Vob2xkZXJzIGluIHBhcmVudCByZXJlbmRlcnNgXG5cdFx0XHRvbGREb20gPSBnZXREb21TaWJsaW5nKG9sZFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRuZXdQYXJlbnRWTm9kZS5fZG9tID0gZmlyc3RDaGlsZERvbTtcblxuXHQvLyBSZW1vdmUgcmVtYWluaW5nIG9sZENoaWxkcmVuIGlmIHRoZXJlIGFyZSBhbnkuXG5cdGZvciAoaSA9IG9sZENoaWxkcmVuTGVuZ3RoOyBpLS07ICkge1xuXHRcdGlmIChvbGRDaGlsZHJlbltpXSAhPSBudWxsKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0b2xkQ2hpbGRyZW5baV0uX2RvbSAhPSBudWxsICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gPT0gbmV3UGFyZW50Vk5vZGUuX25leHREb21cblx0XHRcdCkge1xuXHRcdFx0XHQvLyBJZiB0aGUgbmV3UGFyZW50Vk5vZGUuX19uZXh0RG9tIHBvaW50cyB0byBhIGRvbSBub2RlIHRoYXQgaXMgYWJvdXQgdG9cblx0XHRcdFx0Ly8gYmUgdW5tb3VudGVkLCB0aGVuIGdldCB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoYXQgdm5vZGUgYW5kIHNldFxuXHRcdFx0XHQvLyBfbmV4dERvbSB0byBpdFxuXHRcdFx0XHRuZXdQYXJlbnRWTm9kZS5fbmV4dERvbSA9IGdldERvbVNpYmxpbmcob2xkUGFyZW50Vk5vZGUsIGkgKyAxKTtcblx0XHRcdH1cblxuXHRcdFx0dW5tb3VudChvbGRDaGlsZHJlbltpXSwgb2xkQ2hpbGRyZW5baV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNldCByZWZzIG9ubHkgYWZ0ZXIgdW5tb3VudFxuXHRpZiAocmVmcykge1xuXHRcdGZvciAoaSA9IDA7IGkgPCByZWZzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRhcHBseVJlZihyZWZzW2ldLCByZWZzWysraV0sIHJlZnNbKytpXSk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHJlb3JkZXJDaGlsZHJlbihjaGlsZFZOb2RlLCBvbGREb20sIHBhcmVudERvbSkge1xuXHQvLyBOb3RlOiBWTm9kZXMgaW4gbmVzdGVkIHN1c3BlbmRlZCB0cmVlcyBtYXkgYmUgbWlzc2luZyBfY2hpbGRyZW4uXG5cdGxldCBjID0gY2hpbGRWTm9kZS5fY2hpbGRyZW47XG5cdGxldCB0bXAgPSAwO1xuXHRmb3IgKDsgYyAmJiB0bXAgPCBjLmxlbmd0aDsgdG1wKyspIHtcblx0XHRsZXQgdm5vZGUgPSBjW3RtcF07XG5cdFx0aWYgKHZub2RlKSB7XG5cdFx0XHQvLyBXZSB0eXBpY2FsbHkgZW50ZXIgdGhpcyBjb2RlIHBhdGggb24gc0NVIGJhaWxvdXQsIHdoZXJlIHdlIGNvcHlcblx0XHRcdC8vIG9sZFZOb2RlLl9jaGlsZHJlbiB0byBuZXdWTm9kZS5fY2hpbGRyZW4uIElmIHRoYXQgaXMgdGhlIGNhc2UsIHdlIG5lZWRcblx0XHRcdC8vIHRvIHVwZGF0ZSB0aGUgb2xkIGNoaWxkcmVuJ3MgX3BhcmVudCBwb2ludGVyIHRvIHBvaW50IHRvIHRoZSBuZXdWTm9kZVxuXHRcdFx0Ly8gKGNoaWxkVk5vZGUgaGVyZSkuXG5cdFx0XHR2bm9kZS5fcGFyZW50ID0gY2hpbGRWTm9kZTtcblxuXHRcdFx0aWYgKHR5cGVvZiB2bm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0b2xkRG9tID0gcmVvcmRlckNoaWxkcmVuKHZub2RlLCBvbGREb20sIHBhcmVudERvbSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHR2bm9kZSxcblx0XHRcdFx0XHR2bm9kZSxcblx0XHRcdFx0XHRjLFxuXHRcdFx0XHRcdHZub2RlLl9kb20sXG5cdFx0XHRcdFx0b2xkRG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9sZERvbTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGFuZCBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbn0gY2hpbGRyZW4gVGhlIHVuZmxhdHRlbmVkXG4gKiBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9DaGlsZEFycmF5KGNoaWxkcmVuLCBvdXQpIHtcblx0b3V0ID0gb3V0IHx8IFtdO1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gJ2Jvb2xlYW4nKSB7XG5cdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRjaGlsZHJlbi5zb21lKGNoaWxkID0+IHtcblx0XHRcdHRvQ2hpbGRBcnJheShjaGlsZCwgb3V0KTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvdXQucHVzaChjaGlsZHJlbik7XG5cdH1cblx0cmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGxhY2VDaGlsZChcblx0cGFyZW50RG9tLFxuXHRjaGlsZFZOb2RlLFxuXHRvbGRWTm9kZSxcblx0b2xkQ2hpbGRyZW4sXG5cdG5ld0RvbSxcblx0b2xkRG9tXG4pIHtcblx0bGV0IG5leHREb207XG5cdGlmIChjaGlsZFZOb2RlLl9uZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyBPbmx5IEZyYWdtZW50cyBvciBjb21wb25lbnRzIHRoYXQgcmV0dXJuIEZyYWdtZW50IGxpa2UgVk5vZGVzIHdpbGxcblx0XHQvLyBoYXZlIGEgbm9uLXVuZGVmaW5lZCBfbmV4dERvbS4gQ29udGludWUgdGhlIGRpZmYgZnJvbSB0aGUgc2libGluZ1xuXHRcdC8vIG9mIGxhc3QgRE9NIGNoaWxkIG9mIHRoaXMgY2hpbGQgVk5vZGVcblx0XHRuZXh0RG9tID0gY2hpbGRWTm9kZS5fbmV4dERvbTtcblxuXHRcdC8vIEVhZ2VybHkgY2xlYW51cCBfbmV4dERvbS4gV2UgZG9uJ3QgbmVlZCB0byBwZXJzaXN0IHRoZSB2YWx1ZSBiZWNhdXNlXG5cdFx0Ly8gaXQgaXMgb25seSB1c2VkIGJ5IGBkaWZmQ2hpbGRyZW5gIHRvIGRldGVybWluZSB3aGVyZSB0byByZXN1bWUgdGhlIGRpZmYgYWZ0ZXJcblx0XHQvLyBkaWZmaW5nIENvbXBvbmVudHMgYW5kIEZyYWdtZW50cy4gT25jZSB3ZSBzdG9yZSBpdCB0aGUgbmV4dERPTSBsb2NhbCB2YXIsIHdlXG5cdFx0Ly8gY2FuIGNsZWFuIHVwIHRoZSBwcm9wZXJ0eVxuXHRcdGNoaWxkVk5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoXG5cdFx0b2xkVk5vZGUgPT0gbnVsbCB8fFxuXHRcdG5ld0RvbSAhPSBvbGREb20gfHxcblx0XHRuZXdEb20ucGFyZW50Tm9kZSA9PSBudWxsXG5cdCkge1xuXHRcdG91dGVyOiBpZiAob2xkRG9tID09IG51bGwgfHwgb2xkRG9tLnBhcmVudE5vZGUgIT09IHBhcmVudERvbSkge1xuXHRcdFx0cGFyZW50RG9tLmFwcGVuZENoaWxkKG5ld0RvbSk7XG5cdFx0XHRuZXh0RG9tID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYGo8b2xkQ2hpbGRyZW5MZW5ndGg7IGorPTJgIGlzIGFuIGFsdGVybmF0aXZlIHRvIGBqKys8b2xkQ2hpbGRyZW5MZW5ndGgvMmBcblx0XHRcdGZvciAoXG5cdFx0XHRcdGxldCBzaWJEb20gPSBvbGREb20sIGogPSAwO1xuXHRcdFx0XHQoc2liRG9tID0gc2liRG9tLm5leHRTaWJsaW5nKSAmJiBqIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHRqICs9IDJcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAoc2liRG9tID09IG5ld0RvbSkge1xuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnREb20uaW5zZXJ0QmVmb3JlKG5ld0RvbSwgb2xkRG9tKTtcblx0XHRcdG5leHREb20gPSBvbGREb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBwcmUtY2FsY3VsYXRlZCB0aGUgbmV4dERPTSBub2RlLCB1c2UgaXQuIEVsc2UgY2FsY3VsYXRlIGl0IG5vd1xuXHQvLyBTdHJpY3RseSBjaGVjayBmb3IgYHVuZGVmaW5lZGAgaGVyZSBjdXogYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUgb2YgYG5leHREb21gLlxuXHQvLyBTZWUgbW9yZSBkZXRhaWwgaW4gY3JlYXRlLWVsZW1lbnQuanM6Y3JlYXRlVk5vZGVcblx0aWYgKG5leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdG9sZERvbSA9IG5leHREb207XG5cdH0gZWxzZSB7XG5cdFx0b2xkRG9tID0gbmV3RG9tLm5leHRTaWJsaW5nO1xuXHR9XG5cblx0cmV0dXJuIG9sZERvbTtcbn1cbiIsImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ2hyZWYnICYmXG5cdFx0XHRuYW1lICE9PSAnbGlzdCcgJiZcblx0XHRcdG5hbWUgIT09ICdmb3JtJyAmJlxuXHRcdFx0Ly8gRGVmYXVsdCB2YWx1ZSBpbiBicm93c2VycyBpcyBgLTFgIGFuZCBhbiBlbXB0eSBzdHJpbmcgaXNcblx0XHRcdC8vIGNhc3QgdG8gYDBgIGluc3RlYWRcblx0XHRcdG5hbWUgIT09ICd0YWJJbmRleCcgJiZcblx0XHRcdG5hbWUgIT09ICdkb3dubG9hZCcgJiZcblx0XHRcdG5hbWUgaW4gZG9tXG5cdFx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0XHRcdFx0Ly8gbGFiZWxsZWQgYnJlYWsgaXMgMWIgc21hbGxlciBoZXJlIHRoYW4gYSByZXR1cm4gc3RhdGVtZW50IChzb3JyeSlcblx0XHRcdFx0YnJlYWsgbztcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0Ly8gZXhpc3Rpbmcgb24gdGhlIERPTSwgc28gd2UgY2FuJ3QgcmVtb3ZlIGl0LiBGb3Igbm9uLWJvb2xlYW5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0Ly8gdGhhdCBvdGhlciBWRE9NIGZyYW1ld29ya3MgYWxzbyBhbHdheXMgc3RyaW5naWZ5IGBmYWxzZWAuXG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBuZXZlciBzZXJpYWxpemUgZnVuY3Rpb25zIGFzIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0dmFsdWUgIT0gbnVsbCAmJlxuXHRcdFx0KHZhbHVlICE9PSBmYWxzZSB8fCAobmFtZVswXSA9PT0gJ2EnICYmIG5hbWVbMV0gPT09ICdyJykpXG5cdFx0KSB7XG5cdFx0XHRkb20uc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBQcm94eSBhbiBldmVudCB0byBob29rZWQgZXZlbnQgaGFuZGxlcnNcbiAqIEBwYXJhbSB7RXZlbnR9IGUgVGhlIGV2ZW50IG9iamVjdCBmcm9tIHRoZSBicm93c2VyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBldmVudFByb3h5KGUpIHtcblx0dGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIGZhbHNlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuXG5mdW5jdGlvbiBldmVudFByb3h5Q2FwdHVyZShlKSB7XG5cdHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyB0cnVlXShvcHRpb25zLmV2ZW50ID8gb3B0aW9ucy5ldmVudChlKSA6IGUpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi4vY29uc3RhbnRzJztcbmltcG9ydCB7IENvbXBvbmVudCwgZ2V0RG9tU2libGluZyB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4uL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCB7IGRpZmZDaGlsZHJlbiB9IGZyb20gJy4vY2hpbGRyZW4nO1xuaW1wb3J0IHsgZGlmZlByb3BzLCBzZXRQcm9wZXJ0eSB9IGZyb20gJy4vcHJvcHMnO1xuaW1wb3J0IHsgYXNzaWduLCByZW1vdmVOb2RlLCBzbGljZSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyBhbmQgYXBwbHkgcHJvcGVyIGNoYW5nZXMgdG8gdGhlIERPTVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBwYXJlbnQgb2YgdGhlIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRWTm9kZSBUaGUgb2xkIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QuIE1vZGlmaWVkIGJ5IGdldENoaWxkQ29udGV4dFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIGVsZW1lbnQgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQ+fSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gb2xkRG9tIFRoZSBjdXJyZW50IGF0dGFjaGVkIERPTVxuICogZWxlbWVudCBhbnkgbmV3IGRvbSBlbGVtZW50cyBzaG91bGQgYmUgcGxhY2VkIGFyb3VuZC4gTGlrZWx5IGBudWxsYCBvbiBmaXJzdFxuICogcmVuZGVyIChleGNlcHQgd2hlbiBoeWRyYXRpbmcpLiBDYW4gYmUgYSBzaWJsaW5nIERPTSBlbGVtZW50IHdoZW4gZGlmZmluZ1xuICogRnJhZ21lbnRzIHRoYXQgaGF2ZSBzaWJsaW5ncy4gSW4gbW9zdCBjYXNlcywgaXQgc3RhcnRzIG91dCBhcyBgb2xkQ2hpbGRyZW5bMF0uX2RvbWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0h5ZHJhdGluZ10gV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZihcblx0cGFyZW50RG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdG9sZERvbSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgdG1wLFxuXHRcdG5ld1R5cGUgPSBuZXdWTm9kZS50eXBlO1xuXG5cdC8vIFdoZW4gcGFzc2luZyB0aHJvdWdoIGNyZWF0ZUVsZW1lbnQgaXQgYXNzaWducyB0aGUgb2JqZWN0XG5cdC8vIGNvbnN0cnVjdG9yIGFzIHVuZGVmaW5lZC4gVGhpcyB0byBwcmV2ZW50IEpTT04taW5qZWN0aW9uLlxuXHRpZiAobmV3Vk5vZGUuY29uc3RydWN0b3IgIT09IHVuZGVmaW5lZCkgcmV0dXJuIG51bGw7XG5cblx0Ly8gSWYgdGhlIHByZXZpb3VzIGRpZmYgYmFpbGVkIG91dCwgcmVzdW1lIGNyZWF0aW5nL2h5ZHJhdGluZy5cblx0aWYgKG9sZFZOb2RlLl9oeWRyYXRpbmcgIT0gbnVsbCkge1xuXHRcdGlzSHlkcmF0aW5nID0gb2xkVk5vZGUuX2h5ZHJhdGluZztcblx0XHRvbGREb20gPSBuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHQvLyBpZiB3ZSByZXN1bWUsIHdlIHdhbnQgdGhlIHRyZWUgdG8gYmUgXCJ1bmxvY2tlZFwiXG5cdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBbb2xkRG9tXTtcblx0fVxuXG5cdGlmICgodG1wID0gb3B0aW9ucy5fZGlmZikpIHRtcChuZXdWTm9kZSk7XG5cblx0dHJ5IHtcblx0XHRvdXRlcjogaWYgKHR5cGVvZiBuZXdUeXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGxldCBjLCBpc05ldywgb2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCwgY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uO1xuXHRcdFx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cblx0XHRcdC8vIE5lY2Vzc2FyeSBmb3IgY3JlYXRlQ29udGV4dCBhcGkuIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSB3aWxsIHBhc3Ncblx0XHRcdC8vIHRoZSBjb250ZXh0IHZhbHVlIGFzIGB0aGlzLmNvbnRleHRgIGp1c3QgZm9yIHRoaXMgY29tcG9uZW50LlxuXHRcdFx0dG1wID0gbmV3VHlwZS5jb250ZXh0VHlwZTtcblx0XHRcdGxldCBwcm92aWRlciA9IHRtcCAmJiBnbG9iYWxDb250ZXh0W3RtcC5faWRdO1xuXHRcdFx0bGV0IGNvbXBvbmVudENvbnRleHQgPSB0bXBcblx0XHRcdFx0PyBwcm92aWRlclxuXHRcdFx0XHRcdD8gcHJvdmlkZXIucHJvcHMudmFsdWVcblx0XHRcdFx0XHQ6IHRtcC5fZGVmYXVsdFZhbHVlXG5cdFx0XHRcdDogZ2xvYmFsQ29udGV4dDtcblxuXHRcdFx0Ly8gR2V0IGNvbXBvbmVudCBhbmQgc2V0IGl0IHRvIGBjYFxuXHRcdFx0aWYgKG9sZFZOb2RlLl9jb21wb25lbnQpIHtcblx0XHRcdFx0YyA9IG5ld1ZOb2RlLl9jb21wb25lbnQgPSBvbGRWTm9kZS5fY29tcG9uZW50O1xuXHRcdFx0XHRjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcGVuZGluZ0Vycm9yO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSW5zdGFudGlhdGUgdGhlIG5ldyBjb21wb25lbnRcblx0XHRcdFx0aWYgKCdwcm90b3R5cGUnIGluIG5ld1R5cGUgJiYgbmV3VHlwZS5wcm90b3R5cGUucmVuZGVyKSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBUaGUgY2hlY2sgYWJvdmUgdmVyaWZpZXMgdGhhdCBuZXdUeXBlIGlzIHN1cHBvc2UgdG8gYmUgY29uc3RydWN0ZWRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBuZXdUeXBlKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBUcnVzdCBtZSwgQ29tcG9uZW50IGltcGxlbWVudHMgdGhlIGludGVyZmFjZSB3ZSB3YW50XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgQ29tcG9uZW50KG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0XHRjLmNvbnN0cnVjdG9yID0gbmV3VHlwZTtcblx0XHRcdFx0XHRjLnJlbmRlciA9IGRvUmVuZGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwcm92aWRlcikgcHJvdmlkZXIuc3ViKGMpO1xuXG5cdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0aWYgKCFjLnN0YXRlKSBjLnN0YXRlID0ge307XG5cdFx0XHRcdGMuY29udGV4dCA9IGNvbXBvbmVudENvbnRleHQ7XG5cdFx0XHRcdGMuX2dsb2JhbENvbnRleHQgPSBnbG9iYWxDb250ZXh0O1xuXHRcdFx0XHRpc05ldyA9IGMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHR9XG5cblx0XHRcdC8vIEludm9rZSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNcblx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gbnVsbCkge1xuXHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBjLnN0YXRlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9IG51bGwpIHtcblx0XHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBjLnN0YXRlKSB7XG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCBjLl9uZXh0U3RhdGUpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0YXNzaWduKFxuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXdQcm9wcywgYy5fbmV4dFN0YXRlKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRvbGRQcm9wcyA9IGMucHJvcHM7XG5cdFx0XHRvbGRTdGF0ZSA9IGMuc3RhdGU7XG5cblx0XHRcdC8vIEludm9rZSBwcmUtcmVuZGVyIGxpZmVjeWNsZSBtZXRob2RzXG5cdFx0XHRpZiAoaXNOZXcpIHtcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09IG51bGwgJiZcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoYy5jb21wb25lbnREaWRNb3VudCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goYy5jb21wb25lbnREaWRNb3VudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0bmV3UHJvcHMgIT09IG9sZFByb3BzICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICE9IG51bGxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQoIWMuX2ZvcmNlICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPSBudWxsICYmXG5cdFx0XHRcdFx0XHRjLnNob3VsZENvbXBvbmVudFVwZGF0ZShcblx0XHRcdFx0XHRcdFx0bmV3UHJvcHMsXG5cdFx0XHRcdFx0XHRcdGMuX25leHRTdGF0ZSxcblx0XHRcdFx0XHRcdFx0Y29tcG9uZW50Q29udGV4dFxuXHRcdFx0XHRcdFx0KSA9PT0gZmFsc2UpIHx8XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRcdGMuc3RhdGUgPSBjLl9uZXh0U3RhdGU7XG5cdFx0XHRcdFx0Ly8gTW9yZSBpbmZvIGFib3V0IHRoaXMgaGVyZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSm92aURlQ3Jvb2NrL2JlYzVmMmNlOTM1NDRkMmU2MDcwZWY4ZTAwMzZlNGU4XG5cdFx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9vcmlnaW5hbCAhPT0gb2xkVk5vZGUuX29yaWdpbmFsKSBjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbi5mb3JFYWNoKHZub2RlID0+IHtcblx0XHRcdFx0XHRcdGlmICh2bm9kZSkgdm5vZGUuX3BhcmVudCA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRjb21taXRRdWV1ZS5wdXNoKGMpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50V2lsbFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MucHVzaCgoKSA9PiB7XG5cdFx0XHRcdFx0XHRjLmNvbXBvbmVudERpZFVwZGF0ZShvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0Yy5fdm5vZGUgPSBuZXdWTm9kZTtcblx0XHRcdGMuX3BhcmVudERvbSA9IHBhcmVudERvbTtcblxuXHRcdFx0bGV0IHJlbmRlckhvb2sgPSBvcHRpb25zLl9yZW5kZXIsXG5cdFx0XHRcdGNvdW50ID0gMDtcblx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXG5cdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHR0bXAgPSBjLnJlbmRlcihjLnByb3BzLCBjLnN0YXRlLCBjLmNvbnRleHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0XHRcdFx0aWYgKHJlbmRlckhvb2spIHJlbmRlckhvb2sobmV3Vk5vZGUpO1xuXG5cdFx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBzZXRTdGF0ZSBjYWxsZWQgaW4gcmVuZGVyLCBzZWUgIzI1NTNcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHR9IHdoaWxlIChjLl9kaXJ0eSAmJiArK2NvdW50IDwgMjUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXG5cdFx0XHRpZiAoYy5nZXRDaGlsZENvbnRleHQgIT0gbnVsbCkge1xuXHRcdFx0XHRnbG9iYWxDb250ZXh0ID0gYXNzaWduKGFzc2lnbih7fSwgZ2xvYmFsQ29udGV4dCksIGMuZ2V0Q2hpbGRDb250ZXh0KCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWlzTmV3ICYmIGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRzbmFwc2hvdCA9IGMuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IGlzVG9wTGV2ZWxGcmFnbWVudCA9XG5cdFx0XHRcdHRtcCAhPSBudWxsICYmIHRtcC50eXBlID09PSBGcmFnbWVudCAmJiB0bXAua2V5ID09IG51bGw7XG5cdFx0XHRsZXQgcmVuZGVyUmVzdWx0ID0gaXNUb3BMZXZlbEZyYWdtZW50ID8gdG1wLnByb3BzLmNoaWxkcmVuIDogdG1wO1xuXG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShyZW5kZXJSZXN1bHQpID8gcmVuZGVyUmVzdWx0IDogW3JlbmRlclJlc3VsdF0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0b2xkRG9tLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Yy5iYXNlID0gbmV3Vk5vZGUuX2RvbTtcblxuXHRcdFx0Ly8gV2Ugc3VjY2Vzc2Z1bGx5IHJlbmRlcmVkIHRoaXMgVk5vZGUsIHVuc2V0IGFueSBzdG9yZWQgaHlkcmF0aW9uL2JhaWxvdXQgc3RhdGU6XG5cdFx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRcdFx0aWYgKGMuX3JlbmRlckNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0XHRjLl9wZW5kaW5nRXJyb3IgPSBjLl9wcm9jZXNzaW5nRXhjZXB0aW9uID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Yy5fZm9yY2UgPSBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPT0gbnVsbCAmJlxuXHRcdFx0bmV3Vk5vZGUuX29yaWdpbmFsID09PSBvbGRWTm9kZS5fb3JpZ2luYWxcblx0XHQpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gZGlmZkVsZW1lbnROb2Rlcyhcblx0XHRcdFx0b2xkVk5vZGUuX2RvbSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2Zyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoKHRtcCA9IG9wdGlvbnMuZGlmZmVkKSkgdG1wKG5ld1ZOb2RlKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0Ly8gaWYgaHlkcmF0aW5nIG9yIGNyZWF0aW5nIGluaXRpYWwgdHJlZSwgYmFpbG91dCBwcmVzZXJ2ZXMgRE9NOlxuXHRcdGlmIChpc0h5ZHJhdGluZyB8fCBleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkRG9tO1xuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9ICEhaXNIeWRyYXRpbmc7XG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbltleGNlc3NEb21DaGlsZHJlbi5pbmRleE9mKG9sZERvbSldID0gbnVsbDtcblx0XHRcdC8vIF4gY291bGQgcG9zc2libHkgYmUgc2ltcGxpZmllZCB0bzpcblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aCA9IDA7XG5cdFx0fVxuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgbmV3Vk5vZGUsIG9sZFZOb2RlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSByb290XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb21taXRSb290KGNvbW1pdFF1ZXVlLCByb290KSB7XG5cdGlmIChvcHRpb25zLl9jb21taXQpIG9wdGlvbnMuX2NvbW1pdChyb290LCBjb21taXRRdWV1ZSk7XG5cblx0Y29tbWl0UXVldWUuc29tZShjID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBSZXVzZSB0aGUgY29tbWl0UXVldWUgdmFyaWFibGUgaGVyZSBzbyB0aGUgdHlwZSBjaGFuZ2VzXG5cdFx0XHRjb21taXRRdWV1ZSA9IGMuX3JlbmRlckNhbGxiYWNrcztcblx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0Y29tbWl0UXVldWUuc29tZShjYiA9PiB7XG5cdFx0XHRcdC8vIEB0cy1pZ25vcmUgU2VlIGFib3ZlIHRzLWlnbm9yZSBvbiBjb21taXRRdWV1ZVxuXHRcdFx0XHRjYi5jYWxsKGMpO1xuXHRcdFx0fSk7XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjLl92bm9kZSk7XG5cdFx0fVxuXHR9KTtcbn1cblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIHJlcHJlc2VudGluZyBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gZWxlbWVudCByZXByZXNlbnRpbmdcbiAqIHRoZSB2aXJ0dWFsIG5vZGVzIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7Kn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fVxuICovXG5mdW5jdGlvbiBkaWZmRWxlbWVudE5vZGVzKFxuXHRkb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0aXNIeWRyYXRpbmdcbikge1xuXHRsZXQgb2xkUHJvcHMgPSBvbGRWTm9kZS5wcm9wcztcblx0bGV0IG5ld1Byb3BzID0gbmV3Vk5vZGUucHJvcHM7XG5cdGxldCBub2RlVHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cdGxldCBpID0gMDtcblxuXHQvLyBUcmFja3MgZW50ZXJpbmcgYW5kIGV4aXRpbmcgU1ZHIG5hbWVzcGFjZSB3aGVuIGRlc2NlbmRpbmcgdGhyb3VnaCB0aGUgdHJlZS5cblx0aWYgKG5vZGVUeXBlID09PSAnc3ZnJykgaXNTdmcgPSB0cnVlO1xuXG5cdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0Zm9yICg7IGkgPCBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgY2hpbGQgPSBleGNlc3NEb21DaGlsZHJlbltpXTtcblxuXHRcdFx0Ly8gaWYgbmV3Vk5vZGUgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuIG9yIHRoZSBgZG9tYFxuXHRcdFx0Ly8gYXJndW1lbnQgbWF0Y2hlcyBhbiBlbGVtZW50IGluIGV4Y2Vzc0RvbUNoaWxkcmVuLCByZW1vdmUgaXQgZnJvbVxuXHRcdFx0Ly8gZXhjZXNzRG9tQ2hpbGRyZW4gc28gaXQgaXNuJ3QgbGF0ZXIgcmVtb3ZlZCBpbiBkaWZmQ2hpbGRyZW5cblx0XHRcdGlmIChcblx0XHRcdFx0Y2hpbGQgJiZcblx0XHRcdFx0J3NldEF0dHJpYnV0ZScgaW4gY2hpbGQgPT09ICEhbm9kZVR5cGUgJiZcblx0XHRcdFx0KG5vZGVUeXBlID8gY2hpbGQubG9jYWxOYW1lID09PSBub2RlVHlwZSA6IGNoaWxkLm5vZGVUeXBlID09PSAzKVxuXHRcdFx0KSB7XG5cdFx0XHRcdGRvbSA9IGNoaWxkO1xuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbltpXSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmIChkb20gPT0gbnVsbCkge1xuXHRcdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdFx0Ly8gQHRzLWlnbm9yZSBjcmVhdGVUZXh0Tm9kZSByZXR1cm5zIFRleHQsIHdlIGV4cGVjdCBQcmVhY3RFbGVtZW50XG5cdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3UHJvcHMpO1xuXHRcdH1cblxuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFxuXHRcdFx0XHQnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFdlIGtub3cgYG5ld1ZOb2RlLnR5cGVgIGlzIGEgc3RyaW5nXG5cdFx0XHRcdG5vZGVUeXBlLFxuXHRcdFx0XHRuZXdQcm9wcy5pcyAmJiBuZXdQcm9wc1xuXHRcdFx0KTtcblx0XHR9XG5cblx0XHQvLyB3ZSBjcmVhdGVkIGEgbmV3IHBhcmVudCwgc28gbm9uZSBvZiB0aGUgcHJldmlvdXNseSBhdHRhY2hlZCBjaGlsZHJlbiBjYW4gYmUgcmV1c2VkOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gbnVsbDtcblx0XHQvLyB3ZSBhcmUgY3JlYXRpbmcgYSBuZXcgbm9kZSwgc28gd2UgY2FuIGFzc3VtZSB0aGlzIGlzIGEgbmV3IHN1YnRyZWUgKGluIGNhc2Ugd2UgYXJlIGh5ZHJhdGluZyksIHRoaXMgZGVvcHRzIHRoZSBoeWRyYXRlXG5cdFx0aXNIeWRyYXRpbmcgPSBmYWxzZTtcblx0fVxuXG5cdGlmIChub2RlVHlwZSA9PT0gbnVsbCkge1xuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHdlIHN0aWxsIGhhdmUgdG8gc3BsaXQgbWVyZ2VkIHRleHQgZnJvbSBTU1InZCBIVE1MLlxuXHRcdGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgJiYgKCFpc0h5ZHJhdGluZyB8fCBkb20uZGF0YSAhPT0gbmV3UHJvcHMpKSB7XG5cdFx0XHRkb20uZGF0YSA9IG5ld1Byb3BzO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBJZiBleGNlc3NEb21DaGlsZHJlbiB3YXMgbm90IG51bGwsIHJlcG9wdWxhdGUgaXQgd2l0aCB0aGUgY3VycmVudCBlbGVtZW50J3MgY2hpbGRyZW46XG5cdFx0ZXhjZXNzRG9tQ2hpbGRyZW4gPSBleGNlc3NEb21DaGlsZHJlbiAmJiBzbGljZS5jYWxsKGRvbS5jaGlsZE5vZGVzKTtcblxuXHRcdG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHMgfHwgRU1QVFlfT0JKO1xuXG5cdFx0bGV0IG9sZEh0bWwgPSBvbGRQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblx0XHRsZXQgbmV3SHRtbCA9IG5ld1Byb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuXG5cdFx0Ly8gRHVyaW5nIGh5ZHJhdGlvbiwgcHJvcHMgYXJlIG5vdCBkaWZmZWQgYXQgYWxsIChpbmNsdWRpbmcgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwpXG5cdFx0Ly8gQFRPRE8gd2Ugc2hvdWxkIHdhcm4gaW4gZGVidWcgbW9kZSB3aGVuIHByb3BzIGRvbid0IG1hdGNoIGhlcmUuXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0Ly8gQnV0LCBpZiB3ZSBhcmUgaW4gYSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIHVzaW5nIGV4aXN0aW5nIERPTSAoZS5nLiByZXBsYWNlTm9kZSlcblx0XHRcdC8vIHdlIHNob3VsZCByZWFkIHRoZSBleGlzdGluZyBET00gYXR0cmlidXRlcyB0byBkaWZmIHRoZW1cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdG9sZFByb3BzID0ge307XG5cdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBkb20uYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdG9sZFByb3BzW2RvbS5hdHRyaWJ1dGVzW2ldLm5hbWVdID0gZG9tLmF0dHJpYnV0ZXNbaV0udmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKG5ld0h0bWwgfHwgb2xkSHRtbCkge1xuXHRcdFx0XHQvLyBBdm9pZCByZS1hcHBseWluZyB0aGUgc2FtZSAnX19odG1sJyBpZiBpdCBkaWQgbm90IGNoYW5nZWQgYmV0d2VlbiByZS1yZW5kZXJcblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdCFuZXdIdG1sIHx8XG5cdFx0XHRcdFx0KCghb2xkSHRtbCB8fCBuZXdIdG1sLl9faHRtbCAhPSBvbGRIdG1sLl9faHRtbCkgJiZcblx0XHRcdFx0XHRcdG5ld0h0bWwuX19odG1sICE9PSBkb20uaW5uZXJIVE1MKVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRkb20uaW5uZXJIVE1MID0gKG5ld0h0bWwgJiYgbmV3SHRtbC5fX2h0bWwpIHx8ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaXNIeWRyYXRpbmcpO1xuXG5cdFx0Ly8gSWYgdGhlIG5ldyB2bm9kZSBkaWRuJ3QgaGF2ZSBkYW5nZXJvdXNseVNldElubmVySFRNTCwgZGlmZiBpdHMgY2hpbGRyZW5cblx0XHRpZiAobmV3SHRtbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gW107XG5cdFx0fSBlbHNlIHtcblx0XHRcdGkgPSBuZXdWTm9kZS5wcm9wcy5jaGlsZHJlbjtcblx0XHRcdGRpZmZDaGlsZHJlbihcblx0XHRcdFx0ZG9tLFxuXHRcdFx0XHRBcnJheS5pc0FycmF5KGkpID8gaSA6IFtpXSxcblx0XHRcdFx0bmV3Vk5vZGUsXG5cdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0XHRpc1N2ZyAmJiBub2RlVHlwZSAhPT0gJ2ZvcmVpZ25PYmplY3QnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuXG5cdFx0XHRcdFx0PyBleGNlc3NEb21DaGlsZHJlblswXVxuXHRcdFx0XHRcdDogb2xkVk5vZGUuX2NoaWxkcmVuICYmIGdldERvbVNpYmxpbmcob2xkVk5vZGUsIDApLFxuXHRcdFx0XHRpc0h5ZHJhdGluZ1xuXHRcdFx0KTtcblxuXHRcdFx0Ly8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIGFueSB2bm9kZS5cblx0XHRcdGlmIChleGNlc3NEb21DaGlsZHJlbiAhPSBudWxsKSB7XG5cdFx0XHRcdGZvciAoaSA9IGV4Y2Vzc0RvbUNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHRcdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW5baV0gIT0gbnVsbCkgcmVtb3ZlTm9kZShleGNlc3NEb21DaGlsZHJlbltpXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyAoYXMgYWJvdmUsIGRvbid0IGRpZmYgcHJvcHMgZHVyaW5nIGh5ZHJhdGlvbilcblx0XHRpZiAoIWlzSHlkcmF0aW5nKSB7XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCd2YWx1ZScgaW4gbmV3UHJvcHMgJiZcblx0XHRcdFx0KGkgPSBuZXdQcm9wcy52YWx1ZSkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHQvLyAjMjc1NiBGb3IgdGhlIDxwcm9ncmVzcz4tZWxlbWVudCB0aGUgaW5pdGlhbCB2YWx1ZSBpcyAwLFxuXHRcdFx0XHQvLyBkZXNwaXRlIHRoZSBhdHRyaWJ1dGUgbm90IGJlaW5nIHByZXNlbnQuIFdoZW4gdGhlIGF0dHJpYnV0ZVxuXHRcdFx0XHQvLyBpcyBtaXNzaW5nIHRoZSBwcm9ncmVzcyBiYXIgaXMgdHJlYXRlZCBhcyBpbmRldGVybWluYXRlLlxuXHRcdFx0XHQvLyBUbyBmaXggdGhhdCB3ZSdsbCBhbHdheXMgdXBkYXRlIGl0IHdoZW4gaXQgaXMgMCBmb3IgcHJvZ3Jlc3MgZWxlbWVudHNcblx0XHRcdFx0KGkgIT09IGRvbS52YWx1ZSB8fFxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ3Byb2dyZXNzJyAmJiAhaSkgfHxcblx0XHRcdFx0XHQvLyBUaGlzIGlzIG9ubHkgZm9yIElFIDExIHRvIGZpeCA8c2VsZWN0PiB2YWx1ZSBub3QgYmVpbmcgdXBkYXRlZC5cblx0XHRcdFx0XHQvLyBUbyBhdm9pZCBhIHN0YWxlIHNlbGVjdCB2YWx1ZSB3ZSBuZWVkIHRvIHNldCB0aGUgb3B0aW9uLnZhbHVlXG5cdFx0XHRcdFx0Ly8gYWdhaW4sIHdoaWNoIHRyaWdnZXJzIElFMTEgdG8gcmUtZXZhbHVhdGUgdGhlIHNlbGVjdCB2YWx1ZVxuXHRcdFx0XHRcdChub2RlVHlwZSA9PT0gJ29wdGlvbicgJiYgaSAhPT0gb2xkUHJvcHMudmFsdWUpKVxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ3ZhbHVlJywgaSwgb2xkUHJvcHMudmFsdWUsIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdGlmIChcblx0XHRcdFx0J2NoZWNrZWQnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMuY2hlY2tlZCkgIT09IHVuZGVmaW5lZCAmJlxuXHRcdFx0XHRpICE9PSBkb20uY2hlY2tlZFxuXHRcdFx0KSB7XG5cdFx0XHRcdHNldFByb3BlcnR5KGRvbSwgJ2NoZWNrZWQnLCBpLCBvbGRQcm9wcy5jaGVja2VkLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGRvbTtcbn1cblxuLyoqXG4gKiBJbnZva2Ugb3IgdXBkYXRlIGEgcmVmLCBkZXBlbmRpbmcgb24gd2hldGhlciBpdCBpcyBhIGZ1bmN0aW9uIG9yIG9iamVjdCByZWYuXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcmVmXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlSZWYocmVmLCB2YWx1ZSwgdm5vZGUpIHtcblx0dHJ5IHtcblx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSByZWYodmFsdWUpO1xuXHRcdGVsc2UgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgdm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVW5tb3VudCBhIHZpcnR1YWwgbm9kZSBmcm9tIHRoZSB0cmVlIGFuZCBhcHBseSBET00gY2hhbmdlc1xuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gdW5tb3VudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHBhcmVudFZOb2RlIFRoZSBwYXJlbnQgb2YgdGhlIFZOb2RlIHRoYXRcbiAqIGluaXRpYXRlZCB0aGUgdW5tb3VudFxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcFJlbW92ZV0gRmxhZyB0aGF0IGluZGljYXRlcyB0aGF0IGEgcGFyZW50IG5vZGUgb2YgdGhlXG4gKiBjdXJyZW50IGVsZW1lbnQgaXMgYWxyZWFkeSBkZXRhY2hlZCBmcm9tIHRoZSBET00uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bm1vdW50KHZub2RlLCBwYXJlbnRWTm9kZSwgc2tpcFJlbW92ZSkge1xuXHRsZXQgcjtcblx0aWYgKG9wdGlvbnMudW5tb3VudCkgb3B0aW9ucy51bm1vdW50KHZub2RlKTtcblxuXHRpZiAoKHIgPSB2bm9kZS5yZWYpKSB7XG5cdFx0aWYgKCFyLmN1cnJlbnQgfHwgci5jdXJyZW50ID09PSB2bm9kZS5fZG9tKSBhcHBseVJlZihyLCBudWxsLCBwYXJlbnRWTm9kZSk7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY29tcG9uZW50KSAhPSBudWxsKSB7XG5cdFx0aWYgKHIuY29tcG9uZW50V2lsbFVubW91bnQpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHIuY29tcG9uZW50V2lsbFVubW91bnQoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBwYXJlbnRWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ci5iYXNlID0gci5fcGFyZW50RG9tID0gbnVsbDtcblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jaGlsZHJlbikpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHIubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChyW2ldKSB7XG5cdFx0XHRcdHVubW91bnQocltpXSwgcGFyZW50Vk5vZGUsIHR5cGVvZiB2bm9kZS50eXBlICE9ICdmdW5jdGlvbicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICghc2tpcFJlbW92ZSAmJiB2bm9kZS5fZG9tICE9IG51bGwpIHJlbW92ZU5vZGUodm5vZGUuX2RvbSk7XG5cblx0Ly8gTXVzdCBiZSBzZXQgdG8gYHVuZGVmaW5lZGAgdG8gcHJvcGVybHkgY2xlYW4gdXAgYF9uZXh0RG9tYFxuXHQvLyBmb3Igd2hpY2ggYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUuIFNlZSBjb21tZW50IGluIGBjcmVhdGUtZWxlbWVudC5qc2Bcblx0dm5vZGUuX2RvbSA9IHZub2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xufVxuXG4vKiogVGhlIGAucmVuZGVyKClgIG1ldGhvZCBmb3IgYSBQRkMgYmFja2luZyBpbnN0YW5jZS4gKi9cbmZ1bmN0aW9uIGRvUmVuZGVyKHByb3BzLCBzdGF0ZSwgY29udGV4dCkge1xuXHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvcihwcm9wcywgY29udGV4dCk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBjb21taXRSb290LCBkaWZmIH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIFJlbmRlciBhIFByZWFjdCB2aXJ0dWFsIG5vZGUgaW50byBhIERPTSBlbGVtZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiByZW5kZXIgaW50b1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50IHwgb2JqZWN0fSBbcmVwbGFjZU5vZGVdIE9wdGlvbmFsOiBBdHRlbXB0IHRvIHJlLXVzZSBhblxuICogZXhpc3RpbmcgRE9NIHRyZWUgcm9vdGVkIGF0IGByZXBsYWNlTm9kZWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCByZXBsYWNlTm9kZSkge1xuXHRpZiAob3B0aW9ucy5fcm9vdCkgb3B0aW9ucy5fcm9vdCh2bm9kZSwgcGFyZW50RG9tKTtcblxuXHQvLyBXZSBhYnVzZSB0aGUgYHJlcGxhY2VOb2RlYCBwYXJhbWV0ZXIgaW4gYGh5ZHJhdGUoKWAgdG8gc2lnbmFsIGlmIHdlIGFyZSBpblxuXHQvLyBoeWRyYXRpb24gbW9kZSBvciBub3QgYnkgcGFzc2luZyB0aGUgYGh5ZHJhdGVgIGZ1bmN0aW9uIGluc3RlYWQgb2YgYSBET01cblx0Ly8gZWxlbWVudC4uXG5cdGxldCBpc0h5ZHJhdGluZyA9IHR5cGVvZiByZXBsYWNlTm9kZSA9PT0gJ2Z1bmN0aW9uJztcblxuXHQvLyBUbyBiZSBhYmxlIHRvIHN1cHBvcnQgY2FsbGluZyBgcmVuZGVyKClgIG11bHRpcGxlIHRpbWVzIG9uIHRoZSBzYW1lXG5cdC8vIERPTSBub2RlLCB3ZSBuZWVkIHRvIG9idGFpbiBhIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXMgdHJlZS4gV2UgZG9cblx0Ly8gdGhpcyBieSBhc3NpZ25pbmcgYSBuZXcgYF9jaGlsZHJlbmAgcHJvcGVydHkgdG8gRE9NIG5vZGVzIHdoaWNoIHBvaW50c1xuXHQvLyB0byB0aGUgbGFzdCByZW5kZXJlZCB0cmVlLiBCeSBkZWZhdWx0IHRoaXMgcHJvcGVydHkgaXMgbm90IHByZXNlbnQsIHdoaWNoXG5cdC8vIG1lYW5zIHRoYXQgd2UgYXJlIG1vdW50aW5nIGEgbmV3IHRyZWUgZm9yIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgb2xkVk5vZGUgPSBpc0h5ZHJhdGluZ1xuXHRcdD8gbnVsbFxuXHRcdDogKHJlcGxhY2VOb2RlICYmIHJlcGxhY2VOb2RlLl9jaGlsZHJlbikgfHwgcGFyZW50RG9tLl9jaGlsZHJlbjtcblxuXHR2bm9kZSA9IChcblx0XHQoIWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlKSB8fFxuXHRcdHBhcmVudERvbVxuXHQpLl9jaGlsZHJlbiA9IGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIFt2bm9kZV0pO1xuXG5cdC8vIExpc3Qgb2YgZWZmZWN0cyB0aGF0IG5lZWQgdG8gYmUgY2FsbGVkIGFmdGVyIGRpZmZpbmcuXG5cdGxldCBjb21taXRRdWV1ZSA9IFtdO1xuXHRkaWZmKFxuXHRcdHBhcmVudERvbSxcblx0XHQvLyBEZXRlcm1pbmUgdGhlIG5ldyB2bm9kZSB0cmVlIGFuZCBzdG9yZSBpdCBvbiB0aGUgRE9NIGVsZW1lbnQgb25cblx0XHQvLyBvdXIgY3VzdG9tIGBfY2hpbGRyZW5gIHByb3BlcnR5LlxuXHRcdHZub2RlLFxuXHRcdG9sZFZOb2RlIHx8IEVNUFRZX09CSixcblx0XHRFTVBUWV9PQkosXG5cdFx0cGFyZW50RG9tLm93bmVyU1ZHRWxlbWVudCAhPT0gdW5kZWZpbmVkLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyBbcmVwbGFjZU5vZGVdXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGRcblx0XHRcdD8gc2xpY2UuY2FsbChwYXJlbnREb20uY2hpbGROb2Rlcylcblx0XHRcdDogbnVsbCxcblx0XHRjb21taXRRdWV1ZSxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gcmVwbGFjZU5vZGVcblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gb2xkVk5vZGUuX2RvbVxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZCxcblx0XHRpc0h5ZHJhdGluZ1xuXHQpO1xuXG5cdC8vIEZsdXNoIGFsbCBxdWV1ZWQgZWZmZWN0c1xuXHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIGFuIGV4aXN0aW5nIERPTSBlbGVtZW50IHdpdGggZGF0YSBmcm9tIGEgUHJlYWN0IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogdXBkYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnREb20pIHtcblx0cmVuZGVyKHZub2RlLCBwYXJlbnREb20sIGh5ZHJhdGUpO1xufVxuIiwiLyoqXG4gKiBGaW5kIHRoZSBjbG9zZXN0IGVycm9yIGJvdW5kYXJ5IHRvIGEgdGhyb3duIGVycm9yIGFuZCBjYWxsIGl0XG4gKiBAcGFyYW0ge29iamVjdH0gZXJyb3IgVGhlIHRocm93biB2YWx1ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFRoZSB2bm9kZSB0aGF0IHRocmV3XG4gKiB0aGUgZXJyb3IgdGhhdCB3YXMgY2F1Z2h0IChleGNlcHQgZm9yIHVubW91bnRpbmcgd2hlbiB0aGlzIHBhcmFtZXRlclxuICogaXMgdGhlIGhpZ2hlc3QgcGFyZW50IHRoYXQgd2FzIGJlaW5nIHVubW91bnRlZClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBbb2xkVk5vZGVdXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5FcnJvckluZm99IFtlcnJvckluZm9dXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2hFcnJvcihlcnJvciwgdm5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50LCBjdG9yLCBoYW5kbGVkO1xuXG5cdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiAhY29tcG9uZW50Ll9wcm9jZXNzaW5nRXhjZXB0aW9uKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRjdG9yID0gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xuXG5cdFx0XHRcdGlmIChjdG9yICYmIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2V0U3RhdGUoY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpKTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaChlcnJvciwgZXJyb3JJbmZvIHx8IHt9KTtcblx0XHRcdFx0XHRoYW5kbGVkID0gY29tcG9uZW50Ll9kaXJ0eTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRoaXMgaXMgYW4gZXJyb3IgYm91bmRhcnkuIE1hcmsgaXQgYXMgaGF2aW5nIGJhaWxlZCBvdXQsIGFuZCB3aGV0aGVyIGl0IHdhcyBtaWQtaHlkcmF0aW9uLlxuXHRcdFx0XHRpZiAoaGFuZGxlZCkge1xuXHRcdFx0XHRcdHJldHVybiAoY29tcG9uZW50Ll9wZW5kaW5nRXJyb3IgPSBjb21wb25lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHR0aHJvdyBlcnJvcjtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMsIEZyYWdtZW50IH0gZnJvbSAncHJlYWN0JztcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ3ByZWFjdCcpLlZOb2RlfSBWTm9kZSAqL1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQGZpbGVvdmVydmlld1xuICogVGhpcyBmaWxlIGV4cG9ydHMgdmFyaW91cyBtZXRob2RzIHRoYXQgaW1wbGVtZW50IEJhYmVsJ3MgXCJhdXRvbWF0aWNcIiBKU1ggcnVudGltZSBBUEk6XG4gKiAtIGpzeCh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hzKHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBfX3NvdXJjZSwgX19zZWxmKVxuICpcbiAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiBjcmVhdGVWTm9kZSBoZXJlIGlzIG9wdGltaXplZCBmb3IgcGVyZm9ybWFuY2UuXG4gKiBCZW5jaG1hcmtzOiBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzVmNmI1NGEwYjQ2MzIxMDBhN2RjZDJiM1xuICovXG5cbi8qKlxuICogSlNYLkVsZW1lbnQgZmFjdG9yeSB1c2VkIGJ5IEJhYmVsJ3Mge3J1bnRpbWU6XCJhdXRvbWF0aWNcIn0gSlNYIHRyYW5zZm9ybVxuICogQHBhcmFtIHtWTm9kZVsndHlwZSddfSB0eXBlXG4gKiBAcGFyYW0ge1ZOb2RlWydwcm9wcyddfSBwcm9wc1xuICogQHBhcmFtIHtWTm9kZVsna2V5J119IFtrZXldXG4gKiBAcGFyYW0ge3N0cmluZ30gW19fc2VsZl1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbX19zb3VyY2VdXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVZOb2RlKHR5cGUsIHByb3BzLCBrZXksIF9fc2VsZiwgX19zb3VyY2UpIHtcblx0Ly8gV2UnbGwgd2FudCB0byBwcmVzZXJ2ZSBgcmVmYCBpbiBwcm9wcyB0byBnZXQgcmlkIG9mIHRoZSBuZWVkIGZvclxuXHQvLyBmb3J3YXJkUmVmIGNvbXBvbmVudHMgaW4gdGhlIGZ1dHVyZSwgYnV0IHRoYXQgc2hvdWxkIGhhcHBlbiB2aWFcblx0Ly8gYSBzZXBhcmF0ZSBQUi5cblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAncmVmJykge1xuXHRcdFx0cmVmID0gcHJvcHNbaV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHByb3BzW2ldO1xuXHRcdH1cblx0fVxuXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHM6IG5vcm1hbGl6ZWRQcm9wcyxcblx0XHRrZXksXG5cdFx0cmVmLFxuXHRcdF9jaGlsZHJlbjogbnVsbCxcblx0XHRfcGFyZW50OiBudWxsLFxuXHRcdF9kZXB0aDogMCxcblx0XHRfZG9tOiBudWxsLFxuXHRcdF9uZXh0RG9tOiB1bmRlZmluZWQsXG5cdFx0X2NvbXBvbmVudDogbnVsbCxcblx0XHRfaHlkcmF0aW5nOiBudWxsLFxuXHRcdGNvbnN0cnVjdG9yOiB1bmRlZmluZWQsXG5cdFx0X29yaWdpbmFsOiAtLXZub2RlSWQsXG5cdFx0X19zb3VyY2UsXG5cdFx0X19zZWxmXG5cdH07XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzLlxuXHQvLyBOb3RlOiBgdHlwZWAgaXMgb2Z0ZW4gYSBTdHJpbmcsIGFuZCBjYW4gYmUgYHVuZGVmaW5lZGAgaW4gZGV2ZWxvcG1lbnQuXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyAmJiAocmVmID0gdHlwZS5kZWZhdWx0UHJvcHMpKSB7XG5cdFx0Zm9yIChpIGluIHJlZilcblx0XHRcdGlmICh0eXBlb2Ygbm9ybWFsaXplZFByb3BzW2ldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSByZWZbaV07XG5cdFx0XHR9XG5cdH1cblxuXHRpZiAob3B0aW9ucy52bm9kZSkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cdHJldHVybiB2bm9kZTtcbn1cblxuZXhwb3J0IHtcblx0Y3JlYXRlVk5vZGUgYXMganN4LFxuXHRjcmVhdGVWTm9kZSBhcyBqc3hzLFxuXHRjcmVhdGVWTm9kZSBhcyBqc3hERVYsXG5cdEZyYWdtZW50XG59O1xuIiwiaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xubGV0IGN1cnJlbnRJbmRleDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5sZXQgY3VycmVudENvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5sZXQgcHJldmlvdXNDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xubGV0IGN1cnJlbnRIb29rID0gMDtcblxuLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSAqL1xubGV0IGFmdGVyUGFpbnRFZmZlY3RzID0gW107XG5cbmxldCBFTVBUWSA9IFtdO1xuXG5sZXQgb2xkQmVmb3JlRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5sZXQgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xubGV0IG9sZEFmdGVyRGlmZiA9IG9wdGlvbnMuZGlmZmVkO1xubGV0IG9sZENvbW1pdCA9IG9wdGlvbnMuX2NvbW1pdDtcbmxldCBvbGRCZWZvcmVVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xuXG5jb25zdCBSQUZfVElNRU9VVCA9IDEwMDtcbmxldCBwcmV2UmFmO1xuXG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRjdXJyZW50Q29tcG9uZW50ID0gbnVsbDtcblx0aWYgKG9sZEJlZm9yZURpZmYpIG9sZEJlZm9yZURpZmYodm5vZGUpO1xufTtcblxub3B0aW9ucy5fcmVuZGVyID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSBvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRjdXJyZW50SW5kZXggPSAwO1xuXG5cdGNvbnN0IGhvb2tzID0gY3VycmVudENvbXBvbmVudC5fX2hvb2tzO1xuXHRpZiAoaG9va3MpIHtcblx0XHRpZiAocHJldmlvdXNDb21wb25lbnQgPT09IGN1cnJlbnRDb21wb25lbnQpIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gW107XG5cdFx0XHRob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdFx0XHRob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fVxuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRpZiAoYy5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nQXJncykge1xuXHRcdFx0XHRob29rSXRlbS5fYXJncyA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncztcblx0XHRcdH1cblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ1ZhbHVlICE9PSBFTVBUWSkge1xuXHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdH0pO1xuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGxldCBoYXNFcnJvcmVkO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aW52b2tlQ2xlYW51cChzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFzRXJyb3JlZCA9IGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0aWYgKGhhc0Vycm9yZWQpIG9wdGlvbnMuX2NhdGNoRXJyb3IoaGFzRXJyb3JlZCwgYy5fdm5vZGUpO1xuXHR9XG59O1xuXG4vKipcbiAqIEdldCBhIGhvb2sncyBzdGF0ZSBmcm9tIHRoZSBjdXJyZW50Q29tcG9uZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBob29rIHRvIGdldFxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGUgVGhlIGluZGV4IG9mIHRoZSBob29rIHRvIGdldFxuICogQHJldHVybnMge2FueX1cbiAqL1xuZnVuY3Rpb24gZ2V0SG9va1N0YXRlKGluZGV4LCB0eXBlKSB7XG5cdGlmIChvcHRpb25zLl9ob29rKSB7XG5cdFx0b3B0aW9ucy5faG9vayhjdXJyZW50Q29tcG9uZW50LCBpbmRleCwgY3VycmVudEhvb2sgfHwgdHlwZSk7XG5cdH1cblx0Y3VycmVudEhvb2sgPSAwO1xuXG5cdC8vIExhcmdlbHkgaW5zcGlyZWQgYnk6XG5cdC8vICogaHR0cHM6Ly9naXRodWIuY29tL21pY2hhZWwta2xlaW4vZnVuY3kuanMvYmxvYi9mNmJlNzM0NjhlNmVjNDZiMGZmNWFhM2NjNGM5YmFmNzJhMjkwMjVhL3NyYy9ob29rcy9jb3JlX2hvb2tzLm1qc1xuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvNjUwYmVhYTU4YzQzYzMzYTc0ODIwYTNjOThiM2M3MDc5Y2YyZTMzMy9zcmMvcmVuZGVyZXIubWpzXG5cdC8vIE90aGVyIGltcGxlbWVudGF0aW9ucyB0byBsb29rIGF0OlxuXHQvLyAqIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9tbm94MDVxcDhcblx0Y29uc3QgaG9va3MgPVxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcyB8fFxuXHRcdChjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgPSB7XG5cdFx0XHRfbGlzdDogW10sXG5cdFx0XHRfcGVuZGluZ0VmZmVjdHM6IFtdXG5cdFx0fSk7XG5cblx0aWYgKGluZGV4ID49IGhvb2tzLl9saXN0Lmxlbmd0aCkge1xuXHRcdGhvb2tzLl9saXN0LnB1c2goeyBfcGVuZGluZ1ZhbHVlOiBFTVBUWSB9KTtcblx0fVxuXHRyZXR1cm4gaG9va3MuX2xpc3RbaW5kZXhdO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuU3RhdGVVcGRhdGVyPGFueT59IFtpbml0aWFsU3RhdGVdXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGF0ZShpbml0aWFsU3RhdGUpIHtcblx0Y3VycmVudEhvb2sgPSAxO1xuXHRyZXR1cm4gdXNlUmVkdWNlcihpbnZva2VPclJldHVybiwgaW5pdGlhbFN0YXRlKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlJlZHVjZXI8YW55LCBhbnk+fSByZWR1Y2VyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBpbml0aWFsU3RhdGVcbiAqIEBwYXJhbSB7KGluaXRpYWxTdGF0ZTogYW55KSA9PiB2b2lkfSBbaW5pdF1cbiAqIEByZXR1cm5zIHtbIGFueSwgKHN0YXRlOiBhbnkpID0+IHZvaWQgXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbFN0YXRlLCBpbml0KSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuUmVkdWNlckhvb2tTdGF0ZX0gKi9cblx0Y29uc3QgaG9va1N0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAyKTtcblx0aG9va1N0YXRlLl9yZWR1Y2VyID0gcmVkdWNlcjtcblx0aWYgKCFob29rU3RhdGUuX2NvbXBvbmVudCkge1xuXHRcdGhvb2tTdGF0ZS5fdmFsdWUgPSBbXG5cdFx0XHQhaW5pdCA/IGludm9rZU9yUmV0dXJuKHVuZGVmaW5lZCwgaW5pdGlhbFN0YXRlKSA6IGluaXQoaW5pdGlhbFN0YXRlKSxcblxuXHRcdFx0YWN0aW9uID0+IHtcblx0XHRcdFx0Y29uc3QgbmV4dFZhbHVlID0gaG9va1N0YXRlLl9yZWR1Y2VyKGhvb2tTdGF0ZS5fdmFsdWVbMF0sIGFjdGlvbik7XG5cdFx0XHRcdGlmIChob29rU3RhdGUuX3ZhbHVlWzBdICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX3ZhbHVlID0gW25leHRWYWx1ZSwgaG9va1N0YXRlLl92YWx1ZVsxXV07XG5cdFx0XHRcdFx0aG9va1N0YXRlLl9jb21wb25lbnQuc2V0U3RhdGUoe30pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XTtcblxuXHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnkpID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IGVyciA9PiB7XG5cdFx0XHRpZiAoc3RhdGUuX3ZhbHVlKSBzdGF0ZS5fdmFsdWUoZXJyKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG4vKipcbiAqIEFmdGVyIHBhaW50IGVmZmVjdHMgY29uc3VtZXIuXG4gKi9cbmZ1bmN0aW9uIGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMoKSB7XG5cdGxldCBjb21wb25lbnQ7XG5cdHdoaWxlICgoY29tcG9uZW50ID0gYWZ0ZXJQYWludEVmZmVjdHMuc2hpZnQoKSkpIHtcblx0XHRpZiAoIWNvbXBvbmVudC5fcGFyZW50RG9tKSBjb250aW51ZTtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIGNvbXBvbmVudC5fdm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5sZXQgSEFTX1JBRiA9IHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT0gJ2Z1bmN0aW9uJztcblxuLyoqXG4gKiBTY2hlZHVsZSBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgYWZ0ZXIgdGhlIGJyb3dzZXIgaGFzIGEgY2hhbmNlIHRvIHBhaW50IGEgbmV3IGZyYW1lLlxuICogRG8gdGhpcyBieSBjb21iaW5pbmcgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIChyQUYpICsgc2V0VGltZW91dCB0byBpbnZva2UgYSBjYWxsYmFjayBhZnRlclxuICogdGhlIG5leHQgYnJvd3NlciBmcmFtZS5cbiAqXG4gKiBBbHNvLCBzY2hlZHVsZSBhIHRpbWVvdXQgaW4gcGFyYWxsZWwgdG8gdGhlIHRoZSByQUYgdG8gZW5zdXJlIHRoZSBjYWxsYmFjayBpcyBpbnZva2VkXG4gKiBldmVuIGlmIFJBRiBkb2Vzbid0IGZpcmUgKGZvciBleGFtcGxlIGlmIHRoZSBicm93c2VyIHRhYiBpcyBub3QgdmlzaWJsZSlcbiAqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGFmdGVyTmV4dEZyYW1lKGNhbGxiYWNrKSB7XG5cdGNvbnN0IGRvbmUgPSAoKSA9PiB7XG5cdFx0Y2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuXHRcdGlmIChIQVNfUkFGKSBjYW5jZWxBbmltYXRpb25GcmFtZShyYWYpO1xuXHRcdHNldFRpbWVvdXQoY2FsbGJhY2spO1xuXHR9O1xuXHRjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dChkb25lLCBSQUZfVElNRU9VVCk7XG5cblx0bGV0IHJhZjtcblx0aWYgKEhBU19SQUYpIHtcblx0XHRyYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9uZSk7XG5cdH1cbn1cblxuLy8gTm90ZTogaWYgc29tZW9uZSB1c2VkIG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4vLyB0aGVuIGVmZmVjdHMgd2lsbCBBTFdBWVMgcnVuIG9uIHRoZSBORVhUIGZyYW1lIGluc3RlYWQgb2YgdGhlIGN1cnJlbnQgb25lLCBpbmN1cnJpbmcgYSB+MTZtcyBkZWxheS5cbi8vIFBlcmhhcHMgdGhpcyBpcyBub3Qgc3VjaCBhIGJpZyBkZWFsLlxuLyoqXG4gKiBTY2hlZHVsZSBhZnRlclBhaW50RWZmZWN0cyBmbHVzaCBhZnRlciB0aGUgYnJvd3NlciBwYWludHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZXdRdWV1ZUxlbmd0aFxuICovXG5mdW5jdGlvbiBhZnRlclBhaW50KG5ld1F1ZXVlTGVuZ3RoKSB7XG5cdGlmIChuZXdRdWV1ZUxlbmd0aCA9PT0gMSB8fCBwcmV2UmFmICE9PSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZSkge1xuXHRcdHByZXZSYWYgPSBvcHRpb25zLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQocHJldlJhZiB8fCBhZnRlck5leHRGcmFtZSkoZmx1c2hBZnRlclBhaW50RWZmZWN0cyk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VDbGVhbnVwKGhvb2spIHtcblx0Ly8gQSBob29rIGNsZWFudXAgY2FuIGludHJvZHVjZSBhIGNhbGwgdG8gcmVuZGVyIHdoaWNoIGNyZWF0ZXMgYSBuZXcgcm9vdCwgdGhpcyB3aWxsIGNhbGwgb3B0aW9ucy52bm9kZVxuXHQvLyBhbmQgbW92ZSB0aGUgY3VycmVudENvbXBvbmVudCBhd2F5LlxuXHRjb25zdCBjb21wID0gY3VycmVudENvbXBvbmVudDtcblx0bGV0IGNsZWFudXAgPSBob29rLl9jbGVhbnVwO1xuXHRpZiAodHlwZW9mIGNsZWFudXAgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdGhvb2suX2NsZWFudXAgPSB1bmRlZmluZWQ7XG5cdFx0Y2xlYW51cCgpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSBjb21wO1xufVxuXG4vKipcbiAqIEludm9rZSBhIEhvb2sncyBlZmZlY3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUVmZmVjdChob29rKSB7XG5cdC8vIEEgaG9vayBjYWxsIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGhvb2suX2NsZWFudXAgPSBob29rLl92YWx1ZSgpO1xuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueVtdfSBvbGRBcmdzXG4gKiBAcGFyYW0ge2FueVtdfSBuZXdBcmdzXG4gKi9cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3MsIG5ld0FyZ3MpIHtcblx0cmV0dXJuIChcblx0XHQhb2xkQXJncyB8fFxuXHRcdG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzLmxlbmd0aCB8fFxuXHRcdG5ld0FyZ3Muc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcblx0KTtcbn1cblxuZnVuY3Rpb24gaW52b2tlT3JSZXR1cm4oYXJnLCBmKSB7XG5cdHJldHVybiB0eXBlb2YgZiA9PSAnZnVuY3Rpb24nID8gZihhcmcpIDogZjtcbn1cbiIsIi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Zm9yIChsZXQgaSBpbiBwcm9wcykgb2JqW2ldID0gcHJvcHNbaV07XG5cdHJldHVybiAvKiogQHR5cGUge08gJiBQfSAqLyAob2JqKTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gb2JqZWN0cyBoYXZlIGEgZGlmZmVyZW50IHNoYXBlXG4gKiBAcGFyYW0ge29iamVjdH0gYVxuICogQHBhcmFtIHtvYmplY3R9IGJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0RpZmZlcnMoYSwgYikge1xuXHRmb3IgKGxldCBpIGluIGEpIGlmIChpICE9PSAnX19zb3VyY2UnICYmICEoaSBpbiBiKSkgcmV0dXJuIHRydWU7XG5cdGZvciAobGV0IGkgaW4gYikgaWYgKGkgIT09ICdfX3NvdXJjZScgJiYgYVtpXSAhPT0gYltpXSkgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc2hhbGxvd0RpZmZlcnMgfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIENvbXBvbmVudCBjbGFzcyB3aXRoIGEgcHJlZGVmaW5lZCBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBpbXBsZW1lbnRhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwKSB7XG5cdHRoaXMucHJvcHMgPSBwO1xufVxuUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG4vLyBTb21lIHRoaXJkLXBhcnR5IGxpYnJhcmllcyBjaGVjayBpZiB0aGlzIHByb3BlcnR5IGlzIHByZXNlbnRcblB1cmVDb21wb25lbnQucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRyZXR1cm4gc2hhbGxvd0RpZmZlcnModGhpcy5wcm9wcywgcHJvcHMpIHx8IHNoYWxsb3dEaWZmZXJzKHRoaXMuc3RhdGUsIHN0YXRlKTtcbn07XG4iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBNZW1vaXplIGEgY29tcG9uZW50LCBzbyB0aGF0IGl0IG9ubHkgdXBkYXRlcyB3aGVuIHRoZSBwcm9wcyBhY3R1YWxseSBoYXZlXG4gKiBjaGFuZ2VkLiBUaGlzIHdhcyBwcmV2aW91c2x5IGtub3duIGFzIGBSZWFjdC5wdXJlYC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRnVuY3Rpb25Db21wb25lbnR9IGMgZnVuY3Rpb25hbCBjb21wb25lbnRcbiAqIEBwYXJhbSB7KHByZXY6IG9iamVjdCwgbmV4dDogb2JqZWN0KSA9PiBib29sZWFufSBbY29tcGFyZXJdIEN1c3RvbSBlcXVhbGl0eSBmdW5jdGlvblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVtbyhjLCBjb21wYXJlcikge1xuXHRmdW5jdGlvbiBzaG91bGRVcGRhdGUobmV4dFByb3BzKSB7XG5cdFx0bGV0IHJlZiA9IHRoaXMucHJvcHMucmVmO1xuXHRcdGxldCB1cGRhdGVSZWYgPSByZWYgPT0gbmV4dFByb3BzLnJlZjtcblx0XHRpZiAoIXVwZGF0ZVJlZiAmJiByZWYpIHtcblx0XHRcdHJlZi5jYWxsID8gcmVmKG51bGwpIDogKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wYXJlcikge1xuXHRcdFx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIG5leHRQcm9wcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuICFjb21wYXJlcih0aGlzLnByb3BzLCBuZXh0UHJvcHMpIHx8ICF1cGRhdGVSZWY7XG5cdH1cblxuXHRmdW5jdGlvbiBNZW1vZWQocHJvcHMpIHtcblx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IHNob3VsZFVwZGF0ZTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjLCBwcm9wcyk7XG5cdH1cblx0TWVtb2VkLmRpc3BsYXlOYW1lID0gJ01lbW8oJyArIChjLmRpc3BsYXlOYW1lIHx8IGMubmFtZSkgKyAnKSc7XG5cdE1lbW9lZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cdE1lbW9lZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIE1lbW9lZDtcbn1cbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxubGV0IG9sZERpZmZIb29rID0gb3B0aW9ucy5fZGlmZjtcbm9wdGlvbnMuX2RpZmYgPSB2bm9kZSA9PiB7XG5cdGlmICh2bm9kZS50eXBlICYmIHZub2RlLnR5cGUuX2ZvcndhcmRlZCAmJiB2bm9kZS5yZWYpIHtcblx0XHR2bm9kZS5wcm9wcy5yZWYgPSB2bm9kZS5yZWY7XG5cdFx0dm5vZGUucmVmID0gbnVsbDtcblx0fVxuXHRpZiAob2xkRGlmZkhvb2spIG9sZERpZmZIb29rKHZub2RlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9GT1JXQVJEX1NZTUJPTCA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmXG5cdFx0U3ltYm9sLmZvciAmJlxuXHRcdFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJykpIHx8XG5cdDB4ZjQ3O1xuXG4vKipcbiAqIFBhc3MgcmVmIGRvd24gdG8gYSBjaGlsZC4gVGhpcyBpcyBtYWlubHkgdXNlZCBpbiBsaWJyYXJpZXMgd2l0aCBIT0NzIHRoYXRcbiAqIHdyYXAgY29tcG9uZW50cy4gVXNpbmcgYGZvcndhcmRSZWZgIHRoZXJlIGlzIGFuIGVhc3kgd2F5IHRvIGdldCBhIHJlZmVyZW5jZVxuICogb2YgdGhlIHdyYXBwZWQgY29tcG9uZW50IGluc3RlYWQgb2Ygb25lIG9mIHRoZSB3cmFwcGVyIGl0c2VsZi5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2luZGV4JykuRm9yd2FyZEZufSBmblxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yd2FyZFJlZihmbikge1xuXHRmdW5jdGlvbiBGb3J3YXJkZWQocHJvcHMpIHtcblx0XHRsZXQgY2xvbmUgPSBhc3NpZ24oe30sIHByb3BzKTtcblx0XHRkZWxldGUgY2xvbmUucmVmO1xuXHRcdHJldHVybiBmbihjbG9uZSwgcHJvcHMucmVmIHx8IG51bGwpO1xuXHR9XG5cblx0Ly8gbW9ieC1yZWFjdCBjaGVja3MgZm9yIHRoaXMgYmVpbmcgcHJlc2VudFxuXHRGb3J3YXJkZWQuJCR0eXBlb2YgPSBSRUFDVF9GT1JXQVJEX1NZTUJPTDtcblx0Ly8gbW9ieC1yZWFjdCBoZWF2aWx5IHJlbGllcyBvbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLlxuXHQvLyBJdCBleHBlY3RzIGFuIG9iamVjdCBoZXJlIHdpdGggYSBgcmVuZGVyYCBwcm9wZXJ0eSxcblx0Ly8gYW5kIHByb3RvdHlwZS5yZW5kZXIgd2lsbCBmYWlsLiBXaXRob3V0IHRoaXNcblx0Ly8gbW9ieC1yZWFjdCB0aHJvd3MuXG5cdEZvcndhcmRlZC5yZW5kZXIgPSBGb3J3YXJkZWQ7XG5cblx0Rm9yd2FyZGVkLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0gRm9yd2FyZGVkLl9mb3J3YXJkZWQgPSB0cnVlO1xuXHRGb3J3YXJkZWQuZGlzcGxheU5hbWUgPSAnRm9yd2FyZFJlZignICsgKGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUpICsgJyknO1xuXHRyZXR1cm4gRm9yd2FyZGVkO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCBjcmVhdGVFbGVtZW50LCBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBhc3NpZ24gfSBmcm9tICcuL3V0aWwnO1xuXG5jb25zdCBvbGRDYXRjaEVycm9yID0gb3B0aW9ucy5fY2F0Y2hFcnJvcjtcbm9wdGlvbnMuX2NhdGNoRXJyb3IgPSBmdW5jdGlvbihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pIHtcblx0aWYgKGVycm9yLnRoZW4pIHtcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0XHRsZXQgY29tcG9uZW50O1xuXHRcdGxldCB2bm9kZSA9IG5ld1ZOb2RlO1xuXG5cdFx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQpIHtcblx0XHRcdFx0aWYgKG5ld1ZOb2RlLl9kb20gPT0gbnVsbCkge1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBEb24ndCBjYWxsIG9sZENhdGNoRXJyb3IgaWYgd2UgZm91bmQgYSBTdXNwZW5zZVxuXHRcdFx0XHRyZXR1cm4gY29tcG9uZW50Ll9jaGlsZERpZFN1c3BlbmQoZXJyb3IsIG5ld1ZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0b2xkQ2F0Y2hFcnJvcihlcnJvciwgbmV3Vk5vZGUsIG9sZFZOb2RlLCBlcnJvckluZm8pO1xufTtcblxuY29uc3Qgb2xkVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcbm9wdGlvbnMudW5tb3VudCA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5fb25SZXNvbHZlKSB7XG5cdFx0Y29tcG9uZW50Ll9vblJlc29sdmUoKTtcblx0fVxuXG5cdC8vIGlmIHRoZSBjb21wb25lbnQgaXMgc3RpbGwgaHlkcmF0aW5nXG5cdC8vIG1vc3QgbGlrZWx5IGl0IGlzIGJlY2F1c2UgdGhlIGNvbXBvbmVudCBpcyBzdXNwZW5kZWRcblx0Ly8gd2Ugc2V0IHRoZSB2bm9kZS50eXBlIGFzIGBudWxsYCBzbyB0aGF0IGl0IGlzIG5vdCBhIHR5cGVvZiBmdW5jdGlvblxuXHQvLyBzbyB0aGUgdW5tb3VudCB3aWxsIHJlbW92ZSB0aGUgdm5vZGUuX2RvbVxuXHRpZiAoY29tcG9uZW50ICYmIHZub2RlLl9oeWRyYXRpbmcgPT09IHRydWUpIHtcblx0XHR2bm9kZS50eXBlID0gbnVsbDtcblx0fVxuXG5cdGlmIChvbGRVbm1vdW50KSBvbGRVbm1vdW50KHZub2RlKTtcbn07XG5cbmZ1bmN0aW9uIGRldGFjaGVkQ2xvbmUodm5vZGUsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgJiYgdm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzKSB7XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZm9yRWFjaChlZmZlY3QgPT4ge1xuXHRcdFx0XHRpZiAodHlwZW9mIGVmZmVjdC5fY2xlYW51cCA9PSAnZnVuY3Rpb24nKSBlZmZlY3QuX2NsZWFudXAoKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9faG9va3MgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlID0gYXNzaWduKHt9LCB2bm9kZSk7XG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gcGFyZW50RG9tKSB7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IGRldGFjaGVkUGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRkZXRhY2hlZENsb25lKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlT3JpZ2luYWwodm5vZGUsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudCkge1xuXHRpZiAodm5vZGUpIHtcblx0XHR2bm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0cmVtb3ZlT3JpZ2luYWwoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBvcmlnaW5hbFBhcmVudClcblx0XHRcdCk7XG5cblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0aWYgKHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9PT0gZGV0YWNoZWRQYXJlbnQpIHtcblx0XHRcdFx0aWYgKHZub2RlLl9kb20pIHtcblx0XHRcdFx0XHRvcmlnaW5hbFBhcmVudC5pbnNlcnRCZWZvcmUodm5vZGUuX2RvbSwgdm5vZGUuX25leHREb20pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX2ZvcmNlID0gdHJ1ZTtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gb3JpZ2luYWxQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG4vLyBoYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2UoKSB7XG5cdC8vIHdlIGRvIG5vdCBjYWxsIHN1cGVyIGhlcmUgdG8gZ29sZiBzb21lIGJ5dGVzLi4uXG5cdHRoaXMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQgPSAwO1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gbnVsbDtcblx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcbn1cblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2UucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7UHJvbWlzZX0gcHJvbWlzZSBUaGUgdGhyb3duIHByb21pc2VcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGU8YW55LCBhbnk+fSBzdXNwZW5kaW5nVk5vZGUgVGhlIHN1c3BlbmRpbmcgY29tcG9uZW50XG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5fY2hpbGREaWRTdXNwZW5kID0gZnVuY3Rpb24ocHJvbWlzZSwgc3VzcGVuZGluZ1ZOb2RlKSB7XG5cdGNvbnN0IHN1c3BlbmRpbmdDb21wb25lbnQgPSBzdXNwZW5kaW5nVk5vZGUuX2NvbXBvbmVudDtcblxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fSAqL1xuXHRjb25zdCBjID0gdGhpcztcblxuXHRpZiAoYy5fc3VzcGVuZGVycyA9PSBudWxsKSB7XG5cdFx0Yy5fc3VzcGVuZGVycyA9IFtdO1xuXHR9XG5cdGMuX3N1c3BlbmRlcnMucHVzaChzdXNwZW5kaW5nQ29tcG9uZW50KTtcblxuXHRjb25zdCByZXNvbHZlID0gc3VzcGVuZGVkKGMuX3Zub2RlKTtcblxuXHRsZXQgcmVzb2x2ZWQgPSBmYWxzZTtcblx0Y29uc3Qgb25SZXNvbHZlZCA9ICgpID0+IHtcblx0XHRpZiAocmVzb2x2ZWQpIHJldHVybjtcblxuXHRcdHJlc29sdmVkID0gdHJ1ZTtcblx0XHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBudWxsO1xuXG5cdFx0aWYgKHJlc29sdmUpIHtcblx0XHRcdHJlc29sdmUob25TdXNwZW5zaW9uQ29tcGxldGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvblN1c3BlbnNpb25Db21wbGV0ZSgpO1xuXHRcdH1cblx0fTtcblxuXHRzdXNwZW5kaW5nQ29tcG9uZW50Ll9vblJlc29sdmUgPSBvblJlc29sdmVkO1xuXG5cdGNvbnN0IG9uU3VzcGVuc2lvbkNvbXBsZXRlID0gKCkgPT4ge1xuXHRcdGlmICghLS1jLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KSB7XG5cdFx0XHQvLyBJZiB0aGUgc3VzcGVuc2lvbiB3YXMgZHVyaW5nIGh5ZHJhdGlvbiB3ZSBkb24ndCBuZWVkIHRvIHJlc3RvcmUgdGhlXG5cdFx0XHQvLyBzdXNwZW5kZWQgY2hpbGRyZW4gaW50byB0aGUgX2NoaWxkcmVuIGFycmF5XG5cdFx0XHRpZiAoYy5zdGF0ZS5fc3VzcGVuZGVkKSB7XG5cdFx0XHRcdGNvbnN0IHN1c3BlbmRlZFZOb2RlID0gYy5zdGF0ZS5fc3VzcGVuZGVkO1xuXHRcdFx0XHRjLl92bm9kZS5fY2hpbGRyZW5bMF0gPSByZW1vdmVPcmlnaW5hbChcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20sXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsKSB9KTtcblxuXHRcdFx0bGV0IHN1c3BlbmRlZDtcblx0XHRcdHdoaWxlICgoc3VzcGVuZGVkID0gYy5fc3VzcGVuZGVycy5wb3AoKSkpIHtcblx0XHRcdFx0c3VzcGVuZGVkLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBXZSBkbyBub3Qgc2V0IGBzdXNwZW5kZWQ6IHRydWVgIGR1cmluZyBoeWRyYXRpb24gYmVjYXVzZSB3ZSB3YW50IHRoZSBhY3R1YWwgbWFya3VwXG5cdCAqIHRvIHJlbWFpbiBvbiBzY3JlZW4gYW5kIGh5ZHJhdGUgaXQgd2hlbiB0aGUgc3VzcGVuc2UgYWN0dWFsbHkgZ2V0cyByZXNvbHZlZC5cblx0ICogV2hpbGUgaW4gbm9uLWh5ZHJhdGlvbiBjYXNlcyB0aGUgdXN1YWwgZmFsbGJhY2sgLT4gY29tcG9uZW50IGZsb3cgd291bGQgb2Njb3VyLlxuXHQgKi9cblx0Y29uc3Qgd2FzSHlkcmF0aW5nID0gc3VzcGVuZGluZ1ZOb2RlLl9oeWRyYXRpbmcgPT09IHRydWU7XG5cdGlmICghYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCsrICYmICF3YXNIeWRyYXRpbmcpIHtcblx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IGMuX3Zub2RlLl9jaGlsZHJlblswXSkgfSk7XG5cdH1cblx0cHJvbWlzZS50aGVuKG9uUmVzb2x2ZWQsIG9uUmVzb2x2ZWQpO1xufTtcblxuU3VzcGVuc2UucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBbXTtcbn07XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudFtcInByb3BzXCJdfSBwcm9wc1xuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZVN0YXRlfSBzdGF0ZVxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMsIHN0YXRlKSB7XG5cdGlmICh0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIpIHtcblx0XHQvLyBXaGVuIHRoZSBTdXNwZW5zZSdzIF92bm9kZSB3YXMgY3JlYXRlZCBieSBhIGNhbGwgdG8gY3JlYXRlVk5vZGVcblx0XHQvLyAoaS5lLiBkdWUgdG8gYSBzZXRTdGF0ZSBmdXJ0aGVyIHVwIGluIHRoZSB0cmVlKVxuXHRcdC8vIGl0J3MgX2NoaWxkcmVuIHByb3AgaXMgbnVsbCwgaW4gdGhpcyBjYXNlIHdlIFwiZm9yZ2V0XCIgYWJvdXQgdGhlIHBhcmtlZCB2bm9kZXMgdG8gZGV0YWNoXG5cdFx0aWYgKHRoaXMuX3Zub2RlLl9jaGlsZHJlbikge1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblx0XHRcdGNvbnN0IGRldGFjaGVkQ29tcG9uZW50ID0gdGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdLl9jb21wb25lbnQ7XG5cdFx0XHR0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0gPSBkZXRhY2hlZENsb25lKFxuXHRcdFx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIsXG5cdFx0XHRcdGRldGFjaGVkUGFyZW50LFxuXHRcdFx0XHQoZGV0YWNoZWRDb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tID0gZGV0YWNoZWRDb21wb25lbnQuX3BhcmVudERvbSlcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbDtcblx0fVxuXG5cdC8vIFdyYXAgZmFsbGJhY2sgdHJlZSBpbiBhIFZOb2RlIHRoYXQgcHJldmVudHMgaXRzZWxmIGZyb20gYmVpbmcgbWFya2VkIGFzIGFib3J0aW5nIG1pZC1oeWRyYXRpb246XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9ICovXG5cdGNvbnN0IGZhbGxiYWNrID1cblx0XHRzdGF0ZS5fc3VzcGVuZGVkICYmIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHByb3BzLmZhbGxiYWNrKTtcblx0aWYgKGZhbGxiYWNrKSBmYWxsYmFjay5faHlkcmF0aW5nID0gbnVsbDtcblxuXHRyZXR1cm4gW1xuXHRcdGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIHN0YXRlLl9zdXNwZW5kZWQgPyBudWxsIDogcHJvcHMuY2hpbGRyZW4pLFxuXHRcdGZhbGxiYWNrXG5cdF07XG59O1xuXG4vKipcbiAqIENoZWNrcyBhbmQgY2FsbHMgdGhlIHBhcmVudCBjb21wb25lbnQncyBfc3VzcGVuZGVkIG1ldGhvZCwgcGFzc2luZyBpbiB0aGVcbiAqIHN1c3BlbmRlZCB2bm9kZS4gVGhpcyBpcyBhIHdheSBmb3IgYSBwYXJlbnQgKGUuZy4gU3VzcGVuc2VMaXN0KSB0byBnZXQgbm90aWZpZWRcbiAqIHRoYXQgb25lIG9mIGl0cyBjaGlsZHJlbi9kZXNjZW5kYW50cyBzdXNwZW5kZWQuXG4gKlxuICogVGhlIHBhcmVudCBNQVkgcmV0dXJuIGEgY2FsbGJhY2suIFRoZSBjYWxsYmFjayB3aWxsIGdldCBjYWxsZWQgd2hlbiB0aGVcbiAqIHN1c3BlbnNpb24gcmVzb2x2ZXMsIG5vdGlmeWluZyB0aGUgcGFyZW50IG9mIHRoZSBmYWN0LlxuICogTW9yZW92ZXIsIHRoZSBjYWxsYmFjayBnZXRzIGZ1bmN0aW9uIGB1bnN1c3BlbmRgIGFzIGEgcGFyYW1ldGVyLiBUaGUgcmVzb2x2ZWRcbiAqIGNoaWxkIGRlc2NlbmRhbnQgd2lsbCBub3QgYWN0dWFsbHkgZ2V0IHVuc3VzcGVuZGVkIHVudGlsIGB1bnN1c3BlbmRgIGdldHMgY2FsbGVkLlxuICogVGhpcyBpcyBhIHdheSBmb3IgdGhlIHBhcmVudCB0byBkZWxheSB1bnN1c3BlbmRpbmcuXG4gKlxuICogSWYgdGhlIHBhcmVudCBkb2VzIG5vdCByZXR1cm4gYSBjYWxsYmFjayB0aGVuIHRoZSByZXNvbHZlZCB2bm9kZVxuICogZ2V0cyB1bnN1c3BlbmRlZCBpbW1lZGlhdGVseSB3aGVuIGl0IHJlc29sdmVzLlxuICpcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcmV0dXJucyB7KCh1bnN1c3BlbmQ6ICgpID0+IHZvaWQpID0+IHZvaWQpP31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN1c3BlbmRlZCh2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCA9IHZub2RlLl9wYXJlbnQuX2NvbXBvbmVudDtcblx0cmV0dXJuIGNvbXBvbmVudCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCAmJiBjb21wb25lbnQuX3N1c3BlbmRlZCh2bm9kZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGxvYWRlcikge1xuXHRsZXQgcHJvbTtcblx0bGV0IGNvbXBvbmVudDtcblx0bGV0IGVycm9yO1xuXG5cdGZ1bmN0aW9uIExhenkocHJvcHMpIHtcblx0XHRpZiAoIXByb20pIHtcblx0XHRcdHByb20gPSBsb2FkZXIoKTtcblx0XHRcdHByb20udGhlbihcblx0XHRcdFx0ZXhwb3J0cyA9PiB7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZXhwb3J0cy5kZWZhdWx0IHx8IGV4cG9ydHM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGUgPT4ge1xuXHRcdFx0XHRcdGVycm9yID0gZTtcblx0XHRcdFx0fVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAoZXJyb3IpIHtcblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblxuXHRcdGlmICghY29tcG9uZW50KSB7XG5cdFx0XHR0aHJvdyBwcm9tO1xuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgcHJvcHMpO1xuXHR9XG5cblx0TGF6eS5kaXNwbGF5TmFtZSA9ICdMYXp5Jztcblx0TGF6eS5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0cmV0dXJuIExhenk7XG59XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzdXNwZW5kZWQgfSBmcm9tICcuL3N1c3BlbnNlLmpzJztcblxuLy8gSW5kZXhlcyB0byBsaW5rZWQgbGlzdCBub2RlcyAobm9kZXMgYXJlIHN0b3JlZCBhcyBhcnJheXMgdG8gc2F2ZSBieXRlcykuXG5jb25zdCBTVVNQRU5ERURfQ09VTlQgPSAwO1xuY29uc3QgUkVTT0xWRURfQ09VTlQgPSAxO1xuY29uc3QgTkVYVF9OT0RFID0gMjtcblxuLy8gSGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlcy5cbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZUxpc3QoKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBudWxsO1xufVxuXG4vLyBNYXJrIG9uZSBvZiBjaGlsZCdzIGVhcmxpZXIgc3VzcGVuc2lvbnMgYXMgcmVzb2x2ZWQuXG4vLyBTb21lIHBlbmRpbmcgY2FsbGJhY2tzIG1heSBiZWNvbWUgY2FsbGFibGUgZHVlIHRvIHRoaXNcbi8vIChlLmcuIHRoZSBsYXN0IHN1c3BlbmRlZCBkZXNjZW5kYW50IGdldHMgcmVzb2x2ZWQgd2hlblxuLy8gcmV2ZWFsT3JkZXIgPT09ICd0b2dldGhlcicpLiBQcm9jZXNzIHRob3NlIGNhbGxiYWNrcyBhcyB3ZWxsLlxuY29uc3QgcmVzb2x2ZSA9IChsaXN0LCBjaGlsZCwgbm9kZSkgPT4ge1xuXHRpZiAoKytub2RlW1JFU09MVkVEX0NPVU5UXSA9PT0gbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0Ly8gVGhlIG51bWJlciBhIGNoaWxkIChvciBhbnkgb2YgaXRzIGRlc2NlbmRhbnRzKSBoYXMgYmVlbiBzdXNwZW5kZWRcblx0XHQvLyBtYXRjaGVzIHRoZSBudW1iZXIgb2YgdGltZXMgaXQncyBiZWVuIHJlc29sdmVkLiBUaGVyZWZvcmUgd2Vcblx0XHQvLyBtYXJrIHRoZSBjaGlsZCBhcyBjb21wbGV0ZWx5IHJlc29sdmVkIGJ5IGRlbGV0aW5nIGl0IGZyb20gLl9tYXAuXG5cdFx0Ly8gVGhpcyBpcyB1c2VkIHRvIGZpZ3VyZSBvdXQgd2hlbiAqYWxsKiBjaGlsZHJlbiBoYXZlIGJlZW4gY29tcGxldGVseVxuXHRcdC8vIHJlc29sdmVkIHdoZW4gcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJy5cblx0XHRsaXN0Ll9tYXAuZGVsZXRlKGNoaWxkKTtcblx0fVxuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzIGZhbHN5IHRoZW4gd2UgY2FuIGRvIGFuIGVhcmx5IGV4aXQsIGFzIHRoZVxuXHQvLyBjYWxsYmFja3Mgd29uJ3QgZ2V0IHF1ZXVlZCBpbiB0aGUgbm9kZSBhbnl3YXkuXG5cdC8vIElmIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicgdGhlbiBhbHNvIGRvIGFuIGVhcmx5IGV4aXRcblx0Ly8gaWYgYWxsIHN1c3BlbmRlZCBkZXNjZW5kYW50cyBoYXZlIG5vdCB5ZXQgYmVlbiByZXNvbHZlZC5cblx0aWYgKFxuXHRcdCFsaXN0LnByb3BzLnJldmVhbE9yZGVyIHx8XG5cdFx0KGxpc3QucHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICd0JyAmJiBsaXN0Ll9tYXAuc2l6ZSlcblx0KSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gV2FsayB0aGUgY3VycmVudGx5IHN1c3BlbmRlZCBjaGlsZHJlbiBpbiBvcmRlciwgY2FsbGluZyB0aGVpclxuXHQvLyBzdG9yZWQgY2FsbGJhY2tzIG9uIHRoZSB3YXkuIFN0b3AgaWYgd2UgZW5jb3VudGVyIGEgY2hpbGQgdGhhdFxuXHQvLyBoYXMgbm90IGJlZW4gY29tcGxldGVseSByZXNvbHZlZCB5ZXQuXG5cdG5vZGUgPSBsaXN0Ll9uZXh0O1xuXHR3aGlsZSAobm9kZSkge1xuXHRcdHdoaWxlIChub2RlLmxlbmd0aCA+IDMpIHtcblx0XHRcdG5vZGUucG9wKCkoKTtcblx0XHR9XG5cdFx0aWYgKG5vZGVbUkVTT0xWRURfQ09VTlRdIDwgbm9kZVtTVVNQRU5ERURfQ09VTlRdKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0bGlzdC5fbmV4dCA9IG5vZGUgPSBub2RlW05FWFRfTk9ERV07XG5cdH1cbn07XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlTGlzdC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuX3N1c3BlbmRlZCA9IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdGNvbnN0IGxpc3QgPSB0aGlzO1xuXHRjb25zdCBkZWxlZ2F0ZWQgPSBzdXNwZW5kZWQobGlzdC5fdm5vZGUpO1xuXG5cdGxldCBub2RlID0gbGlzdC5fbWFwLmdldChjaGlsZCk7XG5cdG5vZGVbU1VTUEVOREVEX0NPVU5UXSsrO1xuXG5cdHJldHVybiB1bnN1c3BlbmQgPT4ge1xuXHRcdGNvbnN0IHdyYXBwZWRVbnN1c3BlbmQgPSAoKSA9PiB7XG5cdFx0XHRpZiAoIWxpc3QucHJvcHMucmV2ZWFsT3JkZXIpIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIHRoZSB1bmRlZmluZWQgKGZhbHN5KSByZXZlYWxPcmRlciwgYXMgdGhlcmVcblx0XHRcdFx0Ly8gaXMgbm8gbmVlZCB0byBjb29yZGluYXRlIGEgc3BlY2lmaWMgb3JkZXIgb3IgdW5zdXNwZW5kcy5cblx0XHRcdFx0dW5zdXNwZW5kKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnB1c2godW5zdXNwZW5kKTtcblx0XHRcdFx0cmVzb2x2ZShsaXN0LCBjaGlsZCwgbm9kZSk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRpZiAoZGVsZWdhdGVkKSB7XG5cdFx0XHRkZWxlZ2F0ZWQod3JhcHBlZFVuc3VzcGVuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdyYXBwZWRVbnN1c3BlbmQoKTtcblx0XHR9XG5cdH07XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzKSB7XG5cdHRoaXMuX25leHQgPSBudWxsO1xuXHR0aGlzLl9tYXAgPSBuZXcgTWFwKCk7XG5cblx0Y29uc3QgY2hpbGRyZW4gPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pO1xuXHRpZiAocHJvcHMucmV2ZWFsT3JkZXIgJiYgcHJvcHMucmV2ZWFsT3JkZXJbMF0gPT09ICdiJykge1xuXHRcdC8vIElmIG9yZGVyID09PSAnYmFja3dhcmRzJyAob3IsIHdlbGwsIGFueXRoaW5nIHN0YXJ0aW5nIHdpdGggYSAnYicpXG5cdFx0Ly8gdGhlbiBmbGlwIHRoZSBjaGlsZCBsaXN0IGFyb3VuZCBzbyB0aGF0IHRoZSBsYXN0IGNoaWxkIHdpbGwgYmVcblx0XHQvLyB0aGUgZmlyc3QgaW4gdGhlIGxpbmtlZCBsaXN0LlxuXHRcdGNoaWxkcmVuLnJldmVyc2UoKTtcblx0fVxuXHQvLyBCdWlsZCB0aGUgbGlua2VkIGxpc3QuIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY2hpbGRyZW4gaW4gcmV2ZXJzZSBvcmRlclxuXHQvLyBzbyB0aGF0IGBfbmV4dGAgcG9pbnRzIHRvIHRoZSBmaXJzdCBsaW5rZWQgbGlzdCBub2RlIHRvIGJlIHJlc29sdmVkLlxuXHRmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoOyBpLS07ICkge1xuXHRcdC8vIENyZWF0ZSBhIG5ldyBsaW5rZWQgbGlzdCBub2RlIGFzIGFuIGFycmF5IG9mIGZvcm06XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlXVxuXHRcdC8vIHdoZXJlIHN1c3BlbmRlZF9jb3VudCBhbmQgcmVzb2x2ZWRfY291bnQgYXJlIG51bWVyaWMgY291bnRlcnMgZm9yXG5cdFx0Ly8ga2VlcGluZyB0cmFjayBob3cgbWFueSB0aW1lcyBhIG5vZGUgaGFzIGJlZW4gc3VzcGVuZGVkIGFuZCByZXNvbHZlZC5cblx0XHQvL1xuXHRcdC8vIE5vdGUgdGhhdCBzdXNwZW5kZWRfY291bnQgc3RhcnRzIGZyb20gMSBpbnN0ZWFkIG9mIDAsIHNvIHdlIGNhbiBibG9ja1xuXHRcdC8vIHByb2Nlc3NpbmcgY2FsbGJhY2tzIHVudGlsIGNvbXBvbmVudERpZE1vdW50IGhhcyBiZWVuIGNhbGxlZC4gSW4gYSBzZW5zZVxuXHRcdC8vIG5vZGUgaXMgc3VzcGVuZGVkIGF0IGxlYXN0IHVudGlsIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkIVxuXHRcdC8vXG5cdFx0Ly8gUGVuZGluZyBjYWxsYmFja3MgYXJlIGFkZGVkIHRvIHRoZSBlbmQgb2YgdGhlIG5vZGU6XG5cdFx0Ly8gXHRbc3VzcGVuZGVkX2NvdW50LCByZXNvbHZlZF9jb3VudCwgbmV4dF9ub2RlLCBjYWxsYmFja18wLCBjYWxsYmFja18xLCAuLi5dXG5cdFx0dGhpcy5fbWFwLnNldChjaGlsZHJlbltpXSwgKHRoaXMuX25leHQgPSBbMSwgMCwgdGhpcy5fbmV4dF0pKTtcblx0fVxuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59O1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IFN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbigpIHtcblx0Ly8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBjaGlsZHJlbiBhZnRlciBtb3VudGluZyBmb3IgdHdvIHJlYXNvbnM6XG5cdC8vIDEuIEFzIGVhY2ggbm9kZVtTVVNQRU5ERURfQ09VTlRdIHN0YXJ0cyBmcm9tIDEsIHRoaXMgaXRlcmF0aW9uIGluY3JlYXNlc1xuXHQvLyAgICBlYWNoIG5vZGVbUkVMRUFTRURfQ09VTlRdIGJ5IDEsIHRoZXJlZm9yZSBiYWxhbmNpbmcgdGhlIGNvdW50ZXJzLlxuXHQvLyAgICBUaGUgbm9kZXMgY2FuIG5vdyBiZSBjb21wbGV0ZWx5IGNvbnN1bWVkIGZyb20gdGhlIGxpbmtlZCBsaXN0LlxuXHQvLyAyLiBIYW5kbGUgbm9kZXMgdGhhdCBtaWdodCBoYXZlIGdvdHRlbiByZXNvbHZlZCBiZXR3ZWVuIHJlbmRlciBhbmRcblx0Ly8gICAgY29tcG9uZW50RGlkTW91bnQuXG5cdHRoaXMuX21hcC5mb3JFYWNoKChub2RlLCBjaGlsZCkgPT4ge1xuXHRcdHJlc29sdmUodGhpcywgY2hpbGQsIG5vZGUpO1xuXHR9KTtcbn07XG4iLCJpbXBvcnQge1xuXHRyZW5kZXIgYXMgcHJlYWN0UmVuZGVyLFxuXHRoeWRyYXRlIGFzIHByZWFjdEh5ZHJhdGUsXG5cdG9wdGlvbnMsXG5cdHRvQ2hpbGRBcnJheSxcblx0Q29tcG9uZW50XG59IGZyb20gJ3ByZWFjdCc7XG5cbmV4cG9ydCBjb25zdCBSRUFDVF9FTEVNRU5UX1RZUEUgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuZm9yICYmIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcblx0MHhlYWM3O1xuXG5jb25zdCBDQU1FTF9QUk9QUyA9IC9eKD86YWNjZW50fGFsaWdubWVudHxhcmFiaWN8YmFzZWxpbmV8Y2FwfGNsaXAoPyFQYXRoVSl8Y29sb3J8ZG9taW5hbnR8ZmlsbHxmbG9vZHxmb250fGdseXBoKD8hUil8aG9yaXp8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHNoYXBlfHN0b3B8c3RyaWtldGhyb3VnaHxzdHJva2V8dGV4dCg/IUwpfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS87XG5cbmNvbnN0IElTX0RPTSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIElucHV0IHR5cGVzIGZvciB3aGljaCBvbmNoYW5nZSBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byBvbmlucHV0LlxuLy8gdHlwZT1cImZpbGV8Y2hlY2tib3h8cmFkaW9cIiwgcGx1cyBcInJhbmdlXCIgaW4gSUUxMS5cbi8vIChJRTExIGRvZXNuJ3Qgc3VwcG9ydCBTeW1ib2wsIHdoaWNoIHdlIHVzZSBoZXJlIHRvIHR1cm4gYHJhZGAgaW50byBgcmFgIHdoaWNoIG1hdGNoZXMgXCJyYW5nZVwiKVxuY29uc3Qgb25DaGFuZ2VJbnB1dFR5cGUgPSB0eXBlID0+XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2woKSA9PSAnc3ltYm9sJ1xuXHRcdD8gL2ZpbHxjaGV8cmFkL2lcblx0XHQ6IC9maWx8Y2hlfHJhL2lcblx0KS50ZXN0KHR5cGUpO1xuXG4vLyBTb21lIGxpYnJhcmllcyBsaWtlIGByZWFjdC12aXJ0dWFsaXplZGAgZXhwbGljaXRseSBjaGVjayBmb3IgdGhpcy5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vLyBgVU5TQUZFXypgIGxpZmVjeWNsZSBob29rc1xuLy8gUHJlYWN0IG9ubHkgZXZlciBpbnZva2VzIHRoZSB1bnByZWZpeGVkIG1ldGhvZHMuXG4vLyBIZXJlIHdlIHByb3ZpZGUgYSBiYXNlIFwiZmFsbGJhY2tcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGNhbGxzIGFueSBkZWZpbmVkIFVOU0FGRV8gcHJlZml4ZWQgbWV0aG9kLlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGl0cyBvd24gYGNvbXBvbmVudERpZE1vdW50KClgIChpbmNsdWRpbmcgdmlhIGRlZmluZVByb3BlcnR5KSwgdXNlIHRoYXQuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgYFVOU0FGRV9jb21wb25lbnREaWRNb3VudCgpYCwgYGNvbXBvbmVudERpZE1vdW50YCBpcyB0aGUgYWxpYXMgZ2V0dGVyL3NldHRlci5cbi8vIC0gSWYgYW55dGhpbmcgYXNzaWducyB0byBhbiBgVU5TQUZFXypgIHByb3BlcnR5LCB0aGUgYXNzaWdubWVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIHVucHJlZml4ZWQgcHJvcGVydHkuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTk0MVxuW1xuXHQnY29tcG9uZW50V2lsbE1vdW50Jyxcblx0J2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuXHQnY29tcG9uZW50V2lsbFVwZGF0ZSdcbl0uZm9yRWFjaChrZXkgPT4ge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwga2V5LCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzWydVTlNBRkVfJyArIGtleV07XG5cdFx0fSxcblx0XHRzZXQodikge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdlxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG4vKipcbiAqIFByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVk5vZGUgdHJlZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50IERPTSBub2RlIHRvIHJlbmRlciB2bm9kZSB0cmVlIGludG9cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHJlbmRlcmluZ1xuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudCB8IG51bGx9IFRoZSByb290IGNvbXBvbmVudCByZWZlcmVuY2Ugb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdC8vIFJlYWN0IGRlc3Ryb3lzIGFueSBleGlzdGluZyBET00gbm9kZXMsIHNlZSAjMTcyN1xuXHQvLyAuLi5idXQgb25seSBvbiB0aGUgZmlyc3QgcmVuZGVyLCBzZWUgIzE4Mjhcblx0aWYgKHBhcmVudC5fY2hpbGRyZW4gPT0gbnVsbCkge1xuXHRcdHBhcmVudC50ZXh0Q29udGVudCA9ICcnO1xuXHR9XG5cblx0cHJlYWN0UmVuZGVyKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdHByZWFjdEh5ZHJhdGUodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxubGV0IG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZSA9PiB7XG5cdGlmIChvbGRFdmVudEhvb2spIGUgPSBvbGRFdmVudEhvb2soZSk7XG5cdGUucGVyc2lzdCA9IGVtcHR5O1xuXHRlLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gaXNQcm9wYWdhdGlvblN0b3BwZWQ7XG5cdGUuaXNEZWZhdWx0UHJldmVudGVkID0gaXNEZWZhdWx0UHJldmVudGVkO1xuXHRyZXR1cm4gKGUubmF0aXZlRXZlbnQgPSBlKTtcbn07XG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxuZnVuY3Rpb24gaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB7XG5cdHJldHVybiB0aGlzLmNhbmNlbEJ1YmJsZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZhdWx0UHJldmVudGVkKCkge1xuXHRyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkO1xufVxuXG5sZXQgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3M7XG5cdH1cbn07XG5cbmxldCBvbGRWTm9kZUhvb2sgPSBvcHRpb25zLnZub2RlO1xub3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0bGV0IHR5cGUgPSB2bm9kZS50eXBlO1xuXHRsZXQgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzO1xuXG5cdC8vIG9ubHkgbm9ybWFsaXplIHByb3BzIG9uIEVsZW1lbnQgbm9kZXNcblx0aWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdGNvbnN0IG5vbkN1c3RvbUVsZW1lbnQgPSB0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTE7XG5cdFx0bm9ybWFsaXplZFByb3BzID0ge307XG5cblx0XHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wc1tpXTtcblxuXHRcdFx0aWYgKElTX0RPTSAmJiBpID09PSAnY2hpbGRyZW4nICYmIHR5cGUgPT09ICdub3NjcmlwdCcpIHtcblx0XHRcdFx0Ly8gRW11bGF0ZSBSZWFjdCdzIGJlaGF2aW9yIG9mIG5vdCByZW5kZXJpbmcgdGhlIGNvbnRlbnRzIG9mIG5vc2NyaXB0IHRhZ3Mgb24gdGhlIGNsaWVudC5cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICd2YWx1ZScgJiYgJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMgJiYgdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBTa2lwIGFwcGx5aW5nIHZhbHVlIGlmIGl0IGlzIG51bGwvdW5kZWZpbmVkIGFuZCB3ZSBhbHJlYWR5IHNldFxuXHRcdFx0XHQvLyBhIGRlZmF1bHQgdmFsdWVcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRpID09PSAnZGVmYXVsdFZhbHVlJyAmJlxuXHRcdFx0XHQndmFsdWUnIGluIHByb3BzICYmXG5cdFx0XHRcdHByb3BzLnZhbHVlID09IG51bGxcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpcyB0cmVhdGVkIGFzIGEgZmFsbGJhY2sgYHZhbHVlYCB3aGVuIGEgdmFsdWUgcHJvcCBpcyBwcmVzZW50IGJ1dCBudWxsL3VuZGVmaW5lZC5cblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgZm9yIEVsZW1lbnRzIHdpdGggbm8gdmFsdWUgcHJvcCBpcyB0aGUgc2FtZSBhcyB0aGUgRE9NIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eS5cblx0XHRcdFx0aSA9ICd2YWx1ZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICdkb3dubG9hZCcgJiYgdmFsdWUgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gQ2FsbGluZyBgc2V0QXR0cmlidXRlYCB3aXRoIGEgdHJ1dGh5IHZhbHVlIHdpbGwgbGVhZCB0byBpdCBiZWluZ1xuXHRcdFx0XHQvLyBwYXNzZWQgYXMgYSBzdHJpbmdpZmllZCB2YWx1ZSwgZS5nLiBgZG93bmxvYWQ9XCJ0cnVlXCJgLiBSZWFjdFxuXHRcdFx0XHQvLyBjb252ZXJ0cyBpdCB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCwgb3RoZXJ3aXNlIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBmaWxlIG5hbWUgYW5kIHRoZSBmaWxlIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHRcdC8vIFwidHJ1ZVwiIHVwb24gZG93bmxvYWRpbmcgaXQuXG5cdFx0XHRcdHZhbHVlID0gJyc7XG5cdFx0XHR9IGVsc2UgaWYgKC9vbmRvdWJsZWNsaWNrL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZGJsY2xpY2snO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KGkgKyB0eXBlKSAmJlxuXHRcdFx0XHQhb25DaGFuZ2VJbnB1dFR5cGUocHJvcHMudHlwZSlcblx0XHRcdCkge1xuXHRcdFx0XHRpID0gJ29uaW5wdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uZm9jdXMkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNpbic7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25ibHVyJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3Vzb3V0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnB8Q29tcG8pLy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKG5vbkN1c3RvbUVsZW1lbnQgJiYgQ0FNRUxfUFJPUFMudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS5yZXBsYWNlKC9bQS1aMC05XS8sICctJCYnKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHN1cHBvcnQgZm9yIG9uSW5wdXQgYW5kIG9uQ2hhbmdlLCBzZWUgIzM1NjFcblx0XHRcdC8vIGlmIHdlIGhhdmUgYW4gb25pbnB1dCBwcm9wIGFscmVhZHkgY2hhbmdlIGl0IHRvIG9uaW5wdXRDYXB0dXJlXG5cdFx0XHRpZiAoL15vbmlucHV0JC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSkge1xuXHRcdFx0XHRcdGkgPSAnb25pbnB1dENhcHR1cmUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHZhbHVlO1xuXHRcdH1cblxuXHRcdC8vIEFkZCBzdXBwb3J0IGZvciBhcnJheSBzZWxlY3QgdmFsdWVzOiA8c2VsZWN0IG11bHRpcGxlIHZhbHVlPXtbXX0gLz5cblx0XHRpZiAoXG5cdFx0XHR0eXBlID09ICdzZWxlY3QnICYmXG5cdFx0XHRub3JtYWxpemVkUHJvcHMubXVsdGlwbGUgJiZcblx0XHRcdEFycmF5LmlzQXJyYXkobm9ybWFsaXplZFByb3BzLnZhbHVlKVxuXHRcdCkge1xuXHRcdFx0Ly8gZm9yRWFjaCgpIGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgd2hpY2ggd2UgYWJ1c2UgaGVyZSB0byB1bnNldCB0aGUgdmFsdWUgcHJvcC5cblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUuaW5kZXhPZihjaGlsZC5wcm9wcy52YWx1ZSkgIT0gLTE7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBBZGRpbmcgc3VwcG9ydCBmb3IgZGVmYXVsdFZhbHVlIGluIHNlbGVjdCB0YWdcblx0XHRpZiAodHlwZSA9PSAnc2VsZWN0JyAmJiBub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcblx0XHRcdG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbikuZm9yRWFjaChjaGlsZCA9PiB7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHMubXVsdGlwbGUpIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNoaWxkLnByb3BzLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdG5vcm1hbGl6ZWRQcm9wcy5kZWZhdWx0VmFsdWUgPT0gY2hpbGQucHJvcHMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHZub2RlLnByb3BzID0gbm9ybWFsaXplZFByb3BzO1xuXG5cdFx0aWYgKHByb3BzLmNsYXNzICE9IHByb3BzLmNsYXNzTmFtZSkge1xuXHRcdFx0Y2xhc3NOYW1lRGVzY3JpcHRvci5lbnVtZXJhYmxlID0gJ2NsYXNzTmFtZScgaW4gcHJvcHM7XG5cdFx0XHRpZiAocHJvcHMuY2xhc3NOYW1lICE9IG51bGwpIG5vcm1hbGl6ZWRQcm9wcy5jbGFzcyA9IHByb3BzLmNsYXNzTmFtZTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub3JtYWxpemVkUHJvcHMsICdjbGFzc05hbWUnLCBjbGFzc05hbWVEZXNjcmlwdG9yKTtcblx0XHR9XG5cdH1cblxuXHR2bm9kZS4kJHR5cGVvZiA9IFJFQUNUX0VMRU1FTlRfVFlQRTtcblxuXHRpZiAob2xkVk5vZGVIb29rKSBvbGRWTm9kZUhvb2sodm5vZGUpO1xufTtcblxuLy8gT25seSBuZWVkZWQgZm9yIHJlYWN0LXJlbGF5XG5sZXQgY3VycmVudENvbXBvbmVudDtcbmNvbnN0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbm9wdGlvbnMuX3JlbmRlciA9IGZ1bmN0aW9uKHZub2RlKSB7XG5cdGlmIChvbGRCZWZvcmVSZW5kZXIpIHtcblx0XHRvbGRCZWZvcmVSZW5kZXIodm5vZGUpO1xuXHR9XG5cdGN1cnJlbnRDb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50O1xufTtcblxuLy8gVGhpcyBpcyBhIHZlcnkgdmVyeSBwcml2YXRlIGludGVybmFsIGZ1bmN0aW9uIGZvciBSZWFjdCBpdFxuLy8gaXMgdXNlZCB0byBzb3J0LW9mIGRvIHJ1bnRpbWUgZGVwZW5kZW5jeSBpbmplY3Rpb24uIFNvIGZhclxuLy8gb25seSBgcmVhY3QtcmVsYXlgIG1ha2VzIHVzZSBvZiBpdC4gSXQgdXNlcyBpdCB0byByZWFkIHRoZVxuLy8gY29udGV4dCB2YWx1ZS5cbmV4cG9ydCBjb25zdCBfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IHtcblx0UmVhY3RDdXJyZW50RGlzcGF0Y2hlcjoge1xuXHRcdGN1cnJlbnQ6IHtcblx0XHRcdHJlYWRDb250ZXh0KGNvbnRleHQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnJlbnRDb21wb25lbnQuX2dsb2JhbENvbnRleHRbY29udGV4dC5faWRdLnByb3BzLnZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgb3B0aW9ucyB9IGZyb20gXCJwcmVhY3RcIlxyXG5cclxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcclxuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4gPSAoKHZhbHVlOiBULCBwcmV2VmFsdWU6IFQgfCB1bmRlZmluZWQpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XHJcblxyXG4vKipcclxuICogRGVidWcgaG9vay5cclxuICogXHJcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXHJcbiAqIFxyXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xyXG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGgsIDApO1xyXG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcclxuICAgIHJldHVybjtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFU+KHZhbHVlOiBVLCBpbmRleDogbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcclxuICAgICAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZih2YWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpbmRleH0taW5kZXhlZCBhcmd1bWVudC5gKTtcclxuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XHJcbiAgICAob3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA/PyBzZXRUaW1lb3V0KShmKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFNpbWlsYXIgdG8gYHVzZVN0YXRlYCwgYnV0IGZvciB2YWx1ZXMgdGhhdCBhcmVuJ3QgXCJyZW5kZXItaW1wb3J0YW50XCIgJm5kYXNoOyB1cGRhdGVzIGRvbid0IGNhdXNlIGEgcmUtcmVuZGVyIGFuZCBzbyB0aGUgdmFsdWUgc2hvdWxkbid0IGJlIHVzZWQgZHVyaW5nIHJlbmRlciAodGhvdWdoIGl0IGNlcnRhaW5seSBjYW4sIGF0IGxlYXN0IGJ5IHJlLXJlbmRlcmluZyBhZ2FpbikuXHJcbiAqIFxyXG4gKiBUbyBjb21wZW5zYXRlIGZvciB0aGlzLCB5b3Ugc2hvdWxkIHBhc3MgYSBgdXNlRWZmZWN0YC1lc3F1ZSBjYWxsYmFjayB0aGF0IGlzIHJ1biB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcy4gIEp1c3QgbGlrZSBgdXNlRWZmZWN0YCwgdGhpcyBjYWxsYmFjayBjYW4gcmV0dXJuIGEgY2xlYW51cCBmdW5jdGlvbiB0aGF0J3MgcnVuIGJlZm9yZSB0aGUgdmFsdWUgY2hhbmdlcy4gIElmIHlvdSB3b3VsZCBsaWtlIHRvIHJlLXJlbmRlciB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIChvciwgc2F5LCB3aGVuIHRoZSB2YWx1ZSBtZWV0cyBzb21lIGNyaXRlcmlhKSwgdGhpcyBpcyB3aGVyZSB5b3UnbGwgd2FudCB0byBwdXQgaW4gYSBjYWxsIHRvIGEgYHNldFN0YXRlYCBmdW5jdGlvbi5cclxuICogXHJcbiAqIFRvIHN1bW1hcml6ZSwgaXQncyBsaWtlIGEgYHVzZVN0YXRlYC1gdXNlRWZmZWN0YCBtYXNodXA6XHJcbiAqIFxyXG4gKiAxLiBJdCdzIGxpa2UgYHVzZVN0YXRlYCwgZXhjZXB0IHRoaXMgdmVyc2lvbiBvZiBgc2V0U3RhdGVgIGRvZXNuJ3QgcmUtcmVuZGVyIHRoZSB3aG9sZSBjb21wb25lbnRcclxuICogMi4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB5b3UgY2FuIHJ1biBhIGZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgdGhhdCBvcHRpb25hbGx5IHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uXHJcbiAqIDMuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHlvdSB0cmlnZ2VyIHRoZSBlZmZlY3QgZnVuY3Rpb24gXCJyZW1vdGVseVwiIGluc3RlYWQgb2YgaXQgcnVubmluZyBhZnRlciByZW5kZXJpbmdcclxuICogNC4gSXQncyBsaWtlIGB1c2VFZmZlY3RgLCBleGNlcHQgdGhlIHNpbmdsZSBcImRlcGVuZGVuY3lcIiBpcyBiYXNlZCBvbiB5b3VyIGNhbGxzIHRvIGBzZXRTdGF0ZWBcclxuICogXHJcbiAqIE5vdGUgdGhhdCB3aGlsZSBjYWxsaW5nIGBzZXRTdGF0ZWAgZG9lc24ndCBjYXVzZSBhbnkgcmUtcmVuZGVycywgeW91IGNhbiBkbyB0aGF0IHdpdGhpbiB5b3VyIGBvbkNoYW5nZWAgZnVuY3Rpb24sIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgY2hhbmdlcyB2aWEgdGhhdCBgc2V0U3RhdGVgLlxyXG4gKiBcclxuICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBcImVmZmVjdFwiIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBgdXNlRWZmZWN0YCdzIFwiZWZmZWN0XCIgZnVuY3Rpb24uICBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxyXG4gKiBAcGFyYW0gZ2V0SW5pdGlhbFZhbHVlIElmIHByb3ZpZGVkLCB0aGUgZWZmZWN0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHdpdGggdGhpcyB2YWx1ZSBvbiBtb3VudC4gTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cclxuICogQHBhcmFtIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nIEJ5IGRlZmF1bHQsIGNoYW5nZXMgdG8gcGFzc2l2ZSBzdGF0ZSBhcmUgZGVsYXllZCBieSBvbmUgdGljayBzbyB0aGF0IHdlIG9ubHkgY2hlY2sgZm9yIGNoYW5nZXMgaW4gYSBzaW1pbGFyIHdheSB0byBQcmVhY3QuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyB0bywgZm9yIGV4YW1wbGUsIGFsd2F5cyBydW4gaW1tZWRpYXRlbHkgaW5zdGVhZC5cclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUGFzc2l2ZVN0YXRlPFQ+KG9uQ2hhbmdlOiB1bmRlZmluZWQgfCBudWxsIHwgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4sIGdldEluaXRpYWxWYWx1ZT86ICgpID0+IFQsIGN1c3RvbURlYm91bmNlUmVuZGVyaW5nPzogdHlwZW9mIGRlYm91bmNlUmVuZGVyaW5nKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xyXG5cclxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcclxuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcpO1xyXG5cclxuICAgIC8vIFNoYXJlZCBiZXR3ZWVuIFwiZGVwZW5kZW5jeSBjaGFuZ2VkXCIgYW5kIFwiY29tcG9uZW50IHVubW91bnRlZFwiLlxyXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXBDYWxsYmFjayA9IGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmIChjbGVhbnVwQ2FsbGJhY2spXHJcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxyXG4gICAgLy8gdmFsdWUgaW4gcGxhY2Ugb2YgaGF2aW5nIG5vIHZhbHVlIGF0IGFsbCB5ZXQuXHJcbiAgICAvLyBUaGlzIGlzIHRoZSBzaGFyZWQgY29kZSBmb3IgdGhhdCwgdXNlZCBvbiBtb3VudCBhbmQgd2hlbmV2ZXJcclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cclxuICAgIGNvbnN0IHRyeUVuc3VyZVZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCAmJiBnZXRJbml0aWFsVmFsdWUgIT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsVmFsdWUgPSBnZXRJbml0aWFsVmFsdWUoKTtcclxuICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBpbml0aWFsVmFsdWU7XHJcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkKSA/PyB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChleCkge1xyXG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIGlmICh3YXJuaW5nUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkR1cmluZyBvbkNoYW5nZSwgcHJlZmVyIHVzaW5nIHRoZSAodmFsdWUsIHByZXZWYWx1ZSkgYXJndW1lbnRzIGluc3RlYWQgb2YgZ2V0VmFsdWUgLS0gaXQncyBhbWJpZ3VvdXMgYXMgdG8gaWYgeW91J3JlIGFza2luZyBmb3IgdGhlIG9sZCBvciBuZXcgdmFsdWUgYXQgdGhpcyBwb2ludCBpbiB0aW1lIGZvciB0aGlzIGNvbXBvbmVudC5cIik7XHJcblxyXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIHdlIGNhbGwgZ2V0VmFsdWUsIGlmIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBhIHZhbHVlIHlldCxcclxuICAgICAgICAvLyAoYW5kIHdlIHdlcmUgZ2l2ZW4gYW4gaW5pdGlhbCB2YWx1ZSB0byB1c2UpXHJcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cclxuICAgICAgICBpZiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQpXHJcbiAgICAgICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XHJcblxyXG4gICAgICAgIHJldHVybiAodmFsdWVSZWYuY3VycmVudCA9PT0gVW5zZXQgPyB1bmRlZmluZWQhIDogdmFsdWVSZWYuY3VycmVudCEpIGFzIFQ7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICAvLyBNYWtlIHN1cmUgd2UndmUgcnVuIG91ciBlZmZlY3QgYXQgbGVhc3Qgb25jZSBvbiBtb3VudC5cclxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXHJcbiAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcclxuXHJcblxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXHJcbiAgICBjb25zdCByID0gdXNlUmVmKHsgcHJldkRlcDogVW5zZXQgYXMgVCB8ICh0eXBlb2YgVW5zZXQpIH0pO1xyXG4gICAgY29uc3Qgc2V0VmFsdWUgPSB1c2VDYWxsYmFjazxQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+PigoYXJnKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIFJlZ2FyZGxlc3Mgb2YgYW55dGhpbmcgZWxzZSwgZmlndXJlIG91dCB3aGF0IG91ciBuZXh0IHZhbHVlIGlzIGFib3V0IHRvIGJlLlxyXG4gICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IChhcmcgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IGFyZyh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCA6IHZhbHVlUmVmLmN1cnJlbnQpIDogYXJnKTtcclxuXHJcblxyXG4gICAgICAgIGlmIChyLmN1cnJlbnQucHJldkRlcCA9PT0gVW5zZXQgJiYgbmV4dFZhbHVlICE9PSB2YWx1ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXHJcbiAgICAgICAgICAgIC8vIEV2YWx1YXRlIHRoZSByZXF1ZXN0IGltbWVkaWF0ZWx5LCB0aGVuIHF1ZXVlIHVwIHRoZSBvbkNoYW5nZSBmdW5jdGlvblxyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcclxuICAgICAgICAgICAgLy8gKGlmIHdlIGZsaXAgYmFjayB0byB0aGlzIHN0YXRlLCB0aGVuIHdlIHdvbid0IHNlbmQgdGhlIG9uQ2hhbmdlIGZ1bmN0aW9uKVxyXG4gICAgICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQ7XHJcblxyXG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgYWN0dWFsIGNoZWNrIGFuZCBpbnZvY2F0aW9uIG9mIG9uQ2hhbmdlIGxhdGVyIHRvIGxldCBlZmZlY3RzIHNldHRsZVxyXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5leHREZXAgPSB2YWx1ZVJlZi5jdXJyZW50ISBhcyBUO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkRlcCA9IHIuY3VycmVudC5wcmV2RGVwIDtcclxuICAgICAgICAgICAgICAgIGlmIChyLmN1cnJlbnQucHJldkRlcCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCBhbnkgcmVnaXN0ZXJlZCBjbGVhbnVwIGZ1bmN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvdWxkQ2xlYW5VcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKG5leHREZXAsIHByZXZEZXAgPT09IFVuc2V0PyB1bmRlZmluZWQgOiBwcmV2RGVwKSA/PyB1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gbmV4dERlcDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSB1c2VyIHRvIG5vcm1hbGx5IGNhbGwgZ2V0VmFsdWUgYWdhaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgd2FybmluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBmaW5pc2hlZCB3aXRoIGV2ZXJ5dGhpbmcsIHNvIG1hcmsgdXMgYXMgYmVpbmcgb24gYSBjbGVhbiBzbGF0ZSBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgIHIuY3VycmVudC5wcmV2RGVwID0gVW5zZXQ7XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdmFsdWUgaW1tZWRpYXRlbHkuXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCBwcmV2RGVwIHRvIHNlZSBpZiB3ZSBzaG91bGQgYWN0dWFsbHkgY2FsbCBvbkNoYW5nZVxyXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XHJcblxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiBbZ2V0VmFsdWUsIHNldFZhbHVlXSBhcyBjb25zdDtcclxufVxyXG5cclxuY29uc3QgVW5zZXQgPSBTeW1ib2woKTtcclxuXHJcbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcclxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblRydWUoKSB7IHJldHVybiB0cnVlOyB9XHJcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5GYWxzZSgpIHsgcmV0dXJuIGZhbHNlOyB9XHJcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuVW5kZWZpbmVkKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XHJcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5aZXJvKCkgeyByZXR1cm4gMDsgfSIsIlxyXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHJldHVyblRydWUsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuXHJcblxyXG4vKipcclxuICogXHJcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCB3YXlzIHRoYXQgYSBmb2N1cyBldmVudCBjYW4gaGFwcGVuLiAgQXNzdW1lXHJcbiAqIHRoZSBmb2xsb3dpbmcgc3RlcHMgaGFwcGVuIGluIG9yZGVyOlxyXG4gKiBcclxuICogMS4gVGhlIHBhZ2UgbG9hZHMuXHJcbiAqICAgICogTm90aGluZyBpcyBmb2N1c2VkLCBidXQgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGBib2R5YC4gXHJcbiAqICAgICogTm8gZm9jdXMgZXZlbnRzIGFyZSBmaXJlZC5cclxuICogMi4gVGhlIHdpbmRvdyBpcyBmb2N1c2VkLCBhbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIHJlbWFpbnMgYXMgYGJvZHlgLlxyXG4gKiAgICAqIEEgYGZvY3VzYC9gZm9jdXNpbmAgZXZlbnQgKk1JR0hUKiBiZSBmaXJlZCBmb3IgYGJvZHlgLiBEZXBlbmRpbmcgb25cclxuICogICAgICB0aGUgYnJvd3NlciwgdGhpcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGhhbmRsZXIgd2FzIGF0dGFjaGVkIHRvIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXHJcbiAqICAgICAgUHJvYmFibHkganVzdCBiZXN0IHRvIG5vdCByZWx5IG9uIGl0LCBvciBsaXN0ZW4gdG8gYHdpbmRvd2AgZm9jdXMgZXZlbnRzIGRpcmVjdGx5LlxyXG4gKiAzLiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgbmV3IGVsZW1lbnQgYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxyXG4gKiAgICAqIGBmb2N1c291dGAgYW5kIGBibHVyYCBhcmUgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxyXG4gKiAgICAqIGBmb2N1c2AgYW5kIGBmb2N1c2luYCBhcmUgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cclxuICogNC4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXHJcbiAqICAgICogKipUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgYGJvZHlgKiogYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxyXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG5ldyBlbGVtZW50LlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgbm93IHNldCB0byB0aGUgbmV3IGVsZW1lbnQuXHJcbiAqICAgICogYGZvY3VzaW5gIGlzIGZpcmVkIG9uIHRoZSBuZXcgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIHRoZSBvbGQgZWxlbWVudC5cclxuICogNS4gQW4gdW5mb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCB0ZXh0IGlzIHNlbGVjdGVkLCBldGMuXHJcbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gYGJvZHlgLlxyXG4gKiAgICAqIGBibHVyYCBhbmQgYGZvY3Vzb3V0YCBhcmUgZmlyZWQgb24gdGhlIG9sZCBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbC5cclxuICogICAgKiBgZm9jdXNpbmAgaXMgKm5vdCogZmlyZWQgb24gYGJvZHlgLlxyXG4gKiBcclxuICogXHJcbiAqIEluIHN1bW1hcnk6XHJcbiAqIDEuIEZvY3VzIGV2ZW50cyAqZG8qIG5vdGlmeSB1cyBvZiBhbGwgY2hhbmdlcyBpbiBmb2N1cywgYnV0IHRoZXJlIGlzIG5vIG9uZSBzaW5nbGUgY29tcHJlaGVuc2l2ZSBldmVudCB0aGF0IHByb3ZpZGVzIHVzIHdpdGggYWxsIGF2YWlsYWJsZSBpbmZvcm1hdGlvbi5cclxuICogMi4gYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgICppcyBub3QqIGFsd2F5cyB0aGUgc2FtZSBhcyB3aGF0J3MgYmVpbmcgcmVmZXJlbmNlZCBieSBhIGZvY3VzIGV2ZW50LiBJbiBwYXJ0aWN1bGFyLCBpdCBtYXkgYmVjb21lIGBib2R5YCBhdCBhbnkgYXJiaXRyYXJ5IHRpbWUuXHJcbiAqIDMuIEEgYGJsdXJgIHdpdGhvdXQgYSBgZm9jdXNgIGNhbiBhbmQgd2lsbCBvY2N1ci4gVGhpcyBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gc29sZWx5IHVzZSBgZm9jdXNgIHRvIGRldGVjdCBhbGwgY2hhbmdlcy5cclxuICogNC4gQSBgYmx1cmAgZXZlbnQgd2hvc2UgYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBmb2xsb3dpbmcgYGZvY3VzYCBldmVudC5cclxuICogXHJcbiAqL1xyXG5jb25zdCBfZHVtbXkgPSAwO1xyXG5cclxuaW50ZXJmYWNlIEZvbzxUPiB7XHJcbiAgICBsYXN0U2VudDogVCB8IHVuZGVmaW5lZDtcclxuICAgIHNlbmQ6IChlOiBUKSA9PiB2b2lkO1xyXG59XHJcbi8qXHJcbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSB8IG51bGwpID0+IHZvaWQpPj4oKTtcclxuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZTogTm9kZSkgPT4gdm9pZCk+PigpO1xyXG5jb25zdCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHZvaWQpPj4oKTtcclxuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTsqL1xyXG5jb25zdCBhY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Tm9kZSB8IG51bGw+Pj4oKTtcclxuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxOb2RlPj4+KCk7XHJcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxib29sZWFuPj4+KCk7XHJcbmNvbnN0IHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIGJvb2xlYW4+KCk7XHJcblxyXG4vL2NvbnN0IG1pY3JvdGFza3MgPSBuZXcgTWFwPFNldDxhbnk+LCBhbnk+KCk7XHJcblxyXG4vLyBUaGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIG9mdGVuIGZpcmUgc3luY3Jvbm91c2x5IGluIHRoZSBtaWRkbGUgb2YgcnVubmluZyBjb2RlLlxyXG4vLyBFLkcuIGNhbGxpbmcgZWxlbWVudC5mb2N1cygpIGNhbiBjYXVzZSBhIGZvY3VzaW4gZXZlbnQgaGFuZGxlciB0byBpbW1lZGlhdGVseSBpbnRlcnJ1cHQgdGhhdCBjb2RlLlxyXG4vLyBGb3IgdGhlIHB1cnBvc2Ugb2YgaW1wcm92aW5nIHN0YWJpbGl0eSwgd2UgZGVib3VuY2UgYWxsIGZvY3VzIGV2ZW50cyB0byB0aGUgbmV4dCBtaWNyb3Rhc2suXHJcbmZ1bmN0aW9uIGZvckVhY2hVcGRhdGVyPFQ+KHdpbmRvdzogV2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgbWFwOiBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxUPj4+LCB2YWx1ZTogVCkge1xyXG4gICAgY29uc3QgdXBkYXRlcnMgPSBtYXAuZ2V0KHdpbmRvdyk7XHJcbiAgICBpZiAodXBkYXRlcnMpIHtcclxuICAgICAgICAvL2lmICghbWljcm90YXNrcy5oYXModXBkYXRlcnNLZXkpKSB7XHJcbiAgICAgICAgLy9kZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XHJcbiAgICAgICAgLy9jb25zdCB1cGRhdGVyc0tleSA9IG1hcC5nZXQod2luZG93KSE7XHJcbiAgICAgICAgLy9jb25zdCB2YWx1ZSA9IG1pY3JvdGFza3MuZ2V0KHVwZGF0ZXJzS2V5KTtcclxuICAgICAgICAvL21pY3JvdGFza3MuZGVsZXRlKHVwZGF0ZXJzS2V5KTtcclxuXHJcbiAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgdXBkYXRlciBvZiB1cGRhdGVycykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyBsYXN0U2VudCwgc2VuZCB9ID0gdXBkYXRlcjtcclxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFNlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZW5kKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyLmxhc3RTZW50ID0gdmFsdWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vfSk7XHJcbiAgICAgICAgLy99XHJcblxyXG4gICAgICAgIC8vbWljcm90YXNrcy5zZXQodXBkYXRlcnNLZXksIHZhbHVlKTtcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZm9jdXNvdXQoZTogRm9jdXNFdmVudCkge1xyXG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcblxyXG4gICAgaWYgKGUucmVsYXRlZFRhcmdldCA9PSBudWxsKSB7XHJcbiAgICAgICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIG51bGwpO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLy8gSnVzdCB3YWl0IGZvciB0aGUgZm9jdXNpbiBldmVudC5cclxuICAgIH1cclxuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3VzaW4oZTogRm9jdXNFdmVudCkge1xyXG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XHJcbiAgICBjb25zdCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCA9IGUudGFyZ2V0IGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCk7XHJcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIGFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xyXG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKGU6IEZvY3VzRXZlbnQpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUudGFyZ2V0IDogZS5jdXJyZW50VGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS5jdXJyZW50VGFyZ2V0IDogKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpO1xyXG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCB0cnVlKTtcclxuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCB0cnVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gd2luZG93Qmx1cihlOiBGb2N1c0V2ZW50KSB7XHJcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcclxuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgZmFsc2UpO1xyXG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIGZhbHNlKTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuIE11c3QgYmUgc3RhYmxlLlxyXG4gICAgICovXHJcbiAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50IHwgbnVsbD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMgYW5kIGlzIG5vdCBudWxsLiBcclxuICAgICAqIE11c3QgYmUgc3RhYmxlLlxyXG4gICAgICovXHJcbiAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIHdpbmRvdyBnYWlucy9sb3NlcyBmb2N1cy4gTXVzdCBiZSBzdGFibGUuXHJcbiAgICAgKi9cclxuICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPGJvb2xlYW4+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtdXN0IGJlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSBkb2N1bWVudCBhc3NvY2lhdGVkIHdpdGggd2hhdGV2ZXIgZWxlbWVudHMgd2UncmUgbGlzdGVuaW5nIHRvLlxyXG4gICAgICogXHJcbiAgICAgKiBFLkcuIHNvbWVEaXZFbGVtZW50Lm93bmVyRG9jdW1lbnRcclxuICAgICAqIFxyXG4gICAgICogKipNVVNUKiogYmUgc3RhYmxlXHJcbiAgICAgKi9cclxuICAgIGdldERvY3VtZW50KCk6IERvY3VtZW50O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQnkgZGVmYXVsdCwgZXZlbnQgaGFuZGxlcnMgYXJlIGF0dGFjaGVkIHRvIHRoZSBkb2N1bWVudCdzIGRlZmF1bHRWaWV3IFdpbmRvdy5cclxuICAgICAqIElmIHlvdSBuZWVkIHNvbWV0aGluZyBkaWZmZXJlbnQsIG92ZXJyaWRlIGl0IGhlcmUuXHJcbiAgICAgKiBcclxuICAgICAqICoqTVVTVCoqIGJlIHN0YWJsZVxyXG4gICAgICovXHJcbiAgICBnZXRXaW5kb3c/KGRvY3VtZW50OiBEb2N1bWVudCk6IFdpbmRvdztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIGBudWxsYCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICBnZXRBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50IHwgbnVsbDtcclxuICAgIC8qKiBcclxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3Igd2hhdGV2ZXIgZWxlbWVudCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGdldExhc3RBY3RpdmVFbGVtZW50OiAoKSA9PiBFbGVtZW50O1xyXG4gICAgLyoqIFxyXG4gICAgICogUmV0dXJucyBpZiB0aGUgd2luZG93IGl0c2VsZiBoYXMgZm9jdXMgb3Igbm90XHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgeW91IHRvIGluc3BlY3Qgd2hpY2ggZWxlbWVudCBpbiB0aGUgYGRvY3VtZW50YCBjdXJyZW50bHkgaGFzIGZvY3VzLCB3aGljaCB3YXMgbW9zdCByZWNlbnRseSBmb2N1c2VkIGlmIG5vbmUgYXJlIGN1cnJlbnRseSwgYW5kIHdoZXRoZXIgb3Igbm90IHRoZSB3aW5kb3cgaGFzIGZvY3VzIGJ5IHJldHVybmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcclxuICogKiBgZ2V0QWN0aXZlRWxlbWVudCgpYFxyXG4gKiAqIGBnZXRMYXN0QWN0aXZlRWxlbWVudCgpYFxyXG4gKiAqIGBnZXRXaW5kb3dGb2N1c2VkKClgXHJcbiAqIFxyXG4gKiAoVGhlIGRvY3VtZW50J3MgYm9keSByZWNlaXZpbmcgZm9jdXMsIGxpa2UgaXQgZG9lcyB3aGVuIHlvdSBjbGljayBvbiBhbiBlbXB0eSBhcmVhLCBpcyBjb3VudGVkIGFzIG5vIGVsZW1lbnQgaGF2aW5nIGZvY3VzIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMpXHJcbiAqIFxyXG4gKiBUaGlzIGlzIGEgcGFzc2l2ZSBob29rLCBzbyBieSBkZWZhdWx0IGl0IHJldHVybnMgZ2V0dGVyIGZ1bmN0aW9ucyB0aGF0IHJlcG9ydCB0aGlzIGluZm9ybWF0aW9uIGJ1dCB0aGUgY29tcG9uZW50IHdpbGwgbm90IHJlLXJlbmRlciBieSBkZWZhdWx0IHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuXHJcbiAqIFxyXG4gKiBJZiB5b3UgbmVlZCB0aGUgY29tcG9uZW50IHRvIHJlLXJlbmRlciB3aGVuIHRoZSBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzLCB1c2UgdGhlIGBvbipDaGFuZ2VgIGFyZ3VtZW50cyB0byBzZXQgc29tZSBzdGF0ZSBvbiB5b3VyIGVuZC5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cgfTogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMpOiBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlQWN0aXZlRWxlbWVudFwiLCBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uV2luZG93Rm9jdXNlZENoYW5nZSwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdyk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KCk7XHJcbiAgICAgICAgY29uc3Qgd2luZG93ID0gKGdldFdpbmRvdz8uKGRvY3VtZW50KSA/PyBkb2N1bWVudD8uZGVmYXVsdFZpZXcpO1xyXG5cclxuICAgICAgICBpZiAoKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KT8uc2l6ZSA/PyAwKSA9PT0gMCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzLCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQWRkIHRoZW0gZXZlbiBpZiB0aGV5J3JlIHVuZGVmaW5lZCB0byBtb3JlIGVhc2lseVxyXG4gICAgICAgIC8vIG1hbmFnZSB0aGUgXCI+MCBtZWFucyBkb24ndCBhZGQgaGFuZGxlcnNcIiBsb2dpYy5cclxuICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMgPSB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuZ2V0KHdpbmRvdykgPz8gbmV3IFNldCgpO1xyXG5cclxuICAgICAgICBjb25zdCBsYWV1ID0geyBzZW5kOiBzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4sIGxhc3RTZW50OiB1bmRlZmluZWQgfVxyXG4gICAgICAgIGNvbnN0IGxsYWV1ID0geyBzZW5kOiBzZXRMYXN0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZT4sIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcclxuICAgICAgICBjb25zdCBsd2Z1ID0geyBzZW5kOiBzZXRXaW5kb3dGb2N1c2VkLCBsYXN0U2VudDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgICAgIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzLmFkZChsYWV1KTtcclxuICAgICAgICBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuYWRkKGxsYWV1KTtcclxuICAgICAgICBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycy5hZGQobHdmdSk7XHJcblxyXG4gICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyk7XHJcbiAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xyXG4gICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycyk7XHJcblxyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGxhZXUpO1xyXG4gICAgICAgICAgICBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUobGFldSk7XHJcbiAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGx3ZnUpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zaXplID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0KTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHdpbmRvd0ZvY3VzKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCBbZ2V0QWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudCB8IG51bGw+KG9uQWN0aXZlRWxlbWVudENoYW5nZSwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIHNldExhc3RBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50Pihvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsIGFzICgpID0+IG5ldmVyKTtcclxuICAgIGNvbnN0IFtnZXRXaW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIHJldHVyblRydWUpO1xyXG5cclxuICAgIHJldHVybiB7IGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuXHJcbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XHJcblxyXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xyXG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXHJcbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxyXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxyXG4gKiBcclxuICogXHJcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcclxuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxyXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcclxufVxyXG5cclxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xyXG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcclxuXHJcblxyXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcclxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxyXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xyXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxyXG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cclxuLy8gXHJcbi8vIEFsc28gaXQncyBwcml2YXRlLlxyXG4vL1xyXG4vLyAuLi5cclxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxyXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXHJcbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXHJcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXHJcbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xyXG5cclxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcclxuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcclxuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcclxuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcclxuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9SdW4uY2xlYXIoKTtcclxuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XHJcbn1cclxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxyXG5cclxuLyoqXHJcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cclxuICogXHJcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXHJcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XHJcblxyXG4gICAgLyooKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xyXG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xyXG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XHJcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKCk7Ki9cclxuXHJcbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcclxuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lkXSlcclxufVxyXG5cclxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuICEhKFxyXG4gICAgICAgICFvbGRBcmdzIHx8XHJcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxyXG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHJpbW1lZEVuZEluZGV4O1xuIiwiaW1wb3J0IHRyaW1tZWRFbmRJbmRleCBmcm9tICcuL190cmltbWVkRW5kSW5kZXguanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUcmltO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBiYXNlVHJpbSBmcm9tICcuL19iYXNlVHJpbS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b051bWJlcjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBub3cgZnJvbSAnLi9ub3cuanMnO1xuaW1wb3J0IHRvTnVtYmVyIGZyb20gJy4vdG9OdW1iZXIuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVib3VuY2U7XG4iLCJpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRocm90dGxlO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiXHJcbmltcG9ydCBkZWJvdW5jZSwgeyBEZWJvdW5jZWRGdW5jLCB0eXBlIERlYm91bmNlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL2RlYm91bmNlXCI7XHJcbmltcG9ydCB0aHJvdHRsZSwgeyB0eXBlIFRocm90dGxlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL3Rocm90dGxlXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG50eXBlIEZ1bmMgPSAoLi4uYXJnczogYW55KSA9PiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93bjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNQYXJhbWV0ZXJzPEFQIGV4dGVuZHMgdW5rbm93bltdLCBTUCBleHRlbmRzIHVua25vd25bXSA9IEFQPiB7XHJcbiAgICAvKipcclxuICAgICAqIElmIHByb3ZpZGVkLCBhZGRzIGEgZGVib3VuY2UgYmVoYXZpb3IgKmluIGFkZGl0aW9uKiB0b1xyXG4gICAgICogdGhlIGRlZmF1bHQgXCJ3YWl0IHVudGlsIHJlc29sdmVkXCIgdGhyb3R0bGluZyBiZWhhdmlvci5cclxuICAgICAqL1xyXG4gICAgZGVib3VuY2U/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBgdXNlQXN5bmNgIHdpdGggYXV0by10aHJvdHRsZSBiYXNlZCBvbiBob3cgbG9uZyBpdCB0YWtlc1xyXG4gICAgICogZm9yIHRoZSBvcGVyYXRpb24gdG8gY29tcGxldGUuICBJZiB5b3Ugd291bGQgbGlrZSB0aGVyZSB0byBiZSBhXHJcbiAgICAgKiBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGFsbG93aW5nIGEgc2Vjb25kIG9wZXJhdGlvbixcclxuICAgICAqIHRoZSBgdGhyb3R0bGVgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBhZGRpdGlvbiB0byB0aGF0IGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICB0aHJvdHRsZT86IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYW4gYXN5bmMgZnVuY3Rpb24gaXMgZGVib3VuY2VkIGR1ZSB0byBvbmUgYWxyZWFkeSBydW5uaW5nLFxyXG4gICAgICogaXQgd2lsbCBydW4gb24gYSBkZWxheSBhbmQsIGFzIGEgcmVzdWx0LCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXHJcbiAgICAgKiB0aGF0IHdlcmUgcGFzc2VkIHRvIGl0IG1heSBuZWVkIHRvIGJlIGFkanVzdGVkIHRvIGFjY291bnQgZm9yIHRoYXQuXHJcbiAgICAgKiBcclxuICAgICAqIEZvciBleGFtcGxlLCBkdXJpbmcgYG9uSW5wdXRgLCB0aGUgYHZhbHVlYCBvZiB0aGF0IGV2ZW50IGlzbid0IHN0b3JlZFxyXG4gICAgICogaW4gdGhlIGV2ZW50IGl0c2VsZiwgaXQncyBzdG9yZWQgaW4gdGhlIGBIVE1MSW5wdXRFbGVtZW50YCB0aGF0IHJhaXNlZCBpdC5cclxuICAgICAqIFNvIHdoZW4gb3VyIGhhbmRsZXIgYWN0dWFsbHkgcnVucyBhIGZldyBzZWNvbmRzIGxhdGVyLCBpdCdsbCByZWFkIHRoZSAqKm5leHQqKlxyXG4gICAgICogYGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWVgLCBpbnN0ZWFkIG9mIHRoZSBvbmUgZnJvbSBhIGZldyBzZWNvbmRzIGFnbyBcclxuICAgICAqIHRoYXQgYWN0dWFsbHkgcmFpc2VkIHRoZSBldmVudCFcclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGFyZ3VtZW50cyB0byB5b3VyIGhhbmRsZXIgcmVxdWlyZSByZWZlcmVuY2luZyBkYXRhIGluIHRoZSBhcmd1bWVudHNcclxuICAgICAqIHRoYXQgbWF5IGJlY29tZSBcInN0YWxlXCIgYnkgdGhlIHRpbWUgdGhlIGZ1bmN0aW9uIGFjdHVhbGx5IHJ1bnMgKGdlbmVyYWxseSBldmVudFxyXG4gICAgICogaGFuZGxlcnMgYW5kIG90aGVyIHRoaW5ncyB0aGF0IHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiBleGlzdGluZyBvYmplY3RzKSxcclxuICAgICAqIHRoZSBgY2FwdHVyZWAgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwYXJhbWV0ZXJzIHlvdSB3ZXJlIGdpdmVuXHJcbiAgICAgKiB3aGVuIHRoZSByZXF1ZXN0IHRvIHJ1biB3YXMgaW5pdGlhbGx5IG1hZGUgaW50byBwYXJhbWV0ZXJzIHRoYXQgeW91IGhhdmVcclxuICAgICAqIGd1YXJhbnRlZWQgd2lsbCBzdGlsbCBiZSBnb29kIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGFjdHVhbGx5IHJ1bnMuXHJcbiAgICAgKi9cclxuICAgIGNhcHR1cmU/OiBDYXB0dXJlRnVuY3Rpb25UeXBlPEFQLCBTUD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNSZXR1cm5UeXBlPFNQIGV4dGVuZHMgdW5rbm93bltdLCBSPiB7XHJcblxyXG4gICAgLy9wcm9taXNlOiBQcm9taXNlPEF3YWl0ZWQ8UmV0dXJuVHlwZTxGPj4+IHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYSBoYW5kbGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcsIHRoaXMgaXMgdHJ1ZS5cclxuICAgICAqIFxyXG4gICAgICogSXQgaXMgZmFsc2UgYmVmb3JlIHRoZSBmaXJzdCBleGVjdXRpb24sIHRydWUgZHVyaW5nIHRoZVxyXG4gICAgICogZmlyc3QgZXhlY3V0aW9uLCByZW1haW5zIHRydWUgaWYgY29udGludWluZyBpbW1lZGlhdGVseVxyXG4gICAgICogaW50byBhIHNlY29uZCwgYW5kIG9ubHkgcmV0dXJucyB0byBmYWxzZSB3aGVuIGEgaGFuZGxlclxyXG4gICAgICogY29tcGxldGVzIHdpdGggbm8gaGFuZGxlciBpbiB3YWl0aW5nLlxyXG4gICAgICovXHJcbiAgICBwZW5kaW5nOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgcnVuLlxyXG4gICAgICogRG9lcyBub3QgaW5jbHVkZSB0aW1lcyB3aGVyZSBpdCB3YXMgdGhyb3R0bGVkIG9yIGRlYm91bmNlZCBhd2F5LlxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgZm9yIGtub3dpbmcgaWYgdGhlIGhhbmRsZXIgaGFzIGJlZW4gY2FsbGVkIHlldCwgb3IgZm9yXHJcbiAgICAgKiBzZXR0aW5nIGEgbmV3IHRpbWVvdXQgdG8gc2hvdyBhIHNwaW5uZXIuXHJcbiAgICAgKi9cclxuICAgIGNhbGxDb3VudDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgc2V0dGxlZFxyXG4gICAgICogKHJlc29sdmVkIG9yIHJlamVjdGVkKSwgc2ltaWxhcmx5IHRvIGBjYWxsQ291bnRgLlxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgZm9yIGtub3dpbmcgaWYgdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBldmVuIG9uY2UgeWV0LFxyXG4gICAgICogb3IganVzdCBmb3Igd2hlbiB0aGUgaGFuZGxlciBoYXMgZmluaXNoZWRcclxuICAgICAqL1xyXG4gICAgc2V0dGxlQ291bnQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIFxyXG4gICAgICogc2ltaWxhcmx5IHRvIGBzZXR0bGVDb3VudGAuXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVDb3VudDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGZhaWxlZCB0byBjb21wbGV0ZSwgXHJcbiAgICAgKiBzaW1pbGFybHkgdG8gYHJlc29sdmVDb3VudGAuXHJcbiAgICAgKi9cclxuICAgIHJlamVjdENvdW50OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IHJldHVybmVkIGZyb20gYSBzdWNjZXNzZnVsIGhhbmRsZXIgaW52b2NhdGlvbixcclxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiBubyBoYW5kbGVyIGhhcyBzdWNjZXNzZnVsbHkgcmV0dXJuZWQgeWV0LlxyXG4gICAgICogXHJcbiAgICAgKiBJZiB0aGUgaGFuZGxlciByZWplY3RzIGFmdGVyIGhhdmluZyBzdWNjZWVkZWQgcHJldmlvdXNseSwgdGhlblxyXG4gICAgICogYHJlc3VsdGAgd2lsbCBzdGlsbCBrZWVwIGl0cyB2YWx1ZTsgaXQgd29uJ3QgYmUgXCJlcmFzZWRcIiBkdWUgdG8gdGhlIGVycm9yLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGByZXN1bHRgIGFuZCBgZXJyb3JgIGNhbiBib3RoIGJlIHBvcHVsYXRlZCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIGhhc1Jlc3VsdCBmb3IgaWYgYHJlc3VsdGAgYmVpbmcgYHVuZGVmaW5lZGAgbWVhbnMgaXQncyB1bmZpbmlzaGVkIG9yIHRoZSBmdW5jdGlvbiBpdHNlbGYgcmV0dXJuZWQgYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIHJlc3VsdDogUiB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydWUgd2hlbiB0aGUgbW9zdCByZWNlbnRseS1ydW4gaGFuZGxlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LFxyXG4gICAgICogYWxzbyBtZWFuaW5nIHRoYXQgdGhhdCBpdCdzIHJldHVybmVkIGEgdmFsdWUgdGhhdCB3ZSBjdXJyZW50bHkgaGF2ZS5cclxuICAgICAqIFxyXG4gICAgICogV2hpbGUgYHBlbmRpbmdgIGlzIHRydWUsICoqYGhhc1Jlc3VsdGAgYW5kIGBoYXNFcnJvcmAgbWF5IGJlIHNpbXVsdGFuZW91c2x5IHRydWUqKixcclxuICAgICAqIGJ1dCBpbiBhbGwgb3RoZXIgY2FzZXMgdGhleSdyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGhhc1Jlc3VsdDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlcnJvciB0aGUgaGFuZGxlciB0aHJldy4gYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB0aG91Z2ggbm90ZVxyXG4gICAgICogdGhhdCBgdW5kZWZpbmVkYCBpcyBhIHZhbGlkIHRoaW5nIHRvIHRocm93LCBzbyBjaGVjayBgaGFzRXJyb3JgIHRvby5cclxuICAgICAqIFxyXG4gICAgICogQHNlZSBoYXNFcnJvclxyXG4gICAgICovXHJcbiAgICBlcnJvcjogdW5rbm93bjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb3N0IHJlY2VudCBoYW5kbGVyIGZpbmlzaGVkIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UsIHRlY2huaWNhbGx5LCBgZXJyb3JgIGNhbiBiZSBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgaGFzRXJyb3I6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSBhbnkgY3VycmVudGx5IGRlYm91bmNlZC1idXQtZXZlbnR1YWxseS1wZW5kaW5nIHByb21pc2VzIHRvIGltbWVkaWF0ZWx5IGJlIGNvbnNpZGVyZWQgYnkgY2FuY2VsbGluZyB0aGVpciBkZWJvdW5jZSB0aW1lb3V0LFxyXG4gICAgICogeW91IGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uICBOb3JtYWwgcHJvY2VkdXJlIGFwcGxpZXMgYXMgaWYgdGhlIGRlYm91bmNlZCBlbmRlZCBub3JtYWxseSAtLSBpZiB0aGVyZSdzIG5vIHByb21pc2Ugd2FpdGluZyBpbiB0aGUgcXVldWUsXHJcbiAgICAgKiB0aGUgZGVib3VuY2VkIHByb21pc2UgcnVucyBub3JtYWxseSwgb3RoZXJ3aXNlLCBpdCB3YWl0cyBpdHMgdHVybiB1bnRpbCB0aGUgY3VycmVudCBvbmUgZW5kcywgcG90ZW50aWFsbHkgYmVpbmcgb3ZlcndyaXR0ZW4gbGF0ZXIgb25cclxuICAgICAqIGlmIGEgbmV3IHByb21pc2UgcnVucyBvdXQgKml0cyogZGVib3VuY2UgdGltZXIgYmVmb3JlIHRoaXMgb25lIGdvdCBhIGNoYW5jZSB0byBydW4uXHJcbiAgICAgKiBcclxuICAgICAqICoqUXVhc2ktc3RhYmxlKiogKGRvbid0IHVzZSBkdXJpbmcgcmVuZGVyKVxyXG4gICAgICovXHJcbiAgICBmbHVzaERlYm91bmNlZFByb21pc2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlZCBvbiB0aGUgdHlwZSBvZiBoYW5kbGVyIHBhc3NlZCBpbiwgdGhpcyByZXR1cm5lZCB2YWx1ZSB3aWxsXHJcbiAgICAgKiByZXByZXNlbnQgd2hhdCB0eXBlIG9mIGhhbmRsZXIgaXQgd2FzLCBqdXN0IGluIGNhc2UgeW91XHJcbiAgICAgKiB5b3Vyc2VsZiBuZWVkIHRvIGtub3cgdGhhdCBhbmQgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsXHJcbiAgICAgKiB0byBmaW5kIG91dCB3aXRob3V0IGl0IGFjdHVhbGx5IGJlaW5nIHJ1bi5cclxuICAgICAqIFxyXG4gICAgICogVW50aWwgYSBoYW5kbGVyIGlzIGNhbGxlZCwgdGhpcyB3aWxsIGJlIG51bGwuICBOYXR1cmFsbHksIGlmIFxyXG4gICAgICogZGlmZmVyZW50IGhhbmRsZXJzIGFyZSBwYXNzZWQgaW4sIGl0IGNhbiBmbGlwIGJhY2sgYW5kXHJcbiAgICAgKiBmb3J0aCBiZXR3ZWVuIFwiYXN5bmNcIiBhbmQgXCJzeW5jXCIgYXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgY3VycmVudFR5cGU6IG51bGwgfCBcInN5bmNcIiB8IFwiYXN5bmNcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIHRoZSBhc3luYyBoYW5kbGVyIHByb3ZpZGVkLFxyXG4gICAgICogbm93IHN5bmNocm9ub3VzIGFuZC9vciB0aHJvdHRsZWQgYW5kL29yIGRlYm91bmNlZFxyXG4gICAgICogXHJcbiAgICAgKiAqKlF1YXNpLXN0YWJsZSoqIChkb24ndCB1c2UgZHVyaW5nIHJlbmRlcilcclxuICAgICAqL1xyXG4gICAgc3luY0hhbmRsZXI6IFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eTxBUCBleHRlbmRzIHVua25vd25bXSwgU1AgZXh0ZW5kcyB1bmtub3duW10+KC4uLnQ6IFNQKSB7IHJldHVybiB0IGFzIHVua25vd25bXSBhcyBBUDsgfVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbi5cclxuICogXHJcbiAqIElmIHRoZSBjYWxsYmFjayBpcyBgbnVsbGAsIHRoZW4gYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSBgY2FsbGJhY2tgIG11c3QgYmUgc3RhYmxlIGZvciB0aGlzIHRvIHdvcmsgYXMgaW50ZW50ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhyb3R0bGVkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IFRocm90dGxlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhyb3R0bGVkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IFRocm90dGxlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xyXG4gICAgY29uc3QgdGhyb3R0bGVkID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gdGhyb3R0bGUoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcclxuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8udHJhaWxpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0aHJvdHRsZWQ/LmNhbmNlbCgpO1xyXG4gICAgfSwgW3Rocm90dGxlZF0pXHJcblxyXG4gICAgcmV0dXJuIHRocm90dGxlZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYGRlYm91bmNlZGAgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBJZiB0aGUgY2FsbGJhY2sgaXMgYG51bGxgLCB0aGVuIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgYGNhbGxiYWNrYCBtdXN0IGJlIHN0YWJsZSBmb3IgdGhpcyB0byB3b3JrIGFzIGludGVudGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBEZWJvdW5jZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xyXG4gICAgY29uc3QgZGVib3VuY2VkID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gZGVib3VuY2UoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcclxuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8ubWF4V2FpdCwgb3B0aW9ucz8udHJhaWxpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBkZWJvdW5jZWQ/LmNhbmNlbCgpO1xyXG4gICAgfSwgW2RlYm91bmNlZF0pXHJcblxyXG4gICAgcmV0dXJuIGRlYm91bmNlZDtcclxufVxyXG5cclxudHlwZSBTeW5jRnVuY3Rpb25UeXBlPFNQIGV4dGVuZHMgdW5rbm93bltdLCBSPiA9ICguLi5hcmdzOiBTUCkgPT4gKFIgfCB1bmRlZmluZWQpO1xyXG50eXBlIEFzeW5jRnVuY3Rpb25UeXBlPEFQIGV4dGVuZHMgdW5rbm93bltdLCBSPiA9ICgoLi4uYXJnczogQVApID0+IChSIHwgUHJvbWlzZTxSPikpO1xyXG50eXBlIEdsdWVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKGVucXVldWU6IGJvb2xlYW4sIC4uLmFyZ3M6IEFQKSA9PiBSIHwgdW5kZWZpbmVkO1xyXG50eXBlIENhcHR1cmVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+ID0gKC4uLmFyZ3M6IFNQKSA9PiBBUDtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhc3luYyBmdW5jdGlvbiwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQncyBzdWl0YWJsZSBmb3Igbm9uLWFzeW5jIEFQSXMsIFxyXG4gKiBhbG9uZyB3aXRoIG90aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHJ1bidzIHN0YXR1cy5cclxuICogXHJcbiAqIFNlZSBhbHNvIGB1c2VBc3luY0hhbmRsZXJgIGZvciBhIHZlcnNpb24gdGhhdCdzIHNwZWNpYWxpemVkIGZvciBET00gZXZlbnQgaGFuZGxlcnMuXHJcbiAqIFxyXG4gKiBXaGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBxdWljayBzdWNjZXNzaW9uLCAoaS5lLiBiZWZvcmUgdGhlIGhhbmRsZXIgaGFzIGZpbmlzaGVkKSwgXHJcbiAqIHRoaXMgd29ya3MgbGlrZSBMb2Rhc2gncyBgdGhyb3R0bGVgIGZ1bmN0aW9uIHdpdGggdGhlIGB3YWl0YCBvcHRpb24gYWx3YXlzXHJcbiAqIHNldCB0byBob3dldmVyIGxvbmcgdGhlIGhhbmRsZXIgdGFrZXMgdG8gY29tcGxldGUuIEEgc2Vjb25kIGNhbGwgdG8gdGhlIHN5bmMgZnVuY3Rpb24gd2lsbCBiZSBcclxuICogdGhyb3R0bGVkIHVudGlsIHRoZSBmaXJzdCBjYWxsIGhhcyBmaW5pc2hlZC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBcclxuICogb2YgdGhlIHByZXZpb3VzIGludm9jYXRpb24sIG9yIGB1bmRlZmluZWRgIG9uIHRoZSBmaXJzdCBjYWxsLlxyXG4gKiBcclxuICogVGhlIGhhbmRsZXIgaXMgb25seSBldmVyIGRlbGF5ZWQgaWYgb25lIGlzIGN1cnJlbnRseSBydW5uaW5nLCBzbywgZS5nLiBmb3IgaU9TIHRvdWNoIGV2ZW50cyB0aGVcclxuICogZmlyc3QgY2FsbCBoYXBwZW5zIGluIHRoZSBzYW1lIGV2ZW50IGhhbmRsZXIgKHdoaWNoIG1lYW5zIHRoaW5ncyBsaWtlIGNhbGxzIHRvIGBlbGVtZW50LmZvY3VzKClgXHJcbiAqIHdpbGwgd29yayBhcyBpbnRlbmRlZCwgc2luY2UgdGhhdCBmYWlscyB3aGVuIHRoZSBldmVudCBpcyBcInNwbGl0IHVwXCIpXHJcbiAqIFxyXG4gKiBGaW5hbGx5LCBiZWNhdXNlIHRoZSBzeW5jIGhhbmRsZXIgbWF5IGJlIGludm9rZWQgb24gYSBkZWxheSwgYW55IHByb3BlcnR5IHJlZmVyZW5jZXMgb24gdGhlIGFyZ3VtZW50c1xyXG4gKiBwcm92aWRlZCBtaWdodCBiZSBzdGFsZSBieSB0aGUgdGltZSBpdCdzIGFjdHVhbGx5IGludm9rZWQgKGUuZy4gYWNjZXNzaW5nIGBldmVudC5jdXJyZW50VGFyZ2V0LmNoZWNrZWRgXHJcbiAqIGlzIG5vdCBzdGFibGUgYWNyb3NzIHRpbWUgYmVjYXVzZSBpdCdzIGEgXCJsaXZlXCIgdmFsdWUgLS0geW91IGFsbW9zdCBhbHdheXMgd2FudCB0aGUgdmFsdWUgdGhhdCBpdFxyXG4gKiBoYWQgYXQgdGhlIG9yaWdpbmFsIHRpbWUgdGhlIGhhbmRsZXIgd2FzIGNhbGxlZCkuIFRoZSBgY2FwdHVyZWAgb3B0aW9uIGFsbG93cyB5b3UgdG8gc2F2ZSB0aGF0IGtpbmQgb2ZcclxuICogZHluYW1pYyBkYXRhIGF0IHRoZSB0aW1lIGl0IHJ1bnM7IHRoZSBgQVBgIGFuZCBgU1BgIHR5cGUgcGFyYW1ldGVycyBsaWtld2lzZSBjb250cm9sXHJcbiAqIHRoZSBwYXJhbWV0ZXJzIHRoZSBhc3luYyBoYW5kbGVyIGFuZCBzeW5jIGhhbmRsZXIgZXhwZWN0IHJlc3BlY3RpdmVseS5cclxuICogXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFIsIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+KGFzeW5jSGFuZGxlcjogQXN5bmNGdW5jdGlvblR5cGU8QVAsIFI+IHwgbnVsbCwgb3B0aW9ucz86IFVzZUFzeW5jUGFyYW1ldGVyczxBUCwgU1A+KTogVXNlQXN5bmNSZXR1cm5UeXBlPFNQLCBSPiB7XHJcblxyXG5cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xyXG4gICAgbGV0IHsgdGhyb3R0bGUsIGRlYm91bmNlLCBjYXB0dXJlIH0gPSAob3B0aW9ucyA/PyB7fSk7XHJcbiAgICBjYXB0dXJlID8/PSBpZGVudGl0eTtcclxuXHJcbiAgICAvLyBXZSBrZWVwLCBsaWtlLCBhIGxvdCBvZiByZW5kZXItc3RhdGUsIGJ1dCBpdCBvbmx5IGV2ZXIgdHJpZ2dlcnMgYSByZS1yZW5kZXJcclxuICAgIC8vIHdoZW4gd2Ugc3RhcnQvc3RvcCBhbiBhc3luYyBhY3Rpb24uXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGZvciB0aGUgY2FsbGVyJ3Mgc2FrZSAtLSB3ZSBkb24ndCByZWFsbHkgY2FyZS5cclxuICAgIGNvbnN0IFtjdXJyZW50VHlwZSwgc2V0Q3VycmVudFR5cGVdID0gdXNlU3RhdGU8bnVsbCB8IFwic3luY1wiIHwgXCJhc3luY1wiPihudWxsKTtcclxuICAgIGNvbnN0IFtydW5Db3VudCwgc2V0UnVuQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2V0dGxlQ291bnQsIHNldFNldHRsZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3Jlc29sdmVDb3VudCwgc2V0UmVzb2x2ZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3JlamVjdENvdW50LCBzZXRSZWplY3RDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICAvLyBUaGluZ3MgcmVsYXRlZCB0byBjdXJyZW50IGV4ZWN1dGlvblxyXG4gICAgLy8gQmVjYXVzZSB3ZSBjYW4gYm90aCByZXR1cm4gYW5kIHRocm93IHVuZGVmaW5lZCwgXHJcbiAgICAvLyB3ZSBuZWVkIHNlcGFyYXRlIHN0YXRlIHRvIHRyYWNrIHRoZWlyIGV4aXN0YW5jZSB0b28uXHJcbiAgICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZywgZ2V0UGVuZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHQsIGdldFJlc3VsdF0gPSB1c2VTdGF0ZTxSPih1bmRlZmluZWQhKTtcclxuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3IsIF9nZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duPih1bmRlZmluZWQhKTtcclxuICAgIGNvbnN0IFtoYXNFcnJvciwgc2V0SGFzRXJyb3IsIF9nZXRIYXNFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaGFzUmVzdWx0LCBzZXRIYXNSZXN1bHQsIF9nZXRIYXNSZXN1bHRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIC8vIFdlIGltcGxlbWVudCBvdXIgb3duIHRocm90dGxpbmcgYmVoYXZpb3IgaW4gcmVnYXJkcyB0byB3YWl0aW5nIHVudGlsIHRoZSBhc3luYyBoYW5kbGVyIGZpbmlzaGVzLlxyXG4gICAgLy8gVGhlc2UgdHdvIHBhc3NpdmUgc3RhdGUgdmFyaWFibGVzIGtlZXAgdHJhY2sgb2YgdGhhdCwgYXV0b21hdGljYWxseSBxdWV1ZWluZy9kZXF1ZXVpbmcgdGhlIG5leHQgaGFuZGxlci5cclxuICAgIGNvbnN0IFtnZXRRdWV1ZWQsIHNldFF1ZXVlZF0gPSB1c2VQYXNzaXZlU3RhdGU8QVAgfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcclxuXHJcblxyXG4gICAgLy8gVGhlIGFjdHVhbCBzeW5jIGhhbmRsZXIuXHJcbiAgICAvLyBDYXB0dXJlL3RyYW5zZm9ybSB0aGUgZ2l2ZW4gcGFyYW1ldGVycyBpZiBhcHBsaWNhYmxlLFxyXG4gICAgLy8gdGhlbiBydW4gZnVydGhlciBsb2dpYyB0aGF0J3MgZGVib3VuY2VkL3Rocm90dGxlZFxyXG4gICAgY29uc3QgY2FwdHVyZUFyZ3NBbmRFeGVjdXRlRGVib3VuY2VkSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrPFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+PihmdW5jdGlvbiBvbk5ld0V4ZWN1dGVSZXF1ZXN0KC4uLm5ld0FyZ3MyOiBTUCkge1xyXG5cclxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBhcmd1bWVudHMgd2Ugd2VyZSBnaXZlbi5cclxuICAgICAgICAvLyBXZSBtaWdodCB1c2UgdGhlbSBpbW1lZGlhdGVseSwgb3Igd2UgbWlnaHQgc3RvcmUgdGhlbSB0byBgcXVldWVkYCxcclxuICAgICAgICAvLyBidXQgaW4gZWl0aGVyIGNhc2Ugd2UgZG8gbmVlZCB0aGUgY2FwdHVyZWQgdmFsdWUuXHJcbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlISguLi5uZXdBcmdzMik7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgYWxsIGxvZ2ljIHRoYXQgZGVhbHMgd2l0aCB0aGUgY2FwdHVyZWQgdmFsdWUgaW5zdGVhZCBvZiB0aGUgcmF3IGFyZ3VtZW50cy5cclxuICAgICAgICAvLyBJdCdzIGNhbGxlZCBpbiB0d28gc2VwYXJhdGUgY2lyY3Vtc3RhbmNlcyxcclxuICAgICAgICAvLyBhbmQgaGFzIHRoZSBkZWJvdW5jZS90aHJvdHRsZSBsb2dpYyBhbHJlYWR5IGFwcGxpZWRcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZ2V0UGVuZGluZygpLCAuLi5jYXB0dXJlZCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVGhpcyBpcyB0aGUgbG9naWMgdGhhdCBydW5zIHdoZW4gdGhlIGhhbmRsZXIgaXMgKmp1c3QqIGFib3V0IHRvIHN0YXJ0LlxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpdHNlbGYgaXMgZnVydGhlciB0cmFuc2Zvcm1lZCB0byBiZSB0aHJvdHRsZWQvZGVib3VuY2VkIGlmIHJlcXVlc3RlZCxcclxuICAgIC8vIHNvIHRoaXMgbWlnaHQgbm90IGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBcclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlID0gdXNlU3RhYmxlQ2FsbGJhY2s8R2x1ZUZ1bmN0aW9uVHlwZTxBUCwgUj4+KGZ1bmN0aW9uIG9uTmV3RXhlY3V0ZVJlcXVlc3QyKGVucXVldWU6IGJvb2xlYW4sIC4uLm5ld0FyZ3M6IEFQKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uVGhlbiA9ICh2YWx1ZTogUikgPT4geyBzZXRSZXN1bHQodmFsdWUpOyBzZXRIYXNSZXN1bHQodHJ1ZSk7IHNldEhhc0Vycm9yKGZhbHNlKTsgc2V0UmVzb2x2ZUNvdW50KHIgPT4gKytyKTsgfTtcclxuICAgICAgICBjb25zdCBvbkNhdGNoID0gKGV4OiBhbnkpID0+IHsgc2V0RXJyb3IoZXgpOyBzZXRIYXNFcnJvcih0cnVlKTsgc2V0SGFzUmVzdWx0KGZhbHNlKTsgc2V0UmVqZWN0Q291bnQociA9PiArK3IpOyB9O1xyXG4gICAgICAgIGNvbnN0IG9uRmluYWxseSA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcXVldWVkID0gZ2V0UXVldWVkKCk7XHJcbiAgICAgICAgICAgIHNldFNldHRsZUNvdW50KHMgPT4gKytzKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0UXVldWVkKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZmFsc2UsIC4uLnF1ZXVlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIWVucXVldWUpIHtcclxuICAgICAgICAgICAgLy8gTm90aGluZyBpcyBwZW5kaW5nIGF0IHRoZSBtb21lbnQsIHNvIHdlIGNhbiBydW4gb3VyIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICBzZXRSdW5Db3VudChyID0+ICsrcik7XHJcbiAgICAgICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzeW5jSGFuZGxlcj8uKC4uLm5ld0FyZ3MpIGFzIFI7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUHJvbWlzZSA9IChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gKHJlc3VsdCBhcyB1bmtub3duIGFzIFByb21pc2U8YW55PikpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgIWlzUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBzeW5jaHJvbm91cyBhbmQgcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkuXHJcbiAgICAgICAgICAgICAgICBvblRoZW4ocmVzdWx0IGFzIFIpO1xyXG4gICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZShcInN5bmNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocmVzdWx0IGFzIHVua25vd24gYXMgUHJvbWlzZTxSPikudGhlbihvblRoZW4pLmNhdGNoKG9uQ2F0Y2gpLmZpbmFsbHkob25GaW5hbGx5KTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlKFwiYXN5bmNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgc3RpbGwgcnVubmluZyBhIHByZXZpb3VzIGhhbmRsZXIsXHJcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IG91cnNlbHZlcyBhcyB0aGUgbmV4dCBvbmUgdG8gcnVuIGFuZCBxdWl0IGVhcmx5LlxyXG4gICAgICAgICAgICAvLyBOb3RoaW5nIG1vcmUgdG8gZG8uXHJcbiAgICAgICAgICAgIHNldFF1ZXVlZChuZXdBcmdzKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHJldHVybiBnZXRSZXN1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPSB1c2VUaHJvdHRsZWQ8Tm9uTnVsbGFibGU8dHlwZW9mIGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlPj4oIXRocm90dGxlID8gbnVsbCA6IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlLCB0aHJvdHRsZSA/PyAwKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aEQgPSB1c2VEZWJvdW5jZWQoIWRlYm91bmNlID8gbnVsbCA6IChleGVjdXRlSGFuZGxlcldpdGhUID8/IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlKSwgZGVib3VuY2UgPz8gMCk7XHJcbiAgICBjb25zdCBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZSA9IChleGVjdXRlSGFuZGxlcldpdGhEID8/IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPz8gZXhlY3V0ZUhhbmRsZXJXaXRob3V0RGVib3VuY2UpO1xyXG5cclxuICAgIGNvbnN0IGZsdXNoRGVib3VuY2VkUHJvbWlzZSA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAoZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UgJiYgXCJmbHVzaFwiIGluIGV4ZWN1dGVIYW5kbGVyV2l0aERlYm91bmNlKVxyXG4gICAgICAgICAgICBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZS5mbHVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzeW5jSGFuZGxlcjogY2FwdHVyZUFyZ3NBbmRFeGVjdXRlRGVib3VuY2VkSGFuZGxlcixcclxuICAgICAgICBjdXJyZW50VHlwZSxcclxuICAgICAgICBwZW5kaW5nLFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBoYXNFcnJvcixcclxuICAgICAgICBoYXNSZXN1bHQsXHJcbiAgICAgICAgcmVzb2x2ZUNvdW50LFxyXG4gICAgICAgIHJlamVjdENvdW50LFxyXG4gICAgICAgIHNldHRsZUNvdW50LFxyXG4gICAgICAgIGNhbGxDb3VudDogcnVuQ291bnQsXHJcbiAgICAgICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyB1c2VBc3luYywgVXNlQXN5bmNQYXJhbWV0ZXJzLCBVc2VBc3luY1JldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtYXN5bmNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFzeW5jSGFuZGxlclBhcmFtZXRlcnM8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQsIENhcHR1cmVUeXBlPiBleHRlbmRzIE9taXQ8VXNlQXN5bmNQYXJhbWV0ZXJzPFtDYXB0dXJlVHlwZSwgRXZlbnRUeXBlXSwgW0V2ZW50VHlwZV0+LCBcImNhcHR1cmVcIj4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGF0IHRyYW5zaWVudCBpbmZvcm1hdGlvbiBpcyBjYXB0dXJlZCBieSB0aGlzIGV2ZW50IFxyXG4gICAgICogYW5kIHByZXNlbnRlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgdGhlIGV2ZW50IGhhbmRsZXI/XHJcbiAgICAgKiBcclxuICAgICAqIFRoZSBcImNhcHR1cmVcIiBwYXJhbWV0ZXIgYW5zd2VycyB0aGlzIHF1ZXN0aW9uLiBUbyBpbXBsZW1lbnQgYSBjaGVja2JveCwgZm9yIGV4YW1wbGUsIHJldHVybiBgdGFyZ2V0LmNoZWNrZWRgLlxyXG4gICAgICovXHJcbiAgICBjYXB0dXJlOiAoZXZlbnQ6IEV2ZW50VHlwZSkgPT4gQ2FwdHVyZVR5cGU7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNIYW5kbGVyUmV0dXJuVHlwZTxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudCwgQ2FwdHVyZVR5cGU+IGV4dGVuZHMgVXNlQXN5bmNSZXR1cm5UeXBlPFtFdmVudFR5cGVdLCB2b2lkPiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbW9zdCByZWNlbnRseSBjYXB0dXJlZCB2YWx1ZS4gSW4gb3RoZXIgd29yZHMsIHJlcHJlc2VudHMgd2hhdFxyXG4gICAgICogdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgYmUgaWYgdGhpcyBvcGVyYXRpb24gd2VyZSBzeW5jaHJvbm91cyBhbmQgXHJcbiAgICAgKiBhbmQgY291bGRuJ3QgZmFpbC4gSXQncyB1c2VmdWwgdG8gcHJldGVuZCB0aGlzIGlzIHRoZSBhY3R1YWwgdmFsdWVcclxuICAgICAqIGZvciBhbiBpbnB1dCBmaWVsZCwgZm9yIGV4YW1wbGUsIHNvIHRoYXQgdGhlIHZhbHVlIGRvZXNuJ3QgXCJzbmFwXHJcbiAgICAgKiBiYWNrXCIgd2hpbGUgeW91J3JlIHdhaXRpbmcgZm9yIHRoZSBoYW5kbGVyIHRvIGZpbmlzaC5cclxuICAgICAqIFxyXG4gICAgICogU29tZXRoaW5nIGxpa2UgYHZhbHVlPXtwZW5kaW5nPyBjdXJyZW50Q2FwdHVyZSA6IHZhbHVlfWAgaXMgZ29vZCBmb3IgY2hlY2tib3hlcyxcclxuICAgICAqIHNvbWV0aGluZyBsaWtlIGB2YWx1ZT17KHBlbmRpbmcgfHwgaGFzRm9jdXMpPyBjdXJyZW50Q2FwdHVyZSA6IHZhbHVlfSBmb3IgdGV4dCBmaWVsZHMuXHJcbiAgICAgKiBcclxuICAgICAqIEBzZWUgaGFzQ2FwdHVyZVxyXG4gICAgICovXHJcbiAgICBjdXJyZW50Q2FwdHVyZTogQ2FwdHVyZVR5cGUgfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqIFxyXG4gICAgICogVGhlIGFib3ZlLCBidXQgc3RhYmxlLCBpZiB5b3UgbmVlZCB0aGUgY3VycmVudCBjYXB0dXJlIHdpdGhvdXQgaXQgYmVpbmcgYW4gZXhwbGljaXQgZGVwZW5kZW5jeS5cclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqICAqL1xyXG4gICAgZ2V0Q3VycmVudENhcHR1cmUoKTogKENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEJlY2F1c2UgeW91J3JlIGFsbG93ZWQgdG8gaGF2ZSBgQ2FwdHVyZVR5cGVgIGV4dGVuZCBgdW5kZWZpbmVkYCxcclxuICAgICAqIHlvdSBtaWdodCBuZWVkIHRoaXMuXHJcbiAgICAgKi9cclxuICAgIGhhc0NhcHR1cmU6IGJvb2xlYW47XHJcblxyXG4gICAgLy8gU2FtZSBhcyBpbiB1c2VBc3luYywgYnV0IHdpdGggYSBkaWZmZXJlbnQgdHlwZVxyXG4gICAgLy9wcm9taXNlOiBQcm9taXNlPHZvaWQ+IHwgbnVsbDtcclxuXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhc3luY3Jvbm91cyBldmVudCBoYW5kbGVyLCByZXR1cm5zIGEgc3luY3Jvbm91cyBvbmUgdGhhdCB3b3JrcyBvbiB0aGUgRE9NLFxyXG4gKiBhbG9uZyB3aXRoIHNvbWUgb3RoZXIgaW5mb3JtYXRpb24gcmVsYXRlZCB0byB0aGUgY3VycmVudCBzdGF0ZS5cclxuICogRG9lcyBub3QgbW9kaWZ5IGFueSBwcm9wcy5cclxuICogXHJcbiAqIE5vdGUgdGhhdCBiZWNhdXNlIHRoZSBoYW5kbGVyIHlvdSBwcm92aWRlIG1heSBiZSBjYWxsZWQgd2l0aCBhIGRlbGF5LCBhbmQgXHJcbiAqIGJlY2F1c2UgdGhlIHZhbHVlIG9mLCBlLmcuLCBhbiBgPGlucHV0PmAgZWxlbWVudCB3aWxsIGxpa2VseSBiZSBzdGFsZSBieSB0aGUgXHJcbiAqIHRpbWUgdGhlIGRlbGF5IGlzIG92ZXIsIGEgYGNhcHR1cmVgIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBcclxuICogY2FwdHVyZSB0aGUgcmVsZXZhbnQgaW5mb3JtYXRpb24gZnJvbSB0aGUgRE9NLiBBbnkgb3RoZXIgc2ltcGxlIGV2ZW50IGRhdGEsIFxyXG4gKiBsaWtlIGBtb3VzZVhgIG9yIGBzaGlmdEtleWAgY2FuIHN0YXkgb24gdGhlIGV2ZW50IGl0c2VsZiBhbmQgZG9uJ3QgXHJcbiAqIG5lZWQgdG8gYmUgY2FwdHVyZWQgJm5kYXNoOyBpdCdzIG5ldmVyIHN0YWxlLlxyXG4gKiBcclxuICogYGBgdHN4XHJcbiAqIGNvbnN0IGFzeW5jT25JbnB1dCA9IGFzeW5jICh2YWx1ZTogbnVtYmVyLCBlOiBFdmVudCkgPT4geyBcclxuICogICAgIFsuLi5dIC8vIEV4LiBzZW5kIHRvIGEgc2VydmVyIGFuZCBzZXRTdGF0ZSB3aGVuIGRvbmVcclxuICogfTtcclxuICogY29uc3Qge1xyXG4gKiAgICAgLy8gQSBzeW5jIHZlcnNpb24gb2YgYXN5bmNPbklucHV0XHJcbiAqICAgICBzeW5jSGFuZGxlcixcclxuICogICAgIC8vIFRydWUgd2hpbGUgdGhlIGhhbmRsZXIgaXMgcnVubmluZ1xyXG4gKiAgICAgcGVuZGluZyxcclxuICogICAgIC8vIFRoZSBlcnJvciB0aHJvd24sIGlmIGFueVxyXG4gKiAgICAgZXJyb3IsXHJcbiAqICAgICAvLyBTaG93IHRoaXMgdmFsdWUgd2hpbGUgdGhlIG9wZXJhdGlvbidzIHBlbmRpbmdcclxuICogICAgIGN1cnJlbnRDYXB0dXJlLFxyXG4gKiAgICAgLy8gQW5kIG90aGVycywgc2VlIGBVc2VBc3luY0hhbmRsZXJSZXR1cm5UeXBlYFxyXG4gKiAgICAgLi4ucmVzdFxyXG4gKiB9ID0gdXNlQXN5bmNIYW5kbGVyPEhUTUxJbnB1dEVsZW1lbnQ+KCkoYXN5bmNPbklucHV0LCB7IFxyXG4gKiAgICAgLy8gUGFzcyBpbiB0aGUgY2FwdHVyZSBmdW5jdGlvbiB0aGF0IHNhdmVzIGV2ZW50IGRhdGFcclxuICogICAgIC8vIGZyb20gYmVpbmcgc3RhbGUuXHJcbiAqICAgICBjYXB0dXJlOiBlID0+IHsgXHJcbiAqICAgICAgICAgLy8gYGNhcHR1cmVgIGNhbiBoYXZlIHNpZGUtZWZmZWN0cyBiZWNhdXNlXHJcbiAqICAgICAgICAgLy8gaXQncyBjYWxsZWQgZXhhY3RseSBvbmNlIHBlciBpbnZvY2F0aW9uXHJcbiAqICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyBcclxuICogXHJcbiAqICAgICAgICAgLy8gU2F2ZSB0aGlzIHZhbHVlIHNvIHRoYXQgaXQncyBuZXZlciBzdGFsZVxyXG4gKiAgICAgICAgIHJldHVybiBlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcjtcclxuICogICAgIH1cclxuICogfSk7XHJcbiAqIFxyXG4gKiBjb25zdCBvbklucHV0ID0gcGVuZGluZz8gbnVsbCA6IHN5bmNIYW5kbGVyO1xyXG4gKiBgYGBcclxuICogXHJcbiAqIFRoZSBoYW5kbGVyIGlzIGF1dG9tYXRpY2FsbHkgdGhyb3R0bGVkIHRvIG9ubHkgcnVuIG9uZSBhdCBhIHRpbWUuIFxyXG4gKiBJZiB0aGUgaGFuZGxlciBpcyBjYWxsZWQsIGFuZCB0aGVuIGJlZm9yZSBpdCBmaW5pc2hlcywgaXMgY2FsbGVkIGFnYWluLFxyXG4gKiBpdCB3aWxsIGJlIHB1dCBvbiBob2xkIHVudGlsIHRoZSBjdXJyZW50IG9uZSBmaW5pc2hlcywgYXQgd2hpY2ggcG9pbnRcclxuICogdGhlIHNlY29uZCBvbmUgd2lsbCBydW4uICBJZiB0aGUgaGFuZGxlciBpcyBjYWxsZWQgYSB0aGlyZCB0aW1lIGJlZm9yZVxyXG4gKiB0aGUgZmlyc3QgaGFzIGZpbmlzaGVkLCBpdCB3aWxsICpyZXBsYWNlKiB0aGUgc2Vjb25kLCBzbyBvbmx5IHRoZSBtb3N0XHJcbiAqIHJlY2VudGx5IGNhbGxlZCBpdGVyYXRpb24gb2YgdGhlIGhhbmRsZXIgd2lsbCBydW4uXHJcbiAqIFxyXG4gKiBcclxuICogWW91IG1heSBvcHRpb25hbGx5ICphbHNvKiBzcGVjaWZ5IGRlYm91bmNlIGFuZCB0aHJvdHRsZSBwYXJhbWV0ZXJzIHRoYXQgd2FpdCB1bnRpbCB0aGVcclxuICogc3luY3Jvbm91cyBoYW5kbGVyIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mXHJcbiAqIG1pbGxpc2Vjb25kcywgYXQgd2hpY2ggcG9pbnQgd2UgKmFjdHVhbGx5KiBydW4gdGhlIGFzeW5jcm9ub3VzIGhhbmRsZXJcclxuICogYWNjb3JkaW5nIHRvIHRoZSBsb2dpYyBpbiB0aGUgcHJldmlvdXMgcGFyYWdyYXBoLiBUaGlzIGlzIGluXHJcbiAqICphZGRpdGlvbiogdG8gdGhyb3R0bGluZyB0aGUgaGFuZGxlciwgYW5kIGRvZXMgbm90IHJlcGxhY2UgdGhhdCBiZWhhdmlvci5cclxuICogXHJcbiAqIEBzZWUgdXNlQXN5bmMgQSBtb3JlIGdlbmVyYWwgdmVyc2lvbiBvZiB0aGlzIGhvb2sgdGhhdCBjYW4gd29yayB3aXRoIGFueSB0eXBlIG9mIGhhbmRsZXIsIG5vdCBqdXN0IERPTSBldmVudCBoYW5kbGVycy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VBc3luY0hhbmRsZXI8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQsIENhcHR1cmVUeXBlPihhc3luY0hhbmRsZXI6ICgoYzogQ2FwdHVyZVR5cGUsIGU6IEV2ZW50VHlwZSkgPT4gKFByb21pc2U8dm9pZD4gfCB2b2lkKSkgfCBudWxsLCB7IGNhcHR1cmU6IG9yaWdpbmFsQ2FwdHVyZSwgLi4ucmVzdEFzeW5jT3B0aW9ucyB9OiBVc2VBc3luY0hhbmRsZXJQYXJhbWV0ZXJzPEV2ZW50VHlwZSwgQ2FwdHVyZVR5cGU+KTogVXNlQXN5bmNIYW5kbGVyUmV0dXJuVHlwZTxFdmVudFR5cGUsIENhcHR1cmVUeXBlPiB7XHJcbiAgICBcclxuICAgIC8vIFdlIG5lZWQgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIFwibm90aGluZyBjYXB0dXJlZCB5ZXRcIiBhbmQgXCJgdW5kZWZpbmVkYCB3YXMgY2FwdHVyZWRcIlxyXG4gICAgY29uc3QgW2N1cnJlbnRDYXB0dXJlLCBzZXRDdXJyZW50Q2FwdHVyZSwgZ2V0Q3VycmVudENhcHR1cmVdID0gdXNlU3RhdGU8Q2FwdHVyZVR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBbaGFzQ2FwdHVyZSwgc2V0SGFzQ2FwdHVyZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBcclxuICAgIC8vIFdyYXAgYXJvdW5kIHRoZSBub3JtYWwgYHVzZUFzeW5jYCBgY2FwdHVyZWAgZnVuY3Rpb24gdG8gYWxzb1xyXG4gICAgLy8ga2VlcCB0cmFjayBvZiB0aGUgbGFzdCB2YWx1ZSB0aGUgdXNlciBhY3R1YWxseSBpbnB1dC5cclxuICAgIC8vIFxyXG4gICAgLy8gV2l0aG91dCB0aGlzIHRoZXJlJ3Mgbm8gd2F5IHRvIHJlLXJlbmRlciB0aGUgY29udHJvbCB3aXRoXHJcbiAgICAvLyBpdCBiZWluZyBib3RoIGNvbnRyb2xsZWQgYW5kIGFsc28gaGF2aW5nIHRoZSBcImNvcnJlY3RcIiB2YWx1ZSxcclxuICAgIC8vIGFuZCBhdCBhbnkgcmF0ZSBhbHNvIHByb3RlY3RzIGFnYWluc3Qgc3VkZGVuIGV4Y2VwdGlvbnMgcmV2ZXJ0aW5nXHJcbiAgICAvLyB5b3VyIGNoYW5nZSBvdXQgZnJvbSB1bmRlciB5b3UuXHJcbiAgICBjb25zdCBjYXB0dXJlID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IEV2ZW50VHlwZSk6IFtDYXB0dXJlVHlwZSwgRXZlbnRUeXBlXSA9PiB7IFxyXG4gICAgICAgIGNvbnN0IGNhcHR1cmVkID0gb3JpZ2luYWxDYXB0dXJlKGUpOyBcclxuICAgICAgICBzZXRDdXJyZW50Q2FwdHVyZShjYXB0dXJlZCk7XHJcbiAgICAgICAgc2V0SGFzQ2FwdHVyZSh0cnVlKTtcclxuICAgICAgICByZXR1cm4gW2NhcHR1cmVkLCBlXTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0Q3VycmVudENhcHR1cmUsXHJcbiAgICAgICAgY3VycmVudENhcHR1cmUsXHJcbiAgICAgICAgaGFzQ2FwdHVyZSxcclxuICAgICAgICAuLi51c2VBc3luYyhhc3luY0hhbmRsZXIsIHsgY2FwdHVyZSwgLi4ucmVzdEFzeW5jT3B0aW9ucyB9KVxyXG4gICAgfTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuIiwiaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSwgZGVib3VuY2VSZW5kZXJpbmcgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuXHJcbi8qKlxyXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XHJcbiAqIFxyXG4gKiAqICh0cmVlIG1vdW50cylcclxuICogKiBQYXJlbnQgcmVuZGVyc1xyXG4gKiAqIENoaWxkcmVuIHJlbmRlclxyXG4gKiAqIENoaWxkcmVuIHJlY2VpdmUgcmVmIChpZiBhcHBsaWNhYmxlKVxyXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXHJcbiAqICogQ2hpbGRyZW4gcnVuIGVmZmVjdHNcclxuICogKiBQYXJlbnQgcnVucyBlZmZlY3RzXHJcbiAqIFxyXG4gKiAqICh0cmVlIHVubW91bnRzKVxyXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdC1jbGVhbnVwXHJcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxyXG4gKiAqIENoaWxkIHJ1bnMgZWZmZWN0LWNsZWFudXBcclxuICogKiBDaGlsZCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcclxuICogXHJcbiAqIFR3byB0aGluZ3MgdG8gbm90ZSBoZXJlOlxyXG4gKiAqIFJlbmRlcmluZyBzdGFydHMgYXQgdGhlIHJvb3QsICBidXQgZWZmZWN0cyBhbmQgcmVmcyBzdGFydCBhdCB0aGUgbGVhdmVzLlxyXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxyXG4gKi9cclxuY29uc3QgX2NvbW1lbnRzID0gdm9pZCAoMCk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cclxuICogXHJcbiAqICogYGluZGV4YCByZWZlcnMgdG8gd2hpY2ggY2hpbGQgdGhpcyBpcy5cclxuICogKiBgZmxhZ3NgIGFyZSBxdWljay1hbmQtZWFzeSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgeW91IGNhbiBvcHRpb25hbGx5IHVzZVxyXG4gKiAqIGBzdWJJbmZvYCBpcyBhbnl0aGluZyB1c2VkIGJ5IGEgZGVyaXZlZCBob29rLiBgdXNlUm92aW5nVGFiSW5kZXhgLCBmb3IgZXhhbXBsZSwgbmVlZHMgdG8ga25vdyBob3cgdG8gZm9jdXMgYW4gYXJiaXRyYXJ5IGNoaWxkLCBzbyB0aGUgY2hpbGQgcG9wdWxhdGVzIGBpbmZvYCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGEgbWV0aG9kIGNhbGxlZCBgZm9jdXNTZWxmYC5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICBpbmRleDogVDtcclxuICAgIGZsYWdzPzogUGFydGlhbDxSZWNvcmQ8SywgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+O1xyXG4gICAgc3ViSW5mbzogQztcclxufVxyXG5cclxuXHJcblxyXG5leHBvcnQgdHlwZSBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKG1vdW50ZWQ6IFNldDxUPiwgdW5tb3VudGVkOiBTZXQ8VD4pID0+IHZvaWQpO1xyXG5leHBvcnQgdHlwZSBPbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKGNhdXNlcnM6IEl0ZXJhYmxlPFQ+KSA9PiB2b2lkKTtcclxuXHJcbmludGVyZmFjZSBNQ1A8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZz4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIGFmdGVyIG9uZSBvciBtb3JlIGNoaWxkcmVuIGhhdmUgdXBkYXRlZCB0aGVpciBpbmZvcm1hdGlvbiAoaW5kZXgsIGV0Yy4pLlxyXG4gICAgICogXHJcbiAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XHJcbiAgICAgKiAqZ3VhcmFudGVlZCogdG8gaGF2ZSBhY3R1YWxseSBiZWVuIGEgY2hhbmdlLlxyXG4gICAgICovXHJcbiAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQ+O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2FtZSBhcyB0aGUgYWJvdmUsIGJ1dCBvbmx5IGZvciBtb3VudC91bm1vdW50IChvciB3aGVuIGEgY2hpbGQgY2hhbmdlcyBpdHMgaW5kZXgpXHJcbiAgICAgKi9cclxuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VD47XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZHJlbk9taXRzID0ga2V5b2YgTUNQPGFueT47XHJcbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZE9taXRzID0ga2V5b2YgTWFuYWdlZENoaWxkSW5mbzxhbnksIGFueSwgYW55PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBPbWl0cyBleHRlbmRzIGtleW9mIE1DUDxUPj4ge1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiBPbWl0PE1DUDxUPiwgT21pdHM+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgQywgSyBleHRlbmRzIHN0cmluZywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzPiB7XHJcbiAgICBtYW5hZ2VkQ2hpbGQ6IE9taXQ8TWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiwgTWNPbWl0cz47XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXHJcbiAgICAgKi9cclxuICAgIG1hbmFnZWRDaGlsZHJlbjoge1xyXG4gICAgICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQsIEMsIEs+IHtcclxuICAgIC8qKlxyXG4gICAgICogQSBob29rIHRoYXQgbXVzdCBiZSBjYWxsZWQgYnkgZXZlcnkgY2hpbGQgY29tcG9uZW50IHRoYXRcclxuICAgICAqIGlzIHRvIGJlIG1hbmFnZWQgYnkgdGhpcyBvbmUuIFRoZSBhcmd1bWVudCB0byB0aGUgaG9va1xyXG4gICAgICogaXMganVzdCB0aGUgYmFnIG9mIHByb3BlcnRpZXMgdG8gcGFzcyB0byB0aGUgcGFyZW50LFxyXG4gICAgICogaW5jbHVkaW5nIHRoZSBjaGlsZCdzIGluZGV4LlxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZU1hbmFnZWRDaGlsZDogVXNlTWFuYWdlZENoaWxkPFQsIEMsIEs+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQsIEMsIEssIG5ldmVyPikgPT4gVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEFic3RyYWN0aW9uIG92ZXIgdGhlIG1hbmFnZWQgY2hpbGRyZW5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEF0KGluZGV4OiBUKTogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPiB8IHVuZGVmaW5lZDtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBmb3JFYWNoOiAoZjogKGNoaWxkOiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+KSA9PiB2b2lkKSA9PiB2b2lkO1xyXG5cclxuICAgIC8qKiAqKlVOU1RBQkxFKiosIGFsc28gaW50ZXJuYWwtdXNlIG9ubHksIGFsc28gVE9ETyBuZWVkIGEgd29ya2Fyb3VuZCBmb3IgdGhpcyBmb3Igc29ydGFibGUgY2hpbGRyZW4gKi9cclxuICAgIGFycmF5U2xpY2U6ICgpID0+IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz5bXTtcclxufVxyXG5cclxuXHJcblxyXG5cclxuLy9leHBvcnQgdHlwZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPEkgZXh0ZW5kcyB7fT4gPSB7IGluZm86IEkgfTtcclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYSBwYXJlbnQgY29tcG9uZW50IHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCBjZXJ0YWluXHJcbiAqIGNoaWxkIGNvbXBvbmVudHMgb25jZSB0aGV5IGhhdmUgcmVuZGVyZWQuXHJcbiAqIFxyXG4gKiBUaGlzIGhvb2sgaXMgZGVzaWduZWQgdG8gYmUgbGlnaHR3ZWlnaHQsIGluIHRoYXQgdGhlIHBhcmVudCBrZWVwcyBubyBzdGF0ZVxyXG4gKiBhbmQgcnVucyBubyBlZmZlY3RzLiAgRWFjaCBjaGlsZCAqZG9lcyogcnVuIGFuIGVmZmVjdCwgYnV0IHdpdGggbm8gc3RhdGVcclxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxyXG4gKiBcclxuICogXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWFuYWdlZENoaWxkcmVuPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCwgbmV2ZXI+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxULCBDLCBLPiB7XHJcbiAgICAvL3R5cGUgSSA9IEkzICYgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPjtcclxuICAgIHR5cGUgSW5mbyA9IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz47XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xyXG5cclxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXHJcbiAgICAvLyBBbnkgbXV0YXRpb25zIHRvIHRoaXMgYXJyYXkgKipETyBOT1QqKiB0cmlnZ2VyIGFueSBzb3J0IG9mIGEgcmUtcmVuZGVyLlxyXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8eyBhcnI6IEFycmF5PEluZm8+OyByZWM6IFBhcnRpYWw8UmVjb3JkPFQsIEluZm8+PjsgaGlnaGVzdEluZGV4OiBudW1iZXIsIGxvd2VzdEluZGV4OiBudW1iZXIgfT4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xyXG5cclxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxyXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXHJcbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xyXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cclxuICAgIC8vIEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlcmUgd2FzIHNvbWV0aGluZyBiZXR0ZXIgZm9yIHRoYXQuXHJcbiAgICBjb25zdCBmb3JFYWNoQ2hpbGQgPSB1c2VDYWxsYmFjaygoZjogKGNoaWxkOiBJbmZvKSA9PiB2b2lkKSA9PiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xyXG4gICAgICAgICAgICBpZiAoY2hpbGQpXHJcbiAgICAgICAgICAgICAgICBmKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxULCBJbmZvPl07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZClcclxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIGB1bmRlZmluZWRgIGlmIG5vdCBjaGlsZCB0aGVyZSwgb3IgaXQncyB1bm1vdW50ZWQuXHJcbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPFQsIEMsIEs+W1wiZ2V0QXRcIl0+KChpbmRleDogVCkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdITtcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cclxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXHJcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cclxuICAgIC8vXHJcbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxyXG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxyXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XHJcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXHJcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxyXG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcclxuICAgIC8vIFxyXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcclxuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxyXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcclxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXHJcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXHJcbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxUPiwgdW5tb3VudHM6IFNldDxUPiB9IHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8VD4oKSk7XHJcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQpID0+IHtcclxuXHJcbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcclxuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5jbGVhcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xyXG5cclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpXHJcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXggYXMgbnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XHJcbiAgICAgICAgICAgICAgICBsZXQgc2hhdmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIuc3BsaWNlKG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIHNoYXZlLCBzaGF2ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnRbbW91bnRlZCA/IFwibW91bnRzXCIgOiBcInVubW91bnRzXCJdLmFkZChpbmRleCk7XHJcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZU1hbmFnZWRDaGlsZCA9IHVzZUNhbGxiYWNrPFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPj4oKHsgbWFuYWdlZENoaWxkOiBpbmZvLCB9KSA9PiB7XHJcbiAgICAgICAgLy8gQW55IHRpbWUgb3VyIGNoaWxkIHByb3BzIGNoYW5nZSwgbWFrZSB0aGF0IGluZm9ybWF0aW9uIGF2YWlsYWJsZVxyXG4gICAgICAgIC8vIHRoZSBwYXJlbnQgaWYgdGhleSBuZWVkIGl0LlxyXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxyXG4gICAgICAgIC8vIGFuZCBtdWx0aXBsZSBjaGlsZHJlbiB1cGRhdGluZyBpbiB0aGUgc2FtZSB0aWNrIHdpbGwgYWxsIGJlIHNlbnQgYXQgb25jZS5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8uaW5kZXggPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5mby5pbmRleCBhcyBudW1iZXJdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5mby5pbmRleCBhcyBUXSA9IHsgaW5kZXg6IGluZm8uaW5kZXgsIGZsYWdzOiBpbmZvLmZsYWdzID8/IHt9LCBzdWJJbmZvOiBpbmZvLnN1YkluZm8gfTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZm8uaW5kZXggYXMgVCk7XHJcbiAgICAgICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXHJcblxyXG4gICAgICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xyXG4gICAgICAgIC8vIChldmVyeSBjaGlsZCBkb2VzIHRoaXMsIHNvIGV2ZXJ5dGhpbmcncyBjb29yZGluYXRlZCB0byBvbmx5IHF1ZXVlIGEgc2luZ2xlIG1pY3JvdGFzayBwZXIgdGljaylcclxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxyXG4gICAgICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcclxuICAgICAgICAvLyBzbyB0aGF0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgaW5mbyBvbiBtb3VudC5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5mby5pbmRleCBhcyBULCBmYWxzZSk7XHJcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcblxyXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPj4oe1xyXG4gICAgICAgIC4uLnsgXzogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCB9IGFzIHt9LFxyXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcclxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcclxuICAgICAgICBnZXRIaWdoZXN0SW5kZXg6IGdldEhpZ2hlc3RJbmRleCxcclxuICAgICAgICBhcnJheVNsaWNlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTWFuYWdlZENoaWxkLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxyXG4gICAgICogXHJcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxyXG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcclxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcclxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cclxuICAgICAqIFxyXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcclxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXHJcbiAgICAgKi9cclxuICAgIC8vY2xvc2VzdEZpdD86IGJvb2xlYW47XHJcbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xyXG5cclxuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cclxuICAgICAqIFxyXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXHJcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxyXG4gICAgICovXHJcbiAgICBvbkluZGV4Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyIHwgbnVsbD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGNoaWxkcmVuIGhhdmUgbXVsdGlwbGUgZmxhZ3MsIHRoZSBga2V5YCBwYXJhbWV0ZXIgY29udHJvbHMgd2hpY2ggZmxhZyB3ZSdyZSBjaGVja2luZy5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBjYW4gYmUgYW55dGhpbmcgeW91IHdhbnQsIGJ1dCBtdXN0IG5vdCBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGtleTogSztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxyXG4gICAgICovXHJcbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjaGlsZCBtdXN0IHNldCBpdHNlbGYgYXMgYWN0aXZlL2luYWN0aXZlLCB3aGF0ZXZlciB0aGF0IGVudGFpbHMuXHJcbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBzZXQ6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxyXG4gICAgICogTW9zdCBjaGlsZHJlbiBzaG91bGQgcmV0dXJuIHRydWUuIFJldHVybmluZyBmYWxzZSBpcyBvbmx5IHVzZWZ1bCB0byBtYXJrIGEgY2hpbGQgYXMgXCJpbnZhbGlkXCIgaW4gc29tZSB3YXkuXHJcbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxyXG4gICAgICovXHJcbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW47XHJcbn1cclxuXHJcblxyXG4vL2V4cG9ydCBpbnRlcmZhY2UgRmxhZ2dhYmxlQ2hpbGRJbmZvQjxLIGV4dGVuZHMgc3RyaW5nPiB7IGZsYWdzOiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4gfSBcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGNoYW5nZUluZGV4OiAoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IG51bWJlciB8IG51bGw7XHJcbiAgICAvKiogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKiBcclxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxyXG4gICAgICogICovXHJcbiAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdDogKCkgPT4gdm9pZDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBleHRlbnNpb24gdG8gdXNlTWFuYWdlZENoaWxkcmVuIHRoYXQgaGFuZGxlcyB0aGUgZm9sbG93aW5nIGNvbW1vbiBjYXNlOlxyXG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXHJcbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cclxuICogMy4gVGhlIHBhcmVudCBoYXMgY29udHJvbCBvdmVyIHdobyBpcyBcInNlbGVjdGVkXCIgdmlhIGEgbnVtZXJpY2FsIGluZGV4LlxyXG4gKiBcclxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxyXG4gKiBcclxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXHJcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXHJcbiAqIFxyXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGtleSB9OiBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEs+KTogVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwga2V5KTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG9uSW5kZXhDaGFuZ2UsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKG51bGwpKSwgW10pKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XHJcblxyXG4gICAgLy8gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcclxuXHJcbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljIChidXQgY291bGQgYmUgSSBndWVzcylcclxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgY2xvc2VzdEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLmFicyhjaGlsZC5pbmRleCAtIHJlcXVlc3RlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY2hpbGQuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xyXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcclxuXHJcbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcclxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxyXG4gICAgLy8gMS4gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjaGlsZCB1bm1vdW50ZWRcclxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxyXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XHJcblxyXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCAhPSBudWxsICYmIGNsb3Nlc3RGaXQgJiYgKHJlcXVlc3RlZEluZGV4ICE9IGN1cnJlbnRJbmRleCB8fCBjdXJyZW50Q2hpbGQgPT0gbnVsbCB8fCAhY3VycmVudENoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0Rml0Q2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjaygoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnO1xyXG4gICAgICAgIC8vaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxyXG4gICAgICAgIC8vICAgIHJlcXVlc3RlZEluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xyXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcclxuXHJcbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xyXG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsKTtcclxuICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkICYmIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChuZXdNYXRjaGluZ0NoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpbml0aWFsSW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQoaW5pdGlhbEluZGV4KT8uZmxhZ3M/LltrZXldPy5zZXQodHJ1ZSk7XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xyXG59XHJcblxyXG4iLCJmdW5jdGlvbiByKGUpe3ZhciB0LGYsbj1cIlwiO2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlfHxcIm51bWJlclwiPT10eXBlb2YgZSluKz1lO2Vsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpaWYoQXJyYXkuaXNBcnJheShlKSlmb3IodD0wO3Q8ZS5sZW5ndGg7dCsrKWVbdF0mJihmPXIoZVt0XSkpJiYobiYmKG4rPVwiIFwiKSxuKz1mKTtlbHNlIGZvcih0IGluIGUpZVt0XSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGZ1bmN0aW9uIGNsc3goKXtmb3IodmFyIGUsdCxmPTAsbj1cIlwiO2Y8YXJndW1lbnRzLmxlbmd0aDspKGU9YXJndW1lbnRzW2YrK10pJiYodD1yKGUpKSYmKG4mJihuKz1cIiBcIiksbis9dCk7cmV0dXJuIG59ZXhwb3J0IGRlZmF1bHQgY2xzeDsiLCJpbXBvcnQgY2xzeCBmcm9tIFwiY2xzeFwiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9jdW1lbnQoZWxlbWVudD86IE5vZGUpIHsgcmV0dXJuIChlbGVtZW50Py5vd25lckRvY3VtZW50ID8/IGRvY3VtZW50ID8/IHdpbmRvdy5kb2N1bWVudCA/PyBnbG9iYWxUaGlzLmRvY3VtZW50KTsgfVxyXG5cclxudHlwZSBQID0gUGFyYW1ldGVyczx0eXBlb2YgY2xzeD47XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRG9jdW1lbnRDbGFzcyhjbGFzc05hbWU6IFBbMF0sIGFjdGl2ZT86IGJvb2xlYW4sIGVsZW1lbnQ/OiBIVE1MRWxlbWVudCkge1xyXG4gICAgZWxlbWVudCA/Pz0gZ2V0RG9jdW1lbnQoKS5kb2N1bWVudEVsZW1lbnQ7XHJcbiAgICBjbGFzc05hbWUgPSBjbHN4KGNsYXNzTmFtZSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoYWN0aXZlICE9PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGVsZW1lbnQhLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lIGFzIHN0cmluZyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgfSwgW2NsYXNzTmFtZSwgYWN0aXZlLCBlbGVtZW50XSk7XHJcblxyXG59XHJcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIEZyYWdtZW50LCBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENoaWxkcmVuKHsgY2hpbGRyZW46IGxocyB9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEV2ZW50VGFyZ2V0PiwgXCJjaGlsZHJlblwiPiwgeyBjaGlsZHJlbjogcmhzfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJjaGlsZHJlblwiXSB7XHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAocmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhZ2dhYmxlUmV0dXJuVHlwZTxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VEcmFnZ2FibGVQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZFxyXG4gICAgICovXHJcbiAgICBkcmFnZ2luZzogYm9vbGVhbjtcclxuICAgIFxyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldERyYWdnaW5nOiAoKSA9PiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT25jZSB0aGUgZHJhZyBlbmRzLCBpZiBpdCB3YXMgb3ZlciBhIHZhbGlkIGRyb3BwYWJsZSwgdGhpcyB3aWxsIGJlXHJcbiAgICAgKiBzZXQgdG8gdGhlIGBkcm9wRWZmZWN0YCB2YWx1ZSBpdCBoYWQuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZWN0IHdoZW4gdGhlIGVsZW1lbnQgaGFzIGRyb3BwZWQsIFxyXG4gICAgICogYW5kIHRoZW4gd2hhdCBzaG91bGQgYmUgZG9uZSB3aXRoIGl0IChnZW5lcmFsbHkgZGVsZXRlZCBpZiB0aGUgZWZmZWN0IHdhcyBcIm1vdmVcIilcclxuICAgICAqL1xyXG4gICAgbGFzdERyb3BFZmZlY3Q6IERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsO1xyXG5cclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRMYXN0RHJvcEVmZmVjdDogKCkgPT4gKERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsKTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhZ2dhYmxlUGFyYW1ldGVycyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHRvIHRoZSBEcmFnIGFuZCBEcm9wIEFQSSAtLSBhbGxvd3MgbGltaXRpbmcgdGhlIGFyZWFzIHRoaXMgZWxlbWVudCBjYW4gYmUgZHJvcHBlZC5cclxuICAgICAqIEZvciBleGFtcGxlLCBzZXR0aW5nIHRoaXMgdG8gXCJjb3B5TGlua1wiIHdpbGwgYWxsb3cgdGhpcyB0aGlzIHRvIGJlIGRyb3BwZWQgb250b1xyXG4gICAgICogYSBkcm9wcGFibGUgd2l0aCBhbiBlZmZlY3Qgb2YgXCJjb3B5XCIgb3IgXCJsaW5rXCIsIGJ1dCBub3QgXCJtb3ZlXCIuXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgZWZmZWN0QWxsb3dlZD86IERhdGFUcmFuc2ZlcltcImVmZmVjdEFsbG93ZWRcIl0gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgY3VzdG9tIGRyYWcgaW1hZ2UgaW5zdGVhZCBvZiB0aGUgYnJvd3NlciBkZWZhdWx0IChhIHRyYW5zcGFyZW50IHJlbmRlciBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCwgZ2VuZXJhbGx5KVxyXG4gICAgICovXHJcbiAgICBkcmFnSW1hZ2U/OiBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50O1xyXG4gICAgZHJhZ0ltYWdlWE9mZnNldD86IG51bWJlcjtcclxuICAgIGRyYWdJbWFnZVlPZmZzZXQ/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgZGljdGlvbmFyeSBtYXBwaW5nIG9mIE1JTUUgdHlwZXMgdG8gZGF0YVxyXG4gICAgICovXHJcbiAgICBkYXRhOiB7IFttaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEcmFnZ2FibGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGVmZmVjdEFsbG93ZWQsIGRhdGEsIGRyYWdJbWFnZSwgZHJhZ0ltYWdlWE9mZnNldCwgZHJhZ0ltYWdlWU9mZnNldCB9OiBVc2VEcmFnZ2FibGVQYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgY29uc3QgW2RyYWdnaW5nLCBzZXREcmFnZ2luZywgZ2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2xhc3REcm9wRWZmZWN0LCBzZXRMYXN0RHJvcEVmZmVjdCwgZ2V0TGFzdERyb3BFZmZlY3RdID0gdXNlU3RhdGU8RGF0YVRyYW5zZmVyW1wiZHJvcEVmZmVjdFwiXSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHVzZURyYWdnYWJsZVByb3BzID0gdXNlQ2FsbGJhY2soPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4ocDogUCkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCByZWYgPSB1c2VSZWY8RT4obnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gKGU6IERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAvL2UucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0RHJhZ2dpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xyXG4gICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IChlZmZlY3RBbGxvd2VkID8/IFwiYWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJbWFnZSlcclxuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ0ltYWdlLCBkcmFnSW1hZ2VYT2Zmc2V0ID8/IDAsIGRyYWdJbWFnZVlPZmZzZXQgPz8gMClcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSkgYXMgW21pbWVUeXBlOiBzdHJpbmcsIGRhdGE6IHN0cmluZ11bXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21pbWVUeXBlLCBkYXRhXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShtaW1lVHlwZSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBvbkRyYWdFbmQgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ICE9IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFzdERyb3BFZmZlY3QoZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMYXN0RHJvcEVmZmVjdChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oe1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQsXHJcbiAgICAgICAgICAgIHJlZlxyXG4gICAgICAgIH0sIHApO1xyXG5cclxuICAgIH0sIFtlZmZlY3RBbGxvd2VkLCBkcmFnSW1hZ2UsIGRyYWdJbWFnZVhPZmZzZXQsIGRyYWdJbWFnZVlPZmZzZXQsIC4uLk9iamVjdC5lbnRyaWVzKGRhdGEpLmZsYXQoKV0pO1xyXG5cclxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxyXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxyXG4gICAgY29uc3QgcmV0OiBVc2VEcmFnZ2FibGVSZXR1cm5UeXBlPEU+ID0ge1xyXG4gICAgICAgIHVzZURyYWdnYWJsZVByb3BzLFxyXG4gICAgICAgIGRyYWdnaW5nLFxyXG4gICAgICAgIGdldERyYWdnaW5nLFxyXG4gICAgICAgIGxhc3REcm9wRWZmZWN0LFxyXG4gICAgICAgIGdldExhc3REcm9wRWZmZWN0XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJvcHBhYmxlUmV0dXJuVHlwZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvb2sgZm9yIG1vZGlmeWluZyB0aGUgcHJvcHMgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byB5b3VyIGRyb3AgdGFyZ2V0IEVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqICpVbnN0YWJsZSpcclxuICAgICAqL1xyXG4gICAgdXNlRHJvcHBhYmxlUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGlsZSBzb21ldGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudCwgdGhpcyB3aWxsIGNvbnRhaW4gYW55IGluZm9ybWF0aW9uIGFib3V0IGFueSBmaWxlcyBpbmNsdWRlZCBpbiB0aGF0IGRyb3AuXHJcbiAgICAgKiBPdGhlcndpc2UsIGl0J2xsIGJlIG51bGwsIG1lYW5pbmcgbm90aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBmaWxlc0ZvckNvbnNpZGVyYXRpb246IERyb3BGaWxlTWV0YWRhdGFbXSB8IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIFdoaWxlIHNvbWV0aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LCBhIGxpc3Qgb2YgYXZhaWxhYmxlIE1JTUUgdHlwZXMgZm9yIHRoZSBub24tZmlsZSBkYXRhIHdpbGwgYmUgbGlzdGVkIGhlcmUuXHJcbiAgICAgKiBPdGhlcndpc2UsIGl0J2xsIGJlIG51bGwsIG1lYW5pbmcgbm90aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbjogU2V0PHN0cmluZz4gfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBmaWxlcyBhcmUgZHJvcHBlZCBvdmVyIHRoZSBlbGVtZW50LCB0aGVpciBkYXRhIHdpbGwgYmUgZ2l2ZW4gaGVyZS5cclxuICAgICAqIFRoaXMgd2lsbCB1cGRhdGUgYXMgbmV3IGRyb3BzIGhhcHBlbi5cclxuICAgICAqL1xyXG4gICAgZHJvcHBlZEZpbGVzOiBEcm9wRmlsZVtdIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gbm9uLWZpbGUgZGF0YSBpcyBkcm9wcGVkIG92ZXIgdGhlIGVsZW1lbnQsIHRoZWlyIGRhdGEgd2lsbCBiZSBnaXZlbiBoZXJlLlxyXG4gICAgICogVGhpcyB3aWxsIHVwZGF0ZSBhcyBuZXcgZHJvcHMgaGFwcGVuLlxyXG4gICAgICovXHJcbiAgICBkcm9wcGVkU3RyaW5nczogeyBbTWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9IHwgbnVsbDtcclxuXHJcblxyXG4gICAgZHJvcEVycm9yOiB1bmtub3duO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyb3BwYWJsZVBhcmFtZXRlcnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHRvIHRoZSBEcmFnIGFuZCBEcm9wIEFQSSAtLSBlZmZlY3RpdmVseSBtZWFucyBcImFzIGNsb3NlIGFzIHBvc3NpYmxlLCB3aGF0J3MgaGFwcGVuaW5nIHRvIHRoZSBkYXRhIHdoZW4gSSBkcm9wIGl0IGhlcmU/IFxyXG4gICAgICogQW0gSSBjb3B5aW5nIGl0IGFuZCBsZWF2aW5nIHRoZSBvcmlnaW5hbCwgYW0gSSBtb3ZpbmcgaXQgYW5kIGRlbGV0aW5nIHRoZSBvcmlnaW5hbCwgb3IgYW0gSSBsaW5raW5nIGl0IHRvIHRoZSBvcmlnaW5hbD9cIlxyXG4gICAgICogXHJcbiAgICAgKiBXaGF0ZXZlciBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyB3aWxsIGhhdmUgaXRzIG93biBwZXJtaXNzaW9uIHRoYXQncyBjaGVja2VkIGFnYWluc3QgdGhpcy5cclxuICAgICAqL1xyXG4gICAgZWZmZWN0OiBEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERyb3BGaWxlIGV4dGVuZHMgRHJvcEZpbGVNZXRhZGF0YSB7IG5hbWU6IHN0cmluZywgZGF0YTogQXJyYXlCdWZmZXIsIHNpemU6IG51bWJlciB8IHVuZGVmaW5lZCwgbGFzdE1vZGlmaWVkOiBudW1iZXIgfCB1bmRlZmluZWQgfVxyXG5leHBvcnQgaW50ZXJmYWNlIERyb3BGaWxlTWV0YWRhdGEgeyB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQgfVxyXG5cclxuXHJcbnR5cGUgRHJvcHBhYmxlRmlsZUVycm9yVHlwZSA9IFwiSW5kZXhTaXplRXJyb3JcIiB8IFwiSGllcmFyY2h5UmVxdWVzdEVycm9yXCIgfCBcIldyb25nRG9jdW1lbnRFcnJvclwiIHwgXCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3JcIiB8IFwiTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3JcIiB8IFwiTm90Rm91bmRFcnJvclwiIHwgXCJOb3RTdXBwb3J0ZWRFcnJvclwiIHwgXCJJbnZhbGlkU3RhdGVFcnJvclwiIHwgXCJJblVzZUF0dHJpYnV0ZUVycm9yXCIgfCBcIlN5bnRheEVycm9yXCIgfCBcIkludmFsaWRNb2RpZmljYXRpb25FcnJvclwiIHwgXCJOYW1lc3BhY2VFcnJvclwiIHwgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiB8IFwiVHlwZU1pc21hdGNoRXJyb3JcIiB8IFwiU2VjdXJpdHlFcnJvclwiIHwgXCJOZXR3b3JrRXJyb3JcIiB8IFwiQWJvcnRFcnJvclwiIHwgXCJVUkxNaXNtYXRjaEVycm9yXCIgfCBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHwgXCJUaW1lb3V0RXJyb3JcIiB8IFwiSW52YWxpZE5vZGVUeXBlRXJyb3JcIiB8IFwiRGF0YUNsb25lRXJyb3JcIiB8IFwiRW5jb2RpbmdFcnJvclwiIHwgXCJOb3RSZWFkYWJsZUVycm9yXCIgfCBcIlVua25vd25FcnJvclwiIHwgXCJDb25zdHJhaW50RXJyb3JcIiB8IFwiRGF0YUVycm9yXCIgfCBcIlRyYW5zYWN0aW9uSW5hY3RpdmVFcnJvclwiIHwgXCJSZWFkT25seUVycm9yXCIgfCBcIlZlcnNpb25FcnJvclwiIHwgXCJPcGVyYXRpb25FcnJvclwiIHwgXCJOb3RBbGxvd2VkRXJyb3JcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBEcm9wcGFibGVGaWxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xyXG4gICAgZXJyb3JUeXBlOiBEcm9wcGFibGVGaWxlRXJyb3JUeXBlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZpbGVOYW1lOiBzdHJpbmcsIGJhc2U6IERPTUV4Y2VwdGlvbiB8IG51bGwpIHtcclxuICAgICAgICBzdXBlcihiYXNlPy5tZXNzYWdlID8/IFwiQW4gdW5zcGVjaWZpZWQgZXJyb3Igb2NjdXJyZWQgcmVhZGluZyB0aGUgZmlsZS5cIik7XHJcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JUeXBlID0gKGJhc2U/Lm5hbWUgYXMgRHJvcHBhYmxlRmlsZUVycm9yVHlwZSk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEcm9wcGFibGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGVmZmVjdCB9OiBVc2VEcm9wcGFibGVQYXJhbWV0ZXJzKTogVXNlRHJvcHBhYmxlUmV0dXJuVHlwZTxFPiB7XHJcblxyXG4gICAgY29uc3QgW2ZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uXSA9IHVzZVN0YXRlPG51bGwgfCBEcm9wRmlsZU1ldGFkYXRhW10+KG51bGwpO1xyXG4gICAgY29uc3QgW3N0cmluZ3NGb3JDb25zaWRlcmF0aW9uLCBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbl0gPSB1c2VTdGF0ZTxudWxsIHwgU2V0PHN0cmluZz4+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IFtkcm9wcGVkRmlsZXMsIHNldERyb3BwZWRGaWxlc10gPSB1c2VTdGF0ZTxudWxsIHwgRHJvcEZpbGVbXT4obnVsbCk7XHJcbiAgICBjb25zdCBbZHJvcHBlZFN0cmluZ3MsIHNldERyb3BwZWRTdHJpbmdzXSA9IHVzZVN0YXRlPG51bGwgfCB7IFtNaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH0+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IFtkcm9wRXJyb3IsIHNldERyb3BFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuICAgIC8vIEFsbCB0aGUgcHJvbWlzZXMgZ2VuZXJhdGVkIGZyb20gdGhlIGRyb3AgZXZlbnRzLlxyXG4gICAgLy8gVXNlZCB0byBwcm9jZXNzIG11bHRpcGxlIGRyb3AgZXZlbnRzIGluIHN1Y2Nlc3Npb25cclxuICAgIGNvbnN0IGRyb3BQcm9taXNlc1JlZiA9IHVzZVJlZjxQcm9taXNlPG51bGwgfCB7IHN0cmluZ3M6IHsgW21pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSwgZmlsZXM6IERyb3BGaWxlW10gfT5bXT4oW10pO1xyXG4gICAgY29uc3QgW2N1cnJlbnRQcm9taXNlSW5kZXgsIHNldEN1cnJlbnRQcm9taXNlSW5kZXgsIGdldEN1cnJlbnRQcm9taXNlSW5kZXhdID0gdXNlU3RhdGUoLTEpO1xyXG4gICAgY29uc3QgW3Byb21pc2VDb3VudCwgc2V0UHJvbWlzZUNvdW50LCBnZXRQcm9taXNlQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgLy8gQW55IHRpbWUgd2UgYWRkIGEgbmV3IHByb21pc2UsIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBwcm9taXNlIHJ1bm5pbmcsIHdlIG5lZWQgdG8gc3RhcnQgb25lLlxyXG4gICAgLy8gSWYgdGhlcmUgaXMgb25lLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcsIHNpbmNlIGl0IHJ1bnMgdGhlIHNhbWUgY2hlY2suXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlSW5kZXggPSBnZXRDdXJyZW50UHJvbWlzZUluZGV4KCk7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XHJcblxyXG4gICAgICAgIGlmIChwcm9taXNlQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICgoY3VycmVudFByb21pc2VJbmRleCArIDEpIDwgcHJvbWlzZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50UHJvbWlzZUluZGV4KGkgPT4gKytpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBbcHJvbWlzZUNvdW50XSk7XHJcblxyXG4gICAgLy8gQW55dGltZSBvdXIgY3VycmVudCBwcm9taXNlIGNoYW5nZXMsXHJcbiAgICAvLyB3YWl0IGZvciBpdCB0byBmaW5pc2gsIHRoZW4gc2V0IG91ciBzdGF0ZSB0byBpdHMgcmVzdWx0LlxyXG4gICAgLy8gRmluYWxseSwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnltb3JlIHByb21pc2VzLlxyXG4gICAgLy8gSWYgdGhlcmUgYXJlLCB0aGVuIGluY3JlYXNlIGN1cnJlbnRQcm9taXNlQ291bnQsXHJcbiAgICAvLyB3aGljaCB3aWxsIHRyaWdnZXIgdGhpcyBhZ2Fpbi5cclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gKm9mdGVuKiwgYnV0IG1heWJlIGluIHRoZSBjYXNlIG9mXHJcbiAgICAvLyBpbmRpdmlkdWFsbHkgZHJvcHBpbmcgYSBidW5jaCBvZiBsYXJnZSBmaWxlcyBvciBzb21ldGhpbmcuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50UHJvbWlzZUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFByb21pc2UgPSBkcm9wUHJvbWlzZXNSZWYuY3VycmVudFtjdXJyZW50UHJvbWlzZUluZGV4XTtcclxuICAgICAgICAgICAgY3VycmVudFByb21pc2UudGhlbigoaW5mbykgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmZvICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlcywgc3RyaW5ncyB9ID0gaW5mbztcclxuICAgICAgICAgICAgICAgICAgICBzZXREcm9wcGVkRmlsZXMoZmlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BwZWRTdHJpbmdzKHN0cmluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGRvbmUsIGFyZSB0aGVyZSBtb3JlIHByb21pc2VzIGluIHRoZSBxdWV1ZT9cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UHJvbWlzZUluZGV4ID0gZ2V0Q3VycmVudFByb21pc2VJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50UHJvbWlzZUluZGV4ICsgMSkgPCBwcm9taXNlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIHByb21pc2UgaGFzIHN0YXJ0ZWQsIG1vcmUgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGlzIGVmZmVjdCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50UHJvbWlzZUluZGV4KGkgPT4gKytpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LCBbY3VycmVudFByb21pc2VJbmRleF0pXHJcblxyXG5cclxuICAgIGNvbnN0IHVzZURyb3BwYWJsZVByb3BzOiBVc2VEcm9wcGFibGVSZXR1cm5UeXBlPEU+W1widXNlRHJvcHBhYmxlUHJvcHNcIl0gPSAocCkgPT4ge1xyXG5cclxuICAgICAgICAvL2NvbnN0IHJlZiA9IHVzZVJlZjxFPihudWxsKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGNvbGxlY3RpbmcgdGhlIGN1cnJlbnQgZmlsZSBtZXRhZGF0YSBvciBNSU1FIHR5cGVzLlxyXG4gICAgICAgIGNvbnN0IG9uRHJhZ0VudGVyID0gKGU6IERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGEgZGVmYXVsdD8gSSBjYW4ndCBmaW5kIG9uZSBhbnl3aGVyZS5cclxuICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAoZWZmZWN0ID8/IFwibW92ZVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNaW1lVHlwZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGVzID0gbmV3IEFycmF5PERyb3BGaWxlTWV0YWRhdGE+KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGUuZGF0YVRyYW5zZmVyPy5pdGVtcyA/PyBbXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHlwZSB9ID0gaXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWltZVR5cGVzLmFkZCh0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2luZCA9PT0gXCJmaWxlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZXMucHVzaCh7IHR5cGU6IGl0ZW0udHlwZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbihuZXdGaWxlcyk7XHJcbiAgICAgICAgICAgICAgICBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbihuZXdNaW1lVHlwZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHJlc2V0dGluZyB0aGUgY3VycmVudCBmaWxlIG1ldGFkYXRhIG9yIE1JTUUgdHlwZXNcclxuICAgICAgICBjb25zdCBvbkRyYWdMZWF2ZSA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XHJcbiAgICAgICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEJvaWxlcnBsYXRlLCBJIGd1ZXNzXHJcbiAgICAgICAgY29uc3Qgb25EcmFnT3ZlciA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGdldHRpbmcgdGhlIGRyb3AgZGF0YSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGNvbnN0IG9uRHJvcCA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFsbFByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkcm9wRGF0YTogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XHJcbiAgICAgICAgICAgIGNvbnN0IGRyb3BGaWxlOiBEcm9wRmlsZVtdID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZS5kYXRhVHJhbnNmZXI/Lml0ZW1zID8/IFtdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtpbmQsIHR5cGUgfSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxQcm9taXNlcy5wdXNoKChuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCBfcmVqZWN0KSA9PiBpdGVtLmdldEFzU3RyaW5nKHJlc29sdmUpKSkudGhlbihzdHIgPT4gZHJvcERhdGFbdHlwZV0gPSBzdHIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IFwiZmlsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChfKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5yZXN1bHQgYXMgQXJyYXlCdWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGaWxlLnB1c2goeyBkYXRhLCBuYW1lOiBmaWxlLm5hbWUsIHR5cGU6IGZpbGUudHlwZSwgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoLCBsYXN0TW9kaWZpZWQ6IGZpbGUubGFzdE1vZGlmaWVkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoXykgPT4geyByZWplY3QobmV3IERyb3BwYWJsZUZpbGVFcnJvcihmaWxlLm5hbWUsIHJlYWRlci5lcnJvcikpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmFib3J0ID0gKF8pID0+IHsgcmVqZWN0KG5ldyBEcm9wcGFibGVGaWxlRXJyb3IoZmlsZS5uYW1lLCByZWFkZXIuZXJyb3IpKTsgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZpbGUucHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGRyb3BQcm9taXNlc1JlZi5jdXJyZW50LnB1c2goUHJvbWlzZS5hbGwoYWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbWlzZUNvdW50KGkgPT4gKytpKTtcclxuICAgICAgICAgICAgICAgIHNldERyb3BFcnJvcihudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nczogZHJvcERhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGRyb3BGaWxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIHNldFByb21pc2VDb3VudChpID0+ICsraSk7XHJcbiAgICAgICAgICAgICAgICBzZXREcm9wRXJyb3IoZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oeyBvbkRyYWdFbnRlciwgb25EcmFnTGVhdmUsIG9uRHJhZ092ZXIsIG9uRHJvcCB9LCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VEcm9wcGFibGVQcm9wcyxcclxuICAgICAgICBmaWxlc0ZvckNvbnNpZGVyYXRpb24sXHJcbiAgICAgICAgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sXHJcbiAgICAgICAgZHJvcHBlZEZpbGVzLFxyXG4gICAgICAgIGRyb3BwZWRTdHJpbmdzLFxyXG5cclxuICAgICAgICBkcm9wRXJyb3JcclxuICAgIH1cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0RWxlbWVudCgpOiBUIHwgbnVsbDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xyXG4gICAgb25FbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+O1xyXG4gICAgb25Nb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG4gICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxyXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcclxuICogYWRkaW5nIGEgUmVmQ2FsbGJhY2sgYW5kIG1lcmdpbmcgaXQgd2l0aCBhbnkgZXhpc3RpbmcgcmVmIHRoYXQgZXhpc3RlZCBvbiB0aGUgcHJvcHMuXHJcbiAqIFxyXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcclxuICogXHJcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGFyZ3M/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcclxuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzID8/IHt9KTtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcclxuXHJcbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cclxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD4+KChlLCBwcmV2VmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcclxuICAgICAgICBpZiAocHJldlZhbHVlKVxyXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcclxuXHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxyXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XHJcbiAgICBjb25zdCB1c2VSZWZFbGVtZW50UHJvcHMgPSB1c2VDYWxsYmFjazxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXT4oKHByb3BzKSA9PiB1c2VNZXJnZWRQcm9wczxUPih7IHJlZjogc2V0RWxlbWVudCB9LCBwcm9wcyksIFtdKTtcclxuXHJcbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcclxuICAgIC8vIHRoZSBwcm9wcyBhbmQgYWxsb3dzIHVzIHRvIGFjdHVhbGx5IGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlUmVmRWxlbWVudFByb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH1cclxufVxyXG5cclxuZnVuY3Rpb24gcnVuSW1tZWRpYXRlbHkoZjogKCkgPT4gdm9pZCkge1xyXG4gICAgZigpO1xyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuXHJcbmludGVyZmFjZSBVc2VFbGVtZW50U2l6ZVBhcmFtZXRlcnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGJyb3dzZXIgZGV0ZWN0cyBhIHNpemUgY2hhbmdlXHJcbiAgICAgKiBvbiB0aGUgZWxlbWVudC4gRG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUsIHNvIHlvdVxyXG4gICAgICogY2FuIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHRoYXQgb25seSBzZXRzIHRoZVxyXG4gICAgICogdmFsdWVzIHlvdSB1c2UgaWYgeW91J2QgbGlrZS5cclxuICAgICAqIEBwYXJhbSBzaXplSW5mbyBcclxuICAgICAqL1xyXG4gICAgb25TaXplQ2hhbmdlKHNpemVJbmZvOiBFbGVtZW50U2l6ZSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNyZWF0ZWQgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZU9ic2VydmVyL29ic2VydmUjcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBnZXRPYnNlcnZlQm94PygpOiBSZXNpemVPYnNlcnZlck9wdGlvbnNbXCJib3hcIl07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudFNpemUge1xyXG4gICAgY2xpZW50V2lkdGg6IG51bWJlcjtcclxuICAgIHNjcm9sbFdpZHRoOiBudW1iZXI7XHJcbiAgICBvZmZzZXRXaWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50SGVpZ2h0OiBudW1iZXI7XHJcbiAgICBzY3JvbGxIZWlnaHQ6IG51bWJlcjtcclxuICAgIG9mZnNldEhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50TGVmdDogbnVtYmVyO1xyXG4gICAgc2Nyb2xsTGVmdDogbnVtYmVyO1xyXG4gICAgb2Zmc2V0TGVmdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50VG9wOiBudW1iZXI7XHJcbiAgICBzY3JvbGxUb3A6IG51bWJlcjtcclxuICAgIG9mZnNldFRvcDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUVsZW1lbnRTaXplUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQoKTogRSB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0U2l6ZSgpOiBFbGVtZW50U2l6ZSB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlRWxlbWVudFNpemVQcm9wczogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT5bXCJ1c2VSZWZFbGVtZW50UHJvcHNcIl07XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRWxlbWVudFNpemU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZ2V0T2JzZXJ2ZUJveCwgb25TaXplQ2hhbmdlIH06IFVzZUVsZW1lbnRTaXplUGFyYW1ldGVycyk6IFVzZUVsZW1lbnRTaXplUmV0dXJuVHlwZTxFPiB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlRWxlbWVudFNpemVcIiwgZ2V0T2JzZXJ2ZUJveCwgb25TaXplQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0U2l6ZSwgc2V0U2l6ZV0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudFNpemUgfCBudWxsPihvblNpemVDaGFuZ2UgYXMgT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudFNpemUgfCBudWxsPiwgcmV0dXJuTnVsbCk7XHJcblxyXG4gICAgY29uc3QgY3VycmVudE9ic2VydmVCb3ggPSB1c2VSZWY8UmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuICAgIGNvbnN0IG5lZWRBTmV3T2JzZXJ2ZXIgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIG9ic2VydmVCb3g6IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSA9IChlbGVtZW50IGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U2l6ZSh7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93ICYmIChcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKF9lbnRyaWVzKSA9PiB7IGhhbmRsZVVwZGF0ZSgpOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBvYnNlcnZlQm94IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEU+KHsgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogRSB8IG51bGwpID0+IG5lZWRBTmV3T2JzZXJ2ZXIoZSwgZ2V0T2JzZXJ2ZUJveD8uKCkpLCBbXSkgfSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZ2V0T2JzZXJ2ZUJveCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE9ic2VydmVCb3guY3VycmVudCAhPT0gZ2V0T2JzZXJ2ZUJveCgpKVxyXG4gICAgICAgICAgICAgICAgbmVlZEFOZXdPYnNlcnZlcihnZXRFbGVtZW50KCksIGdldE9ic2VydmVCb3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldFNpemUsXHJcbiAgICAgICAgdXNlRWxlbWVudFNpemVQcm9wczogdXNlUmVmRWxlbWVudFByb3BzXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoLCBQcmVhY3RET01BdHRyaWJ1dGVzIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogVGhpcyBpcyB1c2VkIHRvIHNlbGVjdCAqanVzdCogdGhlIHR5cGVkIGFkZEV2ZW50TGlzdGVuZXIgXHJcbiAqIGFuZCBub3QgdGhlIGdlbmVyaWMgXCJJJ2xsIGFjY2VwdCBhbnkgc3RyaW5nIGFuZCBhbnkgaGFuZGxlclwiIG9uZS5cclxuICogXHJcbiAqIFRPRE86IFRoaXMgXCJcIlwid29ya3NcIlwiXCIgYnV0IGl0J3Mgbm90IGdyZWF0IGFuZCBpbXBsaWNpdGx5IHJlbGllcyBvblxyXG4gKiBsaWIuZG9tLnRzIGFsd2F5cyBnaXZlaW5nIHRoZSB0d28gb3ZlcmxvYWRzIGluIHRoZSBzYW1lIG9yZGVyLCB3aXRoIHRoZVxyXG4gKiB0eXBlZCBvbmUgZmlyc3QuICpUaGF0KiBwcm9iYWJseSB3b24ndCBjaGFuZ2UsIGJ1dCBpZiBtb3JlIG92ZXJsb2Fkc1xyXG4gKiBhcmUgZXZlciBhZGRlZCB0aGlzIHdpbGwgbmVlZCBhZGp1c3RtZW50LlxyXG4gKiBcclxuICogU2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS81Mjc2MTE1NiBmb3IgaG93IHNlbGVjdGluZyB0aGUgY29ycmVjdCBvdmVybG9hZCB3b3Jrcy5cclxuICovXHJcbnR5cGUgRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8VD4gPVxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBpbmZlciBSIH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55IH0gPyBSIDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUikgPT4gYW55ID8gUiA6IFtdO1xyXG5cclxuLy8gR2V0IGp1c3QgdGhlIHR5cGVkIHZlcnNpb24gb2YgYWRkRXZlbnRMaXN0ZW5lciwgaWYgaXQgZXhpc3RzXHJcbnR5cGUgVHlwZWRBZGRFdmVudExpc3RlbmVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSAoLi4uYXJnczogRmlyc3RPdmVybG9hZFBhcmFtZXRlcnM8KFRbXCJhZGRFdmVudExpc3RlbmVyXCJdKT4pID0+IHZvaWQ7XHJcblxyXG4vLyBSZXR1cm5zIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBcImFkZEV2ZW50TGlzdGVuZXJcIiAodGhlIGV2ZW50IHR5cGUgYXMgYSBzdHJpbmcpXHJcbnR5cGUgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VCBleHRlbmRzIEV2ZW50VGFyZ2V0PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUPiBleHRlbmRzICgodHlwZTogaW5mZXIgSzIsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSzIgOiBzdHJpbmc7XHJcblxyXG5cclxuLy8gVE9ETzogVGhpcyBpc24ndCBxdWl0ZSBhYmxlIHRvIG5hcnJvdyBkb3duIHRoZSBleGFjdCBldmVudCB0eXBlIGZvciB1bmtub3duIHJlYXNvbnMuXHJcbi8vIEluc3RlYWQgaXQgcmV0dXJucyBhIHVuaW9uIG9mIGFsbCBhdmFpbGFibGUgZXZlbnQgdHlwZXMsIHdoaWNoIGlzLi4uZmluZSwgSSBndWVzcy5cclxuLy8gSSBkb24ndCBrbm93IHdoeSBgaW5mZXIgSGAgaXMgZG9pbmcgdGhhdCB3aGVuIHRoZSB0eXBlIHNob3VsZCBiZSBuYXJyb3dlZCBieSBgVGAgdGhvdWdoLi4uXHJcbi8vIE5vdGUgdGhhdCB0aGUgdHlwZSBwYXJhbWV0ZXIgaXMgc3RpbGwgdXNlZCwgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBuYXJyb3cgZG93biB0aGUgdHlwZSxcclxuLy8gYmVjYXVzZSBvdGhlcndpc2UsIGluc3RlYWQgb2YgYmVpbmcgYSB1bmlvbiBvZiBhbGwgdHlwZXMsIGl0J3MganVzdCBgYW55YFxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyPEUgZXh0ZW5kcyBFdmVudFRhcmdldCwgVCBleHRlbmRzIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPEU+PiA9IFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogaW5mZXIgSCwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBOb25OdWxsYWJsZTxIPiA6IG5ldmVyO1xyXG4vLygoVHlwZWRBZGRFdmVudExpc3RlbmVyPEU+ICYgKCh0eXBlOiBULCBoYW5kbGVyOiAoZTogRXZlbnQpID0+IHZvaWQsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpKSBleHRlbmRzICgodHlwZTogVCwgaGFuZGxlcjogKGU6IGluZmVyIEgpID0+IGFueSwgLi4uYXJnczogYW55W10pID0+IGFueSkgPyBIIDogRnVuY3Rpb24pIC8qJiAoVCBleHRlbmRzIGtleW9mIEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcD8gR2xvYmFsRXZlbnRIYW5kbGVyc0V2ZW50TWFwW1RdIDogKGU6IEV2ZW50KSA9PiB2b2lkKSovO1xyXG5cclxudHlwZSBQYXJhbWV0ZXJzMjxUIGV4dGVuZHMgKEV2ZW50TGlzdGVuZXJPYmplY3QgfCAoKC4uLmFyZ3M6IGFueSkgPT4gYW55KSk+ID1cclxuICAgIFQgZXh0ZW5kcyBFdmVudExpc3RlbmVyT2JqZWN0ID8gUGFyYW1ldGVyczxUW1wiaGFuZGxlRXZlbnRcIl0+IDpcclxuICAgIFQgZXh0ZW5kcyAoLi4uYXJnczogaW5mZXIgUCkgPT4gYW55ID8gUCA6IG5ldmVyO1xyXG5cclxuXHJcbnR5cGUgVHlwZWRFdmVudEhhbmRsZXJFdmVudDxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBQYXJhbWV0ZXJzMjxUeXBlZEV2ZW50SGFuZGxlcjxFLCBUPj5bMF07XHJcblxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlciB0byBhbnkgKm5vbi1QcmVhY3QqIGVsZW1lbnQsIGFuZCByZW1vdmluZyBpdCB3aGVuIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhvb2sgdW5tb3VudHMuIFRoZSBjYWxsYmFjayBkb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICogXHJcbiAqIER1ZSB0byB0eXBpbmcgbGltaXRhdGlvbnMsIHRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgbGlrZSB0aGlzOlxyXG4gKiBcclxuICogYHVzZUV2ZW50SGFuZGxlcihlbGVtZW50LCBcImlucHV0XCIpPElucHV0RXZlbnQ+KGUgPT4ge30pYFxyXG4gKiBcclxuICogVGhlIHR5cGUgYXJndW1lbnQgaXMgb3B0aW9uYWwsIGJ1dCBuYXJyb3dzIGRvd24gdGhlIHR5cGUgZnJvbSBcImEgdW5pb24gb2YgYWxsIGV2ZW50c1wiIHRvIHdoYXRldmVyIHlvdSBzcGVjaWZ5LCBhbmQgZXJyb3JzIGlmIGl0IGRvZXNuJ3QgZXhpc3QuXHJcbiAqIFxyXG4gKiBUaGVyZSBpcyBhIHNlcGFyYXRlIHZlcnNpb24gdGhhdCBhdHRhY2hlcyBldmVudCBoYW5kbGVycyB0byBhIHNldCBvZiBwcm9wcy4gXHJcbiAqIEl0IHRha2VzIGRpZmZlcmVudCBldmVudCBzdHJpbmcgdHlwZXMgKG9uRXZlbnQgdnMgb25ldmVudCkuXHJcbiAqIFxyXG4gKiBAcGFyYW0gdGFyZ2V0IEEgKm5vbi1QcmVhY3QqIG5vZGUgdG8gYXR0YWNoIHRoZSBldmVudCB0by5cclxuICogQHJldHVybnNcclxuICogKlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdsb2JhbEhhbmRsZXI8VCBleHRlbmRzIEV2ZW50VGFyZ2V0LCBFdmVudFR5cGUgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxUPiwgSCBleHRlbmRzIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8VCwgRXZlbnRUeXBlPj4odGFyZ2V0OiBULCB0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IG51bGwgfCAoKGU6IEgpID0+IHZvaWQpLCBvcHRpb25zPzogUGFyYW1ldGVyczxUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4+WzJdKTogdm9pZCB7XHJcblxyXG4gICAgLy8gTm90ZSB0byBzZWxmOiBUaGUgdHlwaW5nIGRvZXNuJ3QgaW1wcm92ZSBldmVuIGlmIHRoaXMgaXMgc3BsaXQgdXAgaW50byBhIHN1Yi1mdW5jdGlvbi5cclxuICAgIC8vIE5vIG1hdHRlciB3aGF0LCBpdCBzZWVtcyBpbXBvc3NpYmxlIHRvIGdldCB0aGUgaGFuZGxlcidzIGV2ZW50IG9iamVjdCB0eXBlZCBwZXJmZWN0bHkuXHJcbiAgICAvLyBJdCBzZWVtcyBsaWtlIGl0J3MgZ3VhcmFudGVlZCB0byBhbHdheXMgYmUgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIHR1cGVzLlxyXG4gICAgLy8gQWdhaW4sIG5vIG1hdHRlciB3aGF0IGNvbWJpbmF0aW9uIG9mIHN1Yi0gb3Igc3ViLXN1Yi1mdW5jdGlvbnMgdXNlZC5cclxuXHJcbiAgICBsZXQgc3RhYmxlSGFuZGxlcjogRXZlbnRMaXN0ZW5lciB8IG51bGwgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyID8/ICgoKSA9PiB7IH0pKSBhcyBFdmVudExpc3RlbmVyO1xyXG4gICAgaWYgKGhhbmRsZXIgPT0gbnVsbClcclxuICAgICAgICBzdGFibGVIYW5kbGVyID0gbnVsbDtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGFibGVIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIHN0YWJsZUhhbmRsZXIsIG9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFt0YXJnZXQsIHR5cGUsIHN0YWJsZUhhbmRsZXJdKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFuIGFsdGVybmF0aXZlIHdheSB0byBhZGQgYW4gZXZlbnQgaGFuZGxlciB0byBhbiBlbGVtZW50LiBVc2VmdWwgcHJpbWFyaWx5IHdoZW4gaW50ZWdyYXRpbmcgM3JkIHBhcnR5IGxpYnJhcmllcyB0aGF0IGV4cGVjdCBhIGdlbmVyaWMgXCJhZGQgZXZlbnQgaGFuZGxlclwiIGZ1bmN0aW9uLlxyXG4gKiBcclxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWxsb3dzIHlvdSB0byBtb2RpZnkgYSBzZXQgb2YgcHJvcHMgdG8gYXBwbHkgdGhpcyBoYW5kbGVyLlxyXG4gKiBcclxuICogRm9yIHR5cGluZyByZWFzb25zLCB0aGlzIGZ1bmN0aW9uIGlzIHNwbGl0IGludG8gdHdvLiAgVXNhZ2UgaXMgbGlrZSB0aGUgZm9sbG93aW5nOlxyXG4gKiBcclxuICogYGBgXHJcbiAqIGNvbnN0IHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9ID0gdXNlTG9jYWxFdmVudEhhbmRsZXI8SFRNTERpdkVsZW1lbnQ+KCkoXCJvbk1vdXNlRG93blwiLCBlID0+IHsgIH0pO1xyXG4gKiBjb25zdCBkaXZQcm9wcyA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMocHJvcHMpO1xyXG4gKiBgYGBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMb2NhbEhhbmRsZXI8RWxlbWVudFR5cGUgZXh0ZW5kcyAoSFRNTEVsZW1lbnRUYWdOYW1lTWFwW2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcF0gfCBTVkdFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBTVkdFbGVtZW50VGFnTmFtZU1hcF0pPigpIHtcclxuICAgIHJldHVybiB1c2VDYWxsYmFjayg8RXZlbnRUeXBlIGV4dGVuZHMgRXhjbHVkZTxrZXlvZiBoLkpTWC5ET01BdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPiwga2V5b2YgUHJlYWN0RE9NQXR0cmlidXRlcz4+KHR5cGU6IEV2ZW50VHlwZSwgaGFuZGxlcjogTm9uTnVsbGFibGU8aC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT5bRXZlbnRUeXBlXT4pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc3RhYmxlSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrKGhhbmRsZXIpO1xyXG5cclxuICAgICAgICBjb25zdCB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT4pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEVsZW1lbnRUeXBlPih7IFt0eXBlXTogc3RhYmxlSGFuZGxlciB9IGFzIHsgW0sgaW4gRXZlbnRUeXBlXTogdHlwZW9mIGhhbmRsZXIgfSwgcHJvcHMpIGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEVsZW1lbnRUeXBlPjtcclxuICAgICAgICB9LCBbdHlwZV0pO1xyXG5cclxuICAgICAgICByZXR1cm4geyB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzIH07XHJcblxyXG4gICAgfSwgW10pO1xyXG59XHJcbiIsImNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFtcbiAgJ2lucHV0JyxcbiAgJ3NlbGVjdCcsXG4gICd0ZXh0YXJlYScsXG4gICdhW2hyZWZdJyxcbiAgJ2J1dHRvbicsXG4gICdbdGFiaW5kZXhdOm5vdChzbG90KScsXG4gICdhdWRpb1tjb250cm9sc10nLFxuICAndmlkZW9bY29udHJvbHNdJyxcbiAgJ1tjb250ZW50ZWRpdGFibGVdOm5vdChbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0pJyxcbiAgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyxcbiAgJ2RldGFpbHMnLFxuXTtcbmNvbnN0IGNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9ycy5qb2luKCcsJyk7XG5cbmNvbnN0IE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcblxuY29uc3QgbWF0Y2hlcyA9IE5vRWxlbWVudFxuICA/IGZ1bmN0aW9uICgpIHt9XG4gIDogRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgRWxlbWVudC5wcm90b3R5cGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5jb25zdCBnZXRSb290Tm9kZSA9XG4gICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGVcbiAgICA/IChlbGVtZW50KSA9PiBlbGVtZW50LmdldFJvb3ROb2RlKClcbiAgICA6IChlbGVtZW50KSA9PiBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbCBjb250YWluZXIgdG8gY2hlY2sgaW5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIHRvIGNoZWNrXG4gKiBAcGFyYW0geyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoZWwsIGluY2x1ZGVDb250YWluZXIsIGZpbHRlcikge1xuICBsZXQgY2FuZGlkYXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShcbiAgICBlbC5xdWVyeVNlbGVjdG9yQWxsKGNhbmRpZGF0ZVNlbGVjdG9yKVxuICApO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZXNTY29wZVxuICogQHByb3BlcnR5IHtFbGVtZW50fSBzY29wZSBjb250YWlucyBpbm5lciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge0VsZW1lbnRbXX0gY2FuZGlkYXRlc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSXRlcmF0aXZlT3B0aW9uc1xuICogQHByb3BlcnR5IHtHZXRTaGFkb3dSb290fGJvb2xlYW59IGdldFNoYWRvd1Jvb3QgdHJ1ZSBpZiBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkOyBmYWxzeSBpZiBub3Q7XG4gKiAgaWYgYSBmdW5jdGlvbiwgaW1wbGllcyBzaGFkb3cgc3VwcG9ydCBpcyBlbmFibGVkIGFuZCBlaXRoZXIgcmV0dXJucyB0aGUgc2hhZG93IHJvb3Qgb2YgYW4gZWxlbWVudFxuICogIG9yIGEgYm9vbGVhbiBzdGF0aW5nIGlmIGl0IGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgcm9vdFxuICogQHByb3BlcnR5IHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGZsYXR0ZW4gaWYgdHJ1ZSB0aGVuIHJlc3VsdCB3aWxsIGZsYXR0ZW4gYW55IENhbmRpZGF0ZXNTY29wZSBpbnRvIHRoZSByZXR1cm5lZCBsaXN0XG4gKiBAcHJvcGVydHkge1NoYWRvd1Jvb3RGaWx0ZXJ9IHNoYWRvd1Jvb3RGaWx0ZXIgZmlsdGVyIHNoYWRvdyByb290cztcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50cyBsaXN0IG9mIGVsZW1lbnQgY29udGFpbmVycyB0byBtYXRjaCBjYW5kaWRhdGVzIGZyb21cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5jbHVkZUNvbnRhaW5lciBhZGQgY29udGFpbmVyIGxpc3QgdG8gY2hlY2tcbiAqIEBwYXJhbSB7SXRlcmF0aXZlT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59XG4gKi9cbmNvbnN0IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseSA9IGZ1bmN0aW9uIChcbiAgZWxlbWVudHMsXG4gIGluY2x1ZGVDb250YWluZXIsXG4gIG9wdGlvbnNcbikge1xuICBjb25zdCBjYW5kaWRhdGVzID0gW107XG4gIGNvbnN0IGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1RvQ2hlY2suc2hpZnQoKTtcbiAgICBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnU0xPVCcpIHtcbiAgICAgIC8vIGFkZCBzaGFkb3cgZG9tIHNsb3Qgc2NvcGUgKHNsb3QgaXRzZWxmIGNhbm5vdCBiZSBmb2N1c2FibGUpXG4gICAgICBjb25zdCBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgY29uc3QgY29udGVudCA9IGFzc2lnbmVkLmxlbmd0aCA/IGFzc2lnbmVkIDogZWxlbWVudC5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoY29udGVudCwgdHJ1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCguLi5uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgc2NvcGU6IGVsZW1lbnQsXG4gICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGNoZWNrIGNhbmRpZGF0ZSBlbGVtZW50XG4gICAgICBjb25zdCB2YWxpZENhbmRpZGF0ZSA9IG1hdGNoZXMuY2FsbChlbGVtZW50LCBjYW5kaWRhdGVTZWxlY3Rvcik7XG4gICAgICBpZiAoXG4gICAgICAgIHZhbGlkQ2FuZGlkYXRlICYmXG4gICAgICAgIG9wdGlvbnMuZmlsdGVyKGVsZW1lbnQpICYmXG4gICAgICAgIChpbmNsdWRlQ29udGFpbmVyIHx8ICFlbGVtZW50cy5pbmNsdWRlcyhlbGVtZW50KSlcbiAgICAgICkge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGl0ZXJhdGUgb3ZlciBzaGFkb3cgY29udGVudCBpZiBwb3NzaWJsZVxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9XG4gICAgICAgIGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgICAvLyBjaGVjayBmb3IgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICh0eXBlb2Ygb3B0aW9ucy5nZXRTaGFkb3dSb290ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgb3B0aW9ucy5nZXRTaGFkb3dSb290KGVsZW1lbnQpKTtcblxuICAgICAgY29uc3QgdmFsaWRTaGFkb3dSb290ID1cbiAgICAgICAgIW9wdGlvbnMuc2hhZG93Um9vdEZpbHRlciB8fCBvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIoZWxlbWVudCk7XG5cbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIGNvbnN0IG5lc3RlZENhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoXG4gICAgICAgICAgc2hhZG93Um9vdCA9PT0gdHJ1ZSA/IGVsZW1lbnQuY2hpbGRyZW4gOiBzaGFkb3dSb290LmNoaWxkcmVuLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgICAgY2FuZGlkYXRlczogbmVzdGVkQ2FuZGlkYXRlcyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gdGhlcmUncyBub3Qgc2hhZG93IHNvIGp1c3QgZGlnIGludG8gdGhlIGVsZW1lbnQncyAobGlnaHQgZG9tKSBjaGlsZHJlblxuICAgICAgICAvLyAgX193aXRob3V0X18gZ2l2aW5nIHRoZSBlbGVtZW50IHNwZWNpYWwgc2NvcGUgdHJlYXRtZW50XG4gICAgICAgIGVsZW1lbnRzVG9DaGVjay51bnNoaWZ0KC4uLmVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGdldFRhYmluZGV4ID0gZnVuY3Rpb24gKG5vZGUsIGlzU2NvcGUpIHtcbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgLy9cbiAgICAvLyBpc1Njb3BlIGlzIHBvc2l0aXZlIGZvciBjdXN0b20gZWxlbWVudCB3aXRoIHNoYWRvdyByb290IG9yIHNsb3QgdGhhdCBieSBkZWZhdWx0XG4gICAgLy8gaGF2ZSB0YWJJbmRleCAtMSwgYnV0IG5lZWQgdG8gYmUgc29ydGVkIGJ5IGRvY3VtZW50IG9yZGVyIGluIG9yZGVyIGZvciB0aGVpclxuICAgIC8vIGNvbnRlbnQgdG8gYmUgaW5zZXJ0ZWQgaW4gdGhlIGNvcnJlY3QgcG9zaXRpb25cbiAgICBpZiAoXG4gICAgICAoaXNTY29wZSB8fFxuICAgICAgICAvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fFxuICAgICAgICBub2RlLmlzQ29udGVudEVkaXRhYmxlKSAmJlxuICAgICAgaXNOYU4ocGFyc2VJbnQobm9kZS5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JyksIDEwKSlcbiAgICApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBub2RlLnRhYkluZGV4O1xufTtcblxuY29uc3Qgc29ydE9yZGVyZWRUYWJiYWJsZXMgPSBmdW5jdGlvbiAoYSwgYikge1xuICByZXR1cm4gYS50YWJJbmRleCA9PT0gYi50YWJJbmRleFxuICAgID8gYS5kb2N1bWVudE9yZGVyIC0gYi5kb2N1bWVudE9yZGVyXG4gICAgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG5cbmNvbnN0IGlzSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcblxuY29uc3QgaXNIaWRkZW5JbnB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xuXG5jb25zdCBpc0RldGFpbHNXaXRoU3VtbWFyeSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHIgPVxuICAgIG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmXG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlXG4gICAgICAuYXBwbHkobm9kZS5jaGlsZHJlbilcbiAgICAgIC5zb21lKChjaGlsZCkgPT4gY2hpbGQudGFnTmFtZSA9PT0gJ1NVTU1BUlknKTtcbiAgcmV0dXJuIHI7XG59O1xuXG5jb25zdCBnZXRDaGVja2VkUmFkaW8gPSBmdW5jdGlvbiAobm9kZXMsIGZvcm0pIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChub2Rlc1tpXS5jaGVja2VkICYmIG5vZGVzW2ldLmZvcm0gPT09IGZvcm0pIHtcbiAgICAgIHJldHVybiBub2Rlc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3QgcmFkaW9TY29wZSA9IG5vZGUuZm9ybSB8fCBnZXRSb290Tm9kZShub2RlKTtcbiAgY29uc3QgcXVlcnlSYWRpb3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHJldHVybiByYWRpb1Njb3BlLnF1ZXJ5U2VsZWN0b3JBbGwoXG4gICAgICAnaW5wdXRbdHlwZT1cInJhZGlvXCJdW25hbWU9XCInICsgbmFtZSArICdcIl0nXG4gICAgKTtcbiAgfTtcblxuICBsZXQgcmFkaW9TZXQ7XG4gIGlmIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuQ1NTLmVzY2FwZSA9PT0gJ2Z1bmN0aW9uJ1xuICApIHtcbiAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKHdpbmRvdy5DU1MuZXNjYXBlKG5vZGUubmFtZSkpO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICByYWRpb1NldCA9IHF1ZXJ5UmFkaW9zKG5vZGUubmFtZSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLFxuICAgICAgICBlcnIubWVzc2FnZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG5cbmNvbnN0IGlzUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xuXG5jb25zdCBpc05vblRhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNSYWRpbyhub2RlKSAmJiAhaXNUYWJiYWJsZVJhZGlvKG5vZGUpO1xufTtcblxuY29uc3QgaXNaZXJvQXJlYSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHdpZHRoID09PSAwICYmIGhlaWdodCA9PT0gMDtcbn07XG5jb25zdCBpc0hpZGRlbiA9IGZ1bmN0aW9uIChub2RlLCB7IGRpc3BsYXlDaGVjaywgZ2V0U2hhZG93Um9vdCB9KSB7XG4gIC8vIE5PVEU6IHZpc2liaWxpdHkgd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiBub2RlIGlzIGRldGFjaGVkIGZyb20gdGhlIGRvY3VtZW50XG4gIC8vICAoc2VlIG5vdGVzIGFib3V0IHRoaXMgZnVydGhlciBkb3duKSwgd2hpY2ggbWVhbnMgd2Ugd2lsbCBjb25zaWRlciBpdCB2aXNpYmxlXG4gIC8vICAodGhpcyBpcyBsZWdhY3kgYmVoYXZpb3IgZnJvbSBhIHZlcnkgbG9uZyB3YXkgYmFjaylcbiAgLy8gTk9URTogd2UgY2hlY2sgdGhpcyByZWdhcmRsZXNzIG9mIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIGJlY2F1c2UgdGhpcyBpcyBhXG4gIC8vICBfdmlzaWJpbGl0eV8gY2hlY2ssIG5vdCBhIF9kaXNwbGF5XyBjaGVja1xuICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS52aXNpYmlsaXR5ID09PSAnaGlkZGVuJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgY29uc3QgaXNEaXJlY3RTdW1tYXJ5ID0gbWF0Y2hlcy5jYWxsKG5vZGUsICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScpO1xuICBjb25zdCBub2RlVW5kZXJEZXRhaWxzID0gaXNEaXJlY3RTdW1tYXJ5ID8gbm9kZS5wYXJlbnRFbGVtZW50IDogbm9kZTtcbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlVW5kZXJEZXRhaWxzLCAnZGV0YWlsczpub3QoW29wZW5dKSAqJykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRoZSByb290IG5vZGUgaXMgdGhlIHNoYWRvdyByb290IGlmIHRoZSBub2RlIGlzIGluIGEgc2hhZG93IERPTTsgc29tZSBkb2N1bWVudCBvdGhlcndpc2VcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xuICAvLyAgaXMgYXR0YWNoZWQsIGFuZCB0aGUgb25lIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBpbiB0aGUgZG9jdW1lbnQgb3Igbm90IChiZWNhdXNlIHRoZVxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxuICAvLyAgaXMgaGlkZGVuLCBvciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGl0c2VsZiBidXQgaXMgZGV0YWNoZWQsIGl0IHdpbGwgYWZmZWN0IHRoZSBzaGFkb3cnc1xuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgLy8gIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBub3QgdGhlIHNoYWRvdyByb290LCBub3IgYW55IG9mIGl0cyBjaGlsZHJlbiAoaS5lLiB0aGUgbm9kZSBiZWluZ1xuICAvLyAgdGVzdGVkKS5cbiAgLy8gSWYgcm9vdE5vZGUgaXMgbm90IGEgc2hhZG93IHJvb3QsIGl0IHdvbid0IGhhdmUgYSBob3N0LCBhbmQgc28gcm9vdE5vZGUgc2hvdWxkIGJlIHRoZVxuICAvLyAgZG9jdW1lbnQgKHBlciB0aGUgZG9jcykgYW5kIHdoaWxlIGl0J3MgYSBEb2N1bWVudC10eXBlIG9iamVjdCwgdGhhdCBkb2N1bWVudCBkb2VzIG5vdFxuICAvLyAgYXBwZWFyIHRvIGJlIHRoZSBzYW1lIGFzIHRoZSBub2RlJ3MgYG93bmVyRG9jdW1lbnRgIGZvciBzb21lIHJlYXNvbiwgc28gaXQncyBzYWZlclxuICAvLyAgdG8gaWdub3JlIHRoZSByb290Tm9kZSBhdCB0aGlzIHBvaW50LCBhbmQgdXNlIGBub2RlLm93bmVyRG9jdW1lbnRgLiBPdGhlcndpc2UsXG4gIC8vICB1c2luZyBgcm9vdE5vZGUuY29udGFpbnMobm9kZSlgIHdpbGwgX2Fsd2F5c18gYmUgdHJ1ZSB3ZSdsbCBnZXQgZmFsc2UtcG9zaXRpdmVzIHdoZW5cbiAgLy8gIG5vZGUgaXMgYWN0dWFsbHkgZGV0YWNoZWQuXG4gIGNvbnN0IG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGUpLmhvc3Q7XG4gIGNvbnN0IG5vZGVJc0F0dGFjaGVkID1cbiAgICBub2RlUm9vdEhvc3Q/Lm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZVJvb3RIb3N0KSB8fFxuICAgIG5vZGUub3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKTtcblxuICBpZiAoIWRpc3BsYXlDaGVjayB8fCBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJykge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICBjb25zdCBvcmlnaW5hbE5vZGUgPSBub2RlO1xuICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50RWxlbWVudCA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQgJiZcbiAgICAgICAgICAhcGFyZW50RWxlbWVudC5zaGFkb3dSb290ICYmXG4gICAgICAgICAgZ2V0U2hhZG93Um9vdChwYXJlbnRFbGVtZW50KSA9PT0gdHJ1ZSAvLyBjaGVjayBpZiB0aGVyZSdzIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICApIHtcbiAgICAgICAgICAvLyBub2RlIGhhcyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgd2hpY2ggbWVhbnMgd2UgY2FuIG9ubHkgdHJlYXQgaXQgYXMgYSBibGFjayBib3gsIHNvIHdlXG4gICAgICAgICAgLy8gIGZhbGwgYmFjayB0byBhIG5vbi16ZXJvLWFyZWEgdGVzdFxuICAgICAgICAgIHJldHVybiBpc1plcm9BcmVhKG5vZGUpO1xuICAgICAgICB9IGVsc2UgaWYgKG5vZGUuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBzbG90XG4gICAgICAgICAgbm9kZSA9IG5vZGUuYXNzaWduZWRTbG90O1xuICAgICAgICB9IGVsc2UgaWYgKCFwYXJlbnRFbGVtZW50ICYmIHJvb3ROb2RlICE9PSBub2RlLm93bmVyRG9jdW1lbnQpIHtcbiAgICAgICAgICAvLyBjcm9zcyBzaGFkb3cgYm91bmRhcnlcbiAgICAgICAgICBub2RlID0gcm9vdE5vZGUuaG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIG5vcm1hbCBkb21cbiAgICAgICAgICBub2RlID0gcGFyZW50RWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAobm9kZUlzQXR0YWNoZWQpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVja2AgbW9kZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG5jb25zdCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKC9eKElOUFVUfEJVVFRPTnxTRUxFQ1R8VEVYVEFSRUEpJC8udGVzdChub2RlLnRhZ05hbWUpKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgLy8gY2hlY2sgaWYgYG5vZGVgIGlzIGNvbnRhaW5lZCBpbiBhIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICB3aGlsZSAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKHBhcmVudE5vZGUudGFnTmFtZSA9PT0gJ0ZJRUxEU0VUJyAmJiBwYXJlbnROb2RlLmRpc2FibGVkKSB7XG4gICAgICAgIC8vIGxvb2sgZm9yIHRoZSBmaXJzdCA8bGVnZW5kPiBhbW9uZyB0aGUgY2hpbGRyZW4gb2YgdGhlIGRpc2FibGVkIDxmaWVsZHNldD5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJlbnROb2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJylcbiAgICAgICAgICAgICAgPyB0cnVlXG4gICAgICAgICAgICAgIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBub2RlLmRpc2FibGVkIHx8XG4gICAgaXNIaWRkZW5JbnB1dChub2RlKSB8fFxuICAgIGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gICAgLy8gRm9yIGEgZGV0YWlscyBlbGVtZW50IHdpdGggYSBzdW1tYXJ5LCB0aGUgc3VtbWFyeSBlbGVtZW50IGdldHMgdGhlIGZvY3VzXG4gICAgaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkgfHxcbiAgICBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZSA9IGZ1bmN0aW9uIChvcHRpb25zLCBub2RlKSB7XG4gIGlmIChcbiAgICBpc05vblRhYmJhYmxlUmFkaW8obm9kZSkgfHxcbiAgICBnZXRUYWJpbmRleChub2RlKSA8IDAgfHxcbiAgICAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlID0gZnVuY3Rpb24gKHNoYWRvd0hvc3ROb2RlKSB7XG4gIGNvbnN0IHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlc1Njb3BlPn0gY2FuZGlkYXRlc1xuICogQHJldHVybnMgRWxlbWVudFtdXG4gKi9cbmNvbnN0IHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gKGNhbmRpZGF0ZXMpIHtcbiAgY29uc3QgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICBjb25zdCBvcmRlcmVkVGFiYmFibGVzID0gW107XG4gIGNhbmRpZGF0ZXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkge1xuICAgIGNvbnN0IGlzU2NvcGUgPSAhIWl0ZW0uc2NvcGU7XG4gICAgY29uc3QgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlIDogaXRlbTtcbiAgICBjb25zdCBjYW5kaWRhdGVUYWJpbmRleCA9IGdldFRhYmluZGV4KGVsZW1lbnQsIGlzU2NvcGUpO1xuICAgIGNvbnN0IGVsZW1lbnRzID0gaXNTY29wZSA/IHNvcnRCeU9yZGVyKGl0ZW0uY2FuZGlkYXRlcykgOiBlbGVtZW50O1xuICAgIGlmIChjYW5kaWRhdGVUYWJpbmRleCA9PT0gMCkge1xuICAgICAgaXNTY29wZVxuICAgICAgICA/IHJlZ3VsYXJUYWJiYWJsZXMucHVzaCguLi5lbGVtZW50cylcbiAgICAgICAgOiByZWd1bGFyVGFiYmFibGVzLnB1c2goZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9yZGVyZWRUYWJiYWJsZXMucHVzaCh7XG4gICAgICAgIGRvY3VtZW50T3JkZXI6IGksXG4gICAgICAgIHRhYkluZGV4OiBjYW5kaWRhdGVUYWJpbmRleCxcbiAgICAgICAgaXRlbTogaXRlbSxcbiAgICAgICAgaXNTY29wZTogaXNTY29wZSxcbiAgICAgICAgY29udGVudDogZWxlbWVudHMsXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvcmRlcmVkVGFiYmFibGVzXG4gICAgLnNvcnQoc29ydE9yZGVyZWRUYWJiYWJsZXMpXG4gICAgLnJlZHVjZSgoYWNjLCBzb3J0YWJsZSkgPT4ge1xuICAgICAgc29ydGFibGUuaXNTY29wZVxuICAgICAgICA/IGFjYy5wdXNoKC4uLnNvcnRhYmxlLmNvbnRlbnQpXG4gICAgICAgIDogYWNjLnB1c2goc29ydGFibGUuY29udGVudCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKVxuICAgIC5jb25jYXQocmVndWxhclRhYmJhYmxlcyk7XG59O1xuXG5jb25zdCB0YWJiYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogZmFsc2UsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgICBzaGFkb3dSb290RmlsdGVyOiBpc1ZhbGlkU2hhZG93Um9vdFRhYmJhYmxlLFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKFxuICAgICAgZWwsXG4gICAgICBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsXG4gICAgICBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHNvcnRCeU9yZGVyKGNhbmRpZGF0ZXMpO1xufTtcblxuY29uc3QgZm9jdXNhYmxlID0gZnVuY3Rpb24gKGVsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIGxldCBjYW5kaWRhdGVzO1xuICBpZiAob3B0aW9ucy5nZXRTaGFkb3dSb290KSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShbZWxdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuY29uc3QgaXNUYWJiYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yID0gLyogI19fUFVSRV9fICovIGNhbmRpZGF0ZVNlbGVjdG9yc1xuICAuY29uY2F0KCdpZnJhbWUnKVxuICAuam9pbignLCcpO1xuXG5jb25zdCBpc0ZvY3VzYWJsZSA9IGZ1bmN0aW9uIChub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyB0YWJiYWJsZSwgZm9jdXNhYmxlLCBpc1RhYmJhYmxlLCBpc0ZvY3VzYWJsZSB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKCdpbmVydCcsIGZhY3RvcnkpIDpcbiAgKGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG4gIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd29yayBpcyBsaWNlbnNlZCB1bmRlciB0aGUgVzNDIFNvZnR3YXJlIGFuZCBEb2N1bWVudCBMaWNlbnNlXG4gICAqIChodHRwOi8vd3d3LnczLm9yZy9Db25zb3J0aXVtL0xlZ2FsLzIwMTUvY29weXJpZ2h0LXNvZnR3YXJlLWFuZC1kb2N1bWVudCkuXG4gICAqL1xuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gUmV0dXJuIGVhcmx5IGlmIHdlJ3JlIG5vdCBydW5uaW5nIGluc2lkZSBvZiB0aGUgYnJvd3Nlci5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBmdW5jdGlvbiBmb3IgY29udmVydGluZyBOb2RlTGlzdHMuXG4gICAgLyoqIEB0eXBlIHt0eXBlb2YgQXJyYXkucHJvdG90eXBlLnNsaWNlfSAqL1xuICAgIHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuICAgIC8qKlxuICAgICAqIElFIGhhcyBhIG5vbi1zdGFuZGFyZCBuYW1lIGZvciBcIm1hdGNoZXNcIi5cbiAgICAgKiBAdHlwZSB7dHlwZW9mIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXN9XG4gICAgICovXG4gICAgdmFyIG1hdGNoZXMgPSBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yO1xuXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdmFyIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZyA9IFsnYVtocmVmXScsICdhcmVhW2hyZWZdJywgJ2lucHV0Om5vdChbZGlzYWJsZWRdKScsICdzZWxlY3Q6bm90KFtkaXNhYmxlZF0pJywgJ3RleHRhcmVhOm5vdChbZGlzYWJsZWRdKScsICdidXR0b246bm90KFtkaXNhYmxlZF0pJywgJ2RldGFpbHMnLCAnc3VtbWFyeScsICdpZnJhbWUnLCAnb2JqZWN0JywgJ2VtYmVkJywgJ1tjb250ZW50ZWRpdGFibGVdJ10uam9pbignLCcpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Um9vdGAgbWFuYWdlcyBhIHNpbmdsZSBpbmVydCBzdWJ0cmVlLCBpLmUuIGEgRE9NIHN1YnRyZWUgd2hvc2Ugcm9vdCBlbGVtZW50IGhhcyBhbiBgaW5lcnRgXG4gICAgICogYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogSXRzIG1haW4gZnVuY3Rpb25zIGFyZTpcbiAgICAgKlxuICAgICAqIC0gdG8gY3JlYXRlIGFuZCBtYWludGFpbiBhIHNldCBvZiBtYW5hZ2VkIGBJbmVydE5vZGVgcywgaW5jbHVkaW5nIHdoZW4gbXV0YXRpb25zIG9jY3VyIGluIHRoZVxuICAgICAqICAgc3VidHJlZS4gVGhlIGBtYWtlU3VidHJlZVVuZm9jdXNhYmxlKClgIG1ldGhvZCBoYW5kbGVzIGNvbGxlY3RpbmcgYEluZXJ0Tm9kZWBzIHZpYSByZWdpc3RlcmluZ1xuICAgICAqICAgZWFjaCBmb2N1c2FibGUgbm9kZSBpbiB0aGUgc3VidHJlZSB3aXRoIHRoZSBzaW5nbGV0b24gYEluZXJ0TWFuYWdlcmAgd2hpY2ggbWFuYWdlcyBhbGwga25vd25cbiAgICAgKiAgIGZvY3VzYWJsZSBub2RlcyB3aXRoaW4gaW5lcnQgc3VidHJlZXMuIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYFxuICAgICAqICAgaW5zdGFuY2UgZXhpc3RzIGZvciBlYWNoIGZvY3VzYWJsZSBub2RlIHdoaWNoIGhhcyBhdCBsZWFzdCBvbmUgaW5lcnQgcm9vdCBhcyBhbiBhbmNlc3Rvci5cbiAgICAgKlxuICAgICAqIC0gdG8gbm90aWZ5IGFsbCBtYW5hZ2VkIGBJbmVydE5vZGVgcyB3aGVuIHRoaXMgc3VidHJlZSBzdG9wcyBiZWluZyBpbmVydCAoaS5lLiB3aGVuIHRoZSBgaW5lcnRgXG4gICAgICogICBhdHRyaWJ1dGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSByb290IG5vZGUpLiBUaGlzIGlzIGhhbmRsZWQgaW4gdGhlIGRlc3RydWN0b3IsIHdoaWNoIGNhbGxzIHRoZVxuICAgICAqICAgYGRlcmVnaXN0ZXJgIG1ldGhvZCBvbiBgSW5lcnRNYW5hZ2VyYCBmb3IgZWFjaCBtYW5hZ2VkIGluZXJ0IG5vZGUuXG4gICAgICovXG5cbiAgICB2YXIgSW5lcnRSb290ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdEVsZW1lbnQgVGhlIEhUTUxFbGVtZW50IGF0IHRoZSByb290IG9mIHRoZSBpbmVydCBzdWJ0cmVlLlxuICAgICAgICogQHBhcmFtIHshSW5lcnRNYW5hZ2VyfSBpbmVydE1hbmFnZXIgVGhlIGdsb2JhbCBzaW5nbGV0b24gSW5lcnRNYW5hZ2VyIG9iamVjdC5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnRSb290KHJvb3RFbGVtZW50LCBpbmVydE1hbmFnZXIpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Um9vdCk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSBpbmVydE1hbmFnZXI7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydE5vZGU+fVxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBmb2N1c2FibGUgbm9kZXMgaW4gdGhpcyBJbmVydFJvb3QncyBzdWJ0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzID0gbmV3IFNldCgpO1xuXG4gICAgICAgIC8vIE1ha2UgdGhlIHN1YnRyZWUgaGlkZGVuIGZyb20gYXNzaXN0aXZlIHRlY2hub2xvZ3lcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50Lmhhc0F0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKSkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSB0aGlzLl9yb290RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgICAvLyBNYWtlIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgaW4gdGhlIHN1YnRyZWUgdW5mb2N1c2FibGUgYW5kIGFkZCB0aGVtIHRvIF9tYW5hZ2VkTm9kZXNcbiAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSh0aGlzLl9yb290RWxlbWVudCk7XG5cbiAgICAgICAgLy8gV2F0Y2ggZm9yOlxuICAgICAgICAvLyAtIGFueSBhZGRpdGlvbnMgaW4gdGhlIHN1YnRyZWU6IG1ha2UgdGhlbSB1bmZvY3VzYWJsZSB0b29cbiAgICAgICAgLy8gLSBhbnkgcmVtb3ZhbHMgZnJvbSB0aGUgc3VidHJlZTogcmVtb3ZlIHRoZW0gZnJvbSB0aGlzIGluZXJ0IHJvb3QncyBtYW5hZ2VkIG5vZGVzXG4gICAgICAgIC8vIC0gYXR0cmlidXRlIGNoYW5nZXM6IGlmIGB0YWJpbmRleGAgaXMgYWRkZWQsIG9yIHJlbW92ZWQgZnJvbSBhbiBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZVxuICAgICAgICAvLyAgIGVsZW1lbnQsIG1ha2UgdGhhdCBub2RlIGEgbWFuYWdlZCBub2RlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX29uTXV0YXRpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fcm9vdEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH0pO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuICBUaGlzIHVud2luZHMgYWxsIG9mIHRoZSBzdGF0ZVxuICAgICAgICogc3RvcmVkIGluIHRoaXMgb2JqZWN0IGFuZCB1cGRhdGVzIHRoZSBzdGF0ZSBvZiBhbGwgb2YgdGhlIG1hbmFnZWQgbm9kZXMuXG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRSb290LCBbe1xuICAgICAgICBrZXk6ICdkZXN0cnVjdG9yJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3RydWN0b3IoKSB7XG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuX3Jvb3RFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0aGlzLl9zYXZlZEFyaWFIaWRkZW4pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubWFuYWdlTm9kZShpbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAvLyBOb3RlIHdlIGNhc3QgdGhlIG51bGxzIHRvIHRoZSBBTlkgdHlwZSBoZXJlIGJlY2F1c2U6XG4gICAgICAgICAgLy8gMSkgV2Ugd2FudCB0aGUgY2xhc3MgcHJvcGVydGllcyB0byBiZSBkZWNsYXJlZCBhcyBub24tbnVsbCwgb3IgZWxzZSB3ZVxuICAgICAgICAgIC8vICAgIG5lZWQgZXZlbiBtb3JlIGNhc3RzIHRocm91Z2hvdXQgdGhpcyBjb2RlLiBBbGwgYmV0cyBhcmUgb2ZmIGlmIGFuXG4gICAgICAgICAgLy8gICAgaW5zdGFuY2UgaGFzIGJlZW4gZGVzdHJveWVkIGFuZCBhIG1ldGhvZCBpcyBjYWxsZWQuXG4gICAgICAgICAgLy8gMikgV2UgZG9uJ3Qgd2FudCB0byBjYXN0IFwidGhpc1wiLCBiZWNhdXNlIHdlIHdhbnQgdHlwZS1hd2FyZSBvcHRpbWl6YXRpb25zXG4gICAgICAgICAgLy8gICAgdG8ga25vdyB3aGljaCBwcm9wZXJ0aWVzIHdlJ3JlIHNldHRpbmcuXG4gICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlciA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm4geyFTZXQ8IUluZXJ0Tm9kZT59IEEgY29weSBvZiB0aGlzIEluZXJ0Um9vdCdzIG1hbmFnZWQgbm9kZXMgc2V0LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfbWFrZVN1YnRyZWVVbmZvY3VzYWJsZScsXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX3Zpc2l0Tm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcblxuICAgICAgICAgIGlmICghZG9jdW1lbnQuYm9keS5jb250YWlucyhzdGFydE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBzdGFydE5vZGUgbWF5IGJlIGluIHNoYWRvdyBET00sIHNvIGZpbmQgaXRzIG5lYXJlc3Qgc2hhZG93Um9vdCB0byBnZXQgdGhlIGFjdGl2ZUVsZW1lbnQuXG4gICAgICAgICAgICB2YXIgbm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgICAgIC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R8dW5kZWZpbmVkfSAqL1xuICAgICAgICAgICAgdmFyIHJvb3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgcm9vdCA9IC8qKiBAdHlwZSB7IVNoYWRvd1Jvb3R9ICovbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgICAgICAgYWN0aXZlRWxlbWVudCA9IHJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXJ0Tm9kZS5jb250YWlucyhhY3RpdmVFbGVtZW50KSkge1xuICAgICAgICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgICAgICAgICAvLyBJbiBJRTExLCBpZiBhbiBlbGVtZW50IGlzIGFscmVhZHkgZm9jdXNlZCwgYW5kIHRoZW4gc2V0IHRvIHRhYmluZGV4PS0xXG4gICAgICAgICAgICAvLyBjYWxsaW5nIGJsdXIoKSB3aWxsIG5vdCBhY3R1YWxseSBtb3ZlIHRoZSBmb2N1cy5cbiAgICAgICAgICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMgd2UgY2FsbCBmb2N1cygpIG9uIHRoZSBib2R5IGluc3RlYWQuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Zpc2l0Tm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdmlzaXROb2RlKG5vZGUpIHtcbiAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuXG4gICAgICAgICAgLy8gSWYgYSBkZXNjZW5kYW50IGluZXJ0IHJvb3QgYmVjb21lcyB1bi1pbmVydCwgaXRzIGRlc2NlbmRhbnRzIHdpbGwgc3RpbGwgYmUgaW5lcnQgYmVjYXVzZSBvZlxuICAgICAgICAgIC8vIHRoaXMgaW5lcnQgcm9vdCwgc28gYWxsIG9mIGl0cyBtYW5hZ2VkIG5vZGVzIG5lZWQgdG8gYmUgYWRvcHRlZCBieSB0aGlzIEluZXJ0Um9vdC5cbiAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KGVsZW1lbnQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSB8fCBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX21hbmFnZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9pbmVydE1hbmFnZXIucmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmFkZChpbmVydE5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVucmVnaXN0ZXIgdGhlIGdpdmVuIG5vZGUgd2l0aCB0aGlzIEluZXJ0Um9vdCBhbmQgd2l0aCBJbmVydE1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3VubWFuYWdlTm9kZScsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdW5tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIobm9kZSwgdGhpcyk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShpbmVydE5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBlbnRpcmUgc3VidHJlZSBzdGFydGluZyBhdCBgc3RhcnROb2RlYC5cbiAgICAgICAgICogQHBhcmFtIHshTm9kZX0gc3RhcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZVN1YnRyZWUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlU3VidHJlZShzdGFydE5vZGUpIHtcbiAgICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc3RhcnROb2RlLCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMy5fdW5tYW5hZ2VOb2RlKG5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGEgZGVzY2VuZGFudCBub2RlIGlzIGZvdW5kIHdpdGggYW4gYGluZXJ0YCBhdHRyaWJ1dGUsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gbm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfYWRvcHRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX2Fkb3B0SW5lcnRSb290KG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnRTdWJyb290ID0gdGhpcy5faW5lcnRNYW5hZ2VyLmdldEluZXJ0Um9vdChub2RlKTtcblxuICAgICAgICAgIC8vIER1cmluZyBpbml0aWFsaXNhdGlvbiB0aGlzIGluZXJ0IHJvb3QgbWF5IG5vdCBoYXZlIGJlZW4gcmVnaXN0ZXJlZCB5ZXQsXG4gICAgICAgICAgLy8gc28gcmVnaXN0ZXIgaXQgbm93IGlmIG5lZWQgYmUuXG4gICAgICAgICAgaWYgKCFpbmVydFN1YnJvb3QpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0TWFuYWdlci5zZXRJbmVydChub2RlLCB0cnVlKTtcbiAgICAgICAgICAgIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5lcnRTdWJyb290Lm1hbmFnZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChzYXZlZEluZXJ0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZShzYXZlZEluZXJ0Tm9kZS5ub2RlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBzdWJ0cmVlIGFkZGl0aW9ucywgcmVtb3ZhbHMsIG9yIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uTXV0YXRpb24nLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uTXV0YXRpb24ocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovcmVjb3JkLnRhcmdldDtcbiAgICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gJ2NoaWxkTGlzdCcpIHtcbiAgICAgICAgICAgICAgLy8gTWFuYWdlIGFkZGVkIG5vZGVzXG4gICAgICAgICAgICAgIHNsaWNlLmNhbGwocmVjb3JkLmFkZGVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgICAvLyBVbi1tYW5hZ2UgcmVtb3ZlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5yZW1vdmVkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91bm1hbmFnZVN1YnRyZWUobm9kZSk7XG4gICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gJ2F0dHJpYnV0ZXMnKSB7XG4gICAgICAgICAgICAgIGlmIChyZWNvcmQuYXR0cmlidXRlTmFtZSA9PT0gJ3RhYmluZGV4Jykge1xuICAgICAgICAgICAgICAgIC8vIFJlLWluaXRpYWxpc2UgaW5lcnQgbm9kZSBpZiB0YWJpbmRleCBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlTm9kZSh0YXJnZXQpO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAhPT0gdGhpcy5fcm9vdEVsZW1lbnQgJiYgcmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICdpbmVydCcgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGEgbmV3IGluZXJ0IHJvb3QgaXMgYWRkZWQsIGFkb3B0IGl0cyBtYW5hZ2VkIG5vZGVzIGFuZCBtYWtlIHN1cmUgaXQga25vd3MgYWJvdXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBtYW5hZ2VkIG5vZGVzIGZyb20gdGhpcyBpbmVydCBzdWJyb290LlxuICAgICAgICAgICAgICAgIHRoaXMuX2Fkb3B0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3QodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobWFuYWdlZE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuY29udGFpbnMobWFuYWdlZE5vZGUubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRTdWJyb290Ll9tYW5hZ2VOb2RlKG1hbmFnZWROb2RlLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnbWFuYWdlZE5vZGVzJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5fbWFuYWdlZE5vZGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gIT09IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/c3RyaW5nfSBhcmlhSGlkZGVuICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnc2F2ZWRBcmlhSGlkZGVuJyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoYXJpYUhpZGRlbikge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IGFyaWFIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P3N0cmluZ30gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuO1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydFJvb3Q7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogYEluZXJ0Tm9kZWAgaW5pdGlhbGlzZXMgYW5kIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgbm9kZS5cbiAgICAgKiBBIG5vZGUgaXMgaW5lcnQgaWYgaXQgaXMgYSBkZXNjZW5kYW50IG9mIG9uZSBvciBtb3JlIGluZXJ0IHJvb3QgZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBPbiBjb25zdHJ1Y3Rpb24sIGBJbmVydE5vZGVgIHNhdmVzIHRoZSBleGlzdGluZyBgdGFiaW5kZXhgIHZhbHVlIGZvciB0aGUgbm9kZSwgaWYgYW55LCBhbmRcbiAgICAgKiBlaXRoZXIgcmVtb3ZlcyB0aGUgYHRhYmluZGV4YCBhdHRyaWJ1dGUgb3Igc2V0cyBpdCB0byBgLTFgLCBkZXBlbmRpbmcgb24gd2hldGhlciB0aGUgZWxlbWVudFxuICAgICAqIGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlIG9yIG5vdC5cbiAgICAgKlxuICAgICAqIGBJbmVydE5vZGVgIG1haW50YWlucyBhIHNldCBvZiBgSW5lcnRSb290YHMgd2hpY2ggYXJlIGRlc2NlbmRhbnRzIG9mIHRoaXMgYEluZXJ0Tm9kZWAuIFdoZW4gYW5cbiAgICAgKiBgSW5lcnRSb290YCBpcyBkZXN0cm95ZWQsIGFuZCBjYWxscyBgSW5lcnRNYW5hZ2VyLmRlcmVnaXN0ZXIoKWAsIHRoZSBgSW5lcnRNYW5hZ2VyYCBub3RpZmllcyB0aGVcbiAgICAgKiBgSW5lcnROb2RlYCB2aWEgYHJlbW92ZUluZXJ0Um9vdCgpYCwgd2hpY2ggaW4gdHVybiBkZXN0cm95cyB0aGUgYEluZXJ0Tm9kZWAgaWYgbm8gYEluZXJ0Um9vdGBzXG4gICAgICogcmVtYWluIGluIHRoZSBzZXQuIE9uIGRlc3RydWN0aW9uLCBgSW5lcnROb2RlYCByZWluc3RhdGVzIHRoZSBzdG9yZWQgYHRhYmluZGV4YCBpZiBvbmUgZXhpc3RzLFxuICAgICAqIG9yIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIGlmIHRoZSBlbGVtZW50IGlzIGludHJpbnNpY2FsbHkgZm9jdXNhYmxlLlxuICAgICAqL1xuXG5cbiAgICB2YXIgSW5lcnROb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIEEgZm9jdXNhYmxlIGVsZW1lbnQgdG8gYmUgbWFkZSBpbmVydC5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290IFRoZSBpbmVydCByb290IGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgaW5lcnQgbm9kZS5cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnROb2RlKTtcblxuICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICB0aGlzLl9ub2RlID0gbm9kZTtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUgeyFTZXQ8IUluZXJ0Um9vdD59IFRoZSBzZXQgb2YgZGVzY2VuZGFudCBpbmVydCByb290cy5cbiAgICAgICAgICogICAgSWYgYW5kIG9ubHkgaWYgdGhpcyBzZXQgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgU2V0KFtpbmVydFJvb3RdKTtcblxuICAgICAgICAvKiogQHR5cGUgez9udW1iZXJ9ICovXG4gICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSBudWxsO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU2F2ZSBhbnkgcHJpb3IgdGFiaW5kZXggaW5mbyBhbmQgbWFrZSB0aGlzIG5vZGUgdW50YWJiYWJsZVxuICAgICAgICB0aGlzLmVuc3VyZVVudGFiYmFibGUoKTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLlxuICAgICAgICogVGhpcyBtYWtlcyB0aGUgbWFuYWdlZCBub2RlIGZvY3VzYWJsZSBhZ2FpbiBhbmQgZGVsZXRlcyBhbGwgb2YgdGhlIHByZXZpb3VzbHkgc3RvcmVkIHN0YXRlLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Tm9kZSwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9ub2RlICYmIHRoaXMuX25vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMuX25vZGU7XG4gICAgICAgICAgICBpZiAodGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCB0aGlzLl9zYXZlZFRhYkluZGV4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBVc2UgYGRlbGV0ZWAgdG8gcmVzdG9yZSBuYXRpdmUgZm9jdXMgbWV0aG9kLlxuICAgICAgICAgICAgaWYgKHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnQuZm9jdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gU2VlIG5vdGUgaW4gSW5lcnRSb290LmRlc3RydWN0b3IgZm9yIHdoeSB3ZSBjYXN0IHRoZXNlIG51bGxzIHRvIEFOWS5cbiAgICAgICAgICB0aGlzLl9ub2RlID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cyA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhpcyBvYmplY3QgaXMgb2Jzb2xldGUgYmVjYXVzZSB0aGUgbWFuYWdlZCBub2RlIGlzIG5vIGxvbmdlciBpbmVydC5cbiAgICAgICAgICogSWYgdGhlIG9iamVjdCBoYXMgYmVlbiBkZXN0cm95ZWQsIGFueSBhdHRlbXB0IHRvIGFjY2VzcyBpdCB3aWxsIGNhdXNlIGFuIGV4Y2VwdGlvbi5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3Rocm93SWZEZXN0cm95ZWQnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRocm93IGlmIHVzZXIgdHJpZXMgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Rocm93SWZEZXN0cm95ZWQoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgZGVzdHJveWVkIEluZXJ0Tm9kZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHtib29sZWFufSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Vuc3VyZVVudGFiYmFibGUnLFxuXG5cbiAgICAgICAgLyoqIFNhdmUgdGhlIGV4aXN0aW5nIHRhYmluZGV4IHZhbHVlIGFuZCBtYWtlIHRoZSBub2RlIHVudGFiYmFibGUgYW5kIHVuZm9jdXNhYmxlICovXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbnN1cmVVbnRhYmJhYmxlKCkge1xuICAgICAgICAgIGlmICh0aGlzLm5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovdGhpcy5ub2RlO1xuICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgX2ZvY3VzYWJsZUVsZW1lbnRzU3RyaW5nKSkge1xuICAgICAgICAgICAgaWYgKCAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4ID09PSAtMSAmJiB0aGlzLmhhc1NhdmVkVGFiSW5kZXgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQudGFiSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICAgIHRoaXMuX292ZXJyb2RlRm9jdXNNZXRob2QgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZCBhbm90aGVyIGluZXJ0IHJvb3QgdG8gdGhpcyBpbmVydCBub2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdhZGRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzLmFkZChpbmVydFJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBmcm9tIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogSWYgdGhlIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cyBiZWNvbWVzIGVtcHR5LCB0aGlzIG5vZGUgaXMgbm8gbG9uZ2VyIGluZXJ0LFxuICAgICAgICAgKiBzbyB0aGUgb2JqZWN0IHNob3VsZCBiZSBkZXN0cm95ZWQuXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlbW92ZUluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHNbJ2RlbGV0ZSddKGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2Rlc3Ryb3llZCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiAoLyoqIEB0eXBlIHshSW5lcnROb2RlfSAqL3RoaXMuX2Rlc3Ryb3llZFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnaGFzU2F2ZWRUYWJJbmRleCcsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4ICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4geyFOb2RlfSAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ25vZGUnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHBhcmFtIHs/bnVtYmVyfSB0YWJJbmRleCAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YWJJbmRleCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gdGFiSW5kZXg7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7P251bWJlcn0gKi9cbiAgICAgICAgLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkVGFiSW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0Tm9kZTtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBJbmVydE1hbmFnZXIgaXMgYSBwZXItZG9jdW1lbnQgc2luZ2xldG9uIG9iamVjdCB3aGljaCBtYW5hZ2VzIGFsbCBpbmVydCByb290cyBhbmQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGFuIGVsZW1lbnQgYmVjb21lcyBhbiBpbmVydCByb290IGJ5IGhhdmluZyBhbiBgaW5lcnRgIGF0dHJpYnV0ZSBzZXQgYW5kL29yIGl0cyBgaW5lcnRgXG4gICAgICogcHJvcGVydHkgc2V0IHRvIGB0cnVlYCwgdGhlIGBzZXRJbmVydGAgbWV0aG9kIGNyZWF0ZXMgYW4gYEluZXJ0Um9vdGAgb2JqZWN0IGZvciB0aGUgZWxlbWVudC5cbiAgICAgKiBUaGUgYEluZXJ0Um9vdGAgaW4gdHVybiByZWdpc3RlcnMgaXRzZWxmIGFzIG1hbmFnaW5nIGFsbCBvZiB0aGUgZWxlbWVudCdzIGZvY3VzYWJsZSBkZXNjZW5kYW50XG4gICAgICogbm9kZXMgdmlhIHRoZSBgcmVnaXN0ZXIoKWAgbWV0aG9kLiBUaGUgYEluZXJ0TWFuYWdlcmAgZW5zdXJlcyB0aGF0IGEgc2luZ2xlIGBJbmVydE5vZGVgIGluc3RhbmNlXG4gICAgICogaXMgY3JlYXRlZCBmb3IgZWFjaCBzdWNoIG5vZGUsIHZpYSB0aGUgYF9tYW5hZ2VkTm9kZXNgIG1hcC5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0TWFuYWdlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshRG9jdW1lbnR9IGRvY3VtZW50XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0TWFuYWdlcihkb2N1bWVudCkge1xuICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5lcnRNYW5hZ2VyKTtcblxuICAgICAgICBpZiAoIWRvY3VtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIHJlcXVpcmVkIGFyZ3VtZW50OyBJbmVydE1hbmFnZXIgbmVlZHMgdG8gd3JhcCBhIGRvY3VtZW50LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG4gICAgICAgIHRoaXMuX2RvY3VtZW50ID0gZG9jdW1lbnQ7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBtYW5hZ2VkIG5vZGVzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnROb2RlPn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBNYXAoKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWxsIGluZXJ0IHJvb3RzIGtub3duIHRvIHRoaXMgSW5lcnRNYW5hZ2VyLiBJbiBhIG1hcCB0byBhbGxvdyBsb29raW5nIHVwIGJ5IE5vZGUuXG4gICAgICAgICAqIEB0eXBlIHshTWFwPCFOb2RlLCAhSW5lcnRSb290Pn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9ic2VydmVyIGZvciBtdXRhdGlvbnMgb24gYGRvY3VtZW50LmJvZHlgLlxuICAgICAgICAgKiBAdHlwZSB7IU11dGF0aW9uT2JzZXJ2ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuX3dhdGNoRm9ySW5lcnQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkIGluZXJ0IHN0eWxlLlxuICAgICAgICBhZGRJbmVydFN0eWxlKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhaXQgZm9yIGRvY3VtZW50IHRvIGJlIGxvYWRlZC5cbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCB0aGlzLl9vbkRvY3VtZW50TG9hZGVkLmJpbmQodGhpcykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX29uRG9jdW1lbnRMb2FkZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiBlbGVtZW50IHNob3VsZCBiZSBhbiBpbmVydCByb290IG9yIG5vdC5cbiAgICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSByb290XG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluZXJ0XG4gICAgICAgKi9cblxuXG4gICAgICBfY3JlYXRlQ2xhc3MoSW5lcnRNYW5hZ2VyLCBbe1xuICAgICAgICBrZXk6ICdzZXRJbmVydCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRJbmVydChyb290LCBpbmVydCkge1xuICAgICAgICAgIGlmIChpbmVydCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBpbmVydFxuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBpbmVydFJvb3QgPSBuZXcgSW5lcnRSb290KHJvb3QsIHRoaXMpO1xuICAgICAgICAgICAgcm9vdC5zZXRBdHRyaWJ1dGUoJ2luZXJ0JywgJycpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290cy5zZXQocm9vdCwgaW5lcnRSb290KTtcbiAgICAgICAgICAgIC8vIElmIG5vdCBjb250YWluZWQgaW4gdGhlIGRvY3VtZW50LCBpdCBtdXN0IGJlIGluIGEgc2hhZG93Um9vdC5cbiAgICAgICAgICAgIC8vIEVuc3VyZSBpbmVydCBzdHlsZXMgYXJlIGFkZGVkIHRoZXJlLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9kb2N1bWVudC5ib2R5LmNvbnRhaW5zKHJvb3QpKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSByb290LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50Lm5vZGVUeXBlID09PSAxMSkge1xuICAgICAgICAgICAgICAgICAgYWRkSW5lcnRTdHlsZShwYXJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luZXJ0Um9vdHMuaGFzKHJvb3QpKSB7XG4gICAgICAgICAgICAgIC8vIGVsZW1lbnQgaXMgYWxyZWFkeSBub24taW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2luZXJ0Um9vdCA9IHRoaXMuX2luZXJ0Um9vdHMuZ2V0KHJvb3QpO1xuICAgICAgICAgICAgX2luZXJ0Um9vdC5kZXN0cnVjdG9yKCk7XG4gICAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShyb290KTtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgdGhlIEluZXJ0Um9vdCBvYmplY3QgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gaW5lcnQgcm9vdCBlbGVtZW50LCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IGVsZW1lbnRcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Um9vdHx1bmRlZmluZWR9XG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2dldEluZXJ0Um9vdCcsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmVydFJvb3QoZWxlbWVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbmVydFJvb3RzLmdldChlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBub2RlLlxuICAgICAgICAgKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgbm9kZSBoYXMgYSBwcmV2aW91c2x5IGV4aXN0aW5nIGluZXJ0IHJvb3QsIHRoaXMgaW5lcnQgcm9vdCB3aWxsXG4gICAgICAgICAqIGJlIGFkZGVkIHRvIGl0cyBzZXQgb2YgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7IUluZXJ0Tm9kZX0gaW5lcnROb2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3JlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gbm9kZSB3YXMgYWxyZWFkeSBpbiBhbiBpbmVydCBzdWJ0cmVlXG4gICAgICAgICAgICBpbmVydE5vZGUuYWRkSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZXJ0Tm9kZSA9IG5ldyBJbmVydE5vZGUobm9kZSwgaW5lcnRSb290KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuc2V0KG5vZGUsIGluZXJ0Tm9kZSk7XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlLXJlZ2lzdGVyIHRoZSBnaXZlbiBJbmVydFJvb3QgYXMgbWFuYWdpbmcgdGhlIGdpdmVuIGluZXJ0IG5vZGUuXG4gICAgICAgICAqIFJlbW92ZXMgdGhlIGluZXJ0IHJvb3QgZnJvbSB0aGUgSW5lcnROb2RlJ3Mgc2V0IG9mIG1hbmFnaW5nIGluZXJ0IHJvb3RzLCBhbmQgcmVtb3ZlIHRoZSBpbmVydFxuICAgICAgICAgKiBub2RlIGZyb20gdGhlIEluZXJ0TWFuYWdlcidzIHNldCBvZiBtYW5hZ2VkIG5vZGVzIGlmIGl0IGlzIGRlc3Ryb3llZC5cbiAgICAgICAgICogSWYgdGhlIG5vZGUgaXMgbm90IGN1cnJlbnRseSBtYW5hZ2VkLCB0aGlzIGlzIGVzc2VudGlhbGx5IGEgbm8tb3AuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICogQHJldHVybiB7P0luZXJ0Tm9kZX0gVGhlIHBvdGVudGlhbGx5IGRlc3Ryb3llZCBJbmVydE5vZGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgaWYgYW55LlxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXJlZ2lzdGVyJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIobm9kZSwgaW5lcnRSb290KSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX21hbmFnZWROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgICAgaWYgKCFpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0Tm9kZS5yZW1vdmVJbmVydFJvb3QoaW5lcnRSb290KTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzWydkZWxldGUnXShub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gaW5lcnROb2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBkb2N1bWVudCBoYXMgZmluaXNoZWQgbG9hZGluZy5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX29uRG9jdW1lbnRMb2FkZWQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX29uRG9jdW1lbnRMb2FkZWQoKSB7XG4gICAgICAgICAgLy8gRmluZCBhbGwgaW5lcnQgcm9vdHMgaW4gZG9jdW1lbnQgYW5kIG1ha2UgdGhlbSBhY3R1YWxseSBpbmVydC5cbiAgICAgICAgICB2YXIgaW5lcnRFbGVtZW50cyA9IHNsaWNlLmNhbGwodGhpcy5fZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gQ29tbWVudCB0aGlzIG91dCB0byB1c2UgcHJvZ3JhbW1hdGljIEFQSSBvbmx5LlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUodGhpcy5fZG9jdW1lbnQuYm9keSB8fCB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHsgYXR0cmlidXRlczogdHJ1ZSwgc3VidHJlZTogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIHVzZWQgd2hlbiBtdXRhdGlvbiBvYnNlcnZlciBkZXRlY3RzIGF0dHJpYnV0ZSBjaGFuZ2VzLlxuICAgICAgICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSByZWNvcmRzXG4gICAgICAgICAqIEBwYXJhbSB7IU11dGF0aW9uT2JzZXJ2ZXJ9IHNlbGZcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX3dhdGNoRm9ySW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3dhdGNoRm9ySW5lcnQocmVjb3Jkcywgc2VsZikge1xuICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSAnY2hpbGRMaXN0JzpcbiAgICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnW2luZXJ0XScpKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzLmNhbGwobm9kZSwgJ1tpbmVydF0nKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLnVuc2hpZnQobm9kZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpbmVydEVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGluZXJ0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluZXJ0KGluZXJ0RWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICB9LCBfdGhpcyk7XG4gICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlICdhdHRyaWJ1dGVzJzpcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgIT09ICdpbmVydCcpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdmFyIGluZXJ0ID0gdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRJbmVydCh0YXJnZXQsIGluZXJ0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRNYW5hZ2VyO1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IHdhbGsgdGhlIGNvbXBvc2VkIHRyZWUgZnJvbSB8bm9kZXwuXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7KGZ1bmN0aW9uICghSFRNTEVsZW1lbnQpKT19IGNhbGxiYWNrIENhbGxiYWNrIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBlbGVtZW50IHRyYXZlcnNlZCxcbiAgICAgKiAgICAgYmVmb3JlIGRlc2NlbmRpbmcgaW50byBjaGlsZCBub2Rlcy5cbiAgICAgKiBAcGFyYW0gez9TaGFkb3dSb290PX0gc2hhZG93Um9vdEFuY2VzdG9yIFRoZSBuZWFyZXN0IFNoYWRvd1Jvb3QgYW5jZXN0b3IsIGlmIGFueS5cbiAgICAgKi9cblxuXG4gICAgZnVuY3Rpb24gY29tcG9zZWRUcmVlV2Fsayhub2RlLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL25vZGU7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIGNhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVzY2VuZCBpbnRvIG5vZGU6XG4gICAgICAgIC8vIElmIGl0IGhhcyBhIFNoYWRvd1Jvb3QsIGlnbm9yZSBhbGwgY2hpbGQgZWxlbWVudHMgLSB0aGVzZSB3aWxsIGJlIHBpY2tlZFxuICAgICAgICAvLyB1cCBieSB0aGUgPGNvbnRlbnQ+IG9yIDxzaGFkb3c+IGVsZW1lbnRzLiBEZXNjZW5kIHN0cmFpZ2h0IGludG8gdGhlXG4gICAgICAgIC8vIFNoYWRvd1Jvb3QuXG4gICAgICAgIHZhciBzaGFkb3dSb290ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgICBpZiAoc2hhZG93Um9vdCkge1xuICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoc2hhZG93Um9vdCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBkaXN0cmlidXRlZCBlbGVtZW50cyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnY29udGVudCcpIHtcbiAgICAgICAgICB2YXIgY29udGVudCA9IC8qKiBAdHlwZSB7IUhUTUxDb250ZW50RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmaWVzIGlmIFNoYWRvd0RvbSB2MCBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIGRpc3RyaWJ1dGVkTm9kZXMgPSBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMgPyBjb250ZW50LmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhkaXN0cmlidXRlZE5vZGVzW2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQgaXMgYSA8c2xvdD4gZWxlbWVudCwgZGVzY2VuZCBpbnRvIGFzc2lnbmVkIG5vZGVzIC0gdGhlc2VcbiAgICAgICAgLy8gYXJlIGVsZW1lbnRzIGZyb20gb3V0c2lkZSB0aGUgc2hhZG93IHJvb3Qgd2hpY2ggYXJlIHJlbmRlcmVkIGluc2lkZSB0aGVcbiAgICAgICAgLy8gc2hhZG93IERPTS5cbiAgICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICdzbG90Jykge1xuICAgICAgICAgIHZhciBzbG90ID0gLyoqIEB0eXBlIHshSFRNTFNsb3RFbGVtZW50fSAqL2VsZW1lbnQ7XG4gICAgICAgICAgLy8gVmVyaWZ5IGlmIFNoYWRvd0RvbSB2MSBpcyBzdXBwb3J0ZWQuXG4gICAgICAgICAgdmFyIF9kaXN0cmlidXRlZE5vZGVzID0gc2xvdC5hc3NpZ25lZE5vZGVzID8gc2xvdC5hc3NpZ25lZE5vZGVzKHsgZmxhdHRlbjogdHJ1ZSB9KSA6IFtdO1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBfZGlzdHJpYnV0ZWROb2Rlcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoX2Rpc3RyaWJ1dGVkTm9kZXNbX2ldLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIGl0IGlzIG5laXRoZXIgdGhlIHBhcmVudCBvZiBhIFNoYWRvd1Jvb3QsIGEgPGNvbnRlbnQ+IGVsZW1lbnQsIGEgPHNsb3Q+XG4gICAgICAvLyBlbGVtZW50LCBub3IgYSA8c2hhZG93PiBlbGVtZW50IHJlY3Vyc2Ugbm9ybWFsbHkuXG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQgIT0gbnVsbCkge1xuICAgICAgICBjb21wb3NlZFRyZWVXYWxrKGNoaWxkLCBjYWxsYmFjaywgc2hhZG93Um9vdEFuY2VzdG9yKTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc3R5bGUgZWxlbWVudCB0byB0aGUgbm9kZSBjb250YWluaW5nIHRoZSBpbmVydCBzcGVjaWZpYyBzdHlsZXNcbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWRkSW5lcnRTdHlsZShub2RlKSB7XG4gICAgICBpZiAobm9kZS5xdWVyeVNlbGVjdG9yKCdzdHlsZSNpbmVydC1zdHlsZSwgbGluayNpbmVydC1zdHlsZScpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2luZXJ0LXN0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9ICdcXG4nICsgJ1tpbmVydF0ge1xcbicgKyAnICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG4nICsgJyAgY3Vyc29yOiBkZWZhdWx0O1xcbicgKyAnfVxcbicgKyAnXFxuJyArICdbaW5lcnRdLCBbaW5lcnRdICoge1xcbicgKyAnICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuJyArICcgIHVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnfVxcbic7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG5cbiAgICBpZiAoIUhUTUxFbGVtZW50LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5lcnQnKSkge1xuICAgICAgLyoqIEB0eXBlIHshSW5lcnRNYW5hZ2VyfSAqL1xuICAgICAgdmFyIGluZXJ0TWFuYWdlciA9IG5ldyBJbmVydE1hbmFnZXIoZG9jdW1lbnQpO1xuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnaW5lcnQnLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldChpbmVydCkge1xuICAgICAgICAgIGluZXJ0TWFuYWdlci5zZXRJbmVydCh0aGlzLCBpbmVydCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSkoKTtcblxufSkpKTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogYEJsb2NraW5nRWxlbWVudHNgIG1hbmFnZXMgYSBzdGFjayBvZiBlbGVtZW50cyB0aGF0IGluZXJ0IHRoZSBpbnRlcmFjdGlvblxuICogb3V0c2lkZSB0aGVtLiBUaGUgdG9wIGVsZW1lbnQgaXMgdGhlIGludGVyYWN0aXZlIHBhcnQgb2YgdGhlIGRvY3VtZW50LlxuICogVGhlIHN0YWNrIGNhbiBiZSB1cGRhdGVkIHdpdGggdGhlIG1ldGhvZHMgYHB1c2gsIHJlbW92ZSwgcG9wYC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgLyoqXG4gICAqIENhbGwgdGhpcyB3aGVuZXZlciB0aGlzIG9iamVjdCBpcyBhYm91dCB0byBiZWNvbWUgb2Jzb2xldGUuIFRoaXMgZW1wdGllc1xuICAgKiB0aGUgYmxvY2tpbmcgZWxlbWVudHNcbiAgICovXG4gIGRlc3RydWN0b3IoKTogdm9pZDtcblxuICAvKipcbiAgICogVGhlIHRvcCBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgdG9wOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBlbGVtZW50IHRvIHRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICovXG4gIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkO1xuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBlbGVtZW50IGZyb20gdGhlIGJsb2NraW5nIGVsZW1lbnRzLiBSZXR1cm5zIHRydWUgaWYgdGhlXG4gICAqIGVsZW1lbnQgd2FzIHJlbW92ZWQuXG4gICAqL1xuICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBSZW1vdmUgdGhlIHRvcCBibG9ja2luZyBlbGVtZW50IGFuZCByZXR1cm5zIGl0LlxuICAgKi9cbiAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGw7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgYSBibG9ja2luZyBlbGVtZW50LlxuICAgKi9cbiAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIGV4dGVuZHMgRG9jdW1lbnQge1xuICAkYmxvY2tpbmdFbGVtZW50czogQmxvY2tpbmdFbGVtZW50cztcbn1cblxuKCgpID0+IHtcbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBwcm9wZXJ0aWVzICovXG4gIGNvbnN0IF9ibG9ja2luZ0VsZW1lbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9hbHJlYWR5SW5lcnRFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfdG9wRWxQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zaWJsaW5nc1RvUmVzdG9yZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfcGFyZW50TU8gPSBTeW1ib2woKTtcblxuICAvKiBTeW1ib2xzIGZvciBwcml2YXRlIHN0YXRpYyBtZXRob2RzICovXG4gIGNvbnN0IF90b3BDaGFuZ2VkID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9zd2FwSW5lcnRlZFNpYmxpbmcgPSBTeW1ib2woKTtcbiAgY29uc3QgX2luZXJ0U2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX3Jlc3RvcmVJbmVydGVkU2libGluZ3MgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldFBhcmVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX2dldERpc3RyaWJ1dGVkQ2hpbGRyZW4gPSBTeW1ib2woKTtcbiAgY29uc3QgX2lzSW5lcnRhYmxlID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9oYW5kbGVNdXRhdGlvbnMgPSBTeW1ib2woKTtcblxuICBpbnRlcmZhY2UgSW5lcnRhYmxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgIGluZXJ0PzogYm9vbGVhbjtcbiAgfVxuXG4gIGludGVyZmFjZSBJbnRlcm5hbFN0YXRlIHtcbiAgICBbX3NpYmxpbmdzVG9SZXN0b3JlXTogU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT47XG4gICAgW19wYXJlbnRNT106IE11dGF0aW9uT2JzZXJ2ZXI7XG4gIH1cbiAgaW50ZXJmYWNlIEhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIEludGVybmFsU3RhdGUge31cbiAgaW50ZXJmYWNlIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSBleHRlbmRzIEluZXJ0YWJsZSwgUGFydGlhbDxJbnRlcm5hbFN0YXRlPiB7fVxuXG4gIC8qKlxuICAgKiBTaGFkeURPTSBzaGFkeSByb290cyBsb29rIGEgbG90IGxpa2UgcmVhbCBTaGFkb3dSb290cy4gVGhlIF9fc2hhZHkgcHJvcGVydHlcbiAgICogZ2l2ZXMgdGhlbSBhd2F5LCB0aG91Z2guXG4gICAqL1xuICBpbnRlcmZhY2UgTWF5YmVTaGFkeVJvb3QgZXh0ZW5kcyBFbGVtZW50IHtcbiAgICBfX3NoYWR5OiB1bmtub3duO1xuICAgIGhvc3Q6IEVsZW1lbnQ7XG4gIH1cblxuICBjbGFzcyBCbG9ja2luZ0VsZW1lbnRzSW1wbCBpbXBsZW1lbnRzIEJsb2NraW5nRWxlbWVudHMge1xuICAgIC8qKlxuICAgICAqIFRoZSBibG9ja2luZyBlbGVtZW50cy5cbiAgICAgKi9cbiAgICBwcml2YXRlW19ibG9ja2luZ0VsZW1lbnRzXTogTWF5YmVIYXNJbnRlcm5hbFN0YXRlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgcGFyZW50cyBvZiB0aGUgdG9wIGVsZW1lbnQsIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgKiBpdHNlbGYgdXAgdG8gYm9keS4gV2hlbiB0b3AgY2hhbmdlcywgdGhlIG9sZCB0b3AgbWlnaHQgaGF2ZSBiZWVuIHJlbW92ZWRcbiAgICAgKiBmcm9tIHRoZSBkb2N1bWVudCwgc28gd2UgbmVlZCB0byBtZW1vaXplIHRoZSBpbmVydGVkIHBhcmVudHMnIHNpYmxpbmdzXG4gICAgICogaW4gb3JkZXIgdG8gcmVzdG9yZSB0aGVpciBpbmVydGVuZXNzIHdoZW4gdG9wIGNoYW5nZXMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wRWxQYXJlbnRzXTogSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBFbGVtZW50cyB0aGF0IGFyZSBhbHJlYWR5IGluZXJ0IGJlZm9yZSB0aGUgZmlyc3QgYmxvY2tpbmcgZWxlbWVudCBpc1xuICAgICAqIHB1c2hlZC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19hbHJlYWR5SW5lcnRFbGVtZW50c10gPSBuZXcgU2V0PE1heWJlSGFzSW50ZXJuYWxTdGF0ZT4oKTtcblxuICAgIGRlc3RydWN0b3IoKTogdm9pZCB7XG4gICAgICAvLyBSZXN0b3JlIG9yaWdpbmFsIGluZXJ0bmVzcy5cbiAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKHRoaXNbX3RvcEVsUGFyZW50c10pO1xuICAgICAgLy8gTm90ZSB3ZSBkb24ndCB3YW50IHRvIG1ha2UgdGhlc2UgcHJvcGVydGllcyBudWxsYWJsZSBvbiB0aGUgY2xhc3MsXG4gICAgICAvLyBzaW5jZSB0aGVuIHdlJ2QgbmVlZCBub24tbnVsbCBjYXN0cyBpbiBtYW55IHBsYWNlcy4gQ2FsbGluZyBhIG1ldGhvZCBvblxuICAgICAgLy8gYSBCbG9ja2luZ0VsZW1lbnRzIGluc3RhbmNlIGFmdGVyIGNhbGxpbmcgZGVzdHJ1Y3RvciB3aWxsIHJlc3VsdCBpbiBhblxuICAgICAgLy8gZXhjZXB0aW9uLlxuICAgICAgY29uc3QgbnVsbGFibGUgPSB0aGlzIGFzIHVua25vd24gYXMge1xuICAgICAgICBbX2Jsb2NraW5nRWxlbWVudHNdOiBudWxsO1xuICAgICAgICBbX3RvcEVsUGFyZW50c106IG51bGw7XG4gICAgICAgIFtfYWxyZWFkeUluZXJ0RWxlbWVudHNdOiBudWxsO1xuICAgICAgfTtcbiAgICAgIG51bGxhYmxlW19ibG9ja2luZ0VsZW1lbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfdG9wRWxQYXJlbnRzXSA9IG51bGw7XG4gICAgICBudWxsYWJsZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbnVsbDtcbiAgICB9XG5cbiAgICBnZXQgdG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgZWxlbXMgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXTtcbiAgICAgIHJldHVybiBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgIH1cblxuICAgIHB1c2goZWxlbWVudDogSFRNTEVsZW1lbnQpOiB2b2lkIHtcbiAgICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50ID09PSB0aGlzLnRvcCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBSZW1vdmUgaXQgZnJvbSB0aGUgc3RhY2ssIHdlJ2xsIGJyaW5nIGl0IHRvIHRoZSB0b3AuXG4gICAgICB0aGlzLnJlbW92ZShlbGVtZW50KTtcbiAgICAgIHRoaXNbX3RvcENoYW5nZWRdKGVsZW1lbnQpO1xuICAgICAgdGhpc1tfYmxvY2tpbmdFbGVtZW50c10ucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZW1vdmUoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIGNvbnN0IGkgPSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpO1xuICAgICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnNwbGljZShpLCAxKTtcbiAgICAgIC8vIFRvcCBjaGFuZ2VkIG9ubHkgaWYgdGhlIHJlbW92ZWQgZWxlbWVudCB3YXMgdGhlIHRvcCBlbGVtZW50LlxuICAgICAgaWYgKGkgPT09IHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLmxlbmd0aCkge1xuICAgICAgICB0aGlzW190b3BDaGFuZ2VkXSh0aGlzLnRvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBwb3AoKTogSFRNTEVsZW1lbnR8bnVsbCB7XG4gICAgICBjb25zdCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgIHRvcCAmJiB0aGlzLnJlbW92ZSh0b3ApO1xuICAgICAgcmV0dXJuIHRvcDtcbiAgICB9XG5cbiAgICBoYXMoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5pbmRleE9mKGVsZW1lbnQpICE9PSAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGBpbmVydGAgdG8gYWxsIGRvY3VtZW50IGVsZW1lbnRzIGV4Y2VwdCB0aGUgbmV3IHRvcCBlbGVtZW50LCBpdHNcbiAgICAgKiBwYXJlbnRzLCBhbmQgaXRzIGRpc3RyaWJ1dGVkIGNvbnRlbnQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfdG9wQ2hhbmdlZF0obmV3VG9wOiBNYXliZUhhc0ludGVybmFsU3RhdGV8bnVsbCk6IHZvaWQge1xuICAgICAgY29uc3QgdG9LZWVwSW5lcnQgPSB0aGlzW19hbHJlYWR5SW5lcnRFbGVtZW50c107XG4gICAgICBjb25zdCBvbGRQYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIC8vIE5vIG5ldyB0b3AsIHJlc2V0IG9sZCB0b3AgaWYgYW55LlxuICAgICAgaWYgKCFuZXdUb3ApIHtcbiAgICAgICAgdGhpc1tfcmVzdG9yZUluZXJ0ZWRTaWJsaW5nc10ob2xkUGFyZW50cyk7XG4gICAgICAgIHRvS2VlcEluZXJ0LmNsZWFyKCk7XG4gICAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBbXTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuZXdQYXJlbnRzID0gdGhpc1tfZ2V0UGFyZW50c10obmV3VG9wKTtcbiAgICAgIC8vIE5ldyB0b3AgaXMgbm90IGNvbnRhaW5lZCBpbiB0aGUgbWFpbiBkb2N1bWVudCFcbiAgICAgIGlmIChuZXdQYXJlbnRzW25ld1BhcmVudHMubGVuZ3RoIC0gMV0ucGFyZW50Tm9kZSAhPT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB0aHJvdyBFcnJvcignTm9uLWNvbm5lY3RlZCBlbGVtZW50IGNhbm5vdCBiZSBhIGJsb2NraW5nIGVsZW1lbnQnKTtcbiAgICAgIH1cbiAgICAgIC8vIENhc3QgaGVyZSBiZWNhdXNlIHdlIGtub3cgd2UnbGwgY2FsbCBfaW5lcnRTaWJsaW5ncyBvbiBuZXdQYXJlbnRzXG4gICAgICAvLyBiZWxvdy5cbiAgICAgIHRoaXNbX3RvcEVsUGFyZW50c10gPSBuZXdQYXJlbnRzIGFzIEFycmF5PEhhc0ludGVybmFsU3RhdGU+O1xuXG4gICAgICBjb25zdCB0b1NraXAgPSB0aGlzW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShuZXdUb3ApO1xuXG4gICAgICAvLyBObyBwcmV2aW91cyB0b3AgZWxlbWVudC5cbiAgICAgIGlmICghb2xkUGFyZW50cy5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfaW5lcnRTaWJsaW5nc10obmV3UGFyZW50cywgdG9Ta2lwLCB0b0tlZXBJbmVydCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGkgPSBvbGRQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICBsZXQgaiA9IG5ld1BhcmVudHMubGVuZ3RoIC0gMTtcbiAgICAgIC8vIEZpbmQgY29tbW9uIHBhcmVudC4gSW5kZXggMCBpcyB0aGUgZWxlbWVudCBpdHNlbGYgKHNvIHN0b3AgYmVmb3JlIGl0KS5cbiAgICAgIHdoaWxlIChpID4gMCAmJiBqID4gMCAmJiBvbGRQYXJlbnRzW2ldID09PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIGktLTtcbiAgICAgICAgai0tO1xuICAgICAgfVxuICAgICAgLy8gSWYgdXAgdGhlIHBhcmVudHMgdHJlZSB0aGVyZSBhcmUgMiBlbGVtZW50cyB0aGF0IGFyZSBzaWJsaW5ncywgc3dhcFxuICAgICAgLy8gdGhlIGluZXJ0ZWQgc2libGluZy5cbiAgICAgIGlmIChvbGRQYXJlbnRzW2ldICE9PSBuZXdQYXJlbnRzW2pdKSB7XG4gICAgICAgIHRoaXNbX3N3YXBJbmVydGVkU2libGluZ10ob2xkUGFyZW50c1tpXSwgbmV3UGFyZW50c1tqXSk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIG9sZCBwYXJlbnRzIHNpYmxpbmdzIGluZXJ0bmVzcy5cbiAgICAgIGkgPiAwICYmIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMuc2xpY2UoMCwgaSkpO1xuICAgICAgLy8gTWFrZSBuZXcgcGFyZW50cyBzaWJsaW5ncyBpbmVydC5cbiAgICAgIGogPiAwICYmIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMuc2xpY2UoMCwgaiksIHRvU2tpcCwgbnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3dhcHMgaW5lcnRuZXNzIGJldHdlZW4gdHdvIHNpYmxpbmcgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfc3dhcEluZXJ0ZWRTaWJsaW5nXShcbiAgICAgICAgb2xkSW5lcnQ6IEhhc0ludGVybmFsU3RhdGUsIG5ld0luZXJ0OiBNYXliZUhhc0ludGVybmFsU3RhdGUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNpYmxpbmdzVG9SZXN0b3JlID0gb2xkSW5lcnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgIC8vIG9sZEluZXJ0IGlzIG5vdCBjb250YWluZWQgaW4gc2libGluZ3MgdG8gcmVzdG9yZSwgc28gd2UgaGF2ZSB0byBjaGVja1xuICAgICAgLy8gaWYgaXQncyBpbmVydGFibGUgYW5kIGlmIGFscmVhZHkgaW5lcnQuXG4gICAgICBpZiAodGhpc1tfaXNJbmVydGFibGVdKG9sZEluZXJ0KSAmJiAhb2xkSW5lcnQuaW5lcnQpIHtcbiAgICAgICAgb2xkSW5lcnQuaW5lcnQgPSB0cnVlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5hZGQob2xkSW5lcnQpO1xuICAgICAgfVxuICAgICAgLy8gSWYgbmV3SW5lcnQgd2FzIGFscmVhZHkgYmV0d2VlbiB0aGUgc2libGluZ3MgdG8gcmVzdG9yZSwgaXQgbWVhbnMgaXQgaXNcbiAgICAgIC8vIGluZXJ0YWJsZSBhbmQgbXVzdCBiZSByZXN0b3JlZC5cbiAgICAgIGlmIChzaWJsaW5nc1RvUmVzdG9yZS5oYXMobmV3SW5lcnQpKSB7XG4gICAgICAgIG5ld0luZXJ0LmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIHNpYmxpbmdzVG9SZXN0b3JlLmRlbGV0ZShuZXdJbmVydCk7XG4gICAgICB9XG4gICAgICBuZXdJbmVydFtfcGFyZW50TU9dID0gb2xkSW5lcnRbX3BhcmVudE1PXTtcbiAgICAgIG5ld0luZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBzaWJsaW5nc1RvUmVzdG9yZTtcbiAgICAgIChvbGRJbmVydCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc3RvcmVzIG9yaWdpbmFsIGluZXJ0bmVzcyB0byB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKGVsZW1lbnRzOiBIYXNJbnRlcm5hbFN0YXRlW10pIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICBjb25zdCBtbyA9IGVsZW1lbnRbX3BhcmVudE1PXTtcbiAgICAgICAgbW8uZGlzY29ubmVjdCgpO1xuICAgICAgICAoZWxlbWVudCBhcyBNYXliZUhhc0ludGVybmFsU3RhdGUpW19wYXJlbnRNT10gPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNpYmxpbmdzID0gZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdO1xuICAgICAgICBmb3IgKGNvbnN0IHNpYmxpbmcgb2Ygc2libGluZ3MpIHtcbiAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfc2libGluZ3NUb1Jlc3RvcmVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluZXJ0cyB0aGUgc2libGluZ3Mgb2YgdGhlIGVsZW1lbnRzIGV4Y2VwdCB0aGUgZWxlbWVudHMgdG8gc2tpcC4gU3RvcmVzXG4gICAgICogdGhlIGluZXJ0ZWQgc2libGluZ3MgaW50byB0aGUgZWxlbWVudCdzIHN5bWJvbCBgX3NpYmxpbmdzVG9SZXN0b3JlYC5cbiAgICAgKiBQYXNzIGB0b0tlZXBJbmVydGAgdG8gY29sbGVjdCB0aGUgYWxyZWFkeSBpbmVydCBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19pbmVydFNpYmxpbmdzXShcbiAgICAgICAgZWxlbWVudHM6IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdLCB0b1NraXA6IFNldDxIVE1MRWxlbWVudD58bnVsbCxcbiAgICAgICAgdG9LZWVwSW5lcnQ6IFNldDxIVE1MRWxlbWVudD58bnVsbCkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIC8vIEFzc3VtZSBlbGVtZW50IGlzIG5vdCBhIERvY3VtZW50LCBzbyBpdCBtdXN0IGhhdmUgYSBwYXJlbnROb2RlLlxuICAgICAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGUhO1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudC5jaGlsZHJlbjtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBjaGlsZHJlbltqXSBhcyBNYXliZUhhc0ludGVybmFsU3RhdGU7XG4gICAgICAgICAgLy8gU2tpcCB0aGUgaW5wdXQgZWxlbWVudCwgaWYgbm90IGluZXJ0YWJsZSBvciB0byBiZSBza2lwcGVkLlxuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBlbGVtZW50IHx8ICF0aGlzW19pc0luZXJ0YWJsZV0oc2libGluZykgfHxcbiAgICAgICAgICAgICAgKHRvU2tpcCAmJiB0b1NraXAuaGFzKHNpYmxpbmcpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFNob3VsZCBiZSBjb2xsZWN0ZWQgc2luY2UgYWxyZWFkeSBpbmVydGVkLlxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3RvcmUgdGhlIHNpYmxpbmdzIHRoYXQgd2VyZSBpbmVydGVkLlxuICAgICAgICBlbGVtZW50W19zaWJsaW5nc1RvUmVzdG9yZV0gPSBpbmVydGVkU2libGluZ3M7XG4gICAgICAgIC8vIE9ic2VydmUgb25seSBpbW1lZGlhdGUgY2hpbGRyZW4gbXV0YXRpb25zIG9uIHRoZSBwYXJlbnQuXG4gICAgICAgIGNvbnN0IG1vID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpc1tfaGFuZGxlTXV0YXRpb25zXS5iaW5kKHRoaXMpKTtcbiAgICAgICAgZWxlbWVudFtfcGFyZW50TU9dID0gbW87XG4gICAgICAgIGxldCBwYXJlbnRUb09ic2VydmUgPSBwYXJlbnQ7XG4gICAgICAgIC8vIElmIHdlJ3JlIHVzaW5nIHRoZSBTaGFkeURPTSBwb2x5ZmlsbCwgdGhlbiBvdXIgcGFyZW50IGNvdWxkIGJlIGFcbiAgICAgICAgLy8gc2hhZHkgcm9vdCwgd2hpY2ggaXMgYW4gb2JqZWN0IHRoYXQgYWN0cyBsaWtlIGEgU2hhZG93Um9vdCwgYnV0IGlzbid0XG4gICAgICAgIC8vIGFjdHVhbGx5IGEgbm9kZSBpbiB0aGUgcmVhbCBET00uIE9ic2VydmUgdGhlIHJlYWwgRE9NIHBhcmVudCBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBtYXliZVNoYWR5Um9vdCA9IHBhcmVudFRvT2JzZXJ2ZSBhcyBNYXliZVNoYWR5Um9vdDtcbiAgICAgICAgaWYgKG1heWJlU2hhZHlSb290Ll9fc2hhZHkgJiYgbWF5YmVTaGFkeVJvb3QuaG9zdCkge1xuICAgICAgICAgIHBhcmVudFRvT2JzZXJ2ZSA9IG1heWJlU2hhZHlSb290Lmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbW8ub2JzZXJ2ZShwYXJlbnRUb09ic2VydmUsIHtcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbmV3bHkgYWRkZWQvcmVtb3ZlZCBub2RlcyBieSB0b2dnbGluZyB0aGVpciBpbmVydG5lc3MuXG4gICAgICogSXQgYWxzbyBjaGVja3MgaWYgdGhlIGN1cnJlbnQgdG9wIEJsb2NraW5nIEVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCxcbiAgICAgKiBub3RpZnlpbmcgYW5kIHJlbW92aW5nIGl0LlxuICAgICAqL1xuICAgIHByaXZhdGVbX2hhbmRsZU11dGF0aW9uc10obXV0YXRpb25zOiBNdXRhdGlvblJlY29yZFtdKTogdm9pZCB7XG4gICAgICBjb25zdCBwYXJlbnRzID0gdGhpc1tfdG9wRWxQYXJlbnRzXTtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRhcmdldCBpcyBhIHNoYWRvd1Jvb3QsIGdldCBpdHMgaG9zdCBhcyB3ZSBza2lwIHNoYWRvd1Jvb3RzIHdoZW5cbiAgICAgICAgLy8gY29tcHV0aW5nIF90b3BFbFBhcmVudHMuXG4gICAgICAgIGNvbnN0IHRhcmdldCA9IChtdXRhdGlvbi50YXJnZXQgYXMgU2hhZG93Um9vdCkuaG9zdCB8fCBtdXRhdGlvbi50YXJnZXQ7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRhcmdldCA9PT0gZG9jdW1lbnQuYm9keSA/XG4gICAgICAgICAgICBwYXJlbnRzLmxlbmd0aCA6XG4gICAgICAgICAgICBwYXJlbnRzLmluZGV4T2YodGFyZ2V0IGFzIEhhc0ludGVybmFsU3RhdGUpO1xuICAgICAgICBjb25zdCBpbmVydGVkQ2hpbGQgPSBwYXJlbnRzW2lkeCAtIDFdO1xuICAgICAgICBjb25zdCBpbmVydGVkU2libGluZ3MgPSBpbmVydGVkQ2hpbGRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcblxuICAgICAgICAvLyBUbyByZXN0b3JlLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG11dGF0aW9uLnJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5yZW1vdmVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmIChzaWJsaW5nID09PSBpbmVydGVkQ2hpbGQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuaW5mbygnRGV0ZWN0ZWQgcmVtb3ZhbCBvZiB0aGUgdG9wIEJsb2NraW5nIEVsZW1lbnQuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW5lcnRlZFNpYmxpbmdzLmhhcyhzaWJsaW5nKSkge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmRlbGV0ZShzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUbyBpbmVydC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IG11dGF0aW9uLmFkZGVkTm9kZXNbaV0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIGlmICghdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRvS2VlcEluZXJ0ICYmIHNpYmxpbmcuaW5lcnQpIHtcbiAgICAgICAgICAgIHRvS2VlcEluZXJ0LmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2libGluZy5pbmVydCA9IHRydWU7XG4gICAgICAgICAgICBpbmVydGVkU2libGluZ3MuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIGVsZW1lbnQgaXMgaW5lcnRhYmxlLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2lzSW5lcnRhYmxlXShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGZhbHNlID09PSAvXihzdHlsZXx0ZW1wbGF0ZXxzY3JpcHQpJC8udGVzdChlbGVtZW50LmxvY2FsTmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGlzdCBvZiBuZXdQYXJlbnRzIG9mIGFuIGVsZW1lbnQsIHN0YXJ0aW5nIGZyb20gZWxlbWVudFxuICAgICAqIChpbmNsdWRlZCkgdXAgdG8gYGRvY3VtZW50LmJvZHlgIChleGNsdWRlZCkuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0UGFyZW50c10oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBBcnJheTxIVE1MRWxlbWVudD4ge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGN1cnJlbnQ6IEhUTUxFbGVtZW50fG51bGx8dW5kZWZpbmVkID0gZWxlbWVudDtcbiAgICAgIC8vIFN0b3AgdG8gYm9keS5cbiAgICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgLy8gU2tpcCBzaGFkb3cgcm9vdHMuXG4gICAgICAgIGlmIChjdXJyZW50Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaGFkb3dEb20gdjFcbiAgICAgICAgaWYgKGN1cnJlbnQuYXNzaWduZWRTbG90KSB7XG4gICAgICAgICAgLy8gQ29sbGVjdCBzbG90cyBmcm9tIGRlZXBlc3Qgc2xvdCB0byB0b3AuXG4gICAgICAgICAgd2hpbGUgKGN1cnJlbnQgPSBjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDb250aW51ZSB0aGUgc2VhcmNoIG9uIHRoZSB0b3Agc2xvdC5cbiAgICAgICAgICBjdXJyZW50ID0gcGFyZW50cy5wb3AoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlIGFzIEhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICAoY3VycmVudCBhcyBOb2RlIGFzIFNoYWRvd1Jvb3QpLmhvc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyZW50cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCBjaGlsZHJlbiBvZiB0aGUgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqIFJldHVybnMgbnVsbCBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYSBzaGFkb3cgcm9vdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19nZXREaXN0cmlidXRlZENoaWxkcmVuXShlbGVtZW50OiBIVE1MRWxlbWVudCk6XG4gICAgICAgIFNldDxIVE1MRWxlbWVudD58bnVsbCB7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKCFzaGFkb3dSb290KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNldDxIVE1MRWxlbWVudD4oKTtcbiAgICAgIGxldCBpO1xuICAgICAgbGV0IGo7XG4gICAgICBsZXQgbm9kZXM7XG4gICAgICBjb25zdCBzbG90cyA9IHNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbCgnc2xvdCcpO1xuICAgICAgaWYgKHNsb3RzLmxlbmd0aCAmJiBzbG90c1swXS5hc3NpZ25lZE5vZGVzKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG5vZGVzID0gc2xvdHNbaV0uYXNzaWduZWROb2Rlcyh7XG4gICAgICAgICAgICBmbGF0dGVuOiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub2Rlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2pdLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICByZXN1bHQuYWRkKG5vZGVzW2pdIGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gbmVlZCB0byBzZWFyY2ggZm9yIDxjb250ZW50Pi5cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG5cbiAgKGRvY3VtZW50IGFzIERvY3VtZW50V2l0aEJsb2NraW5nRWxlbWVudHMpLiRibG9ja2luZ0VsZW1lbnRzID1cbiAgICAgIG5ldyBCbG9ja2luZ0VsZW1lbnRzSW1wbCgpO1xufSkoKTtcbiIsImltcG9ydCBcIndpY2ctaW5lcnRcIjtcbmltcG9ydCBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzIH0gZnJvbSBcImJsb2NraW5nLWVsZW1lbnRzXCI7XG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmZ1bmN0aW9uIGJsb2NraW5nRWxlbWVudHMoKSB7IHJldHVybiAoZ2V0RG9jdW1lbnQoKSBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyB9XG4vKipcbiAqIEFsbG93cyBhbiBlbGVtZW50IHRvIHRyYXAgZm9jdXMgYnkgYXBwbHlpbmcgdGhlIFwiaW5lcnRcIiBhdHRyaWJ1dGUgdG8gYWxsIHNpYmxpbmcsIGF1bnQsIGFuZCB1bmNsZSBub2Rlcy5cbiAqIFxuICogQXV0b21hdGljYWxseSBoYW5kbGVzIGNvbnNlY3V0aXZlIGNhbGxzIHdpdGggYSBsb29zZWx5IGFwcGxpZWQgc3RhY2sgb3BlcmF0aW9uIFxuICogKHNwZWNpZmljYWxseSB2aWEgYGJsb2NraW5nRWxlbWVudHNgLCB3aXRoIGEgc21hbGwgcG9seWZpbGwgYmVjYXVzZSBJJ20gbm90IHN1cmUgaG93IGxvbmdcbiAqIGl0J2xsIHRha2UgdG8gZmluZCBpdHMgd2F5IGludG8gdGhlIHNwZWMsIGlmIGV2ZXIpXG4gKiBAcGFyYW0gdGFyZ2V0IFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmxvY2tpbmdFbGVtZW50PEUgZXh0ZW5kcyBFbGVtZW50PihlbmFibGVkOiBib29sZWFuLCBnZXRUYXJnZXQ6ICgpID0+IChFIHwgbnVsbCkpIHtcblxuICAgIGNvbnN0IHN0YWJsZUdldFRhcmdldCA9IHVzZVN0YWJsZUNhbGxiYWNrKGdldFRhcmdldCk7XG5cbiAgICAvKipcbiAgICAgKiBQdXNoL3BvcCB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZ0VsZW1lbnRzIHN0YWNrLlxuICAgICAqL1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IHN0YWJsZUdldFRhcmdldCgpO1xuXG4gICAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBTb21ldGltZXMgYmxvY2tpbmdFbGVtZW50cyB3aWxsIGZhaWwgaWYsIGZvciBleGFtcGxlLFxuICAgICAgICAgICAgLy8gdGhlIHRhcmdldCBlbGVtZW50IGlzbid0IGNvbm5lY3RlZCB0byBkb2N1bWVudC5ib2R5LlxuICAgICAgICAgICAgLy8gVGhpcyBpcyByYXJlLCBidXQgaXQncyBiZXR0ZXIgdG8gZmFpbCBzaWxlbnRseSB3aXRoIHdlaXJkIHRhYmJpbmcgYmVoYXZpb3JcbiAgICAgICAgICAgIC8vIHRoYW4gdG8gY3Jhc2ggdGhlIGVudGlyZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmxvY2tpbmdFbGVtZW50cygpLnB1c2godGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5yZW1vdmUodGFyZ2V0IGFzIEVsZW1lbnQgYXMgSFRNTEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBXZWxsLCBzZW1pLXNpbGVudGx5LlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2VuYWJsZWRdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRvcEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGJsb2NraW5nRWxlbWVudHMoKS50b3A7XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgaXNGb2N1c2FibGUgfSBmcm9tIFwidGFiYmFibGVcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyBnZXRUb3BFbGVtZW50LCB1c2VCbG9ja2luZ0VsZW1lbnQgfSBmcm9tIFwiLi91c2UtYmxvY2tpbmctZWxlbWVudFwiO1xyXG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMgeyB0cmFwQWN0aXZlOiBib29sZWFuOyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUZvY3VzVHJhcFJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4ge1xyXG4gICAgLyoqICpVbnN0YWJsZSogKHJlbGllcyBvbiB0aGUgYHRyYXBBY3RpdmVgIHByb3ApICovXHJcbiAgICB1c2VGb2N1c1RyYXBQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmNvbnN0IGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUbyA9IG5ldyBNYXA8RWxlbWVudCB8IG51bGwsIChOb2RlICYgSFRNTE9yU1ZHRWxlbWVudCk+KCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9jdXNUcmFwPEUgZXh0ZW5kcyBIVE1MRWxlbWVudD4oeyB0cmFwQWN0aXZlIH06IFVzZUZvY3VzVHJhcFBhcmFtZXRlcnMpOiBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEU+IHtcclxuICAgIFxyXG4gICAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYXBBY3RpdmU6IGJvb2xlYW4sIGVsZW1lbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xyXG5cclxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGlzIGV4dHJhIHF1ZXVlTWljcm90YXNrIGlzIG5lZWRlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIC4uLnJlYXNvbnM/XHJcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudCkge1xyXG5cclxuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgZm9jdXMgdG8gdGhlIGVsZW1lbnRcclxuICAgICAgICAgICAgLy8gdGhhdCBoYXMgcmV0dXJuZWQgdG8gdGhlIHRvcCBvZiB0aGUgc3RhY2tcclxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvLmdldChnZXRUb3BFbGVtZW50KCkpPy5mb2N1cygpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHJhZkhhbmRsZSlcclxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuICAgIFxyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oeyBvbkVsZW1lbnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCkgPT4gaGFuZGxlQWN0aXZlQ2hhbmdlKHRyYXBBY3RpdmUsIGVsZW1lbnQpKSB9KVxyXG4gICAgY29uc3QgeyBnZXRMYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7IGdldERvY3VtZW50OiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiBnZXRFbGVtZW50KCk/Lm93bmVyRG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ICkgfSk7XHJcblxyXG5cclxuICAgIC8vIFdoZW4gdGhlIHRyYXAgYmVjb21lcyBhY3RpdmUsIGJlZm9yZSB3ZSBsZXQgdGhlIGJsb2NraW5nRWxlbWVudHMgaG9vayBydW4sXHJcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoYXRldmVyJ3MgY3VycmVudGx5IGZvY3VzZWQgYW5kIHNhdmUgaXQuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKHRyYXBBY3RpdmUgJiYgZWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xyXG5cclxuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxyXG4gICAgICAgICAgICAvLyB0byB3aGF0ZXZlcidzIGN1cnJlbnRseSBhdCB0aGUgdG9wIG9mIHRoZSBzdGFja1xyXG4gICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uc2V0KGdldFRvcEVsZW1lbnQoKSwgKGdldExhc3RBY3RpdmVFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSkgPz8gZG9jdW1lbnQuYm9keSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW3RyYXBBY3RpdmVdKTtcclxuXHJcbiAgICB1c2VCbG9ja2luZ0VsZW1lbnQodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBbnkgdGltZSB3ZSBhY3RpdmF0ZSBvciBkZWFjdGl2YXRlIHRoZSB0cmFwLFxyXG4gICAgICogY2hhbmdlIGZvY3VzIHRvIHNvbWV0aGluZyBlbHNlIChzb21ldGhpbmcgaW5cclxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxyXG4gICAgICogdHJhY2tlZCBpbiBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gaWYgbm90KVxyXG4gICAgICovXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGhhbmRsZUFjdGl2ZUNoYW5nZSh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KCkpO1xyXG4gICAgfSwgW3RyYXBBY3RpdmVdKTtcclxuXHJcbiAgICBjb25zdCB1c2VGb2N1c1RyYXBQcm9wcyA9ICgocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcDEgPSB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpO1xyXG4gICAgICAgIGNvbnN0IHAyID0geyBcImFyaWEtbW9kYWxcIjogdHJhcEFjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHAxLCBwMik7XHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VGb2N1c1RyYXBQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUmV0dXJucyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgY29udGFpbmVkIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSwgb3IgbnVsbCBpZiBub25lIGFyZSBmb3VuZC5cclxuICogQHBhcmFtIGVsZW1lbnQgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50OiBOb2RlKSB7XHJcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSlcclxuICAgIGNvbnN0IGZpcnN0Rm9jdXNhYmxlID0gdHJlZVdhbGtlci5maXJzdENoaWxkKCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSB8IG51bGw7XHJcbiAgICByZXR1cm4gZmlyc3RGb2N1c2FibGU7XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCwgd2hlbiBjYWxsZWQsIGZvcmNlIHRoZSBjb21wb25lbnRcbiAqIHRoYXQgdXNlcyB0aGlzIGhvb2sgdG8gcmUtcmVuZGVyIGl0c2VsZi5cbiAqIFxuICogSXQncyBhIGJpdCBzbWVsbHksIHNvIGJlc3QgdG8gdXNlIHNwYXJpbmdseS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IFssIHNldF0gPSB1c2VTdGF0ZSgwKTtcbiAgICByZXR1cm4gdXNlUmVmKCgpID0+IHNldChpID0+ICsraSkpLmN1cnJlbnQ7XG59IiwiXHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnMsIHVzZU1hbmFnZWRDaGlsZHJlbiwgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVycywgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlQWN0aXZlRWxlbWVudCwgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFjdGl2ZS1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHJldHVybkZhbHNlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAqIFxyXG4gICAgICogYHByZXZGb2N1c2VkYCBpcyBnZW5lcmFsbHkgdGhlIG9wcG9zaXRlIG9mIGBmb2N1c2VkYCwgYnV0IG9uIG1vdW50IGl0J3MgYHVuZGVmaW5lZGAgd2hpbGUgYGZvY3VzZWRgIGlzIHByb2JhYmx5IGZhbHNlIChib3RoIGZhbHN5KVxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGBvbkZvY3VzZWRDaGFuZ2VkYCwgYnV0IGFsc28gKmFkZGl0aW9uYWxseSogaWYgYW55IGNoaWxkIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbWlsYXIgdG8gYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgaXMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCB0aGF0ICpkaWQqIGhhdmUgZm9jdXMgbGFzdC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoaWxlIGBmb2N1c2VkYCBpcyBgdHJ1ZWAuIElmIGBmb2N1c2VkYCBpcyBgZmFsc2VgLCB0aGlzIG1heSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSBpbXBsaWNhdGlvbnMgb2YgYG9uRm9jdXNlZENoYW5nZWRgIGFuZCBgb25Gb2N1c2VkQ2hhbmdlZGAuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1JldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4sIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBlbGVtZW50IHRvIGJlIGFibGUgdG8gdHJhY2sgaXRzIG93biBmb2N1cyBzdGF0ZVxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZUhhc0ZvY3VzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG5cclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzPFQgZXh0ZW5kcyBOb2RlPih7IG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNGb2N1c1JldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRJbm5lckNoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7XHJcbiAgICAgICAgZ2V0RG9jdW1lbnQsXHJcbiAgICAgICAgZ2V0V2luZG93LFxyXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigoYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZkVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZvY3VzZWQpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPy4oYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigobGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldExhc3RGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT8uKGxhc3RBY3RpdmVFbGVtZW50LCBwcmV2TGFzdEFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUhhc0ZvY3VzUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiB7IHJldHVybiB1c2VSZWZFbGVtZW50UHJvcHMocHJvcHMpOyB9LCBbXSk7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldEZvY3VzZWQsXHJcbiAgICAgICAgZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcclxuICAgICAgICBvbkFueUdhaW5lZEZvY3VzPygpOiB2b2lkO1xyXG4gICAgICAgIG9uQWxsTG9zdEZvY3VzPygpOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxudW1iZXIsIEZvY3VzSW5mbywgbmV2ZXIsIFwic3ViSW5mb1wiPiwgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzPEU+IHtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPEU+LCBcInVzZVJlZkVsZW1lbnRQcm9wc1wiPiwgT21pdDxVc2VIYXNGb2N1c1JldHVyblR5cGU8RT4sIFwidXNlSGFzRm9jdXNQcm9wc1wiPiB7XHJcbiAgICB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHMocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmludGVyZmFjZSBGb2N1c0luZm8ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVJbmZvIGV4dGVuZHMgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZUluZm88bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPiB7XHJcbn1cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyBleHRlbmRzIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZDogPEUgZXh0ZW5kcyBFbGVtZW50PihwYXJhbWV0ZXJzOiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPikgPT4gVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFJldHVyblR5cGU8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VDaGlsZHJlbkhhdmVGb2N1cyh7IGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH06IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyk6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzUmV0dXJuVHlwZVdpdGhIb29rcyB7XHJcbiAgICBjb25zdCB7IG1hbmFnZWRDaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBGb2N1c0luZm8sIG5ldmVyPih7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0pO1xyXG4gICAgY29uc3QgYWxsRWxlbWVudHNSZWYgPSB1c2VSZWY8U2V0PE5vZGU+PihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgW19nZXRGb2N1c0NvdW50LCBzZXRGb2N1c0NvdW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxudW1iZXI+KHVzZVN0YWJsZUNhbGxiYWNrKChhbnlGb2N1c2VkOiBudW1iZXIsIGFueVByZXZpb3VzbHlGb2N1c2VkOiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgQ2hhbmdpbmcgZm9jdXMgY291bnQgZnJvbSAke2FueVByZXZpb3VzbHlGb2N1c2VkfSB0byAke2FueUZvY3VzZWR9YCk7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoYW55Rm9jdXNlZCA+PSAwICYmIGFueUZvY3VzZWQgPD0gMSk7XHJcblxyXG4gICAgICAgIGlmIChhbnlGb2N1c2VkICYmICFhbnlQcmV2aW91c2x5Rm9jdXNlZClcclxuICAgICAgICAgICAgb25BbnlHYWluZWRGb2N1cz8uKCk7XHJcbiAgICAgICAgaWYgKCFhbnlGb2N1c2VkICYmIGFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCA9IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFPik6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+ID0+IHtcclxuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIHN1YkluZm86IHt9LCBmbGFncyB9IH0pO1xyXG4gICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgLi4uaGFzRm9jdXMgIH0gPSB1c2VIYXNGb2N1czxFPih7XHJcbiAgICAgICAgICAgIGdldERvY3VtZW50LFxyXG4gICAgICAgICAgICBnZXRXaW5kb3csXHJcbiAgICAgICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgICAgICAgICAgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogRSB8IG51bGwsIHByZXY6IEUgfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBsZXQgciA9IG9uRWxlbWVudENoYW5nZT8uKGUsIHByZXYpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxFbGVtZW50c1JlZi5jdXJyZW50LmFkZChlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByPy4oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRWxlbWVudHNSZWYuY3VycmVudC5kZWxldGUoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBbb25FbGVtZW50Q2hhbmdlXSksXHJcbiAgICAgICAgICAgIG9uTW91bnQsXHJcbiAgICAgICAgICAgIG9uVW5tb3VudCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLFxyXG4gICAgICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLFxyXG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChmb2N1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENoaWxkICR7aW5kZXh9IGlzIGZvY3VzZWRgKTtcclxuICAgICAgICAgICAgICAgICAgICBzZXRGb2N1c0NvdW50KHAgPT4gKHAgPz8gMCkgKyAxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFmb2N1c2VkICYmIHByZXYpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ2hpbGQgJHtpbmRleH0gaXMgdW5mb2N1c2VkYCk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0Rm9jdXNDb3VudChwID0+IChwID8/IDApIC0gMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xyXG4gICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wczogdXNlSGFzRm9jdXNQcm9wcyxcclxuICAgICAgICAgICAgLi4uaGFzRm9jdXNcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlR2xvYmFsSGFuZGxlciB9IGZyb20gXCIuL3VzZS1ldmVudC1oYW5kbGVyXCI7XHJcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSBcIi4vdXNlLWZvcmNlLXVwZGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG5pbnRlcmZhY2UgVXNlUHJlc3NQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBOb2RlPiB7XHJcbiAgICBvbkNsaWNrU3luYzogKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWQ7XHJcbiAgICBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfTtcclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBZGRzIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgdG8gY3JlYXRlIGEgXCJwcmVzc1wiLWxpa2UgZXZlbnQgZm9yXHJcbiAqIGFueSBlbGVtZW50LCB3aGV0aGVyIGl0J3MgYSBuYXRpdmUgPEJVVFRPTj4gb3IgcmVndWxhciA8RElWPi5cclxuICogXHJcbiAqIE5vdGFibHksIHRoZSBmb2xsb3dpbmcgY2FzZXMgYXJlIGNvdmVyZWQ6XHJcbiAqICogVGhlIHRhcmdldCBlbGVtZW50IGlzIHByb3Blcmx5IGZvY3VzZWQsIGV2ZW4gb24gaU9TIFNhZmFyaSAoKmVzcGVjaWFsbHkqIG9uIGlPUyBTYWZhcmkpXHJcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXHJcbiAqICogQ29udmVyc2VseSwgbWFudWFsbHkgc2VsZWN0aW5nIHRleHQgd29uJ3QgaW52b2tlIGEgcHJlc3MuXHJcbiAqICogS2V5Ym9hcmQgZXZlbnRzICZtZGFzaDsgYGVudGVyYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBoYW5kbGVyLCB3aGlsZSBgc3BhY2VgIGludm9rZXMgaXQgb24ga2V5dXAuXHJcbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcclxuICogXHJcbiAqIEluIGFkZGl0aW9uLCB3aGVuIHRoZSBDU1MgYDphY3RpdmVgIHBzZXVkby1jbGFzcyB3b3VsZCBhcHBseSB0byBhIG5vcm1hbCBidXR0b25cclxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcclxuICogaXMgYWRkZWQgdG8gdGhlIHByb3BzLiAgWW91IGNhbiBlaXRoZXIgbGV0IGl0IHBhc3MgdGhyb3VnaCBhbmQgc3R5bGUgaXQgdGhyb3VnaCBuZXcgQ1NTLFxyXG4gKiBvciBpbnNwZWN0IHRoZSByZXR1cm5lZCBwcm9wcyBmb3IgaXQgYW5kIGFkZCBlLmcuIGFuIGAuYWN0aXZlYCBjbGFzcyBmb3IgZXhpc3RpbmcgQ1NTXHJcbiAqIFxyXG4gKiBAcGFyYW0gb25DbGlja1N5bmMgXHJcbiAqIEBwYXJhbSBleGNsdWRlIFdoZXRoZXIgdGhlIHBvbHlmaWxsIHNob3VsZG4ndCBhcHBseSAoY2FuIHNwZWNpZnkgZm9yIHNwZWNpZmljIGludGVyYWN0aW9ucylcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VQcmVzczxFIGV4dGVuZHMgTm9kZT4oeyBleGNsdWRlLCBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0sIG9uQ2xpY2tTeW5jIH06IFVzZVByZXNzUGFyYW1ldGVyczxFPikge1xyXG5cclxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcclxuICAgIC8vIHRoYXQgbXVsdGlwbGUgYXJlIHRyaWdnZXJlZCBhdCBvbmNlLCB3ZSBvbmx5ICphY3R1YWxseSogcmVnaXN0ZXJcclxuICAgIC8vIGEgcHJlc3Mgb25jZSBhbGwgb2Ygb3VyIFwib25cIiBzaWduYWxzIGhhdmUgdHVybmVkIGJhY2sgdG8gXCJvZmZcIi5cclxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxyXG4gICAgLy8gZGVjcmVtZW50aW5nIHdoZW4gZGVhY3RpdmF0ZWQuXHJcbiAgICAvL1xyXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxyXG4gICAgLy8gdGhpcyBpcyByZXNldCBiYWNrIHRvIDAuXHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmUsIGdldEFjdGl2ZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlSGFzRm9jdXMoe1xyXG4gICAgICAgIC4uLmhhc0ZvY3VzLFxyXG4gICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGY6IGJvb2xlYW4sIHA6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZiwgcCk7XHJcbiAgICAgICAgICAgIGlmICghZikge1xyXG4gICAgICAgICAgICAgICAgc2V0QWN0aXZlKDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIElmIHdlIHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIGNoYW5nZXMgdG8gaW5jbHVkZSB0aGlzIGVsZW1lbnRcclxuICAgIC8vIERVUklORyBlLmcuIGEgbW91c2Vkb3duLCB0aGVuIHdlIGRvbid0IHdhbnQgdGhlIG1vdXNldXAgdG8gXCJjb3VudFwiLCBhcyBpdCB3ZXJlLFxyXG4gICAgLy8gYmVjYXVzZSBpdHMgb25seSBwdXJwb3NlIHdhcyBzZWxlY3RpbmcgdGV4dCwgbm90IGNsaWNraW5nIGJ1dHRvbnMuXHJcbiAgICAvL1xyXG4gICAgLy8gVG8gY2F0Y2ggdGhpcywgYW55IHRpbWUgdGhlIHRleHQgc2VsZWN0aW9uIGluY2x1ZGVzIHVzIHdoaWxlIGluIHRoZSBtaWRkbGVcclxuICAgIC8vIG9mIGEgY2xpY2ssIHRoaXMgZmxhZyBpcyBzZXQsIHdoaWNoIGNhbmNlbHMgdGhlIGFjdGl2YXRpb24gb2YgYSBwcmVzcy5cclxuICAgIC8vIFRoZSBmbGFnIGlzIHJlc2V0IGFueSB0aW1lIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgb3IgdGhlIGJ1dHRvbiBpc1xyXG4gICAgLy8gbm8gbG9uZ2VyIGFjdGl2ZS5cclxuICAgIGNvbnN0IFt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lLCBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lXSA9IHVzZVN0YXRlPERhdGUgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IHBzZXVkb0FjdGl2ZSA9IChhY3RpdmUgJiYgKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgPT0gbnVsbCkpO1xyXG5cclxuICAgIHVzZUdsb2JhbEhhbmRsZXIoZG9jdW1lbnQsIFwic2VsZWN0aW9uY2hhbmdlXCIsIF8gPT4ge1xyXG4gICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUocHJldiA9PiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSkgPT0gMCA/IG51bGwgOiBwcmV2ICE9IG51bGwgPyBwcmV2IDogbmV3IERhdGUoKSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChhY3RpdmUgPT0gMClcclxuICAgICAgICAgICAgc2V0VGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZShudWxsKTtcclxuXHJcbiAgICB9LCBbYWN0aXZlID09IDBdKTtcclxuXHJcbiAgICBjb25zdCBvbkFjdGl2ZVN0YXJ0ID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKF8pID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoYSA9PiArK2EpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgb25BY3RpdmVTdG9wID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKGUpID0+IHtcclxuICAgICAgICBzZXRBY3RpdmUoYSA9PiBNYXRoLm1heCgwLCAtLWEpKTtcclxuXHJcbiAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHRpbWVEaWZmZXJlbmNlID0gKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgPT0gbnVsbCA/IG51bGwgOiArY3VycmVudFRpbWUgLSArdGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSk7XHJcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyc1NlbGVjdGVkID0gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpXHJcblxyXG4gICAgICAgIC8vIElmIHdlJ3JlIHNlbGVjdGluZyB0ZXh0IChoZXVyaXN0aWNhbGx5IGRldGVybWluZWQgYnkgc2VsZWN0aW5nIGZvciBsb25nZXIgdGhhbiAxLzQgYSBzZWNvbmQsIG9yIG1vcmUgdGhhbiAyIGNoYXJhY3RlcnMpXHJcbiAgICAgICAgLy8gdGhlbiB0aGlzIGlzbid0IGEgcHJlc3MgZXZlbnQuXHJcbiAgICAgICAgLy8gVE9ETzogVGhpcyBzaG91bGQgbWVhc3VyZSBnbHlwaHMgaW5zdGVhZCBvZiBjaGFyYWN0ZXJzLlxyXG4gICAgICAgIGlmIChjaGFyYWN0ZXJzU2VsZWN0ZWQgPiAxIHx8ICgodGltZURpZmZlcmVuY2UgPz8gMCkgPiAyNTAgJiYgY2hhcmFjdGVyc1NlbGVjdGVkID49IDEpKSB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGdldEFjdGl2ZSgpIDw9IDApIHtcclxuICAgICAgICAgICAgaGFuZGxlUHJlc3MoZSk7XHJcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7ICAvLyBUT0RPOiBSZW1vdmUgd2hlbiBpc3N1ZSByZXNvbHZlZCBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2lzc3Vlcy8zNzMxXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaGFuZGxlUHJlc3MgPSB1c2VTdGFibGVDYWxsYmFjazxOb25OdWxsYWJsZTx0eXBlb2Ygb25DbGlja1N5bmM+PigoZSkgPT4ge1xyXG4gICAgICAgIGlmIChvbkNsaWNrU3luYykge1xyXG5cclxuICAgICAgICAgICAgLy8gTm90ZTogVGhlIGVsZW1lbnQgaXMgZm9jdXNlZCBoZXJlIGJlY2F1c2Ugb2YgaU9TIFNhZmFyaS5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gSXQncyBhbHdheXMgaU9TIFNhZmFyaS5cclxuICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgLy8gaU9TIFNhZmFyaSAodGVzdGVkIG9uIDEyKSBkb3ducmlnaHQgcmVmdXNlcyB0byBhbGxvdyBcclxuICAgICAgICAgICAgLy8gZWxlbWVudHMgdG8gYmUgbWFudWFsbHkgZm9jdXNlZCBVTkxFU1MgaXQgaGFwcGVucyB3aXRoaW5cclxuICAgICAgICAgICAgLy8gYW4gZXZlbnQgaGFuZGxlciBsaWtlIHRoaXMuICBJdCBhbHNvIGRvZXNuJ3QgZm9jdXNcclxuICAgICAgICAgICAgLy8gYnV0dG9ucyBieSBkZWZhdWx0IHdoZW4gY2xpY2tlZCwgdGFwcGVkLCBldGMuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIElmIGl0IGJlY29tZXMgcHJvYmxlbWF0aWMgdGhhdCBidXR0b24tbGlrZXMgZXhwbGljaXRseSBiZWNvbWVcclxuICAgICAgICAgICAgLy8gZm9jdXNlZCB3aGVuIHRoZXkgYXJlIHByZXNzZWQsIHRoZW4gYW4gYWx0ZXJuYXRpdmUgc29sdXRpb24gZm9yXHJcbiAgICAgICAgICAgIC8vIHRoZSBxdWVzdGlvbiBvZiBcImhvdyBkbyBtZW51IGJ1dHRvbnMga2VlcCB0aGVpciBtZW51cyBvcGVuXCJcclxuICAgICAgICAgICAgLy8gYW5kIG90aGVyIGZvY3VzLXJlbGF0ZWQgbm9uc2Vuc2UgbmVlZHMgdG8gYmUgZmlndXJlZCBvdXQuXHJcbiAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgIC8vIEZvciBpT1MgU2FmYXJpLlxyXG4gICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBcImZvY3VzXCIgaW4gKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQpKVxyXG4gICAgICAgICAgICAgICAgKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXMoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFdoYXRldmVyIHRoZSBicm93c2VyIHdhcyBnb2luZyB0byBkbyB3aXRoIHRoaXMgZXZlbnQsXHJcbiAgICAgICAgICAgIC8vIGZvcmdldCBpdC4gV2UncmUgdHVybmluZyBpdCBpbnRvIGEgXCJwcmVzc1wiIGV2ZW50LlxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBBbHNvIHN0b3AgYW55b25lIGVsc2UgZnJvbSBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCxcclxuICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgZXhwbGljaXRseSBoYW5kbGluZyBpdC5cclxuICAgICAgICAgICAgLy8gKE5vdGFibHksIHRoaXMgYWxsb3dzIGxhYmVscyB0byB3cmFwIGlucHV0cywgd2l0aCB0aGVtXHJcbiAgICAgICAgICAgIC8vIGJvdGggaGF2aW5nIHByZXNzIGV2ZW50IGhhbmRsZXJzLCB3aXRob3V0IGRvdWJsZS1maXJpbmcpXHJcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblxyXG4gICAgICAgICAgICAvLyBIYXB0aWMgZmVlZGJhY2sgZm9yIHRoaXMgcHJlc3MgZXZlbnRcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdGhyb3csXHJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIGd1YXJkIGFnYWluc3QgdXNlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBjb3VsZC5cclxuICAgICAgICAgICAgICAgIHB1bHNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAvLyBBY3R1YWxseSBjYWxsIG91ciBoYW5kbGVyLlxyXG4gICAgICAgICAgICAgICAgb25DbGlja1N5bmMoZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qgb25Nb3VzZURvd24gPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIC8vIFN0b3AgZG91YmxlIGNsaWNrcyBmcm9tIHNlbGVjdGluZyB0ZXh0IGluIGFuIGNvbXBvbmVudCB0aGF0J3MgKnN1cHBvc2VkKiB0byBiZSBhY3RpbmcgbGlrZSBhIGJ1dHRvbixcclxuICAgICAgICAvLyBidXQgYWxzbyBkb24ndCBwcmV2ZW50IHRoZSB1c2VyIGZyb20gc2VsZWN0aW5nIHRoYXQgdGV4dCBtYW51YWxseSBpZiB0aGV5IHJlYWxseSB3YW50IHRvXHJcbiAgICAgICAgLy8gKHdoaWNoIHVzZXItc2VsZWN0OiBub25lIHdvdWxkIGRvLCBidXQgY2FuY2VsbGluZyBhIGRvdWJsZSBjbGljayBvbiBtb3VzZURvd24gZG9lc24ndClcclxuICAgICAgICBpZiAoZS5kZXRhaWwgPiAxKVxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG5cclxuICAgICAgICBpZiAoZS5idXR0b24gPT09IDApXHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvbk1vdXNlVXAgPSBleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpID8gdW5kZWZpbmVkIDogKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xyXG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBhY3RpdmUgPiAwKVxyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XHJcbiAgICB9O1xyXG5cclxuXHJcbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKCFleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpKVxyXG4gICAgICAgICAgICBzZXRBY3RpdmUoMCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBvbktleURvd24gPSBleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpICYmIGV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmIG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKSB7XHJcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGFjdGl2YXRlIGl0IG9uIGEgc3BhY2Uga2V5ZG93blxyXG4gICAgICAgICAgICAvLyBidXQgd2UgZG8gcHJldmVudERlZmF1bHQgdG8gc3RvcCB0aGUgcGFnZSBmcm9tIHNjcm9sbGluZy5cclxuICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKGUua2V5ID09IFwiRW50ZXJcIiAmJiAhZXhjbHVkZXMoXCJlbnRlclwiLCBleGNsdWRlKSkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RhcnQoZSk7XHJcbiAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25LZXlVcCA9IGV4Y2x1ZGVzKFwic3BhY2VcIiwgZXhjbHVkZSkgPyB1bmRlZmluZWQgOiAoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XHJcbiAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKVxyXG4gICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qgb25DbGljayA9IChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xyXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlUHJlc3NQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pIHtcclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4ocHJvcHMsIHVzZUhhc0ZvY3VzUHJvcHMoKHtcclxuICAgICAgICAgICAgb25LZXlEb3duLFxyXG4gICAgICAgICAgICBvbktleVVwLFxyXG4gICAgICAgICAgICBvbk1vdXNlRG93bixcclxuICAgICAgICAgICAgb25Nb3VzZVVwLFxyXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUsXHJcbiAgICAgICAgICAgIG9uQ2xpY2ssXHJcbiAgICAgICAgICAgIHN0eWxlOiAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSAhPSBudWxsKSA/IHsgY3Vyc29yOiBcInRleHRcIiB9IDogdW5kZWZpbmVkLFxyXG4gICAgICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cclxuICAgICAgICB9KSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSBkb2Vzbid0IGFjY291bnQgZm9yIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCxcclxuICogc28gaGVyZSdzIGEgd29ya2Fyb3VuZCBmb3IgdGhhdC5cclxuICogXHJcbiAqIFdlIGFsc28gb25seSBsb29rIGZvciB0aGUgc2VsZWN0aW9uIGVuZCB0byBvbmx5IGNhdGNoIHRoZSBcclxuICogZXNzZW5zZSBvZiBhIG5vbi1leGlzdGFudCBcInNlbGVjdGlvbnN0b3BcIiBldmVudC5cclxuICogXHJcbiAqIEBwYXJhbSBlbGVtZW50IFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmZ1bmN0aW9uIG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50IGluc3RhbmNlb2YgTm9kZSkge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcclxuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAoc2VsZWN0aW9uPy5yYW5nZUNvdW50ID8/IDApOyArK2kpIHtcclxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24hLmdldFJhbmdlQXQoaSkhO1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uIS50b1N0cmluZygpLmxlbmd0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gMDtcclxufVxyXG5cclxuXHJcbmxldCBwdWxzZSA9ICgoXCJ2aWJyYXRlXCIgaW4gbmF2aWdhdG9yKSAmJiAobmF2aWdhdG9yLnZpYnJhdGUgaW5zdGFuY2VvZiBGdW5jdGlvbikpID8gKCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKSkgOiAoKCkgPT4geyB9KTtcclxuXHJcbi8qKlxyXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSB1c2VkIHRvIGVuYWJsZS9kaXNhYmxlIGJ1dHRvbiB2aWJyYXRpb24gcHVsc2VzIG9uIGFuIGFwcC13aWRlIHNjYWxlLlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBmdW5jIFRoZSBmdW5jdGlvbiB0byBydW4gd2hlbiBhIGJ1dHRvbiBpcyB0YXBwZWQuXHJcbiAqIChEZWZhdWx0IGlzIGAoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMClgIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBpdCwgYSBub29wIG90aGVyd2lzZSlcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRQcmVzc1ZpYnJhdGUoZnVuYzogKCkgPT4gdm9pZCkge1xyXG4gICAgcHVsc2UgPSBmdW5jO1xyXG59XHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIGV4Y2x1ZGVzKHRhcmdldDogXCJjbGlja1wiIHwgXCJzcGFjZVwiIHwgXCJlbnRlclwiLCBleGNsdWRlOiB1bmRlZmluZWQgfCB7IGNsaWNrPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIHNwYWNlPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQsIGVudGVyPzogXCJleGNsdWRlXCIgfCB1bmRlZmluZWQgfSkge1xyXG4gICAgaWYgKGV4Y2x1ZGU/Llt0YXJnZXRdKVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgRWxlbWVudFNpemUsIHVzZUVsZW1lbnRTaXplIH0gZnJvbSBcIi4vdXNlLWVsZW1lbnQtc2l6ZVwiO1xyXG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuXHJcbi8vZXhwb3J0IHR5cGUgQmxvY2tGbG93RGlyZWN0aW9uID0gXCJkb3dud2FyZHNcIiB8IFwibGVmdHdhcmRzXCIgfCBcInJpZ2h0d2FyZHNcIjtcclxuZXhwb3J0IHR5cGUgUGh5c2ljYWxEaXJlY3Rpb24gPSBcImx0clwiIHwgXCJydGxcIiB8IFwidHRiXCIgfCBcImJ0dFwiO1xyXG5leHBvcnQgdHlwZSBQaHlzaWNhbE9yaWVudGF0aW9uID0gXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCI7XHJcbmV4cG9ydCB0eXBlIFBoeXNpY2FsU2l6ZSA9IFwid2lkdGhcIiB8IFwiaGVpZ2h0XCI7XHJcblxyXG5leHBvcnQgdHlwZSBMb2dpY2FsT3JpZW50YXRpb24gPSBcImlubGluZVwiIHwgXCJibG9ja1wiO1xyXG5cclxuLy9leHBvcnQgdHlwZSBMaW5lT3JpZW50YXRpb24gPSBcInVwcmlnaHRcIiB8IFwibGVmdHJpZ2h0XCIgfCBcImRvd25yaWdodFwiIHwgXCJyaWdodHJpZ2h0XCI7XHJcblxyXG50eXBlIFdyaXRpbmdNb2RlID0gXCJob3Jpem9udGFsLXRiXCIgfCBcInZlcnRpY2FsLWxyXCIgfCBcInNpZGV3YXlzLXJsXCIgfCBcInZlcnRpY2FsLXJsXCIgfCBcInNpZGV3YXlzLWxyXCI7XHJcbnR5cGUgRGlyZWN0aW9uID0gXCJsdHJcIiB8IFwicnRsXCI7XHJcbnR5cGUgVGV4dE9yaWVudGF0aW9uID0gXCJtaXhlZFwiIHwgXCJ1cHJpZ2h0XCIgfCBcInNpZGV3YXlzXCI7XHJcblxyXG5mdW5jdGlvbiBjYXBpdGFsaXplPFQgZXh0ZW5kcyBzdHJpbmc+KHN0cjogVCk6IENhcGl0YWxpemU8VD4ge1xyXG4gICAgcmV0dXJuIChzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSkpIGFzIENhcGl0YWxpemU8VD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTG9naWNhbERpcmVjdGlvblBhcmFtZXRlcnMge1xyXG4gICAgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlPyhpbmZvOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwpOiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIExvZ2ljYWxFbGVtZW50U2l6ZSB7XHJcbiAgICBjbGllbnRJbmxpbmVTaXplOiBudW1iZXI7XHJcbiAgICBzY3JvbGxJbmxpbmVTaXplOiBudW1iZXI7XHJcbiAgICBvZmZzZXRJbmxpbmVTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBjbGllbnRCbG9ja1NpemU6IG51bWJlcjtcclxuICAgIHNjcm9sbEJsb2NrU2l6ZTogbnVtYmVyO1xyXG4gICAgb2Zmc2V0QmxvY2tTaXplOiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBjbGllbnRJbmxpbmVJbnNldDogbnVtYmVyO1xyXG4gICAgc2Nyb2xsSW5saW5lSW5zZXQ6IG51bWJlcjtcclxuICAgIG9mZnNldElubGluZUluc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbiAgICBjbGllbnRCbG9ja0luc2V0OiBudW1iZXI7XHJcbiAgICBzY3JvbGxCbG9ja0luc2V0OiBudW1iZXI7XHJcbiAgICBvZmZzZXRCbG9ja0luc2V0OiBudW1iZXIgfCB1bmRlZmluZWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbnNwZWN0cyB0aGUgZWxlbWVudCdzIHN0eWxlIGFuZCBkZXRlcm1pbmVzIHRoZSBsb2dpY2FsIGRpcmVjdGlvbiB0aGF0IHRleHQgZmxvd3MuXHJcbiAqIFxyXG4gKiBDZXJ0YWluIENTUyBwcm9wZXJ0aWVzLCBsaWtlIGBibG9jay1zaXplYCwgcmVzcGVjdCB0aGUgY3VycmVudCB3cml0aW5nIG1vZGUgYW5kIHRleHQgZGlyZWN0aW9uLlxyXG4gKiBCdXQgYHRyYW5zZm9ybWAsIGBjbGlwYCwgZXRjLiBkb24ndC5cclxuICogXHJcbiAqIFRoaXMgaXMgcHJvdmlkZWQgc28gdGhhdCBDU1MgcHJvcGVydGllcyBjYW4gY29uc2lzdGVudGx5IHVzZSB0aG9zZSBsb2dpY2FsIHByb3BlcnRpZXMuXHJcbiAqIFxyXG4gKiBTZWUgaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy13cml0aW5nLW1vZGVzLyNsb2dpY2FsLXRvLXBoeXNpY2FsXHJcbiAqIFxyXG4gKiBAcmV0dXJucyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uczpcclxuICogKiBgZ2V0TG9naWNhbERpcmVjdGlvbmA6IHJldHJpZXZlcyBhIGBMb2dpY2FsRGlyZWN0aW9uSW5mb2AgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBlbGVtZW50LiAoRnVuY3Rpb24gaXMgY29uc3RhbnQgYmV0d2VlbiByZW5kZXJzKVxyXG4gKiAqIGBjb252ZXJ0RWxlbWVudFNpemVgOiBXaGVuIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlRWxlbWVudFNpemVgLCBhbGxvd3MgeW91IHRvIHJldHJpZXZlIHRoZSBsb2dpY2FsIHNpemUgb2YgYW4gZWxlbWVudCBpbnN0ZWFkIG9mIHRoZSBwaHlzaWNhbCBzaXplLiBcclxuICogKiBgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uYDogQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIgdG8gXCJpbmxpbmVcIiBvciBcImJsb2NrXCIuXHJcbiAqICogYGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb25gOiAgQmFzZWQgb24gdGhlIGN1cnJlbnQgZGlyZWN0aW9uLCBjb252ZXJ0cyBcImlubGluZVwiIG9yIFwiYmxvY2tcIiB0byBcImhvcml6b250YWxcIiBvciBcInZlcnRpY2FsXCIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9naWNhbERpcmVjdGlvbjxUIGV4dGVuZHMgRWxlbWVudD4oeyBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UgfTogVXNlTG9naWNhbERpcmVjdGlvblBhcmFtZXRlcnMpOiBVc2VMb2dpY2FsRGlyZWN0aW9uUmV0dXJuVHlwZTxUPiB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTG9naWNhbERpcmVjdGlvblwiLCBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UpO1xyXG5cclxuICAgIGNvbnN0IFtnZXRDb21wdXRlZFN0eWxlcywgc2V0Q29tcHV0ZWRTdHlsZXNdID0gdXNlUGFzc2l2ZVN0YXRlPENTU1N0eWxlRGVjbGFyYXRpb24gfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcclxuXHJcblxyXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VSZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8VD4oe1xyXG4gICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGVsZW1lbnQ6IFQgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDb21wdXRlZFN0eWxlcyh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSlcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFRPRE86IFRoZXJlJ3Mgbm8gd2F5IHRvIHJlZnJlc2ggd2hpY2ggd3JpdGluZyBtb2RlIHdlIGhhdmUgb25jZSBtb3VudGVkLlxyXG4gICAgLy8gICBBLiBUaGVyZSdzIG5vIHdheSB0byB3YXRjaCBmb3IgQ1NTIHN0eWxlIGNoYW5nZXNcclxuICAgIC8vICAgQi4gQ2FsbGluZyBnZXRDb21wdXRlZFN0eWxlIGFmdGVyIGV2ZXJ5IHJlbmRlciBmb3IgZXZlcnkgZWxlbWVudCBnZXRzIGV4cGVuc2l2ZSBmYXN0IGFuZFxyXG4gICAgLy8gICBDLiBJcyBub3QgbmVjZXNzYXJ5IGZvciBtb3N0IHVzZSBjYXNlcyB0aGF0IHdpbGwgbmV2ZXIgc3dpdGNoIHdyaXRpbmctbW9kZSB3aXRoaW4gYSBzaW5nbGUgY29tcG9uZW50XHJcbiAgICAvLyAgICAgIChUaG9zZSB0aGF0IGRvIHdpbGwgbmVlZCB0byBtb3VudCBhbmQgdW5tb3VudCB0aGUgY29tcG9uZW50IHRoYXQgdXNlcyBpdClcclxuICAgIC8vXHJcbiAgICAvLyBBcyBhIHNvbHV0aW9uLCBoZXJlJ3MgYSBjaGVhcCB3b3JrYXJvdW5kIHRoYXQgY2hlY2tzIHdoZW4gdGhlIGVsZW1lbnQncyBzaXplIGhhcyBjaGFuZ2VkLFxyXG4gICAgLy8gYW5kIGlmIHNvLCB0ZXN0cyBpZiB0aGUgd3JpdGluZyBtb2RlIGhhcyBjaGFuZ2VkIHRvby5cclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIHdpbGwgd29yayBmb3IgYXQgbGVhc3Qgc29tZSBudW1iZXIgb2YgY2FzZXMsIGJ1dCBhIGJldHRlciBzb2x1dGlvbiBpcyBzdGlsbCBuZWVkZWQuXHJcbiAgICBjb25zdCB7IHVzZUVsZW1lbnRTaXplUHJvcHMgfSA9IHVzZUVsZW1lbnRTaXplPFQ+KHsgb25TaXplQ2hhbmdlOiB1c2VDYWxsYmFjayhfID0+IG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8uKGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCkpLCBbXSkgfSlcclxuXHJcbiAgICBjb25zdCBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGVzKCk7XHJcbiAgICAgICAgaWYgKGNvbXB1dGVkU3R5bGVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHcgPSBjb21wdXRlZFN0eWxlcy53cml0aW5nTW9kZSBhcyBXcml0aW5nTW9kZTtcclxuICAgICAgICAgICAgbGV0IGQgPSBjb21wdXRlZFN0eWxlcy5kaXJlY3Rpb24gYXMgRGlyZWN0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCB0ID0gY29tcHV0ZWRTdHlsZXMudGV4dE9yaWVudGF0aW9uIGFzIFRleHRPcmllbnRhdGlvbjtcclxuXHJcbiAgICAgICAgICAgIGlmICh0ID09IFwidXByaWdodFwiKVxyXG4gICAgICAgICAgICAgICAgZCA9IFwibHRyXCI7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gKHsgLi4uV3JpdGluZ01vZGVzW3cgfHwgXCJob3Jpem9udGFsLXRiXCJdW2QgfHwgXCJsdHJcIl0gfSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIC8vY29uc3QgW2dldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCBzZXRMb2dpY2FsRGlyZWN0aW9uSW5mb10gPSB1c2VQYXNzaXZlU3RhdGU8TG9naWNhbERpcmVjdGlvbkluZm8+KG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZSk7XHJcblxyXG4gICAgY29uc3QgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBlbGVtZW50T3JpZW50YXRpb24pXHJcbiAgICAgICAgICAgIHJldHVybiBcImlubGluZVwiO1xyXG4gICAgICAgIHJldHVybiBcImJsb2NrXCI7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxTaWRlID0gdXNlQ2FsbGJhY2soKHNpZGU6IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIsIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCk6IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCIgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcclxuXHJcbiAgICAgICAgc3dpdGNoIChzaWRlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJibG9jay1zdGFydFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIilbMF0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stZW5kXCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5ibG9ja0RpcmVjdGlvbiA/PyBcInR0YlwiKVsyXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XHJcblxyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLXN0YXJ0XCI6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gTVsoZGlyZWN0aW9uPy5pbmxpbmVEaXJlY3Rpb24gPz8gXCJsdHJcIilbMF0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xyXG4gICAgICAgICAgICBjYXNlIFwiaW5saW5lLWVuZFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzJdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCBjb252ZXJ0VG9Mb2dpY2FsU2lkZSA9IHVzZUNhbGxiYWNrKChzaWRlOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIikge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHNpZGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJib3R0b21cIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJidHRcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwibHRyXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInJpZ2h0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJ0dGJcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5ibG9ja0RpcmVjdGlvbiA9PT0gXCJidHRcIiA/IFwiYmxvY2stc3RhcnRcIiA6IFwiYmxvY2stZW5kXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJsdHJcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uaW5saW5lRGlyZWN0aW9uID09PSBcInJ0bFwiID8gXCJpbmxpbmUtc3RhcnRcIiA6IFwiaW5saW5lLWVuZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlKTtcclxuICAgICAgICByZXR1cm4gXCJpbmxpbmUtc3RhcnRcIjtcclxuXHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICBjb25zdCBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XHJcbiAgICAgICAgaWYgKGVsZW1lbnRPcmllbnRhdGlvbiA9PSBcImlubGluZVwiKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09IFwiaG9yaXpvbnRhbFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvbj8uYmxvY2tPcmllbnRhdGlvbiA9PSBcInZlcnRpY2FsXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJ2ZXJ0aWNhbFwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIFwiaG9yaXpvbnRhbFwiO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCBjb252ZXJ0RWxlbWVudFNpemUgPSB1c2VDYWxsYmFjaygoZWxlbWVudFNpemU6IEVsZW1lbnRTaXplLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBMb2dpY2FsRWxlbWVudFNpemUgfCBudWxsID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XHJcbiAgICAgICAgaWYgKGRpcmVjdGlvbikge1xyXG4gICAgICAgICAgICBjb25zdCB7IGlubGluZVNpemUsIGJsb2NrU2l6ZSwgaW5saW5lRGlyZWN0aW9uLCBibG9ja0RpcmVjdGlvbiB9ID0gZGlyZWN0aW9uO1xyXG5cclxuICAgICAgICAgICAgLy8gU2l6ZSBpcyByZWxhdGl2ZWx5IHNpbXBsZVxyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50QmxvY2tTaXplID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgICAgICBjb25zdCBmMSA9IGdldFBoeXNpY2FsTGVmdFRvcChpbmxpbmVEaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBjb25zdCBmMiA9IGdldFBoeXNpY2FsUmlnaHRCb3R0b20oaW5saW5lRGlyZWN0aW9uKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGYzID0gZ2V0UGh5c2ljYWxMZWZ0VG9wKGJsb2NrRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgZjQgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGJsb2NrRGlyZWN0aW9uKTtcclxuXHJcblxyXG4gICAgICAgICAgIGNvbnN0IGNsaWVudElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMSl9YF0gKyAoIWYyID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjIpfWBdKTtcclxuICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYyKX1gXSk7XHJcbiAgICAgICAgICAgY29uc3Qgb2Zmc2V0SW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYxKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0hICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYyKX1gXSEpKTtcclxuXHJcblxyXG4gICAgICAgICAgICBjb25zdCBjbGllbnRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYGNsaWVudCR7Y2FwaXRhbGl6ZShmMyl9YF0gKyAoIWY0ID8gMCA6IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjQpfWBdKTtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BzY3JvbGwke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGY0KX1gXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGYzKX1gXSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiAoZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0hICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGY0KX1gXSEpKTtcclxuXHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lU2l6ZSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbElubGluZVNpemUsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsQmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tTaXplLFxyXG4gICAgICAgICAgICAgICAgY2xpZW50SW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgICAgIG9mZnNldElubGluZUluc2V0LFxyXG4gICAgICAgICAgICAgICAgY2xpZW50QmxvY2tJbnNldCxcclxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IHVzZVJlZkVsZW1lbnRQcm9wcyh1c2VFbGVtZW50U2l6ZVByb3BzKHByb3BzKSksIFtdKSxcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvLFxyXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiBjb252ZXJ0RWxlbWVudFNpemUsXHJcbiAgICAgICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uLFxyXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb24sXHJcbiAgICAgICAgY29udmVydFRvTG9naWNhbFNpZGUsXHJcbiAgICAgICAgY29udmVydFRvUGh5c2ljYWxTaWRlXHJcbiAgICB9O1xyXG59XHJcblxyXG4vLyBQb3NpdGlvbiByZXF1aXJlcyB1cyB0byBzb21ldGltZXMgdXNlIG9uZSBwcm9wZXJ0eSAobGlrZSBgbGVmdGApXHJcbi8vIG9yIHNvbWV0aW1lcyB0d28gKGxpa2UgYGxlZnRgICsgYHdpZHRoYClcclxuZnVuY3Rpb24gZ2V0UGh5c2ljYWxMZWZ0VG9wKGRpcjogUGh5c2ljYWxEaXJlY3Rpb24pIHsgaWYgKGRpciA9PT0gXCJsdHJcIiB8fCBkaXIgPT0gXCJydGxcIikgcmV0dXJuIFwibGVmdFwiOyByZXR1cm4gXCJ0b3BcIjsgfVxyXG5mdW5jdGlvbiBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGRpcjogUGh5c2ljYWxEaXJlY3Rpb24pIHsgaWYgKGRpciA9PT0gXCJydGxcIikgcmV0dXJuIFwid2lkdGhcIjsgaWYgKGRpciA9PT0gXCJidHRcIikgcmV0dXJuIFwiaGVpZ2h0XCI7IHJldHVybiBudWxsOyB9XHJcblxyXG4vLyBIZWxwZXIgZm9yIGV4dHJhY3RpbmcgaW5mbyBmcm9tIFwibHRyXCIsIFwidHRiXCIsIGV0Yy5cclxuY29uc3QgTSA9IHtcclxuICAgIHQ6IFwidG9wXCIsXHJcbiAgICBiOiBcImJvdHRvbVwiLFxyXG4gICAgbDogXCJsZWZ0XCIsXHJcbiAgICByOiBcInJpZ2h0XCJcclxufSBhcyBjb25zdDtcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvZ2ljYWxEaXJlY3Rpb25SZXR1cm5UeXBlPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0RWxlbWVudDogKCkgPT4gVCB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0TG9naWNhbERpcmVjdGlvbkluZm86ICgpID0+IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIHRoZSBFbGVtZW50U2l6ZSBpbmZvIGZyb20gdXNlRWxlbWVudFNpemUsIGNvbnZlcnRzIGFsbCB0aG9zZSBwaHlzaWNhbCBwcm9wZXJ0aWVzIHRvIHRoZWlyIGxvZ2ljYWwgY291bnRlcnBhcnRzLlxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb0xvZ2ljYWxTaXplOiAoZWxlbWVudFNpemU6IEVsZW1lbnRTaXplLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IExvZ2ljYWxFbGVtZW50U2l6ZSB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJucyBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgIGludG8gYFwiaW5saW5lXCIgfCBcImJsb2NrXCJgXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgY29udmVydFRvTG9naWNhbE9yaWVudGF0aW9uOiAoZWxlbWVudE9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lXCIgfCBcImJsb2NrXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJucyBgXCJpbmxpbmVcIiB8IFwiYmxvY2tcImAgaW50byBgXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCJgXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbjogKGVsZW1lbnRPcmllbnRhdGlvbjogTG9naWNhbE9yaWVudGF0aW9uLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybnMgYFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCJgIGludG8gYFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgfCBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCJgXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgY29udmVydFRvTG9naWNhbFNpZGU6IChzaWRlOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcIiB8IFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJucyBgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiB8IFwiaW5saW5lLXN0YXJ0XCIgfCBcImlubGluZS1lbmRcImAgaW50byBgXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcImBcclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9QaHlzaWNhbFNpZGU6IChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpID0+IFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCI7XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2dpY2FsRGlyZWN0aW9uSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBnbHlwaCBieSBnbHlwaC4gIEJ5IGZhciB0aGUgbW9zdCBjb21wbGV4IHByb3BlcnR5LlxyXG4gICAgICogXHJcbiAgICAgKiB8YHdyaXRpbmctbW9kZWB8YGRpcmVjdGlvbmB8UmVzdWx0fFxyXG4gICAgICogfC0tLS0tfC0tLS0tfC0tLS0tfFxyXG4gICAgICogfGBob3Jpem9udGFsLXRiYHxgbHRyYHxgbHRyYHxcclxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YHJ0bGB8YHJ0bGB8XHJcbiAgICAgKiB8YHZlcnRpY2FsLXJsYCAmIGBzaWRld2F5cy1ybGB8YGx0cmB8YHR0YmB8XHJcbiAgICAgKiB8YHZlcnRpY2FsLXJsYCAmIGBzaWRld2F5cy1ybGB8YHJ0bGB8YGJ0dGB8XHJcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgbHRyYHxgdHRiYHxcclxuICAgICAqIHxgdmVydGljYWwtbHJgfGBydGxgfGBidHRgfFxyXG4gICAgICogfGBzaWRld2F5cy1scmB8YGx0cmB8YGJ0dGB8XHJcbiAgICAgKiB8YHNpZGV3YXlzLWxyYHxgcnRsYHxgdHRiYHxcclxuICAgICAqL1xyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgaW5saW5lRGlyZWN0aW9uYDpcclxuICAgICAqIFxyXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGBob3Jpem9udGFsLXRiYFxyXG4gICAgICogKiBgdmVydGljYWxgIGZvciBhbGwgb3RoZXJzXHJcbiAgICAgKi9cclxuICAgIGlubGluZU9yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyB0aGUgZGlyZWN0aW9uIHRleHQgZmxvd3MsIGxpbmUgYnkgbGluZS5cclxuICAgICAqIFxyXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxyXG4gICAgICogKiBgcnRsYCBmb3IgYHZlcnRpY2FsLXJsYCAmIGBzaWRld2F5cy1ybGAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXHJcbiAgICAgKiAqIGBsdHJgIGZvciBgdmVydGljYWwtbHJgICYgYHNpZGV3YXlzLWxyYCwgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgYmxvY2tEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltcGxpZmllZCB2ZXJzaW9uIG9mIGBibG9ja0RpcmVjdGlvbmA6XHJcbiAgICAgKiBcclxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYGhvcml6b250YWwtdGJgXHJcbiAgICAgKiAqIGBob3Jpem9udGFsYCBmb3IgYWxsIG90aGVyc1xyXG4gICAgICovXHJcbiAgICBibG9ja09yaWVudGF0aW9uOiBQaHlzaWNhbE9yaWVudGF0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICppbmxpbmUqIHNpemUuXHJcbiAgICAgKiBcclxuICAgICAqICogYHdpZHRoYCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxyXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYWxsIG90aGVyc1xyXG4gICAgICovXHJcbiAgICBpbmxpbmVTaXplOiBQaHlzaWNhbFNpemU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGhvdyB5b3UgY2FuICpwaHlzaWNhbGx5KiByZWZlciB0byB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCBpbiB0aGUgKmJsb2NrKiBzaXplLlxyXG4gICAgICogXHJcbiAgICAgKiAqIGBoZWlnaHRgIGZvciBgaG9yaXpvbnRhbC10YmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXHJcbiAgICAgKiAqIGB3aWR0aGAgZm9yIGFsbCBvdGhlcnNcclxuICAgICAqL1xyXG4gICAgYmxvY2tTaXplOiBQaHlzaWNhbFNpemU7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBGb3IgZWFjaCBnbHlwaCwgYXNjZW5kZXJzIHRvIGRlc2NlbmRlcnMgKnBoeXNpY2FsbHkqIGdvOlxyXG4gICAgICogXHJcbiAgICAgKiAqIGB0dGJgIGZvciBgaG9yaXpvbnRhbC10YmBcclxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxyXG4gICAgICogKiBgbHRyYCBmb3IgYHNpZGV3YXlzLWxyYFxyXG4gICAgICovXHJcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGl0cyBcImxlZnRcIiBzaWRlICh0aGluayBvZiB0aGlzIHJlbGF0aXZlIHRvIGB3cml0aW5nLW1vZGVgIGJ1dCAqbm90KiByZWxhdGl2ZSB0byBgZGlyZWN0aW9uYCwgb3IgYWx0ZXJuYXRpdmVseSB3aGF0IGB0ZXh0LWFsaWduOiBsZWZ0YCBtZWFucykgdG8gaXRzIFwicmlnaHRcIiBzaWRlICpwaHlzaWNhbGx5KiBnb2VzIGZyb206XHJcbiAgICAgKiBcclxuICAgICAqICogYGx0cmAgZm9yIGBob3Jpem9udGFsLXRiYFxyXG4gICAgICogKiBgdHRiYCBmb3IgYHZlcnRpY2FsLXJsYCwgYHZlcnRpY2FsLWxyYCwgJiBgc2lkZXdheXMtcmxgXHJcbiAgICAgKiAqIGBidHRgIGZvciBgc2lkZXdheXMtbHJgXHJcbiAgICAgKi9cclxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogUGh5c2ljYWxEaXJlY3Rpb247XHJcbn1cclxuXHJcbmNvbnN0IEhvcml6b250YWxUYkx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwibHRyXCIsXHJcbiAgICBibG9ja0RpcmVjdGlvbjogXCJ0dGJcIixcclxuXHJcbiAgICBpbmxpbmVPcmllbnRhdGlvbjogXCJob3Jpem9udGFsXCIsXHJcbiAgICBibG9ja09yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXHJcblxyXG4gICAgaW5saW5lU2l6ZTogXCJ3aWR0aFwiLFxyXG4gICAgYmxvY2tTaXplOiBcImhlaWdodFwiLFxyXG5cclxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJsdHJcIixcclxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJ0dGJcIlxyXG59O1xyXG5cclxuY29uc3QgSG9yaXpvbnRhbFRiUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIC4uLkhvcml6b250YWxUYkx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJydGxcIixcclxufTtcclxuXHJcbmNvbnN0IFZlcnRpY2FsUmxMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwicnRsXCIsXHJcblxyXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwidmVydGljYWxcIixcclxuICAgIGJsb2NrT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG5cclxuICAgIGlubGluZVNpemU6IFwiaGVpZ2h0XCIsXHJcbiAgICBibG9ja1NpemU6IFwid2lkdGhcIixcclxuXHJcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwidHRiXCIsXHJcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwicnRsXCJcclxufTtcclxuXHJcbmNvbnN0IFZlcnRpY2FsUmxSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgLi4uVmVydGljYWxSbEx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIlxyXG59O1xyXG5cclxuXHJcbmNvbnN0IFNpZGV3YXlzUmxMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0geyAuLi5WZXJ0aWNhbFJsTHRyIH07XHJcbmNvbnN0IFNpZGV3YXlzUmxSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0geyAuLi5WZXJ0aWNhbFJsUnRsIH07XHJcblxyXG5jb25zdCBWZXJ0aWNhbExyTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIC4uLlZlcnRpY2FsUmxMdHIsXHJcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcclxufTtcclxuXHJcbmNvbnN0IFZlcnRpY2FsTHJSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgLi4uVmVydGljYWxSbFJ0bCxcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcImx0clwiLFxyXG59O1xyXG5cclxuY29uc3QgU2lkZXdheXNMdEx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICAuLi5WZXJ0aWNhbExyTHRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImJ0dFwiLFxyXG5cclxuICAgIGxlZnRSaWdodERpcmVjdGlvbjogXCJidHRcIixcclxuICAgIG92ZXJVbmRlckRpcmVjdGlvbjogXCJsdHJcIlxyXG59O1xyXG5cclxuY29uc3QgU2lkZXdheXNMdFJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICAuLi5TaWRld2F5c0x0THRyLFxyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcInR0YlwiXHJcbn07XHJcblxyXG5cclxuXHJcbmNvbnN0IEhvcml6b250YWxUYiA9IHtcclxuICAgIGx0cjogSG9yaXpvbnRhbFRiTHRyLFxyXG4gICAgcnRsOiBIb3Jpem9udGFsVGJSdGxcclxufSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IFZlcnRpY2FsUmwgPSB7XHJcbiAgICBsdHI6IFZlcnRpY2FsUmxMdHIsXHJcbiAgICBydGw6IFZlcnRpY2FsUmxSdGxcclxufSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IFZlcnRpY2FsTHIgPSB7XHJcbiAgICBsdHI6IFZlcnRpY2FsTHJMdHIsXHJcbiAgICBydGw6IFZlcnRpY2FsTHJSdGxcclxufSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IFNpZGV3YXlzUmwgPSB7XHJcbiAgICBsdHI6IFNpZGV3YXlzUmxMdHIsXHJcbiAgICBydGw6IFNpZGV3YXlzUmxSdGxcclxufSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IFNpZGV3YXlzTHIgPSB7XHJcbiAgICBsdHI6IFNpZGV3YXlzTHRMdHIsXHJcbiAgICBydGw6IFNpZGV3YXlzTHRSdGxcclxufSBhcyBjb25zdDtcclxuXHJcbmNvbnN0IFdyaXRpbmdNb2RlcyA9IHtcclxuICAgIFwiaG9yaXpvbnRhbC10YlwiOiBIb3Jpem9udGFsVGIsXHJcbiAgICBcInZlcnRpY2FsLWxyXCI6IFZlcnRpY2FsTHIsXHJcbiAgICBcInZlcnRpY2FsLXJsXCI6IFZlcnRpY2FsUmwsXHJcbiAgICBcInNpZGV3YXlzLWxyXCI6IFNpZGV3YXlzTHIsXHJcbiAgICBcInNpZGV3YXlzLXJsXCI6IFNpZGV3YXlzUmxcclxufSBhcyBjb25zdDtcclxuIiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVRpbWVvdXQge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC4gIFxuICAgICAqIElmIGBudWxsYCwgY2FuY2VscyB0aGUgdGltZW91dCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0byB0aGlzIHByb3AgYmV0d2VlbiByZW5kZXJzIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBjdXJyZW50IHRpbWVvdXQgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdHJpZ2dlckluZGV4PzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKiBcbiAgICAgKiBEb2VzICpub3QqIG5lZWQgdG8gYmUgc3RhYmxlLiBHbyBhaGVhZCBhbmQgcGFzcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9OiBVc2VUaW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7IHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gbnVsbDsgY2FsbGJhY2soKTsgfSk7XG4gICAgY29uc3QgZ2V0VGltZW91dCA9IHVzZVN0YWJsZUdldHRlcih0aW1lb3V0KTtcblxuICAgIC8vIFNldCBhbnkgdGltZSB3ZSBzdGFydCB0aW1lb3V0LlxuICAgIC8vIFVuc2V0IGFueSB0aW1lIHRoZSB0aW1lb3V0IGNvbXBsZXRlc1xuICAgIGNvbnN0IHN0YXJ0VGltZVJlZiA9IHVzZVJlZjxudW1iZXIgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IHRpbWVvdXRJc051bGwgPSAodGltZW91dCA9PSBudWxsKTtcblxuICAgIC8vIEFueSB0aW1lIHRoZSB0cmlnZ2VySW5kZXggY2hhbmdlcyAoaW5jbHVkaW5nIG9uIG1vdW50KVxuICAgIC8vIHJlc3RhcnQgdGhlIHRpbWVvdXQuICBUaGUgdGltZW91dCBkb2VzIE5PVCByZXNldFxuICAgIC8vIHdoZW4gdGhlIGR1cmF0aW9uIG9yIGNhbGxiYWNrIGNoYW5nZXMsIG9ubHkgdHJpZ2dlckluZGV4LlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdGltZW91dElzTnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHRpbWVvdXRJc051bGwgPT0gKHRpbWVvdXQgPT0gbnVsbCkpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHRpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0VGltZVJlZi5jdXJyZW50ID0gKyhuZXcgRGF0ZSgpKTtcbiAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KHN0YWJsZUNhbGxiYWNrLCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfSwgW3RyaWdnZXJJbmRleCwgdGltZW91dElzTnVsbF0pXG5cbiAgICBjb25zdCBnZXRFbGFwc2VkVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgrKG5ldyBEYXRlKCkpKSAtICgrKHN0YXJ0VGltZVJlZi5jdXJyZW50ID8/IG5ldyBEYXRlKCkpKTtcbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRSZW1haW5pbmdUaW1lID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gZ2V0VGltZW91dCgpO1xuICAgICAgICByZXR1cm4gdGltZW91dCA9PSBudWxsID8gbnVsbCA6IE1hdGgubWF4KDAsIHRpbWVvdXQgLSBnZXRFbGFwc2VkVGltZSgpKVxuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7IGdldEVsYXBzZWRUaW1lLCBnZXRSZW1haW5pbmdUaW1lIH07XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTG9naWNhbERpcmVjdGlvbiB9IGZyb20gXCIuL3VzZS1sb2dpY2FsLWRpcmVjdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwiLi91c2UtdGltZW91dFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xyXG4gICAgbGluZWFyTmF2aWdhdGlvbjoge31cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIC8qKiBcclxuICAgICAqIFRoZXNlIHByb3BzIGNhbiBiZSBhdHRhdGNoZWQgZWl0aGVyIHRvIHRoZSBwYXJlbnQgb3IgdG8gZWFjaCBpbmRpdmlkdWFsIGNoaWxkLlxyXG4gICAgICogV2hpY2hldmVyIHdvcmtzIGJldHRlciBmb3IgeW91ciBzY2VuYXJpby5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKiBcclxuICAgICAqICovXHJcbiAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XHJcbn1cclxuXHJcbmludGVyZmFjZSBMTlAge1xyXG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcclxuICAgIG5hdmlnYXRlVG9QcmV2KCk6IHZvaWQ7XHJcbiAgICBuYXZpZ2F0ZVRvRmlyc3QoKTogdm9pZDtcclxuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIENvbnRyb2xzIHdoaWNoIGFycm93IGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgY29tcG9uZW50LlxyXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSwgc28gaW4gRW5nbGlzaCwgXCJpbmxpbmVcIiBjb3JyZXNwb25kc1xyXG4gICAgICogdG8gdGhlIGxlZnQgJiByaWdodCBhcnJvdyBrZXlzLCBhbmQgXCJibG9ja1wiIHRvIHRoZSB1cCAmIGRvd24gYXJyb3cga2V5cy5cclxuICAgICAqIFxyXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBVc2UgXCJub25lXCIgdG8gZGlzYWxsb3cgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIGluIGFueSBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24/OiBcImlubGluZVwiIHwgXCJibG9ja1wiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxyXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXHJcbiAgICAgKiBiZSB1bmFmZmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXHJcbiAgICAgKiBiZSBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlXHJcbiAgICAgKiB1bmFmZmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXM/OiBib29sZWFuO1xyXG59XHJcbmV4cG9ydCB0eXBlIExpbmVhck5hdmlnYXRpb25PbWl0cyA9IGtleW9mIExOUDtcclxuXHJcbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHM+IHtcclxuICAgIGxpbmVhck5hdmlnYXRpb246IE9taXQ8TE5QLCBPbWl0cz5cclxufVxyXG5cclxuXHJcbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkYCAqL1xyXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cclxuXHJcbi8qKlxyXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcclxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IGxpbmVhck5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0ZpcnN0OiBudGYsIG5hdmlnYXRlVG9MYXN0OiBudGwsIG5hdmlnYXRlVG9OZXh0OiBudG4sIG5hdmlnYXRlVG9QcmV2OiBudHAsIG5hdmlnYXRpb25EaXJlY3Rpb246IG5kLCBkaXNhYmxlQXJyb3dLZXlzOiBkYWssIGRpc2FibGVIb21lRW5kS2V5czogZGhlayB9IH06IFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyPik6IFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiB7XHJcblxyXG4gICAgbmQgPz89IFwiZWl0aGVyXCI7XHJcblxyXG4gICAgY29uc3QgeyBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbywgdXNlTG9naWNhbERpcmVjdGlvblByb3BzIH0gPSB1c2VMb2dpY2FsRGlyZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7fSk7XHJcblxyXG4gICAgY29uc3QgbmF2aWdhdGVUb0ZpcnN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRmKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9MYXN0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRsKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRuKTtcclxuICAgIGNvbnN0IG5hdmlnYXRlVG9QcmV2ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRwKTtcclxuICAgIGNvbnN0IGdldERpc2FibGVBcnJvd0tleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGFrKTtcclxuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihkaGVrKTtcclxuICAgIGNvbnN0IGdldE5hdmlnYXRpb25EaXJlY3Rpb24gPSB1c2VTdGFibGVHZXR0ZXIobmQpO1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPT4ge1xyXG5cclxuICAgICAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxyXG4gICAgICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmF2aWdhdGlvbkRpcmVjdGlvbiA9IGdldE5hdmlnYXRpb25EaXJlY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc2FibGVBcnJvd0tleXMgPSBnZXREaXNhYmxlQXJyb3dLZXlzKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlSG9tZUVuZEtleXMgPSBnZXREaXNhYmxlSG9tZUVuZEtleXMoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NCbG9ja05hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImJsb2NrXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c0lubGluZU5hdmlnYXRpb24gPSAobmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImlubGluZVwiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChlLmtleSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1VwXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dEb3duXCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uYmxvY2tPcmllbnRhdGlvbiA9PT0gXCJ2ZXJ0aWNhbFwiID8gXCJibG9ja0RpcmVjdGlvblwiIDogXCJpbmxpbmVEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IGFsbG93c0Jsb2NrTmF2aWdhdGlvbiA6IGFsbG93c0lubGluZU5hdmlnYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcImJ0dFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93TGVmdFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IFwiaW5saW5lRGlyZWN0aW9uXCIgOiBcImJsb2NrRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uIDogYWxsb3dzQmxvY2tOYXZpZ2F0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJydGxcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb05leHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZFwiOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHModXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duIH0sIHByb3BzKSlcclxuICAgICAgICB9LCBbXSksXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcclxuICAgICAgICBjdXJyZW50VHlwZWFoZWFkOiBzdHJpbmcgfCBudWxsO1xyXG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XHJcbiAgICAvKipcclxuICAgICAqIENhbiBiZSB1c2VkIG9uIGVpdGhlciB0aGUgcGFyZW50IG9yIGVhY2ggY2hpbGQgZWxlbWVudC5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD47XHJcblxyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZDogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPEUgZXh0ZW5kcyBFbGVtZW50PiA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlID0gdm9pZDtcclxuXHJcbmludGVyZmFjZSBUTlAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbGxhdG9yIHRvIHVzZSB3aGVuIGNvbXBhcmluZy4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdXNlcyBgbG9jYWxlQ29tcGFyZWAgYWZ0ZXIgdHJhbnNmb3JtaW5nIGVhY2ggdG8gbG93ZXJjYXNlLCB3aGljaCB3aWxsLCBhdCBiZXN0LCB3b3JrIG9rYXkgaW4gRW5nbGlzaC5cclxuICAgICAqL1xyXG4gICAgY29sbGF0b3I/OiBJbnRsLkNvbGxhdG9yO1xyXG5cclxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcclxuXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0PzogbnVtYmVyO1xyXG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcclxuICAgIHNldEluZGV4KHZhbHVlOiBudW1iZXIgfCBudWxsIHwgKChwcmV2aW91c1ZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzID0ga2V5b2YgVE5QO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cz4ge1xyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogT21pdDxUTlAsIE9taXRzPlxyXG59XHJcblxyXG4vKiogQXJndW1lbnRzIHBhc3NlZCB0byB0aGUgY2hpbGQgJ3VzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZGAgKi9cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxyXG4gICAgICogSXQgc2hvdWxkIGJlIHRoZSBzYW1lIHRleHQgY29udGVudCBhcyB3aGF0ZXZlcidzIGRpc3BsYXllZCwgaWRlYWxseS5cclxuICAgICAqL1xyXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcclxuXHJcbiAgICBpbmRleDogbnVtYmVyO1xyXG59XHJcblxyXG4vKiogVHlwZSBvZiB0aGUgY2hpbGQncyBzdWItaG9vayAqL1xyXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSAoYXJnczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycykgPT4gVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTtcclxuXHJcblxyXG4vKipcclxuICogQWxsb3dzIGZvciB0aGUgc2VsZWN0aW9uIG9mIGEgbWFuYWdlZCBjaGlsZCBieSB0eXBpbmcgdGhlIGdpdmVuIHRleHQgYXNzb2NpYXRlZCB3aXRoIGl0LlxyXG4gKiBcclxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4oeyB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGNvbGxhdG9yLCBnZXRJbmRleCwgdHlwZWFoZWFkVGltZW91dCwgc2V0SW5kZXgsIG5vVHlwZWFoZWFkIH0gfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcclxuXHJcblxyXG4gICAgLy8gRm9yIHR5cGVhaGVhZCwga2VlcCB0cmFjayBvZiB3aGF0IG91ciBjdXJyZW50IFwic2VhcmNoXCIgc3RyaW5nIGlzIChpZiB3ZSBoYXZlIG9uZSlcclxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxyXG4gICAgLy8gTmV4dCwga2VlcCBhIG1hcHBpbmcgb2YgdHlwZWFoZWFkIHZhbHVlcyB0byBpbmRpY2VzIGZvciBmYXN0ZXIgc2VhcmNoaW5nLlxyXG4gICAgLy8gQW5kLCBmb3IgdGhlIHVzZXIncyBzYWtlLCBsZXQgdGhlbSBrbm93IHdoZW4gdGhlaXIgdHlwZWFoZWFkIGNhbid0IG1hdGNoIGFueXRoaW5nIGFueW1vcmVcclxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xyXG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQ6IHR5cGVhaGVhZFRpbWVvdXQgPz8gMTAwMCwgY2FsbGJhY2s6ICgpID0+IHsgc2V0Q3VycmVudFR5cGVhaGVhZChudWxsKTsgc2V0SW52YWxpZFR5cGVhaGVhZChudWxsKTsgfSwgdHJpZ2dlckluZGV4OiBjdXJyZW50VHlwZWFoZWFkIH0pO1xyXG4gICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5mbyA9IHVzZVJlZjx7IHRleHQ6IHN0cmluZywgdW5zb3J0ZWRJbmRleDogbnVtYmVyIH1bXT4oW10pO1xyXG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgdHlwZWFoZWFkIGZvciBpbnB1dCBtZXRob2QgZWRpdG9ycyBhcyB3ZWxsXHJcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXHJcbiAgICAvLyBiZWNhdXNlIHdlJ3JlIHdhaXRpbmcgZm9yIGEgQ29tcG9zaXRpb25FbmQgZXZlbnRcclxuICAgIGNvbnN0IFssIHNldEltZUFjdGl2ZSwgZ2V0SW1lQWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuXHJcbiAgICAvLyBCZWNhdXNlIGNvbXBvc2l0aW9uIGV2ZW50cyBmaXJlICphZnRlcioga2V5ZG93biBldmVudHMgXHJcbiAgICAvLyAoYnV0IHdpdGhpbiB0aGUgc2FtZSB0YXNrLCB3aGljaCwgVE9ETywgY291bGQgYmUgYnJvd3Nlci1kZXBlbmRlbnQpLFxyXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cclxuICAgIGNvbnN0IFtuZXh0VHlwZWFoZWFkQ2hhciwgc2V0TmV4dFR5cGVhaGVhZENoYXJdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHR5cGVhaGVhZCA9PiAoKHR5cGVhaGVhZCA/PyBcIlwiKSArIG5leHRUeXBlYWhlYWRDaGFyKSk7XHJcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKG51bGwpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtuZXh0VHlwZWFoZWFkQ2hhcl0pO1xyXG5cclxuXHJcbiAgICBjb25zdCBjb21wYXJhdG9yU2hhcmVkID0gdXNlU3RhYmxlQ2FsbGJhY2soKHNhZmVMaHM6IHN0cmluZywgc2FmZVJoczogc3RyaW5nKSA9PiB7XHJcbiAgICAgICAgbGV0IGNvbXBhcmU6IG51bWJlcjtcclxuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXHJcbiAgICAgICAgLy8gQnkgbm9ybWFsaXppbmcgdGhlbSBmaXJzdCwgd2UgZW5zdXJlIHRoaXMgYnl0ZS1ieS1ieXRlIGhhbmRsaW5nIG9mIHJhdyBjaGFyYWN0ZXIgZGF0YSB3b3JrcyBvdXQgb2theS5cclxuICAgICAgICBzYWZlTGhzID0gc2FmZUxocy5ub3JtYWxpemUoXCJORkRcIik7XHJcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXHJcblxyXG4gICAgICAgIGlmIChjb2xsYXRvcilcclxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgIGNvbXBhcmUgPSBzYWZlTGhzLnRvTG93ZXJDYXNlKCkubG9jYWxlQ29tcGFyZShzYWZlUmhzLnRvTG93ZXJDYXNlKCkgPz8gXCJcIik7XHJcblxyXG4gICAgICAgIHJldHVybiBjb21wYXJlO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgaW5zZXJ0aW5nQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAobGhzIGFzIHVua25vd24gYXMgbnVtYmVyKSAtIChyaHMgYXMgdW5rbm93biBhcyBudW1iZXIpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdHlwZWFoZWFkQ29tcGFyYXRvciA9IHVzZVN0YWJsZUNhbGxiYWNrKChsaHM6IHN0cmluZywgcmhzOiB7IHRleHQ6IHN0cmluZzsgdW5zb3J0ZWRJbmRleDogbnVtYmVyOyB9KSA9PiB7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAvLyBEdXJpbmcgdHlwZWFoZWFkLCBhbGwgc3RyaW5ncyBsb25nZXIgdGhhbiBvdXJzIHNob3VsZCBiZSB0cnVuY2F0ZWRcclxuICAgICAgICAgICAgLy8gc28gdGhhdCB0aGV5J3JlIGFsbCBjb25zaWRlcmVkIGVxdWFsbHkgYnkgdGhhdCBwb2ludC5cclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dC5zdWJzdHJpbmcoMCwgbGhzLmxlbmd0aCkpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpc0Rpc2FibGVkID0gdXNlU3RhYmxlR2V0dGVyKG5vVHlwZWFoZWFkKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKHsgLi4ucHJvcHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvblN0YXJ0ID0gKF9lOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7IHNldEltZUFjdGl2ZSh0cnVlKSB9O1xyXG4gICAgICAgIGNvbnN0IG9uQ29tcG9zaXRpb25FbmQgPSAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihlLmRhdGEpO1xyXG4gICAgICAgICAgICBzZXRJbWVBY3RpdmUoZmFsc2UpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKCkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBjb25zdCBpbWVBY3RpdmUgPSBnZXRJbWVBY3RpdmUoKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGUua2V5O1xyXG5cclxuICAgICAgICAgICAgLy8gTm90IGhhbmRsZWQgYnkgdHlwZWFoZWFkIChpLmUuIGFzc3VtZSB0aGlzIGlzIGEga2V5Ym9hcmQgc2hvcnRjdXQpXHJcbiAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUgJiYgZS5rZXkgPT09IFwiQmFja3NwYWNlXCIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IHNwbGl0IFVURi0xNiBzdXJyb2dhdGVzLlxyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0ID0+IHQgPT09IG51bGwgPyBudWxsIDogWy4uLnRdLnJldmVyc2UoKS5zbGljZSgxKS5yZXZlcnNlKCkuam9pbihcIlwiKSk7XHJcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAvLyBUaGUga2V5IHByb3BlcnR5IHJlcHJlc2VudHMgdGhlIHR5cGVkIGNoYXJhY3RlciBPUiB0aGUgXCJuYW1lZCBrZXkgYXR0cmlidXRlXCIgb2YgdGhlIGtleSBwcmVzc2VkLlxyXG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIGRlZmluaXRlIHdheSB0byB0ZWxsIHRoZSBkaWZmZXJlbmNlLCBidXQgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3Nlc1xyXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gb25lLWNoYXJhY3RlciBuYW1lcywgYW5kIHRoZXJlIGFyZSBubyBub24tQVNDSUktYWxwaGEgbmFtZXMuXHJcbiAgICAgICAgICAgIC8vIFRodXMsIGFueSBvbmUtY2hhcmFjdGVyIG9yIG5vbi1BU0NJSSB2YWx1ZSBmb3IgYGtleWAgaXMgKmFsbW9zdCBjZXJ0YWlubHkqIGEgdHlwZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgICBjb25zdCBpc0NoYXJhY3RlcktleSA9IChrZXkubGVuZ3RoID09PSAxIHx8ICEvXltBLVphLXpdLy50ZXN0KGtleSkpO1xyXG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJLZXkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09IFwiIFwiICYmIChnZXRDdXJyZW50VHlwZWFoZWFkKCkgPz8gXCJcIikudHJpbSgpLmxlbmd0aCA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5pdGlhdGUgYSB0eXBlYWhlYWQsIG9ubHkgY29udGludWUgb25lLlxyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90ZTogV29uJ3QgYmUgdHJ1ZSBmb3IgdGhlIGZpcnN0IGtleWRvd25cclxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgd2lsbCBiZSBvdmVyd3JpdHRlbiBiZWZvcmUgdXNlTGF5b3V0RWZmZWN0IGlzIGNhbGxlZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoa2V5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHsgb25LZXlEb3duLCBvbkNvbXBvc2l0aW9uU3RhcnQsIG9uQ29tcG9zaXRpb25FbmQsIH0sIHByb3BzKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBIYW5kbGUgY2hhbmdlcyBpbiB0eXBlYWhlYWQgdGhhdCBjYXVzZSBjaGFuZ2VzIHRvIHRoZSB0YWJiYWJsZSBpbmRleFxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XHJcblxyXG5cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHNvcnRlZFR5cGVhaGVhZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgY3VycmVudFR5cGVhaGVhZCwgdHlwZWFoZWFkQ29tcGFyYXRvcik7XHJcblxyXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgdXNlciBoYXMgdHlwZWQgYW4gZW50cnkgdGhhdCBkb2Vzbid0IGV4aXN0IGluIHRoZSBsaXN0XHJcbiAgICAgICAgICAgICAgICAvLyAob3IgbW9yZSBzcGVjaWZpY2FsbHkgXCJmb3Igd2hpY2ggdGhlcmUgaXMgbm8gZW50cnkgdGhhdCBzdGFydHMgd2l0aCB0aGF0IGlucHV0XCIpXHJcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XHJcblxyXG4gICAgICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cclxuICAgICAgICAgICAgICAgICAgQnV0IHJvdWdobHkgaXNuJ3QgZ29vZCBlbm91Z2ggaWYgdGhlcmUgYXJlIG11bHRpcGxlIG1hdGNoZXMuXHJcbiAgICAgICAgICAgICAgICAgIFRvIGNvbnZlcnQgb3VyIHNvcnRlZCBpbmRleCB0byB0aGUgdW5zb3J0ZWQgaW5kZXggd2UgbmVlZCwgd2UgaGF2ZSB0byBmaW5kIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG5cclxuICAgICAgICAgICAgICAgICAgSW4gb3RoZXIgd29yZHMsIHRoZSBvbmx5IHdheSB0eXBlYWhlYWQgbW92ZXMgYmFja3dhcmRzIHJlbGF0aXZlIHRvIG91ciBjdXJyZW50XHJcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXHJcblxyXG4gICAgICAgICAgICAgICAgICBJdCdzIG5vdCBzcGVjaWZpZWQgaW4gV0FJLUFSSUEgd2hhdCB0byBkbyBpbiB0aGF0IGNhc2UuICBJIHN1cHBvc2Ugd3JhcCBiYWNrIHRvIHRoZSBzdGFydD9cclxuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cclxuICAgICAgICAgICAgICAgICAgQnV0IGlmIHlvdSdyZSBhbHJlYWR5IGRvaW5nIHR5cGVhaGVhZCBvbiBhbiB1bnNvcnRlZCBsaXN0LCBsaWtlLCBqdW1waW5lc3MgY2FuJ3QgYmUgYXZvaWRlZC5cclxuICAgICAgICAgICAgICAgICAgSSBkdW5uby4gR29pbmcgYmFjayB0byB0aGUgc3RhcnQgaXMgdGhlIHNpbXBsaXN0IHRob3VnaC5cclxuXHJcbiAgICAgICAgICAgICAgICAgIEJhc2ljYWxseSB3aGF0IHRoaXMgZG9lczogU3RhcnRpbmcgZnJvbSB3aGVyZSB3ZSBmb3VuZCBvdXJzZWx2ZXMgYWZ0ZXIgb3VyIGJpbmFyeSBzZWFyY2gsXHJcbiAgICAgICAgICAgICAgICAgIHNjYW4gYmFja3dhcmRzIGFuZCBmb3J3YXJkcyB0aHJvdWdoIGFsbCBhZGphY2VudCBlbnRyaWVzIHRoYXQgYWxzbyBjb21wYXJlIGVxdWFsbHkgc28gdGhhdFxyXG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcclxuICAgICAgICAgICAgICAgICAgKGFuZCBhbHNvIHRoZSBsb3dlc3QgYHVuc29ydGVkSW5kZXhgIHlhZGRhIHlhZGRhIGV4Y2VwdCB0aGF0IGl0IGNvbWVzIGFmdGVyIHVzKS5cclxuXHJcbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxyXG4gICAgICAgICAgICAgICAgICBzZWFyY2hlcyBhcmUsIHRoYW5rcyB0byBwaWdlb25ob2xlIHByaW5jaXBhbCwgZXZlbnR1YWxseSBndWFyYW50ZWVkIHRvIGJlY29tZSBcclxuICAgICAgICAgICAgICAgICAgTyhuKmxvZyBuKS4gVGhpcyBpcyBhbm5veWluZyBidXQgcHJvYmFibHkgbm90IGVhc2lseSBzb2x2YWJsZT8gVGhlcmUgY291bGQgYmUgYW4gXHJcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXHJcbiAgICAgICAgICAgICAgICAgIHRoZSByb2FkLiBNYXliZSBvbmUgb3IgdHdvIGNoYXJhY3RlcnMgd291bGQgYmUgZ29vZCBlbm91Z2ggdGhvdWdoLlxyXG4gICAgICAgICAgICAgICAgKi9cclxuXHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgY2FuZGlkYXRlcycgcG9zaXRpb25zIGluIGJvdGggb3VyIHNvcnRlZCBhcnJheSBhbmQgdGhlIHVuc29ydGVkIERPTS5cclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVCZXN0Rml0ID0gKHU6IG51bWJlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhBbGwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4QWxsID0gaTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgPSB1O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleE5leHQgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPj0gMCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC0taTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGggJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVCZXN0Rml0KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXS51bnNvcnRlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgICAgICArK2k7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleE5leHRdLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleEFsbCAhPT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2N1cnJlbnRUeXBlYWhlYWRdKTtcclxuXHJcbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ+KCh7IGluZGV4LCB0ZXh0IH0pID0+IHtcclxuXHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRleHQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHdoZXJlIHRvIGluc2VydCB0aGlzIGl0ZW0uXHJcbiAgICAgICAgICAgICAgICAvLyBCZWNhdXNlIGFsbCBpbmRleCB2YWx1ZXMgc2hvdWxkIGJlIHVuaXF1ZSwgdGhlIHJldHVybmVkIHNvcnRlZEluZGV4XHJcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZSgtc29ydGVkSW5kZXggLSAxLCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW5tb3VudGluZywgZmluZCB3aGVyZSB3ZSB3ZXJlIGFuZCByZW1vdmUgb3Vyc2VsdmVzLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChzb3J0ZWRJbmRleCA8IDAgfHwgaW5zZXJ0aW5nQ29tcGFyYXRvcihzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbc29ydGVkSW5kZXhdLnRleHQsIHsgdW5zb3J0ZWRJbmRleDogaW5kZXgsIHRleHQgfSkgPT0gMCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFt0ZXh0XSk7XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxyXG5cclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRUeXBlYWhlYWQsXHJcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIFlvdXIgdXN1YWwgYmluYXJ5IHNlYXJjaCBpbXBsZW1lbnRhdGlvbi5cclxuICogXHJcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXHJcbiAqIEBwYXJhbSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoIHRocm91Z2hcclxuICogQHBhcmFtIHdhbnRlZCBUaGUgdmFsdWUgeW91J2QgbGlrZSB0byBmaW5kXHJcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxyXG4gKiBAcmV0dXJucyBBIG5vbi1uZWdhdGl2ZSB2YWx1ZSBpZiBgd2FudGVkYCB3YXMgZm91bmQsIGFuZCBhIG5lZ2F0aXZlIG51bWJlciBpZiBub3QuIFxyXG4gKiBUaGUgYWJzb2x1dGUgdmFsdWUgb2YgdGhpcyBudW1iZXIsIG1pbnVzIG9uZSwgaXMgd2hlcmUgYHdhbnRlZGAgKndvdWxkKiBiZSBmb3VuZCBpZiBpdCAqd2FzKiBpbiBgYXJyYXlgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U2VhcmNoPFQsIFUsIEYgZXh0ZW5kcyAobGhzOiBVLCByaHM6IFQpID0+IG51bWJlcj4oYXJyYXk6IFRbXSwgd2FudGVkOiBVLCBjb21wYXJhdG9yOiBGKTogbnVtYmVyIHtcclxuICAgIGxldCBmaXJzdEluZGV4ID0gMDtcclxuICAgIGxldCBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xyXG4gICAgd2hpbGUgKGZpcnN0SW5kZXggPD0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgdGVzdEluZGV4ID0gKGxhc3RJbmRleCArIGZpcnN0SW5kZXgpID4+IDE7XHJcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcclxuXHJcbiAgICAgICAgaWYgKGNvbXBhcmlzb25SZXN1bHQgPiAwKSB7XHJcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wYXJpc29uUmVzdWx0IDwgMCkge1xyXG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIC1maXJzdEluZGV4IC0gMTtcclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgQ2hpbGRGbGFnT3BlcmF0aW9ucywgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZywgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG4vL2V4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPEsgZXh0ZW5kcyBzdHJpbmcsIEkgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkSW5mb0Jhc2U8Sz4+ID0gUmVxdWlyZWQ8ST4gJiBGbGFnZ2FibGVDaGlsZEluZm88XCJ0YWJiYWJsZVwiPiAmIHtcclxuLy99O1xyXG5cclxuZXhwb3J0IHR5cGUgT25UYWJiYWJsZUluZGV4Q2hhbmdlID0gKHRhYmJhYmxlSW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWQ7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxFIGV4dGVuZHMgRWxlbWVudCwgQz4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB0YWJiaW5nIHRocm91Z2ggdGhpcyBjb21wb25lbnQgd2lsbCBjYXVzZSB0aGUgcmVmZXJlbmNlZCBlbGVtZW50IHRvIGJlIGZvY3VzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciB0byBkbyBzb21ldGhpbmcgZGlmZmVyZW50IGlmIHlvdSdkIGxpa2UuXHJcbiAgICAgKi9cclxuICAgIGZvY3VzU2VsZigpOiB2b2lkO1xyXG5cclxuICAgIC8vYmx1clNlbGYoKTogdm9pZDtcclxuXHJcbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xyXG5cclxuICAgIGhpZGRlbjogYm9vbGVhbjtcclxuXHJcbiAgICBzdWJJbmZvOiBDO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgUlRJUCB7XHJcbiAgICAvLyBDYWxsZWQgZHVyaW5nIGFuIGVmZmVjdCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyByZW5kZXJlZCBpdHNlbGYgaW4gYSB0YWJiYWJsZSBzdGF0ZVxyXG4gICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT86IE9uVGFiYmFibGVJbmRleENoYW5nZTtcclxuXHJcbiAgICAvL29uVGFiYmVkSW5Ubz86ICgpID0+IHZvaWQ7XHJcbiAgICAvL29uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xyXG5cclxuICAgIGluaXRpYWxJbmRleD86IG51bWJlcjtcclxufVxyXG5leHBvcnQgdHlwZSBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cyA9IGtleW9mIFJUSVA7XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPG51bWJlciwgTWNPbWl0cz4ge1xyXG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcclxuICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0VGFiYmFibGVJbmRleDogKCkgPT4gbnVtYmVyIHwgbnVsbDtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGZvY3VzU2VsZjogKCkgPT4gdm9pZDtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xyXG4gICAgVXNlUm92aW5nVGFiSW5kZXhSZXR1cm5UeXBlSW5mbzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj5cclxue1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcclxufVxyXG5cclxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZywgUnRpY09taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXHJcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIj4ge1xyXG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UGFydGlhbDxPbWl0PFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxhbnksIGFueT4sIFwiZ2V0RWxlbWVudFwiIHwgXCJzdWJJbmZvXCI+PiwgUnRpY09taXRzPjtcclxuICAgIHN1YkluZm86IFN1YmJlc3RJbmZvO1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMsIG5ldmVyLCBuZXZlciwgUnRpU3ViSW5mbz4pID0+IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0VGFiYmFibGUoKTogYm9vbGVhbjtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGdldEVsZW1lbnQoKTogQ2hpbGRFbGVtZW50IHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgLyoqICpVbnN0YWJsZSogKi9cclxuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgYSByb3ZpbmcgdGFiaW5kZXggc3lzdGVtIHdoZXJlIG9ubHkgb25lIFwiZm9jdXNhYmxlXCJcclxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxyXG4gKiBvZiB0aG9zZSBlbGVtZW50cyByZWNlaXZlcyBmb2N1cyBpcyBkZXRlcm1pbmVkIGJ5IHlvdSwgYnV0IGl0J3NcclxuICogcmVjb21tZW5kZWQgdG8gb2ZmbG9hZCB0aGF0IGxvZ2ljIHRoZW4gdG8gYW5vdGhlciBob29rLCBsaWtlXHJcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxyXG4gKiBlbGVtZW50IHdpdGggdGhlIGFycm93IGtleXMsIGB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uYCwgd2hpY2hcclxuICogbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHR5cGVhaGVhZCwgb3JcclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cclxuICogXHJcbiAqIE5vdGUgdGhhdCB0aGUgY2hpbGQgaG9vayByZXR1cm5lZCBieSB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZFxyXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcclxuICogcHJvcC1tb2RpZnlpbmcgaG9vayAqdGhhdCogaG9vayByZXR1cm5zIHNob3VsZCB0aGVuIGJlIHVzZWRcclxuICogb24gdGhlIGNoaWxkJ3MgZWxlbWVudCwgYXMgd2VsbCBhcyBhbnkgb3RoZXIgZWxlbWVudHMgeW91J2QgbGlrZVxyXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXHJcbiAqIFxyXG4gKiBgc2hvdWxkRm9jdXNPbkNoYW5nZWAgc2hvdWxkIHJldHVybiB0cnVlIGlmIGZvY3VzIGlzIFxyXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXHJcbiAqIEdlbmVyYWxseSBhcyBzaW1wbGUgYXMgdGhlIGZvbGxvd2luZzpcclxuICogYGBgXHJcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAqIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8UGFyZW50RWxlbWVudD4oeyBzZXRGb2N1c2VkSW5uZXIgfSk7XHJcbiAqIGNvbnN0IGZvY3VzT25DaGFuZ2UgPSAoZm9jdXNlZElubmVyICE9IGZhbHNlKTtcclxuICogYGBgXHJcbiAqIEl0J3Mgbm90IGluY2x1ZGVkIGhlcmUgYmVjYXVzZSBgdXNlUm92aW5nVGFiSW5kZXhgIGRvZXNuJ3Qga25vdyBcclxuICogYW55dGhpbmcgYWJvdXQgdGhlIGNvbnRhaW5lciBlbGVtZW50LCBvbmx5IGNoaWxkcmVuIGVsZW1lbnRzLlxyXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXHJcbiAqIHJlZ2FyZGxlc3Mgb2YgaWYgaXQncyB0aGUgd2hvbGUgYXBwIG9yIGp1c3QgYSBnaXZlbiBjb21wb25lbnQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcblxyXG4gICAgbGV0IHsgcm92aW5nVGFiSW5kZXg6IHsgaW5pdGlhbEluZGV4LCBvblRhYmJhYmxlUmVuZGVyLCBvblRhYmJhYmxlSW5kZXhDaGFuZ2UgfSwgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSA9IHBhcmVudFBhcmFtZXRlcnM7XHJcblxyXG4gICAgaW5pdGlhbEluZGV4ID8/PSAwO1xyXG4gICAgY29uc3Qgc3RhYmxlT25UYWJiYWJsZVJlbmRlciA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uVGFiYmFibGVSZW5kZXIgPz8gKCgpID0+IHsgfSkpO1xyXG4gICAgLypjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICBpZiAob2xkQ291bnQgPT0gMCAmJiBuZXdDb3VudCA+IDApIHtcclxuICAgICAgICAgICAgb25UYWJiZWRJblRvPy4oKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChuZXdDb3VudCA9PSAwICYmIChvbGRDb3VudCA/PyAwKSA+IDApIHtcclxuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSksIHJldHVyblplcm8pOyovXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aHJlZSB0aGluZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnQncyBpbmRleDpcclxuICAgIC8vIFdoYXQgaXQgaXMsIGFuZCB3aGV0aGVyLCB3aGVuIHdlIHJlbmRlciB0aGlzIGNvbXBvbmVudCBhbmQgaXQncyBjaGFuZ2VkLCB0byBhbHNvIGZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIG1hZGUgdGFiYmFibGUuXHJcbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ID8/IDAgfSwgW10pKTtcclxuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VDYWxsYmFjaygodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleDIoKHByZXZJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyKHByZXZJbmRleCA/PyBudWxsKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gdXBkYXRlcjtcclxuXHJcbiAgICAgICAgICAgIG5leHRJbmRleCA9IGNoYW5nZUluZGV4KG5leHRJbmRleCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQobmV4dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIC8vY29uc3QgcHJldkNoaWxkID0gcHJldkluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQocHJldkluZGV4KTtcclxuXHJcbiAgICAgICAgICAgICAgICAvL2lmIChwcmV2Q2hpbGQgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgIC8vICAgIHByZXZDaGlsZC5zdWJJbmZvLmJsdXJTZWxmKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIGZyb21Vc2VySW50ZXJhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoaWxkLnN1YkluZm8uZm9jdXNTZWxmKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBBbnkgdGltZSB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyxcclxuICAgIC8vIG5vdGlmeSB0aGUgcHJldmlvdXMgY2hpbGQgdGhhdCBpdCdzIG5vIGxvbmdlciB0YWJiYWJsZSxcclxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cclxuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obW91bnRlZCwgdW5tb3VudGVkKTsgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTsgfSksXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xyXG5cclxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHsgaW5pdGlhbEluZGV4LCBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4sIGNsb3Nlc3RGaXQ6IHRydWUsIGtleTogXCJ0YWJiYWJsZVwiIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgeyBzdWJJbmZvLCBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgZm9jdXNTZWxmOiBmb2N1c1NlbGZPdmVycmlkZSB9IH0gPSBjaGlsZFBhcmFtZXRlcnM7XHJcblxyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7XHJcbiAgICAgICAgfSwgWyEhaGlkZGVuXSlcclxuXHJcblxyXG4gICAgICAgIGNvbnN0IGZzT3ZlcnJpZGUgPSB1c2VTdGFibGVHZXR0ZXIoZm9jdXNTZWxmT3ZlcnJpZGUpO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZnMgPSBmc092ZXJyaWRlKCk7XHJcbiAgICAgICAgICAgIGlmIChmcykge1xyXG4gICAgICAgICAgICAgICAgZnMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzPy4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICAvKmNvbnN0IGJsdXJTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBicyA9IGJzT3ZlcnJpZGUoKTtcclxuICAgICAgICAgICAgaWYgKGJzKSB7XHJcbiAgICAgICAgICAgICAgICBicygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKSBhcyAoRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KTtcclxuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KVxyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuYmx1cj8uKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbXSk7Ki9cclxuXHJcbiAgICAgICAgY29uc3Qgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIF9wcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDaGlsZEVsZW1lbnQ+KHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBnZXREb2N1bWVudDogdXNlQ2FsbGJhY2soKCk6IERvY3VtZW50ID0+IHsgcmV0dXJuIChnZXRFbGVtZW50KCk/Lm93bmVyRG9jdW1lbnQpID8/ICh3aW5kb3cuZG9jdW1lbnQpIH0sIFtdKSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgW3RhYmJhYmxlLCBzZXRUYWJiYWJsZSwgZ2V0VGFiYmFibGVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgICAgIGNvbnN0IHRhYmJhYmxlRmxhZ3MgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldFRhYmJhYmxlLCBzZXQ6IHNldFRhYmJhYmxlLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhaGlkZGVuKSB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgXzogdm9pZCA9IHVzZU1hbmFnZWRDaGlsZCh7XHJcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZDoge1xyXG4gICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICBmbGFnczogeyAuLi5mbGFncywgdGFiYmFibGU6IHRhYmJhYmxlRmxhZ3MuY3VycmVudCB9IGFzIFBhcnRpYWw8UmVjb3JkPEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIENoaWxkRmxhZ09wZXJhdGlvbnM+PixcclxuICAgICAgICAgICAgICAgIHN1YkluZm86IHtcclxuICAgICAgICAgICAgICAgICAgICAvL2JsdXJTZWxmLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcclxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogISFoaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViSW5mb1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxyXG4gICAgICAgICAgICAgICAgc3RhYmxlT25UYWJiYWJsZVJlbmRlcihpbmRleCk7XHJcbiAgICAgICAgfSwgW3RhYmJhYmxlLCBpbmRleF0pXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLnRhYkluZGV4ID09IG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VIYXNGb2N1c1Byb3BzKHsgdGFiSW5kZXg6IHRhYmJhYmxlID8gMCA6IC0xIH0pLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xyXG5cclxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgdXNlUm92aW5nVGFiSW5kZXguZm9jdXNTZWxmYCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KGluZGV4KT8uc3ViSW5mby5mb2N1c1NlbGY/LigpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChudWxsLCB0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgICAgIGZvY3VzU2VsZixcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKmZ1bmN0aW9uIHRlc3QoKSB7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXgsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIH0gPSB1c2VSb3ZpbmdUYWJJbmRleDxIVE1MRGl2RWxlbWVudCwgeyBcImZvb1wiOiBcImJhclwiIH0sIFwiZmxhZzJcIj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHt9LCByb3ZpbmdUYWJJbmRleDoge30gfSk7XHJcbiAgICBjb25zdCB7IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4OiAwLCBmbGFnczoge30gfSwgcnRpOiB7IGluZm8zOiB7IGZvbzogXCJiYXJcIiB9IH0gfSk7XHJcbn0qL1xyXG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSYW5kb207XG4iLCJpbXBvcnQgYmFzZVJhbmRvbSBmcm9tICcuL19iYXNlUmFuZG9tLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgfVxuICBhcnJheS5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNodWZmbGVTZWxmO1xuIiwiaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IHNodWZmbGVTZWxmIGZyb20gJy4vX3NodWZmbGVTZWxmLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTaHVmZmxlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlNYXA7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVZhbHVlcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsImltcG9ydCBiYXNlSXNUeXBlZEFycmF5IGZyb20gJy4vX2Jhc2VJc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzVHlwZWRBcnJheTtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzO1xuIiwiaW1wb3J0IHNodWZmbGVTZWxmIGZyb20gJy4vX3NodWZmbGVTZWxmLmpzJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTaHVmZmxlO1xuIiwiaW1wb3J0IGFycmF5U2h1ZmZsZSBmcm9tICcuL19hcnJheVNodWZmbGUuanMnO1xuaW1wb3J0IGJhc2VTaHVmZmxlIGZyb20gJy4vX2Jhc2VTaHVmZmxlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNodWZmbGU7XG4iLCJpbXBvcnQgKiBhcyBfIGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IE11dGFibGVSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEdldEluZGV4PEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHJvdzogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+KSA9PiAobnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCk7XHJcbmV4cG9ydCB0eXBlIEdldFZhbHVlPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4sIC4uLmFyZ3M6IEcpID0+IFY7XHJcbmV4cG9ydCB0eXBlIENvbXBhcmU8Vj4gPSAobGhzOiBWLCByaHM6IFYpID0+IG51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IHJldHVybiwgZS5nLiwgdGhlIHJvdyBpbmRleCBvZiB0aGlzIGNoaWxkXHJcbiAgICAgKiAoVXN1YWxseSBqdXN0IGFuIGBpbmRleGAgcHJvcClcclxuICAgICAqL1xyXG4gICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiBHZXRJbmRleDxDLCBLPjsgfVxyXG59XHJcblxyXG4vKipcclxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+IHtcclxuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNdXN0IHJldHVybiB0aGUgdmFsdWUgdGhpcyBjaGlsZCB1c2VzIFJFOiBzb3J0aW5nLlxyXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHNvcnRpbmcgKHlvdSBqdXN0IHVzZSBcclxuICAgICAgICAgKiB5b3VyIG93bmFyYml0cmFyeSByZW9yZGVyaW5nKSwgdGhpcyB3aWxsIG5ldmVyXHJcbiAgICAgICAgICogYmUgdXNlZCwgc28gaXQgY2FuIHJldHVybiBhbnl0aGluZy5cclxuICAgICAgICAgKiBAcGFyYW0gcm93IFxyXG4gICAgICAgICAqIEBwYXJhbSBhcmdzIFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldFZhbHVlOiBHZXRWYWx1ZTxDLCBLLCBHLCBWPjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udHJvbHMgaG93IHZhbHVlcyBjb21wYXJlIGFnYWluc3QgZWFjaCBvdGhlci5cclxuICAgICAgICAgKiBAcGFyYW0gbGhzIFxyXG4gICAgICAgICAqIEBwYXJhbSByaHMgXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgY29tcGFyZTogQ29tcGFyZTxWPjtcclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG4vKipcclxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXHJcbiAqIFxyXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqXHJcbiAqIFxyXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXHJcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcclxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cclxuICogXHJcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXHJcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxyXG4gKiBcclxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XHJcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxyXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cclxuICogXHJcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcclxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXHJcbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcclxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9OiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+KTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLPiB7XHJcblxyXG4gICAgLy8gVGhlc2UgYXJlIHVzZWQgdG8ga2VlcCB0cmFjayBvZiBhIG1hcHBpbmcgYmV0d2VlbiB1bnNvcnRlZCBpbmRleCA8LS0tPiBzb3J0ZWQgaW5kZXguXHJcbiAgICAvLyBUaGVzZSBhcmUgbmVlZGVkIGZvciBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMuXHJcbiAgICBjb25zdCBtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XHJcbiAgICBjb25zdCBkZW1hbmdsZU1hcCA9IHVzZVJlZihuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpKTtcclxuICAgIGNvbnN0IGluZGV4TWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChtYW5nbGVNYXAuY3VycmVudC5nZXQobikgPz8gbiksIFtdKTtcclxuICAgIGNvbnN0IGluZGV4RGVtYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKGRlbWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XHJcblxyXG4gICAgLy8gVGhlIHNvcnQgZnVuY3Rpb24gbmVlZHMgdG8gYmUgYWJsZSB0byB1cGRhdGUgd2hvZXZlciBoYXMgYWxsIHRoZSBzb3J0YWJsZSBjaGlsZHJlbi5cclxuICAgIC8vIEJlY2F1c2UgdGhhdCBtaWdodCBub3QgYmUgdGhlIGNvbnN1bWVyIG9mICp0aGlzKiBob29rIGRpcmVjdGx5IChlLmcuIGEgdGFibGUgdXNlc1xyXG4gICAgLy8gdGhpcyBob29rLCBidXQgaXQncyB0Ym9keSB0aGF0IGFjdHVhbGx5IG5lZWRzIHVwZGF0aW5nKSwgd2UgbmVlZCB0byByZW1vdGVseVxyXG4gICAgLy8gZ2V0IGFuZCBzZXQgYSBmb3JjZVVwZGF0ZSBmdW5jdGlvbi5cclxuICAgIC8vY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XHJcbiAgICBjb25zdCBbZ2V0Rm9yY2VVcGRhdGUsIHNldEZvcmNlVXBkYXRlXSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgKCgpID0+IHZvaWQpPihudWxsLCByZXR1cm5OdWxsKTtcclxuXHJcbiAgICBjb25zdCByZWFycmFuZ2UgPSB1c2VDYWxsYmFjaygoc29ydGVkUm93czogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+W10pID0+IHtcclxuXHJcbiAgICAgICAgLy8gVXBkYXRlIG91ciBzb3J0ZWQgPC0tPiB1bnNvcnRlZCBpbmRpY2VzIG1hcCBcclxuICAgICAgICAvLyBhbmQgcmVyZW5kZXIgdGhlIHdob2xlIHRhYmxlLCBiYXNpY2FsbHlcclxuICAgICAgICBmb3IgKGxldCBpbmRleEFzU29ydGVkID0gMDsgaW5kZXhBc1NvcnRlZCA8IHNvcnRlZFJvd3MubGVuZ3RoOyArK2luZGV4QXNTb3J0ZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXhBc1Vuc29ydGVkID0gc29ydGVkUm93c1tpbmRleEFzU29ydGVkXS5pbmRleDtcclxuXHJcbiAgICAgICAgICAgIG1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzVW5zb3J0ZWQsIGluZGV4QXNTb3J0ZWQpO1xyXG4gICAgICAgICAgICBkZW1hbmdsZU1hcC5jdXJyZW50LnNldChpbmRleEFzU29ydGVkLCBpbmRleEFzVW5zb3J0ZWQpO1xyXG4gICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgIGdldEZvcmNlVXBkYXRlKCk/LigpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHVzZVJlYXJyYW5nZWFibGVQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB9KSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4geyBzZXRGb3JjZVVwZGF0ZShfcHJldiA9PiBmb3JjZVVwZGF0ZSk7IH0sIFtmb3JjZVVwZGF0ZV0pXHJcblxyXG4gICAgICAgIHJldHVybiAodXNlTWVyZ2VkUHJvcHM8UGFyZW50RWxlbWVudD4oe1xyXG4gICAgICAgICAgICBjaGlsZHJlbjpcclxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiBhcyBWTm9kZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+W10pXHJcbiAgICAgICAgICAgICAgICAgICAgLnNsaWNlKClcclxuICAgICAgICAgICAgICAgICAgICAubWFwKGNoaWxkID0+ICh7IGNoaWxkLCBtYW5nbGVkSW5kZXg6IGluZGV4TWFuZ2xlcihnZXRJbmRleChjaGlsZC5wcm9wcyEpISksIGRlbWFuZ2xlZEluZGV4OiBnZXRJbmRleChjaGlsZC5wcm9wcykgfSkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMubWFuZ2xlZEluZGV4IC0gcmhzLm1hbmdsZWRJbmRleCB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKHsgY2hpbGQsIG1hbmdsZWRJbmRleCwgZGVtYW5nbGVkSW5kZXggfSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaChjaGlsZC50eXBlIGFzIGFueSwgeyAuLi5jaGlsZC5wcm9wcywga2V5OiBkZW1hbmdsZWRJbmRleCwgXCJkYXRhLW1hbmdsZWQtaW5kZXhcIjogbWFuZ2xlZEluZGV4LCBcImRhdGEtdW5tYW5nbGVkLWluZGV4XCI6IGRlbWFuZ2xlZEluZGV4IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSwgcHJvcHMpKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4geyB1c2VSZWFycmFuZ2VhYmxlUHJvcHMsIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyLCBtYW5nbGVNYXAsIGRlbWFuZ2xlTWFwLCByZWFycmFuZ2UgfSB9O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxyXG4gKiBcclxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKiBcclxuICogXHJcbiAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoaXMgaW4gY29uanVuY3Rpb24gd2l0aCBgdXNlTGlzdE5hdmlnYXRpb25gOyBpdCB0YWtlcyB0aGUgc2FtZSBgaW5kZXhNYW5nbGVyYCBhbmQgYGluZGV4RGVtYW5nbGVyYCBcclxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxyXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxyXG4gKiBcclxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcclxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXHJcbiAqIFxyXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcclxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXHJcbiAqIHNvcnRlZCBhbmQgdW5zb3J0ZWQgaW5kZXggcG9zaXRpb25zLlxyXG4gKiBcclxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxyXG4gKiB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayBpbnNwZWN0cyB0aGUgZ2l2ZW4gY2hpbGRyZW4sIHRoZW4gcmUtY3JlYXRlcyB0aGVtIHdpdGggbmV3IGBrZXlgcy5cclxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxyXG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9LCBzb3J0YWJsZUNoaWxkcmVuOiB7IGNvbXBhcmU6IHVzZXJDb21wYXJlLCBnZXRWYWx1ZSB9IH06IFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEssIEcsIFY+KTogVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQywgSywgRz4ge1xyXG5cclxuICAgIGNvbnN0IGNvbXBhcmUgPSAodXNlckNvbXBhcmUgPz8gZGVmYXVsdENvbXBhcmUpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiB1c2VTb3J0YWJsZVByb3BzLCAuLi5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlIH0gPSB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9KTtcclxuICAgIGNvbnN0IHsgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IHJlYXJyYW5nZSB9IH0gPSByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlO1xyXG4gICAgLy8gVGhlIGFjdHVhbCBzb3J0IGZ1bmN0aW9uLlxyXG4gICAgY29uc3Qgc29ydCA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBzb3J0ZWRSb3dzID0gbWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpLnNvcnQoKGxoc1JvdywgcmhzUm93KSA9PiB7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGdldFZhbHVlKGxoc1JvdywgLi4uYXJncykgYXMgYW55O1xyXG4gICAgICAgICAgICBjb25zdCByaHNWYWx1ZSA9IGdldFZhbHVlKHJoc1JvdywgLi4uYXJncykgYXMgYW55O1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjb21wYXJlKGxoc1ZhbHVlLCByaHNWYWx1ZSkgLy8gbGhzUm93LmdldE1hbmFnZWRDZWxscygpPy5bY29sdW1uXT8udmFsdWUsIHJoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGRpcmVjdGlvblswXSA9PSBcImRcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiAtcmVzdWx0O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG5cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHJlYXJyYW5nZShzb3J0ZWRSb3dzKTtcclxuXHJcbiAgICB9LCBbIC8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xyXG5cclxuICAgIGNvbnN0IHNodWZmbGUgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHNodWZmbGVkUm93cyA9IGxvZGFzaFNodWZmbGUobWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpKVxyXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc2h1ZmZsZWRSb3dzKTtcclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXHJcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0LCBzaHVmZmxlIH0sXHJcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiByZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnJlYXJyYW5nZWFibGVDaGlsZHJlblxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQYXNzIGFuIGFycmF5IG9mIG5vdC1zb3J0ZWQgY2hpbGQgaW5mb3JtYXRpb24gdG8gdGhpcyBmdW5jdGlvblxyXG4gICAgICAgICAqIGFuZCB0aGUgY2hpbGRyZW4gd2lsbCByZS1hcnJhbmdlIHRoZW1zZWx2ZXMgdG8gbWF0Y2guXHJcbiAgICAgICAgICogIFxyXG4gICAgICAgICAqICoqU1RBQkxFKipcclxuICAgICAgICAgKiAgXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgcmVhcnJhbmdlOiAocm93c0luT3JkZXI6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB2b2lkO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZGVtYW5nbGVNYXA6IE11dGFibGVSZWY8TWFwPG51bWJlciwgbnVtYmVyPj47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuPzogVk5vZGU8YW55PltdIHwgdW5kZWZpbmVkOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PjtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XHJcbiAgICBzb3J0YWJsZUNoaWxkcmVuOiB7LyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBzb3J0OiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRykgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBzaHVmZmxlOiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcclxuICAgIH1cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHNcclxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlU29ydGFibGVQcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB8IHVuZGVmaW5lZDsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuICAgIHJldHVybiBjb21wYXJlMShsaHMsIHJocyk7XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZTMobGhzOiBzdHJpbmcgfCBudW1iZXIsIHJoczogc3RyaW5nIHwgbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIC8vIENvZXJjZSBzdHJpbmdzIHRvIG51bWJlcnMgaWYgdGhleSBzZWVtIHRvIHN0YXkgdGhlIHNhbWUgd2hlbiBzZXJpYWxpemVkXHJcbiAgICAgICAgaWYgKGAkeytsaHN9YCA9PT0gbGhzKVxyXG4gICAgICAgICAgICBsaHMgPSArbGhzO1xyXG4gICAgICAgIGlmIChgJHsrcmhzfWAgPT09IHJocylcclxuICAgICAgICAgICAgcmhzID0gK3JocztcclxuXHJcbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgaWYgZWl0aGVyIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0dXJuIHRoZSBvdGhlciBvbmUgaW50byBvbmUgdG9vXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHJocyA9IGAke3Joc31gO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICBsaHMgPSBgJHtsaHN9YDtcclxuXHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIGxocyA9PT0gdHlwZW9mIHJocyk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLmxvY2FsZUNvbXBhcmUocmhzIGFzIHN0cmluZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwibnVtYmVyXCIpXHJcbiAgICAgICAgICAgIHJldHVybiArbGhzIC0gK3JocztcclxuXHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBjb21wYXJlMihsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwiYm9vbGVhblwiIHx8IGxocyBpbnN0YW5jZW9mIERhdGUpXHJcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwiYm9vbGVhblwiIHx8IHJocyBpbnN0YW5jZW9mIERhdGUpXHJcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUzKGxocywgcmhzKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUxKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggbnVsbFxyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGhzID09IG51bGwgfHwgcmhzID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gT25lIG9mIHRoZSB0d28gaXMgbnVsbCAtLSBlYXN5IGNhc2VcclxuICAgICAgICAgICAgcmV0dXJuIGxocyAhPSBudWxsID8gMSA6IC0xXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb21wYXJlMihsaHMsIHJocyk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VQcmVzcyB9IGZyb20gXCIuL3VzZS1wcmVzc1wiO1xyXG5pbXBvcnQgeyB1c2VDaGlsZHJlbkhhdmVGb2N1cywgVXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW4sIE1hbmFnZWRDaGlsZHJlbk9taXRzLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCB1c2VMaW5lYXJOYXZpZ2F0aW9uLCBVc2VMaW5lYXJOYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIHVzZVJvdmluZ1RhYkluZGV4LCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVycywgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm8sIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcclxuaW1wb3J0IHsgdXNlU29ydGFibGVDaGlsZHJlbiwgVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnMsIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1zb3J0YWJsZS1jaGlsZHJlblwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcblxyXG4vKipcclxuICogXHJcbiAqIFRPRE86IFRoaXMgdGFibGUgd2FzIHNjcmFwcGVkIHdoZW4gdGhpcyB3YXMgY2hhbmdlZCB0byBqdXN0IGFjY2VwdCBhIGNvbGxhdG9yIGRpcmVjdGx5LFxyXG4gKiBidXQgaXQncyBub3QgYmFkIGZvciBhIGNvbGxhdGlvbiBjcmFzaCBjb3Vyc2UgYW5kIEkgbWlnaHQgdXNlIGl0IGFnYWluLlxyXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cclxuICogXHJcbiAqIHxMYW5nLnxUYXJnZXR8VXNlciBpbnB1dHxgYmFzZWB8YGFjY2VudGB8YGNhc2VgfGB2YXJpYW50YHxcclxuICogfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18XHJcbiAqIHxFTnxIaXxCeWV84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8RU58SGl8SGl84pyFfOKchXzinIV84pyFfFxyXG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcclxuICogfEVOfEhpfGhpfOKchXzinIV84p2MfOKdjHxcclxuICogfEVOfEhpfEjDr3zinIV84p2MfOKdjHzinYx8XHJcbiAqIHxFTnzDpXxhYXzinYx84p2MfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxhYXzinIV84pyFfOKchXzinYx8XHJcbiAqIHxEQXzDpXxBQXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxhQXzinYx84p2MfOKdjHzinYx8XHJcbiAqIHxFTnzDpXxhfOKchXzinIV84p2MfOKdjHxcclxuICogfERBfMOlfGF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8SlB876qqfOedgHzinIV84pyFfOKchXzinIV8XHJcbiAqIHxKUHzjgqt87722fOKchXzinIV84pyFfOKchXxcclxuICogfEpQfOOCq3zjgYt84pyFfOKchXzinIV84p2MfFxyXG4gKiB8SlB844KrfOODtXzinIV84pyFfOKchXzinYx8XHJcbiAqIHxKUHzjgqt844uVfOKchXzinIV84p2MfOKdjHxcclxuICogfEpQfOOCq3zjgqx84pyFfOKdjHzinYx84p2MfFxyXG4gKiB8SlB844KrfOWKm3zinYx84p2MfOKdjHzinYx8XHJcbiAqIHxaSHzntIV857qifOKdjHzinYx84p2MfOKdjHxcclxuICogXHJcbiAqIFxyXG4gKiAoTm90ZSB0byBzZWxmOiBBdCBzb21lIHBvaW50LCB0aGlzIGZpbGUgd2lsbCBwcm9iYWJseSBiZSBub3JtYWxpemVkXHJcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxyXG4gKiBcclxuICovXHJcbmNvbnN0IF9kdW1teTogYW55ID0gbnVsbDtcclxuXHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XHJcbnR5cGUgT21pdDxULCBLIGV4dGVuZHMga2V5b2YgVD4gPSBQaWNrPFQsIEV4Y2x1ZGU8a2V5b2YgVCwgSz4+O1xyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPiB7XHJcbiAgICB0ZXh0OiBzdHJpbmc7XHJcblxyXG4gICAgc3ViSW5mbzogQztcclxufVxyXG5cclxuLyoqXHJcbiAqIEBwYXJhbSBmcm9tVXNlckludGVyYWN0aW9uIFdoZXRoZXIgdGhlIHVzZXIgaW50ZXJhY3RlZCB3aXRoIHRoaXMgY2hpbGQgYXMgYSBtZWFucyBvZiBuYXZpZ2F0aW5nIHRvIGl0LiAgSW4gdGhhdCB3YXMgdGhlIGNhc2UsIHRoZSBjaGlsZCBpcyBhbHNvIGZvY3VzZWQuIE90aGVyd2lzZSwgZm9jdXMgbW92ZXMgYXMgdGhlIGJyb3dzZXIgZGV0ZXJtaW5lcy5cclxuICovXHJcbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xyXG5cclxuXHJcbmludGVyZmFjZSBMU1Age1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBhbmQgaW5kZXhEZW1hbmdsZXIgYXJlIHVzZWQgdG8gYWxsb3cgY2hpbGRyZW4gdG8gYmUgbmF2aWdhdGVkIGluIGFuIG9yZGVyXHJcbiAgICAgKiB0aGF0IGRvZXNuJ3QgbmVjZXNzYXJpbHkgbWF0Y2ggdGhlaXIgY2hpbGQgb3JkZXIsIGxpa2UgaWYgYSBsaXN0IGlzIHNvcnRlZC5cclxuICAgICAqIFxyXG4gICAgICogVXNlZCB0byB0dXJuIGFuIFwiYWJzb2x1dGVcIiBpbmRleCBpbnRvIGEgXCJzb3J0ZWQvZmlsdGVyZWQvbWFuZ2xlZFwiIG9uZS5cclxuICAgICAqIFxyXG4gICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXHJcbiAgICAgKiBAcGFyYW0gcmF3SW5kZXggXHJcbiAgICAgKi9cclxuICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgdG8gdHVybiBhIFwibWFuZ2xlZFwiIGluZGV4IGludG8gaXQncyBcInVuc29ydGVkXCIgb3IgXCJ1bm1hbmdsZWRcIiBpbmRleC5cclxuICAgICAqIFxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gaW5jcmVtZW50aW5nIG9yIGRlY3JlbWVudGluZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGluZGV4LFxyXG4gICAgICogaXQgbmVlZHMgdG8gYmUgZGVtYW5nbGVkIHRvIGRvIFwibm9ybWFsXCIgbWF0aCBvbiBpdCwgYW5kIHRoZW4gcmUtbWFuZ2xlZCAoYWJvdmUpXHJcbiAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxyXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybWVkSW5kZXggXHJcbiAgICAgKi9cclxuICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzID0ga2V5b2YgTFNQO1xyXG5cclxuLy8gKioqIFBhcmFtZXRlcnMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcclxuICAgIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVyczxSdGlPbWl0cywgTWNPbWl0cz4sXHJcbiAgICBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxUbk9taXRzIHwgXCJnZXRJbmRleFwiIHwgXCJzZXRJbmRleFwiPixcclxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPExuT21pdHMgfCBcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiB7XHJcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxMU1AsIExzT21pdHM+O1xyXG59XHJcblxyXG5pbnRlcmZhY2UgU1NQIHtcclxuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XHJcbiAgICBvblNlbGVjdGVkSW5kZXhDaGFuZ2U6IChldmVudDogRXZlbnQsIG5ld0luZGV4OiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRpb25cIjtcclxufVxyXG5leHBvcnQgdHlwZSBTaW5nbGVTZWxlY3Rpb25PbWl0cyA9IGtleW9mIFNTUDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzIHwgXCJpbml0aWFsSW5kZXhcIiwgTWNPbWl0cz4ge1xyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBPbWl0PFNTUCwgU1NPbWl0cz47XHJcbiAgICBjaGlsZHJlbkhhdmVGb2N1czogUGFydGlhbDxVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnNbXCJjaGlsZHJlbkhhdmVGb2N1c1wiXT47XHJcbn1cclxuZXhwb3J0IHR5cGUgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzID0ga2V5b2YgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPGFueT47XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8THNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kc1xyXG4gICAgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIFJ0aU9taXRzLCBNY09taXRzLCBTdWJiZXN0SW5mbz4ge1xyXG4gICAgLy9yb3ZpbmdUYWJJbmRleDogT21pdDxVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cywgbmV2ZXI+W1wicm92aW5nVGFiSW5kZXhcIl0sIFwic3ViSW5mb1wiPjtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBMc09taXRzIHwgXCJzdWJJbmZvXCI+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLIHwgXCJzZWxlY3RlZFwiLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgU3ViYmVzdEluZm8+IHtcclxuICAgIGhhc0ZvY3VzOiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT47XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+PiwgXCJ0YWJiYWJsZVwiIHwgRXh0cmFGbGFnS2V5cz4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleDogTmF2aWdhdGVUb0luZGV4IH07XHJcbn1cclxuXHJcbi8vICoqKiBSZXR1cm4gdHlwZXMgKGxpc3QsIGxpc3Qtc2luZ2xlLCBsaXN0LWNoaWxkLCBsaXN0LXNpbmdsZS1jaGlsZClcclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcclxuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcclxuXHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcbiAgICBzaW5nbGVTZWxlY3Rpb246IHt9XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xyXG4gICAgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQsIEMsIEs+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wczogVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+W1widXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiXTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XHJcbiAgICBzaW5nbGVTZWxlY3Rpb246IHtcclxuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbjtcclxuICAgICAgICBnZXRTZWxlY3RlZCgpOiBib29sZWFuO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+W1widXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXCJdO1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuXHJcbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXHJcbiAqIFxyXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXHJcbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPih7XHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlLCAuLi5tYyB9LFxyXG4gICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblxyXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcclxuICAgIGluZGV4TWFuZ2xlciA/Pz0gaWRlbnRpdHk7XHJcbiAgICBpbmRleERlbWFuZ2xlciA/Pz0gaWRlbnRpdHk7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlTGlzdE5hdmlnYXRpb25cIiwgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlcik7XHJcblxyXG5cclxuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VSb3ZpbmdUYWJJbmRleDxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzPih7XHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgIC4uLm1jLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obSwgdSk7XHJcbiAgICAgICAgICAgIH0sIFtdKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXhcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sIHJvdmluZ1RhYkluZGV4OiB7IGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSB9ID0gcGFyZW50UmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGlmIChpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdHJ5TmF2aWdhdGVUb0luZGV4KHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGksXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXHJcbiAgICAgICAgICAgICAgICBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSxcclxuICAgICAgICAgICAgICAgIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4LCBmcm9tVXNlckludGVyYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZFxyXG4gICAgICAgIH1cclxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICBnZXRJbmRleDogZ2V0VGFiYmFibGVJbmRleCxcclxuICAgICAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCB0cnVlKTtcclxuICAgICAgICAgICAgfSwgW10pLFxyXG4gICAgICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zdCB7IHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXY6IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoKGMgPz8gMCkpIC0gMSksIHNlYXJjaERpcmVjdGlvbjogLTEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSlcclxuICAgICAgICAgICAgICAgIH0sIHRydWUpXHJcbiAgICAgICAgICAgIH0sIFtdKSxcclxuICAgICAgICAgICAgbmF2aWdhdGVUb05leHQ6IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoYyA/PyAwKSArIDEpLCBzZWFyY2hEaXJlY3Rpb246IDEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSk7XHJcbiAgICAgICAgICAgICAgICB9LCB0cnVlKVxyXG4gICAgICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKDApLCB0cnVlKTsgfSwgW10pLFxyXG4gICAgICAgICAgICBuYXZpZ2F0ZVRvTGFzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpKSwgdHJ1ZSk7IH0sIFtdKSxcclxuICAgICAgICAgICAgLi4ubGluZWFyTmF2aWdhdGlvblxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wcyh1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMocHJvcHMpKTtcclxuICAgIH0sIFt1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHMsIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wc10pO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBoaWRkZW4gfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBzdWJJbmZvIH0pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgX3Y6IHZvaWQgPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQoeyB0ZXh0LCBpbmRleCB9KTtcclxuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VGFiYmFibGVJbmRleCgpID09IGdldEluZGV4KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZSxcclxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbjogISFoaWRkZW4gfSxcclxuICAgICAgICAgICAgc3ViSW5mbzogeyB0ZXh0LCBzdWJJbmZvIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiA9IGZ1bmN0aW9uICh7IC4uLnByb3BzIH0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPENoaWxkRWxlbWVudD4odXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKCgoeyBpbmVydDogaGlkZGVuIH0gYXMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikpKSwgcHJvcHMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZSxcclxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFt1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG5hdmlnYXRlVG9JbmRleF0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG5cclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9XHJcbiAgICAgICAgLypsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfSovXHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEl0J3MgdmVyeSBjb21tb24gdG8gY29tYmluZSBhIHRhYmJhYmxlIGxpc3Qgb2YgdGhpbmdzIGFuZCBcInNlbGVjdGlvblwiIG9mIG9uZSBvZiB0aG9zZSB0aGluZ3MuXHJcbiAqIFxyXG4gKiBMaXN0cywgcmFkaW8gYnV0dG9ucywgdGFicywgZXRjLiBldGMuXHJcbiAqIFxyXG4gKiBUaGlzIGlzIGEgc2hvcnRjdXQgdGhhdCBjb21iaW5lcyB0aGUgdHdvIHdpdGggdGhlIGNvcnJlY3QgdHlwaW5nLlxyXG4gKiBAcGFyYW0gcGFyYW0wIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHtcclxuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGVkSW5kZXhDaGFuZ2UgfSxcclxuICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgcm92aW5nVGFiSW5kZXg6IHsgLi4ucm92aW5nVGFiSW5kZXggfSxcclxuICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHsgb25BbGxMb3N0Rm9jdXMsIG9uQW55R2FpbmVkRm9jdXMgfVxyXG59OiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4ge1xyXG4gICAgY29uc3QgcGFyZW50UmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+KHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcclxuICAgICAgICAgICAgaW5pdGlhbEluZGV4OiAoc2VsZWN0ZWRJbmRleCA/PyB1bmRlZmluZWQpLFxyXG4gICAgICAgICAgICAuLi5yb3ZpbmdUYWJJbmRleFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQgfSA9IHVzZUNoaWxkcmVuSGF2ZUZvY3VzKHtcclxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czoge1xyXG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1czogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25BbGxMb3N0Rm9jdXM/LigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KHNlbGVjdGVkSW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG9uQW55R2FpbmVkRm9jdXNcclxuICAgICAgICB9LCBtYW5hZ2VkQ2hpbGRyZW46IHtcclxuICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0OiBudWxsLFxyXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGxcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBzdGFibGVPbkNoYW5nZSA9IHVzZVN0YWJsZUNhbGxiYWNrKG9uU2VsZWN0ZWRJbmRleENoYW5nZSk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICAuLi5saXN0UmVzdFxyXG4gICAgfSA9IHBhcmVudFJldHVyblR5cGU7XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSwgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9IH0gPSBsaXN0UmVzdDtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgY2hhbmdlSW5kZXg6IGNoYW5nZVNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAgZ2V0Q3VycmVudEluZGV4OiBnZXRTZWxlY3RlZEluZGV4LFxyXG4gICAgICAgIC8vcmVldmFsdWF0ZUNsb3Nlc3RGaXRcclxuICAgIH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSyB8IFwic2VsZWN0ZWRcIj4oe1xyXG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICBpbml0aWFsSW5kZXg6IHNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAga2V5OiBcInNlbGVjdGVkXCIsXHJcbiAgICAgICAgY2xvc2VzdEZpdDogZmFsc2VcclxuICAgIH0pO1xyXG5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleChzZWxlY3RlZEluZGV4KTtcclxuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aSwgbGlzdE5hdmlnYXRpb246IGxzLCBoYXNGb2N1czogeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIC4uLmhhc0ZvY3VzIH0sIHN1YkluZm8gfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFJlZiA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0SXNTZWxlY3RlZCwgc2V0OiBzZXRJc1NlbGVjdGVkLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhcnRpLmhpZGRlbikgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkKHtcclxuICAgICAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uTW9kZSA9PSAnZm9jdXMnICYmIGZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWJsZU9uQ2hhbmdlKHsgdGFyZ2V0OiBnZXRFbGVtZW50KCksIGN1cnJlbnRUYXJnZXQ6IGdldEVsZW1lbnQoKSB9IGFzIEV2ZW50LCBnZXRJbmRleCgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgICAgICAuLi5oYXNGb2N1cyxcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXHJcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHNcclxuICAgICAgICAgICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQoe1xyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgsXHJcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3M6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsYWdzXHJcbiAgICAgICAgICAgICAgICAgICAgfSBhcyBQYXJ0aWFsPFJlY29yZDxLIHwgXCJzZWxlY3RlZFwiIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxyXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IGxzLFxyXG4gICAgICAgICAgICAgICAgc3ViSW5mbyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHVzZVByZXNzUHJvcHMgPSB1c2VQcmVzczxDaGlsZEVsZW1lbnQ+KHsgb25DbGlja1N5bmM6IChlKSA9PiB7IHN0YWJsZU9uQ2hhbmdlKGUsIGdldEluZGV4KCkpOyB9LCBleGNsdWRlOiB7fSwgaGFzRm9jdXMgfSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IHVzZVByZXNzUHJvcHModXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFByb3BzKHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcykpKSxcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxyXG4gICAgICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkOiBpc1NlbGVjdGVkLCBnZXRTZWxlY3RlZDogZ2V0SXNTZWxlY3RlZCB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSwgW3NlbGVjdGlvbk1vZGVdKSxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygoLi4ucDogUGFyYW1ldGVyczx0eXBlb2YgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcz4pID0+IHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMoLi4ucCkgfSwgW10pLFxyXG4gICAgICAgIC4uLmxpc3RSZXN0LFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge31cclxuICAgIH1cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kc1xyXG4gICAgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgfCBcImluZGV4TWFuZ2xlclwiIHwgXCJpbmRleERlbWFuZ2xlclwiLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4sXHJcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLLCBHLCBWPiB7XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cz4gPSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLLCBMc09taXRzLCBSdGlPbWl0cywgTWNPbWl0cywgQz47XHJcbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXI+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPixcclxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLLCBHPiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xyXG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XHJcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdLCBWPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW4sIHNvcnRhYmxlQ2hpbGRyZW4gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSywgRywgViwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSywgRz4ge1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxyXG4gICAgICAgIC4uLnNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBHLCBWPih7XHJcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLFxyXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW4sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xyXG4gICAgICAgIHJldHVybiAodXNlTGlzdE5hdmlnYXRpb25Qcm9wcyh1c2VTb3J0YWJsZVByb3BzKHByb3BzKSkpXHJcbiAgICB9XHJcbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+ID0gKHApID0+IHtcclxuICAgICAgICByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25DaGlsZChwKVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoe1xyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyxcclxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGUsXHJcbiAgICAgICAgLi4uc29ydGFibGVDaGlsZHJlblJldHVyblR5cGVcclxuICAgICAgICAvKm1hbmFnZWRDaGlsZHJlbjogbGlzdE5hdlJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBsaXN0TmF2UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBsaXN0TmF2UmV0dXJuVHlwZS50eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlLnNvcnRhYmxlQ2hpbGRyZW4sXHJcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW4qL1xyXG4gICAgfSk7XHJcblxyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYXJnczogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cyBleHRlbmRzIFNpbmdsZVNlbGVjdGlvbk9taXRzLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8U1NPbWl0cywgTHNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XHJcblxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEssIEc+LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzXHJcbiAgICBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLLCBHPiB7XHJcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cclxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24sIGNoaWxkcmVuSGF2ZUZvY3VzIH06IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLLCBbXT4ge1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxyXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZVxyXG4gICAgfSA9IHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSywgW10sIG51bWJlcj4oe1xyXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSkgfSxcclxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XHJcbiAgICAgICAgICAgIGdldFZhbHVlOiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSxcclxuICAgICAgICAgICAgY29tcGFyZTogdXNlQ2FsbGJhY2soKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMgLSByaHM7IH0sIFtdKSxcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlUmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxyXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc2luZ2xlU2VsZWN0aW9uLFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBjaGlsZHJlbkhhdmVGb2N1c1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzID0gKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuICh1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHVzZVNvcnRhYmxlUHJvcHMocHJvcHMpKSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4ge1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoe1xyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcclxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgLy9zb3J0YWJsZTogeyBzb3J0LCBzaHVmZmxlLCByZWFycmFuZ2UsIGRlbWFuZ2xlTWFwLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCBtYW5nbGVNYXAgfSxcclxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGUsXHJcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcclxuICAgIH0pO1xyXG5cclxufVxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRyeU5hdmlnYXRlVG9JbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xyXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxDPj4sIEs+O1xyXG4gICAgZGVmYXVsdDogbnVtYmVyO1xyXG4gICAgdGFyZ2V0OiBudW1iZXI7XHJcbiAgICBzZWFyY2hEaXJlY3Rpb246IDEgfCAtMTtcclxuICAgIGluZGV4TWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB0cnlOYXZpZ2F0ZVRvSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbiwgc2VhcmNoRGlyZWN0aW9uLCBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCB0YXJnZXQgfTogVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEs+KSB7XHJcbiAgICBjb25zdCB1cHBlciA9IGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpO1xyXG4gICAgY29uc3QgbG93ZXIgPSAwO1xyXG5cclxuICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IC0xKSB7XHJcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPj0gbG93ZXIgJiYgKGNoaWxkcmVuLmdldEF0KHRhcmdldCkgPT0gbnVsbCkgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5zdWJJbmZvLmhpZGRlbikpXHJcbiAgICAgICAgICAgIHRhcmdldCA9IGluZGV4RGVtYW5nbGVyKGluZGV4TWFuZ2xlcih0YXJnZXQpIC0gMSk7XHJcblxyXG4gICAgICAgIHJldHVybiB0YXJnZXQgPCBsb3dlciA/IGluZGV4RGVtYW5nbGVyKGxvd2VyKSA6IHRhcmdldDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gMSkge1xyXG4gICAgICAgIHdoaWxlICgodGFyZ2V0IDw9IHVwcGVyICYmIGNoaWxkcmVuLmdldEF0KHRhcmdldCkgPT0gbnVsbCkgfHwgISFjaGlsZHJlbi5nZXRBdCh0YXJnZXQpPy5zdWJJbmZvLmhpZGRlbilcclxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgKyAxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCA+IHVwcGVyID8gaW5kZXhEZW1hbmdsZXIodXBwZXIpIDogdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGxvd2VyO1xyXG4gICAgfVxyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuT21pdHMgfSBmcm9tIFwiLi91c2UtY2hpbGQtbWFuYWdlclwiO1xyXG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XHJcbmltcG9ydCB7IHVzZUhhc0ZvY3VzLCBVc2VIYXNGb2N1c1BhcmFtZXRlcnMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2UtbGlzdC1uYXZpZ2F0aW9uXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5cclxuLyoqXHJcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXHJcbiAqIFxyXG4gKiBUaGlzIHJlc3VsdHMgaW4gYSBsb3Qgb2YgdGhpbmdzIHdpdGggdmVyeSBzaW1pbGFyIG5hbWVzIGFuZCBqdXN0IGNvbmZ1c2lvbiBhbGwgYXJvdW5kLiBQbGVhc2UgdXNlIGNhdXRpb24uXHJcbiAqL1xyXG5cclxuLy8gUGFyYW1ldGVycyAocGFyZW50LCByb3csIGNlbGwpXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cyB8IFwibmF2aWdhdGlvbkRpcmVjdGlvblwiLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XHJcbiAgICBDUixcclxuICAgIEtSIGV4dGVuZHMgc3RyaW5nLFxyXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxyXG4gICAgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cyxcclxuICAgIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsXHJcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxyXG4gICAgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzLFxyXG5cclxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcclxuICAgIFJ0aUNoaWxkT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsXHJcbiAgICBNY0NoaWxkT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cyxcclxuXHJcbiAgICBTdWJiZXN0SW5mb1xyXG4gICAgPiB7XHJcbiAgICBhc1BhcmVudFJvd09mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzIHwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCIsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPjtcclxuICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENSLCBLUiwgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPlxyXG5cclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmcsIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXHJcbiAgICBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQywgS0MsIExzQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cywgTWNDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4ge1xyXG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxDZWxsRWxlbWVudD47XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcbiAgICBncmlkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgIGdldEN1cnJlbnRDb2x1bW4oKTogbnVtYmVyIHwgbnVsbDtcclxuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XHJcbiAgICB1c2VHcmlkTmF2aWdhdGlvblJvdzogVXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIENSLCBDQywgS1IsIEtDPjtcclxuICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAgIGFzQ2hpbGRSb3c6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxSb3c+O1xyXG4gICAgYXNQYXJlbnRPZkNlbGxzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENlbGwsIENDLCBLQz47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlSW5mbzxSb3csIENlbGwsIENDLCBLQz4ge1xyXG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCwgQ0MsIEtDPjtcclxuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Um93PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlSW5mbzxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xyXG4gICAgZ3JpZE5hdmlnYXRpb246IHtcclxuICAgICAgICAvL3Jvd0lzVGFiYmFibGU6IGJvb2xlYW47XHJcbiAgICAgICAgLy9nZXRSb3dJc1RhYmJhYmxlKCk6IGJvb2xlYW47XHJcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZUluZm88Q2VsbD4ge1xyXG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGw+O1xyXG59XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Q1IsIEtSLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIENSPikgPT4gVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvdywgQ2VsbCwgQ0MsIEtDPjtcclxuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbCwgQ0MsIEtDLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDQz4pID0+IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbD47XHJcblxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uPFxyXG4gICAgUGFyZW50T3JSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcclxuICAgIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxyXG4gICAgUm93U3ViSW5mbyxcclxuICAgIENlbGxTdWJJbmZvLFxyXG4gICAgUm93RXh0cmFGbGFncyBleHRlbmRzIHN0cmluZyxcclxuICAgIENlbGxFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nXHJcbj4oe1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcclxuICAgIHJvdmluZ1RhYkluZGV4OiBydGksXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogbHMsXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsbixcclxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHRuXHJcbn06IFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4ge1xyXG4gICAgY29uc3QgW2N1cnJlbnRDb2x1bW4sIHNldEN1cnJlbnRDb2x1bW4sIGdldEN1cnJlbnRDb2x1bW5dID0gdXNlU3RhdGU8bnVtYmVyIHwgbnVsbD4ocnRpLmluaXRpYWxJbmRleCA/PyAwKTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzOiB1c2VMaXN0TmF2aWdhdGlvblByb3BzQXNHcmlkUGFyZW50LFxyXG4gICAgICAgIC4uLnBhcmVudExzUmV0dXJuVHlwZVxyXG4gICAgfSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgUm93U3ViSW5mbywgUm93RXh0cmFGbGFncz4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbHMsXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImJsb2NrXCIsIC4uLmxuIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG4sXHJcbiAgICB9KTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25Sb3cgPSB1c2VDYWxsYmFjazxVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUm93U3ViSW5mbywgQ2VsbFN1YkluZm8sIFJvd0V4dHJhRmxhZ3MsIENlbGxFeHRyYUZsYWdzPj4oKHsgYXNDaGlsZFJvd09mU2VjdGlvbjogYXNDaGlsZCwgYXNQYXJlbnRSb3dPZkNlbGxzOiBhc1BhcmVudCB9KSA9PiB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgdGhlIGZvY3VzU2VsZiB0aGF0IHJvdmluZ1RhYkluZGV4IGRvZXMuXHJcbiAgICAgICAgLy8gSW5zdGVhZCBvZiBmb2N1c2luZyB0aGUgZW50aXJlIHJvdywgd2UgYXNrIHRoZSBjZWxsIHRoYXQgY29ycmVzcG9uZHNcclxuICAgICAgICAvLyB0byBvdXIgY3VycmVudCBjb2x1bW4gdG8gZm9jdXMgaXRzZWxmLlxyXG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYzIgPSBnZXRDdXJyZW50Q29sdW1uKCk7XHJcbiAgICAgICAgICAgIGlmIChhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZikge1xyXG4gICAgICAgICAgICAgICAgYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChjMiA/PyAwLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCByb3dMc0NoaWxkUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3coe1xyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IGFzQ2hpbGQubWFuYWdlZENoaWxkLFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc0NoaWxkLmxpc3ROYXZpZ2F0aW9uIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzQ2hpbGQucm92aW5nVGFiSW5kZXgsIGZvY3VzU2VsZiB9LFxyXG4gICAgICAgICAgICBzdWJJbmZvOiBhc0NoaWxkLnN1YkluZm8sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHJvd0xzQ2hpbGRSZXR1cm5UeXBlO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGFiYmFibGUpIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChudWxsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFiYmFibGVdKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93THNSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248Q2VsbEVsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+KHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLmFzUGFyZW50Lm1hbmFnZWRDaGlsZHJlbiB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc1BhcmVudC5yb3ZpbmdUYWJJbmRleCB9LFxyXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5hc1BhcmVudC5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJpbmxpbmVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC50eXBlYWhlYWROYXZpZ2F0aW9uLCBub1R5cGVhaGVhZDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC5saXN0TmF2aWdhdGlvbiB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHMsIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9IH0gPSByb3dMc1JldHVyblR5cGU7XHJcblxyXG4gICAgICAgIC8vY29uc3Qgcm93SGlkZGVuID0gISFhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmhpZGRlbjtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBzdWJJbmZvLCBoYXNGb2N1czogeyBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCAuLi5oYXNGb2N1cyB9LCBtYW5hZ2VkQ2hpbGQsIGxpc3ROYXZpZ2F0aW9uOiBscywgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmOiBmcywgLi4ucnRpIH0gfSkgPT4ge1xyXG4gICAgICAgICAgICAvL3J0aS5oaWRkZW4gfHwgcm93SGlkZGVuO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIGlmIChmcylcclxuICAgICAgICAgICAgICAgICAgICBmcygpO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIChydGlfY2VsbF9yZXQuZ2V0RWxlbWVudCgpIGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik/LmZvY3VzPy4oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIC8qY29uc3QgYmx1clNlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnMpXHJcbiAgICAgICAgICAgICAgICAgICAgYnMoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5ibHVyPy4oKTtcclxuICAgICAgICAgICAgfSk7Ki9cclxuICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLFxyXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldFxyXG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Db2x1bW4yKHtcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogbWFuYWdlZENoaWxkLFxyXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4ubHMgfSxcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZiwgLi4ucnRpIH0sXHJcbiAgICAgICAgICAgICAgICBzdWJJbmZvXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDZWxsRWxlbWVudD4oe1xyXG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZm9jdXNlZCwgcHJldik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgLi4uaGFzRm9jdXNcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZVdpdGhIb29rczxDZWxsRWxlbWVudD4gPSB7XHJcbiAgICAgICAgICAgICAgICBncmlkTmF2aWdhdGlvbjogeyBnZXRDdXJyZW50Q29sdW1uIH0sXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0LFxyXG4gICAgICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsUHJvcHM6IGZ1bmN0aW9uIDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbEVsZW1lbnQ+Pihwcm9wczogUCkgeyByZXR1cm4gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHModXNlSGFzRm9jdXNQcm9wcyhwcm9wcykpKTsgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gcmV0O1xyXG5cclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+ID0ge1xyXG4gICAgICAgICAgICBhc1BhcmVudE9mQ2VsbHM6IHtcclxuICAgICAgICAgICAgICAgIGxpbmVhck5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcm93THNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiByb3dMc1JldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcclxuXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGFzQ2hpbGRSb3c6IHJvd0xzQ2hpbGRSZXR1cm5UeXBlLFxyXG5cclxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsLFxyXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvd0VsZW1lbnQ+Pihwcm9wczogUCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzKHByb3BzKTtcclxuICAgICAgICAgICAgICAgIHJldC50YWJJbmRleCA9IC0xO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgIGdldEN1cnJlbnRDb2x1bW4sXHJcbiAgICAgICAgICAgIGN1cnJlbnRDb2x1bW5cclxuICAgICAgICB9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHBhcmVudExzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHBhcmVudExzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3csXHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogdXNlTGlzdE5hdmlnYXRpb25Qcm9wc0FzR3JpZFBhcmVudCxcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUludGVydmFsIHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuXG4gICAgICovXG4gICAgaW50ZXJ2YWw6IG51bWJlciB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjayB9OiBVc2VJbnRlcnZhbCkge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZ2V0SW50ZXJ2YWwgPSB1c2VTdGFibGVHZXR0ZXIoaW50ZXJ2YWwpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCgpO1xuICAgICAgICBsZXQgbGFzdERlbGF5VXNlZCA9IGludGVydmFsO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyB0aGF0IGNsZWFycyBhbmQgcmVzZXRzIHRoZSBpbnRlcnZhbCBpZiBpdCBjaGFuZ2VzLlxuICAgICAgICBjb25zdCBhZGp1c3RhYmxlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFibGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEludGVydmFsID0gZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgIT0gbGFzdERlbGF5VXNlZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHNldEludGVydmFsKGFkanVzdGFibGVDYWxsYmFjaywgbGFzdERlbGF5VXNlZCA9IGN1cnJlbnRJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZSA9IHNldEludGVydmFsKGFkanVzdGFibGVDYWxsYmFjaywgaW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChoYW5kbGUpO1xuICAgIH0sIFtdKTtcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlSW50ZXJ2YWwgfSBmcm9tIFwiLi4vLi5cIjtcblxuXG5leHBvcnQgY29uc3QgRGVtb1VzZUludGVydmFsID0gKCkgPT4ge1xuICAgIGNvbnN0IFtpbnRlcnZhbCwgc2V0SW50ZXJ2YWxdID0gdXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBbZmlyZUNvdW50LCBzZXRGaXJlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjazogKCkgPT4gc2V0RmlyZUNvdW50KGkgPT4gKytpKSB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+SW50ZXJ2YWwgZHVyYXRpb246IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2ludGVydmFsfSBvbklucHV0PXtlID0+IHNldEludGVydmFsKGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5UaGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIHtmaXJlQ291bnR9IHRpbWV7ZmlyZUNvdW50ID09PSAxID8gXCJcIiA6IFwic1wifS48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgbWVtbywgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi4vLi4vdXNlLXN0YXRlXCI7XHJcblxyXG5cclxuY29uc3QgUmFuZG9tV29yZHMgPSBcIkxvcmVtIGlwc3VtIGRvbG9yIHNpdCBhbWV0LCBjb25zZWN0ZXR1ciBhZGlwaXNjaW5nIGVsaXQsIHNlZCBkbyBlaXVzbW9kIHRlbXBvciBpbmNpZGlkdW50IHV0IGxhYm9yZSBldCBkb2xvcmUgbWFnbmEgYWxpcXVhLiBVdCBlbmltIGFkIG1pbmltIHZlbmlhbSwgcXVpcyBub3N0cnVkIGV4ZXJjaXRhdGlvbiB1bGxhbWNvIGxhYm9yaXMgbmlzaSB1dCBhbGlxdWlwIGV4IGVhIGNvbW1vZG8gY29uc2VxdWF0LiBEdWlzIGF1dGUgaXJ1cmUgZG9sb3IgaW4gcmVwcmVoZW5kZXJpdCBpbiB2b2x1cHRhdGUgdmVsaXQgZXNzZSBjaWxsdW0gZG9sb3JlIGV1IGZ1Z2lhdCBudWxsYSBwYXJpYXR1ci4gRXhjZXB0ZXVyIHNpbnQgb2NjYWVjYXQgY3VwaWRhdGF0IG5vbiBwcm9pZGVudCwgc3VudCBpbiBjdWxwYSBxdWkgb2ZmaWNpYSBkZXNlcnVudCBtb2xsaXQgYW5pbSBpZCBlc3QgbGFib3J1bS5cIi5zcGxpdChcIiBcIik7XHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcclxuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XHJcbn1cclxuXHJcblxyXG5jb25zdCBSb3ZpbmdDaGlsZENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxIVE1MTElFbGVtZW50LCB7fSwgc3RyaW5nPj4obnVsbCEpXHJcbmV4cG9ydCBjb25zdCBEZW1vVXNlUm92aW5nVGFiSW5kZXggPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCBbc2VsZWN0aW9uTW9kZSwgc2V0U2VsZWN0aW9uTW9kZV0gPSB1c2VTdGF0ZShcImZvY3VzXCIgYXMgXCJmb2N1c1wiIHwgXCJhY3RpdmF0aW9uXCIpO1xyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSgxMCk7XHJcbiAgICBjb25zdCBbc2VsZWN0ZWRJbmRleCwgc2V0U2VsZWN0ZWRJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFt0YWJiYWJsZUluZGV4LCBzZXRMb2NhbFRhYmJhYmxlSW5kZXhdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LFxyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcclxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCB9LFxyXG4gICAgICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsgc2h1ZmZsZSB9LFxyXG4gICAgfSA9IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248SFRNTFVMaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwge30sIHN0cmluZz4oe1xyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHt9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IG9uVGFiYmFibGVJbmRleENoYW5nZTogdXNlQ2FsbGJhY2soKGluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB7IGlmIChpbmRleCAhPSBudWxsKSBzZXRMb2NhbFRhYmJhYmxlSW5kZXgoaW5kZXgpOyB9LCBbXSkgfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgb25TZWxlY3RlZEluZGV4Q2hhbmdlOiAoZSwgaSkgPT4gc2V0U2VsZWN0ZWRJbmRleChpKSB9LFxyXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7ICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8aDI+S2V5Ym9hcmQgJmFtcDsgTGlzdCBOYXZpZ2F0aW9uPC9oMj5cclxuICAgICAgICAgICAgPGgzPjxjb2RlPnVzZVJvdmluZ1RhYkluZGV4PC9jb2RlPjwvaDM+XHJcblxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIE5hdGl2ZSBIVE1MIGVsZW1lbnRzIG9mZmVyIGZhbnRhc3RpYyBrZXlib2FyZCBhY2Nlc3NhYmlsaXR5LCBidXQgY292ZXIgYSByZWxhdGl2ZWx5IGxpbWl0ZWQgbnVtYmVyIG9mIHVzZSBjYXNlcy5cclxuICAgICAgICAgICAgICAgIFRoZXJlIGlzIG5vIG5hdGl2ZSBIVE1MIHRyZWUgZWxlbWVudCwgZm9yIGV4YW1wbGUsIHRoYXQgYWxsb3dzIGtleWJvYXJkIG5hdmlnYXRpb24gb2YgaXRzIGl0ZW1zLFxyXG4gICAgICAgICAgICAgICAgbm9yIGlzIGl0IHBvc3NpYmxlIHRvIGNvbWJpbmUgdGhlIGtleWJvYXJkIG5hdmlnYXRpb24gYmVoYXZpb3Igb2YgYSA8Y29kZT57XCI8c2VsZWN0PlwifTwvY29kZT4gbWVudSB3aXRoIHRoZSBtZW51IGluIGEgZHJhd2VyIGNvbXBvbmVudC48L3A+XHJcblxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIFdoZW4gY29taW5nIGFjcm9zcyBhIExpc3Qgb3IgYSBNZW51IG9yIGEgUmFkaW9Hcm91cCBvciBhIFRvZ2dsZUJ1dHRvbkdyb3VwIG9yIGFueSBvdGhlciBcIm9uZSBjb21wb25lbnQgbWFkZSB1cCBvZiBjaGlsZCBjb21wb25lbnRzXCIsIHRoZSB1c3VhbCBleHBlY3RlZCBiZWhhdmlvcixcclxuICAgICAgICAgICAgICAgIGF0IGxlYXN0IG5hdGl2ZWx5LCBpcyB0aGF0IHRhYmJpbmcgaW50byB0aGUgY29tcG9uZW50IGlzIG9uZSBhY3Rpb24sIGFuZCB0YWJiaW5nIG91dCBpcyBhbm90aGVyLiAgTmF2aWdhdGluZyA8ZW0+d2l0aGluPC9lbT4gdGhlIGNvbXBvbmVudCBpcyBkb25lIHdpdGggdGhlIGFycm93IGtleXMgb3Igb3RoZXIgbWV0aG9kcy5cclxuICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8cD5cclxuICAgICAgICAgICAgICAgIFRoaXMgaXMgaW1wb3J0YW50IGJvdGggZm9yIGFjY2Vzc2FiaWxpdHksIGJ1dCBhbHNvIGp1c3QgZm9yIGdlbmVyYWwgdXNhYmlsaXR5LiAgV2hlbiB0YWJiaW5nIGJhY2sgYW5kIGZvcnRoLCB0aGUgYWJpbGl0eSB0byBza2lwIGEgbG9uZyBsaXN0IHdpdGhvdXQgbmVlZGluZyB0byB0cnVkZ2UgdGhyb3VnaCA8ZW0+ZXZlcnkgb25lPC9lbT4gb2YgaXRzIGNoaWxkIGVsZW1lbnRzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQuXHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb248L2NvZGU+IHdyYXBzIHVwIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGEgZmV3IGhvb2tzICg8Y29kZT51c2VSb3ZpbmdUYWJJbmRleDwvY29kZT4sIDxjb2RlPnVzZUxpbmVhck5hdmlnYXRpb248L2NvZGU+LCA8Y29kZT51c2VUeXBlYWhlYWROYXZpZ2F0aW9uPC9jb2RlPilcclxuICAgICAgICAgICAgICAgIHRvIGFsbG93IGZvciBBUklBLWNvbXBsaWFudCBuYXZpZ2F0aW9uIG9mIGxpc3RzIGFuZCBvdGhlciBzaW1pbGFyIGNvbXBvbmVudHMuICBGb3IgbW9yZSBhZHZhbmNlZCB1c2UgY2FzZXMsIHlvdSBjYW4gdXNlIHRoZSBvdGhlciBob29rcyBpbmRpdmlkdWFsbHkuXHJcbiAgICAgICAgICAgIDwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb248L2NvZGU+IChhbmQgPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+KSBpbnRlcm5hbGx5IHVzZSA8Y29kZT51c2VDaGlsZE1hbmFnZXI8L2NvZGU+LCB3aGljaCBpcyBob3cgdGhlIGNoaWxkIGVsZW1lbnRzIGFuZCB0aGUgcGFyZW50IGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cclxuICAgICAgICAgICAgICAgIFRoaXMgbWVhbnMgdGhlcmUgYXJlIHZpcnR1YWxseSBubyByZXN0cmljdGlvbnMgb24gaG93IHRoZSBET00gaXMgc2V0IHVwIGFzIGxvbmcgYXMgeW91IGNhbiBwcm92aWRlIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSA8Y29kZT51c2VMaXN0TmF2aWdhdGlvbkNoaWxkPC9jb2RlPiBob29rIHRoYXQncyByZXR1cm5lZCwgdXN1YWxseSB3aXRoIGEgc2ltcGxlIDxjb2RlPkNvbnRleHQ8L2NvZGU+LlxyXG4gICAgICAgICAgICAgICAgSWYgdGhlIGNoaWxkIGVsZW1lbnQgaXRzZWxmIGhhcyBhIGZvY3VzYWJsZSBlbGVtZW50LCBsaWtlIGEgYnV0dG9uLCBpdCBjYW4gYWxzbyBiZSB3aXJlZCB1cCB0byBkaXNhYmxlIGl0c2VsZlxyXG4gICAgICAgICAgICAgICAgRmVlbCBmcmVlIHRvIG5lc3QgdGhlbSB0b28sIGFzIGxvbmcgYXMgeW91IGFyZSBhd2FyZSBvZiB5b3VyIDxjb2RlPkNvbnRleHQ8L2NvZGU+IG1hbmFnZW1lbnQgKGkuZS4gcmVtZW1iZXIgdGhhdCB5b3UgbmVlZCB0byBjcmVhdGUgYSBuZXcgPGNvZGU+Q29udGV4dDwvY29kZT4gZm9yIGVhY2ggdXNlIGNhc2UpLlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDxsYWJlbD4jIG9mIGl0ZW1zPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17Y291bnR9IG1pbj17MH0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0Q291bnQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpIH19IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzaHVmZmxlKGNoaWxkcmVuKX0+U2h1ZmZsZTwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8bGFiZWw+VGFiYmFibGUgaW5kZXg6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RhYmJhYmxlSW5kZXggPz8gdW5kZWZpbmVkfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRUYWJiYWJsZUluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyLCBmYWxzZSk7IH19IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPlNlbGVjdGVkIGluZGV4OiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtzZWxlY3RlZEluZGV4ID8/IHVuZGVmaW5lZH0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0U2VsZWN0ZWRJbmRleChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcik7IH19IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPlNlbGVjdGlvbiBtb2RlOlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCBuYW1lPVwicnRpLWRlbW8tc2VsZWN0aW9uLW1vZGVcIiB0eXBlPVwicmFkaW9cIiBjaGVja2VkPXtzZWxlY3Rpb25Nb2RlID09ICdmb2N1cyd9IG9uSW5wdXQ9e2UgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IHNldFNlbGVjdGlvbk1vZGUoXCJmb2N1c1wiKTsgfX0gLz4gT24gZm9jdXM8L2xhYmVsPlxyXG4gICAgICAgICAgICAgICAgPGxhYmVsPjxpbnB1dCBuYW1lPVwicnRpLWRlbW8tc2VsZWN0aW9uLW1vZGVcIiB0eXBlPVwicmFkaW9cIiBjaGVja2VkPXtzZWxlY3Rpb25Nb2RlID09ICdhY3RpdmF0aW9uJ30gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0U2VsZWN0aW9uTW9kZShcImFjdGl2YXRpb25cIik7IH19IC8+IE9uIGFjdGl2YXRpb24gKGNsaWNrLCB0YXAsIEVudGVyLCBTcGFjZSwgZXRjLik8L2xhYmVsPlxyXG4gICAgICAgICAgICA8L2xhYmVsPlxyXG5cclxuICAgICAgICAgICAgPFJvdmluZ0NoaWxkQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkfT5cclxuICAgICAgICAgICAgICAgIDx1bCB7Li4uKHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyh7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9Vc2VSb3ZpbmdUYWJJbmRleENoaWxkIGluZGV4PXtpfSBrZXk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9KSgpKVxyXG4gICAgICAgICAgICAgICAgfSkpfT48L3VsPlxyXG4gICAgICAgICAgICA8L1JvdmluZ0NoaWxkQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICAgICAge2N1cnJlbnRUeXBlYWhlYWQgJiYgPGRpdj5UeXBlYWhlYWQ6IHtjdXJyZW50VHlwZWFoZWFkfTwvZGl2Pn1cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pXHJcblxyXG5jb25zdCBfUHJlZml4ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xyXG5jb25zdCBEZW1vVXNlUm92aW5nVGFiSW5kZXhDaGlsZCA9IG1lbW8oKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XHJcbiAgICBjb25zdCBoaWRkZW4gPSAoaW5kZXggPT0gNyk7XHJcbiAgICBjb25zdCBbcmFuZG9tV29yZF0gPSB1c2VTdGF0ZSgoKSA9PiBSYW5kb21Xb3Jkc1tpbmRleC8qTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKFJhbmRvbVdvcmRzLmxlbmd0aCAtIDEpKSovXSk7XHJcbiAgICBjb25zdCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkID0gdXNlQ29udGV4dChSb3ZpbmdDaGlsZENvbnRleHQpO1xyXG4gICAgY29uc3QgdGV4dCA9IGAke3JhbmRvbVdvcmR9IFRoaXMgaXMgaXRlbSAjJHtpbmRleH0ke2hpZGRlbiA/IFwiIChoaWRkZW4pXCIgOiBcIlwifWA7XHJcbiAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcywgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSwgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkIH0gfSA9IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW4gfSwgc3ViSW5mbzoge30sIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50IH0gfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMoe30pO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8bGkgey4uLnByb3BzfT57dGV4dH0gKHt0YWJiYWJsZSA/IFwiVGFiYmFibGVcIiA6IFwiTm90IHRhYmJhYmxlXCJ9LCB7c2VsZWN0ZWQgPyBcIlNlbGVjdGVkXCIgOiBcIk5vdCBzZWxlY3RlZFwifSk8aW5wdXQgey4uLnVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wcyh7IHR5cGU6IFwibnVtYmVyXCIgfSkgYXMgYW55fSBzdHlsZT17eyB3aWR0aDogXCI1Y2hcIiB9fSAvPjwvbGk+XHJcbiAgICApXHJcbn0pKTsiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4uLy4uXCI7XG5cblxuZXhwb3J0IGNvbnN0IERlbW9Vc2VUaW1lb3V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IFt0aW1lb3V0LCBzZXRUaW1lb3V0XSA9IHVzZVN0YXRlKDEwMDApO1xuICAgIGNvbnN0IFt0cmlnZ2VySW5kZXgsIHNldFRyaWdnZXJJbmRleF0gPSB1c2VTdGF0ZShcIlwiKTtcblxuICAgIGNvbnN0IFtmaXJlQ291bnQsIHNldEZpcmVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0LCB0cmlnZ2VySW5kZXgsIGNhbGxiYWNrOiAoKSA9PiBzZXRGaXJlQ291bnQoaSA9PiArK2kpIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGxhYmVsPlRpbWVvdXQgZHVyYXRpb246IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RpbWVvdXR9IG9uSW5wdXQ9e2UgPT4gc2V0VGltZW91dChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5SZWZyZXNoIGtleTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdmFsdWU9e3RyaWdnZXJJbmRleH0gb25JbnB1dD17ZSA9PiBzZXRUcmlnZ2VySW5kZXgoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5UaGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIHtmaXJlQ291bnR9IHRpbWV7ZmlyZUNvdW50ID09PSAxID8gXCJcIiA6IFwic1wifS48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgcmVuZGVyIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBbmltYXRpb25GcmFtZSwgdXNlQXN5bmNIYW5kbGVyLCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSwgdXNlRWxlbWVudFNpemUsIHVzZUZvY3VzVHJhcCwgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YXRlIH0gZnJvbSBcIi4uXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRTaXplIH0gZnJvbSBcIi4uL3VzZS1lbGVtZW50LXNpemVcIjtcclxuaW1wb3J0IHsgdXNlR3JpZE5hdmlnYXRpb24sIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbCwgVXNlR3JpZE5hdmlnYXRpb25Sb3cgfSBmcm9tIFwiLi4vdXNlLWdyaWQtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IERlbW9Vc2VJbnRlcnZhbCB9IGZyb20gXCIuL2RlbW9zL3VzZS1pbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBEZW1vVXNlUm92aW5nVGFiSW5kZXggfSBmcm9tIFwiLi9kZW1vcy91c2Utcm92aW5nLXRhYi1pbmRleFwiO1xyXG5pbXBvcnQgeyBEZW1vVXNlVGltZW91dCB9IGZyb20gXCIuL2RlbW9zL3VzZS10aW1lb3V0XCI7XHJcblxyXG5jb25zdCBSYW5kb21Xb3JkcyA9IFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlwiLnNwbGl0KFwiIFwiKTtcclxuXHJcblxyXG5cclxuY29uc3QgRGVtb1VzZURyb3BwYWJsZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IHsgZHJvcHBlZEZpbGVzLCBkcm9wcGVkU3RyaW5ncywgZmlsZXNGb3JDb25zaWRlcmF0aW9uLCBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgdXNlRHJvcHBhYmxlUHJvcHMsIGRyb3BFcnJvciB9ID0gdXNlRHJvcHBhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGVmZmVjdDogXCJjb3B5XCIgfSk7XHJcblxyXG4gICAgY29uc3QgeyByZWY6IF9yZWYgfSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KHt9LCB7IHJlZjogdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwhKSB9KVxyXG5cclxuICAgIGNvbnN0IHAgPSB1c2VEcm9wcGFibGVQcm9wcyh7IGNsYXNzTmFtZTogXCJkZW1vIGRyb3BwYWJsZVwiIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiB7Li4ucH0+XHJcblxyXG4gICAgICAgICAgICB7ZHJvcHBlZFN0cmluZ3MgIT0gbnVsbCAmJiA8ZGl2PkRhdGEgZHJvcHBlZDogPHVsPnsoT2JqZWN0LmVudHJpZXMoZHJvcHBlZFN0cmluZ3MpIGFzIFtrZXlvZiB0eXBlb2Ygc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHN0cmluZ11bXSkubWFwKChbdHlwZSwgdmFsdWVdKSA9PiA8bGk+e3R5cGV9OiB7dmFsdWV9PC9saT4pfTwvdWw+PC9kaXY+fVxyXG4gICAgICAgICAgICB7ZHJvcHBlZEZpbGVzICE9IG51bGwgJiYgPGRpdj5GaWxlcyBkcm9wcGVkOiA8dGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGhlYWQ+PHRyPjx0aD5OYW1lPC90aD48dGg+U2l6ZTwvdGg+PHRoPlR5cGU8L3RoPjx0aD5MYXN0IG1vZGlmaWVkPC90aD48L3RyPjwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+e2Ryb3BwZWRGaWxlcy5tYXAoZiA9PiA8dHI+PHRkPntmLm5hbWV9PC90ZD57Zi5kYXRhLmJ5dGVMZW5ndGh9PHRkPntmLnR5cGV9PC90ZD48dGQ+e25ldyBEYXRlKGYubGFzdE1vZGlmaWVkID8/IDApfTwvdGQ+PC90cj4pfTwvdGJvZHk+XHJcbiAgICAgICAgICAgIDwvdGFibGU+PC9kaXY+fVxyXG4gICAgICAgICAgICA8aHIgLz5cclxuXHJcbiAgICAgICAgICAgIHtzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiAhPSBudWxsICYmIDxkaXY+RGF0YSBiZWluZyBjb25zaWRlcmVkOiA8dWw+e0FycmF5LmZyb20oc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24pLm1hcCh0eXBlID0+IDxsaT57dHlwZX08L2xpPil9PC91bD48L2Rpdj59XHJcbiAgICAgICAgICAgIHtmaWxlc0ZvckNvbnNpZGVyYXRpb24gIT0gbnVsbCAmJiA8ZGl2PkZpbGVzIGJlaW5nIGNvbnNpZGVyZWQ6IDx1bD57ZmlsZXNGb3JDb25zaWRlcmF0aW9uLm1hcChmID0+IDxsaT57SlNPTi5zdHJpbmdpZnkoZil9PC9saT4pfTwvdWw+PC9kaXY+fVxyXG5cclxuICAgICAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgICAgIHtkcm9wRXJyb3IgJiYgPGRpdj57ZHJvcEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkcm9wRXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGRyb3BFcnJvcil9PC9kaXY+fVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5jb25zdCBEZW1vVXNlRHJhZ2dhYmxlID0gKCkgPT4ge1xyXG4gICAgY29uc3QgeyB1c2VEcmFnZ2FibGVQcm9wcyB9ID0gdXNlRHJhZ2dhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGRhdGE6IHsgXCJ0ZXh0L3BsYWluXCI6IFwiVGhpcyBpcyBjdXN0b20gZHJhZ2dhYmxlIGNvbnRlbnQgb2YgdHlwZSB0ZXh0L3BsYWluLlwiIH0gfSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiB7Li4udXNlRHJhZ2dhYmxlUHJvcHMoeyBjbGFzc05hbWU6IFwiZGVtb1wiIH0pfT5cclxuICAgICAgICAgICAgRHJhZ2dhYmxlIGNvbnRlbnRcclxuICAgICAgICA8L2Rpdj4pXHJcbn1cclxuXHJcbmNvbnN0IERlbW9Vc2VFbGVtZW50U2l6ZUFuaW1hdGlvbiA9ICgpID0+IHtcclxuICAgIGNvbnN0IFtoZWlnaHQsIHNldEhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFthbmdsZSwgc2V0QW5nbGVdID0gdXNlU3RhdGUoMCk7XHJcbiAgICB1c2VBbmltYXRpb25GcmFtZSh7XHJcbiAgICAgICAgY2FsbGJhY2s6IChfbXMpID0+IHtcclxuICAgICAgICAgICAgc2V0QW5nbGUoYSA9PiBhICsgMC4wMSlcclxuICAgICAgICAgICAgc2V0SGVpZ2h0KChNYXRoLnNpbihhbmdsZSkgKyAxKSAvIDAuNSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgW2VsZW1lbnRTaXplLCBzZXRFbGVtZW50U2l6ZV0gPSB1c2VTdGF0ZTxFbGVtZW50U2l6ZSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcyB9ID0gdXNlRWxlbWVudFNpemU8SFRNTERpdkVsZW1lbnQ+KHsgb25TaXplQ2hhbmdlOiBzZXRFbGVtZW50U2l6ZSB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgey4uLnVzZUVsZW1lbnRTaXplUHJvcHMoeyByZWY6IHVuZGVmaW5lZCwgY2xhc3NOYW1lOiBcImRlbW9cIiwgc3R5bGU6IHsgaGVpZ2h0OiBgJHsoaGVpZ2h0ICogMTAwKSArIDEwMH1weGAgfSB9KX0+XHJcbiAgICAgICAgICAgIDxwcmU+e0pTT04uc3RyaW5naWZ5KGVsZW1lbnRTaXplLCBudWxsLCAyKX08L3ByZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcblxyXG5jb25zdCBEZW1vVXNlRm9jdXNUcmFwID0gbWVtbygoeyBkZXB0aCB9OiB7IGRlcHRoPzogbnVtYmVyIH0pID0+IHtcclxuXHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxIVE1MRGl2RWxlbWVudD4oeyB0cmFwQWN0aXZlOiBhY3RpdmUgfSk7XHJcbiAgICAvL2NvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhQcm9wcyB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTFVMaXN0RWxlbWVudCwgUm92aW5nVGFiSW5kZXhDaGlsZEluZm8+KHsgdGFiYmFibGVJbmRleCwgZm9jdXNPbkNoYW5nZTogZmFsc2UgfSk7XHJcblxyXG4gICAgY29uc3QgZGl2UHJvcHMgPSB1c2VGb2N1c1RyYXBQcm9wcyh7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZm9jdXMtdHJhcC1kZW1vXCIgfSk7XHJcbiAgICBpZiAoZGVwdGggPT0gMilcclxuICAgICAgICByZXR1cm4gPGRpdiAvPjtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLmRpdlByb3BzfSA+XHJcbiAgICAgICAgICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcENoaWxkIGFjdGl2ZT17YWN0aXZlfSBzZXRBY3RpdmU9e3NldEFjdGl2ZX0gZGVwdGg9e2RlcHRoID8/IDB9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5cclxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcENoaWxkID0gbWVtbygoeyBzZXRBY3RpdmUsIGFjdGl2ZSB9OiB7IGFjdGl2ZTogYm9vbGVhbiwgc2V0QWN0aXZlOiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkLCBkZXB0aDogbnVtYmVyIH0pID0+IHtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAxPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDI8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbj5CdXR0b24gMzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XHJcblxyXG4gICAgICAgIDwvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5jb25zdCBEZW1vVXNlQXN5bmNIYW5kbGVyMSA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFt0aW1lb3V0LCBzZXRUaW1lb3V0XSA9IHVzZVN0YXRlKDEwMDApO1xyXG4gICAgY29uc3QgW2RlYm91bmNlLCBzZXREZWJvdW5jZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtzaG91bGRUaHJvdywgc2V0U2hvdWxkVGhyb3csIGdldFNob3VsZFRocm93XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtkaXNhYmxlQ29uc2VjdXRpdmUsIHNldERpc2FibGVDb25zZWN1dGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgYXN5bmNPbkNsaWNrID0gKChfdjogdm9pZCwgX2U6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGdldFNob3VsZFRocm93KCkgPyByZWplY3QoKSA6IHJlc29sdmUoKSwgdGltZW91dCkpKTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjYWxsQ291bnQsXHJcbiAgICAgICAgc2V0dGxlQ291bnQsXHJcbiAgICAgICAgaGFzQ2FwdHVyZSxcclxuICAgICAgICBzeW5jSGFuZGxlcixcclxuICAgICAgICBwZW5kaW5nLFxyXG4gICAgICAgIGhhc0Vycm9yLFxyXG4gICAgICAgIHJlamVjdENvdW50LFxyXG4gICAgICAgIHJlc29sdmVDb3VudFxyXG4gICAgfSA9IHVzZUFzeW5jSGFuZGxlcjxoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+LCB2b2lkPihhc3luY09uQ2xpY2ssIHsgY2FwdHVyZTogKCkgPT4geyB9LCBkZWJvdW5jZTogZGVib3VuY2UgPT0gMCA/IHVuZGVmaW5lZCA6IGRlYm91bmNlIH0pO1xyXG5cclxuICAgIGNvbnN0IG9uQ2xpY2sgPSBwZW5kaW5nID8gdW5kZWZpbmVkIDogc3luY0hhbmRsZXI7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uQ2xpY2s9e29uQ2xpY2t9PkNsaWNrIG1lITwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8bGFiZWw+U2xlZXAgZm9yOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aW1lb3V0fSBvbklucHV0PXtlID0+IHNldFRpbWVvdXQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5UaHJvdyBhbiBlcnJvciA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17c2hvdWxkVGhyb3d9IG9uSW5wdXQ9e2UgPT4gc2V0U2hvdWxkVGhyb3coZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5EaXNhYmxlZCB3aGlsZSBwZW5kaW5nIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e2UgPT4gc2V0RGlzYWJsZUNvbnNlY3V0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8bGFiZWw+RGVib3VuY2U6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2RlYm91bmNlfSBvbklucHV0PXtlID0+IHNldERlYm91bmNlKGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8dGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+RmllbGQ8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+Y2FsbENvdW50PC90ZD48dGQ+e2NhbGxDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5zZXR0bGVDb3VudDwvdGQ+PHRkPntzZXR0bGVDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZXNvbHZlQ291bnQ8L3RkPjx0ZD57cmVzb2x2ZUNvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnJlamVjdENvdW50PC90ZD48dGQ+e3JlamVjdENvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmhhc0Vycm9yPC90ZD48dGQ+e2hhc0Vycm9yLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzQ2FwdHVyZTwvdGQ+PHRkPntoYXNDYXB0dXJlLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuY29uc3QgRGVtb1VzZUFzeW5jSGFuZGxlcjIgPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcclxuICAgIGNvbnN0IFtkZWJvdW5jZSwgc2V0RGVib3VuY2VdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2hvdWxkVGhyb3csIHNldFNob3VsZFRocm93LCBnZXRTaG91bGRUaHJvd10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IFt0ZXh0LCBzZXRUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG5cclxuICAgIGNvbnN0IG9uSW5wdXRBc3luYyA9IGFzeW5jICh2OiBzdHJpbmcsIF9lOiBhbnkpID0+IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoZ2V0U2hvdWxkVGhyb3coKSkge1xyXG4gICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRleHQodik7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0KSk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGNhbGxDb3VudCxcclxuICAgICAgICBzZXR0bGVDb3VudCxcclxuICAgICAgICBoYXNDYXB0dXJlLFxyXG4gICAgICAgIHN5bmNIYW5kbGVyLFxyXG4gICAgICAgIGN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgIHBlbmRpbmcsXHJcbiAgICAgICAgaGFzRXJyb3IsXHJcbiAgICAgICAgcmVqZWN0Q291bnQsXHJcbiAgICAgICAgcmVzb2x2ZUNvdW50XHJcbiAgICB9ID0gdXNlQXN5bmNIYW5kbGVyPGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sIHN0cmluZz4ob25JbnB1dEFzeW5jLCB7IGNhcHR1cmU6IChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGUuY3VycmVudFRhcmdldC52YWx1ZSB9LCBkZWJvdW5jZTogZGVib3VuY2UgPT0gMCA/IHVuZGVmaW5lZCA6IGRlYm91bmNlIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8bGFiZWw+RGVtbyB0ZXh0OiA8aW5wdXQgdmFsdWU9e2hhc0NhcHR1cmUgPyBjdXJyZW50Q2FwdHVyZSA6IHRleHR9IGRpc2FibGVkPXtwZW5kaW5nICYmIGRpc2FibGVDb25zZWN1dGl2ZX0gb25JbnB1dD17c3luY0hhbmRsZXJ9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD5TbGVlcCBmb3I6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RpbWVvdXR9IG9uSW5wdXQ9e2UgPT4gc2V0VGltZW91dChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPlRocm93IGFuIGVycm9yIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzaG91bGRUaHJvd30gb25JbnB1dD17ZSA9PiBzZXRTaG91bGRUaHJvdyhlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPkRpc2FibGVkIHdoaWxlIHBlbmRpbmcgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e2Rpc2FibGVDb25zZWN1dGl2ZX0gb25JbnB1dD17ZSA9PiBzZXREaXNhYmxlQ29uc2VjdXRpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5EZWJvdW5jZTogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17ZGVib3VuY2V9IG9uSW5wdXQ9e2UgPT4gc2V0RGVib3VuY2UoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDx0YWJsZT5cclxuICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5GaWVsZDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5WYWx1ZTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5jYWxsQ291bnQ8L3RkPjx0ZD57Y2FsbENvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnNldHRsZUNvdW50PC90ZD48dGQ+e3NldHRsZUNvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnJlc29sdmVDb3VudDwvdGQ+PHRkPntyZXNvbHZlQ291bnR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVqZWN0Q291bnQ8L3RkPjx0ZD57cmVqZWN0Q291bnR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzRXJyb3I8L3RkPjx0ZD57aGFzRXJyb3IudG9TdHJpbmcoKX08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5jdXJyZW50Q2FwdHVyZTwvdGQ+PHRkPntjdXJyZW50Q2FwdHVyZX08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5cIlNhdmVkXCIgaW5wdXQ8L3RkPjx0ZD57dGV4dH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcclxuICAgIHJldHVybiB3aW5kb3cuZG9jdW1lbnQ7XHJcbn1cclxuXHJcbmNvbnN0IERlbW9Gb2N1cyA9IG1lbW8oKCkgPT4ge1xyXG4gICAgY29uc3QgW2xhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VTdGF0ZTwoRWxlbWVudCkgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IFthY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVN0YXRlPChFbGVtZW50KSB8IG51bGw+KG51bGwpO1xyXG4gICAgY29uc3QgW3dpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2ZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtsYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2xhc3RGb2N1c2VkSW5uZXIsIHNldExhc3RGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIVE1MRGl2RWxlbWVudD4oe1xyXG4gICAgICAgIGdldERvY3VtZW50LFxyXG4gICAgICAgIG9uRm9jdXNlZENoYW5nZWQ6IHNldEZvY3VzZWQsXHJcbiAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ6IHNldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlOiBzZXRBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHNldExhc3RBY3RpdmVFbGVtZW50LFxyXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZTogc2V0V2luZG93Rm9jdXNlZFxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIDxoMj51c2VIYXNGb2N1czwvaDI+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLnVzZUhhc0ZvY3VzUHJvcHMoeyBzdHlsZTogeyBib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCIgfSwgdGFiSW5kZXg6IDAgfSl9Pk91dGVyIDxkaXYgdGFiSW5kZXg9ezB9IHN0eWxlPXt7IGJvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIiB9fT5Jbm5lciBlbGVtZW50PC9kaXY+PC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgICA8dWw+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpPlN0cmljdGx5IGZvY3VzZWQ6IHtmb2N1c2VkLnRvU3RyaW5nKCl9LCB7bGFzdEZvY3VzZWQudG9TdHJpbmcoKX08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5Jbm5lciBmb2N1c2VkOiB7Zm9jdXNlZElubmVyLnRvU3RyaW5nKCl9LCB7bGFzdEZvY3VzZWRJbm5lci50b1N0cmluZygpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpPldpbmRvdyBmb2N1c2VkOiB7d2luZG93Rm9jdXNlZC50b1N0cmluZygpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpPmFjdGl2ZUVsZW1lbnQ6IHthY3RpdmVFbGVtZW50Py50ZXh0Q29udGVudH08L2xpPlxyXG4gICAgICAgICAgICAgICAgICAgIDxsaT5sYXN0QWN0aXZlRWxlbWVudDoge2xhc3RBY3RpdmVFbGVtZW50Py50ZXh0Q29udGVudH08L2xpPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApXHJcbn0pXHJcblxyXG5cclxuY29uc3QgR3JpZFJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWROYXZpZ2F0aW9uUm93PEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwge30sIHN0cmluZywgc3RyaW5nPj4obnVsbCEpO1xyXG5jb25zdCBHcmlkQ2VsbENvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxIVE1MVGFibGVDZWxsRWxlbWVudCwge30sIHN0cmluZz4+KG51bGwhKTtcclxuZXhwb3J0IGNvbnN0IERlbW9Vc2VHcmlkID0gbWVtbygoKSA9PiB7XHJcblxyXG4gICAgY29uc3QgWywgc2V0TGFzdEZvY3VzZWRJbm5lciwgX2dldExhc3RGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIVE1MVGFibGVTZWN0aW9uRWxlbWVudD4oeyBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRMYXN0Rm9jdXNlZElubmVyLCBnZXREb2N1bWVudCB9KTtcclxuICAgIGNvbnN0IHsgdXNlR3JpZE5hdmlnYXRpb25Sb3csIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMsIGdyaWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRDb2x1bW4gfSB9ID0gdXNlR3JpZE5hdmlnYXRpb248SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwge30sIHN0cmluZywgc3RyaW5nPih7XHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHt9LFxyXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHt9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIHs8ZGl2PkN1cnJlbnQgY29sdW1uOiB7Y3VycmVudENvbHVtbn08L2Rpdj59XHJcbiAgICAgICAgICAgIDx0YWJsZSB7Li4ueyBib3JkZXI6IFwiMlwiIH0gYXMge319IHN0eWxlPXt7IHdoaXRlU3BhY2U6IFwibm93cmFwXCIgfX0+XHJcblxyXG4gICAgICAgICAgICAgICAgPHRoZWFkPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPlJvdyBpcyB0YWJiYWJsZT88L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Q29sdW1uIDE8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Q29sdW1uIDI8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5IHsuLi51c2VIYXNGb2N1c1Byb3BzKHVzZUdyaWROYXZpZ2F0aW9uUHJvcHMoe30pKX0+XHJcbiAgICAgICAgICAgICAgICAgICAgPEdyaWRSb3dDb250ZXh0LlByb3ZpZGVyIHZhbHVlPXt1c2VHcmlkTmF2aWdhdGlvblJvd30+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgKytpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgPERlbW9Vc2VHcmlkUm93IGluZGV4PXtpfSBrZXk9e2l9IC8+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICAgICAgICAgIDwvR3JpZFJvd0NvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSlcclxuXHJcbmNvbnN0IF9QcmVmaXggPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XHJcbmNvbnN0IERlbW9Vc2VHcmlkUm93ID0gbWVtbygoKHsgaW5kZXggfTogeyBpbmRleDogbnVtYmVyIH0pID0+IHtcclxuICAgIGNvbnN0IFtfcmFuZG9tV29yZF0gPSB1c2VTdGF0ZSgoKSA9PiBSYW5kb21Xb3Jkc1tpbmRleC8qTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKFJhbmRvbVdvcmRzLmxlbmd0aCAtIDEpKSovXSk7XHJcbiAgICBjb25zdCB1c2VHcmlkUm93ID0gdXNlQ29udGV4dChHcmlkUm93Q29udGV4dCk7XHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wcyxcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXHJcbiAgICAgICAgYXNDaGlsZFJvdzogeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9IH0sXHJcbiAgICB9ID0gdXNlR3JpZFJvdyh7XHJcbiAgICAgICAgYXNDaGlsZFJvd09mU2VjdGlvbjogeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dDogXCJcIiB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW46IGluZGV4ID09IDMgfSwgc3ViSW5mbzoge30gfSxcclxuICAgICAgICBhc1BhcmVudFJvd09mQ2VsbHM6IHsgbGluZWFyTmF2aWdhdGlvbjoge30sIGxpc3ROYXZpZ2F0aW9uOiB7fSwgcm92aW5nVGFiSW5kZXg6IHt9LCB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7fSwgbWFuYWdlZENoaWxkcmVuOiB7fSB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzKHt9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxHcmlkQ2VsbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUdyaWROYXZpZ2F0aW9uQ2VsbH0+XHJcbiAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZUdyaWRDZWxsIGluZGV4PXtpfSBrZXk9e2l9IHJvdz17aW5kZXh9IHJvd0lzVGFiYmFibGU9e3RhYmJhYmxlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICA8L0dyaWRDZWxsQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKVxyXG59KSk7XHJcblxyXG5jb25zdCBEZW1vVXNlR3JpZENlbGwgPSAoKHsgaW5kZXgsIHJvdywgcm93SXNUYWJiYWJsZSB9OiB7IGluZGV4OiBudW1iZXIsIHJvdzogbnVtYmVyLCByb3dJc1RhYmJhYmxlOiBib29sZWFuIH0pID0+IHtcclxuICAgIGlmIChyb3cgPj0gNiAmJiByb3cgJSAyID09IDAgJiYgaW5kZXggPiAxKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGxldCBoaWRkZW5UZXh0ID0gKHJvdyA9PT0gMykgPyBcIiAocm93IGhpZGRlbilcIiA6IFwiXCJcclxuXHJcbiAgICBjb25zdCB1c2VHcmlkQ2VsbCA9IHVzZUNvbnRleHQoR3JpZENlbGxDb250ZXh0KTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZTogY2VsbElzVGFiYmFibGUgfVxyXG4gICAgfSA9IHVzZUdyaWRDZWxsKHtcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0OiBcIlwiIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4IH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuOiBmYWxzZSB9LFxyXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50IH0sXHJcbiAgICAgICAgc3ViSW5mbzoge30sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBwcm9wcyA9IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzKHt9KSBhcyBhbnk7XHJcblxyXG4gICAgY29uc3QgdCA9IChjZWxsSXNUYWJiYWJsZSA/IFwiKFRhYmJhYmxlKVwiIDogXCIoTm90IHRhYmJhYmxlKVwiKVxyXG5cclxuICAgIGlmIChpbmRleCA9PT0gMClcclxuICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30+e3Jvd0lzVGFiYmFibGUudG9TdHJpbmcoKX08L3RkPlxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgaWYgKHJvdyA8IDYgfHwgcm93ICUgMiAhPSAwKSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8dGQgey4uLnByb3BzfT5HcmlkIGNlbGwgI3tpbmRleCArIDF9IHt0fXtoaWRkZW5UZXh0fTwvdGQ+XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiA8dGQ+PGxhYmVsPjxpbnB1dCAgey4uLnByb3BzfSB0eXBlPVwiY2hlY2tib3hcIiAvPiBUZXN0IGlucHV0IHt0fXtoaWRkZW5UZXh0fTwvbGFiZWw+PC90ZD5cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gMSlcclxuICAgICAgICAgICAgICAgIHJldHVybiA8dGQgey4uLnByb3BzfSBjb2xTcGFuPXsyfT5HcmlkIGNlbGwgI3tpbmRleCArIDF9LCBzcGFuIDIge3R9e2hpZGRlblRleHR9PC90ZD5cclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgICAgIH1cclxuICAgIH1cclxufSlcclxuXHJcbmNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcclxuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZmxleFwiIHN0eWxlPXt7IGZsZXhXcmFwOiBcIndyYXBcIiB9fT5cclxuICAgICAgICA8RGVtb0ZvY3VzIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VHcmlkIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VUaW1lb3V0IC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VJbnRlcnZhbCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlUm92aW5nVGFiSW5kZXggLz5cclxuICAgICAgICA8aHIgLz5cclxuXHJcblxyXG4gICAgICAgIDxEZW1vVXNlRm9jdXNUcmFwIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VBc3luY0hhbmRsZXIxIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VBc3luY0hhbmRsZXIyIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcm9wcGFibGUgLz5cclxuICAgICAgICA8aHIgLz5cclxuICAgICAgICA8RGVtb1VzZURyYWdnYWJsZSAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlRWxlbWVudFNpemVBbmltYXRpb24gLz5cclxuICAgICAgICA8aHIgLz5cclxuICAgICAgICA8aW5wdXQgLz5cclxuICAgIDwvZGl2PlxyXG59XHJcblxyXG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xyXG59KVxyXG4iXSwibmFtZXMiOlsic2xpY2UiLCJvcHRpb25zIiwidm5vZGVJZCIsInJlcmVuZGVyUXVldWUiLCJwcmV2RGVib3VuY2UiLCJpIiwiRU1QVFlfT0JKIiwiRU1QVFlfQVJSIiwiSVNfTk9OX0RJTUVOU0lPTkFMIiwiYXNzaWduIiwib2JqIiwicHJvcHMiLCJyZW1vdmVOb2RlIiwibm9kZSIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsImNyZWF0ZUVsZW1lbnQiLCJ0eXBlIiwiY2hpbGRyZW4iLCJrZXkiLCJyZWYiLCJub3JtYWxpemVkUHJvcHMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJjYWxsIiwiZGVmYXVsdFByb3BzIiwidW5kZWZpbmVkIiwiY3JlYXRlVk5vZGUiLCJvcmlnaW5hbCIsInZub2RlIiwiY29uc3RydWN0b3IiLCJGcmFnbWVudCIsIkNvbXBvbmVudCIsImNvbnRleHQiLCJnZXREb21TaWJsaW5nIiwiY2hpbGRJbmRleCIsImluZGV4T2YiLCJzaWJsaW5nIiwidXBkYXRlUGFyZW50RG9tUG9pbnRlcnMiLCJjaGlsZCIsImJhc2UiLCJlbnF1ZXVlUmVuZGVyIiwiYyIsInB1c2giLCJwcm9jZXNzIiwiZGVib3VuY2VSZW5kZXJpbmciLCJzZXRUaW1lb3V0IiwicXVldWUiLCJzb3J0IiwiYSIsImIiLCJzb21lIiwiY29tcG9uZW50IiwiY29tbWl0UXVldWUiLCJvbGRWTm9kZSIsIm9sZERvbSIsInBhcmVudERvbSIsImRpZmYiLCJvd25lclNWR0VsZW1lbnQiLCJjb21taXRSb290IiwiZGlmZkNoaWxkcmVuIiwicmVuZGVyUmVzdWx0IiwibmV3UGFyZW50Vk5vZGUiLCJvbGRQYXJlbnRWTm9kZSIsImdsb2JhbENvbnRleHQiLCJpc1N2ZyIsImV4Y2Vzc0RvbUNoaWxkcmVuIiwiaXNIeWRyYXRpbmciLCJqIiwiY2hpbGRWTm9kZSIsIm5ld0RvbSIsImZpcnN0Q2hpbGREb20iLCJyZWZzIiwib2xkQ2hpbGRyZW4iLCJvbGRDaGlsZHJlbkxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsInJlb3JkZXJDaGlsZHJlbiIsInBsYWNlQ2hpbGQiLCJ1bm1vdW50IiwiYXBwbHlSZWYiLCJ0bXAiLCJ0b0NoaWxkQXJyYXkiLCJvdXQiLCJuZXh0RG9tIiwic2liRG9tIiwib3V0ZXIiLCJhcHBlbmRDaGlsZCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0QmVmb3JlIiwiZGlmZlByb3BzIiwiZG9tIiwibmV3UHJvcHMiLCJvbGRQcm9wcyIsImh5ZHJhdGUiLCJzZXRQcm9wZXJ0eSIsInNldFN0eWxlIiwic3R5bGUiLCJ2YWx1ZSIsInRlc3QiLCJuYW1lIiwib2xkVmFsdWUiLCJ1c2VDYXB0dXJlIiwibyIsImNzc1RleHQiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJfbGlzdGVuZXJzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50UHJveHlDYXB0dXJlIiwiZXZlbnRQcm94eSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJlIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiZXZlbnQiLCJuZXdWTm9kZSIsImlzTmV3Iiwib2xkU3RhdGUiLCJzbmFwc2hvdCIsImNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiIsInByb3ZpZGVyIiwiY29tcG9uZW50Q29udGV4dCIsInJlbmRlckhvb2siLCJjb3VudCIsIm5ld1R5cGUiLCJjb250ZXh0VHlwZSIsInByb3RvdHlwZSIsInJlbmRlciIsImRvUmVuZGVyIiwic3ViIiwic3RhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJmb3JFYWNoIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldENoaWxkQ29udGV4dCIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiZGlmZkVsZW1lbnROb2RlcyIsImRpZmZlZCIsInJvb3QiLCJjYiIsIm9sZEh0bWwiLCJuZXdIdG1sIiwibm9kZVR5cGUiLCJsb2NhbE5hbWUiLCJkb2N1bWVudCIsImNyZWF0ZVRleHROb2RlIiwiY3JlYXRlRWxlbWVudE5TIiwiaXMiLCJkYXRhIiwiY2hpbGROb2RlcyIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiYXR0cmlidXRlcyIsImlubmVySFRNTCIsImNoZWNrZWQiLCJjdXJyZW50IiwicGFyZW50Vk5vZGUiLCJza2lwUmVtb3ZlIiwiciIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwidGhpcyIsInJlcGxhY2VOb2RlIiwiZmlyc3RDaGlsZCIsImNyZWF0ZUNvbnRleHQiLCJkZWZhdWx0VmFsdWUiLCJjb250ZXh0SWQiLCJDb25zdW1lciIsImNvbnRleHRWYWx1ZSIsIlByb3ZpZGVyIiwic3VicyIsImN0eCIsIl9wcm9wcyIsIm9sZCIsInNwbGljZSIsImVycm9yIiwiZXJyb3JJbmZvIiwiY3RvciIsImhhbmRsZWQiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJzZXRTdGF0ZSIsImNvbXBvbmVudERpZENhdGNoIiwiaXNWYWxpZEVsZW1lbnQiLCJ1cGRhdGUiLCJjYWxsYmFjayIsInMiLCJmb3JjZVVwZGF0ZSIsIl9fc2VsZiIsIl9fc291cmNlIiwiY3VycmVudEluZGV4IiwiY3VycmVudENvbXBvbmVudCIsInByZXZpb3VzQ29tcG9uZW50IiwicHJldlJhZiIsImN1cnJlbnRIb29rIiwiYWZ0ZXJQYWludEVmZmVjdHMiLCJFTVBUWSIsIm9sZEJlZm9yZURpZmYiLCJvbGRCZWZvcmVSZW5kZXIiLCJvbGRBZnRlckRpZmYiLCJvbGRDb21taXQiLCJvbGRCZWZvcmVVbm1vdW50IiwiZ2V0SG9va1N0YXRlIiwiaW5kZXgiLCJob29rcyIsInVzZVN0YXRlIiwiaW5pdGlhbFN0YXRlIiwidXNlUmVkdWNlciIsImludm9rZU9yUmV0dXJuIiwicmVkdWNlciIsImluaXQiLCJob29rU3RhdGUiLCJfcmVkdWNlciIsImFjdGlvbiIsIm5leHRWYWx1ZSIsInVzZUVmZmVjdCIsImFyZ3MiLCJhcmdzQ2hhbmdlZCIsIl9wZW5kaW5nQXJncyIsInVzZUxheW91dEVmZmVjdCIsInVzZVJlZiIsImluaXRpYWxWYWx1ZSIsInVzZU1lbW8iLCJmYWN0b3J5IiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwiZmx1c2hBZnRlclBhaW50RWZmZWN0cyIsInNoaWZ0IiwiaW52b2tlQ2xlYW51cCIsImludm9rZUVmZmVjdCIsImhvb2tJdGVtIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwicmFmIiwiZG9uZSIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJIQVNfUkFGIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJmaWx0ZXIiLCJoYXNFcnJvcmVkIiwiaG9vayIsImNvbXAiLCJjbGVhbnVwIiwib2xkQXJncyIsIm5ld0FyZ3MiLCJhcmciLCJmIiwic2hhbGxvd0RpZmZlcnMiLCJQdXJlQ29tcG9uZW50IiwicCIsIm1lbW8iLCJjb21wYXJlciIsInNob3VsZFVwZGF0ZSIsIm5leHRQcm9wcyIsInVwZGF0ZVJlZiIsIk1lbW9lZCIsImRpc3BsYXlOYW1lIiwiaXNSZWFjdENvbXBvbmVudCIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwib2xkRGlmZkhvb2siLCJGb3J3YXJkZWQiLCJvbGRDYXRjaEVycm9yIiwidGhlbiIsIm9sZFVubW91bnQiLCJTdXNwZW5zZSIsIl9zdXNwZW5kZXJzIiwic3VzcGVuZGVkIiwiU3VzcGVuc2VMaXN0IiwiX25leHQiLCJfbWFwIiwicHJvbWlzZSIsInN1c3BlbmRpbmdWTm9kZSIsInN1c3BlbmRpbmdDb21wb25lbnQiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJvblJlc29sdmVkIiwib25TdXNwZW5zaW9uQ29tcGxldGUiLCJzdXNwZW5kZWRWTm9kZSIsInJlbW92ZU9yaWdpbmFsIiwiZGV0YWNoZWRQYXJlbnQiLCJvcmlnaW5hbFBhcmVudCIsIm1hcCIsInBvcCIsIndhc0h5ZHJhdGluZyIsImRldGFjaGVkQ29tcG9uZW50IiwiZGV0YWNoZWRDbG9uZSIsImVmZmVjdCIsImZhbGxiYWNrIiwibGlzdCIsImRlbGV0ZSIsInJldmVhbE9yZGVyIiwic2l6ZSIsImRlbGVnYXRlZCIsImdldCIsInVuc3VzcGVuZCIsIndyYXBwZWRVbnN1c3BlbmQiLCJNYXAiLCJyZXZlcnNlIiwic2V0IiwiX3RoaXMiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJDQU1FTF9QUk9QUyIsIklTX0RPTSIsIm9uQ2hhbmdlSW5wdXRUeXBlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJ2Iiwid3JpdGFibGUiLCJvbGRFdmVudEhvb2siLCJlbXB0eSIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiY2FuY2VsQnViYmxlIiwiaXNEZWZhdWx0UHJldmVudGVkIiwiZGVmYXVsdFByZXZlbnRlZCIsInBlcnNpc3QiLCJuYXRpdmVFdmVudCIsImNsYXNzTmFtZURlc2NyaXB0b3IiLCJjbGFzcyIsIm9sZFZOb2RlSG9vayIsIm5vbkN1c3RvbUVsZW1lbnQiLCJtdWx0aXBsZSIsInNlbGVjdGVkIiwiY2xhc3NOYW1lIiwiZW51bWVyYWJsZSIsIiQkdHlwZW9mIiwiVW5zZXQiLCJvYmplY3RQcm90byIsImhhc093blByb3BlcnR5IiwibmF0aXZlT2JqZWN0VG9TdHJpbmciLCJzeW1Ub1N0cmluZ1RhZyIsIkZVTkNfRVJST1JfVEVYVCIsInVzZVN0YXRlUCIsImlkZW50aXR5IiwiZ2V0RG9jdW1lbnQiLCJjYW5kaWRhdGVTZWxlY3RvcnMiLCJOb0VsZW1lbnQiLCJFbGVtZW50IiwibWF0Y2hlcyIsIm1zTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiZ2V0Um9vdE5vZGUiLCJlbGVtZW50Iiwib3duZXJEb2N1bWVudCIsImlzSW5wdXQiLCJ0YWdOYW1lIiwiaXNIaWRkZW5JbnB1dCIsImlzRGV0YWlsc1dpdGhTdW1tYXJ5IiwiYXBwbHkiLCJpc1plcm9BcmVhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpc0hpZGRlbiIsImRpc3BsYXlDaGVjayIsImdldFNoYWRvd1Jvb3QiLCJnZXRDb21wdXRlZFN0eWxlIiwidmlzaWJpbGl0eSIsImlzRGlyZWN0U3VtbWFyeSIsIm5vZGVVbmRlckRldGFpbHMiLCJwYXJlbnRFbGVtZW50Iiwibm9kZVJvb3RIb3N0IiwiaG9zdCIsIm5vZGVJc0F0dGFjaGVkIiwiY29udGFpbnMiLCJvcmlnaW5hbE5vZGUiLCJyb290Tm9kZSIsInNoYWRvd1Jvb3QiLCJhc3NpZ25lZFNsb3QiLCJnZXRDbGllbnRSZWN0cyIsImlzRGlzYWJsZWRGcm9tRmllbGRzZXQiLCJkaXNhYmxlZCIsIml0ZW0iLCJpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlIiwiZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IiLCJjb25jYXQiLCJqb2luIiwiaXNGb2N1c2FibGUiLCJFcnJvciIsImFyZ3NUYWciLCJmcmVlRXhwb3J0cyIsImZyZWVNb2R1bGUiLCJtb2R1bGVFeHBvcnRzIiwiTUFYX1NBRkVfSU5URUdFUiIsImZ1bmNUYWciLCJoIiwic2h1ZmZsZSIsImxvZGFzaFNodWZmbGUiLCJfanN4cyIsIl9qc3giLCJSYW5kb21Xb3JkcyJdLCJtYXBwaW5ncyI6Ijs7O0FBMEJhQSxRQUFBQSxDQUFBQSxDQ2ZQQyxHQ1JGQyxDQUFBQSxHQUFBQSxDQ3VLQUMsR0FBQUEsQ0FXQUMsR0NuTE9DLENBQUFBLEdBQUFBLENDRkVDLEdBQVksQ0FBQSxFQUFBLENBQ1pDLEdBQVksQ0FBQSxFQUFBLENBQ1pDLEdBQXFCLENBQUEsb0VMTzNCLFNBQVNDLEdBQUFBLENBQU9DLENBQUtDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBRXRCLElBQUlOLENBQUFBLElBQUtNLENBQU9ELENBQUFBLENBQUFBLENBQUlMLENBQUtNLENBQUFBLENBQUFBLENBQUFBLENBQU1OLENBQ1BLLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBU3ZCLFNBQVNFLEdBQUFBLENBQVdDLENBQ3RCQyxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFhRCxFQUFLQyxVQUNsQkEsQ0FBQUEsQ0FBQUEsRUFBWUEsQ0FBV0MsQ0FBQUEsV0FBQUEsQ0FBWUYsQ0VWeEMsRUFBQSxDQUFBLFNBQWdCRyxHQUFjQyxDQUFBQSxDQUFBQSxDQUFNTixDQUFPTyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUV6Q0MsQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQWYsQ0FIR2dCLENBQUFBLENBQUFBLENBQWtCLEVBSWpCaEIsQ0FBQUEsSUFBQUEsQ0FBQUEsSUFBS00sQ0FDQSxDQUFBLEtBQUEsRUFBTE4sQ0FBWWMsQ0FBQUEsQ0FBQUEsQ0FBTVIsQ0FBTU4sQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDZCxLQUFMQSxFQUFBQSxDQUFBQSxDQUFZZSxDQUFNVCxDQUFBQSxDQUFBQSxDQUFNTixDQUM1QmdCLENBQUFBLENBQUFBLENBQUFBLENBQWdCaEIsQ0FBS00sQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTU4sTUFHN0JpQixTQUFVQyxDQUFBQSxNQUFBQSxDQUFTLENBQ3RCRixHQUFBQSxDQUFBQSxDQUFnQkgsUUFDZkksQ0FBQUEsU0FBQUEsQ0FBVUMsTUFBUyxDQUFBLENBQUEsQ0FBSXZCLENBQU13QixDQUFBQSxJQUFBQSxDQUFLRixTQUFXLENBQUEsQ0FBQSxDQUFBLENBQUtKLENBS2pDLENBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBUkQsQ0FBMkMsRUFBQSxJQUFBLEVBQXJCQSxDQUFLUSxDQUFBQSxZQUFBQSxDQUFBQSxJQUNoQ3BCLENBQUtZLElBQUFBLENBQUFBLENBQUtRLFlBQ2FDLENBQUFBLEtBQUFBLENBQUFBLEdBQXZCTCxDQUFnQmhCLENBQUFBLENBQUFBLENBQUFBLEdBQ25CZ0IsQ0FBZ0JoQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFLWSxDQUFLUSxDQUFBQSxZQUFBQSxDQUFhcEIsQ0FLbkNzQixDQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxHQUFBQSxDQUFZVixDQUFNSSxDQUFBQSxDQUFBQSxDQUFpQkYsQ0FBS0MsQ0FBQUEsQ0FBQUEsQ0FBSyxJQWU5QyxDQUFBLENBQUEsU0FBU08sR0FBWVYsQ0FBQUEsQ0FBQUEsQ0FBTU4sQ0FBT1EsQ0FBQUEsQ0FBQUEsQ0FBS0MsQ0FBS1EsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFHNUNDLENBQVEsQ0FBQSxDQUNiWixJQUFBQSxDQUFBQSxDQUFBQSxDQUNBTixLQUFBQSxDQUFBQSxDQUFBQSxDQUNBUSxHQUFBQSxDQUFBQSxDQUFBQSxDQUNBQyxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUNXLElBQ0YsQ0FBQSxFQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsQ0FDRCxDQUNGLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsS0FLSU0sQ0FDRSxDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxDQUNBLElBQ1pJLENBQUFBLFdBQUFBLENBQUFBLEtBQWFKLENBQ1UsQ0FBQSxHQUFBLENBQUEsSUFBQSxFQUFaRSxJQUFxQjFCLEdBQVUwQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxPQUkzQixJQUFaQSxFQUFBQSxDQUFBQSxFQUFxQyxJQUFqQjNCLEVBQUFBLEdBQUFBLENBQVE0QixLQUFlNUIsRUFBQUEsR0FBQUEsQ0FBUTRCLEtBQU1BLENBQUFBLENBQUFBLENBQUFBLENBRXREQSxDQUdSLENBSU8sU0FBU0UsR0FBQUEsQ0FBU3BCLENBQ2pCQSxDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxDQUFNTyxRQzVFUCxDQUFBLFNBQVNjLEdBQVVyQixDQUFBQSxDQUFBQSxDQUFPc0IsQ0FDM0J0QixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxLQUFBQSxDQUFRQSxDQUNSc0IsQ0FBQUEsSUFBQUEsQ0FBQUEsT0FBQUEsQ0FBVUEsRUF5RVQsQ0FBQSxTQUFTQyxHQUFjTCxDQUFBQSxDQUFBQSxDQUFPTSxDQUNsQixDQUFBLENBQUEsR0FBQSxJQUFBLEVBQWRBLENBRUlOLENBQUFBLE9BQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQ0pLLEdBQWNMLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQWVBLENBQXdCTyxDQUFBQSxFQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxPQUFBQSxDQUFRUCxDQUFTLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDdEUsSUFHQVEsQ0FBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsQ0FDR0YsQ0FBYU4sQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBZ0JOLE1BQVFZLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLEdBRzVCLElBRmZFLEdBQUFBLENBQUFBLENBQVVSLENBQWdCTSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUVhLElBQWhCRSxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxPQUlmQSxDQVNtQixDQUFBLEdBQUEsQ0FBQSxPQUFBLFVBQUEsRUFBQSxPQUFkUixDQUFNWixDQUFBQSxJQUFBQSxDQUFxQmlCLEdBQWNMLENBQUFBLENBQUFBLENBQUFBLENBQVMsSUF1Q2pFLENBQUEsU0FBU1MsSUFBd0JULENBQWpDLENBQUEsQ0FBQSxJQUdXeEIsQ0FDSmtDLENBQUFBLENBQUFBLENBQUFBLEdBSHlCLElBQTFCVixHQUFBQSxDQUFBQSxDQUFRQSxDQUE4QyxDQUFBLEVBQUEsQ0FBQSxFQUFBLElBQUEsRUFBcEJBLENBQTBCLENBQUEsR0FBQSxDQUFBLENBQUEsSUFDaEVBLENBQWFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWlCVyxJQUFPLENBQUEsSUFBQSxDQUM1Qm5DLENBQUksQ0FBQSxDQUFBLENBQUdBLENBQUl3QixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFnQk4sTUFBUWxCLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLEdBRTlCLElBRFRrQyxHQUFBQSxDQUFBQSxDQUFRVixDQUFnQnhCLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQ08sSUFBZGtDLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQW9CLENBQ3hDVixDQUFBQSxDQUFBQSxHQUFBQSxDQUFhQSxDQUFpQlcsQ0FBQUEsR0FBQUEsQ0FBQUEsSUFBQUEsQ0FBT0QsQ0FLaENELENBQUFBLEdBQUFBLENBQUFBLEtBQUFBLENBQUFBLE9BQUFBLEdBQUFBLENBQXdCVCxDQXlCMUIsQ0FBQSxDQUFBLENBQUEsU0FBU1ksR0FBY0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFMUJBLENBQ0FBLENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQVcsQ0FDWnZDLENBQUFBLEVBQUFBLEdBQUFBLENBQWN3QyxJQUFLRCxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUNsQkUsR0FDRnhDLENBQUFBLEdBQUFBLEVBQUFBLEVBQUFBLEdBQUFBLEdBQWlCSCxHQUFRNEMsQ0FBQUEsaUJBQUFBLEdBQUFBLENBQUFBLENBRXpCekMsR0FBZUgsQ0FBQUEsR0FBQUEsQ0FBUTRDLGlCQUNOQyxHQUFBQSxVQUFBQSxFQUFZRixHQUsvQixFQUFBLENBQUEsU0FBU0EsR0FDSkcsRUFBQUEsQ0FBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsQ0FDSUgsR0FBeUJ6QyxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFjb0IsTUFDOUN3QixFQUFBQSxDQUFBQSxDQUFRNUMsR0FBYzZDLENBQUFBLElBQUFBLENBQUssU0FBQ0MsQ0FBQUEsQ0FBR0MsVUFBTUQsQ0FBa0JDLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQ3ZEL0MsR0FBZ0IsQ0FBQSxFQUFBLENBR2hCNEMsQ0FBTUksQ0FBQUEsSUFBQUEsQ0FBSyxTQUFBVCxDQUFBQSxDQUFBQSxDQXpGYixJQUF5QlUsQ0FBQUEsQ0FNbkJDLENBQ0VDLENBQUFBLENBQUFBLENBTkh6QixDQUNIMEIsQ0FBQUEsQ0FBQUEsQ0FDQUMsQ0F1RktkLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBeEZMYSxDQURHMUIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FEb0J1QixDQTBGUVYsQ0FBQUEsQ0FBQUEsRUFBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsQ0F2Ri9CYyxDQUFZSixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxJQUdSQyxDQUFjLENBQUEsRUFBQSxDQUFBLENBQ1pDLENBQVc3QyxDQUFBQSxHQUFBQSxDQUFPLEVBQUlvQixDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxDQUNQQSxDQUFrQixDQUFBLEdBQUEsQ0FBQSxDQUFBLENBRXZDNEIsR0FDQ0QsQ0FBQUEsQ0FBQUEsQ0FDQTNCLENBQ0F5QixDQUFBQSxDQUFBQSxDQUNBRixDQUM4QjFCLENBQUFBLEdBQUFBLENBQUFBLEtBQUFBLENBQUFBLEdBQTlCOEIsQ0FBVUUsQ0FBQUEsZUFBQUEsQ0FDVSxJQUFwQjdCLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQTJCLENBQUMwQixDQUFBQSxDQUFBQSxDQUFVLElBQ3RDRixDQUFBQSxDQUFBQSxDQUNVLElBQVZFLEVBQUFBLENBQUFBLENBQWlCckIsR0FBY0wsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBUzBCLENBQ3hDMUIsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FFRDhCLEdBQVdOLENBQUFBLENBQUFBLENBQWF4QixDQUVwQkEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBYzBCLENBQ2pCakIsRUFBQUEsR0FBQUEsQ0FBd0JULENHdEgzQixDQUFBLENBQUEsRUFBQSxDQUFBLEVBQUEsQ0FBQSxTQUFnQitCLEdBQ2ZKLENBQUFBLENBQUFBLENBQ0FLLENBQ0FDLENBQUFBLENBQUFBLENBQ0FDLEVBQ0FDLENBQ0FDLENBQUFBLENBQUFBLENBQ0FDLENBQ0FiLENBQUFBLENBQUFBLENBQ0FFLENBQ0FZLENBQUFBLENBQUFBLENBQUFBLENBVkQsSUFZSzlELENBQUFBLENBQUcrRCxDQUFHZCxDQUFBQSxDQUFBQSxDQUFVZSxDQUFZQyxDQUFBQSxDQUFBQSxDQUFRQyxDQUFlQyxDQUFBQSxDQUFBQSxDQUluREMsQ0FBZVYsQ0FBQUEsQ0FBQUEsRUFBa0JBLENBQTZCeEQsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FFOURtRSxDQUFvQkQsQ0FBQUEsQ0FBQUEsQ0FBWWxELE1BRXBDdUMsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBMkIsRUFDdEJ6RCxDQUFBQSxDQUFBQSxDQUFJLENBQUdBLENBQUFBLENBQUFBLENBQUl3RCxDQUFhdEMsQ0FBQUEsTUFBQUEsQ0FBUWxCLENBZ0RsQixFQUFBLENBQUEsR0FBQSxJQUFBLEdBNUNqQmdFLENBQWFQLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXlCekQsQ0FEckIsQ0FBQSxDQUFBLElBQUEsR0FGbEJnRSxDQUFhUixDQUFBQSxDQUFBQSxDQUFheEQsQ0FFcUIsQ0FBQSxDQUFBLEVBQUEsU0FBQSxFQUFBLE9BQWRnRSxDQUNXLENBQUEsSUFBQSxDQU10QixRQUFkQSxFQUFBQSxPQUFBQSxDQUFBQSxFQUNjLFFBQWRBLEVBQUFBLE9BQUFBLENBQUFBLEVBRWMsUUFBZEEsRUFBQUEsT0FBQUEsQ0FBQUEsQ0FFb0MxQyxHQUMxQyxDQUFBLElBQUEsQ0FDQTBDLENBQ0EsQ0FBQSxJQUFBLENBQ0EsSUFDQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFU00sS0FBTUMsQ0FBQUEsT0FBQUEsQ0FBUVAsQ0FDbUIxQyxDQUFBQSxDQUFBQSxHQUFBQSxDQUMxQ0ksR0FDQSxDQUFBLENBQUViLFFBQVVtRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUNaLElBQ0EsQ0FBQSxJQUFBLENBQ0EsTUFFU0EsQ0FBb0IsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUthMUMsR0FDMUMwQyxDQUFBQSxDQUFBQSxDQUFXcEQsSUFDWG9ELENBQUFBLENBQUFBLENBQVcxRCxLQUNYMEQsQ0FBQUEsQ0FBQUEsQ0FBV2xELEdBQ1gsQ0FBQSxJQUFBLENBQ0FrRCxDQUcwQ0EsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FTNUNBLENBQXFCUCxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUNyQk8sQ0FBb0JQLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXdCLENBUzlCLENBQUEsSUFBQSxJQUhkUixDQUFXbUIsQ0FBQUEsQ0FBQUEsQ0FBWXBFLENBSXJCaUQsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsRUFDQWUsQ0FBV2xELENBQUFBLEdBQUFBLEVBQU9tQyxDQUFTbkMsQ0FBQUEsR0FBQUEsRUFDM0JrRCxDQUFXcEQsQ0FBQUEsSUFBQUEsR0FBU3FDLENBQVNyQyxDQUFBQSxJQUFBQSxDQUU5QndELENBQVlwRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxLQUFLcUIsQ0FJWjBDLENBQUFBLEtBQUFBLElBQUFBLENBQUFBLENBQUksQ0FBR0EsQ0FBQUEsQ0FBQUEsQ0FBSU0sQ0FBbUJOLENBQUFBLENBQUFBLEVBQUFBLENBQUssQ0FDdkNkLEdBQUFBLENBQUFBLENBQUFBLENBQVdtQixDQUFZTCxDQUFBQSxDQUFBQSxDQUFBQSxHQUt0QkMsQ0FBV2xELENBQUFBLEdBQUFBLEVBQU9tQyxDQUFTbkMsQ0FBQUEsR0FBQUEsRUFDM0JrRCxDQUFXcEQsQ0FBQUEsSUFBQUEsR0FBU3FDLENBQVNyQyxDQUFBQSxJQUFBQSxDQUM1QixDQUNEd0QsQ0FBQUEsQ0FBWUwsQ0FBSzFDLENBQUFBLENBQUFBLEtBQUFBLENBQUFBLENBQUFBLEtBQUFBLENBR2xCNEIsQ0FBVyxDQUFBLEtBQUEsQ0FPYkcsR0FDQ0QsQ0FBQUEsQ0FBQUEsQ0FDQWEsQ0FMRGYsQ0FBQUEsQ0FBQUEsQ0FBV0EsQ0FBWWhELEVBQUFBLEdBQUFBLENBT3RCMEQsRUFDQUMsQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQWIsQ0FDQUUsQ0FBQUEsQ0FBQUEsQ0FDQVksQ0FHREcsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBU0QsQ0FFSkQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBSUMsQ0FBV2pELENBQUFBLEdBQUFBLEdBQVFrQyxDQUFTbEMsQ0FBQUEsR0FBQUEsRUFBT2dELENBQ3RDSSxHQUFBQSxDQUFBQSxHQUFNQSxDQUFPLENBQUEsRUFBQSxDQUFBLENBQ2RsQixDQUFTbEMsQ0FBQUEsR0FBQUEsRUFBS29ELENBQUs3QixDQUFBQSxJQUFBQSxDQUFLVyxDQUFTbEMsQ0FBQUEsR0FBQUEsQ0FBSyxJQUFNaUQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDaERHLENBQUs3QixDQUFBQSxJQUFBQSxDQUFLeUIsQ0FBR0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBeUJDLENBQVFELENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBR2pDLElBQVZDLEVBQUFBLENBQUFBLEVBQ2tCLElBQWpCQyxFQUFBQSxDQUFBQSxHQUNIQSxDQUFnQkQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FJVSxVQUFuQkQsRUFBQUEsT0FBQUEsQ0FBQUEsQ0FBV3BELElBQ2xCb0QsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0FBeUJmLENBRXpCZSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFzQmQsQ0FBU3NCLENBQUFBLEdBQUFBLENBQzlCUixDQUNBZCxDQUFBQSxDQUFBQSxDQUNBQyxDQUdERCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFTdUIsR0FDUnRCLENBQUFBLENBQUFBLENBQ0FhLENBQ0FmLENBQUFBLENBQUFBLENBQ0FtQixDQUNBSCxDQUFBQSxDQUFBQSxDQUNBZixDQUlnQyxDQUFBLENBQUEsVUFBQSxFQUFBLE9BQXZCTyxDQUFlN0MsQ0FBQUEsSUFBQUEsR0FRekI2QyxDQUEwQlAsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFHM0JBLENBQ0FELEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQWlCQyxHQUNqQkEsQ0FBT3pDLENBQUFBLFVBQUFBLEVBQWMwQyxDQUlyQkQsR0FBQUEsQ0FBQUEsQ0FBU3JCLEdBQWNvQixDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxJQUl6QlEsQ0FBc0JTLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBR2pCbEUsQ0FBSXFFLENBQUFBLENBQUFBLENBQW1CckUsQ0FDTCxFQUFBLEVBQUEsSUFBQSxFQUFsQm9FLENBQVlwRSxDQUFBQSxDQUFBQSxDQUFBQSxHQUVnQixVQUF2QnlELEVBQUFBLE9BQUFBLENBQUFBLENBQWU3QyxJQUNDLEVBQUEsSUFBQSxFQUF2QndELENBQVlwRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUNab0UsQ0FBWXBFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQVd5RCxDQUt2QkEsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBMEI1QixHQUFjNkIsQ0FBQUEsQ0FBQUEsQ0FBZ0IxRCxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FHN0QwRSxDQUFRTixDQUFBQSxDQUFBQSxDQUFZcEUsQ0FBSW9FLENBQUFBLENBQUFBLENBQUFBLENBQVlwRSxDQUtsQ21FLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLElBQ0VuRSxDQUFJLENBQUEsQ0FBQSxDQUFHQSxDQUFJbUUsQ0FBQUEsQ0FBQUEsQ0FBS2pELE1BQVFsQixDQUFBQSxDQUFBQSxFQUFBQSxDQUM1QjJFLEdBQVNSLENBQUFBLENBQUFBLENBQUtuRSxDQUFJbUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBT25FLENBQUltRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFPbkUsQ0FLdkMsQ0FBQSxFQUFBLENBQUEsU0FBU3dFLEdBQWdCUixDQUFBQSxDQUFBQSxDQUFZZCxDQUFRQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUE3QyxJQUtNM0IsQ0FBQUEsQ0FIRGEsQ0FBSTJCLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQ0pZLENBQU0sQ0FBQSxDQUFBLENBQ0h2QyxDQUFLdUMsRUFBQUEsQ0FBQUEsQ0FBTXZDLENBQUVuQixDQUFBQSxNQUFBQSxDQUFRMEQsS0FDdkJwRCxDQUFRYSxDQUFBQSxDQUFBQSxDQUFFdUMsQ0FNYnBELENBQUFBLElBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQWdCd0MsQ0FHZmQsQ0FBQUEsQ0FBQUEsQ0FEd0IsVUFBZDFCLEVBQUFBLE9BQUFBLENBQUFBLENBQU1aLElBQ1A0RCxDQUFBQSxHQUFBQSxDQUFnQmhELENBQU8wQixDQUFBQSxDQUFBQSxDQUFRQyxDQUUvQnNCLENBQUFBLENBQUFBLEdBQUFBLENBQ1J0QixDQUNBM0IsQ0FBQUEsQ0FBQUEsQ0FDQUEsQ0FDQWEsQ0FBQUEsQ0FBQUEsQ0FDQWIsQ0FDQTBCLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BTUdBLENBU0QsQ0FBQSxTQUFTMkIsQ0FBYWhFLENBQUFBLENBQUFBLENBQVVpRSxDQUN0Q0EsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBTUEsQ0FBTyxFQUFBLEVBQUEsQ0FDRyxJQUFaakUsRUFBQUEsQ0FBQUEsRUFBdUMsU0FBWkEsRUFBQUEsT0FBQUEsQ0FBQUEsR0FDcEJ5RCxLQUFNQyxDQUFBQSxPQUFBQSxDQUFRMUQsQ0FDeEJBLENBQUFBLENBQUFBLENBQUFBLENBQVNpQyxJQUFLLENBQUEsU0FBQVosQ0FDYjJDLENBQUFBLENBQUFBLENBQUFBLENBQWEzQyxDQUFPNEMsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FHckJBLENBQUl4QyxDQUFBQSxJQUFBQSxDQUFLekIsQ0FFSGlFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBR1IsU0FBU0wsR0FBQUEsQ0FDUnRCLENBQ0FhLENBQUFBLENBQUFBLENBQ0FmLENBQ0FtQixDQUFBQSxDQUFBQSxDQUNBSCxDQUNBZixDQUFBQSxDQUFBQSxDQUFBQSxDQU5ELElBUUs2QixDQUFBQSxDQXVCR0MsQ0FBaUJqQixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxLQXRCSTFDLENBQXhCMkMsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FJSGUsQ0FBVWYsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FNVkEsV0FBc0IzQyxDQUNoQixDQUFBLEtBQUEsR0FDTSxJQUFaNEIsRUFBQUEsQ0FBQUEsRUFDQWdCLENBQVVmLEVBQUFBLENBQUFBLEVBQ1csSUFBckJlLEVBQUFBLENBQUFBLENBQU94RCxVQUVQd0UsQ0FBQUEsQ0FBQUEsQ0FBTyxHQUFjLElBQUEsRUFBVi9CLENBQWtCQSxFQUFBQSxDQUFBQSxDQUFPekMsVUFBZTBDLEdBQUFBLENBQUFBLENBQ2xEQSxDQUFVK0IsQ0FBQUEsV0FBQUEsQ0FBWWpCLENBQ3RCYyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFVLElBQ0osQ0FBQSxLQUFBLENBQUEsSUFHREMsQ0FBUzlCLENBQUFBLENBQUFBLENBQVFhLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FDeEJpQixDQUFTQSxDQUFBQSxDQUFBQSxDQUFPRyxXQUFnQnBCLEdBQUFBLENBQUFBLENBQUlLLENBQVlsRCxDQUFBQSxNQUFBQSxDQUNqRDZDLENBQUssRUFBQSxDQUFBLENBQUEsR0FFRGlCLENBQVVmLEVBQUFBLENBQUFBLENBQUFBLE1BQ1BnQixDQUdSOUIsQ0FBQUEsQ0FBQUEsQ0FBVWlDLFlBQWFuQixDQUFBQSxDQUFBQSxDQUFRZixDQUMvQjZCLENBQUFBLENBQUFBLENBQUFBLENBQVU3QixFQU9JN0IsQ0FBQUEsT0FBQUEsS0FBQUEsQ0FBQUEsR0FBWjBELENBQ01BLENBQUFBLENBQUFBLENBRUFkLENBQU9rQixDQUFBQSxXQUFBQSxDQzlUWCxTQUFTRSxHQUFBQSxDQUFVQyxDQUFLQyxDQUFBQSxDQUFBQSxDQUFVQyxDQUFVNUIsQ0FBQUEsQ0FBQUEsQ0FBTzZCLENBQ3JEekYsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsSUFFQ0EsQ0FBS3dGLElBQUFBLENBQUFBLENBQ0MsVUFBTnhGLEdBQUFBLENBQUFBLEVBQTBCLEtBQU5BLEdBQUFBLENBQUFBLEVBQWlCQSxLQUFLdUYsQ0FDN0NHLEVBQUFBLEdBQUFBLENBQVlKLENBQUt0RixDQUFBQSxDQUFBQSxDQUFHLElBQU13RixDQUFBQSxDQUFBQSxDQUFTeEYsQ0FBSTRELENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBSXBDNUQsQ0FBS3VGLElBQUFBLENBQUFBLENBRU5FLENBQWlDLEVBQUEsVUFBQSxFQUFBLE9BQWZGLENBQVN2RixDQUFBQSxDQUFBQSxDQUFBQSxFQUN2QixVQUFOQSxHQUFBQSxDQUFBQSxFQUNNLEtBQU5BLEdBQUFBLENBQUFBLEVBQ00sT0FBTkEsR0FBQUEsQ0FBQUEsRUFDTSxTQUFOQSxHQUFBQSxDQUFBQSxFQUNBd0YsQ0FBU3hGLENBQUFBLENBQUFBLENBQUFBLEdBQU91RixDQUFTdkYsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFFekIwRixHQUFZSixDQUFBQSxDQUFBQSxDQUFLdEYsQ0FBR3VGLENBQUFBLENBQUFBLENBQVN2RixDQUFJd0YsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBU3hGLENBQUk0RCxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUtqRCxTQUFTK0IsR0FBQUEsQ0FBU0MsQ0FBTzlFLENBQUFBLENBQUFBLENBQUsrRSxDQUNkLENBQUEsQ0FBQSxHQUFBLEdBQVgvRSxDQUFJLENBQUEsQ0FBQSxDQUFBLENBQ1A4RSxDQUFNRixDQUFBQSxXQUFBQSxDQUFZNUUsQ0FBSytFLENBQUFBLENBQUFBLENBQUFBLENBRXZCRCxDQUFNOUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FEYSxJQUFUK0UsRUFBQUEsQ0FBQUEsQ0FDRyxFQUNhLENBQUEsUUFBQSxFQUFBLE9BQVRBLENBQXFCMUYsRUFBQUEsR0FBQUEsQ0FBbUIyRixJQUFLaEYsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDakQrRSxDQUVBQSxDQUFBQSxDQUFBQSxDQUFRLEtBWWhCLENBQUEsU0FBU0gsR0FBWUosQ0FBQUEsQ0FBQUEsQ0FBS1MsRUFBTUYsQ0FBT0csQ0FBQUEsQ0FBQUEsQ0FBVXBDLENBQWpELENBQUEsQ0FBQSxJQUNGcUMsQ0FFSkMsQ0FBQUEsQ0FBQUEsQ0FBRyxHQUFhLE9BQUEsR0FBVEgsQ0FDYyxDQUFBLEdBQUEsUUFBQSxFQUFBLE9BQVRGLENBQ1ZQLENBQUFBLENBQUFBLENBQUlNLEtBQU1PLENBQUFBLE9BQUFBLENBQVVOLENBQ2QsQ0FBQSxLQUFBLENBQUEsR0FDaUIsUUFBWkcsRUFBQUEsT0FBQUEsQ0FBQUEsR0FDVlYsQ0FBSU0sQ0FBQUEsS0FBQUEsQ0FBTU8sT0FBVUgsQ0FBQUEsQ0FBQUEsQ0FBVyxFQUc1QkEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFDRUQsQ0FBUUMsSUFBQUEsQ0FBQUEsQ0FDTkgsQ0FBU0UsRUFBQUEsQ0FBQUEsSUFBUUYsQ0FDdEJGLEVBQUFBLEdBQUFBLENBQVNMLENBQUlNLENBQUFBLEtBQUFBLENBQU9HLENBQU0sQ0FBQSxFQUFBLENBQUEsQ0FBQSxHQUt6QkYsQ0FDRUUsQ0FBQUEsSUFBQUEsQ0FBQUEsSUFBUUYsQ0FDUEcsQ0FBQUEsQ0FBQUEsRUFBWUgsQ0FBTUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBVUMsQ0FBU0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFDekNKLEdBQVNMLENBQUFBLENBQUFBLENBQUlNLEtBQU9HLENBQUFBLENBQUFBLENBQU1GLENBQU1FLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLEtBT2hDLEdBQWdCLEdBQUEsR0FBWkEsQ0FBSyxDQUFBLENBQUEsQ0FBQSxFQUEwQixHQUFaQSxHQUFBQSxDQUFBQSxDQUFLLENBQ2hDRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFhRixDQUFVQSxJQUFBQSxDQUFBQSxDQUFPQSxDQUFLSyxDQUFBQSxPQUFBQSxDQUFRLFVBQVksQ0FBQSxFQUFBLENBQUEsQ0FBQSxDQUd4QkwsRUFBM0JBLENBQUtNLENBQUFBLFdBQUFBLEVBQUFBLEdBQWlCZixDQUFZUyxDQUFBQSxDQUFBQSxDQUFLTSxXQUFjMUcsRUFBQUEsQ0FBQUEsS0FBQUEsQ0FBTSxDQUNuRG9HLENBQUFBLENBQUFBLENBQUFBLENBQUtwRyxLQUFNLENBQUEsQ0FBQSxDQUFBLENBRWxCMkYsQ0FBSWdCLENBQUFBLENBQUFBLEdBQVloQixDQUFJZ0IsQ0FBQUEsQ0FBQUEsQ0FBYSxFQUN0Q2hCLENBQUFBLENBQUFBLENBQUFBLENBQUlnQixDQUFXUCxDQUFBQSxDQUFBQSxDQUFPRSxDQUFjSixDQUFBQSxDQUFBQSxDQUFBQSxDQUVoQ0EsQ0FDRUcsQ0FBQUEsQ0FBQUEsRUFFSlYsQ0FBSWlCLENBQUFBLGdCQUFBQSxDQUFpQlIsQ0FETEUsQ0FBQUEsQ0FBQUEsQ0FBYU8sR0FBb0JDLENBQUFBLENBQUFBLENBQ2JSLENBSXJDWCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJb0IsbUJBQW9CWCxDQUFBQSxDQUFBQSxDQURSRSxDQUFhTyxDQUFBQSxHQUFBQSxDQUFvQkMsQ0FDVlIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsS0FFbEMsR0FBYSx5QkFBQSxHQUFURixDQUFvQyxDQUFBLENBQUEsR0FDMUNuQyxDQUlIbUMsQ0FBQUEsQ0FBQUEsQ0FBT0EsQ0FBS0ssQ0FBQUEsT0FBQUEsQ0FBUSxhQUFlLENBQUEsR0FBQSxDQUFBLENBQUtBLE9BQVEsQ0FBQSxRQUFBLENBQVUsR0FDcEQsQ0FBQSxDQUFBLEtBQUEsR0FDRyxNQUFUTCxHQUFBQSxDQUFBQSxFQUNTLE1BQVRBLEdBQUFBLENBQUFBLEVBQ1MsTUFBVEEsR0FBQUEsQ0FBQUEsRUFHUyxVQUFUQSxHQUFBQSxDQUFBQSxFQUNTLFVBQVRBLEdBQUFBLENBQUFBLEVBQ0FBLENBQVFULElBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBR1BBLEVBQUlTLENBQWlCLENBQUEsQ0FBQSxJQUFBLEVBQVRGLENBQWdCLENBQUEsRUFBQSxDQUFLQSxDQUUzQkssQ0FBQUEsTUFBQUEsQ0FBQUEsQ0FDTCxNQUFPUyxDQUFBQSxDQUFBQSxFQVVXLFVBQVZkLEVBQUFBLE9BQUFBLENBQUFBLEdBR0QsSUFBVEEsRUFBQUEsQ0FBQUEsR0FBQUEsQ0FDVyxDQUFWQSxHQUFBQSxDQUFBQSxFQUFnQyxHQUFaRSxHQUFBQSxDQUFBQSxDQUFLLENBQTBCLENBQUEsRUFBQSxHQUFBLEdBQVpBLENBQUssQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUU3Q1QsQ0FBSXNCLENBQUFBLFlBQUFBLENBQWFiLENBQU1GLENBQUFBLENBQUFBLENBQUFBLENBRXZCUCxDQUFJdUIsQ0FBQUEsZUFBQUEsQ0FBZ0JkLENBVXZCLENBQUEsRUFBQSxDQUFBLENBQUEsU0FBU1UsQ0FBV0UsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FDZEwsQ0FBV0ssQ0FBQUEsQ0FBQUEsQ0FBRS9GLElBQU8sQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFPaEIsR0FBUWtILENBQUFBLEtBQUFBLENBQVFsSCxHQUFRa0gsQ0FBQUEsS0FBQUEsQ0FBTUgsQ0FBS0EsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FHcEUsU0FBU0gsR0FBQUEsQ0FBa0JHLENBQ3JCTCxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxDQUFXSyxDQUFFL0YsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBTyxDQUFNaEIsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBUWtILEtBQVFsSCxDQUFBQSxHQUFBQSxDQUFRa0gsS0FBTUgsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBS0EsQ0NwSW5FLEVBQUEsQ0FBQSxTQUFnQnZELEdBQ2ZELENBQUFBLENBQUFBLENBQ0E0RCxDQUNBOUQsQ0FBQUEsQ0FBQUEsQ0FDQVUsQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQUMsQ0FDQWIsQ0FBQUEsQ0FBQUEsQ0FDQUUsRUFDQVksQ0FURCxDQUFBLENBQUEsSUFXS2MsQ0FvQkV2QyxDQUFBQSxDQUFBQSxDQUFHMkUsQ0FBT3hCLENBQUFBLENBQUFBLENBQVV5QixDQUFVQyxDQUFBQSxDQUFBQSxDQUFVQyxDQUN4QzVCLENBQUFBLENBQUFBLENBS0E2QixDQUNBQyxDQUFBQSxDQUFBQSxDQWlIQUMsQ0FDSEMsQ0FBQUEsQ0FBQUEsQ0FpQ0cvRCxDQTdLTGdFLENBQUFBLENBQUFBLENBQVVULENBQVNuRyxDQUFBQSxJQUFBQSxDQUFBQSxHQUFBQSxLQUlTUyxDQUF6QjBGLEdBQUFBLENBQUFBLENBQVN0RixXQUEyQixDQUFBLE9BQU8sSUFHcEIsQ0FBQSxJQUFBLEVBQXZCd0IsQ0FDSGEsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBY2IsQ0FDZEMsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBUzZELENBQWdCOUQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FFekI4RCxDQUFzQixDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQ3RCbEQsQ0FBb0IsQ0FBQSxDQUFDWCxDQUdqQjBCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQU1oRixHQUFnQmdGLENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLENBQUltQyxDQUc5QjlCLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQU8sR0FBc0IsVUFBQSxFQUFBLE9BQVh1QyxDQUF1QixDQUFBLENBQUEsR0FFcENqQyxDQUFXd0IsQ0FBQUEsQ0FBQUEsQ0FBU3pHLEtBS3BCOEcsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FESnhDLENBQU00QyxDQUFBQSxDQUFBQSxDQUFRQyxXQUNROUQsR0FBQUEsQ0FBQUEsQ0FBY2lCLENBQ2hDeUMsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBbUJ6QyxDQUNwQndDLENBQUFBLENBQUFBLENBQ0NBLENBQVM5RyxDQUFBQSxLQUFBQSxDQUFNdUYsS0FDZmpCLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQ0RqQixDQUdDVixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUVIa0UsR0FEQTlFLENBQUkwRSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFzQjlELENBQzBCWixDQUFBQSxHQUFBQSxFQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUdoRCxXQUFlbUYsR0FBQUEsQ0FBQUEsRUFBV0EsQ0FBUUUsQ0FBQUEsU0FBQUEsQ0FBVUMsTUFFL0NaLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXNCMUUsQ0FBSSxDQUFBLElBQUltRixDQUFRakMsQ0FBQUEsQ0FBQUEsQ0FBVThCLENBR2hETixDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFzQjFFLENBQUksQ0FBQSxJQUFJVixHQUFVNEQsQ0FBQUEsQ0FBQUEsQ0FBVThCLENBQ2xEaEYsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBRVosV0FBYytGLENBQUFBLENBQUFBLENBQ2hCbkYsQ0FBRXNGLENBQUFBLE1BQUFBLENBQVNDLEdBRVJSLENBQUFBLENBQUFBLENBQUFBLEVBQVVBLENBQVNTLENBQUFBLEdBQUFBLENBQUl4RixHQUUzQkEsQ0FBRS9CLENBQUFBLEtBQUFBLENBQVFpRixDQUNMbEQsQ0FBQUEsQ0FBQUEsQ0FBRXlGLEtBQU96RixHQUFBQSxDQUFBQSxDQUFFeUYsS0FBUSxDQUFBLEVBQUEsQ0FBQSxDQUN4QnpGLENBQUVULENBQUFBLE9BQUFBLENBQVV5RixDQUNaaEYsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBbUJzQixDQUNuQnFELENBQUFBLENBQUFBLENBQVEzRSxDQUFXLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUNuQkEsQ0FBcUIsQ0FBQSxHQUFBLENBQUEsRUFBQSxDQUFBLENBSUYsSUFBaEJBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBQ0hBLENBQWVBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUV5RixLQUVzQixDQUFBLENBQUEsSUFBQSxFQUFwQ04sQ0FBUU8sQ0FBQUEsd0JBQUFBLEdBQ1AxRixDQUFnQkEsQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsQ0FBRXlGLEtBQ3JCekYsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBZWpDLElBQU8sRUFBSWlDLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBRzNCakMsR0FDQ2lDLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQ0FtRixDQUFRTyxDQUFBQSx3QkFBQUEsQ0FBeUJ4QyxDQUFVbEQsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FJN0NtRCxDQUFXbkQsQ0FBQUEsQ0FBQUEsQ0FBRS9CLEtBQ2IyRyxDQUFBQSxDQUFBQSxDQUFXNUUsQ0FBRXlGLENBQUFBLEtBQUFBLENBR1RkLENBRWtDLENBQUEsSUFBQSxFQUFwQ1EsQ0FBUU8sQ0FBQUEsd0JBQUFBLEVBQ2dCLElBQXhCMUYsRUFBQUEsQ0FBQUEsQ0FBRTJGLGtCQUVGM0YsRUFBQUEsQ0FBQUEsQ0FBRTJGLGtCQUd3QixFQUFBLENBQUEsSUFBQSxFQUF2QjNGLENBQUU0RixDQUFBQSxpQkFBQUEsRUFDTDVGLENBQW1CQyxDQUFBQSxHQUFBQSxDQUFBQSxJQUFBQSxDQUFLRCxDQUFFNEYsQ0FBQUEsaUJBQUFBLENBQUFBLENBQUFBLEtBRXJCLENBRStCLEdBQUEsSUFBQSxFQUFwQ1QsQ0FBUU8sQ0FBQUEsd0JBQUFBLEVBQ1J4QyxDQUFhQyxHQUFBQSxDQUFBQSxFQUNrQixJQUEvQm5ELEVBQUFBLENBQUFBLENBQUU2Rix5QkFFRjdGLEVBQUFBLENBQUFBLENBQUU2Rix5QkFBMEIzQyxDQUFBQSxDQUFBQSxDQUFVOEIsQ0FJcENoRixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUMwQixJQUEzQkEsRUFBQUEsQ0FBQUEsQ0FBRThGLHFCQUtJLEVBQUEsQ0FBQSxDQUFBLEdBSk45RixDQUFFOEYsQ0FBQUEscUJBQUFBLENBQ0Q1QyxDQUNBbEQsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDQWdGLENBRUZOLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBQXVCOUQsQ0FDdEIsQ0FBQSxHQUFBLENBQUEsQ0FDRFosQ0FBRS9CLENBQUFBLEtBQUFBLENBQVFpRixDQUNWbEQsQ0FBQUEsQ0FBQUEsQ0FBRXlGLEtBQVF6RixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUVOMEUsUUFBdUI5RCxDQUFvQlosQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBVyxDQUMxREEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBVzBFLENBQ1hBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWdCOUQsQ0FDaEI4RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFxQjlELENBQ3JCOEQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBbUJxQixPQUFRLENBQUEsU0FBQTVHLENBQ3RCQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFPQSxDQUFnQnVGLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBRXhCMUUsQ0FBbUJuQixDQUFBQSxHQUFBQSxDQUFBQSxNQUFBQSxFQUN0QjhCLENBQVlWLENBQUFBLElBQUFBLENBQUtELENBR1o0QyxDQUFBQSxDQUFBQSxNQUFBQSxDQUFBQSxDQUdzQixJQUF6QjVDLEVBQUFBLENBQUFBLENBQUVnRyxtQkFDTGhHLEVBQUFBLENBQUFBLENBQUVnRyxtQkFBb0I5QyxDQUFBQSxDQUFBQSxDQUFVbEQsQ0FBY2dGLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBR25CLElBQXhCaEYsRUFBQUEsQ0FBQUEsQ0FBRWlHLGtCQUNMakcsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBbUJDLElBQUssQ0FBQSxVQUFBLENBQ3ZCRCxDQUFFaUcsQ0FBQUEsa0JBQUFBLENBQW1COUMsQ0FBVXlCLENBQUFBLENBQUFBLENBQVVDLENBSzVDN0UsRUFBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBRVQsT0FBVXlGLENBQUFBLENBQUFBLENBQ1poRixDQUFFL0IsQ0FBQUEsS0FBQUEsQ0FBUWlGLENBQ1ZsRCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFXMEUsQ0FDWDFFLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWVjLENBRVhtRSxDQUFBQSxDQUFBQSxDQUFhMUgsR0FDaEIySCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFRLENBQ0wsQ0FBQSxXQUFBLEdBQWVDLENBQVdBLEVBQUFBLENBQUFBLENBQVFFLFNBQVVDLENBQUFBLE1BQUFBLENBQy9DdEYsQ0FBRXlGLENBQUFBLEtBQUFBLENBQVF6RixNQUNWQSxDQUFXLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUVQaUYsQ0FBWUEsRUFBQUEsQ0FBQUEsQ0FBV1AsQ0FFM0JuQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFNdkMsQ0FBRXNGLENBQUFBLE1BQUFBLENBQU90RixDQUFFL0IsQ0FBQUEsS0FBQUEsQ0FBTytCLENBQUV5RixDQUFBQSxLQUFBQSxDQUFPekYsQ0FBRVQsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsS0FBQUEsRUFBQUEsQ0FHbENTLENBQVcsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQ1BpRixDQUFZQSxFQUFBQSxDQUFBQSxDQUFXUCxDQUUzQm5DLENBQUFBLENBQUFBLENBQUFBLENBQU12QyxDQUFFc0YsQ0FBQUEsTUFBQUEsQ0FBT3RGLENBQUUvQixDQUFBQSxLQUFBQSxDQUFPK0IsQ0FBRXlGLENBQUFBLEtBQUFBLENBQU96RixDQUFFVCxDQUFBQSxPQUFBQSxDQUFBQSxDQUduQ1MsQ0FBRXlGLENBQUFBLEtBQUFBLENBQVF6RixDQUNGQSxDQUFBQSxJQUFBQSxDQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxFQUFja0YsQ0FBUSxDQUFBLEVBQUEsRUFJaENsRixDQUFFeUYsQ0FBQUEsS0FBQUEsQ0FBUXpGLENBRWUsQ0FBQSxHQUFBLENBQUEsSUFBQSxFQUFyQkEsQ0FBRWtHLENBQUFBLGVBQUFBLEdBQ0w1RSxDQUFnQnZELENBQUFBLEdBQUFBLENBQU9BLEdBQU8sQ0FBQSxFQUFBLENBQUl1RCxDQUFnQnRCLENBQUFBLENBQUFBLENBQUFBLENBQUVrRyxlQUdoRHZCLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQXNDLElBQTdCM0UsRUFBQUEsQ0FBQUEsQ0FBRW1HLHVCQUNmdEIsR0FBQUEsQ0FBQUEsQ0FBVzdFLENBQUVtRyxDQUFBQSx1QkFBQUEsQ0FBd0JoRCxDQUFVeUIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FLNUN6RCxDQURJLENBQUEsSUFBQSxFQUFQb0IsQ0FBZUEsRUFBQUEsQ0FBQUEsQ0FBSWhFLElBQVNjLEdBQUFBLEdBQUFBLEVBQXVCLE1BQVhrRCxDQUFJOUQsQ0FBQUEsR0FBQUEsQ0FDTDhELENBQUl0RSxDQUFBQSxLQUFBQSxDQUFNTyxRQUFXK0QsQ0FBQUEsQ0FBQUEsQ0FFN0RyQixHQUNDSixDQUFBQSxDQUFBQSxDQUNBbUIsS0FBTUMsQ0FBQUEsT0FBQUEsQ0FBUWYsQ0FBZ0JBLENBQUFBLENBQUFBLENBQUFBLENBQWUsQ0FBQ0EsQ0FBQUEsQ0FBQUEsQ0FDOUN1RCxDQUNBOUQsQ0FBQUEsQ0FBQUEsQ0FDQVUsQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQUMsQ0FDQWIsQ0FBQUEsQ0FBQUEsQ0FDQUUsQ0FDQVksQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHRHpCLENBQUVGLENBQUFBLElBQUFBLENBQU80RSxDQUdUQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFzQixJQUVsQjFFLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQW1CbkIsTUFDdEI4QixFQUFBQSxDQUFBQSxDQUFZVixJQUFLRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUdkOEUsQ0FDSDlFLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWtCQSxDQUF5QixDQUFBLEVBQUEsQ0FBQSxJQUFBLENBQUEsQ0FHNUNBLENBQVcsQ0FBQSxHQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsS0FFVSxJQUFyQndCLEVBQUFBLENBQUFBLEVBQ0FrRCxDQUF1QjlELENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBRXZCOEQsQ0FBcUI5RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUNyQjhELENBQWdCOUQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFFaEI4RCxDQUFnQjBCLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQ2Z4RixDQUNBOEQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDQTlELENBQ0FVLENBQUFBLENBQUFBLENBQ0FDLENBQ0FDLENBQUFBLENBQUFBLENBQ0FiLENBQ0FjLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBSUdjLENBQU1oRixDQUFBQSxHQUFBQSxDQUFROEksTUFBUzlELEdBQUFBLENBQUFBLENBQUltQyxDQUMvQixFQUFBLENBQUEsTUFBT0osR0FDUkksQ0FBcUIsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFBLENBRWpCakQsQ0FBb0MsRUFBQSxJQUFBLEVBQXJCRCxDQUNsQmtELElBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWdCN0QsQ0FDaEI2RCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUF3QmpELENBQ3hCRCxDQUFBQSxDQUFBQSxDQUFrQkEsQ0FBa0I5QixDQUFBQSxPQUFBQSxDQUFRbUIsQ0FBVyxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUEsQ0FJeER0RCxHQUFvQitHLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUdJLENBQVU5RCxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQVM1QixTQUFTSyxHQUFBQSxDQUFXTixDQUFhMkYsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDbkMvSSxHQUFpQkEsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBZ0IrSSxDQUFNM0YsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFM0NBLENBQVlGLENBQUFBLElBQUFBLENBQUssU0FBQVQsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FHZlcsQ0FBY1gsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDZEEsQ0FBcUIsQ0FBQSxHQUFBLENBQUEsRUFBQSxDQUNyQlcsQ0FBWUYsQ0FBQUEsSUFBQUEsQ0FBSyxTQUFBOEYsQ0FBQUEsQ0FBQUEsQ0FFaEJBLENBQUd6SCxDQUFBQSxJQUFBQSxDQUFLa0IsQ0FFUixFQUFBLENBQUEsRUFBQSxDQUFBLE1BQU9zRSxDQUNSL0csQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBb0IrRyxDQUFHdEUsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FtQjFCLFNBQVNvRyxHQUFBQSxDQUNSbkQsQ0FDQXlCLENBQUFBLENBQUFBLENBQ0E5RCxDQUNBVSxDQUFBQSxDQUFBQSxDQUNBQyxDQUNBQyxDQUFBQSxDQUFBQSxDQUNBYixDQUNBYyxDQUFBQSxDQUFBQSxDQUFBQSxDQVJELElBb0JTNUIsQ0FBQUEsQ0FzREgyRyxDQUNBQyxDQUFBQSxDQUFBQSxDQWpFRHRELENBQVd2QyxDQUFBQSxDQUFBQSxDQUFTM0MsTUFDcEJpRixDQUFXd0IsQ0FBQUEsQ0FBQUEsQ0FBU3pHLEtBQ3BCeUksQ0FBQUEsQ0FBQUEsQ0FBV2hDLENBQVNuRyxDQUFBQSxJQUFBQSxDQUNwQlosQ0FBSSxDQUFBLENBQUEsQ0FBQSxHQUdTLEtBQWIrSSxHQUFBQSxDQUFBQSxHQUFvQm5GLENBQVEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUVQLElBQXJCQyxFQUFBQSxDQUFBQSxDQUFBQSxLQUNJN0QsQ0FBSTZELENBQUFBLENBQUFBLENBQWtCM0MsTUFBUWxCLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLEdBQUFBLENBQzlCa0MsQ0FBUTJCLENBQUFBLENBQUFBLENBQWtCN0QsQ0FPL0IsQ0FBQSxHQUFBLGNBQUEsR0FBa0JrQyxDQUFZNkcsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FDN0JBLENBQVc3RyxDQUFBQSxDQUFBQSxDQUFNOEcsU0FBY0QsR0FBQUEsQ0FBQUEsQ0FBOEIsQ0FBbkI3RyxHQUFBQSxDQUFBQSxDQUFNNkcsUUFDaEQsQ0FBQSxDQUFBLENBQ0R6RCxDQUFNcEQsQ0FBQUEsQ0FBQUEsQ0FDTjJCLENBQWtCN0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBSyxJQU1mLENBQUEsS0FBQSxDQUFBLEdBQUEsSUFBQSxFQUFQc0YsQ0FBYSxDQUFBLENBQUEsR0FDQyxJQUFieUQsR0FBQUEsQ0FBQUEsQ0FBQUEsT0FFSUUsUUFBU0MsQ0FBQUEsY0FBQUEsQ0FBZTNELENBSS9CRCxDQUFBQSxDQUFBQSxDQUFBQSxDQURHMUIsQ0FDR3FGLENBQUFBLFFBQUFBLENBQVNFLGVBQ2QsQ0FBQSw0QkFBQSxDQUVBSixDQUdLRSxDQUFBQSxDQUFBQSxRQUFBQSxDQUFTdEksYUFFZG9JLENBQUFBLENBQUFBLENBQ0F4RCxDQUFTNkQsQ0FBQUEsRUFBQUEsRUFBTTdELENBS2pCMUIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBb0IsSUFFcEJDLENBQUFBLENBQUFBLENBQUFBLENBQWMsRUFHRSxDQUFBLEdBQUEsSUFBQSxHQUFiaUYsRUFFQ3ZELENBQWFELEdBQUFBLENBQUFBLEVBQWN6QixDQUFld0IsRUFBQUEsQ0FBQUEsQ0FBSStELElBQVM5RCxHQUFBQSxDQUFBQSxHQUMxREQsQ0FBSStELENBQUFBLElBQUFBLENBQU85RCxDQUVOLENBQUEsQ0FBQSxLQUFBLENBQUEsR0FFTjFCLENBQW9CQSxDQUFBQSxDQUFBQSxFQUFxQmxFLENBQU13QixDQUFBQSxJQUFBQSxDQUFLbUUsQ0FBSWdFLENBQUFBLFVBQUFBLENBQUFBLENBSXBEVCxDQUZKckQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBV3ZDLENBQVMzQyxDQUFBQSxLQUFBQSxFQUFTTCxHQUVOc0osRUFBQUEsdUJBQUFBLENBQ25CVCxDQUFVdkQsQ0FBQUEsQ0FBQUEsQ0FBU2dFLHVCQUlsQnpGLENBQUFBLENBQUFBLENBQUFBLENBQWEsQ0FHUSxHQUFBLElBQUEsRUFBckJELENBQ0gyQixDQUFBQSxJQUFBQSxDQUFBQSxDQUFXLEVBQ054RixDQUFBQSxDQUFBQSxDQUFJLENBQUdBLENBQUFBLENBQUFBLENBQUlzRixDQUFJa0UsQ0FBQUEsVUFBQUEsQ0FBV3RJLE1BQVFsQixDQUFBQSxDQUFBQSxFQUFBQSxDQUN0Q3dGLENBQVNGLENBQUFBLENBQUFBLENBQUlrRSxVQUFXeEosQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBRytGLElBQVFULENBQUFBLENBQUFBLENBQUFBLENBQUlrRSxVQUFXeEosQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBRzZGLEtBSW5EaUQsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBV0QsQ0FHWkMsSUFBQUEsQ0FBQUEsR0FDRUQsQ0FBV0MsRUFBQUEsQ0FBQUEsQ0FBQUEsTUFBQUEsRUFBa0JELENBQy9CQyxDQUFBQSxNQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxNQUFBQSxHQUFtQnhELENBQUltRSxDQUFBQSxTQUFBQSxDQUFBQSxHQUV4Qm5FLENBQUltRSxDQUFBQSxTQUFBQSxDQUFhWCxDQUFXQSxFQUFBQSxDQUFBQSxDQUFBQSxNQUFBQSxFQUFtQixFQUtsRHpELENBQUFBLEVBQUFBLENBQUFBLEdBQUFBLEdBQUFBLENBQVVDLEVBQUtDLENBQVVDLENBQUFBLENBQUFBLENBQVU1QixDQUFPRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUd0Q2dGLENBQ0gvQixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFxQixFQUVyQi9HLENBQUFBLEtBQUFBLEdBQUFBLENBQUFBLENBQUkrRyxDQUFTekcsQ0FBQUEsS0FBQUEsQ0FBTU8sUUFDbkIwQyxDQUFBQSxHQUFBQSxDQUNDK0IsQ0FDQWhCLENBQUFBLEtBQUFBLENBQU1DLE9BQVF2RSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFLQSxDQUFJLENBQUEsQ0FBQ0EsQ0FDeEIrRyxDQUFBQSxDQUFBQSxDQUFBQSxDQUNBOUQsQ0FDQVUsQ0FBQUEsQ0FBQUEsQ0FDQUMsQ0FBc0IsRUFBQSxlQUFBLEdBQWJtRixDQUNUbEYsQ0FBQUEsQ0FBQUEsQ0FDQWIsQ0FDQWEsQ0FBQUEsQ0FBQUEsQ0FDR0EsQ0FBa0IsQ0FBQSxDQUFBLENBQUEsQ0FDbEJaLENBQXNCcEIsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBY29CLENBQVUsQ0FBQSxDQUFBLENBQUEsQ0FDakRhLENBSXdCLENBQUEsQ0FBQSxJQUFBLEVBQXJCRCxDQUNFN0QsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBSTZELENBQWtCM0MsQ0FBQUEsTUFBQUEsQ0FBUWxCLENBQ04sRUFBQSxFQUFBLElBQUEsRUFBeEI2RCxDQUFrQjdELENBQUFBLENBQUFBLENBQUFBLEVBQVlPLEdBQVdzRCxDQUFBQSxDQUFBQSxDQUFrQjdELENBTTdEOEQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FFSCxPQUFXeUIsR0FBQUEsQ0FBQUEsRUFBQUEsS0FDY2xFLENBQXhCckIsSUFBQUEsQ0FBQUEsQ0FBSXVGLENBQVNNLENBQUFBLEtBQUFBLENBQUFBLEdBS2I3RixDQUFNc0YsR0FBQUEsQ0FBQUEsQ0FBSU8sS0FDSSxFQUFBLFVBQUEsR0FBYmtELENBQTRCL0ksRUFBQUEsQ0FBQUEsQ0FBQUEsRUFJZixRQUFiK0ksR0FBQUEsQ0FBQUEsRUFBeUIvSSxJQUFNd0YsQ0FBU0ssQ0FBQUEsS0FBQUEsQ0FBQUEsRUFFMUNILEdBQVlKLENBQUFBLENBQUFBLENBQUssT0FBU3RGLENBQUFBLENBQUFBLENBQUd3RixDQUFTSyxDQUFBQSxLQUFBQSxDQUFBQSxDQUFPLENBRzdDLENBQUEsQ0FBQSxTQUFBLEdBQWFOLENBQ2NsRSxFQUFBQSxLQUFBQSxDQUFBQSxJQUExQnJCLENBQUl1RixDQUFBQSxDQUFBQSxDQUFTbUUsT0FDZDFKLENBQUFBLEVBQUFBLENBQUFBLEdBQU1zRixDQUFJb0UsQ0FBQUEsT0FBQUEsRUFFVmhFLEdBQVlKLENBQUFBLENBQUFBLENBQUssU0FBV3RGLENBQUFBLENBQUFBLENBQUd3RixDQUFTa0UsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBUyxDQUs3Q3BFLENBQUFBLEVBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBU1IsU0FBZ0JYLEdBQUFBLENBQVM1RCxDQUFLOEUsQ0FBQUEsQ0FBQUEsQ0FBT3JFLENBRWpCLENBQUEsQ0FBQSxHQUFBLENBQUEsVUFBQSxFQUFBLE9BQVBULENBQW1CQSxDQUFBQSxDQUFBQSxDQUFJOEUsQ0FDN0I5RSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJNEksT0FBVTlELENBQUFBLEVBQUFBLENBQ2xCLE1BQU9jLENBQUFBLENBQUFBLENBQ1IvRyxHQUFvQitHLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUduRixDQVl6QixFQUFBLENBQUEsQ0FBQSxTQUFnQmtELENBQVFsRCxDQUFBQSxDQUFBQSxDQUFPb0ksQ0FBYUMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBNUMsSUFDS0MsQ0FBQUEsQ0FvQk05SixDQW5CTkosQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBUThFLE9BQVM5RSxFQUFBQSxHQUFBQSxDQUFROEUsT0FBUWxELENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBRWhDc0ksQ0FBSXRJLENBQUFBLENBQUFBLENBQU1ULEdBQ1QrSSxJQUFBQSxDQUFBQSxDQUFFSCxPQUFXRyxFQUFBQSxDQUFBQSxDQUFFSCxVQUFZbkksQ0FBWW1ELENBQUFBLEdBQUFBLEVBQUFBLEdBQUFBLENBQVNtRixDQUFHLENBQUEsSUFBQSxDQUFNRixDQUdqQyxDQUFBLENBQUEsQ0FBQSxJQUFBLEdBQXpCRSxDQUFJdEksQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBMkIsQ0FDL0JzSSxHQUFBQSxDQUFBQSxDQUFFQyxvQkFFSkQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBRUMsb0JBQ0QsR0FBQSxDQUFBLE1BQU9wRCxDQUNSL0csQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBb0IrRyxDQUFHaUQsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FJekJFLENBQUUzSCxDQUFBQSxJQUFBQSxDQUFPMkgsQ0FBZSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsR0FHcEJBLENBQUl0SSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxJQUNDeEIsQ0FBSSxDQUFBLENBQUEsQ0FBR0EsQ0FBSThKLENBQUFBLENBQUFBLENBQUU1SSxNQUFRbEIsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FDekI4SixDQUFFOUosQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFDTDBFLENBQVFvRixDQUFBQSxDQUFBQSxDQUFFOUosQ0FBSTRKLENBQUFBLENBQUFBLENBQUFBLENBQWtDLFVBQWRwSSxFQUFBQSxPQUFBQSxDQUFBQSxDQUFNWixJQUt0Q2lKLENBQUFBLENBQUFBLENBQUFBLEVBQTRCLElBQWRySSxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFvQmpCLEdBQVdpQixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUlsREEsQ0FBYUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsS0FBaUJILEVBSS9CLENBQUEsU0FBU3VHLEdBQVN0SCxDQUFBQSxDQUFBQSxDQUFPd0gsQ0FBT2xHLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BQ3hCb0ksSUFBS3ZJLENBQUFBLFdBQUFBLENBQVluQixDQUFPc0IsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0NyZ0JoQyxTQUFnQitGLEdBQUFBLENBQU9uRyxDQUFPMkIsQ0FBQUEsQ0FBQUEsQ0FBVzhHLENBQXpDLENBQUEsQ0FBQSxJQU1LbkcsRUFPQWIsQ0FVQUQsQ0FBQUEsQ0FBQUEsQ0F0QkFwRCxHQUFlQSxDQUFBQSxFQUFBQSxFQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFjNEIsQ0FBTzJCLENBQUFBLENBQUFBLENBQUFBLENBWXBDRixDQVBBYSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFxQyxVQUFoQm1HLEVBQUFBLE9BQUFBLENBQUFBLEVBUXRCLElBQ0NBLENBQUFBLENBQUFBLEVBQWVBLENBQTBCOUcsQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FRekNILENBQWMsQ0FBQSxFQUFBLENBQ2xCSSxHQUNDRCxDQUFBQSxDQUFBQSxDQVJEM0IsQ0FDR3NDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQWVtRyxDQUNqQjlHLEVBQUFBLENBQUFBLEVBQUFBLEdBQUFBLENBQ2F4QyxHQUFjZSxDQUFBQSxHQUFBQSxDQUFVLElBQU0sQ0FBQSxDQUFDRixDQVM1Q3lCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQVloRCxHQUNaQSxDQUFBQSxHQUFBQSxDQUFBQSxLQUM4Qm9CLENBQTlCOEIsR0FBQUEsQ0FBQUEsQ0FBVUUsZUFDVFMsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBZW1HLENBQ2IsQ0FBQSxDQUFDQSxDQUNEaEgsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDQSxJQUNBRSxDQUFBQSxDQUFBQSxDQUFVK0csVUFDVnZLLENBQUFBLENBQUFBLENBQU13QixJQUFLZ0MsQ0FBQUEsQ0FBQUEsQ0FBVW1HLFVBQ3JCLENBQUEsQ0FBQSxJQUFBLENBQ0h0RyxDQUNDYyxDQUFBQSxDQUFBQSxDQUFBQSxFQUFlbUcsQ0FDYkEsQ0FBQUEsQ0FBQUEsQ0FDQWhILENBQ0FBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQ0FFLENBQVUrRyxDQUFBQSxVQUFBQSxDQUNicEcsQ0FJRFIsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBV04sQ0FBYXhCLENBQUFBLENBQUFBLEVBQUFBLENMM0RsQixTQUFTMkksQ0FBQUEsQ0FBY0MsQ0FBY0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFHckN6SSxDQUFVLENBQUEsQ0FBQSxHQUFBLENBRmhCeUksRUFBWSxNQUFTckssQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsRUFBQUEsQ0FJTG9LLENBRWZFLENBQUFBLFFBQUFBLENBQUFBLFNBQVNoSyxDQUFPaUssQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FJUmpLLENBQU1PLENBQUFBLFFBQUFBLENBQVMwSixDQUd2QkMsQ0FBQUEsQ0FBQUEsQ0FBQUEsUUFBQUEsQ0FBQUEsU0FBU2xLLENBRUhtSyxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUNBQyxDQUZBVixDQUFBQSxPQUFBQSxJQUFBQSxDQUFLekIsZUFDTGtDLEdBQUFBLENBQUFBLENBQU8sRUFDUEMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTSxFQUNOTCxFQUFBQSxDQUFBQSxDQUFBQSxDQUFhTCxJQUVaekIsQ0FBQUEsSUFBQUEsQ0FBQUEsZUFBQUEsQ0FBa0IsVUFBTW1DLENBQUFBLE9BQUFBLENBQUFBLENBQUFBLENBQUFBLElBQUFBLENBRXhCdkMscUJBQXdCLENBQUEsU0FBU3dDLENBQ2pDWCxDQUFBQSxDQUFBQSxJQUFBQSxDQUFLMUosS0FBTXVGLENBQUFBLEtBQUFBLEdBQVU4RSxDQUFPOUUsQ0FBQUEsS0FBQUEsRUFlL0I0RSxDQUFLM0gsQ0FBQUEsSUFBQUEsQ0FBS1YsR0FJUHlGLEVBQUFBLENBQUFBLENBQUFBLElBQUFBLENBQUFBLEdBQUFBLENBQU0sU0FBQXhGLENBQUFBLENBQUFBLENBQ1ZvSSxDQUFLbkksQ0FBQUEsSUFBQUEsQ0FBS0QsQ0FDTnVJLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQU12SSxDQUFFMEgsQ0FBQUEsb0JBQUFBLENBQ1oxSCxDQUFFMEgsQ0FBQUEsb0JBQUFBLENBQXVCLFVBQ3hCVSxDQUFBQSxDQUFBQSxDQUFLSSxNQUFPSixDQUFBQSxDQUFBQSxDQUFLMUksT0FBUU0sQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBSSxDQUN6QnVJLENBQUFBLENBQUFBLENBQUFBLEVBQUtBLENBQUl6SixDQUFBQSxJQUFBQSxDQUFLa0IsQ0FLZC9CLEVBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQU1PLFFBVVBlLENBQUFBLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQVE0SSxRQUF1QjVJLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQVEwSSxTQUFTN0MsV0FBYzdGLENBQUFBLENBQUFBLENKeEMxRGpDLENBQVFPLENBQUFBLEdBQUFBLENBQVVQLEtDZnpCQyxDQUFBQSxHQUFBQSxDQUFVLENTRmhCLEdBQUEsQ0FBQSxTQUE0QmtMLENBQU90SixDQUFBQSxDQUFBQSxDQUFPeUIsQ0FBVThILENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBQUFBLElBRS9DaEksQ0FBV2lJLENBQUFBLENBQUFBLENBQU1DLENBRWJ6SixDQUFBQSxDQUFBQSxDQUFRQSxDQUNWdUIsQ0FBQUEsRUFBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBWXZCLENBQXNCdUIsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FFckNpSSxDQUFPakksQ0FBQUEsQ0FBQUEsQ0FBVXRCLFdBRTRCLEdBQUEsSUFBQSxFQUFqQ3VKLENBQUtFLENBQUFBLHdCQUFBQSxHQUNoQm5JLENBQVVvSSxDQUFBQSxRQUFBQSxDQUFTSCxDQUFLRSxDQUFBQSx3QkFBQUEsQ0FBeUJKLENBQ2pERyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFVbEksQ0FHd0IsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUFBLEVBQS9CQSxDQUFVcUksQ0FBQUEsaUJBQUFBLEdBQ2JySSxDQUFVcUksQ0FBQUEsaUJBQUFBLENBQWtCTixDQUFPQyxDQUFBQSxDQUFBQSxFQUFhLEVBQ2hERSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFVbEksQ0FJUGtJLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BQ0tsSSxDQUEwQkEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFbEMsTUFBTzRELENBQUFBLENBQUFBLENBQ1JtRSxDQUFRbkUsQ0FBQUEsRUFBQUEsQ0FBQUEsTUFLTG1FLENSbkNIakwsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBVSxDQTZGRHdMLENDdEViMUosR0FBQUEsQ0FBVStGLFVBQVV5RCxRQUFXLENBQUEsU0FBU0csQ0FBUUMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFFM0NDLENBRUhBLENBQUFBLENBQUFBLENBRHNCLElBQW5CeEIsRUFBQUEsSUFBQUEsQ0FBQUEsR0FBQUEsRUFBMkJBLElBQW9CQSxDQUFBQSxHQUFBQSxHQUFBQSxJQUFBQSxDQUFLbEMsS0FDbkRrQyxDQUFBQSxJQUFBQSxDQUFBQSxHQUFBQSxDQUVBQSxJQUFrQjVKLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQU8sRUFBSTRKLENBQUFBLElBQUFBLENBQUtsQyxLQUdsQixDQUFBLENBQUEsVUFBQSxFQUFBLE9BQVZ3RCxDQUdWQSxHQUFBQSxDQUFBQSxDQUFTQSxDQUFPbEwsQ0FBQUEsR0FBQUEsQ0FBTyxFQUFJb0wsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBSXhCLElBQUsxSixDQUFBQSxLQUFBQSxDQUFBQSxDQUFBQSxDQUdqQ2dMLENBQ0hsTCxFQUFBQSxHQUFBQSxDQUFPb0wsQ0FBR0YsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FJRyxJQUFWQSxFQUFBQSxDQUFBQSxFQUVBdEIsSUFDQ3VCLENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLEVBQVV2QixJQUFzQjFILENBQUFBLEdBQUFBLENBQUFBLElBQUFBLENBQUtpSixDQUN6Q25KLENBQUFBLENBQUFBLEdBQUFBLENBQWM0SCxJQVVoQnJJLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQVUrRixTQUFVK0QsQ0FBQUEsV0FBQUEsQ0FBYyxTQUFTRixDQUFBQSxDQUFBQSxDQUN0Q3ZCLElBSVcsQ0FBQSxHQUFBLEdBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDVnVCLENBQVV2QixFQUFBQSxJQUFBQSxDQUFBQSxHQUFBQSxDQUFzQjFILElBQUtpSixDQUFBQSxDQUFBQSxDQUFBQSxDQUN6Q25KLEdBQWM0SCxDQUFBQSxJQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQWNoQnJJLEdBQVUrRixDQUFBQSxTQUFBQSxDQUFVQyxNQUFTakcsQ0FBQUEsR0FBQUEsQ0F5RnpCNUIsR0FBZ0IsQ0FBQSxFQUFBLENBMkNwQnlDLEdBQXlCLENBQUEsR0FBQSxDQUFBLENBQUEsQ0NuTmR2QyxHQUFJLENBQUEsQ0FBQTs7SU9FZixJQUFJSCxHQUFVLENBQUEsQ0FBQSxDQXFCZCxTQUFTeUIsR0FBQUEsQ0FBWVYsQ0FBTU4sQ0FBQUEsQ0FBQUEsQ0FBT1EsQ0FBSzRLLENBQUFBLENBQUFBLENBQVFDLENBSzdDNUssQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FDQWYsQ0FGR2dCLENBQUFBLENBQUFBLENBQWtCLE9BR2pCaEIsQ0FBS00sSUFBQUEsQ0FBQUEsQ0FDQSxLQUFMTixFQUFBQSxDQUFBQSxDQUNIZSxDQUFNVCxDQUFBQSxDQUFBQSxDQUFNTixDQUVaZ0IsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBZ0JoQixHQUFLTSxDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUl2QndCLENBQVEsQ0FBQSxDQUNiWixJQUFBQSxDQUFBQSxDQUFBQSxDQUNBTixLQUFPVSxDQUFBQSxDQUFBQSxDQUNQRixJQUFBQSxDQUNBQyxDQUFBQSxHQUFBQSxDQUFBQSxDQUNXLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxFQUFBLENBQ0YsSUFDRCxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUNGLElBQ0lNLENBQUFBLEdBQUFBLENBQUFBLEtBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQ0UsSUFDQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQ1pJLFdBQWFKLENBQUFBLEtBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEVBQ0F4QixHQUNiOEwsQ0FBQUEsUUFBQUEsQ0FBQUEsQ0FDQUQsQ0FBQUEsTUFBQUEsQ0FBQUEsTUFLbUIsVUFBVDlLLEVBQUFBLE9BQUFBLENBQUFBLEdBQXdCRyxDQUFNSCxDQUFBQSxDQUFBQSxDQUFLUSxZQUN4Q3BCLENBQUFBLENBQUFBLElBQUFBLENBQUFBLElBQUtlLENBQ3lCLENBQUEsS0FBQSxDQUFBLEdBQXZCQyxFQUFnQmhCLENBQzFCZ0IsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBZ0JoQixDQUFLZSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJZixDQUl4QkosQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FBQUEsR0FBQUEsQ0FBUTRCLEtBQU81QixFQUFBQSxHQUFBQSxDQUFRNEIsTUFBTUEsQ0FDMUJBLENBQUFBLENBQUFBLENBQUFBOztJQ2pFUixJQUFJb0ssQ0FHQUMsQ0FBQUEsQ0FBQUEsQ0FHQUMsR0FpQkFDLENBQUFBLENBQUFBLENBZEFDLENBQWMsQ0FBQSxDQUFBLENBR2RDLENBQW9CLENBQUEsRUFBQSxDQUVwQkMsQ0FBUSxDQUFBLEVBQUEsQ0FFUkMsQ0FBZ0J2TSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUNoQndNLENBQWtCeE0sQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FDbEJ5TSxDQUFlek0sQ0FBQUEsR0FBQUEsQ0FBUThJLE1BQ3ZCNEQsQ0FBQUEsQ0FBQUEsQ0FBWTFNLEdBQ1oyTSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFtQjNNLEdBQVE4RSxDQUFBQSxPQUFBQSxDQWdHL0IsU0FBUzhILENBQUFBLENBQWFDLENBQU83TCxDQUFBQSxDQUFBQSxDQUFBQSxDQUN4QmhCLEdBQ0hBLENBQUFBLEdBQUFBLEVBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQWNpTSxFQUFrQlksQ0FBT1QsQ0FBQUEsQ0FBQUEsRUFBZXBMLENBRXZEb0wsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBYyxDQU9SVSxDQUFBQSxJQUFBQSxDQUFBQSxDQUNMYixDQUNDQSxDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUEyQixDQUNwQixFQUFBLENBQUEsRUFBQSxDQUFBLEdBQUEsQ0FDVSxFQUdmWSxDQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxFQUFTQyxDQUFZeEwsQ0FBQUEsRUFBQUEsQ0FBQUEsTUFBQUEsRUFDeEJ3TCxDQUFZcEssQ0FBQUEsRUFBQUEsQ0FBQUEsSUFBQUEsQ0FBSyxDQUFpQjRKLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBRTVCUSxDQUFZRCxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQU1iLFNBQVNFLENBQUFBLENBQVNDLENBQ3hCWixDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxDQUFjLENBQ1BhLENBQUFBLENBQUFBLENBQVdDLENBQWdCRixDQUFBQSxDQUFBQSxDQUFBQSxDQVNuQyxTQUFnQkMsQ0FBQUEsQ0FBV0UsQ0FBU0gsQ0FBQUEsQ0FBQUEsQ0FBY0ksT0FFM0NDLENBQVlULENBQUFBLENBQUFBLENBQWFaLENBQWdCLEVBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxPQUMvQ3FCLENBQVVDLENBQUFBLENBQUFBLENBQVdILENBQ2hCRSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxHQUNKQSxDQUFtQixDQUFBLEVBQUEsQ0FBQSxDQUNqQkQsQ0FBaURBLENBQUFBLENBQUFBLENBQUtKLENBQS9DRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxLQUFlekwsQ0FBV3VMLENBQUFBLENBQUFBLENBQUFBLENBRWxDLFNBQUFPLENBQUFBLENBQUFBLENBQUFBLElBQ09DLENBQVlILENBQUFBLENBQUFBLENBQVVDLENBQVNELENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQWlCLENBQUlFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQ3RERixDQUFpQixDQUFBLEVBQUEsQ0FBQSxDQUFBLENBQUEsR0FBT0csQ0FDM0JILEdBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQW1CLENBQUNHLENBQUFBLENBQVdILENBQWlCLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQ2hEQSxNQUFxQjlCLFFBQVMsQ0FBQSxFQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FLakM4QixDQUF1QnBCLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBR2pCb0IsQ0FPRCxDQUFBLEVBQUEsQ0FBQSxTQUFTSSxDQUFVOUIsQ0FBQUEsQ0FBQUEsQ0FBVStCLENBRTdCeEYsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBUTBFLENBQWFaLENBQUFBLENBQUFBLEVBQUFBLENBQWdCLENBQ3RDaE0sQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsRUFBd0IyTixHQUFZekYsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBYXdGLENBQ3JEeEYsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZXlELENBQ2Z6RCxDQUFBQSxDQUFBQSxDQUFNMEYsQ0FBZUYsQ0FBQUEsQ0FBQUEsQ0FFckJ6QixDQUF5Q3ZKLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQUFBLElBQUFBLENBQUt3RixDQVF6QyxDQUFBLEVBQUEsQ0FBQSxTQUFTMkYsQ0FBZ0JsQyxDQUFBQSxDQUFBQSxDQUFVK0IsQ0FFbkN4RixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFRMEUsQ0FBYVosQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZ0IsSUFDdENoTSxHQUF3QjJOLENBQUFBLEdBQUFBLEVBQUFBLEdBQUFBLENBQVl6RixDQUFhd0YsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FDckR4RixDQUFleUQsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FDZnpELENBQU0wRixDQUFBQSxDQUFBQSxDQUFlRixDQUVyQnpCLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWtDdkosSUFBS3dGLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBSWxDLFNBQVM0RixDQUFBQSxDQUFPQyxDQUN0QjNCLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQWMsQ0FDUDRCLENBQUFBLEdBQUFBLENBQVEsVUFBTyxDQUFBLE9BQUEsQ0FBRWpFLE9BQVNnRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFpQixFQVFuRCxDQUFBLENBb0JPLFNBQVNDLEdBQVFDLENBQUFBLENBQUFBLENBQVNQLENBRTFCeEYsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBUTBFLENBQWFaLENBQUFBLENBQUFBLEVBQUFBLENBQWdCLENBQ3ZDMkIsQ0FBQUEsQ0FBQUEsT0FBQUEsR0FBQUEsQ0FBWXpGLENBQWF3RixDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUM1QnhGLE1BQXNCK0YsQ0FDdEIvRixFQUFBQSxDQUFBQSxDQUFBQSxDQUFNMEYsQ0FBZUYsQ0FBQUEsQ0FBQUEsQ0FDckJ4RixDQUFpQitGLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQ1YvRixDQUdEQSxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQU9ELFNBQVNnRyxHQUFBQSxDQUFZdkMsQ0FBVStCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BQ3JDdEIsQ0FBYyxDQUFBLENBQUEsQ0FDUDRCLEdBQVEsQ0FBQSxVQUFBLENBQUEsT0FBTXJDLENBQVUrQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQU16QixTQUFTUyxHQUFBQSxDQUFXbk0sQ0FDcEJ3RixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFXeUUsQ0FBaUJqSyxDQUFBQSxPQUFBQSxDQUFRQSxDQUtwQ2tHLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQVEwRSxDQUFhWixDQUFBQSxDQUFBQSxFQUFBQSxDQUFnQixDQUkzQzlELENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQUFBLENBQUFBLENBQWlCbEcsQ0FDWndGLENBQUFBLENBQUFBLEVBRWUsTUFBaEJVLENBQ0hBLENBQUFBLEVBQUFBLEdBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBQWUsQ0FDZlYsQ0FBQUEsQ0FBQUEsQ0FBU1MsR0FBSWdFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBRVB6RSxDQUFTOUcsQ0FBQUEsS0FBQUEsQ0FBTXVGLEtBTkFqRSxFQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQTRDdkIsU0FBU29NLENBQ0pqTCxFQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxDQUNJQSxDQUFZa0osQ0FBQUEsQ0FBQUEsQ0FBa0JnQyxLQUNoQ2xMLEVBQUFBLEVBQUFBLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBRUpBLENBQWtDcUYsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsT0FBQUEsQ0FBUThGLEdBQzFDbkwsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBa0NxRixPQUFRK0YsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDMUNwTCxVQUFvQyxHQUNuQyxDQUFBLE1BQU80RCxDQUNSNUQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBb0MsRUFDcENuRCxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFvQitHLENBQUc1RCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQTlTMUJuRCxHQUFnQixDQUFBLEdBQUEsQ0FBQSxTQUFBNEIsQ0FDZnFLLENBQUFBLENBQUFBLENBQUFBLENBQW1CLElBQ2ZNLENBQUFBLENBQUFBLEVBQWVBLENBQWMzSyxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQUdsQzVCLEdBQWtCLENBQUEsR0FBQSxDQUFBLFNBQUE0QixDQUNiNEssQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBaUJBLENBQWdCNUssQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHckNvSyxDQUFlLENBQUEsQ0FBQSxDQUFBLElBRVRjLENBSE5iLENBQUFBLENBQUFBLENBQUFBLENBQW1CckssQ0FJZmtMLENBQUFBLEdBQUFBLEVBQUFBLEdBQUFBLENBQUFBLENBQUFBLEdBQ0NaLEdBQXNCRCxHQUFBQSxDQUFBQSxFQUN6QmEsQ0FBd0IsQ0FBQSxHQUFBLENBQUEsRUFBQSxDQUN4QmIsTUFBb0MsRUFDcENhLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQVl0RSxPQUFRLENBQUEsU0FBQWdHLENBQ25CQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUF5QmxDLENBQ3pCa0MsQ0FBQUEsQ0FBQUEsQ0FBU1osQ0FBZW5NLENBQUFBLEtBQUFBLEVBQUFBLENBQUFBLENBQUFBLEdBR3pCcUwsQ0FBc0J0RSxDQUFBQSxHQUFBQSxDQUFBQSxPQUFBQSxDQUFROEYsR0FDOUJ4QixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFzQnRFLE9BQVErRixDQUFBQSxDQUFBQSxDQUFBQSxDQUM5QnpCLENBQXdCLENBQUEsR0FBQSxDQUFBLEVBQUEsQ0FBQSxDQUFBLENBRzFCWixHQUFvQkQsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FHckJqTSxHQUFROEksQ0FBQUEsTUFBQUEsQ0FBUyxTQUFBbEgsQ0FBQUEsQ0FBQUEsQ0FDWjZLLENBQWNBLEVBQUFBLENBQUFBLENBQWE3SyxDQUV6QmEsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBSWIsQ0FDTmEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsRUFBS0EsQ0FDSkEsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBMEJuQixTQW1UUixDQW5UMkIrSyxHQUFBQSxDQUFBQSxDQUFrQjNKLElBQUtELENBQUFBLENBQUFBLENBQUFBLEVBbVQ3QzBKLENBQVluTSxHQUFBQSxHQUFBQSxDQUFReU8scUJBQy9DdEMsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBVW5NLEdBQVF5TyxDQUFBQSxxQkFBQUEsR0F2QnBCLFNBQXdCOUMsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFRbkIrQyxDQVBFQyxDQUFBQSxDQUFBQSxDQUFPLFVBQ1pDLENBQUFBLFlBQUFBLENBQWFDLENBQ1RDLENBQUFBLENBQUFBLEdBQUFBLEVBQVNDLG9CQUFxQkwsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDbEM3TCxVQUFXOEksQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FFTmtELENBQVVoTSxDQUFBQSxVQUFBQSxDQUFXOEwsQ0F4VVIsQ0FBQSxHQUFBLENBQUEsQ0EyVWZHLEdBQ0hKLEdBQUFBLENBQUFBLENBQU1ELHFCQUFzQkUsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsRUFjQVAsQ0FwVDVCM0wsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZ0IrRixRQUFRLFNBQUFnRyxDQUFBQSxDQUFBQSxDQUNuQkEsQ0FBU1osQ0FBQUEsQ0FBQUEsR0FDWlksQ0FBaUJBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQVNaLENBRXZCWSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxHQUEyQmxDLENBQzlCa0MsR0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBa0JBLENBRW5CQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFTWixDQUFlbk0sQ0FBQUEsS0FBQUEsQ0FBQUEsQ0FDeEIrTSxDQUF5QmxDLENBQUFBLEdBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLENBRzNCSixHQUFvQkQsQ0FBQUEsQ0FBQUEsQ0FBbUIsS0FHeENqTSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFrQixTQUFDNEIsQ0FBQUEsQ0FBT3dCLENBQ3pCQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFZRixJQUFLLENBQUEsU0FBQUMsQ0FFZkEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBMkJxRixPQUFROEYsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FDbkNuTCxDQUE2QkEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBMkI2TCxPQUFPLFNBQUFoRyxDQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxDQUM5REEsQ0FBWXVGLENBQUFBLEVBQUFBLEVBQUFBLENBQUFBLENBQWF2RixDQUV6QixDQUFBLENBQUEsRUFBQSxDQUFBLE1BQU9qQyxDQUNSM0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBWUYsSUFBSyxDQUFBLFNBQUFULENBQ1pBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBQW9CQSxDQUFxQixDQUFBLEdBQUEsQ0FBQSxFQUFBLEVBQUEsQ0FBQSxDQUFBLENBRTlDVyxDQUFjLENBQUEsRUFBQSxDQUNkcEQsR0FBb0IrRyxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFHNUQsQ0FJckJ1SixDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFXQSxDQUFVOUssQ0FBQUEsQ0FBQUEsQ0FBT3dCLENBR2pDcEQsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBUThFLE9BQVUsQ0FBQSxTQUFBbEQsQ0FDYitLLENBQUFBLENBQUFBLENBQUFBLEVBQWtCQSxDQUFpQi9LLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBSWxDcU4sQ0FGQ3hNLENBQUFBLENBQUFBLENBQUliLE1BQ05hLENBQUtBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBRVJBLENBQWdCK0YsQ0FBQUEsR0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsT0FBQUEsQ0FBUSxTQUFBb0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FFdEIwQyxHQUFjMUMsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FDYixNQUFPN0UsQ0FBQUEsQ0FBQUEsQ0FDUmtJLENBQWFsSSxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUdYa0ksQ0FBWWpQLEVBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQW9CaVAsQ0FBWXhNLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBa09sRCxJQUFJcU0sR0FBQUEsQ0FBMEMsVUFBekJMLEVBQUFBLE9BQUFBLHFCQUFBQSxDQTJDckIsU0FBU0gsR0FBQUEsQ0FBY1ksQ0FHaEJDLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQU9sRCxDQUNUbUQsQ0FBQUEsQ0FBQUEsQ0FBVUYsQ0FDUSxDQUFBLEdBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBWEUsQ0FDVkYsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsS0FBZ0J6TixDQUNoQjJOLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBRURuRCxFQUFtQmtELEVBT3BCLENBQUEsU0FBU1osQ0FBYVcsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFHZkMsQ0FBT2xELENBQUFBLENBQUFBLENBQ2JpRCxDQUFnQkEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsRUFBQUEsQ0FDaEJqRCxDQUFtQmtELENBQUFBLEVBQUFBLENBT3BCLFNBQVN4QixHQUFBQSxDQUFZMEIsQ0FBU0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FFM0JELENBQ0RBLEVBQUFBLENBQUFBLENBQVEvTixTQUFXZ08sQ0FBUWhPLENBQUFBLE1BQUFBLEVBQzNCZ08sQ0FBUXBNLENBQUFBLElBQUFBLENBQUssU0FBQ3FNLENBQUFBLENBQUsxQyxDQUFVMEMsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsR0FBUUYsQ0FBUXhDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBSS9DLFNBQVNLLENBQUFBLENBQWVxQyxDQUFLQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxPQUNULFVBQUxBLEVBQUFBLE9BQUFBLENBQUFBLENBQWtCQSxFQUFFRCxDQUFPQyxDQUFBQSxDQUFBQSxDQUFBQTs7SUN4Wm5DLFNBQVNoUCxFQUFPQyxDQUFLQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUN0QixJQUFJTixDQUFBQSxJQUFLTSxFQUFPRCxDQUFJTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFLTSxDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxPQUNQSyxFQVN2QixTQUFTZ1AsQ0FBQUEsQ0FBZXpNLENBQUdDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBQzVCLElBQUk3QyxDQUFLNEMsSUFBQUEsQ0FBQUEsQ0FBQUEsR0FBYSxVQUFONUMsR0FBQUEsQ0FBQUEsRUFBQUEsRUFBc0JBLEtBQUs2QyxDQUFJLENBQUEsQ0FBQSxPQUFBLENBQU8sQ0FDdEQsQ0FBQSxJQUFBLElBQUk3QyxLQUFLNkMsQ0FBYSxDQUFBLEdBQUEsVUFBQSxHQUFON0MsQ0FBb0I0QyxFQUFBQSxDQUFBQSxDQUFFNUMsS0FBTzZDLENBQUU3QyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJLFFBQU8sQ0FDeEQsQ0FBQSxPQUFBLENBQUEsQ0FBQSxDQ2ZELFNBQVNzUCxDQUFjQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUFBQSxDQUN4QmpQLEtBQVFpUCxDQUFBQSxFQUFBQSxDQ0dQLFNBQVNDLENBQUtuTixDQUFBQSxDQUFBQSxDQUFHb04sQ0FDZEMsQ0FBQUEsQ0FBQUEsU0FBQUEsQ0FBQUEsQ0FBYUMsT0FDakI1TyxDQUFNaUosQ0FBQUEsSUFBQUEsQ0FBSzFKLEtBQU1TLENBQUFBLEdBQUFBLENBQ2pCNk8sRUFBWTdPLENBQU80TyxFQUFBQSxDQUFBQSxDQUFVNU8sR0FDNUI2TyxDQUFBQSxPQUFBQSxDQUFBQSxDQUFBQSxFQUFhN08sSUFDakJBLENBQUlJLENBQUFBLElBQUFBLENBQU9KLENBQUksQ0FBQSxJQUFBLENBQUEsQ0FBU0EsRUFBSTRJLE9BQVUsQ0FBQSxJQUFBLENBQUEsQ0FHbEM4RixDQUlHQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFTekYsS0FBSzFKLEtBQU9xUCxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFlQyxDQUhwQ1AsQ0FBQUEsQ0FBQUEsQ0FBZXJGLEtBQUsxSixLQUFPcVAsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsU0FNM0JFLEVBQU92UCxDQUNWNkgsQ0FBQUEsQ0FBQUEsT0FBQUEsSUFBQUEsQ0FBQUEscUJBQUFBLENBQXdCdUgsRUFDdEIvTyxHQUFjMEIsQ0FBQUEsQ0FBQUEsQ0FBRy9CLENBRXpCdVAsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBT0MsWUFBYyxPQUFXek4sRUFBQUEsQ0FBQUEsQ0FBRXlOLFdBQWV6TixFQUFBQSxDQUFBQSxDQUFFMEQsTUFBUSxHQUMzRDhKLENBQUFBLENBQUFBLENBQU9uSSxTQUFVcUksQ0FBQUEsZ0JBQUFBLENBQUFBLENBQW1CLEVBQ3BDRixDQUFvQixDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDYkEsQ0R2QlJQLENBQUFBLENBQUFBLENBQUFBLENBQWM1SCxVQUFZLElBQUkvRixHQUFBQSxFQUVOcU8sb0JBQXVCLENBQUEsQ0FBQSxDQUFBLENBQy9DVixFQUFjNUgsU0FBVVMsQ0FBQUEscUJBQUFBLENBQXdCLFNBQVM3SCxDQUFBQSxDQUFPd0gsVUFDeER1SCxDQUFlckYsQ0FBQUEsSUFBQUEsQ0FBSzFKLEtBQU9BLENBQUFBLENBQUFBLENBQUFBLEVBQVUrTyxFQUFlckYsSUFBS2xDLENBQUFBLEtBQUFBLENBQU9BLElFVnhFLElBQUltSSxDQUFBQSxDQUFjclEsUUFDbEJBLEdBQWdCLENBQUEsR0FBQSxDQUFBLFNBQUE0QixDQUNYQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFNWixNQUFRWSxDQUFNWixDQUFBQSxJQUFBQSxDQUFBQSxHQUFBQSxFQUFtQlksQ0FBTVQsQ0FBQUEsR0FBQUEsR0FDaERTLEVBQU1sQixLQUFNUyxDQUFBQSxHQUFBQSxDQUFNUyxDQUFNVCxDQUFBQSxHQUFBQSxDQUN4QlMsRUFBTVQsR0FBTSxDQUFBLElBQUEsQ0FBQSxDQUVUa1AsR0FBYUEsQ0FBWXpPLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBaUN0QjBPLElDdkNGQyxDQUFBQSxDQUFnQnZRLEdBQ3RCQSxDQUFBQSxJQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFzQixTQUFTa0wsQ0FBTy9ELENBQUFBLENBQUFBLENBQVU5RCxDQUFVOEgsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FDckRELEVBQU1zRixJQUVMck4sQ0FBQUEsSUFBQUEsSUFBQUEsQ0FBQUEsQ0FDQXZCLENBQVF1RixDQUFBQSxDQUFBQSxDQUVKdkYsRUFBUUEsQ0FDVnVCLENBQUFBLEVBQUFBLEVBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQVl2QixRQUFxQnVCLENBQ2hCLENBQUEsR0FBQSxDQUFBLE9BQUEsSUFBQSxFQUFqQmdFLFFBQ0hBLENBQWdCOUQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDaEI4RCxDQUFxQjlELENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBR2ZGLE1BQTJCK0gsQ0FBTy9ELENBQUFBLENBQUFBLENBQUFBLENBSTVDb0osQ0FBY3JGLENBQUFBLENBQUFBLENBQU8vRCxFQUFVOUQsQ0FBVThILENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBRzFDLElBQU1zRixDQUFBQSxDQUFhelEsSUFBUThFLE9BdUUzQixDQUFBLFNBQWdCNEwsQ0FFZ0IsRUFBQSxDQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FDMUJDLEVBQWMsSUFDUSxDQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsS0FBQSxDQW9JckIsU0FBU0MsQ0FBQUEsQ0FBVWhQLE9BRXJCdUIsQ0FBWXZCLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLEdBQUFBLENBQUFBLE9BQ1R1QixDQUFhQSxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUF3QkEsTUFBcUJ2QixDQUczRCxDQUFBLENDcE9QLFNBQWdCaVAsQ0FDVkMsRUFBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBUSxJQUNSQyxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxDQUFPLE1EY2IvUSxHQUFROEUsQ0FBQUEsT0FBQUEsQ0FBVSxTQUFTbEQsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFFcEJ1QixFQUFZdkIsQ0FDZHVCLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLEVBQWFBLE9BQ2hCQSxDQU9HQSxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFrQyxJQUFyQnZCLENBQ2hCQSxDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFNWixJQUFPLENBQUEsSUFBQSxDQUFBLENBR1Z5UCxHQUFZQSxDQUFXN08sQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FpRTVCOE8sQ0FBUzVJLENBQUFBLFNBQUFBLENBQVksSUFBSS9GLEdBT2EsRUFBQSxHQUFBLENBQUEsU0FBU2lQLENBQVNDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBQ2pEQyxFQUFzQkQsQ0FHdEJ4TyxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFJMkgsSUFFVyxDQUFBLElBQUEsRUFBakIzSCxFQUFFa08sQ0FDTGxPLEdBQUFBLENBQUFBLENBQUVrTyxDQUFjLENBQUEsRUFBQSxDQUFBLENBRWpCbE8sRUFBRWtPLENBQVlqTyxDQUFBQSxJQUFBQSxDQUFLd08sQ0FFYkMsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBVVAsRUFBVW5PLENBRXRCMk8sQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBVyxDQUNUQyxDQUFBQSxDQUFBQSxDQUFhLFdBQ2RELENBRUpBLEdBQUFBLENBQUFBLENBQUFBLENBQVcsRUFDWEYsQ0FBaUMsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUU3QkMsRUFDSEEsQ0FBUUcsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFUkEsQ0FJRkosRUFBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBaUNHLE1BRTNCQyxDQUF1QixDQUFBLFVBQUEsQ0FBQSxHQUFBLENBQUEsRUFDckI3TyxDQUEyQixDQUFBLEdBQUEsQ0FBQSxDQUFBLEdBRzdCQSxFQUFFeUYsS0FBa0IsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUNqQnFKLENBQWlCOU8sQ0FBQUEsQ0FBQUEsQ0FBRXlGLFVBQ3pCekYsQ0FBbUIsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQTVFdkIsU0FBUytPLENBQUFBLENBQWU1UCxFQUFPNlAsQ0FBZ0JDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BQzFDOVAsQ0FDSEEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBa0IsS0FDbEJBLENBQ0NBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQ0FBLENBQWdCK1AsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBSSxTQUFBclAsQ0FDbkJrUCxDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxDQUFlbFAsQ0FBT21QLENBQUFBLENBQUFBLENBQWdCQyxLQUdwQzlQLENBQ0NBLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLEdBQWdDNlAsSUFDL0I3UCxDQUNIOFAsQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsQ0FBZWxNLGFBQWE1RCxDQUFZQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUV6Q0EsQ0FBMEIsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUMxQkEsVUFBOEI4UCxDQUsxQjlQLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBd0RvQjRQLENBQ3ZCRCxDQUFBQSxDQUNBQSxVQUNBQSxDQU1FWCxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxJQUZKbk8sQ0FBRThJLENBQUFBLFFBQUFBLENBQVMsS0FBZTlJLENBQXdCLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxDQUFBLENBRzFDbU8sQ0FBWW5PLENBQUFBLENBQUFBLENBQUVrTyxFQUFZaUIsR0FDakNoQixFQUFBQSxFQUFBQSxDQUFBQSxDQUFVL0UsV0FVUGdHLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQThDLElBQS9CWixDQUNoQnhPLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQUFBLEVBQWdDb1AsQ0FDcENwUCxFQUFBQSxDQUFBQSxDQUFFOEksU0FBUyxDQUFlOUksR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBd0JBLENBQW1CLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBRXRFdU8sRUFBUVIsSUFBS2EsQ0FBQUEsQ0FBQUEsQ0FBWUEsS0FHMUJYLENBQVM1SSxDQUFBQSxTQUFBQSxDQUFVcUMscUJBQXVCLFVBQ3BDd0csQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBYyxHQVFwQkQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBUzVJLFVBQVVDLE1BQVMsQ0FBQSxTQUFTckgsQ0FBT3dILENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQ3ZDa0MsU0FBMEIsQ0FJekJBLEdBQUFBLElBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQXVCLENBQ3BCcUgsSUFBQUEsQ0FBQUEsQ0FBaUJwSSxTQUFTdEksYUFBYyxDQUFBLEtBQUEsQ0FBQSxDQUN4QytRLEVBQW9CMUgsSUFBc0IsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLEdBQUEsQ0FDMUIsR0FySnpCLFNBQVMySCxDQUFBQSxDQUFjblEsQ0FBTzZQLENBQUFBLENBQUFBLENBQWdCbE8sVUFDekMzQixDQUNDQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFvQkEsQ0FDdkJBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQUFBLEVBQUFBLENBQStCNEcsUUFBUSxTQUFBd0osQ0FBQUEsQ0FBQUEsQ0FDUixVQUFuQkEsRUFBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBK0JBLFdBRzNDcFEsQ0FBMkIsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxDQUlKLE9BRHhCQSxDQUFRcEIsQ0FBQUEsQ0FBQUEsQ0FBTyxHQUFJb0IsQ0FFZEEsQ0FBQUEsRUFBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsR0FBZ0MyQixDQUNuQzNCLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQThCNlAsR0FFL0I3UCxDQUFtQixDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQUEsQ0FHcEJBLENBQ0NBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQ0FBLE1BQWdCK1AsR0FBSSxDQUFBLFNBQUFyUCxDQUNuQnlQLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQWN6UCxFQUFPbVAsQ0FBZ0JsTyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUlqQzNCLENBNEhzQm1RLENBQUFBLENBQzFCM0gsU0FDQXFILENBQ0NLLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXVDQSxDQUlmLENBQUEsR0FBQSxFQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBQUEsSUFLdEJHLEVBQ0wvSixDQUFvQm5ILENBQUFBLEdBQUFBLEVBQUFBLEdBQUFBLENBQWNlLEdBQVUsQ0FBQSxJQUFBLENBQU1wQixFQUFNdVIsUUFDckRBLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLEdBQVVBLENBQXNCLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxDQUU3QixDQUNObFIsR0FBY2UsQ0FBQUEsR0FBQUEsQ0FBVSxLQUFNb0csQ0FBbUIsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFPeEgsRUFBTU8sUUFDOURnUixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQ2hNRixJQUFNZCxDQUFBQSxDQUFVLFNBQUNlLENBQU01UCxDQUFBQSxDQUFBQSxDQUFPMUIsQ0FDdkJBLENBQUFBLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLENBZGdCLEtBY1NBLENBZlIsQ0FBQSxDQUFBLENBQUEsRUFxQnRCc1IsQ0FBS25CLENBQUFBLENBQUFBLENBQUtvQixPQUFPN1AsQ0FRaEI0UCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFLeFIsTUFBTTBSLFdBQ21CLEdBQUEsR0FBQSxHQUE5QkYsRUFBS3hSLEtBQU0wUixDQUFBQSxXQUFBQSxDQUFZLENBQWNGLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUtuQixFQUFLc0IsSUFRakR6UixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFPc1IsQ0FBS3BCLENBQUFBLENBQUFBLENBQ0xsUSxHQUFNLENBQ0xBLEtBQUFBLENBQUFBLENBQUtVLE1BQVMsQ0FBQSxDQUFBLEVBQ3BCVixFQUFLZ1IsR0FBTGhSLEVBQUFBLEVBQUFBLENBQUFBLEdBRUdBLEVBMUNpQixDQTBDTUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0EzQ0wsU0E4Q3RCc1IsQ0FBS3BCLENBQUFBLENBQUFBLENBQVFsUSxDQUFPQSxDQUFBQSxDQUFBQSxDQTVDSixNQW1EbEJpUSxDQUFBQSxDQUFBQSxDQUFhL0ksVUFBWSxJQUFJL0YsR0FBQUEsRUFBQUEsR0FBQUEsQ0FFTyxTQUFTTyxDQUN0QzRQLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQU85SCxJQUNQa0ksQ0FBQUEsQ0FBQUEsQ0FBWTFCLEVBQVVzQixDQUV4QnRSLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQU9zUixDQUFLbkIsQ0FBQUEsQ0FBQUEsQ0FBS3dCLElBQUlqUSxDQUN6QjFCLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBNUR1QixDQThEaEIsQ0FBQSxFQUFBLENBQUEsU0FBQTRSLE9BQ0FDLENBQW1CLENBQUEsVUFBQSxDQUNuQlAsQ0FBS3hSLENBQUFBLEtBQUFBLENBQU0wUixhQUtmeFIsQ0FBSzhCLENBQUFBLElBQUFBLENBQUs4UCxDQUNWckIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBUWUsRUFBTTVQLENBQU8xQixDQUFBQSxDQUFBQSxDQUFBQSxFQUhyQjRSLENBTUVGLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQ0hBLEVBQVVHLENBRVZBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBS0g1QixDQUFhL0ksQ0FBQUEsU0FBQUEsQ0FBVUMsT0FBUyxTQUFTckgsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FDbkNvUSxFQUFRLElBQ1JDLENBQUFBLElBQUFBLENBQUFBLENBQUFBLENBQU8sSUFBSTJCLEdBRVZ6UixDQUFBQSxJQUFBQSxDQUFBQSxDQUFXZ0UsQ0FBYXZFLENBQUFBLENBQUFBLENBQU1PLFVBQ2hDUCxDQUFNMFIsQ0FBQUEsV0FBQUEsRUFBd0MsR0FBekIxUixHQUFBQSxDQUFBQSxDQUFNMFIsWUFBWSxDQUkxQ25SLENBQUFBLEVBQUFBLENBQUFBLENBQVMwUixPQUlMLEVBQUEsQ0FBQSxJQUFBLElBQUl2UyxFQUFJYSxDQUFTSyxDQUFBQSxNQUFBQSxDQUFRbEIsQ0FZeEIyUSxFQUFBQSxFQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxDQUFLNkIsSUFBSTNSLENBQVNiLENBQUFBLENBQUFBLENBQUFBLENBQUtnSyxJQUFLMEcsQ0FBQUEsQ0FBQUEsQ0FBUSxDQUFDLENBQUcsQ0FBQSxDQUFBLENBQUcxRyxJQUFLMEcsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FFL0NwUSxFQUFNTyxRQUdkNFAsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBYS9JLFNBQVVZLENBQUFBLGtCQUFBQSxDQUFxQm1JLEVBQWEvSSxTQUFVTyxDQUFBQSxpQkFBQUEsQ0FBb0IsMkJBT2pGMEksQ0FBS3ZJLENBQUFBLE9BQUFBLENBQVEsU0FBQzVILENBQU0wQixDQUFBQSxDQUFBQSxDQUFBQSxDQUN4QjZPLENBQVEwQixDQUFBQSxDQUFBQSxDQUFNdlEsRUFBTzFCLENDbkhWa1MsRUFBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FDTSxXQUFWQyxFQUFBQSxPQUFBQSxNQUFBQSxFQUF5QkEsT0FBT0MsR0FBT0QsRUFBQUEsTUFBQUEsQ0FBT0MsR0FBSSxDQUFBLGVBQUEsQ0FBQSxFQUMxRCxNQUVLQyxDQUFjLENBQUEsaVBBQUEsQ0FFZEMsRUFBNkIsV0FBYjdKLEVBQUFBLE9BQUFBLFFBQUFBLENBS2hCOEosRUFBb0IsU0FBQW5TLENBQUFBLENBQUFBLENBQUFBLE9BQUFBLENBQ1AsV0FBVitSLEVBQUFBLE9BQUFBLE1BQUFBLEVBQTRDLGlCQUFaQSxNQUNyQyxFQUFBLENBQUEsY0FBQSxDQUNBLGFBQ0Q3TSxFQUFBQSxJQUFBQSxDQUFLbEYsSUFHUmUsR0FBVStGLENBQUFBLFNBQUFBLENBQVVxSSxpQkFBbUIsRUFTdkMsQ0FBQSxDQUNDLG9CQUNBLENBQUEsMkJBQUEsQ0FDQSx1QkFDQzNILE9BQVEsQ0FBQSxTQUFBdEgsQ0FDVGtTLENBQUFBLENBQUFBLE1BQUFBLENBQU9DLGVBQWV0UixHQUFVK0YsQ0FBQUEsU0FBQUEsQ0FBVzVHLEVBQUssQ0FDL0NvUyxZQUFBQSxDQUFBQSxDQUFjLEVBQ2RmLEdBQ1FuSSxDQUFBQSxVQUFBQSxDQUFBQSxPQUFBQSxJQUFBQSxDQUFLLFNBQVlsSixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUV6QjBSLGFBQUlXLENBQ0hILENBQUFBLENBQUFBLE1BQUFBLENBQU9DLGNBQWVqSixDQUFBQSxJQUFBQSxDQUFNbEosRUFBSyxDQUNoQ29TLFlBQUFBLENBQUFBLENBQWMsQ0FDZEUsQ0FBQUEsUUFBQUEsQ0FBQUEsQ0FBVSxFQUNWdk4sS0FBT3NOLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBaUNYLElBQUlFLENBQWV6VCxDQUFBQSxHQUFBQSxDQUFRa0gsTUFTM0IsU0FBU3dNLENBQUFBLEVBQUFBLEVBRVQsU0FBU0MsQ0FBQUEsRUFBQUEsQ0FBQUEsT0FDRHZKLEtBQUt3SixZQUdiLENBQUEsU0FBU0MsQ0FDRHpKLEVBQUFBLENBQUFBLE9BQUFBLElBQUFBLENBQUswSixpQkFmYjlULEdBQVFrSCxDQUFBQSxLQUFBQSxDQUFRLFNBQUFILENBQUFBLENBQUFBLENBQUFBLE9BQ1gwTSxJQUFjMU0sQ0FBSTBNLENBQUFBLENBQUFBLENBQWExTSxJQUNuQ0EsQ0FBRWdOLENBQUFBLE9BQUFBLENBQVVMLEVBQ1ozTSxDQUFFNE0sQ0FBQUEsb0JBQUFBLENBQXVCQSxDQUN6QjVNLENBQUFBLENBQUFBLENBQUU4TSxtQkFBcUJBLENBQ2Y5TSxDQUFBQSxDQUFBQSxDQUFFaU4sV0FBY2pOLENBQUFBLENBQUFBLENBQUFBLEtBYXJCa04sQ0FBQUEsQ0FBc0IsQ0FDekJYLFlBQUFBLENBQUFBLENBQWMsRUFDZGYsR0FDUW5JLENBQUFBLFVBQUFBLENBQUFBLE9BQUFBLElBQUFBLENBQUs4SixLQUlWQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFlblUsSUFBUTRCLE1BQzNCNUIsR0FBQUEsQ0FBUTRCLEtBQVEsQ0FBQSxTQUFBQSxPQUNYWixDQUFPWSxDQUFBQSxDQUFBQSxDQUFNWixJQUNiTixDQUFBQSxDQUFBQSxDQUFRa0IsRUFBTWxCLEtBQ2RVLENBQUFBLENBQUFBLENBQWtCVixDQUdGLENBQUEsR0FBQSxRQUFBLEVBQUEsT0FBVE0sRUFBbUIsQ0FDdkJvVCxJQUFBQSxDQUFBQSxDQUFBQSxDQUEwQyxJQUF2QnBULENBQUttQixDQUFBQSxPQUFBQSxDQUFRLFNBR2pDLElBQUkvQixDQUFBQSxJQUZUZ0IsQ0FBa0IsQ0FBQSxFQUFBLENBRUpWLEVBQU8sQ0FDaEJ1RixJQUFBQSxDQUFBQSxDQUFRdkYsQ0FBTU4sQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFZDhTLEdBQWdCLFVBQU45UyxHQUFBQSxDQUFBQSxFQUE2QixVQUFUWSxHQUFBQSxDQUFBQSxFQUdqQixVQUFOWixDQUFpQixFQUFBLGNBQUEsR0FBa0JNLEdBQWtCLElBQVR1RixFQUFBQSxDQUFBQSxHQUtoRCxpQkFBTjdGLENBQ0EsRUFBQSxPQUFBLEdBQVdNLENBQ0ksRUFBQSxJQUFBLEVBQWZBLEVBQU11RixLQUlON0YsQ0FBQUEsQ0FBQUEsQ0FBSSxPQUNZLENBQUEsVUFBQSxHQUFOQSxJQUE4QixDQUFWNkYsR0FBQUEsQ0FBQUEsQ0FNOUJBLENBQVEsQ0FBQSxFQUFBLENBQ0UsaUJBQWlCQyxJQUFLOUYsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDaENBLEVBQUksWUFFSixDQUFBLDRCQUFBLENBQTZCOEYsS0FBSzlGLENBQUlZLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQ3JDbVMsQ0FBa0J6UyxDQUFBQSxDQUFBQSxDQUFNTSxNQUV6QlosQ0FBSSxDQUFBLFNBQUEsQ0FDTSxZQUFhOEYsQ0FBQUEsSUFBQUEsQ0FBSzlGLEdBQzVCQSxDQUFJLENBQUEsV0FBQSxDQUNNLFdBQVk4RixDQUFBQSxJQUFBQSxDQUFLOUYsR0FDM0JBLENBQUksQ0FBQSxZQUFBLENBQ00sa0NBQW1DOEYsQ0FBQUEsSUFBQUEsQ0FBSzlGLEdBQ2xEQSxDQUFJQSxDQUFBQSxDQUFBQSxDQUFFcUcsV0FDSTJOLEVBQUFBLENBQUFBLENBQUFBLEVBQW9CbkIsRUFBWS9NLElBQUs5RixDQUFBQSxDQUFBQSxDQUFBQSxDQUMvQ0EsQ0FBSUEsQ0FBQUEsQ0FBQUEsQ0FBRW9HLFFBQVEsVUFBWSxDQUFBLEtBQUEsQ0FBQSxDQUFPQyxXQUNiLEVBQUEsQ0FBQSxJQUFBLEdBQVZSLElBQ1ZBLENBQVF4RSxDQUFBQSxLQUFBQSxDQUFBQSxDQUFBQSxDQUtMLGFBQWF5RSxJQUFLOUYsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FDckJBLEVBQUlBLENBQUVxRyxDQUFBQSxXQUFBQSxFQUFBQSxDQUNGckYsQ0FBZ0JoQixDQUFBQSxDQUFBQSxDQUFBQSxHQUNuQkEsRUFBSSxnQkFJTmdCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQWdCaEIsQ0FBSzZGLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBS2IsVUFBUmpGLENBQ0FJLEVBQUFBLENBQUFBLENBQWdCaVQsUUFDaEIzUCxFQUFBQSxLQUFBQSxDQUFNQyxRQUFRdkQsQ0FBZ0I2RSxDQUFBQSxLQUFBQSxDQUFBQSxHQUc5QjdFLENBQWdCNkUsQ0FBQUEsS0FBQUEsQ0FBUWhCLEVBQWF2RSxDQUFNTyxDQUFBQSxRQUFBQSxDQUFBQSxDQUFVdUgsT0FBUSxDQUFBLFNBQUFsRyxHQUM1REEsQ0FBTTVCLENBQUFBLEtBQUFBLENBQU00VCxRQUMwQyxDQUFBLENBQUEsQ0FBQSxFQUFyRGxULEVBQWdCNkUsS0FBTTlELENBQUFBLE9BQUFBLENBQVFHLENBQU01QixDQUFBQSxLQUFBQSxDQUFNdUYsV0FLakMsUUFBUmpGLEVBQUFBLENBQUFBLEVBQW9ELE1BQWhDSSxDQUFnQm9KLENBQUFBLFlBQUFBLEdBQ3ZDcEosRUFBZ0I2RSxLQUFRaEIsQ0FBQUEsQ0FBQUEsQ0FBYXZFLENBQU1PLENBQUFBLFFBQUFBLENBQUFBLENBQVV1SCxRQUFRLFNBQUFsRyxDQUFBQSxDQUFBQSxDQUUzREEsQ0FBTTVCLENBQUFBLEtBQUFBLENBQU00VCxTQURUbFQsQ0FBZ0JpVCxDQUFBQSxRQUFBQSxDQUFBQSxDQUUwQyxDQUE1RGpULEVBQUFBLENBQUFBLENBQWdCb0osYUFBYXJJLE9BQVFHLENBQUFBLENBQUFBLENBQU01QixLQUFNdUYsQ0FBQUEsS0FBQUEsQ0FBQUEsQ0FHakQ3RSxFQUFnQm9KLFlBQWdCbEksRUFBQUEsQ0FBQUEsQ0FBTTVCLEtBQU11RixDQUFBQSxNQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUtoRHJFLEVBQU1sQixLQUFRVSxDQUFBQSxDQUFBQSxDQUVWVixDQUFNd1QsQ0FBQUEsS0FBQUEsRUFBU3hULEVBQU02VCxTQUN4Qk4sR0FBQUEsQ0FBQUEsQ0FBb0JPLFVBQWEsQ0FBQSxXQUFBLEdBQWU5VCxFQUN6QixJQUFuQkEsRUFBQUEsQ0FBQUEsQ0FBTTZULFlBQW1CblQsQ0FBZ0I4UyxDQUFBQSxLQUFBQSxDQUFReFQsRUFBTTZULFNBQzNEbkIsQ0FBQUEsQ0FBQUEsTUFBQUEsQ0FBT0MsY0FBZWpTLENBQUFBLENBQUFBLENBQWlCLFlBQWE2UyxDQUl0RHJTLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQU02UyxRQUFXM0IsQ0FBQUEsQ0FBQUEsQ0FFYnFCLEdBQWNBLENBQWF2UyxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQUtoQyxJQUFNNEssQ0FBQUEsQ0FBa0J4TSxRQUN4QkEsR0FBa0IsQ0FBQSxHQUFBLENBQUEsU0FBUzRCLEdBQ3RCNEssQ0FDSEEsRUFBQUEsQ0FBQUEsQ0FBZ0I1SyxHQUVFQSxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQTs7SUN4TnBCOzs7Ozs7SUFNRzthQUNhLGtCQUFrQixDQUFrQixjQUFzQixFQUFFLEdBQUcsTUFBUyxFQUFBO0lBQ3BGLElBQUEsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDNUIsSUFBQSxNQUFNLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzFCLE9BQU87SUFHUCxJQUFBLFNBQVMsU0FBUyxDQUFJLEtBQVEsRUFBRSxLQUFhLEVBQUE7O0lBR3pDLFFBQUEsTUFBTSx1QkFBdUIsR0FBR2tNLENBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM5QyxRQUFBLE1BQU0sVUFBVSxHQUFHQSxDQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsUUFBQSxJQUFJLHVCQUF1QixDQUFDLE9BQU8sSUFBSSxLQUFLLEVBQUU7SUFDMUMsWUFBQSxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sRUFBRTs7SUFFckIsZ0JBQUEsU0FBUztvQkFDVCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUEsU0FBQSxFQUFZLGNBQWMsQ0FBNkYsMEZBQUEsRUFBQSxLQUFLLENBQW9CLGtCQUFBLENBQUEsQ0FBQyxDQUFDO0lBQ2hLLGdCQUFBLFVBQVUsQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDO0lBQzdCLGFBQUE7SUFDSixTQUFBO1NBQ0o7SUFDTCxDQUFDO0lBRUssU0FBVSxpQkFBaUIsQ0FBQyxDQUFhLEVBQUE7UUFDM0MsQ0FBQzlOLEdBQU8sQ0FBQyxpQkFBaUIsSUFBSSxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFrQkc7YUFDYSxlQUFlLENBQUksUUFBb0QsRUFBRSxlQUF5QixFQUFFLHVCQUFrRCxFQUFBO0lBRWxLLElBQUEsTUFBTSxRQUFRLEdBQUc4TixDQUFNLENBQW1CNEcsT0FBSyxDQUFDLENBQUM7SUFDakQsSUFBQSxNQUFNLFVBQVUsR0FBRzVHLENBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxJQUFBLE1BQU0sa0JBQWtCLEdBQUdBLENBQU0sQ0FBMkIsU0FBUyxDQUFDLENBQUM7O1FBR3ZFLGtCQUFrQixDQUFDLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxlQUFlLEVBQUUsdUJBQXVCLENBQUMsQ0FBQzs7SUFHMUYsSUFBQSxNQUFNLGVBQWUsR0FBR0ksR0FBVyxDQUFDLE1BQUs7SUFDckMsUUFBQSxNQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7SUFDbkQsUUFBQSxJQUFJLGVBQWU7SUFDZixZQUFBLGVBQWUsRUFBRSxDQUFDO1NBQ3pCLEVBQUUsRUFBRSxDQUFDLENBQUM7Ozs7O0lBTVAsSUFBQSxNQUFNLGNBQWMsR0FBR0EsR0FBVyxDQUFDLE1BQUs7WUFDcEMsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLd0csT0FBSyxJQUFJLGVBQWUsSUFBSSxTQUFTLEVBQUU7Z0JBQzVELElBQUk7SUFDQSxnQkFBQSxNQUFNLFlBQVksR0FBRyxlQUFlLEVBQUUsQ0FBQztJQUN2QyxnQkFBQSxRQUFRLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQztJQUNoQyxnQkFBQSxrQkFBa0IsQ0FBQyxPQUFPLElBQUksUUFBUSxHQUFHLFlBQVksRUFBRSxTQUFTLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQztJQUNuRixhQUFBO0lBQ0QsWUFBQSxPQUFPLEVBQUUsRUFBRTs7SUFFVixhQUFBO0lBQ0osU0FBQTtJQUNMLEtBQUMsRUFBRSwyREFBMEQsQ0FBQyxDQUFDO0lBRy9ELElBQUEsTUFBTSxRQUFRLEdBQUd4RyxHQUFXLENBQUMsTUFBSztZQUM5QixJQUFJLFVBQVUsQ0FBQyxPQUFPO0lBQ2xCLFlBQUEsT0FBTyxDQUFDLElBQUksQ0FBQyxnTUFBZ00sQ0FBQyxDQUFDOzs7O0lBS25OLFFBQUEsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLd0csT0FBSztJQUMxQixZQUFBLGNBQWMsRUFBRSxDQUFDO0lBRXJCLFFBQUEsUUFBUSxRQUFRLENBQUMsT0FBTyxLQUFLQSxPQUFLLEdBQUcsU0FBVSxHQUFHLFFBQVEsQ0FBQyxPQUFRLEVBQU87U0FDN0UsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQN0csQ0FBZSxDQUFDLE1BQUs7OztJQUdqQixRQUFBLGNBQWMsRUFBRSxDQUFDO1NBR3BCLEVBQUUsRUFBRSxDQUFDLENBQUM7O1FBR1AsTUFBTSxDQUFDLEdBQUdDLENBQU0sQ0FBQyxFQUFFLE9BQU8sRUFBRTRHLE9BQTJCLEVBQUUsQ0FBQyxDQUFDO0lBQzNELElBQUEsTUFBTSxRQUFRLEdBQUd4RyxHQUFXLENBQXlCLENBQUMsR0FBRyxLQUFJOztJQUd6RCxRQUFBLE1BQU0sU0FBUyxJQUFJLEdBQUcsWUFBWSxRQUFRLEdBQUcsR0FBRyxDQUFDLFFBQVEsQ0FBQyxPQUFPLEtBQUt3RyxPQUFLLEdBQUcsU0FBUyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztJQUduSCxRQUFBLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLEtBQUtBLE9BQUssSUFBSSxTQUFTLEtBQUssUUFBUSxDQUFDLE9BQU8sRUFBRTs7Ozs7Z0JBTS9ELENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxHQUFHLFFBQVEsQ0FBQyxPQUFPLENBQUM7O0lBR3JDLFlBQUEsQ0FBQyx1QkFBdUIsSUFBSSxpQkFBaUIsRUFBRSxNQUFLO0lBQ2hELGdCQUFBLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxPQUFhLENBQUM7SUFDdkMsZ0JBQUEsTUFBTSxPQUFPLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUU7b0JBQ25DLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxPQUFPLElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRTtJQUN2QyxvQkFBQSxVQUFVLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQzt3QkFFMUIsSUFBSTs7SUFFQSx3QkFBQSxlQUFlLEVBQUUsQ0FBQzs0QkFDbEIsa0JBQWtCLENBQUMsT0FBTyxJQUFJLFFBQVEsR0FBRyxPQUFPLEVBQUUsT0FBTyxLQUFLQSxPQUFLLEdBQUUsU0FBUyxHQUFHLE9BQU8sQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDO0lBQ3hHLHdCQUFBLFFBQVEsQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO0lBQzlCLHFCQUFBO0lBQ08sNEJBQUE7O0lBRUosd0JBQUEsVUFBVSxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7SUFDOUIscUJBQUE7SUFFSixpQkFBQTs7SUFHRCxnQkFBQSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBR0EsT0FBSyxDQUFDO0lBRTlCLGFBQUMsQ0FBQyxDQUFDO0lBQ04sU0FBQTs7O0lBSUQsUUFBQSxRQUFRLENBQUMsT0FBTyxHQUFHLFNBQVMsQ0FBQztTQUVoQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRVAsSUFBQSxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBVSxDQUFDO0lBQ3pDLENBQUM7SUFFRCxNQUFNQSxPQUFLLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFFdkI7YUFDZ0IsVUFBVSxHQUFBLEVBQUssT0FBTyxJQUFJLENBQUMsRUFBRTthQUM3QixXQUFXLEdBQUEsRUFBSyxPQUFPLEtBQUssQ0FBQyxFQUFFO2FBQy9CLFVBQVUsR0FBQSxFQUFLLE9BQU8sSUFBSSxDQUFDOztJQzNIM0M7Ozs7SUFJK0U7SUFDL0UsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLEdBQUcsRUFBb0QsQ0FBQztJQUMxRixNQUFNLHlCQUF5QixHQUFHLElBQUksR0FBRyxFQUE2QyxDQUFDO0lBQ3ZGLE1BQU0scUJBQXFCLEdBQUcsSUFBSSxHQUFHLEVBQWdELENBQUM7SUFDdEYsTUFBTSxzQkFBc0IsR0FBRyxJQUFJLEdBQUcsRUFBc0MsQ0FBQztJQUU3RTtJQUVBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFJLE1BQWlDLEVBQUUsR0FBZ0QsRUFBRSxLQUFRLEVBQUE7UUFDcEgsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNqQyxJQUFBLElBQUksUUFBUSxFQUFFOzs7Ozs7SUFPVixRQUFBLElBQUksUUFBUSxFQUFFO0lBQ1YsWUFBQSxLQUFLLE1BQU0sT0FBTyxJQUFJLFFBQVEsRUFBRTtJQUM1QixnQkFBQSxNQUFNLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxHQUFHLE9BQU8sQ0FBQztvQkFDbkMsSUFBSSxLQUFLLEtBQUssUUFBUSxFQUFFO3dCQUNwQixJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDWixvQkFBQSxPQUFPLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQztJQUM1QixpQkFBQTtJQUVKLGFBQUE7SUFDSixTQUFBOzs7O0lBS0osS0FBQTtJQUNMLENBQUM7SUFFRCxTQUFTLFFBQVEsQ0FBQyxDQUFhLEVBQUE7UUFDM0IsTUFBTSxNQUFNLEdBQUksQ0FBQyxDQUFDLE1BQWtCLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQztJQUUvRCxJQUFBLElBQUksQ0FBQyxDQUFDLGFBQWEsSUFBSSxJQUFJLEVBQUU7SUFDekIsUUFBQSxjQUFjLENBQUMsTUFBTSxFQUFFLHFCQUFxQixFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3ZELEtBR0E7SUFFTCxDQUFDO0lBRUQsU0FBUyxPQUFPLENBQUMsQ0FBYSxFQUFBO1FBQzFCLE1BQU0sTUFBTSxHQUFJLENBQUMsQ0FBQyxNQUFrQixDQUFDLGFBQWEsQ0FBQyxXQUFXLENBQUM7SUFDL0QsSUFBQSxNQUFNLHVCQUF1QixHQUFHLENBQUMsQ0FBQyxNQUFzQyxDQUFDO0lBQ3pFLElBQUEsY0FBYyxDQUFDLE1BQU0sRUFBRSxxQkFBcUIsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQ3ZFLElBQUEsY0FBYyxDQUFDLE1BQU0sRUFBRSx5QkFBeUIsRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQy9FLENBQUM7SUFFRCxTQUFTLFdBQVcsQ0FBQyxDQUFhLEVBQUE7SUFDOUIsSUFBQSxNQUFNLE1BQU0sSUFBSSxDQUFDLENBQUMsTUFBTSxZQUFZLE1BQU0sR0FBRyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxhQUFhLFlBQVksTUFBTSxHQUFHLENBQUMsQ0FBQyxhQUFhLEdBQUksQ0FBQyxDQUFDLE1BQWtCLENBQUMsYUFBYSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQy9KLElBQUEsc0JBQXNCLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN6QyxJQUFBLGNBQWMsQ0FBQyxNQUFNLEVBQUUscUJBQXFCLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDeEQsQ0FBQztJQUVELFNBQVMsVUFBVSxDQUFDLENBQWEsRUFBQTtJQUM3QixJQUFBLE1BQU0sTUFBTSxJQUFJLENBQUMsQ0FBQyxNQUFNLFlBQVksTUFBTSxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLGFBQWEsWUFBWSxNQUFNLEdBQUcsQ0FBQyxDQUFDLGFBQWEsR0FBSSxDQUFDLENBQUMsTUFBa0IsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDL0osSUFBQSxzQkFBc0IsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFDLElBQUEsY0FBYyxDQUFDLE1BQU0sRUFBRSxxQkFBcUIsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBd0REOzs7Ozs7Ozs7OztJQVdHO0lBQ2EsU0FBQSxnQkFBZ0IsQ0FBQyxFQUFFLHFCQUFxQixFQUFFLHlCQUF5QixFQUFFLHFCQUFxQixFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQThCLEVBQUE7SUFFNUosSUFBQSxrQkFBa0IsQ0FBQyxrQkFBa0IsRUFBRSxxQkFBcUIsRUFBRSx5QkFBeUIsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLEVBQUUsU0FBUyxDQUFDLENBQUM7UUFFeElqSCxDQUFTLENBQUMsTUFBSztJQUNYLFFBQUEsTUFBTSxRQUFRLEdBQUcsV0FBVyxFQUFFLENBQUM7SUFDL0IsUUFBQSxNQUFNLE1BQU0sSUFBSSxTQUFTLEdBQUcsUUFBUSxDQUFDLElBQUksUUFBUSxFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBRWhFLFFBQUEsSUFBSSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRTtJQUN0RCxZQUFBLFFBQVEsRUFBRSxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDbEUsWUFBQSxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLFFBQVEsRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQ3BFLFlBQUEsTUFBTSxFQUFFLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNsRSxZQUFBLE1BQU0sRUFBRSxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDbkUsU0FBQTs7O0lBSUQsUUFBQSxNQUFNLDBCQUEwQixHQUFHLHFCQUFxQixDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLEdBQUcsRUFBRSxDQUFDO0lBQ2xGLFFBQUEsTUFBTSw4QkFBOEIsR0FBRyx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLElBQUksSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUMxRixRQUFBLE1BQU0sMEJBQTBCLEdBQUcscUJBQXFCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksR0FBRyxFQUFFLENBQUM7WUFFbEYsTUFBTSxJQUFJLEdBQUcsRUFBRSxJQUFJLEVBQUUsZ0JBQTZDLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxDQUFBO1lBQ3pGLE1BQU0sS0FBSyxHQUFHLEVBQUUsSUFBSSxFQUFFLG9CQUEwQyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsQ0FBQztZQUN4RixNQUFNLElBQUksR0FBRyxFQUFFLElBQUksRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLENBQUM7SUFFN0QsUUFBQSwwQkFBMEIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDckMsUUFBQSw4QkFBOEIsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDMUMsUUFBQSwwQkFBMEIsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFckMsUUFBQSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLDBCQUEwQixDQUFDLENBQUM7SUFDOUQsUUFBQSx5QkFBeUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLDhCQUE4QixDQUFDLENBQUM7SUFDdEUsUUFBQSxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLDBCQUEwQixDQUFDLENBQUM7SUFFOUQsUUFBQSxPQUFPLE1BQUs7Z0JBQ1IscUJBQXFCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDaEQseUJBQXlCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDcEQscUJBQXFCLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUVoRCxZQUFBLElBQUkscUJBQXFCLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtJQUNsQyxnQkFBQSxRQUFRLEVBQUUsbUJBQW1CLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ2xELGdCQUFBLFFBQVEsRUFBRSxtQkFBbUIsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7SUFDcEQsZ0JBQUEsTUFBTSxFQUFFLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQztJQUNsRCxnQkFBQSxNQUFNLEVBQUUsbUJBQW1CLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ25ELGFBQUE7SUFDTCxTQUFDLENBQUE7U0FDSixFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBRU4sSUFBQSxNQUFNLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxlQUFlLENBQWlCLHFCQUFxQixFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ2hILElBQUEsTUFBTSxDQUFDLG9CQUFvQixFQUFFLG9CQUFvQixDQUFDLEdBQUcsZUFBZSxDQUFVLHlCQUF5QixFQUFFLFVBQXlCLENBQUMsQ0FBQztJQUNwSSxJQUFBLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxnQkFBZ0IsQ0FBQyxHQUFHLGVBQWUsQ0FBVSxxQkFBcUIsRUFBRSxVQUFVLENBQUMsQ0FBQztJQUV6RyxJQUFBLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxnQkFBZ0IsRUFBRSxDQUFDO0lBQ3hFOztJQ3RPQSxNQUFNLEtBQUssR0FBRyxrRUFBa0UsQ0FBQztJQUVqRixTQUFTLE1BQU0sQ0FBQyxLQUFhLEVBQUE7SUFDekIsSUFBQSxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN4QixDQUFDO0lBRUQsU0FBUyxXQUFXLEdBQUE7UUFDaEIsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxTQUFTLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRUQsU0FBUyxZQUFZLEdBQUE7SUFDakIsSUFBQSxPQUFPLENBQUMsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQVUsQ0FBQztJQUMxTCxDQUFDO0lBRUQ7Ozs7Ozs7OztJQVNHO0lBQ0csU0FBVSxnQkFBZ0IsQ0FBQyxNQUFlLEVBQUE7UUFDNUMsT0FBTyxDQUFBLEVBQUcsTUFBTSxJQUFJLEtBQUssQ0FBQSxFQUFHLFlBQVksRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFBLENBQUUsQ0FBQztJQUM5RSxDQUFDO0lBRUQsTUFBTSxjQUFjLEdBQUcsSUFBSSxHQUFHLEVBQThCLENBQUM7SUFDN0QsTUFBTSxLQUFLLEdBQUcsSUFBSSxHQUFHLEVBQXdHLENBQUM7SUFHOUg7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxNQUFNLFVBQVUsR0FBRyxRQUFRLENBQUM7SUFFNUIsTUFBTSxjQUFjLEdBQUd6TixHQUFPLENBQUMsVUFBVSxDQUFxRCxDQUFDO0lBQy9GLE1BQU0sU0FBUyxHQUEwQixDQUFDLEdBQUcsSUFBSSxLQUFJO1FBQ2pELEtBQUssTUFBTSxDQUFDLEVBQUUsRUFBRSxVQUFVLENBQUMsSUFBSSxLQUFLLEVBQUU7WUFDbEMsTUFBTSxTQUFTLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUN6QyxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQzNDLFlBQUEsVUFBVSxDQUFDLE9BQU8sSUFBSSxDQUFDO0lBQ3ZCLFlBQUEsVUFBVSxDQUFDLE9BQU8sR0FBRyxVQUFVLENBQUMsTUFBTSxFQUFFLENBQUM7Z0JBQ3pDLGNBQWMsQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3QyxTQUFBO0lBQ0osS0FBQTtRQUNELEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUNkLElBQUEsY0FBYyxHQUFHLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDOUIsQ0FBQyxDQUFBO0FBQ0RBLE9BQU8sQ0FBQyxVQUFVLENBQUMsR0FBRyxTQUFrQixDQUFBO0lBRXhDOzs7Ozs7OztJQVFHO0lBQ2EsU0FBQSxxQkFBcUIsQ0FBQyxNQUFzQixFQUFFLE1BQWUsRUFBQTtJQUV6RTs7Ozs7Ozs7O0lBU087SUFFUCxJQUFBLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRytNLENBQVEsQ0FBQyxNQUFNLGdCQUFnQixFQUFFLENBQUMsQ0FBQztJQUNoRCxJQUFBLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxFQUFFLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUVqRFUsQ0FBUyxDQUFDLE1BQUs7SUFDWCxRQUFBLE9BQU8sTUFBSztJQUNSLFlBQUEsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNqQixZQUFBLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDOUIsU0FBQyxDQUFBO0lBQ0wsS0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQTtJQUNaLENBQUM7SUFFRCxTQUFTLFdBQVcsQ0FBQyxPQUFnQixFQUFFLE9BQWdCLEVBQUE7SUFDbkQsSUFBQSxPQUFPLENBQUMsRUFDSixDQUFDLE9BQU87SUFDUixRQUFBLE9BQU8sQ0FBQyxNQUFNLEtBQUssT0FBTyxFQUFFLE1BQU07SUFDbEMsUUFBQSxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssS0FBSyxHQUFHLEtBQUssT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQ3hELENBQUM7SUFDTjs7SUN4R0EsTUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBRTlCOzs7Ozs7Ozs7SUFTRztJQUNHLFNBQVUsZUFBZSxDQUFJLEtBQVEsRUFBQTtJQUN2QyxJQUFBLE1BQU0sR0FBRyxHQUFHSyxDQUFNLENBQUksS0FBcUIsQ0FBQyxDQUFDO0lBQzdDLElBQUEscUJBQXFCLENBQUMsTUFBUSxFQUFBLEdBQUcsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDL0QsT0FBT0ksR0FBVyxDQUFDLE1BQUs7SUFDcEIsUUFBQSxJQUFJLEdBQUcsQ0FBQyxPQUFrQixLQUFLLEtBQUssRUFBRTtJQUNsQyxZQUFBLE1BQU0sSUFBSSxLQUFLLENBQUMsd0VBQXdFLENBQUMsQ0FBQTtJQUM1RixTQUFBO1lBQ0QsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDO1NBQ3RCLEVBQUUsRUFBRSxDQUFDLENBQUE7SUFDVjs7SUNwQkE7Ozs7O0lBS0c7SUFDRyxTQUFVLGlCQUFpQixDQUFxQyxFQUFLLEVBQUE7SUFDdkUsSUFBQSxNQUFNLHFCQUFxQixHQUFHLGVBQWUsQ0FBSSxFQUFFLENBQUMsQ0FBQztJQUVyRCxJQUFBLE9BQU9BLEdBQVcsQ0FBQyxDQUFDLEdBQUcsSUFBbUIsS0FBbUI7SUFDekQsUUFBQSxPQUFPLHFCQUFxQixFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztTQUMzQyxFQUFFLEVBQUUsQ0FBTSxDQUFDO0lBQ2hCOztJQ0xBLE1BQU0sMkJBQTJCLEdBQUczRCxDQUFhLENBQXFCLElBQUksQ0FBQyxDQUFDO0lBNEM1RTs7Ozs7O0lBTUc7SUFDYSxTQUFBLGlCQUFpQixDQUFDLEVBQUUsUUFBUSxFQUErQixFQUFBOztRQUV2RSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLENBQUM7SUFDM0QsSUFBQSxNQUFNLFdBQVcsSUFBSSxRQUFRLElBQUksSUFBSSxDQUFDLENBQUM7SUFFdkMsSUFBQSxNQUFNLDJCQUEyQixHQUFHNEQsR0FBVSxDQUFDLDJCQUEyQixDQUFDLENBQUM7UUFFNUVWLENBQVMsQ0FBQyxNQUFLO0lBQ1gsUUFBQSxJQUFJLDJCQUEyQixFQUFFO0lBQzdCLFlBQUEsSUFBSSxXQUFXLEVBQUU7SUFDYixnQkFBQSwyQkFBMkIsQ0FBQyxXQUFXLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDM0QsYUFBQTtJQUNJLGlCQUFBO0lBQ0QsZ0JBQUEsMkJBQTJCLENBQUMsY0FBYyxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzlELGFBQUE7SUFDSixTQUFBO0lBQ0ksYUFBQTtJQUNELFlBQUEsSUFBSSxXQUFXLEVBQUU7OztJQUdiLGdCQUFBLE1BQU0sV0FBVyxHQUFHLENBQUMsRUFBVSxLQUFJO0lBQy9CLG9CQUFBLE1BQU0sR0FBRyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQzt3QkFDNUMsY0FBYyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3ZCLGlCQUFDLENBQUE7SUFDRCxnQkFBQSxJQUFJLE1BQU0sR0FBRyxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNoRCxnQkFBQSxPQUFPLE1BQU0sb0JBQW9CLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDN0MsYUFBQTtJQUNKLFNBQUE7SUFDTCxLQUFDLEVBQUUsQ0FBQywyQkFBMkIsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFBO0lBQ2xELENBQUM7SUFFRDtJQUNBLFNBQVMsSUFBSTs7SUM5RmI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxJQUFJLElBQUksR0FBRyxPQUFPLEtBQUssQ0FBQztJQUMxQixFQUFFLE9BQU8sS0FBSyxJQUFJLElBQUksS0FBSyxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxVQUFVLENBQUMsQ0FBQztJQUNuRTs7SUM1QkE7SUFDQSxJQUFJLFVBQVUsR0FBRyxPQUFPLE1BQU0sSUFBSSxRQUFRLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLEtBQUssTUFBTSxJQUFJLE1BQU07O0lDQzFGO0lBQ0EsSUFBSSxRQUFRLEdBQUcsT0FBTyxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsTUFBTSxLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUM7QUFDakY7SUFDQTtJQUNBLElBQUksSUFBSSxHQUFHLFVBQVUsSUFBSSxRQUFRLElBQUksUUFBUSxDQUFDLGFBQWEsQ0FBQyxFQUFFOztJQ0o5RDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksR0FBRyxHQUFHLFdBQVc7SUFDckIsRUFBRSxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDekIsQ0FBQzs7SUNwQkQ7SUFDQSxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUM7QUFDeEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxlQUFlLENBQUMsTUFBTSxFQUFFO0lBQ2pDLEVBQUUsSUFBSSxLQUFLLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUM1QjtJQUNBLEVBQUUsT0FBTyxLQUFLLEVBQUUsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFO0lBQy9ELEVBQUUsT0FBTyxLQUFLLENBQUM7SUFDZjs7SUNkQTtJQUNBLElBQUksV0FBVyxHQUFHLE1BQU0sQ0FBQztBQUN6QjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsTUFBTSxFQUFFO0lBQzFCLEVBQUUsT0FBTyxNQUFNO0lBQ2YsTUFBTSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxlQUFlLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxFQUFFLENBQUM7SUFDM0UsTUFBTSxNQUFNLENBQUM7SUFDYjs7SUNkQTtJQUNBLElBQUlzRixRQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU07O0lDRHhCO0lBQ0EsSUFBSTRCLGFBQVcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ25DO0lBQ0E7SUFDQSxJQUFJQyxnQkFBYyxHQUFHRCxhQUFXLENBQUMsY0FBYyxDQUFDO0FBQ2hEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUlFLHNCQUFvQixHQUFHRixhQUFXLENBQUMsUUFBUSxDQUFDO0FBQ2hEO0lBQ0E7SUFDQSxJQUFJRyxnQkFBYyxHQUFHL0IsUUFBTSxHQUFHQSxRQUFNLENBQUMsV0FBVyxHQUFHLFNBQVMsQ0FBQztBQUM3RDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxTQUFTLENBQUMsS0FBSyxFQUFFO0lBQzFCLEVBQUUsSUFBSSxLQUFLLEdBQUc2QixnQkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUVFLGdCQUFjLENBQUM7SUFDeEQsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDQSxnQkFBYyxDQUFDLENBQUM7QUFDbEM7SUFDQSxFQUFFLElBQUk7SUFDTixJQUFJLEtBQUssQ0FBQ0EsZ0JBQWMsQ0FBQyxHQUFHLFNBQVMsQ0FBQztJQUN0QyxJQUFJLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztJQUN4QixHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtBQUNoQjtJQUNBLEVBQUUsSUFBSSxNQUFNLEdBQUdELHNCQUFvQixDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNoRCxFQUFFLElBQUksUUFBUSxFQUFFO0lBQ2hCLElBQUksSUFBSSxLQUFLLEVBQUU7SUFDZixNQUFNLEtBQUssQ0FBQ0MsZ0JBQWMsQ0FBQyxHQUFHLEdBQUcsQ0FBQztJQUNsQyxLQUFLLE1BQU07SUFDWCxNQUFNLE9BQU8sS0FBSyxDQUFDQSxnQkFBYyxDQUFDLENBQUM7SUFDbkMsS0FBSztJQUNMLEdBQUc7SUFDSCxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCOztJQzNDQTtJQUNBLElBQUlILGFBQVcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksb0JBQW9CLEdBQUdBLGFBQVcsQ0FBQyxRQUFRLENBQUM7QUFDaEQ7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsY0FBYyxDQUFDLEtBQUssRUFBRTtJQUMvQixFQUFFLE9BQU8sb0JBQW9CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFDOztJQ2ZBO0lBQ0EsSUFBSSxPQUFPLEdBQUcsZUFBZTtJQUM3QixJQUFJLFlBQVksR0FBRyxvQkFBb0IsQ0FBQztBQUN4QztJQUNBO0lBQ0EsSUFBSSxjQUFjLEdBQUc1QixRQUFNLEdBQUdBLFFBQU0sQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDO0FBQzdEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUU7SUFDM0IsRUFBRSxJQUFJLEtBQUssSUFBSSxJQUFJLEVBQUU7SUFDckIsSUFBSSxPQUFPLEtBQUssS0FBSyxTQUFTLEdBQUcsWUFBWSxHQUFHLE9BQU8sQ0FBQztJQUN4RCxHQUFHO0lBQ0gsRUFBRSxPQUFPLENBQUMsY0FBYyxJQUFJLGNBQWMsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQzNELE1BQU0sU0FBUyxDQUFDLEtBQUssQ0FBQztJQUN0QixNQUFNLGNBQWMsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM1Qjs7SUN6QkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxZQUFZLENBQUMsS0FBSyxFQUFFO0lBQzdCLEVBQUUsT0FBTyxLQUFLLElBQUksSUFBSSxJQUFJLE9BQU8sS0FBSyxJQUFJLFFBQVEsQ0FBQztJQUNuRDs7SUN2QkE7SUFDQSxJQUFJLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQztBQUNsQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDekIsRUFBRSxPQUFPLE9BQU8sS0FBSyxJQUFJLFFBQVE7SUFDakMsS0FBSyxZQUFZLENBQUMsS0FBSyxDQUFDLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxJQUFJLFNBQVMsQ0FBQyxDQUFDO0lBQzVEOztJQ3RCQTtJQUNBLElBQUksR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDaEI7SUFDQTtJQUNBLElBQUksVUFBVSxHQUFHLG9CQUFvQixDQUFDO0FBQ3RDO0lBQ0E7SUFDQSxJQUFJLFVBQVUsR0FBRyxZQUFZLENBQUM7QUFDOUI7SUFDQTtJQUNBLElBQUksU0FBUyxHQUFHLGFBQWEsQ0FBQztBQUM5QjtJQUNBO0lBQ0EsSUFBSSxZQUFZLEdBQUcsUUFBUSxDQUFDO0FBQzVCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsUUFBUSxDQUFDLEtBQUssRUFBRTtJQUN6QixFQUFFLElBQUksT0FBTyxLQUFLLElBQUksUUFBUSxFQUFFO0lBQ2hDLElBQUksT0FBTyxLQUFLLENBQUM7SUFDakIsR0FBRztJQUNILEVBQUUsSUFBSSxRQUFRLENBQUMsS0FBSyxDQUFDLEVBQUU7SUFDdkIsSUFBSSxPQUFPLEdBQUcsQ0FBQztJQUNmLEdBQUc7SUFDSCxFQUFFLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxFQUFFO0lBQ3ZCLElBQUksSUFBSSxLQUFLLEdBQUcsT0FBTyxLQUFLLENBQUMsT0FBTyxJQUFJLFVBQVUsR0FBRyxLQUFLLENBQUMsT0FBTyxFQUFFLEdBQUcsS0FBSyxDQUFDO0lBQzdFLElBQUksS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsSUFBSSxLQUFLLEdBQUcsRUFBRSxJQUFJLEtBQUssQ0FBQztJQUNuRCxHQUFHO0lBQ0gsRUFBRSxJQUFJLE9BQU8sS0FBSyxJQUFJLFFBQVEsRUFBRTtJQUNoQyxJQUFJLE9BQU8sS0FBSyxLQUFLLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxLQUFLLENBQUM7SUFDeEMsR0FBRztJQUNILEVBQUUsS0FBSyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMxQixFQUFFLElBQUksUUFBUSxHQUFHLFVBQVUsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDeEMsRUFBRSxPQUFPLENBQUMsUUFBUSxJQUFJLFNBQVMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO0lBQzNDLE1BQU0sWUFBWSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBUSxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDcEQsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlDOztJQ3pEQTtJQUNBLElBQUlnQyxpQkFBZSxHQUFHLHFCQUFxQixDQUFDO0FBQzVDO0lBQ0E7SUFDQSxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRztJQUN4QixJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0FBQ3pCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUU7SUFDdkMsRUFBRSxJQUFJLFFBQVE7SUFDZCxNQUFNLFFBQVE7SUFDZCxNQUFNLE9BQU87SUFDYixNQUFNLE1BQU07SUFDWixNQUFNLE9BQU87SUFDYixNQUFNLFlBQVk7SUFDbEIsTUFBTSxjQUFjLEdBQUcsQ0FBQztJQUN4QixNQUFNLE9BQU8sR0FBRyxLQUFLO0lBQ3JCLE1BQU0sTUFBTSxHQUFHLEtBQUs7SUFDcEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3RCO0lBQ0EsRUFBRSxJQUFJLE9BQU8sSUFBSSxJQUFJLFVBQVUsRUFBRTtJQUNqQyxJQUFJLE1BQU0sSUFBSSxTQUFTLENBQUNBLGlCQUFlLENBQUMsQ0FBQztJQUN6QyxHQUFHO0lBQ0gsRUFBRSxJQUFJLEdBQUcsUUFBUSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixFQUFFLElBQUksUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO0lBQ3pCLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDO0lBQ2hDLElBQUksTUFBTSxHQUFHLFNBQVMsSUFBSSxPQUFPLENBQUM7SUFDbEMsSUFBSSxPQUFPLEdBQUcsTUFBTSxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsR0FBRyxPQUFPLENBQUM7SUFDakYsSUFBSSxRQUFRLEdBQUcsVUFBVSxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDckUsR0FBRztBQUNIO0lBQ0EsRUFBRSxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUU7SUFDNUIsSUFBSSxJQUFJLElBQUksR0FBRyxRQUFRO0lBQ3ZCLFFBQVEsT0FBTyxHQUFHLFFBQVEsQ0FBQztBQUMzQjtJQUNBLElBQUksUUFBUSxHQUFHLFFBQVEsR0FBRyxTQUFTLENBQUM7SUFDcEMsSUFBSSxjQUFjLEdBQUcsSUFBSSxDQUFDO0lBQzFCLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ3ZDLElBQUksT0FBTyxNQUFNLENBQUM7SUFDbEIsR0FBRztBQUNIO0lBQ0EsRUFBRSxTQUFTLFdBQVcsQ0FBQyxJQUFJLEVBQUU7SUFDN0I7SUFDQSxJQUFJLGNBQWMsR0FBRyxJQUFJLENBQUM7SUFDMUI7SUFDQSxJQUFJLE9BQU8sR0FBRyxVQUFVLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzdDO0lBQ0EsSUFBSSxPQUFPLE9BQU8sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLEdBQUcsTUFBTSxDQUFDO0lBQy9DLEdBQUc7QUFDSDtJQUNBLEVBQUUsU0FBUyxhQUFhLENBQUMsSUFBSSxFQUFFO0lBQy9CLElBQUksSUFBSSxpQkFBaUIsR0FBRyxJQUFJLEdBQUcsWUFBWTtJQUMvQyxRQUFRLG1CQUFtQixHQUFHLElBQUksR0FBRyxjQUFjO0lBQ25ELFFBQVEsV0FBVyxHQUFHLElBQUksR0FBRyxpQkFBaUIsQ0FBQztBQUMvQztJQUNBLElBQUksT0FBTyxNQUFNO0lBQ2pCLFFBQVEsU0FBUyxDQUFDLFdBQVcsRUFBRSxPQUFPLEdBQUcsbUJBQW1CLENBQUM7SUFDN0QsUUFBUSxXQUFXLENBQUM7SUFDcEIsR0FBRztBQUNIO0lBQ0EsRUFBRSxTQUFTLFlBQVksQ0FBQyxJQUFJLEVBQUU7SUFDOUIsSUFBSSxJQUFJLGlCQUFpQixHQUFHLElBQUksR0FBRyxZQUFZO0lBQy9DLFFBQVEsbUJBQW1CLEdBQUcsSUFBSSxHQUFHLGNBQWMsQ0FBQztBQUNwRDtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksUUFBUSxZQUFZLEtBQUssU0FBUyxLQUFLLGlCQUFpQixJQUFJLElBQUksQ0FBQztJQUNyRSxPQUFPLGlCQUFpQixHQUFHLENBQUMsQ0FBQyxLQUFLLE1BQU0sSUFBSSxtQkFBbUIsSUFBSSxPQUFPLENBQUMsRUFBRTtJQUM3RSxHQUFHO0FBQ0g7SUFDQSxFQUFFLFNBQVMsWUFBWSxHQUFHO0lBQzFCLElBQUksSUFBSSxJQUFJLEdBQUcsR0FBRyxFQUFFLENBQUM7SUFDckIsSUFBSSxJQUFJLFlBQVksQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUM1QixNQUFNLE9BQU8sWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hDLEtBQUs7SUFDTDtJQUNBLElBQUksT0FBTyxHQUFHLFVBQVUsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDNUQsR0FBRztBQUNIO0lBQ0EsRUFBRSxTQUFTLFlBQVksQ0FBQyxJQUFJLEVBQUU7SUFDOUIsSUFBSSxPQUFPLEdBQUcsU0FBUyxDQUFDO0FBQ3hCO0lBQ0E7SUFDQTtJQUNBLElBQUksSUFBSSxRQUFRLElBQUksUUFBUSxFQUFFO0lBQzlCLE1BQU0sT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDOUIsS0FBSztJQUNMLElBQUksUUFBUSxHQUFHLFFBQVEsR0FBRyxTQUFTLENBQUM7SUFDcEMsSUFBSSxPQUFPLE1BQU0sQ0FBQztJQUNsQixHQUFHO0FBQ0g7SUFDQSxFQUFFLFNBQVMsTUFBTSxHQUFHO0lBQ3BCLElBQUksSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO0lBQy9CLE1BQU0sWUFBWSxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzVCLEtBQUs7SUFDTCxJQUFJLGNBQWMsR0FBRyxDQUFDLENBQUM7SUFDdkIsSUFBSSxRQUFRLEdBQUcsWUFBWSxHQUFHLFFBQVEsR0FBRyxPQUFPLEdBQUcsU0FBUyxDQUFDO0lBQzdELEdBQUc7QUFDSDtJQUNBLEVBQUUsU0FBUyxLQUFLLEdBQUc7SUFDbkIsSUFBSSxPQUFPLE9BQU8sS0FBSyxTQUFTLEdBQUcsTUFBTSxHQUFHLFlBQVksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0lBQ2hFLEdBQUc7QUFDSDtJQUNBLEVBQUUsU0FBUyxTQUFTLEdBQUc7SUFDdkIsSUFBSSxJQUFJLElBQUksR0FBRyxHQUFHLEVBQUU7SUFDcEIsUUFBUSxVQUFVLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3hDO0lBQ0EsSUFBSSxRQUFRLEdBQUcsU0FBUyxDQUFDO0lBQ3pCLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQztJQUNwQixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUM7QUFDeEI7SUFDQSxJQUFJLElBQUksVUFBVSxFQUFFO0lBQ3BCLE1BQU0sSUFBSSxPQUFPLEtBQUssU0FBUyxFQUFFO0lBQ2pDLFFBQVEsT0FBTyxXQUFXLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDekMsT0FBTztJQUNQLE1BQU0sSUFBSSxNQUFNLEVBQUU7SUFDbEI7SUFDQSxRQUFRLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM5QixRQUFRLE9BQU8sR0FBRyxVQUFVLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQ2pELFFBQVEsT0FBTyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDeEMsT0FBTztJQUNQLEtBQUs7SUFDTCxJQUFJLElBQUksT0FBTyxLQUFLLFNBQVMsRUFBRTtJQUMvQixNQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQy9DLEtBQUs7SUFDTCxJQUFJLE9BQU8sTUFBTSxDQUFDO0lBQ2xCLEdBQUc7SUFDSCxFQUFFLFNBQVMsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQzVCLEVBQUUsU0FBUyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDMUIsRUFBRSxPQUFPLFNBQVMsQ0FBQztJQUNuQjs7SUN6TEE7SUFDQSxJQUFJLGVBQWUsR0FBRyxxQkFBcUIsQ0FBQztBQUM1QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtJQUN2QyxFQUFFLElBQUksT0FBTyxHQUFHLElBQUk7SUFDcEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDO0FBQ3RCO0lBQ0EsRUFBRSxJQUFJLE9BQU8sSUFBSSxJQUFJLFVBQVUsRUFBRTtJQUNqQyxJQUFJLE1BQU0sSUFBSSxTQUFTLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDekMsR0FBRztJQUNILEVBQUUsSUFBSSxRQUFRLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDekIsSUFBSSxPQUFPLEdBQUcsU0FBUyxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxPQUFPLENBQUM7SUFDakUsSUFBSSxRQUFRLEdBQUcsVUFBVSxJQUFJLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDckUsR0FBRztJQUNILEVBQUUsT0FBTyxRQUFRLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRTtJQUM5QixJQUFJLFNBQVMsRUFBRSxPQUFPO0lBQ3RCLElBQUksU0FBUyxFQUFFLElBQUk7SUFDbkIsSUFBSSxVQUFVLEVBQUUsUUFBUTtJQUN4QixHQUFHLENBQUMsQ0FBQztJQUNMOztJQy9EQTs7Ozs7O0lBTUc7SUFDRyxTQUFVLFFBQVEsQ0FBSSxZQUEyQixFQUFBOztRQUduRCxNQUFNLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQyxHQUFHQyxDQUFTLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbkQsSUFBQSxNQUFNLEdBQUcsR0FBR2xILENBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQzs7O0lBSTFCLElBQUEsTUFBTSxRQUFRLEdBQUdJLEdBQVcsQ0FBa0IsS0FBSyxJQUFHO0lBQ2xELFFBQUEsSUFBSSxPQUFPLEtBQUssS0FBSyxVQUFVLEVBQUU7Z0JBQzdCLE1BQU0sUUFBUSxHQUFHLEtBQStCLENBQUM7Z0JBQ2pELFNBQVMsQ0FBQyxTQUFTLElBQUc7SUFDbEIsZ0JBQUEsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3RDLGdCQUFBLEdBQUcsQ0FBQyxPQUFPLEdBQUcsU0FBUyxDQUFDO0lBQ3hCLGdCQUFBLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLGFBQUMsQ0FBQyxDQUFDO0lBQ04sU0FBQTtJQUNJLGFBQUE7SUFDRCxZQUFBLEdBQUcsQ0FBQyxPQUFPLEdBQUcsS0FBSyxDQUFDO2dCQUNwQixTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEIsU0FBQTtTQUNKLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFUCxJQUFBLE1BQU0sUUFBUSxHQUFHLE1BQVEsRUFBQSxPQUFPLEdBQUcsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDO1FBRy9DLE9BQU8sQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLE9BQU8sS0FBSyxLQUFLLEtBQUssT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckYsSUFBQSxPQUFPLENBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxRQUFRLENBQVUsQ0FBQztJQUNoRDs7SUN3SEEsU0FBUytHLFVBQVEsQ0FBNkMsR0FBRyxDQUFLLElBQUksT0FBTyxDQUFvQixDQUFDLEVBQUU7YUFTeEYsWUFBWSxDQUFpQixRQUFrQixFQUFFLElBQVksRUFBRSxPQUEwQixFQUFBO0lBQ3JHLElBQUEsTUFBTSxTQUFTLEdBQUdqSCxHQUFPLENBQUMsTUFBSztJQUMzQixRQUFBLE9BQU8sUUFBUSxHQUFHLFFBQVEsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQztJQUMvRCxLQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFFMURQLENBQVMsQ0FBQyxNQUFLO0lBQ1gsUUFBQSxPQUFPLE1BQU0sU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDO0lBQ3JDLEtBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUE7SUFFZixJQUFBLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7YUFTZSxZQUFZLENBQWlCLFFBQWtCLEVBQUUsSUFBWSxFQUFFLE9BQTBCLEVBQUE7SUFDckcsSUFBQSxNQUFNLFNBQVMsR0FBR08sR0FBTyxDQUFDLE1BQUs7SUFDM0IsUUFBQSxPQUFPLFFBQVEsR0FBRyxRQUFRLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxJQUFJLENBQUM7SUFDL0QsS0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLFFBQVEsQ0FBQyxDQUFDLENBQUM7UUFFNUVQLENBQVMsQ0FBQyxNQUFLO0lBQ1gsUUFBQSxPQUFPLE1BQU0sU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDO0lBQ3JDLEtBQUMsRUFBRSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUE7SUFFZixJQUFBLE9BQU8sU0FBUyxDQUFDO0lBQ3JCLENBQUM7SUFPRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUF1Qkc7SUFDYSxTQUFBLFFBQVEsQ0FBcUQsWUFBNkMsRUFBRSxPQUFvQyxFQUFBOztJQUk1SixJQUFBLElBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxJQUFJLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQztRQUN0RCxPQUFPLEtBQUt3SCxVQUFRLENBQUM7Ozs7UUFNckIsTUFBTSxDQUFDLFdBQVcsRUFBRSxjQUFjLENBQUMsR0FBRyxRQUFRLENBQTBCLElBQUksQ0FBQyxDQUFDO1FBQzlFLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzVDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ2xELE1BQU0sQ0FBQyxZQUFZLEVBQUUsZUFBZSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3BELE1BQU0sQ0FBQyxXQUFXLEVBQUUsY0FBYyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDOzs7O0lBS2xELElBQUEsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzFELElBQUEsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFJLFNBQVUsQ0FBQyxDQUFDO0lBQy9ELElBQUEsTUFBTSxDQUFDLEtBQUssRUFBRSxRQUFRLEVBQUUsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFVLFNBQVUsQ0FBQyxDQUFDO0lBQ25FLElBQUEsTUFBTSxDQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUUsWUFBWSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlELElBQUEsTUFBTSxDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUUsYUFBYSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7SUFJakUsSUFBQSxNQUFNLENBQUMsU0FBUyxFQUFFLFNBQVMsQ0FBQyxHQUFHLGVBQWUsQ0FBWSxJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7Ozs7UUFNNUUsTUFBTSxxQ0FBcUMsR0FBRyxpQkFBaUIsQ0FBMEIsU0FBUyxtQkFBbUIsQ0FBQyxHQUFHLFFBQVksRUFBQTs7OztJQUtqSSxRQUFBLE1BQU0sUUFBUSxHQUFHLE9BQVEsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDOzs7O1lBS3ZDLE9BQU8sMEJBQTBCLENBQUMsVUFBVSxFQUFFLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQztJQUVqRSxLQUFDLENBQUMsQ0FBQzs7OztRQUtILE1BQU0sNkJBQTZCLEdBQUcsaUJBQWlCLENBQTBCLFNBQVMsb0JBQW9CLENBQUMsT0FBZ0IsRUFBRSxHQUFHLE9BQVcsRUFBQTtJQUUzSSxRQUFBLE1BQU0sTUFBTSxHQUFHLENBQUMsS0FBUSxLQUFPLEVBQUEsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztJQUN0SCxRQUFBLE1BQU0sT0FBTyxHQUFHLENBQUMsRUFBTyxLQUFPLEVBQUEsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQztZQUNqSCxNQUFNLFNBQVMsR0FBRyxNQUFLO0lBQ25CLFlBQUEsTUFBTSxNQUFNLEdBQUcsU0FBUyxFQUFFLENBQUM7Z0JBQzNCLGNBQWMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN6QixZQUFBLElBQUksTUFBTSxFQUFFO29CQUNSLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoQixnQkFBQSwwQkFBMEIsQ0FBQyxLQUFLLEVBQUUsR0FBRyxNQUFNLENBQUMsQ0FBQztJQUNoRCxhQUFBO0lBQ0ksaUJBQUE7b0JBQ0QsVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JCLGFBQUE7SUFFTCxTQUFDLENBQUM7WUFFRixJQUFJLENBQUMsT0FBTyxFQUFFOztnQkFFVixXQUFXLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3RCLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDakIsTUFBTSxNQUFNLEdBQUcsWUFBWSxHQUFHLEdBQUcsT0FBTyxDQUFNLENBQUM7SUFDL0MsWUFBQSxNQUFNLFNBQVMsSUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLE9BQU8sTUFBTSxJQUFJLFFBQVEsSUFBSSxNQUFNLElBQUssTUFBa0MsQ0FBQyxDQUFDO0lBQ2pILFlBQUEsSUFBSSxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFOzs7b0JBRzlCLE1BQU0sQ0FBQyxNQUFXLENBQUMsQ0FBQztJQUNwQixnQkFBQSxTQUFTLEVBQUUsQ0FBQztvQkFDWixjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDMUIsYUFBQTtJQUNJLGlCQUFBO0lBQ0EsZ0JBQUEsTUFBZ0MsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDakYsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQzNCLGFBQUE7SUFDSixTQUFBO0lBQ0ksYUFBQTs7OztnQkFJRCxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdEIsU0FBQTtZQUtELE9BQU8sU0FBUyxFQUFFLENBQUM7SUFDdkIsS0FBQyxDQUFDLENBQUM7SUFFSCxJQUFBLE1BQU0sbUJBQW1CLEdBQUcsWUFBWSxDQUFvRCxDQUFDLFFBQVEsR0FBRyxJQUFJLEdBQUcsNkJBQTZCLEVBQUUsUUFBUSxJQUFJLENBQUMsQ0FBQyxDQUFDO1FBQzdKLE1BQU0sbUJBQW1CLEdBQUcsWUFBWSxDQUFDLENBQUMsUUFBUSxHQUFHLElBQUksSUFBSSxtQkFBbUIsSUFBSSw2QkFBNkIsQ0FBQyxFQUFFLFFBQVEsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUNuSSxNQUFNLDBCQUEwQixJQUFJLG1CQUFtQixJQUFJLG1CQUFtQixJQUFJLDZCQUE2QixDQUFDLENBQUM7SUFFakgsSUFBQSxNQUFNLHFCQUFxQixHQUFHLGlCQUFpQixDQUFDLE1BQUs7SUFDakQsUUFBQSxJQUFJLDBCQUEwQixJQUFJLE9BQU8sSUFBSSwwQkFBMEI7Z0JBQ25FLDBCQUEwQixDQUFDLEtBQUssRUFBRSxDQUFDO0lBQzNDLEtBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTztJQUNILFFBQUEsV0FBVyxFQUFFLHFDQUFxQztZQUNsRCxXQUFXO1lBQ1gsT0FBTztZQUNQLE1BQU07WUFDTixLQUFLO1lBQ0wsUUFBUTtZQUNSLFNBQVM7WUFDVCxZQUFZO1lBQ1osV0FBVztZQUNYLFdBQVc7SUFDWCxRQUFBLFNBQVMsRUFBRSxRQUFRO1lBQ25CLHFCQUFxQjtTQUN4QixDQUFBO0lBR0w7O0lDaFRBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMERHO0lBQ2EsU0FBQSxlQUFlLENBQXVDLFlBQStFLEVBQUUsRUFBRSxPQUFPLEVBQUUsZUFBZSxFQUFFLEdBQUcsZ0JBQWdCLEVBQXFELEVBQUE7O0lBR3ZQLElBQUEsTUFBTSxDQUFDLGNBQWMsRUFBRSxpQkFBaUIsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHLFFBQVEsQ0FBMEIsU0FBUyxDQUFDLENBQUM7UUFDNUcsTUFBTSxDQUFDLFVBQVUsRUFBRSxhQUFhLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7Ozs7Ozs7O0lBU3BELElBQUEsTUFBTSxPQUFPLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxDQUFZLEtBQThCO0lBQ3pFLFFBQUEsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ3BDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxDQUFDO1lBQzVCLGFBQWEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwQixRQUFBLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDekIsS0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPO1lBQ0gsaUJBQWlCO1lBQ2pCLGNBQWM7WUFDZCxVQUFVO1lBQ1YsR0FBRyxRQUFRLENBQUMsWUFBWSxFQUFFLEVBQUUsT0FBTyxFQUFFLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztTQUM5RCxDQUFDO0lBQ047O0lDVEE7SUFFQTs7Ozs7Ozs7O0lBU0c7SUFDRyxTQUFVLGtCQUFrQixDQUFpRCxnQkFBd0QsRUFBQTtRQUl2SSxNQUFNLEVBQUUsZUFBZSxFQUFFLEVBQUUsd0JBQXdCLEVBQUUscUJBQXFCLEVBQUUsRUFBRSxHQUFHLGdCQUFnQixDQUFDO0lBRWxHLElBQUEsa0JBQWtCLENBQUMsb0JBQW9CLEVBQUUsd0JBQXdCLEVBQUUscUJBQXFCLENBQUMsQ0FBQztJQUUxRixJQUFBLE1BQU0sZUFBZSxHQUFHL0csR0FBVyxDQUFDLE1BQWE7SUFDN0MsUUFBQSxPQUFPLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUM7U0FDcEQsRUFBRSxFQUFFLENBQUMsQ0FBQzs7O1FBSVAsTUFBTSxvQkFBb0IsR0FBR0osQ0FBTSxDQUFpRyxFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQUUsQ0FBQyxFQUFFLFdBQVcsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDOzs7Ozs7SUFPM0wsSUFBQSxNQUFNLFlBQVksR0FBR0ksR0FBVyxDQUFDLENBQUMsQ0FBd0IsS0FBSTtZQUMxRCxLQUFLLE1BQU0sS0FBSyxJQUFJLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUU7SUFDbEQsWUFBQSxJQUFJLEtBQUs7b0JBQ0wsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hCLFNBQUE7WUFDRCxLQUFLLE1BQU0sS0FBSyxJQUFJLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUU7Z0JBQ2xELE1BQU0sS0FBSyxHQUFxQixvQkFBb0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQThCLENBQUMsQ0FBQztJQUNqRyxZQUFBLElBQUksS0FBSztvQkFDTCxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEIsU0FBQTtTQUNKLEVBQUUsRUFBRSxDQUFDLENBQUE7OztJQUlOLElBQUEsTUFBTSxtQkFBbUIsR0FBR0EsR0FBVyxDQUFvQyxDQUFDLEtBQVEsS0FBSTtZQUNwRixJQUFJLE9BQU8sS0FBSyxJQUFJLFFBQVE7Z0JBQ3hCLE9BQU8sb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFlLENBQUUsQ0FBQzs7Z0JBRTFELE9BQU8sb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFVLENBQUUsQ0FBQztTQUM1RCxFQUFFLEVBQUUsQ0FBQyxDQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztJQWtCTixJQUFBLE1BQU0sd0JBQXdCLEdBQUdKLENBQU0sQ0FBOEMsSUFBSSxDQUFDLENBQUM7UUFDM0YsTUFBTSw0QkFBNEIsR0FBR0EsQ0FBTSxDQUFDLElBQUksR0FBRyxFQUFLLENBQUMsQ0FBQztJQUMxRCxJQUFBLE1BQU0scUJBQXFCLEdBQUdJLEdBQVcsQ0FBQyxDQUFDLEtBQVEsS0FBSTtJQUVuRCxRQUFBLElBQUksNEJBQTRCLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxDQUFDLEVBQUU7Z0JBQ2hELGlCQUFpQixDQUFDLE1BQUs7SUFDbkIsZ0JBQUEsd0JBQXdCLEdBQUcsNEJBQTRCLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDakUsZ0JBQUEsNEJBQTRCLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBQ2pELGFBQUMsQ0FBQyxDQUFDO0lBQ04sU0FBQTtJQUVELFFBQUEsNEJBQTRCLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVoRCxRQUFBLE9BQU8sTUFBUSxHQUFDLENBQUM7SUFFckIsS0FBQyxFQUFFLDJCQUEwQixDQUFDLENBQUM7UUFFL0IsTUFBTSxxQkFBcUIsR0FBR0EsR0FBVyxDQUFDLENBQUMsS0FBUSxFQUFFLE9BQWdCLEtBQVU7SUFDM0UsUUFBQSxJQUFJLENBQUMsd0JBQXdCLENBQUMsT0FBTyxFQUFFO2dCQUNuQyx3QkFBd0IsQ0FBQyxPQUFPLEdBQUc7b0JBQy9CLE1BQU0sRUFBRSxJQUFJLEdBQUcsRUFBRTtvQkFDakIsUUFBUSxFQUFFLElBQUksR0FBRyxFQUFFO2lCQUN0QixDQUFDO2dCQUNGLGlCQUFpQixDQUFDLE1BQUs7SUFDbkIsZ0JBQUEscUJBQXFCLEdBQUcsd0JBQXdCLENBQUMsT0FBUSxDQUFDLE1BQU0sRUFBRSx3QkFBd0IsQ0FBQyxPQUFRLENBQUMsUUFBUSxDQUFDLENBQUE7SUFDN0csZ0JBQUEsd0JBQXdCLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztJQUM1QyxhQUFDLENBQUMsQ0FBQztJQUNOLFNBQUE7SUFFRCxRQUFBLElBQUksT0FBTyxFQUFFO0lBQ1QsWUFBQSxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLFlBQVksRUFBRSxLQUFlLENBQUMsQ0FBQztJQUNwSCxTQUFBO0lBQ0ksYUFBQTtJQUNELFlBQUEsSUFBSSxPQUFPLEtBQUssSUFBSSxRQUFRLEVBQUU7b0JBQzFCLE9BQU8sb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFlLENBQUMsQ0FBQztvQkFDekQsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsZ0JBQUEsT0FBTyxLQUFLLElBQUksb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLElBQUksb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDLEtBQUssU0FBUyxFQUFFO0lBQzVKLG9CQUFBLEVBQUUsS0FBSyxDQUFDO0lBQ1gsaUJBQUE7SUFDRCxnQkFBQSxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sR0FBRyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDbkcsYUFBQTs7b0JBRUcsT0FBTyxvQkFBb0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQVUsQ0FBQyxDQUFDO0lBQzNELFNBQUE7SUFFRCxRQUFBLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxPQUFPLEdBQUcsUUFBUSxHQUFHLFVBQVUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqRixLQUFDLEVBQUUsMkJBQTBCLENBQUMsQ0FBQztRQUcvQixNQUFNLGVBQWUsR0FBR0EsR0FBVyxDQUEyQixDQUFDLEVBQUUsWUFBWSxFQUFFLElBQUksR0FBRyxLQUFJOzs7OztZQUt0RkwsQ0FBZSxDQUFDLE1BQUs7O0lBRWpCLFlBQUEsSUFBSSxPQUFPLElBQUksQ0FBQyxLQUFLLElBQUksUUFBUSxFQUFFO0lBQy9CLGdCQUFBLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQWUsQ0FBQyxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLElBQUksRUFBRSxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbEksYUFBQTtJQUNJLGlCQUFBO0lBQ0QsZ0JBQUEsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBVSxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQztJQUM3SCxhQUFBO0lBQ0QsWUFBQSxPQUFPLHFCQUFxQixDQUFDLElBQUksQ0FBQyxLQUFVLENBQUMsQ0FBQztJQUNsRCxTQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7Ozs7O1lBT3RDQSxDQUFlLENBQUMsTUFBSztnQkFDakIscUJBQXFCLEdBQUcsSUFBSSxDQUFDLEtBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMvQyxZQUFBLE9BQU8sTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMsS0FBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2pFLFNBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLEtBQUMsRUFBRSwyQkFBMEIsQ0FBQyxDQUFDO1FBRy9CLE1BQU0sZUFBZSxHQUFHQyxDQUFNLENBQTJCO0lBQ3JELFFBQUEsR0FBRyxFQUFFLENBQUMsRUFBRSxvQkFBb0IsQ0FBQyxPQUFPLEVBQVE7SUFDNUMsUUFBQSxPQUFPLEVBQUUsWUFBWTtJQUNyQixRQUFBLEtBQUssRUFBRSxtQkFBbUI7SUFDMUIsUUFBQSxlQUFlLEVBQUUsZUFBZTtZQUNoQyxVQUFVLEVBQUUsTUFBSztnQkFDYixPQUFPLG9CQUFvQixDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUM7YUFDbkQ7SUFDSixLQUFBLENBQUMsQ0FBQztRQUVILE9BQU87WUFDSCxlQUFlO0lBQ2YsUUFBQSxlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsZUFBZSxDQUFDLE9BQU8sRUFBRTtTQUN6RCxDQUFBO0lBQ0wsQ0FBQztJQStFRDs7Ozs7Ozs7Ozs7Ozs7OztJQWdCRztJQUNhLFNBQUEsZUFBZSxDQUFzQixFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLGFBQWEsRUFBRSxHQUFHLEVBQW1DLEVBQUE7SUFDNUksSUFBQSxrQkFBa0IsQ0FBQyxpQkFBaUIsRUFBRSxhQUFhLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFFMUQsTUFBTSxDQUFDLGVBQWUsRUFBRSxlQUFlLENBQUMsR0FBRyxlQUFlLENBQWdCLGFBQWEsRUFBRUksR0FBVyxDQUFDLE9BQU8sWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUUxSSxNQUFNLENBQUMsaUJBQWlCLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxlQUFlLENBQWdCLElBQUksRUFBRUEsR0FBVyxDQUFDLE9BQU8sWUFBWSxLQUFLLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQzs7O0lBS3JJLElBQUEsTUFBTSxhQUFhLEdBQUdBLEdBQVcsQ0FBQyxDQUFDLGNBQXNCLEtBQUk7WUFDekQsSUFBSSxlQUFlLEdBQUcsUUFBUSxDQUFDO1lBQy9CLElBQUksWUFBWSxHQUFrQixJQUFJLENBQUM7SUFDdkMsUUFBQSxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBRztnQkFFckIsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFLE9BQU8sRUFBRSxFQUFFO0lBQy9CLGdCQUFBLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEtBQUssR0FBRyxjQUFjLENBQUMsQ0FBQztJQUMzRCxnQkFBQSxJQUFJLFdBQVcsR0FBRyxlQUFlLEtBQUssV0FBVyxJQUFJLGVBQWUsSUFBSSxLQUFLLENBQUMsS0FBSyxHQUFHLGNBQWMsQ0FBQyxFQUFFO3dCQUNuRyxlQUFlLEdBQUcsV0FBVyxDQUFDO0lBQzlCLG9CQUFBLFlBQVksR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDO0lBQzlCLGlCQUFBO0lBQ0osYUFBQTtJQUNMLFNBQUMsQ0FBQyxDQUFDO0lBQ0gsUUFBQSxPQUFPLFlBQVksQ0FBQztJQUN4QixLQUFDLEVBQUUsNEJBQTJCLENBQUMsQ0FBQzs7Ozs7SUFNaEMsSUFBQSxNQUFNLG9CQUFvQixHQUFHLGlCQUFpQixDQUFDLE1BQUs7SUFDaEQsUUFBQSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsRUFBRSxDQUFDO0lBQzNDLFFBQUEsTUFBTSxZQUFZLEdBQUcsZUFBZSxFQUFFLENBQUM7SUFDdkMsUUFBQSxNQUFNLFlBQVksR0FBRyxZQUFZLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDO1lBRWhGLElBQUksY0FBYyxJQUFJLElBQUksSUFBSSxVQUFVLEtBQUssY0FBYyxJQUFJLFlBQVksSUFBSSxZQUFZLElBQUksSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssR0FBRyxHQUFHLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFO2dCQUMzSSxZQUFZLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxZQUFBLE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDdEQsZUFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFDO2dCQUNqQyxJQUFJLGVBQWUsSUFBSSxJQUFJLEVBQUU7b0JBQ3pCLE1BQU0sZUFBZSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsZUFBZSxDQUFFLENBQUM7b0JBQ3pELE9BQU8sQ0FBQyxNQUFNLENBQUMsZUFBZSxJQUFJLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO29CQUM3RCxlQUFlLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQyxhQUFBO0lBRUosU0FBQTtJQUNMLEtBQUMsQ0FBQyxDQUFDO0lBS0gsSUFBQSxNQUFNLFdBQVcsR0FBR0EsR0FBVyxDQUFDLENBQUMsR0FBK0MsS0FBSTtJQUNoRixRQUFBLE1BQU0sY0FBYyxHQUFHLEdBQUcsWUFBWSxRQUFRLEdBQUcsR0FBRyxDQUFDLGlCQUFpQixFQUFFLENBQUMsR0FBRyxHQUFHLENBQUM7OztZQUloRixpQkFBaUIsQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUNsQyxRQUFBLE1BQU0sWUFBWSxHQUFHLGVBQWUsRUFBRSxDQUFDO1lBQ3ZDLElBQUksWUFBWSxJQUFJLGNBQWM7SUFDOUIsWUFBQSxPQUFPLGNBQWMsQ0FBQztZQUUxQixJQUFJLGdCQUFnQixJQUFJLGNBQWMsSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsY0FBYyxDQUFDLENBQUMsQ0FBQztZQUN4RixNQUFNLGdCQUFnQixJQUFJLFlBQVksSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQztZQUN0RixJQUFJLGNBQWMsSUFBSSxJQUFJLEVBQUU7O2dCQUV4QixlQUFlLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQ3RCLGdCQUFnQixFQUFFLEtBQUssR0FBRyxHQUFHLENBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0MsWUFBQSxPQUFPLElBQUksQ0FBQztJQUNmLFNBQUE7SUFDSSxhQUFBO0lBQ0QsWUFBQSxJQUFJLGdCQUFnQixJQUFJLGdCQUFnQixDQUFDLEtBQUssR0FBRyxHQUFHLENBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRTtvQkFDOUQsZUFBZSxDQUFDLGNBQWMsQ0FBQyxDQUFDO29CQUNoQyxnQkFBZ0IsRUFBRSxLQUFLLEdBQUcsR0FBRyxDQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUMzQyxnQkFBZ0IsQ0FBQyxLQUFLLEdBQUcsR0FBRyxDQUFFLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3pDLGdCQUFBLE9BQU8sY0FBYyxDQUFDO0lBQ3pCLGFBQUE7SUFDSSxpQkFBQTtJQUNELGdCQUFBLE1BQU0sZUFBZSxHQUFHLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztvQkFDdEQsZUFBZSxDQUFDLGVBQWUsQ0FBQyxDQUFDO29CQUNqQyxJQUFJLGVBQWUsSUFBSSxJQUFJLEVBQUU7SUFDekIsb0JBQUEsZ0JBQWdCLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxlQUFlLENBQUUsQ0FBQzt3QkFDcEQsT0FBTyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLEVBQUUsbUJBQW1CLENBQUMsQ0FBQzt3QkFDOUQsZ0JBQWdCLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQzt3QkFDM0MsZ0JBQWdCLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN6QyxvQkFBQSxPQUFPLGVBQWUsQ0FBQztJQUMxQixpQkFBQTtJQUNJLHFCQUFBO3dCQUNELGdCQUFnQixFQUFFLEtBQUssR0FBRyxHQUFHLENBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDM0Msb0JBQUEsT0FBTyxJQUFJLENBQUM7SUFDZixpQkFBQTtJQUNKLGFBQUE7SUFDSixTQUFBO1NBQ0osRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQTCxDQUFlLENBQUMsTUFBSztZQUNqQixJQUFJLFlBQVksSUFBSSxJQUFJO0lBQ3BCLFlBQUEsUUFBUSxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsRUFBRSxLQUFLLEdBQUcsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQzdELEVBQUUsRUFBRSxDQUFDLENBQUE7SUFFTixJQUFBLE9BQU8sRUFBRSxXQUFXLEVBQUUsb0JBQW9CLEVBQUUsZUFBZSxFQUFFLENBQUM7SUFDbEU7O0lDaGVBLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxFQUFFLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEtBQUssR0FBRyxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEtBQUssSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBUSxTQUFTLElBQUksRUFBRSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDOztJQ0czVixTQUFVcUgsYUFBVyxDQUFDLE9BQWMsSUFBSSxRQUFRLE9BQU8sRUFBRSxhQUFhLElBQUksUUFBUSxJQUFJLE1BQU0sQ0FBQyxRQUFRLElBQUksVUFBVSxDQUFDLFFBQVEsRUFBRTs7SUNEcEgsU0FBQSxpQkFBaUIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQXVELEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFzRCxFQUFBO0lBQzNLLElBQUEsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7SUFDNUIsUUFBQSxPQUFPLFNBQVMsQ0FBQztJQUNwQixLQUFBO2FBQ0ksSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ2xCLFFBQUEsT0FBTyxHQUFHLENBQUM7SUFDZCxLQUFBO2FBQ0ksSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ2xCLFFBQUEsT0FBTyxHQUFHLENBQUM7SUFDZCxLQUFBO0lBQ0ksU0FBQTtZQUNELE9BQU9uVSxHQUFhLENBQUNlLEdBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ2hELEtBQUE7SUFDTDs7SUNaQTs7Ozs7OztJQU9HO0lBQ0csU0FBVSxnQkFBZ0IsQ0FBd0IsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQXdELEVBQUUsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQXVELEVBQUE7OztJQUt6UCxJQUFBLElBQUksUUFBUSxJQUFJLFFBQVEsSUFBSSxZQUFZLElBQUksWUFBWSxFQUFFO0lBQ3RELFFBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFFBQVEsRUFBRSxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDM0QsUUFBQSxNQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLFlBQVksQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUMzRCxNQUFNLFVBQVUsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsRUFBRSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFBO1lBRWxGLE9BQU8sS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDM0MsS0FBQTtJQUNJLFNBQUE7SUFDRCxRQUFBLE9BQU8sU0FBUyxDQUFDO0lBQ3BCLEtBQUE7SUFDTDs7SUN0QkEsU0FBUyxVQUFVLENBQUksUUFBa0IsRUFBRSxHQUE4QixFQUFBO0lBQ3JFLElBQUEsSUFBSSxPQUFPLEdBQUcsS0FBSyxVQUFVLEVBQUU7WUFDM0IsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2pCLEtBQUE7YUFDSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7SUFDakIsUUFBQSxHQUEyQixDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUM7SUFDbkQsS0FBQTtJQUNJLFNBQUE7O0lBRUQsUUFBQSxTQUFTO0lBQ1QsUUFBQSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSx1RUFBdUUsQ0FBQyxDQUFDO0lBQ2xHLEtBQUE7SUFDTCxDQUFDO0lBT0Q7Ozs7O0lBS0c7SUFDYSxTQUFBLGFBQWEsQ0FBd0IsRUFBRSxHQUFHLEVBQUUsR0FBRyxFQUEyQixFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBMkIsRUFBQTtJQUM3SCxJQUFBLE1BQU0sUUFBUSxHQUFtQm9NLEdBQVcsQ0FBQyxDQUFDLE9BQWlCLEtBQUk7SUFDL0QsUUFBQSxVQUFVLENBQUMsT0FBTyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ3pCLFFBQUEsVUFBVSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUMsQ0FBQztJQUM3QixLQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUVmLElBQUEsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7SUFDNUIsUUFBQSxPQUFPLFNBQVUsQ0FBQztJQUNyQixLQUFBO2FBQ0ksSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ2xCLFFBQUEsT0FBTyxHQUFJLENBQUM7SUFDZixLQUFBO2FBQ0ksSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ2xCLFFBQUEsT0FBTyxHQUFJLENBQUM7SUFDZixLQUFBO0lBQ0ksU0FBQTtJQUNELFFBQUEsT0FBTyxRQUFRLENBQUM7SUFDbkIsS0FBQTtJQUNMOztJQzdDQSxTQUFTLG1CQUFtQixDQUFDLEtBQWEsRUFBQTs7UUFFdEMsT0FBTyxNQUFNLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQW1DLENBQUM7SUFDekgsQ0FBQztJQUVEOzs7Ozs7SUFNRztJQUNhLFNBQUEsZUFBZSxDQUFDLEdBQXFELEVBQUUsR0FBcUQsRUFBQTs7UUFHeEksSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSztJQUMxQixRQUFBLE9BQU8sU0FBUyxDQUFDO0lBRXJCLElBQUEsSUFBSSxPQUFPLEdBQUcsSUFBSSxPQUFPLEdBQUcsRUFBRTs7SUFFMUIsUUFBQSxJQUFJLEdBQUcsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSztnQkFDekIsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDO0lBQ3JCLFFBQUEsSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLElBQUksR0FBRyxFQUFFLEtBQUs7Z0JBQ3pCLE9BQU8sR0FBRyxDQUFDLEtBQUssQ0FBQzs7O0lBSXJCLFFBQUEsSUFBSSxHQUFHLEVBQUUsS0FBSyxJQUFJLEdBQUcsRUFBRSxLQUFLLEVBQUU7O0lBRTFCLFlBQUEsSUFBSSxPQUFPLEdBQUcsRUFBRSxLQUFLLElBQUksUUFBUTtJQUM3QixnQkFBQSxPQUFPLGVBQWUsQ0FBQyxFQUFFLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsS0FBZSxDQUFDLEVBQUUsRUFBRSxHQUFHLENBQXdCLENBQUM7SUFDN0csWUFBQSxJQUFJLE9BQU8sR0FBRyxFQUFFLEtBQUssSUFBSSxRQUFRO0lBQzdCLGdCQUFBLE9BQU8sZUFBZSxDQUFDLEdBQUcsRUFBRSxFQUFFLEtBQUssRUFBRSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsS0FBZSxDQUFDLEVBQUUsQ0FBd0IsQ0FBQztJQUNoSCxTQUFBOztJQUdELFFBQUEsT0FBTyxTQUFTLENBQUM7SUFDcEIsS0FBQTs7SUFHRCxJQUFBLElBQUksT0FBTyxHQUFHLEVBQUUsS0FBSyxJQUFJLFFBQVEsRUFBRTtZQUMvQixPQUFPLENBQUEsRUFBRyxHQUFHLENBQUMsS0FBSyxDQUFBLENBQUEsRUFBSSxHQUFHLEVBQUUsS0FBSyxJQUFJLEVBQUUsQ0FBQSxDQUF1QixDQUFDO0lBQ2xFLEtBQUE7O1FBR0QsT0FBTztJQUNILFFBQUEsSUFBSSxHQUFHLEVBQUUsS0FBSyxJQUFJLEVBQUUsQ0FBd0I7SUFDNUMsUUFBQSxJQUFJLEdBQUcsRUFBRSxLQUFLLElBQUksRUFBRSxDQUF3QjtTQUNiLENBQUE7SUFDdkM7O0lDN0NBLElBQUksR0FBRyxHQUFHLE9BQU8sQ0FBQyxJQUFJLENBQUM7SUFPdkI7Ozs7Ozs7SUFPRztJQUNhLFNBQUEsY0FBYyxDQUF3QixNQUErQixFQUFFLE1BQStCLEVBQUE7Ozs7O1FBS2xILE1BQU0sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsR0FBRyxPQUFPLEVBQUUsR0FBRyxNQUFNLENBQUM7UUFDbEksTUFBTSxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxHQUFHLE9BQU8sRUFBRSxHQUFHLE1BQU0sQ0FBQztJQUVsSSxJQUFBLE1BQU0sR0FBRyxHQUE0QjtJQUNqQyxRQUFBLEdBQUcsT0FBTztJQUNWLFFBQUEsR0FBRyxFQUFFLGFBQWEsQ0FBSSxNQUFNLEVBQUUsTUFBTSxDQUFDO0lBQ3JDLFFBQUEsS0FBSyxFQUFFLGVBQWUsQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDO0lBQ3RDLFFBQUEsU0FBUyxFQUFFLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUM7SUFDM0MsUUFBQSxRQUFRLEVBQUUsaUJBQWlCLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQztTQUN2QyxDQUFDO0lBRVQsSUFBQSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssU0FBUztZQUFFLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUMxQyxJQUFBLElBQUksR0FBRyxDQUFDLEtBQUssS0FBSyxTQUFTO1lBQUUsT0FBTyxHQUFHLENBQUMsS0FBSyxDQUFDO0lBQzlDLElBQUEsSUFBSSxHQUFHLENBQUMsU0FBUyxLQUFLLFNBQVM7WUFBRSxPQUFPLEdBQUcsQ0FBQyxTQUFTLENBQUM7SUFDdEQsSUFBQSxJQUFJLEdBQUcsQ0FBQyxRQUFRLEtBQUssU0FBUztZQUFFLE9BQU8sR0FBRyxDQUFDLFFBQVEsQ0FBQzs7OztRQUtwRCxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBRTNDLEtBQUssTUFBTSxDQUFDLE9BQU8sRUFBRSxRQUFRLENBQUMsSUFBSSxVQUFVLEVBQUU7WUFDMUMsTUFBTSxNQUFNLEdBQUcsT0FBd0MsQ0FBQztJQUV4RCxRQUFBLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxNQUE4QixDQUFDLENBQUM7WUFFekQsSUFBSSxPQUFPLFFBQVEsS0FBSyxVQUFVLElBQUksT0FBTyxRQUFRLEtBQUssVUFBVSxFQUFFOzs7Z0JBSWxFLE1BQU0sTUFBTSxHQUFHLGNBQWMsQ0FBQyxRQUFpQixFQUFFLFFBQWlCLENBQUMsQ0FBQztJQUNwRSxZQUFBLEdBQUcsQ0FBQyxNQUF1QyxDQUFDLEdBQUcsTUFBZSxDQUFDO0lBQ2xFLFNBQUE7SUFDSSxhQUFBOztJQUVELFlBQUEsSUFBSSxRQUFRLElBQUksSUFBSSxJQUFJLFFBQVEsSUFBSSxJQUFJLEVBQUU7SUFDdEMsZ0JBQUEsSUFBSSxRQUFRLEtBQUssSUFBSSxJQUFJLFFBQVEsS0FBSyxTQUFTO0lBQzNDLG9CQUFBLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxRQUFpQixDQUFDOztJQUVoQyxvQkFBQSxHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsUUFBaUIsQ0FBQztJQUN2QyxhQUFBO2dCQUNELElBQUksUUFBUSxJQUFJLElBQUk7SUFDaEIsZ0JBQUEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFFBQWlCLENBQUM7cUJBQy9CLElBQUksUUFBUSxJQUFJLElBQUk7SUFDckIsZ0JBQUEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLFFBQWlCLENBQUM7cUJBQy9CLElBQUssUUFBZ0IsSUFBSSxRQUFRLEVBQUUsQ0FJdkM7SUFDSSxpQkFBQTs7O29CQUdELEdBQUcsR0FBRyxDQUFBLFVBQUEsRUFBYSxNQUFNLENBQUEsc0NBQUEsRUFBeUMsUUFBUSxDQUFRLEtBQUEsRUFBQSxRQUFRLENBQWlELCtDQUFBLENBQUEsQ0FBQyxDQUFDO0lBQzdJLGdCQUFBLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBRyxRQUFpQixDQUFBO0lBQ2xDLGFBQUE7SUFDSixTQUFBO0lBQ0osS0FBQTtJQUVELElBQUEsT0FBTyxHQUFHLENBQUM7SUFFZixDQUFDO0lBRUQsU0FBUyxjQUFjLENBQXVFLEdBQXlCLEVBQUUsR0FBeUIsRUFBQTtJQUU5SSxJQUFBLElBQUksQ0FBQyxHQUFHO0lBQ0osUUFBQSxPQUFPLEdBQUcsQ0FBQztJQUNmLElBQUEsSUFBSSxDQUFDLEdBQUc7SUFDSixRQUFBLE9BQU8sR0FBRyxDQUFDO0lBRWYsSUFBQSxPQUFPLENBQUMsR0FBRyxJQUFtQixLQUFJO0lBQzlCLFFBQUEsTUFBTSxFQUFFLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7SUFDeEIsUUFBQSxNQUFNLEVBQUUsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztJQUV4QixRQUFBLElBQUksRUFBRSxZQUFZLE9BQU8sSUFBSSxFQUFFLFlBQVksT0FBTztnQkFDOUMsT0FBTyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDckMsS0FBQyxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBK0tFOztJQ2xPYyxTQUFBLFlBQVksQ0FBd0IsRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBMEIsRUFBQTtJQUU5SSxJQUFBLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUM3RCxJQUFBLE1BQU0sQ0FBQyxjQUFjLEVBQUUsaUJBQWlCLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxRQUFRLENBQW9DLElBQUksQ0FBQyxDQUFDO0lBRWpILElBQUEsTUFBTSxpQkFBaUIsR0FBR0EsR0FBVyxDQUFDLENBQW9DLENBQUksS0FBSTtJQUU5RSxRQUFBLE1BQU0sR0FBRyxHQUFHSixDQUFNLENBQUksSUFBSSxDQUFDLENBQUM7SUFFNUIsUUFBQSxNQUFNLFdBQVcsR0FBRyxDQUFDLENBQVksS0FBSTs7Z0JBRWpDLFdBQVcsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbEIsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFFO29CQUNoQixDQUFDLENBQUMsWUFBWSxDQUFDLGFBQWEsSUFBSSxhQUFhLElBQUksS0FBSyxDQUFDLENBQUM7SUFDeEQsZ0JBQUEsSUFBSSxTQUFTO0lBQ1Qsb0JBQUEsQ0FBQyxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsU0FBUyxFQUFFLGdCQUFnQixJQUFJLENBQUMsRUFBRSxnQkFBZ0IsSUFBSSxDQUFDLENBQUMsQ0FBQTtvQkFFeEYsTUFBTSxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQXVDLENBQUM7b0JBQzNFLEtBQUssTUFBTSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsSUFBSSxPQUFPLEVBQUU7d0JBQ3BDLENBQUMsQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMxQyxpQkFBQTtJQUNKLGFBQUE7SUFDTCxTQUFDLENBQUM7SUFFRixRQUFBLE1BQU0sU0FBUyxHQUFHLENBQUMsQ0FBWSxLQUFJO2dCQUMvQixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ25CLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDbkIsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFFO0lBQ2hCLGdCQUFBLElBQUksQ0FBQyxDQUFDLFlBQVksQ0FBQyxVQUFVLElBQUksTUFBTSxFQUFFO0lBQ3JDLG9CQUFBLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLENBQUM7SUFDaEQsaUJBQUE7SUFDSSxxQkFBQTt3QkFDRCxpQkFBaUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMzQixpQkFBQTtJQUNKLGFBQUE7SUFDTCxTQUFDLENBQUM7SUFHRixRQUFBLE9BQU8sY0FBYyxDQUFJO0lBQ3JCLFlBQUEsU0FBUyxFQUFFLElBQUk7Z0JBQ2YsV0FBVztnQkFDWCxTQUFTO2dCQUNULEdBQUc7YUFDTixFQUFFLENBQUMsQ0FBQyxDQUFDO1NBRVQsRUFBRSxDQUFDLGFBQWEsRUFBRSxTQUFTLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQzs7O0lBSW5HLElBQUEsTUFBTSxHQUFHLEdBQThCO1lBQ25DLGlCQUFpQjtZQUNqQixRQUFRO1lBQ1IsV0FBVztZQUNYLGNBQWM7WUFDZCxpQkFBaUI7U0FDcEIsQ0FBQztJQUVGLElBQUEsT0FBTyxHQUFHLENBQUM7SUFDZjs7SUN2RE0sTUFBTyxrQkFBbUIsU0FBUSxLQUFLLENBQUE7SUFDekMsSUFBQSxRQUFRLENBQVM7SUFDakIsSUFBQSxTQUFTLENBQXlCO1FBRWxDLFdBQVksQ0FBQSxRQUFnQixFQUFFLElBQXlCLEVBQUE7SUFDbkQsUUFBQSxLQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8sSUFBSSxpREFBaUQsQ0FBQyxDQUFDO0lBQzFFLFFBQUEsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDekIsUUFBQSxJQUFJLENBQUMsU0FBUyxHQUFJLElBQUksRUFBRSxJQUErQixDQUFDO1NBQzNEO0lBRUosQ0FBQTtJQUllLFNBQUEsWUFBWSxDQUF3QixFQUFFLE1BQU0sRUFBMEIsRUFBQTtRQUVsRixNQUFNLENBQUMscUJBQXFCLEVBQUUsd0JBQXdCLENBQUMsR0FBRyxRQUFRLENBQTRCLElBQUksQ0FBQyxDQUFDO1FBQ3BHLE1BQU0sQ0FBQyx1QkFBdUIsRUFBRSwwQkFBMEIsQ0FBQyxHQUFHLFFBQVEsQ0FBcUIsSUFBSSxDQUFDLENBQUM7UUFFakcsTUFBTSxDQUFDLFlBQVksRUFBRSxlQUFlLENBQUMsR0FBRyxRQUFRLENBQW9CLElBQUksQ0FBQyxDQUFDO1FBQzFFLE1BQU0sQ0FBQyxjQUFjLEVBQUUsaUJBQWlCLENBQUMsR0FBRyxRQUFRLENBQXdDLElBQUksQ0FBQyxDQUFDO1FBRWxHLE1BQU0sQ0FBQyxTQUFTLEVBQUUsWUFBWSxDQUFDLEdBQUcsUUFBUSxDQUFzQixTQUFTLENBQUMsQ0FBQzs7O0lBSTNFLElBQUEsTUFBTSxlQUFlLEdBQUdBLENBQU0sQ0FBbUYsRUFBRSxDQUFDLENBQUM7SUFDckgsSUFBQSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsc0JBQXNCLEVBQUUsc0JBQXNCLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzRixJQUFBLE1BQU0sQ0FBQyxZQUFZLEVBQUUsZUFBZSxFQUFFLGVBQWUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7O1FBSXJFTCxDQUFTLENBQUMsTUFBSztJQUNYLFFBQUEsTUFBTSxtQkFBbUIsR0FBRyxzQkFBc0IsRUFBRSxDQUFDO0lBQ3JELFFBQUEsTUFBTSxZQUFZLEdBQUcsZUFBZSxFQUFFLENBQUM7WUFFdkMsSUFBSSxZQUFZLEdBQUcsQ0FBQyxFQUFFO0lBQ2xCLFlBQUEsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsSUFBSSxZQUFZLEVBQUU7b0JBQzFDLHNCQUFzQixDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3BDLGFBQUE7SUFDSixTQUFBO0lBRUwsS0FBQyxFQUFFLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7O1FBVW5CQSxDQUFTLENBQUMsTUFBSztZQUNYLElBQUksbUJBQW1CLElBQUksQ0FBQyxFQUFFO2dCQUMxQixNQUFNLGNBQWMsR0FBRyxlQUFlLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDLENBQUM7SUFDcEUsWUFBQSxjQUFjLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFJO29CQUV6QixJQUFJLElBQUksS0FBSyxJQUFJLEVBQUU7SUFDZixvQkFBQSxNQUFNLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQzt3QkFDaEMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO3dCQUN2QixpQkFBaUIsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM5QixpQkFBQTs7SUFJRCxnQkFBQSxNQUFNLG1CQUFtQixHQUFHLHNCQUFzQixFQUFFLENBQUM7SUFDckQsZ0JBQUEsTUFBTSxZQUFZLEdBQUcsZUFBZSxFQUFFLENBQUM7SUFFdkMsZ0JBQUEsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsSUFBSSxZQUFZLEVBQUU7Ozt3QkFHMUMsc0JBQXNCLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDcEMsaUJBQUE7SUFDTCxhQUFDLENBQUMsQ0FBQTtJQUNMLFNBQUE7SUFDTCxLQUFDLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUE7SUFHekIsSUFBQSxNQUFNLGlCQUFpQixHQUFtRCxDQUFDLENBQUMsS0FBSTs7O0lBSzVFLFFBQUEsTUFBTSxXQUFXLEdBQUcsQ0FBQyxDQUFZLEtBQUk7Z0JBQ2pDLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDbkIsSUFBSSxDQUFDLENBQUMsWUFBWSxFQUFFOztvQkFHaEIsQ0FBQyxDQUFDLFlBQVksQ0FBQyxVQUFVLElBQUksTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDO0lBRS9DLGdCQUFBLE1BQU0sWUFBWSxHQUFHLElBQUksR0FBRyxFQUFVLENBQUM7SUFDdkMsZ0JBQUEsTUFBTSxRQUFRLEdBQUcsSUFBSSxLQUFLLEVBQW9CLENBQUM7b0JBRS9DLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLFlBQVksRUFBRSxLQUFLLElBQUksRUFBRSxFQUFFO0lBQzVDLG9CQUFBLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDO3dCQUU1QixJQUFJLElBQUksS0FBSyxRQUFRLEVBQUU7SUFDbkIsd0JBQUEsWUFBWSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixxQkFBQTs2QkFDSSxJQUFJLElBQUksS0FBSyxNQUFNLEVBQUU7NEJBQ3RCLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFFdEMscUJBQUE7SUFDSixpQkFBQTtvQkFFRCx3QkFBd0IsQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDbkMsMEJBQTBCLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDNUMsYUFBQTtJQUNMLFNBQUMsQ0FBQzs7SUFHRixRQUFBLE1BQU0sV0FBVyxHQUFHLENBQUMsQ0FBWSxLQUFJO2dCQUNqQyxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ25CLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQiwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNyQyxTQUFDLENBQUM7O0lBR0YsUUFBQSxNQUFNLFVBQVUsR0FBRyxDQUFDLENBQVksS0FBSTtnQkFDaEMsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ3ZCLFNBQUMsQ0FBQTs7SUFHRCxRQUFBLE1BQU0sTUFBTSxHQUFHLENBQUMsQ0FBWSxLQUFJO2dCQUM1QixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBRW5CLHdCQUF3QixDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQiwwQkFBMEIsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUVqQyxZQUFBLE1BQU0sV0FBVyxHQUFHLElBQUksS0FBSyxFQUFvQixDQUFDO2dCQUVsRCxNQUFNLFFBQVEsR0FBbUMsRUFBRSxDQUFDO2dCQUNwRCxNQUFNLFFBQVEsR0FBZSxFQUFFLENBQUM7Z0JBRWhDLEtBQUssTUFBTSxJQUFJLElBQUksQ0FBQyxDQUFDLFlBQVksRUFBRSxLQUFLLElBQUksRUFBRSxFQUFFO0lBQzVDLGdCQUFBLE1BQU0sRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDO29CQUU1QixJQUFJLElBQUksS0FBSyxRQUFRLEVBQUU7SUFDbkIsb0JBQUEsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxDQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sS0FBSyxJQUFJLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLEdBQUcsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUM5SCxpQkFBQTt5QkFDSSxJQUFJLElBQUksS0FBSyxNQUFNLEVBQUU7SUFDdEIsb0JBQUEsTUFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQzlCLG9CQUFBLElBQUksSUFBSSxFQUFFOzRCQUNOLFdBQVcsQ0FBQyxJQUFJLENBQ1osSUFBSSxPQUFPLENBQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxLQUFJO0lBRWxDLDRCQUFBLE1BQU0sTUFBTSxHQUFHLElBQUksVUFBVSxFQUFFLENBQUM7SUFFaEMsNEJBQUEsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSTtJQUNsQixnQ0FBQSxPQUFPLEVBQUUsQ0FBQztJQUNWLGdDQUFBLE1BQU0sSUFBSSxHQUFHLE1BQU0sQ0FBQyxNQUFxQixDQUFDO0lBQzFDLGdDQUFBLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxVQUFVLEVBQUUsWUFBWSxFQUFFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDO0lBQ3RILDZCQUFDLENBQUM7Z0NBQ0YsTUFBTSxDQUFDLE9BQU8sR0FBRyxDQUFDLENBQUMsS0FBSSxFQUFHLE1BQU0sQ0FBQyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO2dDQUNyRixNQUFNLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQyxLQUFJLEVBQUcsTUFBTSxDQUFDLElBQUksa0JBQWtCLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFFckYsNEJBQUEsTUFBTSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxDQUFDOzZCQUNsQyxDQUFDLENBQ0wsQ0FBQzs0QkFDRixRQUFRLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDbkIscUJBQUE7SUFDSixpQkFBQTtJQUNKLGFBQUE7SUFHRCxZQUFBLGVBQWUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQUs7b0JBQzVELGVBQWUsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDMUIsWUFBWSxDQUFDLElBQUksQ0FBQyxDQUFDO29CQUNuQixPQUFPO0lBQ0gsb0JBQUEsT0FBTyxFQUFFLFFBQVE7SUFDakIsb0JBQUEsS0FBSyxFQUFFLFFBQVE7cUJBQ2xCLENBQUE7SUFDTCxhQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsRUFBRSxJQUFHOztJQUVWLGdCQUFBLFNBQVM7b0JBQ1QsZUFBZSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO29CQUMxQixZQUFZLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakIsZ0JBQUEsT0FBTyxJQUFJLENBQUM7aUJBQ2YsQ0FBQyxDQUFDLENBQUM7SUFDUixTQUFDLENBQUE7SUFHRCxRQUFBLE9BQU8sY0FBYyxDQUFJLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEYsS0FBQyxDQUFDO1FBRUYsT0FBTztZQUNILGlCQUFpQjtZQUNqQixxQkFBcUI7WUFDckIsdUJBQXVCO1lBQ3ZCLFlBQVk7WUFDWixjQUFjO1lBRWQsU0FBUztTQUNaLENBQUE7SUFDTDs7SUN6T0E7Ozs7Ozs7O0lBUUc7SUFDRyxTQUFVLGFBQWEsQ0FBd0IsSUFBaUMsRUFBQTtJQUNsRixJQUFBLE1BQU0sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxJQUFJLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQztRQUU3RCxrQkFBa0IsQ0FBQyxlQUFlLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQzs7UUFHekUsTUFBTSxPQUFPLEdBQUdTLEdBQVcsQ0FBaUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxLQUFJO1lBQ3pFLE1BQU0sT0FBTyxHQUFHLGVBQWUsR0FBRyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDaEQsUUFBQSxJQUFJLFNBQVM7SUFDVCxZQUFBLFNBQVMsR0FBRyxTQUFVLENBQUMsQ0FBQztJQUU1QixRQUFBLElBQUksQ0FBQztJQUNELFlBQUEsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRWpCLFFBQUEsT0FBTyxPQUFPLENBQUM7U0FDbEIsRUFBRSxFQUFFLENBQUMsQ0FBQzs7SUFHUCxJQUFBLE1BQU0sQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLEdBQUcsZUFBZSxDQUFXLE9BQU8sRUFBRSxVQUFVLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFDaEcsTUFBTSxrQkFBa0IsR0FBR0EsR0FBVyxDQUFtRCxDQUFDLEtBQUssS0FBSyxjQUFjLENBQUksRUFBRSxHQUFHLEVBQUUsVUFBVSxFQUFFLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7OztRQUl2SixPQUFPO1lBQ0gsa0JBQWtCO1lBQ2xCLFVBQVU7U0FDYixDQUFBO0lBQ0wsQ0FBQztJQUVELFNBQVMsY0FBYyxDQUFDLENBQWEsRUFBQTtJQUNqQyxJQUFBLENBQUMsRUFBRSxDQUFDO0lBQ1I7O2FDVGdCLGNBQWMsQ0FBb0IsRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUE0QixFQUFBO0lBRXZHLElBQUEsa0JBQWtCLENBQUMsZ0JBQWdCLEVBQUUsYUFBYSxFQUFFLFlBQVksQ0FBQyxDQUFDO0lBRWxFLElBQUEsTUFBTSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsR0FBRyxlQUFlLENBQXFCLFlBQXdELEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFckksSUFBQSxNQUFNLGlCQUFpQixHQUFHSixDQUFNLENBQXVDLFNBQVMsQ0FBQyxDQUFDO1FBRWxGLE1BQU0sZ0JBQWdCLEdBQUdJLEdBQVcsQ0FBQyxDQUFDLE9BQWlCLEVBQUUsVUFBZ0QsS0FBSTtJQUN6RyxRQUFBLElBQUksT0FBTyxFQUFFO0lBQ1QsWUFBQSxNQUFNLFFBQVEsR0FBR2dILGFBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN0QyxZQUFBLE1BQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxXQUFXLENBQUM7Z0JBRXBDLE1BQU0sWUFBWSxHQUFHLE1BQUs7b0JBQ3RCLElBQUksT0FBTyxDQUFDLFdBQVcsRUFBRTt3QkFDckIsTUFBTSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEdBQUksT0FBMEMsQ0FBQzt3QkFDN00sT0FBTyxDQUFDLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ3JLLGlCQUFBO0lBQ0wsYUFBQyxDQUFBO0lBR0QsWUFBQSxJQUFJLE1BQU0sS0FBSyxnQkFBZ0IsSUFBSSxNQUFNLENBQUMsRUFBRTtJQUN4QyxnQkFBQSxNQUFNLFFBQVEsR0FBRyxJQUFJLGNBQWMsQ0FBQyxDQUFDLFFBQVEsS0FBSSxFQUFHLFlBQVksRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO29CQUV2RSxRQUFRLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBRS9DLGdCQUFBLE9BQU8sTUFBTSxRQUFRLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDdEMsYUFBQTtJQUNJLGlCQUFBO0lBQ0QsZ0JBQUEsUUFBUSxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxZQUFZLEVBQUUsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztvQkFDckUsT0FBTyxNQUFNLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDckUsYUFBQTtJQUNKLFNBQUE7U0FDSixFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBRU4sSUFBQSxNQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsYUFBYSxDQUFJLEVBQUUsZUFBZSxFQUFFaEgsR0FBVyxDQUFDLENBQUMsQ0FBVyxLQUFLLGdCQUFnQixDQUFDLENBQUMsRUFBRSxhQUFhLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUUzSlQsQ0FBUyxDQUFDLE1BQUs7SUFDWCxRQUFBLElBQUksYUFBYSxFQUFFO0lBQ2YsWUFBQSxJQUFJLGlCQUFpQixDQUFDLE9BQU8sS0FBSyxhQUFhLEVBQUU7SUFDN0MsZ0JBQUEsZ0JBQWdCLENBQUMsVUFBVSxFQUFFLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQztJQUN2RCxTQUFBO0lBQ0wsS0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPO1lBQ0gsVUFBVTtZQUNWLE9BQU87SUFDUCxRQUFBLG1CQUFtQixFQUFFLGtCQUFrQjtTQUMxQyxDQUFBO0lBR0w7O0lDdkRBOzs7Ozs7Ozs7Ozs7Ozs7SUFlRztJQUNHLFNBQVUsZ0JBQWdCLENBQXNILE1BQVMsRUFBRSxJQUFlLEVBQUUsT0FBZ0MsRUFBRSxPQUFpRCxFQUFBOzs7OztJQU9qUSxJQUFBLElBQUksYUFBYSxHQUF5QixpQkFBaUIsQ0FBQyxPQUFPLEtBQUssTUFBSyxHQUFJLENBQUMsQ0FBa0IsQ0FBQztRQUNyRyxJQUFJLE9BQU8sSUFBSSxJQUFJO1lBQ2YsYUFBYSxHQUFHLElBQUksQ0FBQztRQUV6QkEsQ0FBUyxDQUFDLE1BQUs7SUFDWCxRQUFBLElBQUksYUFBYSxFQUFFO2dCQUNmLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBRXRELFlBQUEsT0FBTyxNQUFNLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ3pFLFNBQUE7U0FDSixFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQyxDQUFDO0lBQ3RDOzs7Ozs7SUMvRUEsSUFBTTBILGtCQUFrQixHQUFHLENBQ3pCLE9BRHlCLEVBRXpCLFFBRnlCLEVBR3pCLFVBSHlCLEVBSXpCLFNBSnlCLEVBS3pCLFFBTHlCLEVBTXpCLHNCQU55QixFQU96QixpQkFQeUIsRUFRekIsaUJBUnlCLEVBU3pCLGtEQVR5QixFQVV6QiwrQkFWeUIsRUFXekIsU0FYeUIsQ0FBM0IsQ0FBQTtJQWVBLElBQU1DLFNBQVMsR0FBRyxPQUFPQyxPQUFQLEtBQW1CLFdBQXJDLENBQUE7SUFFQSxJQUFNQyxPQUFPLEdBQUdGLFNBQVMsR0FDckIsWUFBWSxFQURTLEdBRXJCQyxPQUFPLENBQUN2TixTQUFSLENBQWtCd04sT0FBbEIsSUFDQUQsT0FBTyxDQUFDdk4sU0FBUixDQUFrQnlOLGlCQURsQixJQUVBRixPQUFPLENBQUN2TixTQUFSLENBQWtCME4scUJBSnRCLENBQUE7SUFNQSxJQUFNQyxXQUFXLEdBQ2YsQ0FBQ0wsU0FBRCxJQUFjQyxPQUFPLENBQUN2TixTQUFSLENBQWtCMk4sV0FBaEMsR0FDSSxVQUFDQyxPQUFELEVBQUE7SUFBQSxFQUFBLE9BQWFBLE9BQU8sQ0FBQ0QsV0FBUixFQUFiLENBQUE7SUFBQSxDQURKLEdBRUksVUFBQ0MsT0FBRCxFQUFBO01BQUEsT0FBYUEsT0FBTyxDQUFDQyxhQUFyQixDQUFBO0lBQUEsQ0FITixDQUFBOztJQWtLQSxJQUFNQyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFVaFYsSUFBVixFQUFnQjtJQUM5QixFQUFBLE9BQU9BLElBQUksQ0FBQ2lWLE9BQUwsS0FBaUIsT0FBeEIsQ0FBQTtJQUNELENBRkQsQ0FBQTs7SUFJQSxJQUFNQyxhQUFhLEdBQUcsU0FBaEJBLGFBQWdCLENBQVVsVixJQUFWLEVBQWdCO01BQ3BDLE9BQU9nVixPQUFPLENBQUNoVixJQUFELENBQVAsSUFBaUJBLElBQUksQ0FBQ0ksSUFBTCxLQUFjLFFBQXRDLENBQUE7SUFDRCxDQUZELENBQUE7O0lBSUEsSUFBTStVLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBVW5WLElBQVYsRUFBZ0I7TUFDM0MsSUFBTXNKLENBQUMsR0FDTHRKLElBQUksQ0FBQ2lWLE9BQUwsS0FBaUIsU0FBakIsSUFDQW5SLEtBQUssQ0FBQ29ELFNBQU4sQ0FBZ0IvSCxLQUFoQixDQUNHaVcsS0FESCxDQUNTcFYsSUFBSSxDQUFDSyxRQURkLENBRUdpQyxDQUFBQSxJQUZILENBRVEsVUFBQ1osS0FBRCxFQUFBO0lBQUEsSUFBQSxPQUFXQSxLQUFLLENBQUN1VCxPQUFOLEtBQWtCLFNBQTdCLENBQUE7SUFBQSxHQUZSLENBRkYsQ0FBQTtJQUtBLEVBQUEsT0FBTzNMLENBQVAsQ0FBQTtJQUNELENBUEQsQ0FBQTs7SUE0REEsSUFBTStMLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVVyVixJQUFWLEVBQWdCO0lBQ2pDLEVBQUEsSUFBMEJBLHFCQUFBQSxHQUFBQSxJQUFJLENBQUNzVixxQkFBTCxFQUExQjtJQUFRQyxNQUFBQSxLQUFSLHlCQUFRQSxLQUFSO1VBQWVDLE1BQWYsR0FBQSxxQkFBQSxDQUFlQSxNQUFmLENBQUE7O0lBQ0EsRUFBQSxPQUFPRCxLQUFLLEtBQUssQ0FBVixJQUFlQyxNQUFNLEtBQUssQ0FBakMsQ0FBQTtJQUNELENBSEQsQ0FBQTs7SUFJQSxJQUFNQyxRQUFRLEdBQUcsU0FBWEEsUUFBVyxDQUFVelYsSUFBVixFQUFpRCxJQUFBLEVBQUE7TUFBQSxJQUEvQjBWLFlBQStCLFFBQS9CQSxZQUErQjtVQUFqQkMsYUFBaUIsR0FBQSxJQUFBLENBQWpCQSxhQUFpQixDQUFBOztJQUNoRTtJQUNBO0lBQ0E7SUFDQTtJQUNBO01BQ0EsSUFBSUMsZ0JBQWdCLENBQUM1VixJQUFELENBQWhCLENBQXVCNlYsVUFBdkIsS0FBc0MsUUFBMUMsRUFBb0Q7SUFDbEQsSUFBQSxPQUFPLElBQVAsQ0FBQTtJQUNELEdBQUE7O01BRUQsSUFBTUMsZUFBZSxHQUFHcEIsT0FBTyxDQUFDL1QsSUFBUixDQUFhWCxJQUFiLEVBQW1CLCtCQUFuQixDQUF4QixDQUFBO01BQ0EsSUFBTStWLGdCQUFnQixHQUFHRCxlQUFlLEdBQUc5VixJQUFJLENBQUNnVyxhQUFSLEdBQXdCaFcsSUFBaEUsQ0FBQTs7TUFDQSxJQUFJMFUsT0FBTyxDQUFDL1QsSUFBUixDQUFhb1YsZ0JBQWIsRUFBK0IsdUJBQS9CLENBQUosRUFBNkQ7SUFDM0QsSUFBQSxPQUFPLElBQVAsQ0FBQTtJQUNELEdBZCtEO0lBaUJoRTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTs7O0lBQ0EsRUFBQSxJQUFNRSxZQUFZLEdBQUdwQixXQUFXLENBQUM3VSxJQUFELENBQVgsQ0FBa0JrVyxJQUF2QyxDQUFBO0lBQ0EsRUFBQSxJQUFNQyxjQUFjLEdBQ2xCLENBQUFGLFlBQVksS0FBQSxJQUFaLElBQUFBLFlBQVksS0FBQSxLQUFBLENBQVosR0FBQUEsS0FBQUEsQ0FBQUEsR0FBQUEsWUFBWSxDQUFFbEIsYUFBZCxDQUE0QnFCLFFBQTVCLENBQXFDSCxZQUFyQyxDQUFBLEtBQ0FqVyxJQUFJLENBQUMrVSxhQUFMLENBQW1CcUIsUUFBbkIsQ0FBNEJwVyxJQUE1QixDQUZGLENBQUE7O0lBSUEsRUFBQSxJQUFJLENBQUMwVixZQUFELElBQWlCQSxZQUFZLEtBQUssTUFBdEMsRUFBOEM7SUFDNUMsSUFBQSxJQUFJLE9BQU9DLGFBQVAsS0FBeUIsVUFBN0IsRUFBeUM7SUFDdkM7SUFDQTtVQUNBLElBQU1VLFlBQVksR0FBR3JXLElBQXJCLENBQUE7O0lBQ0EsTUFBQSxPQUFPQSxJQUFQLEVBQWE7SUFDWCxRQUFBLElBQU1nVyxhQUFhLEdBQUdoVyxJQUFJLENBQUNnVyxhQUEzQixDQUFBO0lBQ0EsUUFBQSxJQUFNTSxRQUFRLEdBQUd6QixXQUFXLENBQUM3VSxJQUFELENBQTVCLENBQUE7O0lBQ0EsUUFBQSxJQUNFZ1csYUFBYSxJQUNiLENBQUNBLGFBQWEsQ0FBQ08sVUFEZixJQUVBWixhQUFhLENBQUNLLGFBQUQsQ0FBYixLQUFpQyxJQUhuQztJQUlFLFVBQUE7SUFDQTtJQUNBO0lBQ0EsVUFBQSxPQUFPWCxVQUFVLENBQUNyVixJQUFELENBQWpCLENBQUE7SUFDRCxTQVJELE1BUU8sSUFBSUEsSUFBSSxDQUFDd1csWUFBVCxFQUF1QjtJQUM1QjtJQUNBeFcsVUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUN3VyxZQUFaLENBQUE7YUFGSyxNQUdBLElBQUksQ0FBQ1IsYUFBRCxJQUFrQk0sUUFBUSxLQUFLdFcsSUFBSSxDQUFDK1UsYUFBeEMsRUFBdUQ7SUFDNUQ7SUFDQS9VLFVBQUFBLElBQUksR0FBR3NXLFFBQVEsQ0FBQ0osSUFBaEIsQ0FBQTtJQUNELFNBSE0sTUFHQTtJQUNMO0lBQ0FsVyxVQUFBQSxJQUFJLEdBQUdnVyxhQUFQLENBQUE7SUFDRCxTQUFBO0lBQ0YsT0FBQTs7SUFFRGhXLE1BQUFBLElBQUksR0FBR3FXLFlBQVAsQ0FBQTtJQUNELEtBN0IyQztJQStCNUM7SUFDQTtJQUVBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7OztJQUVBLElBQUEsSUFBSUYsY0FBSixFQUFvQjtJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLE1BQUEsT0FBTyxDQUFDblcsSUFBSSxDQUFDeVcsY0FBTCxFQUFBLENBQXNCL1YsTUFBOUIsQ0FBQTtJQUNELEtBOUMyQztJQWlENUM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBOztJQUNELEdBN0RELE1BNkRPLElBQUlnVixZQUFZLEtBQUssZUFBckIsRUFBc0M7SUFDM0M7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUEsT0FBT0wsVUFBVSxDQUFDclYsSUFBRCxDQUFqQixDQUFBO0lBQ0QsR0ExRytEOzs7SUE2R2hFLEVBQUEsT0FBTyxLQUFQLENBQUE7SUFDRCxDQTlHRCxDQUFBO0lBaUhBO0lBQ0E7OztJQUNBLElBQU0wVyxzQkFBc0IsR0FBRyxTQUF6QkEsc0JBQXlCLENBQVUxVyxJQUFWLEVBQWdCO0lBQzdDLEVBQUEsSUFBSSxtQ0FBbUNzRixJQUFuQyxDQUF3Q3RGLElBQUksQ0FBQ2lWLE9BQTdDLENBQUosRUFBMkQ7SUFDekQsSUFBQSxJQUFJaFYsVUFBVSxHQUFHRCxJQUFJLENBQUNnVyxhQUF0QixDQUR5RDs7SUFHekQsSUFBQSxPQUFPL1YsVUFBUCxFQUFtQjtVQUNqQixJQUFJQSxVQUFVLENBQUNnVixPQUFYLEtBQXVCLFVBQXZCLElBQXFDaFYsVUFBVSxDQUFDMFcsUUFBcEQsRUFBOEQ7SUFDNUQ7SUFDQSxRQUFBLEtBQUssSUFBSW5YLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdTLFVBQVUsQ0FBQ0ksUUFBWCxDQUFvQkssTUFBeEMsRUFBZ0RsQixDQUFDLEVBQWpELEVBQXFEO2NBQ25ELElBQU1rQyxLQUFLLEdBQUd6QixVQUFVLENBQUNJLFFBQVgsQ0FBb0J1VyxJQUFwQixDQUF5QnBYLENBQXpCLENBQWQsQ0FEbUQ7O0lBR25ELFVBQUEsSUFBSWtDLEtBQUssQ0FBQ3VULE9BQU4sS0FBa0IsUUFBdEIsRUFBZ0M7SUFDOUI7SUFDQTtJQUNBLFlBQUEsT0FBT1AsT0FBTyxDQUFDL1QsSUFBUixDQUFhVixVQUFiLEVBQXlCLHNCQUF6QixDQUFBLEdBQ0gsSUFERyxHQUVILENBQUN5QixLQUFLLENBQUMwVSxRQUFOLENBQWVwVyxJQUFmLENBRkwsQ0FBQTtJQUdELFdBQUE7SUFDRixTQVoyRDs7O0lBYzVELFFBQUEsT0FBTyxJQUFQLENBQUE7SUFDRCxPQUFBOztJQUNEQyxNQUFBQSxVQUFVLEdBQUdBLFVBQVUsQ0FBQytWLGFBQXhCLENBQUE7SUFDRCxLQUFBO0lBQ0YsR0F2QjRDO0lBMEI3Qzs7O0lBQ0EsRUFBQSxPQUFPLEtBQVAsQ0FBQTtJQUNELENBNUJELENBQUE7O0lBOEJBLElBQU1hLCtCQUErQixHQUFHLFNBQWxDQSwrQkFBa0MsQ0FBVXpYLE9BQVYsRUFBbUJZLElBQW5CLEVBQXlCO0lBQy9ELEVBQUEsSUFDRUEsSUFBSSxDQUFDMlcsUUFBTCxJQUNBekIsYUFBYSxDQUFDbFYsSUFBRCxDQURiLElBRUF5VixRQUFRLENBQUN6VixJQUFELEVBQU9aLE9BQVAsQ0FGUjtNQUlBK1Ysb0JBQW9CLENBQUNuVixJQUFELENBSnBCLElBS0EwVyxzQkFBc0IsQ0FBQzFXLElBQUQsQ0FOeEIsRUFPRTtJQUNBLElBQUEsT0FBTyxLQUFQLENBQUE7SUFDRCxHQUFBOztJQUNELEVBQUEsT0FBTyxJQUFQLENBQUE7SUFDRCxDQVpELENBQUE7O0lBOEhBLElBQU04VywwQkFBMEIsa0JBQW1CdkMsa0JBQWtCLENBQ2xFd0MsTUFEZ0QsQ0FDekMsUUFEeUMsQ0FFaERDLENBQUFBLElBRmdELENBRTNDLEdBRjJDLENBQW5ELENBQUE7O0lBSU1DLElBQUFBLFdBQVcsR0FBRyxTQUFkQSxXQUFjLENBQVVqWCxJQUFWLEVBQWdCWixPQUFoQixFQUF5QjtJQUMzQ0EsRUFBQUEsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckIsQ0FBQTs7TUFDQSxJQUFJLENBQUNZLElBQUwsRUFBVztJQUNULElBQUEsTUFBTSxJQUFJa1gsS0FBSixDQUFVLGtCQUFWLENBQU4sQ0FBQTtJQUNELEdBQUE7O01BQ0QsSUFBSXhDLE9BQU8sQ0FBQy9ULElBQVIsQ0FBYVgsSUFBYixFQUFtQjhXLDBCQUFuQixDQUFtRCxLQUFBLEtBQXZELEVBQThEO0lBQzVELElBQUEsT0FBTyxLQUFQLENBQUE7SUFDRCxHQUFBOztJQUNELEVBQUEsT0FBT0QsK0JBQStCLENBQUN6WCxPQUFELEVBQVVZLElBQVYsQ0FBdEMsQ0FBQTtJQUNELENBQUE7Ozs7O0lDN2hCRCxDQUFBLENBQUMsVUFBVSxNQUFNLEVBQUUsT0FBTyxFQUFFO09BQ3FDLE9BQU8sRUFBRSxDQUU3RCxDQUFDO0lBQ2QsRUFBQyxDQUFDd0osY0FBSSxHQUFHLFlBQVksQ0FDckI7SUFDQSxHQUFFLElBQUksWUFBWSxHQUFHLFlBQVksRUFBRSxTQUFTLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsRUFBRSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLElBQUksVUFBVSxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDLFVBQVUsSUFBSSxLQUFLLENBQUMsQ0FBQyxVQUFVLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksT0FBTyxJQUFJLFVBQVUsRUFBRSxVQUFVLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsVUFBVSxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxVQUFVLFdBQVcsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLEVBQUUsSUFBSSxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksV0FBVyxFQUFFLGdCQUFnQixDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLE9BQU8sV0FBVyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQztBQUN0akI7T0FDRSxTQUFTLGVBQWUsQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsWUFBWSxXQUFXLENBQUMsRUFBRSxFQUFFLE1BQU0sSUFBSSxTQUFTLENBQUMsbUNBQW1DLENBQUMsQ0FBQyxFQUFFLEVBQUU7QUFDM0o7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsR0FBRSxDQUFDLFlBQVk7SUFDZjtJQUNBLEtBQUksSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7SUFDdkMsT0FBTSxPQUFPO1VBQ1I7QUFDTDtJQUNBO0lBQ0E7U0FDSSxJQUFJLEtBQUssR0FBRyxLQUFLLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztBQUN0QztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsS0FBSSxJQUFJLE9BQU8sR0FBRyxPQUFPLENBQUMsU0FBUyxDQUFDLE9BQU8sSUFBSSxPQUFPLENBQUMsU0FBUyxDQUFDLGlCQUFpQixDQUFDO0FBQ25GO0lBQ0E7SUFDQSxLQUFJLElBQUksd0JBQXdCLEdBQUcsQ0FBQyxTQUFTLEVBQUUsWUFBWSxFQUFFLHVCQUF1QixFQUFFLHdCQUF3QixFQUFFLDBCQUEwQixFQUFFLHdCQUF3QixFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsbUJBQW1CLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDeFA7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO1NBQ0ksSUFBSSxTQUFTLEdBQUcsWUFBWTtJQUNoQztJQUNBO0lBQ0E7SUFDQTtJQUNBLE9BQU0sU0FBUyxTQUFTLENBQUMsV0FBVyxFQUFFLFlBQVksRUFBRTtJQUNwRCxTQUFRLGVBQWUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDekM7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLGFBQWEsR0FBRyxZQUFZLENBQUM7QUFDMUM7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLFlBQVksR0FBRyxXQUFXLENBQUM7QUFDeEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLGFBQWEsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ3ZDO0lBQ0E7YUFDUSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLGFBQWEsQ0FBQyxFQUFFO0lBQzNEO0lBQ0EsV0FBVSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDaEYsVUFBUyxNQUFNO0lBQ2YsV0FBVSxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDO2NBQzlCO2FBQ0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsYUFBYSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0FBQzlEO0lBQ0E7YUFDUSxJQUFJLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3hEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7YUFDbkUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUNqRztBQUNQO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtBQUNBO0lBQ0EsT0FBTSxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUM7YUFDdkIsR0FBRyxFQUFFLFlBQVk7SUFDekIsU0FBUSxLQUFLLEVBQUUsU0FBUyxVQUFVLEdBQUc7SUFDckMsV0FBVSxJQUFJLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ3RDO0lBQ0EsV0FBVSxJQUFJLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDakMsYUFBWSxJQUFJLElBQUksQ0FBQyxnQkFBZ0IsS0FBSyxJQUFJLEVBQUU7SUFDaEQsZUFBYyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUM7SUFDbkYsY0FBYSxNQUFNO21CQUNMLElBQUksQ0FBQyxZQUFZLENBQUMsZUFBZSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2tCQUNsRDtnQkFDRjtBQUNYO2VBQ1UsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBVSxTQUFTLEVBQUU7aUJBQzlDLElBQUksQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUNwQyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ25CO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsV0FBVSxJQUFJLENBQUMsU0FBUyxtQkFBbUIsSUFBSSxDQUFDO0lBQ2hELFdBQVUsSUFBSSxDQUFDLFlBQVksbUJBQW1CLElBQUksQ0FBQztJQUNuRCxXQUFVLElBQUksQ0FBQyxhQUFhLG1CQUFtQixJQUFJLENBQUM7SUFDcEQsV0FBVSxJQUFJLENBQUMsYUFBYSxtQkFBbUIsSUFBSSxDQUFDO2NBQzNDO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSx5QkFBeUI7QUFDdEM7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVEsS0FBSyxFQUFFLFNBQVMsdUJBQXVCLENBQUMsU0FBUyxFQUFFO0lBQzNELFdBQVUsSUFBSSxNQUFNLEdBQUcsSUFBSSxDQUFDO0FBQzVCO0lBQ0EsV0FBVSxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsVUFBVSxJQUFJLEVBQUU7SUFDdEQsYUFBWSxPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0MsWUFBVyxDQUFDLENBQUM7QUFDYjtJQUNBLFdBQVUsSUFBSSxhQUFhLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQztBQUNyRDtlQUNVLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUNsRDtJQUNBLGFBQVksSUFBSSxJQUFJLEdBQUcsU0FBUyxDQUFDO0lBQ2pDO0lBQ0EsYUFBWSxJQUFJLElBQUksR0FBRyxTQUFTLENBQUM7aUJBQ3JCLE9BQU8sSUFBSSxFQUFFO21CQUNYLElBQUksSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsc0JBQXNCLEVBQUU7cUJBQ2pELElBQUksNkJBQTZCLElBQUksQ0FBQztJQUN0RCxpQkFBZ0IsTUFBTTtvQkFDUDtJQUNmLGVBQWMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7a0JBQ3hCO2lCQUNELElBQUksSUFBSSxFQUFFO0lBQ3RCLGVBQWMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7a0JBQ3BDO2dCQUNGO0lBQ1gsV0FBVSxJQUFJLFNBQVMsQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLEVBQUU7SUFDakQsYUFBWSxhQUFhLENBQUMsSUFBSSxFQUFFLENBQUM7SUFDakM7SUFDQTtJQUNBO0lBQ0EsYUFBWSxJQUFJLGFBQWEsS0FBSyxRQUFRLENBQUMsYUFBYSxFQUFFO0lBQzFELGVBQWMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztrQkFDdkI7Z0JBQ0Y7Y0FDRjtBQUNUO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQSxRQUFPLEVBQUU7YUFDRCxHQUFHLEVBQUUsWUFBWTtJQUN6QixTQUFRLEtBQUssRUFBRSxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUU7ZUFDL0IsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDbkQsYUFBWSxPQUFPO2dCQUNSO0lBQ1gsV0FBVSxJQUFJLE9BQU8sOEJBQThCLElBQUksQ0FBQztBQUN4RDtJQUNBO0lBQ0E7SUFDQSxXQUFVLElBQUksT0FBTyxLQUFLLElBQUksQ0FBQyxZQUFZLElBQUksT0FBTyxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsRUFBRTtJQUM5RSxhQUFZLElBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQy9CO0FBQ1g7SUFDQSxXQUFVLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsd0JBQXdCLENBQUMsSUFBSSxPQUFPLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQ25HLGFBQVksSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDM0I7Y0FDRjtBQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxhQUFhO0lBQzFCLFNBQVEsS0FBSyxFQUFFLFNBQVMsV0FBVyxDQUFDLElBQUksRUFBRTtJQUMxQyxXQUFVLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsUUFBUSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztlQUN4RCxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztjQUNuQztBQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxlQUFlO0lBQzVCLFNBQVEsS0FBSyxFQUFFLFNBQVMsYUFBYSxDQUFDLElBQUksRUFBRTtJQUM1QyxXQUFVLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztlQUMxRCxJQUFJLFNBQVMsRUFBRTtpQkFDYixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN6QztjQUNGO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLGtCQUFrQjtJQUMvQixTQUFRLEtBQUssRUFBRSxTQUFTLGdCQUFnQixDQUFDLFNBQVMsRUFBRTtJQUNwRCxXQUFVLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQztBQUM1QjtJQUNBLFdBQVUsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLFVBQVUsSUFBSSxFQUFFO0lBQ3RELGFBQVksT0FBTyxNQUFNLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlDLFlBQVcsQ0FBQyxDQUFDO2NBQ0o7QUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQSxRQUFPLEVBQUU7YUFDRCxHQUFHLEVBQUUsaUJBQWlCO0lBQzlCLFNBQVEsS0FBSyxFQUFFLFNBQVMsZUFBZSxDQUFDLElBQUksRUFBRTtlQUNwQyxJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuRTtJQUNBO0lBQ0E7ZUFDVSxJQUFJLENBQUMsWUFBWSxFQUFFO2lCQUNqQixJQUFJLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ3hDLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDdEQ7QUFDWDtlQUNVLFlBQVksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLFVBQVUsY0FBYyxFQUFFO2lCQUMxRCxJQUFJLENBQUMsV0FBVyxDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDdkMsRUFBRSxJQUFJLENBQUMsQ0FBQztjQUNWO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQSxRQUFPLEVBQUU7YUFDRCxHQUFHLEVBQUUsYUFBYTthQUNsQixLQUFLLEVBQUUsU0FBUyxXQUFXLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtJQUNuRCxXQUFVLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBVSxNQUFNLEVBQUU7SUFDNUMsYUFBWSxJQUFJLE1BQU0sOEJBQThCLE1BQU0sQ0FBQyxNQUFNLENBQUM7SUFDbEUsYUFBWSxJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssV0FBVyxFQUFFO0lBQzdDO0lBQ0EsZUFBYyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxJQUFJLEVBQUU7SUFDcEUsaUJBQWdCLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDcEMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUN2QjtJQUNBO0lBQ0EsZUFBYyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBVSxJQUFJLEVBQUU7SUFDdEUsaUJBQWdCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBQztvQkFDN0IsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUN2QixjQUFhLE1BQU0sSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFlBQVksRUFBRTtJQUNyRCxlQUFjLElBQUksTUFBTSxDQUFDLGFBQWEsS0FBSyxVQUFVLEVBQUU7SUFDdkQ7SUFDQSxpQkFBZ0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDMUIsTUFBTSxJQUFJLE1BQU0sS0FBSyxJQUFJLENBQUMsWUFBWSxJQUFJLE1BQU0sQ0FBQyxhQUFhLEtBQUssT0FBTyxJQUFJLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDM0g7SUFDQTtJQUNBLGlCQUFnQixJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sQ0FBQyxDQUFDO3FCQUM3QixJQUFJLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQztxQkFDM0QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsVUFBVSxXQUFXLEVBQUU7dUJBQ2hELElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEVBQUU7eUJBQ3JDLFlBQVksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDO3dCQUM1QztJQUNuQixrQkFBaUIsQ0FBQyxDQUFDO29CQUNKO2tCQUNGO2dCQUNGLEVBQUUsSUFBSSxDQUFDLENBQUM7Y0FDVjtJQUNULFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxjQUFjO0lBQzNCLFNBQVEsR0FBRyxFQUFFLFNBQVMsR0FBRyxHQUFHO2VBQ2xCLE9BQU8sSUFBSSxHQUFHLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2NBQ3BDO0FBQ1Q7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLG9CQUFvQjtJQUNqQyxTQUFRLEdBQUcsRUFBRSxTQUFTLEdBQUcsR0FBRztJQUM1QixXQUFVLE9BQU8sSUFBSSxDQUFDLGdCQUFnQixLQUFLLElBQUksQ0FBQztjQUN2QztBQUNUO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxpQkFBaUI7SUFDOUIsU0FBUSxHQUFHLEVBQUUsU0FBUyxHQUFHLENBQUMsVUFBVSxFQUFFO0lBQ3RDLFdBQVUsSUFBSSxDQUFDLGdCQUFnQixHQUFHLFVBQVUsQ0FBQztjQUNwQztBQUNUO0lBQ0E7SUFDQTtJQUNBLFNBQVEsR0FBRyxFQUFFLFNBQVMsR0FBRyxHQUFHO0lBQzVCLFdBQVUsT0FBTyxJQUFJLENBQUMsZ0JBQWdCLENBQUM7Y0FDOUI7WUFDRixDQUFDLENBQUMsQ0FBQztBQUNWO1dBQ00sT0FBTyxTQUFTLENBQUM7SUFDdkIsTUFBSyxFQUFFLENBQUM7QUFDUjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtBQUNBO1NBQ0ksSUFBSSxTQUFTLEdBQUcsWUFBWTtJQUNoQztJQUNBO0lBQ0E7SUFDQTtJQUNBLE9BQU0sU0FBUyxTQUFTLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRTtJQUMxQyxTQUFRLGVBQWUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7QUFDekM7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7QUFDMUI7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLG9CQUFvQixHQUFHLEtBQUssQ0FBQztBQUMxQztJQUNBO0lBQ0E7SUFDQTtJQUNBO2FBQ1EsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7QUFDaEQ7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLGNBQWMsR0FBRyxJQUFJLENBQUM7QUFDbkM7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLFVBQVUsR0FBRyxLQUFLLENBQUM7QUFDaEM7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLGdCQUFnQixFQUFFLENBQUM7WUFDekI7QUFDUDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7QUFDQTtJQUNBLE9BQU0sWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDO2FBQ3ZCLEdBQUcsRUFBRSxZQUFZO0lBQ3pCLFNBQVEsS0FBSyxFQUFFLFNBQVMsVUFBVSxHQUFHO0lBQ3JDLFdBQVUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7QUFDbkM7SUFDQSxXQUFVLElBQUksSUFBSSxDQUFDLEtBQUssSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsWUFBWSxFQUFFO0lBQ3ZFLGFBQVksSUFBSSxPQUFPLDhCQUE4QixJQUFJLENBQUMsS0FBSyxDQUFDO0lBQ2hFLGFBQVksSUFBSSxJQUFJLENBQUMsY0FBYyxLQUFLLElBQUksRUFBRTttQkFDaEMsT0FBTyxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQ3BFLGNBQWEsTUFBTTtJQUNuQixlQUFjLE9BQU8sQ0FBQyxlQUFlLENBQUMsVUFBVSxDQUFDLENBQUM7a0JBQ3JDO0FBQ2I7SUFDQTtJQUNBLGFBQVksSUFBSSxJQUFJLENBQUMsb0JBQW9CLEVBQUU7SUFDM0MsZUFBYyxPQUFPLE9BQU8sQ0FBQyxLQUFLLENBQUM7a0JBQ3RCO2dCQUNGO0FBQ1g7SUFDQTtJQUNBLFdBQVUsSUFBSSxDQUFDLEtBQUssbUJBQW1CLElBQUksQ0FBQztJQUM1QyxXQUFVLElBQUksQ0FBQyxXQUFXLG1CQUFtQixJQUFJLENBQUM7SUFDbEQsV0FBVSxJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQztjQUN4QjtBQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxtQkFBbUI7QUFDaEM7QUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVEsS0FBSyxFQUFFLFNBQVMsaUJBQWlCLEdBQUc7SUFDNUMsV0FBVSxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUU7SUFDOUIsYUFBWSxNQUFNLElBQUksS0FBSyxDQUFDLHNDQUFzQyxDQUFDLENBQUM7Z0JBQ3pEO2NBQ0Y7QUFDVDtJQUNBO0FBQ0E7SUFDQSxRQUFPLEVBQUU7YUFDRCxHQUFHLEVBQUUsa0JBQWtCO0FBQy9CO0FBQ0E7SUFDQTtJQUNBLFNBQVEsS0FBSyxFQUFFLFNBQVMsZ0JBQWdCLEdBQUc7ZUFDakMsSUFBSSxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsWUFBWSxFQUFFO0lBQ3hELGFBQVksT0FBTztnQkFDUjtJQUNYLFdBQVUsSUFBSSxPQUFPLDhCQUE4QixJQUFJLENBQUMsSUFBSSxDQUFDO2VBQ25ELElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsd0JBQXdCLENBQUMsRUFBRTtpQkFDbkQsZ0NBQWdDLE9BQU8sQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLGdCQUFnQixFQUFFO0lBQzlGLGVBQWMsT0FBTztrQkFDUjtBQUNiO0lBQ0EsYUFBWSxJQUFJLE9BQU8sQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUU7SUFDbEQsZUFBYyxJQUFJLENBQUMsY0FBYyw4QkFBOEIsT0FBTyxDQUFDLFFBQVEsQ0FBQztrQkFDbkU7aUJBQ0QsT0FBTyxDQUFDLFlBQVksQ0FBQyxVQUFVLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQ3ZDLElBQUksT0FBTyxDQUFDLFFBQVEsS0FBSyxJQUFJLENBQUMsWUFBWSxFQUFFO0lBQ3hELGVBQWMsT0FBTyxDQUFDLEtBQUssR0FBRyxZQUFZLEVBQUUsQ0FBQztJQUM3QyxlQUFjLElBQUksQ0FBQyxvQkFBb0IsR0FBRyxJQUFJLENBQUM7a0JBQ2xDO2dCQUNGLE1BQU0sSUFBSSxPQUFPLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFO0lBQ3ZELGFBQVksSUFBSSxDQUFDLGNBQWMsOEJBQThCLE9BQU8sQ0FBQyxRQUFRLENBQUM7SUFDOUUsYUFBWSxPQUFPLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxDQUFDO2dCQUNyQztjQUNGO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLGNBQWM7SUFDM0IsU0FBUSxLQUFLLEVBQUUsU0FBUyxZQUFZLENBQUMsU0FBUyxFQUFFO0lBQ2hELFdBQVUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7ZUFDekIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7Y0FDakM7QUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLGlCQUFpQjtJQUM5QixTQUFRLEtBQUssRUFBRSxTQUFTLGVBQWUsQ0FBQyxTQUFTLEVBQUU7SUFDbkQsV0FBVSxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztlQUN6QixJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2VBQ3RDLElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO0lBQzNDLGFBQVksSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO2dCQUNuQjtjQUNGO0lBQ1QsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLFdBQVc7SUFDeEIsU0FBUSxHQUFHLEVBQUUsU0FBUyxHQUFHLEdBQUc7ZUFDbEIsaUNBQWlDLElBQUksQ0FBQyxVQUFVO2lCQUM5QztjQUNIO0lBQ1QsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLGtCQUFrQjtJQUMvQixTQUFRLEdBQUcsRUFBRSxTQUFTLEdBQUcsR0FBRztJQUM1QixXQUFVLE9BQU8sSUFBSSxDQUFDLGNBQWMsS0FBSyxJQUFJLENBQUM7Y0FDckM7QUFDVDtJQUNBO0FBQ0E7SUFDQSxRQUFPLEVBQUU7YUFDRCxHQUFHLEVBQUUsTUFBTTtJQUNuQixTQUFRLEdBQUcsRUFBRSxTQUFTLEdBQUcsR0FBRztJQUM1QixXQUFVLElBQUksQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO0lBQ25DLFdBQVUsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO2NBQ25CO0FBQ1Q7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLGVBQWU7SUFDNUIsU0FBUSxHQUFHLEVBQUUsU0FBUyxHQUFHLENBQUMsUUFBUSxFQUFFO0lBQ3BDLFdBQVUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDbkMsV0FBVSxJQUFJLENBQUMsY0FBYyxHQUFHLFFBQVEsQ0FBQztjQUNoQztBQUNUO0lBQ0E7SUFDQTtJQUNBLFNBQVEsR0FBRyxFQUFFLFNBQVMsR0FBRyxHQUFHO0lBQzVCLFdBQVUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDbkMsV0FBVSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7Y0FDNUI7WUFDRixDQUFDLENBQUMsQ0FBQztBQUNWO1dBQ00sT0FBTyxTQUFTLENBQUM7SUFDdkIsTUFBSyxFQUFFLENBQUM7QUFDUjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0FBQ0E7U0FDSSxJQUFJLFlBQVksR0FBRyxZQUFZO0lBQ25DO0lBQ0E7SUFDQTtJQUNBLE9BQU0sU0FBUyxZQUFZLENBQUMsUUFBUSxFQUFFO0lBQ3RDLFNBQVEsZUFBZSxDQUFDLElBQUksRUFBRSxZQUFZLENBQUMsQ0FBQztBQUM1QzthQUNRLElBQUksQ0FBQyxRQUFRLEVBQUU7SUFDdkIsV0FBVSxNQUFNLElBQUksS0FBSyxDQUFDLG1FQUFtRSxDQUFDLENBQUM7Y0FDdEY7QUFDVDtJQUNBO0lBQ0EsU0FBUSxJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQztBQUNsQztJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUSxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksR0FBRyxFQUFFLENBQUM7QUFDdkM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVEsSUFBSSxDQUFDLFdBQVcsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO0FBQ3JDO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFRLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQzlFO0lBQ0E7SUFDQSxTQUFRLGFBQWEsQ0FBQyxRQUFRLENBQUMsSUFBSSxJQUFJLFFBQVEsQ0FBQyxJQUFJLElBQUksUUFBUSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ2xGO0lBQ0E7SUFDQSxTQUFRLElBQUksUUFBUSxDQUFDLFVBQVUsS0FBSyxTQUFTLEVBQUU7SUFDL0MsV0FBVSxRQUFRLENBQUMsZ0JBQWdCLENBQUMsa0JBQWtCLEVBQUUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzNGLFVBQVMsTUFBTTtJQUNmLFdBQVUsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7Y0FDMUI7WUFDRjtBQUNQO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0FBQ0E7SUFDQSxPQUFNLFlBQVksQ0FBQyxZQUFZLEVBQUUsQ0FBQzthQUMxQixHQUFHLEVBQUUsVUFBVTthQUNmLEtBQUssRUFBRSxTQUFTLFFBQVEsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFO2VBQ3BDLElBQUksS0FBSyxFQUFFO2lCQUNULElBQUksSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUU7SUFDNUM7SUFDQSxlQUFjLE9BQU87a0JBQ1I7QUFDYjtpQkFDWSxJQUFJLFNBQVMsR0FBRyxJQUFJLFNBQVMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7aUJBQzFDLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO2lCQUMvQixJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDbEQ7SUFDQTtJQUNBLGFBQVksSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRTtJQUNyRCxlQUFjLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUM7bUJBQzdCLE9BQU8sTUFBTSxFQUFFO0lBQzdCLGlCQUFnQixJQUFJLE1BQU0sQ0FBQyxRQUFRLEtBQUssRUFBRSxFQUFFO0lBQzVDLG1CQUFrQixhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7c0JBQ3ZCO0lBQ2pCLGlCQUFnQixNQUFNLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQztvQkFDNUI7a0JBQ0Y7SUFDYixZQUFXLE1BQU07aUJBQ0wsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQzdDO0lBQ0EsZUFBYyxPQUFPO2tCQUNSO0FBQ2I7aUJBQ1ksSUFBSSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEQsYUFBWSxVQUFVLENBQUMsVUFBVSxFQUFFLENBQUM7aUJBQ3hCLElBQUksQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDN0MsYUFBWSxJQUFJLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2dCQUMvQjtjQUNGO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0FBQ0E7SUFDQSxRQUFPLEVBQUU7YUFDRCxHQUFHLEVBQUUsY0FBYztJQUMzQixTQUFRLEtBQUssRUFBRSxTQUFTLFlBQVksQ0FBQyxPQUFPLEVBQUU7ZUFDcEMsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztjQUN0QztBQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLFVBQVU7YUFDZixLQUFLLEVBQUUsU0FBUyxRQUFRLENBQUMsSUFBSSxFQUFFLFNBQVMsRUFBRTtlQUN4QyxJQUFJLFNBQVMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxXQUFVLElBQUksU0FBUyxLQUFLLFNBQVMsRUFBRTtJQUN2QztJQUNBLGFBQVksU0FBUyxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM5QyxZQUFXLE1BQU07aUJBQ0wsU0FBUyxHQUFHLElBQUksU0FBUyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztnQkFDNUM7QUFDWDtlQUNVLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQztBQUNsRDtlQUNVLE9BQU8sU0FBUyxDQUFDO2NBQ2xCO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxZQUFZO2FBQ2pCLEtBQUssRUFBRSxTQUFTLFVBQVUsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFO2VBQzFDLElBQUksU0FBUyxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2VBQzdDLElBQUksQ0FBQyxTQUFTLEVBQUU7aUJBQ2QsT0FBTyxJQUFJLENBQUM7Z0JBQ2I7QUFDWDtJQUNBLFdBQVUsU0FBUyxDQUFDLGVBQWUsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMvQyxXQUFVLElBQUksU0FBUyxDQUFDLFNBQVMsRUFBRTtpQkFDdkIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDcEM7QUFDWDtlQUNVLE9BQU8sU0FBUyxDQUFDO2NBQ2xCO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7QUFDQTtJQUNBLFFBQU8sRUFBRTthQUNELEdBQUcsRUFBRSxtQkFBbUI7SUFDaEMsU0FBUSxLQUFLLEVBQUUsU0FBUyxpQkFBaUIsR0FBRztJQUM1QztJQUNBLFdBQVUsSUFBSSxhQUFhLEdBQUcsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7SUFDckYsV0FBVSxhQUFhLENBQUMsT0FBTyxDQUFDLFVBQVUsWUFBWSxFQUFFO2lCQUM1QyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQztnQkFDbkMsRUFBRSxJQUFJLENBQUMsQ0FBQztBQUNuQjtJQUNBO0lBQ0EsV0FBVSxJQUFJLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsU0FBUyxDQUFDLGVBQWUsRUFBRSxFQUFFLFVBQVUsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztjQUNySTtBQUNUO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtBQUNBO0lBQ0EsUUFBTyxFQUFFO2FBQ0QsR0FBRyxFQUFFLGdCQUFnQjthQUNyQixLQUFLLEVBQUUsU0FBUyxjQUFjLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRTtJQUN0RCxXQUFVLElBQUksS0FBSyxHQUFHLElBQUksQ0FBQztJQUMzQixXQUFVLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBVSxNQUFNLEVBQUU7aUJBQ2hDLFFBQVEsTUFBTSxDQUFDLElBQUk7SUFDL0IsZUFBYyxLQUFLLFdBQVc7SUFDOUIsaUJBQWdCLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxVQUFVLElBQUksRUFBRTt1QkFDcEQsSUFBSSxJQUFJLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDM0QscUJBQW9CLE9BQU87d0JBQ1I7SUFDbkIsbUJBQWtCLElBQUksYUFBYSxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7dUJBQ2pFLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLEVBQUU7SUFDckQscUJBQW9CLGFBQWEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7d0JBQzdCO0lBQ25CLG1CQUFrQixhQUFhLENBQUMsT0FBTyxDQUFDLFVBQVUsWUFBWSxFQUFFO3lCQUM1QyxJQUFJLENBQUMsUUFBUSxDQUFDLFlBQVksRUFBRSxJQUFJLENBQUMsQ0FBQzt3QkFDbkMsRUFBRSxLQUFLLENBQUMsQ0FBQztzQkFDWCxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzFCLGlCQUFnQixNQUFNO0lBQ3RCLGVBQWMsS0FBSyxZQUFZO0lBQy9CLGlCQUFnQixJQUFJLE1BQU0sQ0FBQyxhQUFhLEtBQUssT0FBTyxFQUFFO0lBQ3RELG1CQUFrQixPQUFPO3NCQUNSO0lBQ2pCLGlCQUFnQixJQUFJLE1BQU0sOEJBQThCLE1BQU0sQ0FBQyxNQUFNLENBQUM7cUJBQ3RELElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7cUJBQ3pDLEtBQUssQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQzlDLGlCQUFnQixNQUFNO2tCQUNUO2dCQUNGLEVBQUUsSUFBSSxDQUFDLENBQUM7Y0FDVjtZQUNGLENBQUMsQ0FBQyxDQUFDO0FBQ1Y7V0FDTSxPQUFPLFlBQVksQ0FBQztJQUMxQixNQUFLLEVBQUUsQ0FBQztBQUNSO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7QUFDQTtBQUNBO1NBQ0ksU0FBUyxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsUUFBUSxFQUFFLGtCQUFrQixFQUFFO1dBQzVELElBQUksSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsWUFBWSxFQUFFO0lBQzlDLFNBQVEsSUFBSSxPQUFPLDhCQUE4QixJQUFJLENBQUM7YUFDOUMsSUFBSSxRQUFRLEVBQUU7SUFDdEIsV0FBVSxRQUFRLENBQUMsT0FBTyxDQUFDLENBQUM7Y0FDbkI7QUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUSxJQUFJLFVBQVUsOEJBQThCLE9BQU8sQ0FBQyxVQUFVLENBQUM7YUFDL0QsSUFBSSxVQUFVLEVBQUU7ZUFDZCxnQkFBZ0IsQ0FBQyxVQUFVLEVBQUUsUUFBb0IsQ0FBQyxDQUFDO0lBQzdELFdBQVUsT0FBTztjQUNSO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFRLElBQUksT0FBTyxDQUFDLFNBQVMsSUFBSSxTQUFTLEVBQUU7SUFDNUMsV0FBVSxJQUFJLE9BQU8scUNBQXFDLE9BQU8sQ0FBQztJQUNsRTtJQUNBLFdBQVUsSUFBSSxnQkFBZ0IsR0FBRyxPQUFPLENBQUMsbUJBQW1CLEdBQUcsT0FBTyxDQUFDLG1CQUFtQixFQUFFLEdBQUcsRUFBRSxDQUFDO0lBQ2xHLFdBQVUsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtpQkFDaEQsZ0JBQWdCLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLEVBQUUsUUFBNEIsQ0FBQyxDQUFDO2dCQUNyRTtJQUNYLFdBQVUsT0FBTztjQUNSO0FBQ1Q7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFRLElBQUksT0FBTyxDQUFDLFNBQVMsSUFBSSxNQUFNLEVBQUU7SUFDekMsV0FBVSxJQUFJLElBQUksa0NBQWtDLE9BQU8sQ0FBQztJQUM1RDtJQUNBLFdBQVUsSUFBSSxpQkFBaUIsR0FBRyxJQUFJLENBQUMsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDbEcsV0FBVSxLQUFLLElBQUksRUFBRSxHQUFHLENBQUMsRUFBRSxFQUFFLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxFQUFFLEVBQUUsRUFBRSxFQUFFO2lCQUNwRCxnQkFBZ0IsQ0FBQyxpQkFBaUIsQ0FBQyxFQUFFLENBQUMsRUFBRSxRQUE0QixDQUFDLENBQUM7Z0JBQ3ZFO0lBQ1gsV0FBVSxPQUFPO2NBQ1I7WUFDRjtBQUNQO0lBQ0E7SUFDQTtJQUNBLE9BQU0sSUFBSSxLQUFLLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUNsQyxPQUFNLE9BQU8sS0FBSyxJQUFJLElBQUksRUFBRTthQUNwQixnQkFBZ0IsQ0FBQyxLQUFLLEVBQUUsUUFBNEIsQ0FBQyxDQUFDO0lBQzlELFNBQVEsS0FBSyxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7WUFDM0I7VUFDRjtBQUNMO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxLQUFJLFNBQVMsYUFBYSxDQUFDLElBQUksRUFBRTtJQUNqQyxPQUFNLElBQUksSUFBSSxDQUFDLGFBQWEsQ0FBQyxxQ0FBcUMsQ0FBQyxFQUFFO0lBQ3JFLFNBQVEsT0FBTztZQUNSO1dBQ0QsSUFBSSxLQUFLLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQztXQUM1QyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksRUFBRSxhQUFhLENBQUMsQ0FBQztXQUN4QyxLQUFLLENBQUMsV0FBVyxHQUFHLElBQUksR0FBRyxhQUFhLEdBQUcsMkJBQTJCLEdBQUcsc0JBQXNCLEdBQUcsS0FBSyxHQUFHLElBQUksR0FBRyx3QkFBd0IsR0FBRyxnQ0FBZ0MsR0FBRyw2QkFBNkIsR0FBRyw0QkFBNEIsR0FBRyx3QkFBd0IsR0FBRyxLQUFLLENBQUM7SUFDclIsT0FBTSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO1VBQ3pCO0FBQ0w7U0FDSSxJQUFJLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDeEQ7V0FDTSxJQUFJLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztBQUNwRDtXQUNNLE1BQU0sQ0FBQyxjQUFjLENBQUMsV0FBVyxDQUFDLFNBQVMsRUFBRSxPQUFPLEVBQUU7YUFDcEQsVUFBVSxFQUFFLElBQUk7SUFDeEI7SUFDQSxTQUFRLEdBQUcsRUFBRSxTQUFTLEdBQUcsR0FBRztJQUM1QixXQUFVLE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsQ0FBQztjQUNuQztJQUNUO0lBQ0EsU0FBUSxHQUFHLEVBQUUsU0FBUyxHQUFHLENBQUMsS0FBSyxFQUFFO2VBQ3ZCLFlBQVksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxDQUFDO2NBQ3BDO0lBQ1QsUUFBTyxDQUFDLENBQUM7VUFDSjtJQUNMLElBQUcsR0FBRyxDQUFDO0FBQ1A7SUFDQSxFQUFDLEVBQUUsRUFBQTs7O0lDdjBCSDs7Ozs7Ozs7Ozs7Ozs7O0lBZUc7SUE2Q0gsQ0FBQyxNQUFLOzs7SUFFSixJQUFBLE1BQU0saUJBQWlCLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFDbkMsSUFBQSxNQUFNLHFCQUFxQixHQUFHLE1BQU0sRUFBRSxDQUFDO0lBQ3ZDLElBQUEsTUFBTSxhQUFhLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFDL0IsSUFBQSxNQUFNLGtCQUFrQixHQUFHLE1BQU0sRUFBRSxDQUFDO0lBQ3BDLElBQUEsTUFBTSxTQUFTLEdBQUcsTUFBTSxFQUFFLENBQUM7O0lBRzNCLElBQUEsTUFBTSxXQUFXLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFDN0IsSUFBQSxNQUFNLG1CQUFtQixHQUFHLE1BQU0sRUFBRSxDQUFDO0lBQ3JDLElBQUEsTUFBTSxjQUFjLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFDaEMsSUFBQSxNQUFNLHVCQUF1QixHQUFHLE1BQU0sRUFBRSxDQUFDO0lBQ3pDLElBQUEsTUFBTSxXQUFXLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFDN0IsSUFBQSxNQUFNLHVCQUF1QixHQUFHLE1BQU0sRUFBRSxDQUFDO0lBQ3pDLElBQUEsTUFBTSxZQUFZLEdBQUcsTUFBTSxFQUFFLENBQUM7SUFDOUIsSUFBQSxNQUFNLGdCQUFnQixHQUFHLE1BQU0sRUFBRSxDQUFDO0lBc0JsQyxJQUFBLE1BQU0sb0JBQW9CLENBQUE7SUFBMUIsUUFBQSxXQUFBLEdBQUE7SUFDRTs7SUFFRztnQkFDSSxJQUFtQixDQUFBLEVBQUEsQ0FBQSxHQUE0QixFQUFFLENBQUM7SUFFekQ7Ozs7O0lBS0c7Z0JBQ0ksSUFBZSxDQUFBLEVBQUEsQ0FBQSxHQUF1QixFQUFFLENBQUM7SUFFaEQ7OztJQUdHO0lBQ0ksWUFBQSxJQUFBLENBQUEsRUFBQSxDQUF1QixHQUFHLElBQUksR0FBRyxFQUF5QixDQUFDO2FBNlRuRTtZQTNUQyxVQUFVLEdBQUE7O2dCQUVSLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDOzs7OztnQkFLbkQsTUFBTSxRQUFRLEdBQUcsSUFJaEIsQ0FBQztJQUNGLFlBQUEsUUFBUSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ25DLFlBQUEsUUFBUSxDQUFDLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBQztJQUMvQixZQUFBLFFBQVEsQ0FBQyxxQkFBcUIsQ0FBQyxHQUFHLElBQUksQ0FBQzthQUN4QztJQUVELFFBQUEsSUFBSSxHQUFHLEdBQUE7SUFDTCxZQUFBLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO2dCQUN0QyxPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQzthQUN4QztJQUVELFFBQUEsSUFBSSxDQUFDLE9BQW9CLEVBQUE7Z0JBQ3ZCLElBQUksQ0FBQyxPQUFPLElBQUksT0FBTyxLQUFLLElBQUksQ0FBQyxHQUFHLEVBQUU7b0JBQ3BDLE9BQU87SUFDUixhQUFBOztJQUVELFlBQUEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNyQixZQUFBLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDM0IsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxDQUFDO2FBQ3ZDO0lBRUQsUUFBQSxNQUFNLENBQUMsT0FBb0IsRUFBQTtnQkFDekIsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELFlBQUEsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7SUFDWixnQkFBQSxPQUFPLEtBQUssQ0FBQztJQUNkLGFBQUE7Z0JBQ0QsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQzs7Z0JBRXJDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLE1BQU0sRUFBRTtvQkFDeEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM3QixhQUFBO0lBQ0QsWUFBQSxPQUFPLElBQUksQ0FBQzthQUNiO1lBRUQsR0FBRyxHQUFBO0lBQ0QsWUFBQSxNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ3JCLFlBQUEsR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDeEIsWUFBQSxPQUFPLEdBQUcsQ0FBQzthQUNaO0lBRUQsUUFBQSxHQUFHLENBQUMsT0FBb0IsRUFBQTtJQUN0QixZQUFBLE9BQU8sSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO2FBQ3hEO0lBRUQ7OztJQUdHO1lBQ0ksRUEzRUMsRUFBQSxHQUFBLGlCQUFpQixPQVFqQixhQUFhLEVBQUEsRUFBQSxHQU1iLHFCQUFxQixFQTZEckIsV0FBVyxFQUFDLENBQUMsTUFBa0MsRUFBQTtJQUNyRCxZQUFBLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO0lBQ2hELFlBQUEsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDOztnQkFFdkMsSUFBSSxDQUFDLE1BQU0sRUFBRTtJQUNYLGdCQUFBLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDO29CQUMxQyxXQUFXLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDcEIsZ0JBQUEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQkFDekIsT0FBTztJQUNSLGFBQUE7Z0JBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxDQUFDOztJQUU3QyxZQUFBLElBQUksVUFBVSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsVUFBVSxLQUFLLFFBQVEsQ0FBQyxJQUFJLEVBQUU7SUFDbEUsZ0JBQUEsTUFBTSxLQUFLLENBQUMsb0RBQW9ELENBQUMsQ0FBQztJQUNuRSxhQUFBOzs7SUFHRCxZQUFBLElBQUksQ0FBQyxhQUFhLENBQUMsR0FBRyxVQUFxQyxDQUFDO2dCQUU1RCxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQzs7SUFHckQsWUFBQSxJQUFJLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRTtvQkFDdEIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsV0FBVyxDQUFDLENBQUM7b0JBQ3RELE9BQU87SUFDUixhQUFBO0lBRUQsWUFBQSxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUM5QixZQUFBLElBQUksQ0FBQyxHQUFHLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDOztJQUU5QixZQUFBLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUU7SUFDeEQsZ0JBQUEsQ0FBQyxFQUFFLENBQUM7SUFDSixnQkFBQSxDQUFDLEVBQUUsQ0FBQztJQUNMLGFBQUE7OztnQkFHRCxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUU7SUFDbkMsZ0JBQUEsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3pELGFBQUE7O0lBRUQsWUFBQSxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7O2dCQUUvRCxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDckU7SUFFRDs7Ozs7SUFLRztJQUNJLFFBQUEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUN4QixRQUEwQixFQUFFLFFBQStCLEVBQUE7SUFDN0QsWUFBQSxNQUFNLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDOzs7SUFHdkQsWUFBQSxJQUFJLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7SUFDbkQsZ0JBQUEsUUFBUSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDdEIsZ0JBQUEsaUJBQWlCLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2pDLGFBQUE7OztJQUdELFlBQUEsSUFBSSxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUU7SUFDbkMsZ0JBQUEsUUFBUSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsZ0JBQUEsaUJBQWlCLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3BDLGFBQUE7Z0JBQ0QsUUFBUSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUMxQyxZQUFBLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLGlCQUFpQixDQUFDO0lBQ2hELFlBQUEsUUFBa0MsQ0FBQyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDMUQsWUFBQSxRQUFrQyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsU0FBUyxDQUFDO2FBQ3JFO0lBRUQ7Ozs7O0lBS0c7WUFDSSxDQUFDLHVCQUF1QixDQUFDLENBQUMsUUFBNEIsRUFBQTtJQUMzRCxZQUFBLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFO0lBQzlCLGdCQUFBLE1BQU0sRUFBRSxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQztvQkFDOUIsRUFBRSxDQUFDLFVBQVUsRUFBRSxDQUFDO0lBQ2YsZ0JBQUEsT0FBaUMsQ0FBQyxTQUFTLENBQUMsR0FBRyxTQUFTLENBQUM7SUFDMUQsZ0JBQUEsTUFBTSxRQUFRLEdBQUcsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUM7SUFDN0MsZ0JBQUEsS0FBSyxNQUFNLE9BQU8sSUFBSSxRQUFRLEVBQUU7SUFDOUIsb0JBQUEsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdkIsaUJBQUE7SUFDQSxnQkFBQSxPQUFpQyxDQUFDLGtCQUFrQixDQUFDLEdBQUcsU0FBUyxDQUFDO0lBQ3BFLGFBQUE7YUFDRjtJQUVEOzs7Ozs7O0lBT0c7SUFDSSxRQUFBLENBQUMsY0FBYyxDQUFDLENBQ25CLFFBQWlDLEVBQUUsTUFBNkIsRUFDaEUsV0FBa0MsRUFBQTtJQUNwQyxZQUFBLEtBQUssTUFBTSxPQUFPLElBQUksUUFBUSxFQUFFOztJQUU5QixnQkFBQSxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsVUFBVyxDQUFDO0lBQ25DLGdCQUFBLE1BQU0sUUFBUSxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUM7SUFDakMsZ0JBQUEsTUFBTSxlQUFlLEdBQUcsSUFBSSxHQUFHLEVBQWUsQ0FBQztJQUMvQyxnQkFBQSxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUN4QyxvQkFBQSxNQUFNLE9BQU8sR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUEwQixDQUFDOzt3QkFFckQsSUFBSSxPQUFPLEtBQUssT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU8sQ0FBQzs2QkFDbEQsTUFBTSxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRTs0QkFDbkMsU0FBUztJQUNWLHFCQUFBOztJQUVELG9CQUFBLElBQUksV0FBVyxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUU7SUFDaEMsd0JBQUEsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixxQkFBQTtJQUFNLHlCQUFBO0lBQ0wsd0JBQUEsT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDckIsd0JBQUEsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM5QixxQkFBQTtJQUNGLGlCQUFBOztJQUVELGdCQUFBLE9BQU8sQ0FBQyxrQkFBa0IsQ0FBQyxHQUFHLGVBQWUsQ0FBQzs7SUFFOUMsZ0JBQUEsTUFBTSxFQUFFLEdBQUcsSUFBSSxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUNuRSxnQkFBQSxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsRUFBRSxDQUFDO29CQUN4QixJQUFJLGVBQWUsR0FBRyxNQUFNLENBQUM7Ozs7b0JBSTdCLE1BQU0sY0FBYyxHQUFHLGVBQWlDLENBQUM7SUFDekQsZ0JBQUEsSUFBSSxjQUFjLENBQUMsT0FBTyxJQUFJLGNBQWMsQ0FBQyxJQUFJLEVBQUU7SUFDakQsb0JBQUEsZUFBZSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUM7SUFDdkMsaUJBQUE7SUFDRCxnQkFBQSxFQUFFLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRTtJQUMxQixvQkFBQSxTQUFTLEVBQUUsSUFBSTtJQUNoQixpQkFBQSxDQUFDLENBQUM7SUFDSixhQUFBO2FBQ0Y7SUFFRDs7OztJQUlHO1lBQ0ksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFNBQTJCLEVBQUE7SUFDbkQsWUFBQSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDcEMsWUFBQSxNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMscUJBQXFCLENBQUMsQ0FBQztJQUNoRCxZQUFBLEtBQUssTUFBTSxRQUFRLElBQUksU0FBUyxFQUFFOzs7b0JBR2hDLE1BQU0sTUFBTSxHQUFJLFFBQVEsQ0FBQyxNQUFxQixDQUFDLElBQUksSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDO29CQUN2RSxNQUFNLEdBQUcsR0FBRyxNQUFNLEtBQUssUUFBUSxDQUFDLElBQUk7d0JBQ2hDLE9BQU8sQ0FBQyxNQUFNO0lBQ2Qsb0JBQUEsT0FBTyxDQUFDLE9BQU8sQ0FBQyxNQUEwQixDQUFDLENBQUM7b0JBQ2hELE1BQU0sWUFBWSxHQUFHLE9BQU8sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdEMsZ0JBQUEsTUFBTSxlQUFlLEdBQUcsWUFBWSxDQUFDLGtCQUFrQixDQUFDLENBQUM7O0lBR3pELGdCQUFBLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDckQsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQTBCLENBQUM7d0JBQ2xFLElBQUksT0FBTyxLQUFLLFlBQVksRUFBRTtJQUM1Qix3QkFBQSxPQUFPLENBQUMsSUFBSSxDQUFDLCtDQUErQyxDQUFDLENBQUM7NEJBQzlELElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQzs0QkFDWCxPQUFPO0lBQ1IscUJBQUE7SUFDRCxvQkFBQSxJQUFJLGVBQWUsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7SUFDaEMsd0JBQUEsT0FBTyxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7SUFDdEIsd0JBQUEsZUFBZSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUNqQyxxQkFBQTtJQUNGLGlCQUFBOztJQUdELGdCQUFBLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxRQUFRLENBQUMsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTt3QkFDbkQsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQTBCLENBQUM7d0JBQ2hFLElBQUksQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLEVBQUU7NEJBQ2hDLFNBQVM7SUFDVixxQkFBQTtJQUNELG9CQUFBLElBQUksV0FBVyxJQUFJLE9BQU8sQ0FBQyxLQUFLLEVBQUU7SUFDaEMsd0JBQUEsV0FBVyxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUMxQixxQkFBQTtJQUFNLHlCQUFBO0lBQ0wsd0JBQUEsT0FBTyxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7SUFDckIsd0JBQUEsZUFBZSxDQUFDLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM5QixxQkFBQTtJQUNGLGlCQUFBO0lBQ0YsYUFBQTthQUNGO0lBRUQ7O0lBRUc7WUFDSSxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQW9CLEVBQUE7Z0JBQ3hDLE9BQU8sS0FBSyxLQUFLLDJCQUEyQixDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7YUFDdEU7SUFFRDs7O0lBR0c7WUFDSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLE9BQW9CLEVBQUE7Z0JBQ3ZDLE1BQU0sT0FBTyxHQUFHLEVBQUUsQ0FBQztnQkFDbkIsSUFBSSxPQUFPLEdBQStCLE9BQU8sQ0FBQzs7SUFFbEQsWUFBQSxPQUFPLE9BQU8sSUFBSSxPQUFPLEtBQUssUUFBUSxDQUFDLElBQUksRUFBRTs7SUFFM0MsZ0JBQUEsSUFBSSxPQUFPLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7SUFDMUMsb0JBQUEsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2QixpQkFBQTs7b0JBRUQsSUFBSSxPQUFPLENBQUMsWUFBWSxFQUFFOztJQUV4QixvQkFBQSxPQUFPLE9BQU8sR0FBRyxPQUFPLENBQUMsWUFBWSxFQUFFO0lBQ3JDLHdCQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDdkIscUJBQUE7O0lBRUQsb0JBQUEsT0FBTyxHQUFHLE9BQU8sQ0FBQyxHQUFHLEVBQUUsQ0FBQzt3QkFDeEIsU0FBUztJQUNWLGlCQUFBO29CQUNELE9BQU8sR0FBRyxPQUFPLENBQUMsVUFBeUI7d0JBQ3RDLE9BQThCLENBQUMsSUFBSSxDQUFDO0lBQzFDLGFBQUE7SUFDRCxZQUFBLE9BQU8sT0FBTyxDQUFDO2FBQ2hCO0lBRUQ7OztJQUdHO1lBQ0ksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLE9BQW9CLEVBQUE7SUFFbkQsWUFBQSxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO2dCQUN0QyxJQUFJLENBQUMsVUFBVSxFQUFFO0lBQ2YsZ0JBQUEsT0FBTyxJQUFJLENBQUM7SUFDYixhQUFBO0lBQ0QsWUFBQSxNQUFNLE1BQU0sR0FBRyxJQUFJLEdBQUcsRUFBZSxDQUFDO0lBQ3RDLFlBQUEsSUFBSSxDQUFDLENBQUM7SUFDTixZQUFBLElBQUksQ0FBQyxDQUFDO0lBQ04sWUFBQSxJQUFJLEtBQUssQ0FBQztnQkFDVixNQUFNLEtBQUssR0FBRyxVQUFVLENBQUMsZ0JBQWdCLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ2xELElBQUksS0FBSyxDQUFDLE1BQU0sSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxFQUFFO0lBQzFDLGdCQUFBLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtJQUNqQyxvQkFBQSxLQUFLLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQztJQUM3Qix3QkFBQSxPQUFPLEVBQUUsSUFBSTtJQUNkLHFCQUFBLENBQUMsQ0FBQztJQUNILG9CQUFBLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTs0QkFDakMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0NBQzNDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBZ0IsQ0FBQyxDQUFDO0lBQ3JDLHlCQUFBO0lBQ0YscUJBQUE7SUFDRixpQkFBQTs7SUFFRixhQUFBO0lBQ0QsWUFBQSxPQUFPLE1BQU0sQ0FBQzthQUNmO0lBQ0YsS0FBQTtJQUVBLElBQUEsUUFBeUMsQ0FBQyxpQkFBaUI7WUFDeEQsSUFBSSxvQkFBb0IsRUFBRSxDQUFDO0lBQ2pDLENBQUMsR0FBRzs7SUM5YUosU0FBUyxnQkFBZ0IsS0FBSyxPQUFROEssYUFBVyxFQUFtQyxDQUFDLGlCQUFpQixDQUFBLEVBQUU7SUFDeEc7Ozs7Ozs7SUFPRztJQUNhLFNBQUEsa0JBQWtCLENBQW9CLE9BQWdCLEVBQUUsU0FBMkIsRUFBQTtJQUUvRixJQUFBLE1BQU0sZUFBZSxHQUFHLGlCQUFpQixDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBRXJEOztJQUVHO1FBQ0hySCxDQUFlLENBQUMsTUFBSztJQUNqQixRQUFBLE1BQU0sTUFBTSxHQUFHLGVBQWUsRUFBRSxDQUFDO0lBRWpDLFFBQUEsSUFBSSxPQUFPLEVBQUU7Ozs7O2dCQUtULElBQUk7SUFDQSxnQkFBQSxnQkFBZ0IsRUFBRSxDQUFDLElBQUksQ0FBQyxNQUFnQyxDQUFDLENBQUM7SUFDMUQsZ0JBQUEsT0FBTyxNQUFLO0lBQ1Isb0JBQUEsZ0JBQWdCLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBZ0MsQ0FBQyxDQUFDO0lBQ2hFLGlCQUFDLENBQUM7SUFDTCxhQUFBO0lBQ0QsWUFBQSxPQUFPLEVBQUUsRUFBRTs7SUFFUCxnQkFBQSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ3JCLGFBQUE7SUFDSixTQUFBO0lBQ0wsS0FBQyxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUNsQixDQUFDO2FBRWUsYUFBYSxHQUFBO0lBQ3pCLElBQUEsT0FBTyxnQkFBZ0IsRUFBRSxDQUFDLEdBQUcsQ0FBQztJQUNsQzs7SUM5QkEsTUFBTSx3QkFBd0IsR0FBRyxJQUFJLEdBQUcsRUFBNkMsQ0FBQztJQUV0RSxTQUFBLFlBQVksQ0FBd0IsRUFBRSxVQUFVLEVBQTBCLEVBQUE7UUFFdEYsTUFBTSxrQkFBa0IsR0FBR0ssR0FBVyxDQUFDLENBQUMsVUFBbUIsRUFBRSxPQUFpQixLQUFJO1lBQzlFLElBQUksVUFBVSxJQUFJLE9BQU8sRUFBRTtJQUV2QixZQUFBLElBQUksU0FBUyxHQUFHLHFCQUFxQixDQUFDLE1BQUs7OztvQkFHdkMsY0FBYyxDQUFDLE1BQUs7SUFDaEIsb0JBQUEsa0JBQWtCLENBQUMsT0FBTyxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUM7d0JBQ3JDLFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDbEIsaUJBQUMsQ0FBQyxDQUFBO0lBQ04sYUFBQyxDQUFDLENBQUE7SUFFRixZQUFBLE9BQU8sTUFBSztJQUNSLGdCQUFBLElBQUksU0FBUzt3QkFDVCxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN4QyxhQUFDLENBQUM7SUFDTCxTQUFBO0lBQ0ksYUFBQSxJQUFJLE9BQU8sRUFBRTs7O0lBSWQsWUFBQSxJQUFJLFNBQVMsR0FBRyxxQkFBcUIsQ0FBQyxNQUFLO29CQUN2QyxjQUFjLENBQUMsTUFBSzt3QkFDaEIsd0JBQXdCLENBQUMsR0FBRyxDQUFDLGFBQWEsRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFFLENBQUM7d0JBQ3ZELFNBQVMsR0FBRyxDQUFDLENBQUM7SUFDbEIsaUJBQUMsQ0FBQyxDQUFDO0lBQ1AsYUFBQyxDQUFDLENBQUM7SUFFSCxZQUFBLE9BQU8sTUFBSztJQUNSLGdCQUFBLElBQUksU0FBUzt3QkFDVCxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN4QyxhQUFDLENBQUM7SUFDTCxTQUFBO1NBQ0osRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQLE1BQU0sRUFBRSxVQUFVLEVBQUUsa0JBQWtCLEVBQUUsR0FBRyxhQUFhLENBQUksRUFBRSxlQUFlLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxPQUFpQixLQUFLLGtCQUFrQixDQUFDLFVBQVUsRUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQTtRQUNuSyxNQUFNLEVBQUUsb0JBQW9CLEVBQUUsR0FBRyxnQkFBZ0IsQ0FBQyxFQUFFLFdBQVcsRUFBRSxpQkFBaUIsQ0FBQyxNQUFNLFVBQVUsRUFBRSxFQUFFLGFBQWEsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFFLEVBQUUsQ0FBQyxDQUFDOzs7UUFLN0lMLENBQWUsQ0FBQyxNQUFLO0lBQ2pCLFFBQUEsTUFBTSxPQUFPLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDN0IsSUFBSSxVQUFVLElBQUksT0FBTyxFQUFFO0lBQ3ZCLFlBQUEsTUFBTSxRQUFRLEdBQUdxSCxhQUFXLENBQUMsT0FBTyxDQUFDLENBQUM7OztJQUl0QyxZQUFBLHdCQUF3QixDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsRUFBRyxvQkFBb0IsRUFBbUMsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDNUgsU0FBQTtJQUNMLEtBQUMsRUFBRSxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7SUFFakIsSUFBQSxrQkFBa0IsQ0FBQyxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFM0M7Ozs7O0lBS0c7UUFDSHJILENBQWUsQ0FBQyxNQUFLO0lBQ2pCLFFBQUEsa0JBQWtCLENBQUMsVUFBVSxFQUFFLFVBQVUsRUFBRSxDQUFDLENBQUM7SUFDakQsS0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUVqQixJQUFBLE1BQU0saUJBQWlCLElBQUksQ0FBQyxLQUE4QixLQUFJO0lBQzFELFFBQUEsTUFBTSxFQUFFLEdBQUcsa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckMsUUFBQSxNQUFNLEVBQUUsR0FBRyxFQUFFLFlBQVksRUFBRSxVQUFVLEdBQUcsTUFBTSxHQUFHLFNBQVMsRUFBNkIsQ0FBQztJQUN4RixRQUFBLE9BQU8sY0FBYyxDQUFJLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNyQyxLQUFDLENBQUMsQ0FBQztRQUdILE9BQU87WUFDSCxpQkFBaUI7WUFDakIsVUFBVTtTQUNiLENBQUM7SUFDTixDQUFDO0lBRUQ7Ozs7SUFJRztJQUNHLFNBQVUsa0JBQWtCLENBQUMsT0FBYSxFQUFBO1FBQzVDLE1BQU0sVUFBVSxHQUFHLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLEVBQUUsVUFBVSxDQUFDLFlBQVksRUFBRSxFQUFFLFVBQVUsRUFBRSxDQUFDLElBQUksTUFBTSxJQUFJLFlBQVksT0FBTyxJQUFJLFdBQVcsQ0FBQyxJQUFJLENBQUMsR0FBRyxVQUFVLENBQUMsYUFBYSxHQUFHLFVBQVUsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDLENBQUE7SUFDNU0sSUFBQSxNQUFNLGNBQWMsR0FBRyxVQUFVLENBQUMsVUFBVSxFQUF5QyxDQUFDO0lBQ3RGLElBQUEsT0FBTyxjQUFjLENBQUM7SUFDMUI7O0lDekdBOzs7OztJQUtHO2FBQ2EsY0FBYyxHQUFBO1FBQzFCLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBR2QsQ0FBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVCLElBQUEsT0FBT2UsQ0FBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDO0lBQy9DOztJQzZDTSxTQUFVLFdBQVcsQ0FBaUIsRUFBRSxnQkFBZ0IsRUFBRSxxQkFBcUIsRUFBRSxvQkFBb0IsRUFBRSx5QkFBeUIsRUFBRSx5QkFBeUIsRUFBRSxxQkFBcUIsRUFBRSxxQkFBcUIsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUE0QixFQUFBO0lBRXBTLElBQUEsa0JBQWtCLENBQUMsYUFBYSxFQUFFLGdCQUFnQixFQUFFLHFCQUFxQixFQUFFLG9CQUFvQixFQUFFLHlCQUF5QixFQUFFLHlCQUF5QixFQUFFLHFCQUFxQixFQUFFLHFCQUFxQixDQUFDLENBQUM7SUFFck0sSUFBQSxNQUFNLENBQUMsVUFBVSxFQUFFLFVBQVUsQ0FBQyxHQUFHLGVBQWUsQ0FBVSxnQkFBZ0IsRUFBRSxXQUFXLENBQUMsQ0FBQztJQUN6RixJQUFBLE1BQU0sQ0FBQyxlQUFlLEVBQUUsZUFBZSxDQUFDLEdBQUcsZUFBZSxDQUFVLHFCQUFxQixFQUFFLFdBQVcsQ0FBQyxDQUFDO0lBQ3hHLElBQUEsTUFBTSxDQUFDLGNBQWMsRUFBRSxjQUFjLENBQUMsR0FBRyxlQUFlLENBQVUsb0JBQW9CLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFDckcsSUFBQSxNQUFNLENBQUMsbUJBQW1CLEVBQUUsbUJBQW1CLENBQUMsR0FBRyxlQUFlLENBQVUseUJBQXlCLEVBQUUsV0FBVyxDQUFDLENBQUM7SUFFcEgsSUFBQSxNQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsYUFBYSxDQUFJLEVBQUUsZUFBZSxFQUFFLE9BQU8sRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO1FBRXJHLE1BQU0sRUFBRSxnQkFBZ0IsRUFBRSxvQkFBb0IsRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLGdCQUFnQixDQUFDO1lBQ2xGLFdBQVc7WUFDWCxTQUFTO1lBQ1QscUJBQXFCLEVBQUVJLEdBQVcsQ0FBbUUsQ0FBQyxhQUFhLEVBQUUsaUJBQWlCLEtBQUk7SUFDdEksWUFBQSxNQUFNLFdBQVcsR0FBRyxVQUFVLEVBQUUsQ0FBQztJQUNqQyxZQUFBLE1BQU0sT0FBTyxJQUFJLFdBQVcsSUFBSSxJQUFJLEtBQUssV0FBVyxJQUFJLGFBQTRCLENBQUMsQ0FBQyxDQUFDO0lBQ3ZGLFlBQUEsTUFBTSxZQUFZLElBQUksQ0FBQyxDQUFDLFdBQVcsRUFBRSxRQUFRLENBQUMsYUFBNEIsQ0FBQyxDQUFDLENBQUM7Z0JBQzdFLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDcEIsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQzlCLFlBQUEscUJBQXFCLEdBQUcsYUFBYSxFQUFFLGlCQUFpQixDQUFDLENBQUM7YUFDN0QsRUFBRSxFQUFFLENBQUM7WUFDTix5QkFBeUIsRUFBRUEsR0FBVyxDQUF1RSxDQUFDLGlCQUFpQixFQUFFLHFCQUFxQixLQUFJO0lBQ3RKLFlBQUEsTUFBTSxXQUFXLEdBQUcsVUFBVSxFQUFFLENBQUM7SUFDakMsWUFBQSxNQUFNLE9BQU8sSUFBSSxXQUFXLElBQUksSUFBSSxLQUFLLFdBQVcsSUFBSSxpQkFBZ0MsQ0FBQyxDQUFDLENBQUM7SUFDM0YsWUFBQSxNQUFNLFlBQVksSUFBSSxDQUFDLENBQUMsV0FBVyxFQUFFLFFBQVEsQ0FBQyxpQkFBZ0MsQ0FBQyxDQUFDLENBQUM7Z0JBQ2pGLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztnQkFDeEIsbUJBQW1CLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDbEMsWUFBQSx5QkFBeUIsR0FBRyxpQkFBaUIsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDO2FBQ3pFLEVBQUUsRUFBRSxDQUFDO1lBQ04scUJBQXFCO0lBQ3hCLEtBQUEsQ0FBQyxDQUFDO1FBRUgsTUFBTSxnQkFBZ0IsR0FBR0EsR0FBVyxDQUFDLENBQUMsS0FBOEIsS0FBTyxFQUFBLE9BQU8sa0JBQWtCLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBR3BILE9BQU87WUFDSCxnQkFBZ0I7WUFDaEIsVUFBVTtZQUNWLFVBQVU7WUFDVixlQUFlO1lBQ2YsY0FBYztZQUNkLG1CQUFtQjtZQUNuQixnQkFBZ0I7WUFDaEIsb0JBQW9CO1lBQ3BCLGdCQUFnQjtTQUNuQixDQUFDO0lBQ04sQ0FBQzthQThCZSxvQkFBb0IsQ0FBQyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLEVBQUUsZUFBZSxFQUFFLEVBQUUsd0JBQXdCLEVBQUUscUJBQXFCLEVBQUUsRUFBa0MsRUFBQTtJQUNsTSxJQUFBLE1BQU0sRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLEdBQUcsa0JBQWtCLENBQTJCLEVBQUUsZUFBZSxFQUFFLEVBQUUsd0JBQXdCLEVBQUUscUJBQXFCLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDcEssTUFBTSxjQUFjLEdBQUdKLENBQU0sQ0FBWSxJQUFJLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDcEQsSUFBQSxNQUFNLENBQUMsY0FBYyxFQUFFLGFBQWEsQ0FBQyxHQUFHLGVBQWUsQ0FBUyxpQkFBaUIsQ0FBQyxDQUFDLFVBQWtCLEVBQUUsb0JBQXdDLEtBQUk7WUFDL0ksT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFBLDBCQUFBLEVBQTZCLG9CQUFvQixDQUFPLElBQUEsRUFBQSxVQUFVLENBQUUsQ0FBQSxDQUFDLENBQUM7WUFDbEYsT0FBTyxDQUFDLE1BQU0sQ0FBQyxVQUFVLElBQUksQ0FBQyxJQUFJLFVBQVUsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUVuRCxJQUFJLFVBQVUsSUFBSSxDQUFDLG9CQUFvQjtnQkFDbkMsZ0JBQWdCLElBQUksQ0FBQztZQUN6QixJQUFJLENBQUMsVUFBVSxJQUFJLG9CQUFvQjtnQkFDbkMsY0FBYyxJQUFJLENBQUM7U0FDMUIsQ0FBQyxDQUFDLENBQUM7SUFFSixJQUFBLE1BQU0seUJBQXlCLEdBQUdJLEdBQVcsQ0FBQyxDQUFvQixFQUFFLGVBQWUsRUFBRSxPQUFPLEVBQUUsU0FBUyxFQUFFLFdBQVcsRUFBRSxTQUFTLEVBQUUscUJBQXFCLEVBQUUsZ0JBQWdCLEVBQUUscUJBQXFCLEVBQUUseUJBQXlCLEVBQUUsb0JBQW9CLEVBQUUseUJBQXlCLEVBQUUscUJBQXFCLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUEwQyxLQUE0QztJQUNwWixRQUFBLGVBQWUsQ0FBQyxFQUFFLFlBQVksRUFBRSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQztZQUNqRSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxRQUFRLEVBQUcsR0FBRyxXQUFXLENBQUk7Z0JBQ3RELFdBQVc7Z0JBQ1gsU0FBUztnQkFDVCxxQkFBcUI7Z0JBQ3JCLGVBQWUsRUFBRUEsR0FBVyxDQUFDLENBQUMsQ0FBVyxFQUFFLElBQTBCLEtBQUk7b0JBQ3JFLElBQUksQ0FBQyxHQUFHLGVBQWUsR0FBRyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDbkMsZ0JBQUEsSUFBSSxDQUFDLEVBQUU7SUFDSCxvQkFBQSxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM5QixvQkFBQSxPQUFPLE1BQUs7NEJBQ1IsQ0FBQyxJQUFJLENBQUM7SUFDTix3QkFBQSxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNyQyxxQkFBQyxDQUFBO0lBQ0osaUJBQUE7SUFDTCxhQUFDLEVBQUUsQ0FBQyxlQUFlLENBQUMsQ0FBQztnQkFDckIsT0FBTztnQkFDUCxTQUFTO2dCQUNULGdCQUFnQjtnQkFDaEIscUJBQXFCO2dCQUNyQix5QkFBeUI7Z0JBQ3pCLG9CQUFvQjtnQkFDcEIseUJBQXlCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxPQUFnQixFQUFFLElBQXlCLEtBQUk7SUFDekYsZ0JBQUEsSUFBSSxPQUFPLEVBQUU7SUFDVCxvQkFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsS0FBSyxDQUFBLFdBQUEsQ0FBYSxDQUFDLENBQUM7SUFDekMsb0JBQUEsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDcEMsaUJBQUE7SUFDSSxxQkFBQSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksRUFBRTtJQUN2QixvQkFBQSxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsS0FBSyxDQUFBLGFBQUEsQ0FBZSxDQUFDLENBQUM7SUFDM0Msb0JBQUEsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7SUFDcEMsaUJBQUE7SUFFRCxnQkFBQSx5QkFBeUIsR0FBRyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDL0MsYUFBQyxDQUFDO2dCQUNGLHFCQUFxQjtJQUN4QixTQUFBLENBQUMsQ0FBQztZQUVILE9BQU87SUFDSCxZQUFBLDhCQUE4QixFQUFFLGdCQUFnQjtJQUNoRCxZQUFBLEdBQUcsUUFBUTthQUNkLENBQUE7U0FDSixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRVAsT0FBTztZQUNILGVBQWU7WUFDZix5QkFBeUI7U0FDNUIsQ0FBQTtJQUNMOztJQ2xMQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0JHO2FBQ2EsUUFBUSxDQUFpQixFQUFFLE9BQU8sRUFBRSxRQUFRLEVBQUUsRUFBRSxxQkFBcUIsRUFBRSxHQUFHLFFBQVEsRUFBRSxFQUFFLFdBQVcsRUFBeUIsRUFBQTs7Ozs7Ozs7O0lBVXRJLElBQUEsTUFBTSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25ELElBQUEsTUFBTSxXQUFXLEdBQUcsY0FBYyxFQUFFLENBQUM7SUFDckMsSUFBQSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLEdBQUcsV0FBVyxDQUFDO0lBQ2pELFFBQUEsR0FBRyxRQUFRO1lBQ1gscUJBQXFCLEVBQUUsaUJBQWlCLENBQUMsQ0FBQyxDQUFVLEVBQUUsQ0FBc0IsS0FBSTtJQUM1RSxZQUFBLHFCQUFxQixHQUFHLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDOUIsSUFBSSxDQUFDLENBQUMsRUFBRTtvQkFDSixTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDaEIsYUFBQTtJQUNMLFNBQUMsQ0FBQztJQUNMLEtBQUEsQ0FBQyxDQUFDOzs7Ozs7Ozs7UUFVSCxNQUFNLENBQUMscUNBQXFDLEVBQUUsd0NBQXdDLENBQUMsR0FBRyxRQUFRLENBQWMsSUFBSSxDQUFDLENBQUM7UUFDdEgsTUFBTSxZQUFZLElBQUksTUFBTSxLQUFLLHFDQUFxQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUM7SUFFakYsSUFBQSxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUUsaUJBQWlCLEVBQUUsQ0FBQyxJQUFHO0lBQzlDLFFBQUEsd0NBQXdDLENBQUMsSUFBSSxJQUFJLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDLENBQUM7SUFDMUksS0FBQyxDQUFDLENBQUM7UUFFSFQsQ0FBUyxDQUFDLE1BQUs7WUFDWCxJQUFJLE1BQU0sSUFBSSxDQUFDO2dCQUNYLHdDQUF3QyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBRXZELEtBQUMsRUFBRSxDQUFDLE1BQU0sSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBRWxCLElBQUEsTUFBTSxhQUFhLEdBQUcsaUJBQWlCLENBQWtDLENBQUMsQ0FBQyxLQUFJO1lBQzNFLFNBQVMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4QixLQUFDLENBQUMsQ0FBQztJQUVILElBQUEsTUFBTSxZQUFZLEdBQUcsaUJBQWlCLENBQWtDLENBQUMsQ0FBQyxLQUFJO0lBQzFFLFFBQUEsU0FBUyxDQUFDLENBQUMsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFakMsUUFBQSxNQUFNLFdBQVcsR0FBRyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQy9CLFFBQUEsTUFBTSxjQUFjLElBQUkscUNBQXFDLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLFdBQVcsR0FBRyxDQUFDLHFDQUFxQyxDQUFDLENBQUM7SUFDdEksUUFBQSxNQUFNLGtCQUFrQixHQUFHLHNCQUFzQixDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUE7Ozs7SUFLL0QsUUFBQSxJQUFJLGtCQUFrQixHQUFHLENBQUMsS0FBSyxDQUFDLGNBQWMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLGtCQUFrQixJQUFJLENBQUMsQ0FBQyxFQUFFO2dCQUNwRixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7Z0JBQ25CLE9BQU87SUFDVixTQUFBO0lBRUQsUUFBQSxJQUFJLFNBQVMsRUFBRSxJQUFJLENBQUMsRUFBRTtnQkFDbEIsV0FBVyxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNmLFdBQVcsRUFBRSxDQUFDO0lBQ2pCLFNBQUE7SUFDTCxLQUFDLENBQUMsQ0FBQztJQUVILElBQUEsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQWtDLENBQUMsQ0FBQyxLQUFJO0lBQ3pFLFFBQUEsSUFBSSxXQUFXLEVBQUU7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBa0JiLFlBQUEsTUFBTSxPQUFPLEdBQUcsVUFBVSxFQUFFLENBQUM7SUFDN0IsWUFBQSxJQUFJLE9BQU8sSUFBSSxPQUFPLElBQUssT0FBc0M7b0JBQzVELE9BQTZDLEVBQUUsS0FBSyxFQUFFLENBQUM7OztnQkFJNUQsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDOzs7OztnQkFNbkIsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDOztnQkFHcEIsSUFBSTs7O0lBR0EsZ0JBQUEsS0FBSyxFQUFFLENBQUM7SUFDWCxhQUFBO0lBQ08sb0JBQUE7O29CQUVKLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNsQixhQUFBO0lBRUosU0FBQTtJQUNMLEtBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBQSxNQUFNLFdBQVcsR0FBRyxRQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQThCLEtBQUk7Ozs7SUFJNUYsUUFBQSxJQUFJLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQztnQkFDWixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7SUFHdkIsUUFBQSxJQUFJLENBQUMsQ0FBQyxNQUFNLEtBQUssQ0FBQztnQkFDZCxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDekIsS0FBQyxDQUFBO0lBQ0QsSUFBQSxNQUFNLFNBQVMsR0FBRyxRQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQThCLEtBQUk7WUFDMUYsSUFBSSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsSUFBSSxNQUFNLEdBQUcsQ0FBQztnQkFDNUIsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hCLEtBQUMsQ0FBQztJQUdGLElBQUEsTUFBTSxZQUFZLEdBQUcsaUJBQWlCLENBQUMsTUFBSztJQUN4QyxRQUFBLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQztnQkFDM0IsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLEtBQUMsQ0FBQyxDQUFDO1FBRUgsTUFBTSxTQUFTLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSSxRQUFRLENBQUMsT0FBTyxFQUFFLE9BQU8sQ0FBQyxHQUFHLFNBQVMsR0FBRyxDQUFDLENBQWlDLEtBQUk7SUFDM0gsUUFBQSxJQUFJLENBQUMsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLFdBQVcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUU7OztnQkFHNUQsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNqQixDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7SUFDdEIsU0FBQTtJQUVELFFBQUEsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLEVBQUU7Z0JBQ2pELENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQkFDbkIsYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNqQixZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDbkIsU0FBQTtJQUNMLEtBQUMsQ0FBQTtJQUVELElBQUEsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFpQyxLQUFJO0lBQzNGLFFBQUEsSUFBSSxDQUFDLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDO2dCQUMzQyxZQUFZLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDeEIsS0FBQyxDQUFBO0lBRUQsSUFBQSxNQUFNLE9BQU8sR0FBRyxDQUFDLENBQThCLEtBQUk7WUFDL0MsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO0lBQ25CLFFBQUEsSUFBSSxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDZCxDQUFDLENBQUMsd0JBQXdCLEVBQUUsQ0FBQztnQkFDN0IsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3ZCLFNBQUE7SUFDTCxLQUFDLENBQUE7UUFFRCxPQUFPLFNBQVMsYUFBYSxDQUFDLEtBQThCLEVBQUE7SUFDeEQsUUFBQSxPQUFPLGNBQWMsQ0FBSSxLQUFLLEVBQUUsZ0JBQWdCLEVBQUU7Z0JBQzlDLFNBQVM7Z0JBQ1QsT0FBTztnQkFDUCxXQUFXO2dCQUNYLFNBQVM7Z0JBQ1QsWUFBWTtnQkFDWixPQUFPO0lBQ1AsWUFBQSxLQUFLLEVBQUUsQ0FBQyxxQ0FBcUMsSUFBSSxJQUFJLElBQUksRUFBRSxNQUFNLEVBQUUsTUFBTSxFQUFFLEdBQUcsU0FBUztJQUN2RixZQUFBLEdBQUcsRUFBRSxvQkFBb0IsRUFBRSxZQUFZLEdBQUcsTUFBTSxHQUFHLFNBQVMsRUFBUTthQUN2RSxFQUFFLENBQUMsQ0FBQztJQUNULEtBQUMsQ0FBQTtJQUNMLENBQUM7SUFLRDs7Ozs7Ozs7O0lBU0c7SUFDSCxTQUFTLHNCQUFzQixDQUFDLE9BQXVDLEVBQUE7SUFDbkUsSUFBQSxJQUFJLE9BQU8sSUFBSSxPQUFPLFlBQVksSUFBSSxFQUFFO0lBQ3BDLFFBQUEsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBRXhDLFFBQUEsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxJQUFJLFNBQVMsRUFBRSxVQUFVLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLEVBQUU7Z0JBQ25ELE1BQU0sS0FBSyxHQUFHLFNBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFFLENBQUM7SUFDeEMsWUFBQSxJQUFJLE9BQU8sQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsRUFBRTtJQUNqRSxnQkFBQSxPQUFPLFNBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUM7SUFDdkMsYUFBQTtJQUNKLFNBQUE7SUFDSixLQUFBO0lBRUQsSUFBQSxPQUFPLENBQUMsQ0FBQztJQUNiLENBQUM7SUFHRCxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUMsU0FBUyxJQUFJLFNBQVMsTUFBTSxTQUFTLENBQUMsT0FBTyxZQUFZLFFBQVEsQ0FBQyxLQUFLLE1BQU0sU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsS0FBSyxNQUFRLEdBQUMsQ0FBQyxDQUFDO0lBZWhJLFNBQVMsUUFBUSxDQUFDLE1BQW1DLEVBQUUsT0FBb0gsRUFBQTtJQUN2SyxJQUFBLElBQUksT0FBTyxHQUFHLE1BQU0sQ0FBQztJQUNqQixRQUFBLE9BQU8sSUFBSSxDQUFDO0lBRWhCLElBQUEsT0FBTyxLQUFLLENBQUM7SUFDakI7O0lDblBBLFNBQVMsVUFBVSxDQUFtQixHQUFNLEVBQUE7SUFDeEMsSUFBQSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsR0FBRyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFtQjtJQUN0RSxDQUFDO0lBcUJEOzs7Ozs7Ozs7Ozs7Ozs7SUFlRztJQUNhLFNBQUEsbUJBQW1CLENBQW9CLEVBQUUsd0JBQXdCLEVBQWlDLEVBQUE7SUFFOUcsSUFBQSxrQkFBa0IsQ0FBQyxxQkFBcUIsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO0lBRXBFLElBQUEsTUFBTSxDQUFDLGlCQUFpQixFQUFFLGlCQUFpQixDQUFDLEdBQUcsZUFBZSxDQUE2QixJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFHN0csSUFBQSxNQUFNLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixFQUFFLEdBQUcsYUFBYSxDQUFJO0lBQ3hELFFBQUEsZUFBZSxFQUFFUyxHQUFXLENBQUMsQ0FBQyxPQUFpQixLQUFJO0lBQy9DLFlBQUEsSUFBSSxPQUFPLEVBQUU7b0JBQ1QsaUJBQWlCLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDdkQsYUFBQTthQUNKLEVBQUUsRUFBRSxDQUFDO0lBQ1QsS0FBQSxDQUFDLENBQUM7Ozs7Ozs7Ozs7O1FBWUgsTUFBTSxFQUFFLG1CQUFtQixFQUFFLEdBQUcsY0FBYyxDQUFJLEVBQUUsWUFBWSxFQUFFQSxHQUFXLENBQUMsQ0FBQyxJQUFJLHdCQUF3QixHQUFHLHVCQUF1QixFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUE7SUFFaEosSUFBQSxNQUFNLHVCQUF1QixHQUFHQSxHQUFXLENBQUMsTUFBSztJQUM3QyxRQUFBLE1BQU0sY0FBYyxHQUFHLGlCQUFpQixFQUFFLENBQUM7SUFDM0MsUUFBQSxJQUFJLGNBQWMsRUFBRTtJQUNoQixZQUFBLE1BQU0sQ0FBQyxHQUFHLGNBQWMsQ0FBQyxXQUEwQixDQUFDO0lBQ3BELFlBQUEsSUFBSSxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQXNCLENBQUM7SUFDOUMsWUFBQSxNQUFNLENBQUMsR0FBRyxjQUFjLENBQUMsZUFBa0MsQ0FBQztnQkFFNUQsSUFBSSxDQUFDLElBQUksU0FBUztvQkFDZCxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBRWQsWUFBQSxRQUFRLEVBQUUsR0FBRyxZQUFZLENBQUMsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2xFLFNBQUE7SUFFRCxRQUFBLE9BQU8sSUFBSSxDQUFDO1NBQ2YsRUFBRSxFQUFFLENBQUMsQ0FBQTs7UUFJTixNQUFNLDJCQUEyQixHQUFHQSxHQUFXLENBQUMsQ0FBQyxrQkFBdUMsRUFBRSxTQUFtRCxLQUFJO1lBQzdJLFNBQVMsS0FBSyx1QkFBdUIsRUFBRSxDQUFDO0lBQ3hDLFFBQUEsSUFBSSxTQUFTLEVBQUUsaUJBQWlCLEtBQUssa0JBQWtCO0lBQ25ELFlBQUEsT0FBTyxRQUFRLENBQUM7SUFDcEIsUUFBQSxPQUFPLE9BQU8sQ0FBQztTQUNsQixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRVAsTUFBTSxxQkFBcUIsR0FBR0EsR0FBVyxDQUFDLENBQUMsSUFBaUUsRUFBRSxTQUFtRCxLQUF5QztZQUN0TSxTQUFTLEtBQUssdUJBQXVCLEVBQUUsQ0FBQztJQUV4QyxRQUFBLFFBQVEsSUFBSTtJQUNSLFlBQUEsS0FBSyxhQUFhO0lBQ2QsZ0JBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsY0FBYyxJQUFJLEtBQUssRUFBRSxDQUFDLENBQTBCLENBQUMsQ0FBQztJQUMvRSxZQUFBLEtBQUssV0FBVztJQUNaLGdCQUFBLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLGNBQWMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxDQUEwQixDQUFDLENBQUM7SUFFL0UsWUFBQSxLQUFLLGNBQWM7SUFDZixnQkFBQSxPQUFPLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxlQUFlLElBQUksS0FBSyxFQUFFLENBQUMsQ0FBMEIsQ0FBQyxDQUFDO0lBQ2hGLFlBQUEsS0FBSyxZQUFZO0lBQ2IsZ0JBQUEsT0FBTyxDQUFDLENBQUMsQ0FBQyxTQUFTLEVBQUUsZUFBZSxJQUFJLEtBQUssRUFBRSxDQUFDLENBQTBCLENBQUMsQ0FBQztJQUNuRixTQUFBO1NBQ0osRUFBRSxFQUFFLENBQUMsQ0FBQTtRQUVOLE1BQU0sb0JBQW9CLEdBQUdBLEdBQVcsQ0FBQyxDQUFDLElBQXlDLEVBQUUsU0FBbUQsS0FBaUU7WUFDck0sU0FBUyxLQUFLLHVCQUF1QixFQUFFLENBQUM7SUFDeEMsUUFBQSxJQUFJLFNBQVMsRUFBRSxpQkFBaUIsS0FBSyxVQUFVLEVBQUU7SUFDN0MsWUFBQSxRQUFRLElBQUk7SUFDUixnQkFBQSxLQUFLLEtBQUs7SUFDTixvQkFBQSxPQUFPLFNBQVMsQ0FBQyxlQUFlLEtBQUssS0FBSyxHQUFHLGNBQWMsR0FBRyxZQUFZLENBQUM7SUFDL0UsZ0JBQUEsS0FBSyxRQUFRO0lBQ1Qsb0JBQUEsT0FBTyxTQUFTLENBQUMsZUFBZSxLQUFLLEtBQUssR0FBRyxjQUFjLEdBQUcsWUFBWSxDQUFDO0lBRS9FLGdCQUFBLEtBQUssTUFBTTtJQUNQLG9CQUFBLE9BQU8sU0FBUyxDQUFDLGNBQWMsS0FBSyxLQUFLLEdBQUcsYUFBYSxHQUFHLFdBQVcsQ0FBQztJQUM1RSxnQkFBQSxLQUFLLE9BQU87SUFDUixvQkFBQSxPQUFPLFNBQVMsQ0FBQyxjQUFjLEtBQUssS0FBSyxHQUFHLGFBQWEsR0FBRyxXQUFXLENBQUM7SUFDL0UsYUFBQTtJQUNKLFNBQUE7SUFDSSxhQUFBLElBQUksU0FBUyxFQUFFLGlCQUFpQixLQUFLLFlBQVksRUFBRTtJQUNwRCxZQUFBLFFBQVEsSUFBSTtJQUNSLGdCQUFBLEtBQUssS0FBSztJQUNOLG9CQUFBLE9BQU8sU0FBUyxDQUFDLGNBQWMsS0FBSyxLQUFLLEdBQUcsYUFBYSxHQUFHLFdBQVcsQ0FBQztJQUM1RSxnQkFBQSxLQUFLLFFBQVE7SUFDVCxvQkFBQSxPQUFPLFNBQVMsQ0FBQyxjQUFjLEtBQUssS0FBSyxHQUFHLGFBQWEsR0FBRyxXQUFXLENBQUM7SUFFNUUsZ0JBQUEsS0FBSyxNQUFNO0lBQ1Asb0JBQUEsT0FBTyxTQUFTLENBQUMsZUFBZSxLQUFLLEtBQUssR0FBRyxjQUFjLEdBQUcsWUFBWSxDQUFDO0lBQy9FLGdCQUFBLEtBQUssT0FBTztJQUNSLG9CQUFBLE9BQU8sU0FBUyxDQUFDLGVBQWUsS0FBSyxLQUFLLEdBQUcsY0FBYyxHQUFHLFlBQVksQ0FBQztJQUNsRixhQUFBO0lBQ0osU0FBQTs7SUFHRCxRQUFBLFNBQVM7SUFDVCxRQUFBLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEIsUUFBQSxPQUFPLGNBQWMsQ0FBQztTQUV6QixFQUFFLEVBQUUsQ0FBQyxDQUFBO1FBRU4sTUFBTSw0QkFBNEIsR0FBR0EsR0FBVyxDQUFDLENBQUMsa0JBQXNDLEVBQUUsU0FBbUQsS0FBSTtZQUM3SSxTQUFTLEtBQUssdUJBQXVCLEVBQUUsQ0FBQztZQUN4QyxJQUFJLGtCQUFrQixJQUFJLFFBQVEsRUFBRTtJQUNoQyxZQUFBLElBQUksU0FBUyxFQUFFLGlCQUFpQixJQUFJLFlBQVk7SUFDNUMsZ0JBQUEsT0FBTyxZQUFZLENBQUM7SUFDeEIsWUFBQSxPQUFPLFVBQVUsQ0FBQztJQUNyQixTQUFBO0lBQ0ksYUFBQTtJQUNELFlBQUEsSUFBSSxTQUFTLEVBQUUsZ0JBQWdCLElBQUksVUFBVTtJQUN6QyxnQkFBQSxPQUFPLFVBQVUsQ0FBQztJQUV0QixZQUFBLE9BQU8sWUFBWSxDQUFDO0lBQ3ZCLFNBQUE7U0FDSixFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRVAsTUFBTSxrQkFBa0IsR0FBR0EsR0FBVyxDQUFDLENBQUMsV0FBd0IsRUFBRSxTQUFtRCxLQUErQjtZQUNoSixTQUFTLEtBQUssdUJBQXVCLEVBQUUsQ0FBQztJQUN4QyxRQUFBLElBQUksU0FBUyxFQUFFO2dCQUNYLE1BQU0sRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsR0FBRyxTQUFTLENBQUM7O2dCQUc3RSxNQUFNLGdCQUFnQixHQUFHLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFBUyxVQUFVLENBQUMsVUFBVSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUM7Z0JBQ3hFLE1BQU0sZUFBZSxHQUFHLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFBUyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUM7Z0JBRXRFLE1BQU0sZ0JBQWdCLEdBQUcsV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxVQUFVLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBQztnQkFDeEUsTUFBTSxlQUFlLEdBQUcsV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBQztnQkFFdEUsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsQ0FBQSxNQUFBLEVBQVMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFDO2dCQUN4RSxNQUFNLGVBQWUsR0FBRyxXQUFXLENBQUMsQ0FBQSxNQUFBLEVBQVMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFFLENBQUEsQ0FBQyxDQUFDO0lBS3RFLFlBQUEsTUFBTSxFQUFFLEdBQUcsa0JBQWtCLENBQUMsZUFBZSxDQUFDLENBQUM7SUFDL0MsWUFBQSxNQUFNLEVBQUUsR0FBRyxzQkFBc0IsQ0FBQyxlQUFlLENBQUMsQ0FBQztJQUVuRCxZQUFBLE1BQU0sRUFBRSxHQUFHLGtCQUFrQixDQUFDLGNBQWMsQ0FBQyxDQUFDO0lBQzlDLFlBQUEsTUFBTSxFQUFFLEdBQUcsc0JBQXNCLENBQUMsY0FBYyxDQUFDLENBQUM7SUFHbkQsWUFBQSxNQUFNLGlCQUFpQixHQUFHLFdBQVcsQ0FBQyxTQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBRSxDQUFBLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBQyxDQUFDO0lBQ3RILFlBQUEsTUFBTSxpQkFBaUIsR0FBRyxXQUFXLENBQUMsU0FBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQztnQkFDdEgsTUFBTSxpQkFBaUIsR0FBRyxXQUFXLENBQUMsQ0FBQSxNQUFBLEVBQVMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFBLENBQUUsQ0FBQyxJQUFJLFNBQVMsR0FBRyxTQUFTLElBQUksV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQSxDQUFFLENBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQVMsTUFBQSxFQUFBLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBRSxDQUFBLENBQUUsQ0FBQyxDQUFDLENBQUM7SUFHM0wsWUFBQSxNQUFNLGdCQUFnQixHQUFHLFdBQVcsQ0FBQyxTQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBRSxDQUFBLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBRSxDQUFBLENBQUMsQ0FBQyxDQUFDO0lBQ3JILFlBQUEsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsU0FBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxHQUFHLFdBQVcsQ0FBQyxDQUFBLE1BQUEsRUFBUyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUUsQ0FBQSxDQUFDLENBQUMsQ0FBQztnQkFDckgsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMsQ0FBQSxNQUFBLEVBQVMsVUFBVSxDQUFDLEVBQUUsQ0FBQyxDQUFBLENBQUUsQ0FBQyxJQUFJLFNBQVMsR0FBRyxTQUFTLElBQUksV0FBVyxDQUFDLENBQUEsTUFBQSxFQUFTLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQSxDQUFFLENBQUUsSUFBSSxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDLENBQVMsTUFBQSxFQUFBLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBRSxDQUFBLENBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBRzNMLE9BQU87b0JBQ0gsZ0JBQWdCO29CQUNoQixnQkFBZ0I7b0JBQ2hCLGdCQUFnQjtvQkFDaEIsZUFBZTtvQkFDZixlQUFlO29CQUNmLGVBQWU7b0JBQ2YsaUJBQWlCO29CQUNqQixpQkFBaUI7b0JBQ2pCLGlCQUFpQjtvQkFDakIsZ0JBQWdCO29CQUNoQixnQkFBZ0I7b0JBQ2hCLGdCQUFnQjtpQkFDbkIsQ0FBQTtJQUNKLFNBQUE7SUFFRCxRQUFBLE9BQU8sSUFBSSxDQUFDO1NBRWYsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQLE9BQU87SUFDSCxRQUFBLHdCQUF3QixFQUFFQSxHQUFXLENBQUMsQ0FBQyxLQUE4QixLQUFLLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDO1lBQzdILFVBQVU7WUFDVix1QkFBdUI7SUFDdkIsUUFBQSxvQkFBb0IsRUFBRSxrQkFBa0I7WUFDeEMsMkJBQTJCO1lBQzNCLDRCQUE0QjtZQUM1QixvQkFBb0I7WUFDcEIscUJBQXFCO1NBQ3hCLENBQUM7SUFDTixDQUFDO0lBRUQ7SUFDQTtJQUNBLFNBQVMsa0JBQWtCLENBQUMsR0FBc0IsRUFBSSxFQUFBLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxHQUFHLElBQUksS0FBSztJQUFFLElBQUEsT0FBTyxNQUFNLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxFQUFFO0lBQ3ZILFNBQVMsc0JBQXNCLENBQUMsR0FBc0IsSUFBSSxJQUFJLEdBQUcsS0FBSyxLQUFLO0lBQUUsSUFBQSxPQUFPLE9BQU8sQ0FBQyxDQUFDLElBQUksR0FBRyxLQUFLLEtBQUs7SUFBRSxJQUFBLE9BQU8sUUFBUSxDQUFDLENBQUMsT0FBTyxJQUFJLENBQUMsRUFBRTtJQUUvSTtJQUNBLE1BQU0sQ0FBQyxHQUFHO0lBQ04sSUFBQSxDQUFDLEVBQUUsS0FBSztJQUNSLElBQUEsQ0FBQyxFQUFFLFFBQVE7SUFDWCxJQUFBLENBQUMsRUFBRSxNQUFNO0lBQ1QsSUFBQSxDQUFDLEVBQUUsT0FBTztLQUNKLENBQUM7SUE4SFgsTUFBTSxlQUFlLEdBQXlCO0lBQzFDLElBQUEsZUFBZSxFQUFFLEtBQUs7SUFDdEIsSUFBQSxjQUFjLEVBQUUsS0FBSztJQUVyQixJQUFBLGlCQUFpQixFQUFFLFlBQVk7SUFDL0IsSUFBQSxnQkFBZ0IsRUFBRSxVQUFVO0lBRTVCLElBQUEsVUFBVSxFQUFFLE9BQU87SUFDbkIsSUFBQSxTQUFTLEVBQUUsUUFBUTtJQUVuQixJQUFBLGtCQUFrQixFQUFFLEtBQUs7SUFDekIsSUFBQSxrQkFBa0IsRUFBRSxLQUFLO0tBQzVCLENBQUM7SUFFRixNQUFNLGVBQWUsR0FBeUI7SUFDMUMsSUFBQSxHQUFHLGVBQWU7SUFDbEIsSUFBQSxlQUFlLEVBQUUsS0FBSztLQUN6QixDQUFDO0lBRUYsTUFBTSxhQUFhLEdBQXlCO0lBQ3hDLElBQUEsZUFBZSxFQUFFLEtBQUs7SUFDdEIsSUFBQSxjQUFjLEVBQUUsS0FBSztJQUVyQixJQUFBLGlCQUFpQixFQUFFLFVBQVU7SUFDN0IsSUFBQSxnQkFBZ0IsRUFBRSxZQUFZO0lBRTlCLElBQUEsVUFBVSxFQUFFLFFBQVE7SUFDcEIsSUFBQSxTQUFTLEVBQUUsT0FBTztJQUVsQixJQUFBLGtCQUFrQixFQUFFLEtBQUs7SUFDekIsSUFBQSxrQkFBa0IsRUFBRSxLQUFLO0tBQzVCLENBQUM7SUFFRixNQUFNLGFBQWEsR0FBeUI7SUFDeEMsSUFBQSxHQUFHLGFBQWE7SUFDaEIsSUFBQSxlQUFlLEVBQUUsS0FBSztLQUN6QixDQUFDO0lBR0YsTUFBTSxhQUFhLEdBQXlCLEVBQUUsR0FBRyxhQUFhLEVBQUUsQ0FBQztJQUNqRSxNQUFNLGFBQWEsR0FBeUIsRUFBRSxHQUFHLGFBQWEsRUFBRSxDQUFDO0lBRWpFLE1BQU0sYUFBYSxHQUF5QjtJQUN4QyxJQUFBLEdBQUcsYUFBYTtJQUNoQixJQUFBLGNBQWMsRUFBRSxLQUFLO0tBQ3hCLENBQUM7SUFFRixNQUFNLGFBQWEsR0FBeUI7SUFDeEMsSUFBQSxHQUFHLGFBQWE7SUFDaEIsSUFBQSxjQUFjLEVBQUUsS0FBSztLQUN4QixDQUFDO0lBRUYsTUFBTSxhQUFhLEdBQXlCO0lBQ3hDLElBQUEsR0FBRyxhQUFhO0lBQ2hCLElBQUEsZUFBZSxFQUFFLEtBQUs7SUFFdEIsSUFBQSxrQkFBa0IsRUFBRSxLQUFLO0lBQ3pCLElBQUEsa0JBQWtCLEVBQUUsS0FBSztLQUM1QixDQUFDO0lBRUYsTUFBTSxhQUFhLEdBQXlCO0lBQ3hDLElBQUEsR0FBRyxhQUFhO0lBQ2hCLElBQUEsZUFBZSxFQUFFLEtBQUs7S0FDekIsQ0FBQztJQUlGLE1BQU0sWUFBWSxHQUFHO0lBQ2pCLElBQUEsR0FBRyxFQUFFLGVBQWU7SUFDcEIsSUFBQSxHQUFHLEVBQUUsZUFBZTtLQUNkLENBQUM7SUFFWCxNQUFNLFVBQVUsR0FBRztJQUNmLElBQUEsR0FBRyxFQUFFLGFBQWE7SUFDbEIsSUFBQSxHQUFHLEVBQUUsYUFBYTtLQUNaLENBQUM7SUFFWCxNQUFNLFVBQVUsR0FBRztJQUNmLElBQUEsR0FBRyxFQUFFLGFBQWE7SUFDbEIsSUFBQSxHQUFHLEVBQUUsYUFBYTtLQUNaLENBQUM7SUFFWCxNQUFNLFVBQVUsR0FBRztJQUNmLElBQUEsR0FBRyxFQUFFLGFBQWE7SUFDbEIsSUFBQSxHQUFHLEVBQUUsYUFBYTtLQUNaLENBQUM7SUFFWCxNQUFNLFVBQVUsR0FBRztJQUNmLElBQUEsR0FBRyxFQUFFLGFBQWE7SUFDbEIsSUFBQSxHQUFHLEVBQUUsYUFBYTtLQUNaLENBQUM7SUFFWCxNQUFNLFlBQVksR0FBRztJQUNqQixJQUFBLGVBQWUsRUFBRSxZQUFZO0lBQzdCLElBQUEsYUFBYSxFQUFFLFVBQVU7SUFDekIsSUFBQSxhQUFhLEVBQUUsVUFBVTtJQUN6QixJQUFBLGFBQWEsRUFBRSxVQUFVO0lBQ3pCLElBQUEsYUFBYSxFQUFFLFVBQVU7S0FDbkI7O0lDdmNKLFNBQVUsVUFBVSxDQUFDLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQWMsRUFBQTtRQUN0RSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFLLEVBQUcsWUFBWSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3RixJQUFBLE1BQU0sVUFBVSxHQUFHLGVBQWUsQ0FBQyxPQUFPLENBQUMsQ0FBQzs7O0lBSTVDLElBQUEsTUFBTSxZQUFZLEdBQUdKLENBQU0sQ0FBZ0IsSUFBSSxDQUFDLENBQUM7SUFFakQsSUFBQSxNQUFNLGFBQWEsSUFBSSxPQUFPLElBQUksSUFBSSxDQUFDLENBQUM7Ozs7UUFLeENMLENBQVMsQ0FBQyxNQUFLO1lBQ1gsSUFBSSxDQUFDLGFBQWEsRUFBRTtJQUNoQixZQUFBLE1BQU0sT0FBTyxHQUFHLFVBQVUsRUFBRSxDQUFDO2dCQUM3QixPQUFPLENBQUMsTUFBTSxDQUFDLGFBQWEsS0FBSyxPQUFPLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQztnQkFFbkQsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFO29CQUNqQixZQUFZLENBQUMsT0FBTyxHQUFHLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxDQUFDO29CQUVyQyxNQUFNLE1BQU0sR0FBRyxVQUFVLENBQUMsY0FBYyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELGdCQUFBLE9BQU8sTUFBTSxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDckMsYUFBQTtJQUNKLFNBQUE7SUFFTCxLQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQTtJQUVqQyxJQUFBLE1BQU0sY0FBYyxHQUFHUyxHQUFXLENBQUMsTUFBSztZQUNwQyxPQUFPLENBQUMsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsT0FBTyxJQUFJLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ3BFLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFUCxJQUFBLE1BQU0sZ0JBQWdCLEdBQUdBLEdBQVcsQ0FBQyxNQUFLO0lBQ3RDLFFBQUEsTUFBTSxPQUFPLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDN0IsT0FBTyxPQUFPLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxPQUFPLEdBQUcsY0FBYyxFQUFFLENBQUMsQ0FBQTtTQUMxRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRVAsSUFBQSxPQUFPLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLENBQUM7SUFDaEQ7O0lDREE7SUFDQTtJQUVBOzs7OztJQUtHO0lBQ2EsU0FBQSxtQkFBbUIsQ0FBdUMsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLGVBQWUsRUFBRSxHQUFHLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxjQUFjLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxHQUFHLEVBQUUsbUJBQW1CLEVBQUUsRUFBRSxFQUFFLGdCQUFnQixFQUFFLEdBQUcsRUFBRSxrQkFBa0IsRUFBRSxJQUFJLEVBQUUsRUFBd0MsRUFBQTtRQUVuUyxFQUFFLEtBQUssUUFBUSxDQUFDO1FBRWhCLE1BQU0sRUFBRSx1QkFBdUIsRUFBRSx3QkFBd0IsRUFBRSxHQUFHLG1CQUFtQixDQUF1QixFQUFFLENBQUMsQ0FBQztJQUU1RyxJQUFBLE1BQU0sZUFBZSxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQy9DLElBQUEsTUFBTSxjQUFjLEdBQUcsaUJBQWlCLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDOUMsSUFBQSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QyxJQUFBLE1BQU0sY0FBYyxHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzlDLElBQUEsTUFBTSxtQkFBbUIsR0FBRyxlQUFlLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakQsSUFBQSxNQUFNLHFCQUFxQixHQUFHLGVBQWUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNwRCxJQUFBLE1BQU0sc0JBQXNCLEdBQUcsZUFBZSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBR25ELE9BQU87SUFDSCxRQUFBLGdCQUFnQixFQUFFLEVBQUU7SUFDcEIsUUFBQSx3QkFBd0IsRUFBRUEsR0FBVyxDQUFDLENBQUMsS0FBaUQsS0FBZ0Q7SUFFcEksWUFBQSxNQUFNLFNBQVMsR0FBRyxDQUFDLENBQWdCLEtBQUk7O0lBRW5DLGdCQUFBLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsT0FBTzt3QkFDdEIsT0FBTztJQUVYLGdCQUFBLE1BQU0sSUFBSSxHQUFHLHVCQUF1QixFQUFFLENBQUM7SUFDdkMsZ0JBQUEsTUFBTSxtQkFBbUIsR0FBRyxzQkFBc0IsRUFBRSxDQUFDO0lBQ3JELGdCQUFBLE1BQU0sZ0JBQWdCLEdBQUcsbUJBQW1CLEVBQUUsQ0FBQztJQUMvQyxnQkFBQSxNQUFNLGtCQUFrQixHQUFHLHFCQUFxQixFQUFFLENBQUM7b0JBRW5ELE1BQU0scUJBQXFCLElBQUksbUJBQW1CLElBQUksT0FBTyxJQUFJLG1CQUFtQixJQUFJLFFBQVEsQ0FBQyxDQUFDO29CQUNsRyxNQUFNLHNCQUFzQixJQUFJLG1CQUFtQixJQUFJLFFBQVEsSUFBSSxtQkFBbUIsSUFBSSxRQUFRLENBQUMsQ0FBQztvQkFFcEcsUUFBUSxDQUFDLENBQUMsR0FBRzt3QkFDVCxLQUFLLFNBQVMsRUFBRTtJQUNaLHdCQUFBLE1BQU0sUUFBUSxJQUFJLElBQUksRUFBRSxnQkFBZ0IsS0FBSyxVQUFVLEdBQUcsZ0JBQWdCLEdBQUcsaUJBQWlCLENBQUMsQ0FBQzs0QkFDaEcsTUFBTSxnQkFBZ0IsSUFBSSxDQUFDLGdCQUFnQixLQUFLLElBQUksRUFBRSxnQkFBZ0IsS0FBSyxVQUFVLEdBQUcscUJBQXFCLEdBQUcsc0JBQXNCLENBQUMsQ0FBQyxDQUFDO0lBQ3pJLHdCQUFBLElBQUksZ0JBQWdCLEVBQUU7SUFDbEIsNEJBQUEsSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO0lBQzVCLGdDQUFBLGNBQWMsRUFBRSxDQUFDO0lBQ3BCLDZCQUFBO0lBQ0ksaUNBQUE7SUFDRCxnQ0FBQSxjQUFjLEVBQUUsQ0FBQztJQUNwQiw2QkFBQTtnQ0FDRCxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7Z0NBQ25CLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN2Qix5QkFBQTs0QkFDRCxNQUFNO0lBQ1QscUJBQUE7d0JBQ0QsS0FBSyxXQUFXLEVBQUU7SUFDZCx3QkFBQSxNQUFNLFFBQVEsSUFBSSxJQUFJLEVBQUUsZ0JBQWdCLEtBQUssVUFBVSxHQUFHLGdCQUFnQixHQUFHLGlCQUFpQixDQUFDLENBQUM7NEJBQ2hHLE1BQU0sZ0JBQWdCLElBQUksQ0FBQyxnQkFBZ0IsS0FBSyxJQUFJLEVBQUUsZ0JBQWdCLEtBQUssVUFBVSxHQUFHLHFCQUFxQixHQUFHLHNCQUFzQixDQUFDLENBQUMsQ0FBQztJQUN6SSx3QkFBQSxJQUFJLGdCQUFnQixFQUFFO0lBQ2xCLDRCQUFBLElBQUksSUFBSSxHQUFHLFFBQVEsQ0FBQyxLQUFLLEtBQUssRUFBRTtJQUM1QixnQ0FBQSxjQUFjLEVBQUUsQ0FBQztJQUNwQiw2QkFBQTtJQUNJLGlDQUFBO0lBQ0QsZ0NBQUEsY0FBYyxFQUFFLENBQUM7SUFDcEIsNkJBQUE7Z0NBQ0QsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO2dDQUNuQixDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDdkIseUJBQUE7NEJBQ0QsTUFBTTtJQUNULHFCQUFBO3dCQUVELEtBQUssV0FBVyxFQUFFO0lBQ2Qsd0JBQUEsTUFBTSxRQUFRLElBQUksSUFBSSxFQUFFLGlCQUFpQixLQUFLLFlBQVksR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsQ0FBQyxDQUFDOzRCQUNuRyxNQUFNLGdCQUFnQixJQUFJLENBQUMsZ0JBQWdCLEtBQUssSUFBSSxFQUFFLGlCQUFpQixLQUFLLFlBQVksR0FBRyxzQkFBc0IsR0FBRyxxQkFBcUIsQ0FBQyxDQUFDLENBQUM7SUFDNUksd0JBQUEsSUFBSSxnQkFBZ0IsRUFBRTtJQUNsQiw0QkFBQSxJQUFJLElBQUksR0FBRyxRQUFRLENBQUMsS0FBSyxLQUFLLEVBQUU7SUFDNUIsZ0NBQUEsY0FBYyxFQUFFLENBQUM7SUFDcEIsNkJBQUE7SUFDSSxpQ0FBQTtJQUNELGdDQUFBLGNBQWMsRUFBRSxDQUFDO0lBQ3BCLDZCQUFBO2dDQUNELENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQ0FDbkIsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3ZCLHlCQUFBOzRCQUNELE1BQU07SUFDVCxxQkFBQTt3QkFDRCxLQUFLLFlBQVksRUFBRTtJQUNmLHdCQUFBLE1BQU0sUUFBUSxJQUFJLElBQUksRUFBRSxpQkFBaUIsS0FBSyxZQUFZLEdBQUcsaUJBQWlCLEdBQUcsZ0JBQWdCLENBQUMsQ0FBQzs0QkFDbkcsTUFBTSxnQkFBZ0IsSUFBSSxDQUFDLGdCQUFnQixLQUFLLElBQUksRUFBRSxpQkFBaUIsS0FBSyxZQUFZLEdBQUcsc0JBQXNCLEdBQUcscUJBQXFCLENBQUMsQ0FBQyxDQUFDO0lBQzVJLHdCQUFBLElBQUksZ0JBQWdCLEVBQUU7SUFDbEIsNEJBQUEsSUFBSSxJQUFJLEdBQUcsUUFBUSxDQUFDLEtBQUssS0FBSyxFQUFFO0lBQzVCLGdDQUFBLGNBQWMsRUFBRSxDQUFDO0lBQ3BCLDZCQUFBO0lBQ0ksaUNBQUE7SUFDRCxnQ0FBQSxjQUFjLEVBQUUsQ0FBQztJQUNwQiw2QkFBQTtnQ0FDRCxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7Z0NBQ25CLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQztJQUN2Qix5QkFBQTs0QkFDRCxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7NEJBQ25CLENBQUMsQ0FBQyxlQUFlLEVBQUUsQ0FBQzs0QkFDcEIsTUFBTTtJQUNULHFCQUFBO0lBQ0Qsb0JBQUEsS0FBSyxNQUFNOzRCQUNQLElBQUksQ0FBQyxrQkFBa0IsRUFBRTtJQUNyQiw0QkFBQSxlQUFlLEVBQUUsQ0FBQztnQ0FDbEIsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO2dDQUNuQixDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7SUFDdkIseUJBQUE7NEJBQ0QsTUFBTTtJQUVWLG9CQUFBLEtBQUssS0FBSzs0QkFDTixJQUFJLENBQUMsa0JBQWtCLEVBQUU7SUFDckIsNEJBQUEsY0FBYyxFQUFFLENBQUM7Z0NBQ2pCLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQztnQ0FDbkIsQ0FBQyxDQUFDLGVBQWUsRUFBRSxDQUFDO0lBQ3ZCLHlCQUFBOzRCQUNELE1BQU07SUFDYixpQkFBQTtJQUNMLGFBQUMsQ0FBQztnQkFDRixPQUFPLHdCQUF3QixDQUFDLGNBQWMsQ0FBdUIsRUFBRSxTQUFTLEVBQUUsRUFBRSxLQUFLLENBQUMsQ0FBQyxDQUFBO2FBQzlGLEVBQUUsRUFBRSxDQUFDO1NBQ1QsQ0FBQTtJQUdMLENBQUM7SUFnRUQ7Ozs7SUFJRzthQUNhLHNCQUFzQixDQUF1QyxFQUFFLG1CQUFtQixFQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLEVBQTJDLEVBQUE7Ozs7O0lBTzFNLElBQUEsTUFBTSxDQUFDLGdCQUFnQixFQUFFLG1CQUFtQixFQUFFLG1CQUFtQixDQUFDLEdBQUcsUUFBUSxDQUFnQixJQUFJLENBQUMsQ0FBQztJQUNuRyxJQUFBLFVBQVUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsSUFBSSxJQUFJLEVBQUUsUUFBUSxFQUFFLE1BQUssRUFBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDO0lBQzdKLElBQUEsTUFBTSxtQkFBbUIsR0FBR0osQ0FBTSxDQUE0QyxFQUFFLENBQUMsQ0FBQztRQUNsRixNQUFNLENBQUMsZ0JBQWdCLEVBQUUsbUJBQW1CLENBQUMsR0FBRyxRQUFRLENBQWlCLEtBQUssQ0FBQyxDQUFDOzs7O1FBS2hGLE1BQU0sR0FBRyxZQUFZLEVBQUUsWUFBWSxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDOzs7O1FBS3ZELE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxvQkFBb0IsQ0FBQyxHQUFHLFFBQVEsQ0FBZ0IsSUFBSSxDQUFDLENBQUM7UUFDaEZELENBQWUsQ0FBQyxNQUFLO1lBQ2pCLElBQUksaUJBQWlCLEtBQUssSUFBSSxFQUFFO0lBQzVCLFlBQUEsbUJBQW1CLENBQUMsU0FBUyxLQUFLLENBQUMsU0FBUyxJQUFJLEVBQUUsSUFBSSxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7Z0JBQzFFLG9CQUFvQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzlCLFNBQUE7SUFDTCxLQUFDLEVBQUUsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUM7UUFHeEIsTUFBTSxnQkFBZ0IsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLE9BQWUsRUFBRSxPQUFlLEtBQUk7SUFDNUUsUUFBQSxJQUFJLE9BQWUsQ0FBQzs7O0lBR3BCLFFBQUEsT0FBTyxHQUFHLE9BQU8sQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDbkMsUUFBQSxPQUFPLEdBQUcsT0FBTyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUVsQyxRQUFBLElBQUksUUFBUTtnQkFDUixPQUFPLEdBQUcsUUFBUSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUE7O0lBRTVDLFlBQUEsT0FBTyxHQUFHLE9BQU8sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBRS9FLFFBQUEsT0FBTyxPQUFPLENBQUM7SUFDbkIsS0FBQyxDQUFDLENBQUM7UUFFSCxNQUFNLG1CQUFtQixHQUFHLGlCQUFpQixDQUFDLENBQUMsR0FBVyxFQUFFLEdBQTZDLEtBQUk7WUFFekcsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLElBQUksT0FBTyxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRTtnQkFDekQsT0FBTyxnQkFBZ0IsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFDLFNBQUE7WUFFRCxPQUFRLEdBQXlCLEdBQUksR0FBeUIsQ0FBQztJQUNuRSxLQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sbUJBQW1CLEdBQUcsaUJBQWlCLENBQUMsQ0FBQyxHQUFXLEVBQUUsR0FBNkMsS0FBSTtZQUV6RyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVEsSUFBSSxPQUFPLEdBQUcsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFOzs7SUFHekQsWUFBQSxPQUFPLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDbkUsU0FBQTtZQUVELE9BQVEsR0FBeUIsR0FBSSxHQUF5QixDQUFDO0lBQ25FLEtBQUMsQ0FBQyxDQUFDO0lBRUgsSUFBQSxNQUFNLFVBQVUsR0FBRyxlQUFlLENBQUMsV0FBVyxDQUFDLENBQUM7UUFHaEQsTUFBTSwyQkFBMkIsR0FBc0RLLEdBQVcsQ0FBQyxVQUFVLEVBQUUsR0FBRyxLQUFLLEVBQThDLEVBQUE7SUFFakssUUFBQSxNQUFNLGtCQUFrQixHQUFHLENBQUMsRUFBb0IsS0FBSSxFQUFHLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQSxFQUFFLENBQUM7SUFDNUUsUUFBQSxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBbUIsS0FBSTtJQUM3QyxZQUFBLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDN0IsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3hCLFNBQUMsQ0FBQztJQUVGLFFBQUEsTUFBTSxTQUFTLEdBQUcsQ0FBQyxDQUFnQixLQUFJO0lBQ25DLFlBQUEsSUFBSSxVQUFVLEVBQUU7b0JBQ1osT0FBTztJQUVYLFlBQUEsTUFBTSxTQUFTLEdBQUcsWUFBWSxFQUFFLENBQUM7SUFFakMsWUFBQSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDOztJQUdsQixZQUFBLElBQUksQ0FBQyxDQUFDLE9BQU8sSUFBSSxDQUFDLENBQUMsT0FBTztvQkFDdEIsT0FBTztnQkFFWCxJQUFJLENBQUMsU0FBUyxJQUFJLENBQUMsQ0FBQyxHQUFHLEtBQUssV0FBVyxFQUFFOztJQUVyQyxnQkFBQSxtQkFBbUIsQ0FBQyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztvQkFDM0YsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO29CQUNuQixDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7b0JBQ3BCLE9BQU87SUFDVixhQUFBOzs7OztJQU1ELFlBQUEsTUFBTSxjQUFjLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDcEUsWUFBQSxJQUFJLGNBQWMsRUFBRTtJQUVoQixnQkFBQSxJQUFJLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQyxtQkFBbUIsRUFBRSxJQUFJLEVBQUUsRUFBRSxJQUFJLEVBQUUsQ0FBQyxNQUFNLElBQUksQ0FBQyxFQUFFLENBS25FO0lBQ0kscUJBQUE7d0JBRUQsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDO3dCQUNuQixDQUFDLENBQUMsZUFBZSxFQUFFLENBQUM7Ozs7SUFLcEIsb0JBQUEsSUFBSSxDQUFDLFNBQVM7NEJBQ1Ysb0JBQW9CLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDakMsaUJBQUE7SUFDSixhQUFBO0lBRUwsU0FBQyxDQUFDO0lBRUYsUUFBQSxPQUFPLGNBQWMsQ0FBdUIsRUFBRSxTQUFTLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEdBQUcsRUFBRSxLQUFLLENBQUMsQ0FBQztTQUM1RyxFQUFFLEVBQUUsQ0FBQyxDQUFDOztRQUdQVCxDQUFTLENBQUMsTUFBSztJQUNYLFFBQUEsSUFBSSxnQkFBZ0IsSUFBSSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsTUFBTSxFQUFFO0lBSXhELFlBQUEsTUFBTSxvQkFBb0IsR0FBRyxZQUFZLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDLENBQUM7Z0JBRTlHLElBQUksb0JBQW9CLEdBQUcsQ0FBQyxFQUFFOzs7b0JBRzFCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzdCLGFBQUE7SUFDSSxpQkFBQTtvQkFDRCxtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUUzQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBd0JFOztvQkFJRixJQUFJLHNCQUFzQixHQUFrQixJQUFJLENBQUM7b0JBQ2pELElBQUksb0JBQW9CLEdBQUcsb0JBQW9CLENBQUM7O29CQUdoRCxJQUFJLHVCQUF1QixHQUFrQixJQUFJLENBQUM7b0JBQ2xELElBQUkscUJBQXFCLEdBQUcsb0JBQW9CLENBQUM7SUFFakQsZ0JBQUEsTUFBTSxhQUFhLEdBQUcsQ0FBQyxDQUFTLEtBQUk7SUFDaEMsb0JBQUEsSUFBSSxzQkFBc0IsSUFBSSxJQUFJLElBQUksQ0FBQyxHQUFHLHNCQUFzQixFQUFFOzRCQUM5RCxzQkFBc0IsR0FBRyxDQUFDLENBQUM7NEJBQzNCLG9CQUFvQixHQUFHLENBQUMsQ0FBQztJQUM1QixxQkFBQTtJQUNELG9CQUFBLElBQUksQ0FBQyx1QkFBdUIsSUFBSSxJQUFJLElBQUksQ0FBQyxHQUFHLHVCQUF1QixLQUFLLENBQUMsSUFBSSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxFQUFFOzRCQUNuRyx1QkFBdUIsR0FBRyxDQUFDLENBQUM7NEJBQzVCLHFCQUFxQixHQUFHLENBQUMsQ0FBQztJQUM3QixxQkFBQTtJQUNMLGlCQUFDLENBQUE7b0JBRUQsSUFBSSxDQUFDLEdBQUcsb0JBQW9CLENBQUM7SUFDN0IsZ0JBQUEsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLG1CQUFtQixDQUFDLGdCQUFnQixFQUFFLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTt3QkFDekYsYUFBYSxDQUFDLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUM1RCxvQkFBQSxFQUFFLENBQUMsQ0FBQztJQUNQLGlCQUFBO29CQUVELENBQUMsR0FBRyxvQkFBb0IsQ0FBQztvQkFDekIsT0FBTyxDQUFDLEdBQUcsbUJBQW1CLENBQUMsT0FBTyxDQUFDLE1BQU0sSUFBSSxtQkFBbUIsQ0FBQyxnQkFBZ0IsRUFBRSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7d0JBQ3pILGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDNUQsb0JBQUEsRUFBRSxDQUFDLENBQUM7SUFDUCxpQkFBQTtvQkFFRCxJQUFJLHVCQUF1QixLQUFLLElBQUk7d0JBQ2hDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMscUJBQXFCLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQzt5QkFDMUUsSUFBSSxzQkFBc0IsS0FBSyxJQUFJO3dCQUNwQyxRQUFRLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsYUFBYSxDQUFDLENBQUM7SUFDakYsYUFBQTtJQUNKLFNBQUE7SUFDTCxLQUFDLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFFdkIsTUFBTSwyQkFBMkIsR0FBR1MsR0FBVyxDQUE4QixDQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxLQUFJO1lBRTdGVCxDQUFTLENBQUMsTUFBSztJQUNYLFlBQUEsSUFBSSxJQUFJLEVBQUU7Ozs7SUFLTixnQkFBQSxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3pGLGdCQUFBLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO29CQUMzSSxJQUFJLFdBQVcsR0FBRyxDQUFDLEVBQUU7d0JBQ2pCLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxXQUFXLEdBQUcsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUMzRixpQkFBQTtJQUNJLHFCQUFBO0lBQ0Qsb0JBQUEsbUJBQW1CLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLGFBQWEsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO0lBQ3RGLGlCQUFBO0lBRUQsZ0JBQUEsT0FBTyxNQUFLOzs7SUFHUixvQkFBQSxNQUFNLFdBQVcsR0FBRyxZQUFZLENBQUMsbUJBQW1CLENBQUMsT0FBTyxFQUFFLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3pGLG9CQUFBLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxHQUFHLENBQUMsSUFBSSxtQkFBbUIsQ0FBQyxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsYUFBYSxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO3dCQUUzSSxJQUFJLFdBQVcsSUFBSSxDQUFDLEVBQUU7NEJBQ2xCLG1CQUFtQixDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3RELHFCQUFBO0lBQ0wsaUJBQUMsQ0FBQTtJQUNKLGFBQUE7SUFDTCxTQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBRVgsT0FBTztTQUVWLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFFUCxPQUFPO1lBQ0gsMkJBQTJCO1lBQzNCLDJCQUEyQjtJQUUzQixRQUFBLG1CQUFtQixFQUFFO2dCQUNqQixnQkFBZ0I7Z0JBQ2hCLGdCQUFnQjtJQUNuQixTQUFBO1NBQ0osQ0FBQTtJQUNMLENBQUM7SUFHRDs7Ozs7Ozs7O0lBU0c7YUFDYSxZQUFZLENBQTZDLEtBQVUsRUFBRSxNQUFTLEVBQUUsVUFBYSxFQUFBO1FBQ3pHLElBQUksVUFBVSxHQUFHLENBQUMsQ0FBQztJQUNuQixJQUFBLElBQUksU0FBUyxHQUFHLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO1FBQ2pDLE9BQU8sVUFBVSxJQUFJLFNBQVMsRUFBRTtZQUM1QixNQUFNLFNBQVMsR0FBRyxDQUFDLFNBQVMsR0FBRyxVQUFVLEtBQUssQ0FBQyxDQUFDO1lBQ2hELE1BQU0sZ0JBQWdCLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUU5RCxJQUFJLGdCQUFnQixHQUFHLENBQUMsRUFBRTtJQUN0QixZQUFBLFVBQVUsR0FBRyxTQUFTLEdBQUcsQ0FBQyxDQUFDO0lBQzlCLFNBQUE7aUJBQ0ksSUFBSSxnQkFBZ0IsR0FBRyxDQUFDLEVBQUU7SUFDM0IsWUFBQSxTQUFTLEdBQUcsU0FBUyxHQUFHLENBQUMsQ0FBQztJQUM3QixTQUFBO0lBQ0ksYUFBQTtJQUNELFlBQUEsT0FBTyxTQUFTLENBQUM7SUFDcEIsU0FBQTtJQUNKLEtBQUE7SUFFRCxJQUFBLE9BQU8sQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDO0lBQzNCOztJQ2pjQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQTRCRztJQUNHLFNBQVUsaUJBQWlCLENBQXlFLGdCQUEyRCxFQUFBO1FBRWpLLElBQUksRUFBRSxjQUFjLEVBQUUsRUFBRSxZQUFZLEVBQUUsZ0JBQWdCLEVBQUUscUJBQXFCLEVBQUUsRUFBRSxlQUFlLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxxQkFBcUIsRUFBRSxFQUFFLEdBQUcsZ0JBQWdCLENBQUM7UUFFM0ssWUFBWSxLQUFLLENBQUMsQ0FBQztJQUNuQixJQUFBLE1BQU0sc0JBQXNCLEdBQUcsaUJBQWlCLENBQUMsZ0JBQWdCLEtBQUssTUFBSyxHQUFJLENBQUMsQ0FBQyxDQUFDO0lBQ2xGOzs7Ozs7OztJQVFrQjs7O1FBSWxCLE1BQU0sQ0FBQyxnQkFBZ0IsRUFBRSxpQkFBaUIsQ0FBQyxHQUFHLGVBQWUsQ0FBZ0IscUJBQXFCLEVBQUVTLEdBQVcsQ0FBQyxNQUFRLEVBQUEsT0FBTyxZQUFZLElBQUksQ0FBQyxDQUFBLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBQ3pKLE1BQU0sZ0JBQWdCLEdBQUdBLEdBQVcsQ0FBQyxDQUFDLE9BQW1ELEVBQUUsbUJBQTRCLEtBQUk7SUFDdkgsUUFBQSxpQkFBaUIsQ0FBQyxDQUFDLFNBQVMsS0FBSTtnQkFDNUIsSUFBSSxTQUFTLEdBQUcsU0FBUyxDQUFDO2dCQUUxQixJQUFJLE9BQU8sT0FBTyxLQUFLLFVBQVU7SUFDN0IsZ0JBQUEsU0FBUyxHQUFHLE9BQU8sQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLENBQUM7O29CQUV2QyxTQUFTLEdBQUcsT0FBTyxDQUFDO0lBRXhCLFlBQUEsU0FBUyxHQUFHLFdBQVcsQ0FBQyxTQUFTLENBQUMsQ0FBQztnQkFFbkMsSUFBSSxTQUFTLElBQUksU0FBUyxFQUFFO29CQUN4QixNQUFNLFNBQVMsR0FBRyxTQUFTLElBQUksSUFBSSxHQUFHLElBQUksR0FBRyxnQkFBZ0IsQ0FBQyxlQUFlLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsQ0FBQzs7OztJQU14RyxnQkFBQSxJQUFJLFNBQVMsSUFBSSxJQUFJLElBQUksbUJBQW1CO0lBQ3hDLG9CQUFBLFNBQVMsQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUM7SUFFckMsYUFBQTtJQUVELFlBQUEsT0FBTyxTQUFTLENBQUM7SUFDckIsU0FBQyxDQUFDLENBQUM7U0FFTixFQUFFLEVBQUUsQ0FBQyxDQUFDOzs7O1FBS1AsTUFBTSxnQkFBZ0IsR0FBRyxrQkFBa0IsQ0FBeUY7SUFDaEksUUFBQSxlQUFlLEVBQUU7Z0JBQ2Isd0JBQXdCO2dCQUN4QixxQkFBcUIsRUFBRSxpQkFBaUIsQ0FBZ0MsQ0FBQyxPQUFPLEVBQUUsU0FBUyxLQUFJLEVBQUcscUJBQXFCLEdBQUcsT0FBTyxFQUFFLFNBQVMsQ0FBQyxDQUFDLENBQUMsb0JBQW9CLEVBQUUsQ0FBQyxFQUFFLENBQUM7SUFDNUssU0FBQTtJQUNKLEtBQUEsQ0FBQyxDQUFDO0lBRUgsSUFBQSxNQUFNLEVBQUUsZUFBZSxFQUFFLEdBQUcsZ0JBQWdCLENBQUM7SUFFN0MsSUFBQSxNQUFNLEVBQUUsV0FBVyxFQUFFLG9CQUFvQixFQUFFLEdBQUcsZUFBZSxDQUFpRixFQUFFLFlBQVksRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRSxVQUFVLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxVQUFVLEVBQUUsQ0FBQyxDQUFDO0lBRXhQLElBQUEsTUFBTSxzQkFBc0IsR0FBR0EsR0FBVyxDQUFrRSxDQUFDLGVBQWUsS0FBSTtZQUU1SCxNQUFNLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLEVBQUUsR0FBRyxlQUFlLENBQUM7WUFFOUhULENBQVMsQ0FBQyxNQUFLO0lBQ1gsWUFBQSxvQkFBb0IsRUFBRSxDQUFDO0lBQzNCLFNBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFBO0lBR2QsUUFBQSxNQUFNLFVBQVUsR0FBRyxlQUFlLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUN0RCxRQUFBLE1BQU0sU0FBUyxHQUFHUyxHQUFXLENBQUMsTUFBSztJQUMvQixZQUFBLE1BQU0sRUFBRSxHQUFHLFVBQVUsRUFBRSxDQUFDO0lBQ3hCLFlBQUEsSUFBSSxFQUFFLEVBQUU7SUFDSixnQkFBQSxFQUFFLEVBQUUsQ0FBQztJQUNSLGFBQUE7SUFDSSxpQkFBQTtJQUNELGdCQUFBLE1BQU0sT0FBTyxHQUFHLFVBQVUsRUFBc0MsQ0FBQztJQUNqRSxnQkFBQSxJQUFJLE9BQU87SUFDUCxvQkFBQSxPQUFPLENBQUMsS0FBSyxJQUFJLENBQUM7SUFDekIsYUFBQTthQUNKLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDUDs7Ozs7Ozs7OztJQVVTO1lBRVQsTUFBTSxxQkFBcUIsR0FBRyxpQkFBaUIsQ0FBQyxDQUFDLE9BQWdCLEVBQUUsWUFBaUMsS0FBSTtJQUNwRyxZQUFBLElBQUksT0FBTyxFQUFFO0lBQ1QsZ0JBQUEsZ0JBQWdCLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQ2xDLGFBQUE7SUFDTCxTQUFDLENBQUMsQ0FBQztJQUNILFFBQUEsTUFBTSxFQUFFLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxHQUFHLFdBQVcsQ0FBZSxFQUFFLHFCQUFxQixFQUFFLFdBQVcsRUFBRUEsR0FBVyxDQUFDLE1BQWtCLEVBQUEsT0FBTyxDQUFDLFVBQVUsRUFBRSxFQUFFLGFBQWEsTUFBTSxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUUzTSxRQUFBLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxFQUFFLFdBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUM3RCxNQUFNLGFBQWEsR0FBR0osQ0FBTSxDQUFzQixFQUFFLEdBQUcsRUFBRSxXQUFXLEVBQUUsR0FBRyxFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsaUJBQWlCLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztZQUVySCxlQUFlLENBQUM7SUFDNUIsWUFBQSxZQUFZLEVBQUU7b0JBQ1YsS0FBSztvQkFDTCxLQUFLLEVBQUUsRUFBRSxHQUFHLEtBQUssRUFBRSxRQUFRLEVBQUUsYUFBYSxDQUFDLE9BQU8sRUFBc0U7SUFDeEgsZ0JBQUEsT0FBTyxFQUFFOzt3QkFFTCxTQUFTO3dCQUNULFVBQVU7d0JBQ1YsTUFBTSxFQUFFLENBQUMsQ0FBQyxNQUFNO3dCQUNoQixPQUFPO0lBQ1YsaUJBQUE7SUFDSixhQUFBO0lBQ0osU0FBQSxFQUFFO1lBQ0hMLENBQVMsQ0FBQyxNQUFLO0lBQ1gsWUFBQSxJQUFJLFFBQVE7b0JBQ1Isc0JBQXNCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdEMsU0FBQyxFQUFFLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUE7WUFDckIsU0FBUywyQkFBMkIsQ0FBQyxLQUF5QyxFQUFBO2dCQUMxRSxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxRQUFRLElBQUksSUFBSSxDQUFDLENBQUM7Z0JBQ3ZDLE9BQU8sY0FBYyxDQUFlLGdCQUFnQixDQUFDLEVBQUUsUUFBUSxFQUFFLFFBQVEsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ2pHO1lBRUQsT0FBTztnQkFDSCwyQkFBMkI7SUFDM0IsWUFBQSxjQUFjLEVBQUU7b0JBQ1osVUFBVTtvQkFDVixRQUFRO29CQUNSLFdBQVc7SUFDZCxhQUFBO2FBQ0osQ0FBQTtJQUNMLEtBQUMsRUFBRSwyQkFBMEIsQ0FBQyxDQUFDO0lBRS9CLElBQUEsTUFBTSxTQUFTLEdBQUdTLEdBQVcsQ0FBQyxNQUFLO0lBQy9CLFFBQUEsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFBLDJCQUFBLENBQTZCLENBQUMsQ0FBQztJQUMzQyxRQUFBLE1BQU0sS0FBSyxHQUFHLGdCQUFnQixFQUFFLENBQUM7WUFDakMsSUFBSSxLQUFLLElBQUksSUFBSTtJQUNiLFlBQUEsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUUsT0FBTyxDQUFDLFNBQVMsSUFBSSxDQUFDOztJQUU5RSxZQUFBLGdCQUFnQixDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNwQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRVAsT0FBTztZQUNILHNCQUFzQjtZQUN0QixlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLFFBQVEsRUFBRTtJQUN4RSxRQUFBLGNBQWMsRUFBRTtnQkFDWixnQkFBZ0I7Z0JBQ2hCLGdCQUFnQjtnQkFDaEIsU0FBUztJQUNaLFNBQUE7U0FDSixDQUFDO0lBQ04sQ0FBQztJQUVEOzs7SUFHRzs7SUN2Ukg7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsU0FBUyxDQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUU7SUFDbEMsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDaEIsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUM3QjtJQUNBLEVBQUUsS0FBSyxLQUFLLEtBQUssR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNuQyxFQUFFLE9BQU8sRUFBRSxLQUFLLEdBQUcsTUFBTSxFQUFFO0lBQzNCLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxHQUFHO0lBQ0gsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmOztJQ2pCQTtJQUNBLElBQUksV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLO0lBQzVCLElBQUksWUFBWSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7QUFDL0I7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFVBQVUsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFO0lBQ2xDLEVBQUUsT0FBTyxLQUFLLEdBQUcsV0FBVyxDQUFDLFlBQVksRUFBRSxJQUFJLEtBQUssR0FBRyxLQUFLLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUNuRTs7SUNiQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRTtJQUNsQyxFQUFFLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQztJQUNoQixNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsTUFBTTtJQUMzQixNQUFNLFNBQVMsR0FBRyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQzdCO0lBQ0EsRUFBRSxJQUFJLEdBQUcsSUFBSSxLQUFLLFNBQVMsR0FBRyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQzVDLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxJQUFJLEVBQUU7SUFDekIsSUFBSSxJQUFJLElBQUksR0FBRyxVQUFVLENBQUMsS0FBSyxFQUFFLFNBQVMsQ0FBQztJQUMzQyxRQUFRLEtBQUssR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDNUI7SUFDQSxJQUFJLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsSUFBSSxLQUFLLENBQUMsS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDO0lBQ3pCLEdBQUc7SUFDSCxFQUFFLEtBQUssQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDO0lBQ3RCLEVBQUUsT0FBTyxLQUFLLENBQUM7SUFDZjs7SUN0QkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFlBQVksQ0FBQyxLQUFLLEVBQUU7SUFDN0IsRUFBRSxPQUFPLFdBQVcsQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUN2Qzs7SUNaQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFFBQVEsQ0FBQyxLQUFLLEVBQUUsUUFBUSxFQUFFO0lBQ25DLEVBQUUsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2hCLE1BQU0sTUFBTSxHQUFHLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNO0lBQy9DLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUM3QjtJQUNBLEVBQUUsT0FBTyxFQUFFLEtBQUssR0FBRyxNQUFNLEVBQUU7SUFDM0IsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsRUFBRSxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDekQsR0FBRztJQUNILEVBQUUsT0FBTyxNQUFNLENBQUM7SUFDaEI7O0lDaEJBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxVQUFVLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRTtJQUNuQyxFQUFFLE9BQU8sUUFBUSxDQUFDLEtBQUssRUFBRSxTQUFTLEdBQUcsRUFBRTtJQUN2QyxJQUFJLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLEdBQUcsQ0FBQyxDQUFDO0lBQ0w7O0lDaEJBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsU0FBUyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUU7SUFDaEMsRUFBRSxJQUFJLEtBQUssR0FBRyxDQUFDLENBQUM7SUFDaEIsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ3hCO0lBQ0EsRUFBRSxPQUFPLEVBQUUsS0FBSyxHQUFHLENBQUMsRUFBRTtJQUN0QixJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDcEMsR0FBRztJQUNILEVBQUUsT0FBTyxNQUFNLENBQUM7SUFDaEI7O0lDZEE7SUFDQSxJQUFJNkosU0FBTyxHQUFHLG9CQUFvQixDQUFDO0FBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGVBQWUsQ0FBQyxLQUFLLEVBQUU7SUFDaEMsRUFBRSxPQUFPLFlBQVksQ0FBQyxLQUFLLENBQUMsSUFBSSxVQUFVLENBQUMsS0FBSyxDQUFDLElBQUlBLFNBQU8sQ0FBQztJQUM3RDs7SUNaQTtJQUNBLElBQUlwRCxhQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUNuQztJQUNBO0lBQ0EsSUFBSUMsZ0JBQWMsR0FBR0QsYUFBVyxDQUFDLGNBQWMsQ0FBQztBQUNoRDtJQUNBO0lBQ0EsSUFBSSxvQkFBb0IsR0FBR0EsYUFBVyxDQUFDLG9CQUFvQixDQUFDO0FBQzVEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsSUFBSSxXQUFXLEdBQUcsZUFBZSxDQUFDLFdBQVcsRUFBRSxPQUFPLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxHQUFHLGVBQWUsR0FBRyxTQUFTLEtBQUssRUFBRTtJQUMxRyxFQUFFLE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQyxJQUFJQyxnQkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDO0lBQ3BFLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQ2hELENBQUM7O0lDakNEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxJQUFJLE9BQU8sR0FBRyxLQUFLLENBQUMsT0FBTzs7SUN2QjNCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxTQUFTLEdBQUc7SUFDckIsRUFBRSxPQUFPLEtBQUssQ0FBQztJQUNmOztJQ1pBO0lBQ0EsSUFBSW9ELGFBQVcsR0FBRyxPQUFPLE9BQU8sSUFBSSxRQUFRLElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUM7QUFDeEY7SUFDQTtJQUNBLElBQUlDLFlBQVUsR0FBR0QsYUFBVyxJQUFJLE9BQU8sTUFBTSxJQUFJLFFBQVEsSUFBSSxNQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQztBQUNsRztJQUNBO0lBQ0EsSUFBSUUsZUFBYSxHQUFHRCxZQUFVLElBQUlBLFlBQVUsQ0FBQyxPQUFPLEtBQUtELGFBQVcsQ0FBQztBQUNyRTtJQUNBO0lBQ0EsSUFBSSxNQUFNLEdBQUdFLGVBQWEsR0FBRyxJQUFJLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztBQUNyRDtJQUNBO0lBQ0EsSUFBSSxjQUFjLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQyxRQUFRLEdBQUcsU0FBUyxDQUFDO0FBQzFEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksUUFBUSxHQUFHLGNBQWMsSUFBSSxTQUFTOztJQ25DMUM7SUFDQSxJQUFJQyxrQkFBZ0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUN4QztJQUNBO0lBQ0EsSUFBSSxRQUFRLEdBQUcsa0JBQWtCLENBQUM7QUFDbEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxPQUFPLENBQUMsS0FBSyxFQUFFLE1BQU0sRUFBRTtJQUNoQyxFQUFFLElBQUksSUFBSSxHQUFHLE9BQU8sS0FBSyxDQUFDO0lBQzFCLEVBQUUsTUFBTSxHQUFHLE1BQU0sSUFBSSxJQUFJLEdBQUdBLGtCQUFnQixHQUFHLE1BQU0sQ0FBQztBQUN0RDtJQUNBLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTTtJQUNqQixLQUFLLElBQUksSUFBSSxRQUFRO0lBQ3JCLE9BQU8sSUFBSSxJQUFJLFFBQVEsSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDakQsU0FBUyxLQUFLLEdBQUcsQ0FBQyxDQUFDLElBQUksS0FBSyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksS0FBSyxHQUFHLE1BQU0sQ0FBQyxDQUFDO0lBQ3pEOztJQ3RCQTtJQUNBLElBQUksZ0JBQWdCLEdBQUcsZ0JBQWdCLENBQUM7QUFDeEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsS0FBSyxFQUFFO0lBQ3pCLEVBQUUsT0FBTyxPQUFPLEtBQUssSUFBSSxRQUFRO0lBQ2pDLElBQUksS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxnQkFBZ0IsQ0FBQztJQUM5RDs7SUM1QkE7SUFDQSxJQUFJLE9BQU8sR0FBRyxvQkFBb0I7SUFDbEMsSUFBSSxRQUFRLEdBQUcsZ0JBQWdCO0lBQy9CLElBQUksT0FBTyxHQUFHLGtCQUFrQjtJQUNoQyxJQUFJLE9BQU8sR0FBRyxlQUFlO0lBQzdCLElBQUksUUFBUSxHQUFHLGdCQUFnQjtJQUMvQixJQUFJQyxTQUFPLEdBQUcsbUJBQW1CO0lBQ2pDLElBQUksTUFBTSxHQUFHLGNBQWM7SUFDM0IsSUFBSSxTQUFTLEdBQUcsaUJBQWlCO0lBQ2pDLElBQUksU0FBUyxHQUFHLGlCQUFpQjtJQUNqQyxJQUFJLFNBQVMsR0FBRyxpQkFBaUI7SUFDakMsSUFBSSxNQUFNLEdBQUcsY0FBYztJQUMzQixJQUFJLFNBQVMsR0FBRyxpQkFBaUI7SUFDakMsSUFBSSxVQUFVLEdBQUcsa0JBQWtCLENBQUM7QUFDcEM7SUFDQSxJQUFJLGNBQWMsR0FBRyxzQkFBc0I7SUFDM0MsSUFBSSxXQUFXLEdBQUcsbUJBQW1CO0lBQ3JDLElBQUksVUFBVSxHQUFHLHVCQUF1QjtJQUN4QyxJQUFJLFVBQVUsR0FBRyx1QkFBdUI7SUFDeEMsSUFBSSxPQUFPLEdBQUcsb0JBQW9CO0lBQ2xDLElBQUksUUFBUSxHQUFHLHFCQUFxQjtJQUNwQyxJQUFJLFFBQVEsR0FBRyxxQkFBcUI7SUFDcEMsSUFBSSxRQUFRLEdBQUcscUJBQXFCO0lBQ3BDLElBQUksZUFBZSxHQUFHLDRCQUE0QjtJQUNsRCxJQUFJLFNBQVMsR0FBRyxzQkFBc0I7SUFDdEMsSUFBSSxTQUFTLEdBQUcsc0JBQXNCLENBQUM7QUFDdkM7SUFDQTtJQUNBLElBQUksY0FBYyxHQUFHLEVBQUUsQ0FBQztJQUN4QixjQUFjLENBQUMsVUFBVSxDQUFDLEdBQUcsY0FBYyxDQUFDLFVBQVUsQ0FBQztJQUN2RCxjQUFjLENBQUMsT0FBTyxDQUFDLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQztJQUNsRCxjQUFjLENBQUMsUUFBUSxDQUFDLEdBQUcsY0FBYyxDQUFDLFFBQVEsQ0FBQztJQUNuRCxjQUFjLENBQUMsZUFBZSxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQztJQUMzRCxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUcsSUFBSSxDQUFDO0lBQ2pDLGNBQWMsQ0FBQyxPQUFPLENBQUMsR0FBRyxjQUFjLENBQUMsUUFBUSxDQUFDO0lBQ2xELGNBQWMsQ0FBQyxjQUFjLENBQUMsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDO0lBQ3hELGNBQWMsQ0FBQyxXQUFXLENBQUMsR0FBRyxjQUFjLENBQUMsT0FBTyxDQUFDO0lBQ3JELGNBQWMsQ0FBQyxRQUFRLENBQUMsR0FBRyxjQUFjLENBQUNBLFNBQU8sQ0FBQztJQUNsRCxjQUFjLENBQUMsTUFBTSxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQztJQUNsRCxjQUFjLENBQUMsU0FBUyxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQztJQUNyRCxjQUFjLENBQUMsTUFBTSxDQUFDLEdBQUcsY0FBYyxDQUFDLFNBQVMsQ0FBQztJQUNsRCxjQUFjLENBQUMsVUFBVSxDQUFDLEdBQUcsS0FBSyxDQUFDO0FBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLGdCQUFnQixDQUFDLEtBQUssRUFBRTtJQUNqQyxFQUFFLE9BQU8sWUFBWSxDQUFDLEtBQUssQ0FBQztJQUM1QixJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLGNBQWMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQztJQUNsRTs7SUN6REE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFNBQVMsQ0FBQyxJQUFJLEVBQUU7SUFDekIsRUFBRSxPQUFPLFNBQVMsS0FBSyxFQUFFO0lBQ3pCLElBQUksT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkIsR0FBRyxDQUFDO0lBQ0o7O0lDVEE7SUFDQSxJQUFJLFdBQVcsR0FBRyxPQUFPLE9BQU8sSUFBSSxRQUFRLElBQUksT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLFFBQVEsSUFBSSxPQUFPLENBQUM7QUFDeEY7SUFDQTtJQUNBLElBQUksVUFBVSxHQUFHLFdBQVcsSUFBSSxPQUFPLE1BQU0sSUFBSSxRQUFRLElBQUksTUFBTSxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxNQUFNLENBQUM7QUFDbEc7SUFDQTtJQUNBLElBQUksYUFBYSxHQUFHLFVBQVUsSUFBSSxVQUFVLENBQUMsT0FBTyxLQUFLLFdBQVcsQ0FBQztBQUNyRTtJQUNBO0lBQ0EsSUFBSSxXQUFXLEdBQUcsYUFBYSxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUM7QUFDdEQ7SUFDQTtJQUNBLElBQUksUUFBUSxJQUFJLFdBQVc7SUFDM0IsRUFBRSxJQUFJO0lBQ047SUFDQSxJQUFJLElBQUksS0FBSyxHQUFHLFVBQVUsSUFBSSxVQUFVLENBQUMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsS0FBSyxDQUFDO0FBQ3JGO0lBQ0EsSUFBSSxJQUFJLEtBQUssRUFBRTtJQUNmLE1BQU0sT0FBTyxLQUFLLENBQUM7SUFDbkIsS0FBSztBQUNMO0lBQ0E7SUFDQSxJQUFJLE9BQU8sV0FBVyxJQUFJLFdBQVcsQ0FBQyxPQUFPLElBQUksV0FBVyxDQUFDLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUM3RSxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsRUFBRTtJQUNoQixDQUFDLEVBQUUsQ0FBQzs7SUN2Qko7SUFDQSxJQUFJLGdCQUFnQixHQUFHLFFBQVEsSUFBSSxRQUFRLENBQUMsWUFBWSxDQUFDO0FBQ3pEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLElBQUksWUFBWSxHQUFHLGdCQUFnQixHQUFHLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxHQUFHLGdCQUFnQjs7SUNqQnBGO0lBQ0EsSUFBSXpELGFBQVcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ25DO0lBQ0E7SUFDQSxJQUFJQyxnQkFBYyxHQUFHRCxhQUFXLENBQUMsY0FBYyxDQUFDO0FBQ2hEO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsYUFBYSxDQUFDLEtBQUssRUFBRSxTQUFTLEVBQUU7SUFDekMsRUFBRSxJQUFJLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSyxDQUFDO0lBQzVCLE1BQU0sS0FBSyxHQUFHLENBQUMsS0FBSyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUM7SUFDMUMsTUFBTSxNQUFNLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQztJQUNsRCxNQUFNLE1BQU0sR0FBRyxDQUFDLEtBQUssSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsS0FBSyxDQUFDO0lBQ2pFLE1BQU0sV0FBVyxHQUFHLEtBQUssSUFBSSxLQUFLLElBQUksTUFBTSxJQUFJLE1BQU07SUFDdEQsTUFBTSxNQUFNLEdBQUcsV0FBVyxHQUFHLFNBQVMsQ0FBQyxLQUFLLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxHQUFHLEVBQUU7SUFDakUsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUM3QjtJQUNBLEVBQUUsS0FBSyxJQUFJLEdBQUcsSUFBSSxLQUFLLEVBQUU7SUFDekIsSUFBSSxJQUFJLENBQUMsU0FBUyxJQUFJQyxnQkFBYyxDQUFDLElBQUksQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDO0lBQ3JELFFBQVEsRUFBRSxXQUFXO0lBQ3JCO0lBQ0EsV0FBVyxHQUFHLElBQUksUUFBUTtJQUMxQjtJQUNBLFlBQVksTUFBTSxLQUFLLEdBQUcsSUFBSSxRQUFRLElBQUksR0FBRyxJQUFJLFFBQVEsQ0FBQyxDQUFDO0lBQzNEO0lBQ0EsWUFBWSxNQUFNLEtBQUssR0FBRyxJQUFJLFFBQVEsSUFBSSxHQUFHLElBQUksWUFBWSxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsQ0FBQztJQUN0RjtJQUNBLFdBQVcsT0FBTyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUM7SUFDL0IsU0FBUyxDQUFDLEVBQUU7SUFDWixNQUFNLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDdkIsS0FBSztJQUNMLEdBQUc7SUFDSCxFQUFFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCOztJQzlDQTtJQUNBLElBQUlELGFBQVcsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDO0FBQ25DO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFdBQVcsQ0FBQyxLQUFLLEVBQUU7SUFDNUIsRUFBRSxJQUFJLElBQUksR0FBRyxLQUFLLElBQUksS0FBSyxDQUFDLFdBQVc7SUFDdkMsTUFBTSxLQUFLLEdBQUcsQ0FBQyxPQUFPLElBQUksSUFBSSxVQUFVLElBQUksSUFBSSxDQUFDLFNBQVMsS0FBS0EsYUFBVyxDQUFDO0FBQzNFO0lBQ0EsRUFBRSxPQUFPLEtBQUssS0FBSyxLQUFLLENBQUM7SUFDekI7O0lDZkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsT0FBTyxDQUFDLElBQUksRUFBRSxTQUFTLEVBQUU7SUFDbEMsRUFBRSxPQUFPLFNBQVMsR0FBRyxFQUFFO0lBQ3ZCLElBQUksT0FBTyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDaEMsR0FBRyxDQUFDO0lBQ0o7O0lDVkE7SUFDQSxJQUFJLFVBQVUsR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksRUFBRSxNQUFNLENBQUM7O0lDQTdDO0lBQ0EsSUFBSSxXQUFXLEdBQUcsTUFBTSxDQUFDLFNBQVMsQ0FBQztBQUNuQztJQUNBO0lBQ0EsSUFBSSxjQUFjLEdBQUcsV0FBVyxDQUFDLGNBQWMsQ0FBQztBQUNoRDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxRQUFRLENBQUMsTUFBTSxFQUFFO0lBQzFCLEVBQUUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsRUFBRTtJQUM1QixJQUFJLE9BQU8sVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlCLEdBQUc7SUFDSCxFQUFFLElBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNsQixFQUFFLEtBQUssSUFBSSxHQUFHLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFO0lBQ2xDLElBQUksSUFBSSxjQUFjLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUMsSUFBSSxHQUFHLElBQUksYUFBYSxFQUFFO0lBQ2xFLE1BQU0sTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN2QixLQUFLO0lBQ0wsR0FBRztJQUNILEVBQUUsT0FBTyxNQUFNLENBQUM7SUFDaEI7O0lDeEJBO0lBQ0EsSUFBSSxRQUFRLEdBQUcsd0JBQXdCO0lBQ3ZDLElBQUksT0FBTyxHQUFHLG1CQUFtQjtJQUNqQyxJQUFJLE1BQU0sR0FBRyw0QkFBNEI7SUFDekMsSUFBSSxRQUFRLEdBQUcsZ0JBQWdCLENBQUM7QUFDaEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxVQUFVLENBQUMsS0FBSyxFQUFFO0lBQzNCLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtJQUN4QixJQUFJLE9BQU8sS0FBSyxDQUFDO0lBQ2pCLEdBQUc7SUFDSDtJQUNBO0lBQ0EsRUFBRSxJQUFJLEdBQUcsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDOUIsRUFBRSxPQUFPLEdBQUcsSUFBSSxPQUFPLElBQUksR0FBRyxJQUFJLE1BQU0sSUFBSSxHQUFHLElBQUksUUFBUSxJQUFJLEdBQUcsSUFBSSxRQUFRLENBQUM7SUFDL0U7O0lDL0JBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxXQUFXLENBQUMsS0FBSyxFQUFFO0lBQzVCLEVBQUUsT0FBTyxLQUFLLElBQUksSUFBSSxJQUFJLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDdkU7O0lDMUJBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsU0FBUyxJQUFJLENBQUMsTUFBTSxFQUFFO0lBQ3RCLEVBQUUsT0FBTyxXQUFXLENBQUMsTUFBTSxDQUFDLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN4RTs7SUMvQkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFNBQVMsTUFBTSxDQUFDLE1BQU0sRUFBRTtJQUN4QixFQUFFLE9BQU8sTUFBTSxJQUFJLElBQUksR0FBRyxFQUFFLEdBQUcsVUFBVSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUNoRTs7SUM1QkE7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLFdBQVcsQ0FBQyxVQUFVLEVBQUU7SUFDakMsRUFBRSxPQUFPLFdBQVcsQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQztJQUN6Qzs7SUNSQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSxTQUFTLE9BQU8sQ0FBQyxVQUFVLEVBQUU7SUFDN0IsRUFBRSxJQUFJLElBQUksR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLEdBQUcsWUFBWSxHQUFHLFdBQVcsQ0FBQztJQUM5RCxFQUFFLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQzFCOztJQzZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFvQkc7SUFDRyxTQUFVLHdCQUF3QixDQUFxRCxFQUFFLHFCQUFxQixFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQTRDLEVBQUE7OztRQUkxSyxNQUFNLFNBQVMsR0FBRzdHLENBQU0sQ0FBQyxJQUFJLEdBQUcsRUFBa0IsQ0FBQyxDQUFDO1FBQ3BELE1BQU0sV0FBVyxHQUFHQSxDQUFNLENBQUMsSUFBSSxHQUFHLEVBQWtCLENBQUMsQ0FBQztRQUN0RCxNQUFNLFlBQVksR0FBR0ksR0FBVyxDQUFDLENBQUMsQ0FBUyxNQUFNLFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQ3JGLE1BQU0sY0FBYyxHQUFHQSxHQUFXLENBQUMsQ0FBQyxDQUFTLE1BQU0sV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7Ozs7OztJQU96RixJQUFBLE1BQU0sQ0FBQyxjQUFjLEVBQUUsY0FBYyxDQUFDLEdBQUcsZUFBZSxDQUFzQixJQUFJLEVBQUUsVUFBVSxDQUFDLENBQUM7SUFFaEcsSUFBQSxNQUFNLFNBQVMsR0FBR0EsR0FBVyxDQUFDLENBQUMsVUFBNEMsS0FBSTs7O0lBSTNFLFFBQUEsS0FBSyxJQUFJLGFBQWEsR0FBRyxDQUFDLEVBQUUsYUFBYSxHQUFHLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxhQUFhLEVBQUU7Z0JBQzVFLE1BQU0sZUFBZSxHQUFHLFVBQVUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBRXhELFNBQVMsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLGVBQWUsRUFBRSxhQUFhLENBQUMsQ0FBQztnQkFDdEQsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLGVBQWUsQ0FBQyxDQUFDO0lBQzNELFNBQUE7WUFHRCxjQUFjLEVBQUUsSUFBSSxDQUFDO1NBQ3hCLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFUCxJQUFBLE1BQU0scUJBQXFCLEdBQUdBLEdBQVcsQ0FBQyxDQUFDLEVBQUUsUUFBUSxFQUFFLEdBQUcsS0FBSyxFQUF1RixLQUFJO0lBRXRKLFFBQUEsTUFBTSxXQUFXLEdBQUcsY0FBYyxFQUFFLENBQUM7WUFDckNMLENBQWUsQ0FBQyxNQUFLLEVBQUcsY0FBYyxDQUFDLEtBQUssSUFBSSxXQUFXLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFBO1lBRS9FLFFBQVEsY0FBYyxDQUFnQjtJQUNsQyxZQUFBLFFBQVEsRUFDSCxRQUFvRDtJQUNoRCxpQkFBQSxLQUFLLEVBQUU7SUFDUCxpQkFBQSxHQUFHLENBQUMsS0FBSyxLQUFLLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxZQUFZLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxLQUFNLENBQUUsQ0FBQyxFQUFFLGNBQWMsRUFBRSxRQUFRLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNySCxpQkFBQSxJQUFJLENBQUMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxLQUFPLEVBQUEsT0FBTyxHQUFHLENBQUMsWUFBWSxHQUFHLEdBQUcsQ0FBQyxZQUFZLENBQUEsRUFBRSxDQUFDO3FCQUNsRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLEtBQUk7b0JBQzdDLE9BQU93SyxHQUFDLENBQUMsS0FBSyxDQUFDLElBQVcsRUFBRSxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsY0FBYyxFQUFFLG9CQUFvQixFQUFFLFlBQVksRUFBRSxzQkFBc0IsRUFBRSxjQUFjLEVBQUUsQ0FBQyxDQUFDO0lBQ3JKLGFBQUMsQ0FBQzthQUNiLEVBQUUsS0FBSyxDQUFDLEVBQUU7U0FDZCxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRVAsSUFBQSxPQUFPLEVBQUUscUJBQXFCLEVBQUUscUJBQXFCLEVBQUUsRUFBRSxZQUFZLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLEVBQUUsQ0FBQztJQUNqSSxDQUFDO0lBR0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0JHO2FBQ2EsbUJBQW1CLENBQXlFLEVBQUUscUJBQXFCLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLEVBQTZDLEVBQUE7SUFFaFAsSUFBQSxNQUFNLE9BQU8sSUFBSSxXQUFXLElBQUksY0FBYyxDQUFDLENBQUM7SUFFaEQsSUFBQSxNQUFNLEVBQUUscUJBQXFCLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRywrQkFBK0IsRUFBRSxHQUFHLHdCQUF3QixDQUFzQixFQUFFLHFCQUFxQixFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQy9LLE1BQU0sRUFBRSxxQkFBcUIsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLEdBQUcsK0JBQStCLENBQUM7O0lBRWpGLElBQUEsTUFBTSxJQUFJLEdBQUduSyxHQUFXLENBQUMsQ0FBQyxXQUEwQyxFQUFFLFNBQXFDLEVBQUUsR0FBRyxJQUFPLEtBQTBCO0lBRTdJLFFBQUEsTUFBTSxVQUFVLEdBQUcsV0FBVyxDQUFDLFVBQVUsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sRUFBRSxNQUFNLEtBQUk7Z0JBRWhFLE1BQU0sUUFBUSxHQUFHLFFBQVEsQ0FBQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQVEsQ0FBQztnQkFDbEQsTUFBTSxRQUFRLEdBQUcsUUFBUSxDQUFDLE1BQU0sRUFBRSxHQUFHLElBQUksQ0FBUSxDQUFDO2dCQUNsRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFBO0lBQzFDLFlBQUEsSUFBSSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBQUksR0FBRztvQkFDbkIsT0FBTyxDQUFDLE1BQU0sQ0FBQztJQUNuQixZQUFBLE9BQU8sTUFBTSxDQUFDO0lBRWxCLFNBQUMsQ0FBQyxDQUFDO0lBRUgsUUFBQSxPQUFPLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUVqQyxLQUFDLEVBQUUsMkJBQTJCLENBQUMsQ0FBQztJQUVoQyxJQUFBLE1BQU1vSyxTQUFPLEdBQUdwSyxHQUFXLENBQUMsQ0FBQyxXQUEwQyxLQUEwQjtZQUM3RixNQUFNLFlBQVksR0FBR3FLLE9BQWEsQ0FBQyxXQUFXLENBQUMsVUFBVSxFQUFFLENBQUMsQ0FBQTtJQUM1RCxRQUFBLE9BQU8sU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO0lBQ25DLEtBQUMsRUFBRSwyQkFBMEIsQ0FBQyxDQUFDO1FBRS9CLE9BQU87WUFDSCxnQkFBZ0I7SUFDaEIsUUFBQSxnQkFBZ0IsRUFBRSxFQUFFLElBQUksV0FBRUQsU0FBTyxFQUFFO1lBQ25DLHFCQUFxQixFQUFFLCtCQUErQixDQUFDLHFCQUFxQjtTQUMvRSxDQUFDO0lBQ04sQ0FBQztJQTRDRCxTQUFTLGNBQWMsQ0FBQyxHQUF3RCxFQUFFLEdBQXdELEVBQUE7SUFDdEksSUFBQSxPQUFPLFFBQVEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLENBQUM7SUFFMUIsSUFBQSxTQUFTLFFBQVEsQ0FBQyxHQUFvQixFQUFFLEdBQW9CLEVBQUE7O0lBR3hELFFBQUEsSUFBSSxDQUFHLEVBQUEsQ0FBQyxHQUFHLENBQUEsQ0FBRSxLQUFLLEdBQUc7Z0JBQ2pCLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUNmLFFBQUEsSUFBSSxDQUFHLEVBQUEsQ0FBQyxHQUFHLENBQUEsQ0FBRSxLQUFLLEdBQUc7Z0JBQ2pCLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQzs7WUFHZixJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVE7SUFDdkIsWUFBQSxHQUFHLEdBQUcsQ0FBQSxFQUFHLEdBQUcsQ0FBQSxDQUFFLENBQUM7WUFDbkIsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRO0lBQ3ZCLFlBQUEsR0FBRyxHQUFHLENBQUEsRUFBRyxHQUFHLENBQUEsQ0FBRSxDQUFDO1lBRW5CLE9BQU8sQ0FBQyxNQUFNLENBQUMsT0FBTyxHQUFHLEtBQUssT0FBTyxHQUFHLENBQUMsQ0FBQztZQUUxQyxJQUFJLE9BQU8sR0FBRyxLQUFLLFFBQVE7SUFDdkIsWUFBQSxPQUFPLEdBQUcsQ0FBQyxhQUFhLENBQUMsR0FBYSxDQUFDLENBQUM7WUFDNUMsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRO0lBQ3ZCLFlBQUEsT0FBTyxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUV2QixRQUFBLE9BQU8sQ0FBQyxDQUFDO1NBQ1o7SUFDRCxJQUFBLFNBQVMsUUFBUSxDQUFDLEdBQXFDLEVBQUUsR0FBcUMsRUFBQTtJQUMxRixRQUFBLElBQUksT0FBTyxHQUFHLEtBQUssU0FBUyxJQUFJLEdBQUcsWUFBWSxJQUFJO2dCQUMvQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUM7SUFDZixRQUFBLElBQUksT0FBTyxHQUFHLEtBQUssU0FBUyxJQUFJLEdBQUcsWUFBWSxJQUFJO2dCQUMvQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUM7SUFDZixRQUFBLE9BQU8sUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUM3QjtJQUNELElBQUEsU0FBUyxRQUFRLENBQUMsR0FBd0QsRUFBRSxHQUF3RCxFQUFBO0lBQ2hJLFFBQUEsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7O0lBRTVCLFlBQUEsT0FBTyxDQUFDLENBQUM7SUFDWixTQUFBO0lBQ0ksYUFBQSxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTs7SUFFakMsWUFBQSxPQUFPLEdBQUcsSUFBSSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFBO0lBQzlCLFNBQUE7SUFDRCxRQUFBLE9BQU8sUUFBUSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztTQUM3QjtJQUNMOztJQ3ZOQSxTQUFTLFFBQVEsQ0FBSSxDQUFJLEVBQUEsRUFBSSxPQUFPLENBQUMsQ0FBQyxFQUFFO0lBK0h4Qzs7Ozs7SUFLRztJQUNHLFNBQVUsaUJBQWlCLENBQThHLEVBQzNJLGVBQWUsRUFBRSxFQUFFLHFCQUFxQixFQUFFLEdBQUcsRUFBRSxFQUFFLEVBQ2pELGNBQWMsRUFDZCxjQUFjLEVBQUUsRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLEVBQ2hELGdCQUFnQixFQUNoQixtQkFBbUIsRUFDMEMsRUFBQTtRQUM3RCxZQUFZLEtBQUssUUFBUSxDQUFDO1FBQzFCLGNBQWMsS0FBSyxRQUFRLENBQUM7SUFFNUIsSUFBQSxrQkFBa0IsQ0FBQyxtQkFBbUIsRUFBRSxZQUFZLEVBQUUsY0FBYyxDQUFDLENBQUM7UUFHdEUsTUFBTSxnQkFBZ0IsR0FBRyxpQkFBaUIsQ0FBbUU7SUFDekcsUUFBQSxlQUFlLEVBQUU7Z0JBQ2IsR0FBRyxFQUFFLEVBQUUscUJBQXFCLEVBQUVwSyxHQUFXLENBQWdDLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSTtJQUM5RSxnQkFBQSxxQkFBcUIsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7aUJBQ2pDLEVBQUUsRUFBRSxDQUFDO0lBQ1QsU0FBQTtZQUNELGNBQWM7SUFDakIsS0FBQSxDQUFDLENBQUM7SUFFSCxJQUFBLE1BQU0sRUFBRSxzQkFBc0IsRUFBRSxlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxnQkFBZ0IsRUFBRSxFQUFFLEdBQUcsZ0JBQWdCLENBQUM7UUFFM0ksTUFBTSxlQUFlLEdBQUdBLEdBQVcsQ0FBQyxDQUFDLENBQWdCLEVBQUUsbUJBQTRCLEtBQUk7WUFDbkYsSUFBSSxDQUFDLElBQUksSUFBSSxFQUFFO2dCQUNYLE1BQU0sU0FBUyxHQUFHLGtCQUFrQixDQUFDO0lBQ2pDLGdCQUFBLFFBQVEsRUFBRSxRQUFRO0lBQ2xCLGdCQUFBLE9BQU8sRUFBRSxDQUFDO0lBQ1YsZ0JBQUEsTUFBTSxFQUFFLENBQUM7SUFDVCxnQkFBQSxlQUFlLEVBQUUsQ0FBQztvQkFDbEIsWUFBWSxFQUFFLFlBQVksSUFBSSxRQUFRO29CQUN0QyxjQUFjLEVBQUUsY0FBYyxJQUFJLFFBQVE7SUFDN0MsYUFBQSxDQUFDLENBQUM7SUFDSCxZQUFBLGdCQUFnQixDQUFDLENBQUMsSUFBSSxJQUFJLEdBQUcsSUFBSSxHQUFHLFNBQVMsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQ3ZFLFNBQUE7SUFDSSxhQUFBO0lBQ0QsWUFBQSxnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUMvQyxTQUFBO1NBQ0osRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVQLElBQUEsTUFBTSxFQUNGLDJCQUEyQixFQUMzQiwyQkFBMkIsRUFDM0IsbUJBQW1CLEVBQUUsRUFDakIsZ0JBQWdCLEVBQ2hCLGdCQUFnQixFQUNuQixFQUNKLEdBQUcsc0JBQXNCLENBQXVCO0lBQzdDLFFBQUEsbUJBQW1CLEVBQUU7SUFDakIsWUFBQSxRQUFRLEVBQUUsZ0JBQWdCO0lBQzFCLFlBQUEsUUFBUSxFQUFFQSxHQUFXLENBQUMsQ0FBQyxLQUFtRSxLQUFJO0lBQzFGLGdCQUFBLGdCQUFnQixDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztpQkFDakMsRUFBRSxFQUFFLENBQUM7SUFDTixZQUFBLEdBQUcsbUJBQW1CO0lBQ3pCLFNBQUE7SUFDSixLQUFBLENBQUMsQ0FBQztJQUNILElBQUEsTUFBTSxFQUFFLHdCQUF3QixFQUFFLEdBQUcsbUJBQW1CLENBQXVCO0lBQzNFLFFBQUEsZ0JBQWdCLEVBQUU7SUFDZCxZQUFBLGNBQWMsRUFBRUEsR0FBVyxDQUFDLE1BQUs7b0JBQzdCLGdCQUFnQixDQUFDLENBQUMsSUFBRzt3QkFDakIsT0FBTyxrQkFBa0IsQ0FBQyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsRUFBRSxNQUFNLEVBQUUsY0FBZSxDQUFDLFlBQWEsRUFBRSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLEVBQUUsZUFBZSxFQUFFLENBQUMsQ0FBQyxFQUFFLFlBQVksRUFBRSxZQUFZLElBQUksUUFBUSxFQUFFLGNBQWMsRUFBRSxjQUFjLElBQUksUUFBUSxFQUFFLENBQUMsQ0FBQTtxQkFDMU4sRUFBRSxJQUFJLENBQUMsQ0FBQTtpQkFDWCxFQUFFLEVBQUUsQ0FBQztJQUNOLFlBQUEsY0FBYyxFQUFFQSxHQUFXLENBQUMsTUFBSztvQkFDN0IsZ0JBQWdCLENBQUMsQ0FBQyxJQUFHO0lBQ2pCLG9CQUFBLE9BQU8sa0JBQWtCLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxFQUFFLGNBQWUsQ0FBQyxZQUFhLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLGVBQWUsRUFBRSxDQUFDLEVBQUUsWUFBWSxFQUFFLFlBQVksSUFBSSxRQUFRLEVBQUUsY0FBYyxFQUFFLGNBQWMsSUFBSSxRQUFRLEVBQUUsQ0FBQyxDQUFDO3FCQUN4TixFQUFFLElBQUksQ0FBQyxDQUFBO2lCQUNYLEVBQUUsRUFBRSxDQUFDO2dCQUNOLGVBQWUsRUFBRUEsR0FBVyxDQUFDLE1BQVEsRUFBQSxlQUFlLENBQUMsY0FBZSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7Z0JBQ3RGLGNBQWMsRUFBRUEsR0FBVyxDQUFDLE1BQVEsRUFBQSxlQUFlLENBQUMsY0FBZSxDQUFDLFFBQVEsQ0FBQyxlQUFlLEVBQUUsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDOUcsWUFBQSxHQUFHLGdCQUFnQjtJQUN0QixTQUFBO0lBQ0osS0FBQSxDQUFDLENBQUM7SUFFSCxJQUFBLE1BQU0sc0JBQXNCLEdBQUdBLEdBQVcsQ0FBQyxDQUFDLEtBQWlELEtBQWdEO0lBQ3pJLFFBQUEsT0FBTyx3QkFBd0IsQ0FBQywyQkFBMkIsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3hFLEtBQUMsRUFBRSxDQUFDLHdCQUF3QixFQUFFLDJCQUEyQixDQUFDLENBQUMsQ0FBQztJQUc1RCxJQUFBLE1BQU0sc0JBQXNCLEdBQUdBLEdBQVcsQ0FBaUUsQ0FBQyxFQUFFLFlBQVksRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsRUFBRSxjQUFjLEVBQUUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUk7WUFFdk0sMkJBQTJCLENBQUMsRUFBRSxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7SUFDOUQsUUFBQSxNQUFNLFFBQVEsR0FBRyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUM7WUFDeENULENBQVMsQ0FBQyxNQUFLO0lBRVgsWUFBQSxPQUFPLE1BQUs7SUFDUixnQkFBQSxJQUFJLGdCQUFnQixFQUFFLElBQUksUUFBUSxFQUFFLEVBQUU7SUFDbEMsb0JBQUEsZUFBZSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNqQyxpQkFBQTtJQUNMLGFBQUMsQ0FBQzthQUNMLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFFUCxRQUFBLE1BQU0sRUFDRiwyQkFBMkIsRUFDM0IsY0FBYyxFQUFFLEVBQ1osUUFBUSxFQUNSLFdBQVcsRUFDWCxVQUFVLEVBQ2IsRUFDSixHQUFHLHNCQUFzQixDQUFDO0lBQ3ZCLFlBQUEsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRTtnQkFDOUIsY0FBYyxFQUFFLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxDQUFDLENBQUMsTUFBTSxFQUFFO0lBQy9DLFlBQUEsT0FBTyxFQUFFLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRTtJQUM3QixTQUFBLENBQUMsQ0FBQztJQUVILFFBQUEsTUFBTSwyQkFBMkIsR0FBa0YsVUFBVSxFQUFFLEdBQUcsS0FBSyxFQUFFLEVBQUE7SUFDckksWUFBQSxPQUFPLGNBQWMsQ0FBZSwyQkFBMkIsQ0FBRyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQTBDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN6SSxTQUFDLENBQUE7WUFFRCxPQUFPO2dCQUNILDJCQUEyQjtJQUMzQixZQUFBLGNBQWMsRUFBRTtvQkFDWixRQUFRO29CQUNSLFdBQVc7b0JBQ1gsVUFBVTtJQUNiLGFBQUE7YUFDSixDQUFBO1NBQ0osRUFBRSxDQUFDLDJCQUEyQixFQUFFLHNCQUFzQixFQUFFLGVBQWUsQ0FBQyxDQUFDLENBQUM7UUFFM0UsT0FBTztZQUNILHNCQUFzQjtZQUN0QixzQkFBc0I7WUFFdEIsY0FBYyxFQUFFLEVBQUUsZUFBZSxFQUFFO1lBQ25DLGVBQWUsRUFBRSxnQkFBZ0IsQ0FBQyxlQUFlO1lBQ2pELGNBQWMsRUFBRSxnQkFBZ0IsQ0FBQyxjQUFjO0lBQy9DLFFBQUEsZ0JBQWdCLEVBQUUsRUFBRTtJQUNwQixRQUFBLG1CQUFtQixFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUU7SUFDM0Q7OztJQUc2RDtTQUNoRSxDQUFBO0lBQ0wsQ0FBQztJQU9EOzs7Ozs7OztJQVFHO2FBQ2EsZ0NBQWdDLENBQTBGLEVBQ3RJLGVBQWUsRUFBRSxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUscUJBQXFCLEVBQUUsRUFDeEUsY0FBYyxFQUNkLGVBQWUsRUFDZixjQUFjLEVBQUUsRUFBRSxHQUFHLGNBQWMsRUFBRSxFQUNyQyxnQkFBZ0IsRUFDaEIsbUJBQW1CLEVBQ25CLGlCQUFpQixFQUFFLEVBQUUsY0FBYyxFQUFFLGdCQUFnQixFQUFFLEVBQzRCLEVBQUE7UUFDbkYsTUFBTSxnQkFBZ0IsR0FBRyxpQkFBaUIsQ0FBd0Q7WUFDOUYsY0FBYztZQUNkLGVBQWU7SUFDZixRQUFBLGNBQWMsRUFBRTtJQUNaLFlBQUEsWUFBWSxHQUFHLGFBQWEsSUFBSSxTQUFTLENBQUM7SUFDMUMsWUFBQSxHQUFHLGNBQWM7SUFDcEIsU0FBQTtZQUNELGdCQUFnQjtZQUNoQixtQkFBbUI7SUFDdEIsS0FBQSxDQUFDLENBQUM7SUFFSCxJQUFBLE1BQU0sRUFBRSx5QkFBeUIsRUFBRSxHQUFHLG9CQUFvQixDQUFDO0lBQ3ZELFFBQUEsaUJBQWlCLEVBQUU7SUFDZixZQUFBLGNBQWMsRUFBRSxpQkFBaUIsQ0FBQyxNQUFLO29CQUNuQyxjQUFjLElBQUksQ0FBQztvQkFDbkIsSUFBSSxhQUFhLElBQUksSUFBSTtJQUNyQixvQkFBQSxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDL0MsYUFBQyxDQUFDO2dCQUNGLGdCQUFnQjtJQUNuQixTQUFBLEVBQUUsZUFBZSxFQUFFO0lBQ2hCLFlBQUEsd0JBQXdCLEVBQUUsSUFBSTtJQUM5QixZQUFBLHFCQUFxQixFQUFFLElBQUk7SUFDOUIsU0FBQTtJQUNKLEtBQUEsQ0FBQyxDQUFDO0lBRUgsSUFBQSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBRWhFLE1BQU0sRUFDRixzQkFBc0IsRUFDdEIsc0JBQXNCLEVBQ3RCLEdBQUcsUUFBUSxFQUNkLEdBQUcsZ0JBQWdCLENBQUM7SUFFckIsSUFBQSxNQUFNLEVBQUUsZUFBZSxFQUFFLEVBQUUsUUFBUSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsZ0JBQWdCLEVBQUUsRUFBRSxHQUFHLFFBQVEsQ0FBQztJQUV6RixJQUFBLE1BQU0sRUFDRixXQUFXLEVBQUUsbUJBQW1CLEVBQ2hDLGVBQWUsRUFBRSxnQkFBZ0I7O0lBRXBDLE1BQUEsR0FBRyxlQUFlLENBQXNGO0lBQ3JHLFFBQUEsUUFBUSxFQUFFLFFBQVE7SUFDbEIsUUFBQSxZQUFZLEVBQUUsYUFBYTtJQUMzQixRQUFBLEdBQUcsRUFBRSxVQUFVO0lBQ2YsUUFBQSxVQUFVLEVBQUUsS0FBSztJQUNwQixLQUFBLENBQUMsQ0FBQztRQUVISSxDQUFlLENBQUMsTUFBSztZQUNqQixtQkFBbUIsQ0FBQyxhQUFhLENBQUMsQ0FBQztJQUN2QyxLQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDO1FBRXBCLE9BQU87SUFDSCxRQUFBLHFDQUFxQyxFQUFFSyxHQUFXLENBQXlFLENBQUMsRUFBRSxZQUFZLEVBQUUsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUUsY0FBYyxFQUFFLEdBQUcsRUFBRSxjQUFjLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxFQUFFLHFCQUFxQixFQUFFLEdBQUcsUUFBUSxFQUFFLEVBQUUsT0FBTyxFQUFFLEtBQUk7SUFDbFEsWUFBQSxNQUFNLENBQUMsVUFBVSxFQUFFLGFBQWEsRUFBRSxhQUFhLENBQUMsR0FBRyxRQUFRLENBQUMsZ0JBQWdCLEVBQUUsSUFBSSxLQUFLLENBQUMsQ0FBQztnQkFDekYsTUFBTSxXQUFXLEdBQUdKLENBQU0sQ0FBc0IsRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLEdBQUcsRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLGlCQUFpQixDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzNJLFlBQUEsTUFBTSxFQUFFLDhCQUE4QixFQUFFLFVBQVUsRUFBRSxHQUFHLHlCQUF5QixDQUFDO29CQUM3RSxxQkFBcUIsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDLE9BQWdCLEVBQUUsSUFBeUIsS0FBSTtJQUNyRixvQkFBQSxxQkFBcUIsR0FBRyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDdkMsb0JBQUEsSUFBSSxhQUFhLElBQUksT0FBTyxJQUFJLE9BQU8sRUFBRTtJQUNqQyx3QkFBQSxjQUFjLENBQUMsRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLEVBQUUsYUFBYSxFQUFFLFVBQVUsRUFBRSxFQUFXLEVBQUUsUUFBUSxFQUFFLENBQUMsQ0FBQztJQUVsRyxxQkFBQTtJQUNMLGlCQUFDLENBQUM7SUFDRixnQkFBQSxHQUFHLFFBQVE7b0JBQ1gsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFO0lBQzFCLGFBQUEsQ0FBQyxDQUFDO2dCQUVILE1BQU0sRUFDRixjQUFjLEVBQUUsT0FBTyxFQUN2QiwyQkFBMkIsRUFDOUIsR0FBRyxzQkFBc0IsQ0FBQztJQUN2QixnQkFBQSxZQUFZLEVBQUU7d0JBQ1YsS0FBSztJQUNMLG9CQUFBLEtBQUssRUFBRTs0QkFDSCxRQUFRLEVBQUUsV0FBVyxDQUFDLE9BQU87SUFDN0Isd0JBQUEsR0FBRyxLQUFLO0lBQzBELHFCQUFBO0lBQ3pFLGlCQUFBO0lBQ0QsZ0JBQUEsY0FBYyxFQUFFLEdBQUc7SUFDbkIsZ0JBQUEsY0FBYyxFQUFFLEVBQUU7b0JBQ2xCLE9BQU87SUFDVixhQUFBLENBQUMsQ0FBQztJQUNILFlBQUEsTUFBTSxRQUFRLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRXhDLFlBQUEsTUFBTSxhQUFhLEdBQUcsUUFBUSxDQUFlLEVBQUUsV0FBVyxFQUFFLENBQUMsQ0FBQyxLQUFJLEVBQUcsY0FBYyxDQUFDLENBQUMsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBRSxPQUFPLEVBQUUsRUFBRSxFQUFFLFFBQVEsRUFBRSxDQUFDLENBQUM7Z0JBRWhJLE9BQU87SUFDSCxnQkFBQSwwQ0FBMEMsRUFBRSxDQUFDLEtBQXlDLEtBQUssYUFBYSxDQUFDLDhCQUE4QixDQUFDLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDNUssZ0JBQUEsY0FBYyxFQUFFLE9BQU87b0JBQ3ZCLGVBQWUsRUFBRSxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLGFBQWEsRUFBRTtpQkFDeEUsQ0FBQztJQUNOLFNBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ25CLHFDQUFxQyxFQUFFSSxHQUFXLENBQUMsQ0FBQyxHQUFHLENBQTRDLEtBQU8sRUFBQSxPQUFPLHNCQUFzQixDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUEsRUFBRSxFQUFFLEVBQUUsQ0FBQztJQUNwSixRQUFBLEdBQUcsUUFBUTtJQUNYLFFBQUEsZUFBZSxFQUFFLEVBQUU7U0FDdEIsQ0FBQTtJQUNMLENBQUM7YUEwRmUsd0NBQXdDLENBQW1GLEVBQUUsZ0JBQWdCLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFnRyxFQUFBO1FBRW5XLE1BQU0sRUFDRixnQkFBZ0IsRUFDaEIsR0FBRyxrQkFBa0IsRUFDeEIsR0FBRyxtQkFBbUIsQ0FBa0M7SUFDckQsUUFBQSxxQkFBcUIsRUFBRSxFQUFFLFFBQVEsRUFBRUEsR0FBVyxDQUFDLENBQUMsR0FBRyxLQUFLLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLEVBQUU7SUFDeEUsUUFBQSxnQkFBZ0IsRUFBRTtJQUNkLFlBQUEsUUFBUSxFQUFFQSxHQUFXLENBQUMsQ0FBQyxHQUFHLEtBQUssR0FBRyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUM7SUFDN0MsWUFBQSxPQUFPLEVBQUVBLEdBQVcsQ0FBQyxDQUFDLEdBQUcsRUFBRSxHQUFHLE9BQU8sT0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUM7SUFDaEUsU0FBQTtJQUNKLEtBQUEsQ0FBQyxDQUFDO1FBRUgsTUFBTSxFQUFFLHFCQUFxQixFQUFFLEVBQUUsY0FBYyxFQUFFLFlBQVksRUFBRSxFQUFFLEdBQUcsa0JBQWtCLENBQUM7UUFFdkYsTUFBTSxFQUNGLHFDQUFxQyxFQUNyQyxxQ0FBcUMsRUFDckMsR0FBRyxpQkFBaUIsRUFDdkIsR0FBRyxnQ0FBZ0MsQ0FBb0M7SUFDcEUsUUFBQSxnQkFBZ0IsRUFBRSxnQkFBZ0I7WUFDbEMsY0FBYyxFQUFFLEVBQUUsY0FBYyxFQUFFLFlBQVksRUFBRSxHQUFHLGNBQWMsRUFBRTtJQUNuRSxRQUFBLGVBQWUsRUFBRSxlQUFlO0lBQ2hDLFFBQUEsY0FBYyxFQUFFLGNBQWM7SUFDOUIsUUFBQSxtQkFBbUIsRUFBRSxtQkFBbUI7SUFDeEMsUUFBQSxlQUFlLEVBQUUsZUFBZTtJQUNoQyxRQUFBLGlCQUFpQixFQUFFLGlCQUFpQjtJQUN2QyxLQUFBLENBQUMsQ0FBQztJQUVILElBQUEsTUFBTSw2Q0FBNkMsR0FBRyxDQUFDLEtBQTBGLEtBQUk7WUFDakosUUFBUSxxQ0FBcUMsQ0FBQyxnQkFBZ0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFO0lBQzVFLEtBQUMsQ0FBQTtJQUNELElBQUEsTUFBTSw2Q0FBNkMsR0FBRyxDQUFDLENBQThGLEtBQUk7SUFDckosUUFBQSxPQUFPLHFDQUFxQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BELEtBQUMsQ0FBQTtJQUVELElBQUEsUUFBUTtZQUNKLDZDQUE2QztZQUM3Qyw2Q0FBNkM7O0lBRTdDLFFBQUEsR0FBRyxrQkFBa0I7SUFDckIsUUFBQSxHQUFHLGlCQUFpQjtJQUN2QixLQUFBLEVBQUU7SUFFUCxDQUFDO0lBMEJlLFNBQUEsa0JBQWtCLENBQW9ELEVBQUUsUUFBUSxFQUFFLGVBQWUsRUFBRSxjQUFjLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBb0QsRUFBQTtJQUN2TSxJQUFBLE1BQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxlQUFlLEVBQUUsQ0FBQztRQUN6QyxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUM7SUFFaEIsSUFBQSxJQUFJLGVBQWUsS0FBSyxDQUFDLENBQUMsRUFBRTtJQUN4QixRQUFBLFFBQVEsTUFBTSxJQUFJLEtBQUssS0FBSyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNO2dCQUNuRyxNQUFNLEdBQUcsY0FBYyxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUV0RCxRQUFBLE9BQU8sTUFBTSxHQUFHLEtBQUssR0FBRyxjQUFjLENBQUMsS0FBSyxDQUFDLEdBQUcsTUFBTSxDQUFDO0lBQzFELEtBQUE7YUFDSSxJQUFJLGVBQWUsS0FBSyxDQUFDLEVBQUU7WUFDNUIsT0FBTyxDQUFDLE1BQU0sSUFBSSxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsT0FBTyxDQUFDLE1BQU07Z0JBQ2xHLE1BQU0sR0FBRyxjQUFjLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0lBRXRELFFBQUEsT0FBTyxNQUFNLEdBQUcsS0FBSyxHQUFHLGNBQWMsQ0FBQyxLQUFLLENBQUMsR0FBRyxNQUFNLENBQUM7SUFDMUQsS0FBQTtJQUNJLFNBQUE7SUFDRCxRQUFBLE9BQU8sS0FBSyxDQUFDO0lBQ2hCLEtBQUE7SUFDTDs7SUNyaEJNLFNBQVUsaUJBQWlCLENBUS9CLEVBQ0UsZUFBZSxFQUFFLEVBQUUsRUFDbkIsY0FBYyxFQUFFLEdBQUcsRUFDbkIsY0FBYyxFQUFFLEVBQUUsRUFDbEIsZ0JBQWdCLEVBQUUsRUFBRSxFQUNwQixtQkFBbUIsRUFBRSxFQUFFLEVBQ3NDLEVBQUE7SUFDN0QsSUFBQSxNQUFNLENBQUMsYUFBYSxFQUFFLGdCQUFnQixFQUFFLGdCQUFnQixDQUFDLEdBQUcsUUFBUSxDQUFnQixHQUFHLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBRTNHLElBQUEsTUFBTSxFQUNGLHNCQUFzQixFQUFFLCtCQUErQixFQUN2RCxzQkFBc0IsRUFBRSxrQ0FBa0MsRUFDMUQsR0FBRyxrQkFBa0IsRUFDeEIsR0FBRyxpQkFBaUIsQ0FBNEQ7SUFDN0UsUUFBQSxlQUFlLEVBQUUsRUFBRTtJQUNuQixRQUFBLGNBQWMsRUFBRSxHQUFHO0lBQ25CLFFBQUEsY0FBYyxFQUFFLEVBQUU7WUFDbEIsZ0JBQWdCLEVBQUUsRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLEVBQUU7SUFDekQsUUFBQSxtQkFBbUIsRUFBRSxFQUFFO0lBQzFCLEtBQUEsQ0FBQyxDQUFDO0lBR0gsSUFBQSxNQUFNLG9CQUFvQixHQUFHQSxHQUFXLENBQXdHLENBQUMsRUFBRSxtQkFBbUIsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsUUFBUSxFQUFFLEtBQUk7Ozs7SUFJL00sUUFBQSxNQUFNLFNBQVMsR0FBRyxpQkFBaUIsQ0FBQyxNQUFLO0lBQ3JDLFlBQUEsTUFBTSxFQUFFLEdBQUcsZ0JBQWdCLEVBQUUsQ0FBQztJQUM5QixZQUFBLElBQUksT0FBTyxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUU7SUFDbEMsZ0JBQUEsT0FBTyxDQUFDLGNBQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQztJQUN0QyxhQUFBO0lBQ0ksaUJBQUE7SUFDRCxnQkFBQSxlQUFlLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztJQUNsQyxhQUFBO0lBQ0wsU0FBQyxDQUFDLENBQUM7WUFFSCxNQUFNLG9CQUFvQixHQUFHLCtCQUErQixDQUFDO2dCQUN6RCxZQUFZLEVBQUUsT0FBTyxDQUFDLFlBQVk7SUFDbEMsWUFBQSxjQUFjLEVBQUUsRUFBRSxHQUFHLE9BQU8sQ0FBQyxjQUFjLEVBQUU7Z0JBQzdDLGNBQWMsRUFBRSxFQUFFLEdBQUcsT0FBTyxDQUFDLGNBQWMsRUFBRSxTQUFTLEVBQUU7Z0JBQ3hELE9BQU8sRUFBRSxPQUFPLENBQUMsT0FBTztJQUMzQixTQUFBLENBQUMsQ0FBQztZQUNILE1BQU0sRUFBRSxjQUFjLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSwyQkFBMkIsRUFBRSxHQUFHLG9CQUFvQixDQUFDO1lBQzNGVCxDQUFTLENBQUMsTUFBSztnQkFDWCxJQUFJLENBQUMsUUFBUSxFQUFFO0lBQ1gsZ0JBQUEsZUFBZSxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsQ0FBQztJQUNoQyxhQUFBO0lBQ0wsU0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztZQUVmLE1BQU0sZUFBZSxHQUFHLGlCQUFpQixDQUF3RDtJQUM3RixZQUFBLGVBQWUsRUFBRSxFQUFFLEdBQUcsUUFBUSxDQUFDLGVBQWUsRUFBRTtJQUNoRCxZQUFBLGNBQWMsRUFBRSxFQUFFLEdBQUcsUUFBUSxDQUFDLGNBQWMsRUFBRTtJQUM5QyxZQUFBLGdCQUFnQixFQUFFO29CQUNkLEdBQUcsUUFBUSxDQUFDLGdCQUFnQjtJQUM1QixnQkFBQSxtQkFBbUIsRUFBRSxRQUFRO0lBQ2hDLGFBQUE7Z0JBQ0QsbUJBQW1CLEVBQUUsRUFBRSxHQUFHLFFBQVEsQ0FBQyxtQkFBbUIsRUFBRSxXQUFXLEVBQUUsSUFBSSxFQUFFO0lBQzNFLFlBQUEsY0FBYyxFQUFFLEVBQUUsR0FBRyxRQUFRLENBQUMsY0FBYyxFQUFFO0lBQ2pELFNBQUEsQ0FBQyxDQUFDO1lBRUgsTUFBTSxFQUFFLGNBQWMsRUFBRSxFQUFFLGdCQUFnQixFQUFFLEVBQUUsc0JBQXNCLEVBQUUsd0JBQXdCLEVBQUUsc0JBQXNCLEVBQUUsNEJBQTRCLEVBQUUsY0FBYyxFQUFFLEVBQUUsZUFBZSxFQUFFLEVBQUUsR0FBRyxlQUFlLENBQUM7O0lBSTlNLFFBQUEsTUFBTSxxQkFBcUIsR0FBR1MsR0FBVyxDQUFrRSxDQUFDLEVBQUUsT0FBTyxFQUFFLFFBQVEsRUFBRSxFQUFFLHlCQUF5QixFQUFFLEdBQUcsUUFBUSxFQUFFLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsU0FBUyxFQUFFLEVBQUUsRUFBRSxHQUFHLEdBQUcsRUFBRSxFQUFFLEtBQUk7O0lBRzFQLFlBQUEsTUFBTSxTQUFTLEdBQUcsaUJBQWlCLENBQUMsTUFBSztJQUNyQyxnQkFBQSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDckMsZ0JBQUEsZ0JBQWdCLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxLQUFLLENBQUMsQ0FBQztJQUM1QyxnQkFBQSxJQUFJLEVBQUU7SUFDRixvQkFBQSxFQUFFLEVBQUUsQ0FBQzs7SUFFSixvQkFBQSxZQUFZLENBQUMsVUFBVSxFQUFxQyxFQUFFLEtBQUssSUFBSSxDQUFDO0lBQ2pGLGFBQUMsQ0FBQyxDQUFDO0lBQ0g7Ozs7O0lBS0s7Z0JBQ0wsTUFBTSxFQUNGLDJCQUEyQixFQUMzQixjQUFjLEVBQUUsWUFBWSxFQUMvQixHQUFHLHdCQUF3QixDQUFDO0lBQ3pCLGdCQUFBLFlBQVksRUFBRSxZQUFZO0lBQzFCLGdCQUFBLGNBQWMsRUFBRSxFQUFFLEdBQUcsRUFBRSxFQUFFO0lBQ3pCLGdCQUFBLGNBQWMsRUFBRSxFQUFFLFNBQVMsRUFBRSxHQUFHLEdBQUcsRUFBRTtvQkFDckMsT0FBTztJQUNWLGFBQUEsQ0FBQyxDQUFDO0lBRUgsWUFBQSxNQUFNLEVBQUUsZ0JBQWdCLEVBQUUsR0FBRyxXQUFXLENBQWM7b0JBQ2xELHlCQUF5QixFQUFFLGlCQUFpQixDQUFDLENBQUMsT0FBZ0IsRUFBRSxJQUF5QixLQUFJO0lBQ3pGLG9CQUFBLHlCQUF5QixHQUFHLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUMzQyxvQkFBQSxJQUFJLE9BQU8sRUFBRTtJQUNULHdCQUFBLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNyQyx3QkFBQSxnQkFBZ0IsQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLEtBQUssQ0FBQyxDQUFDO0lBQy9DLHFCQUFBO0lBQ0wsaUJBQUMsQ0FBQztJQUNGLGdCQUFBLEdBQUcsUUFBUTtJQUNkLGFBQUEsQ0FBQyxDQUFBO0lBRUYsWUFBQSxNQUFNLEdBQUcsR0FBMEQ7b0JBQy9ELGNBQWMsRUFBRSxFQUFFLGdCQUFnQixFQUFFO0lBQ3BDLGdCQUFBLGNBQWMsRUFBRSxZQUFZO0lBQzVCLGdCQUFBLDBCQUEwQixFQUFFLFVBQXVELEtBQVEsRUFBSSxFQUFBLE9BQU8sMkJBQTJCLENBQUMsNEJBQTRCLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7aUJBQzlMLENBQUE7SUFFRCxZQUFBLE9BQU8sR0FBRyxDQUFDO2FBRWQsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVQLFFBQUEsTUFBTSxHQUFHLEdBQWtHO0lBQ3ZHLFlBQUEsZUFBZSxFQUFFO29CQUNiLGdCQUFnQixFQUFFLGVBQWUsQ0FBQyxnQkFBZ0I7b0JBQ2xELGNBQWMsRUFBRSxlQUFlLENBQUMsY0FBYztvQkFDOUMsZUFBZSxFQUFFLGVBQWUsQ0FBQyxlQUFlO29CQUNoRCxjQUFjLEVBQUUsZUFBZSxDQUFDLGNBQWM7b0JBQzlDLG1CQUFtQixFQUFFLGVBQWUsQ0FBQyxtQkFBbUI7SUFFM0QsYUFBQTtJQUNELFlBQUEsVUFBVSxFQUFFLG9CQUFvQjtnQkFFaEMscUJBQXFCO2dCQUNyQix5QkFBeUIsRUFBRSxVQUFzRCxLQUFRLEVBQUE7SUFDckYsZ0JBQUEsTUFBTSxHQUFHLEdBQUcsMkJBQTJCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0MsZ0JBQUEsR0FBRyxDQUFDLFFBQVEsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUNsQixnQkFBQSxPQUFPLEdBQUcsQ0FBQztpQkFDZDthQUNKLENBQUE7SUFFRCxRQUFBLE9BQU8sR0FBRyxDQUFDO1NBQ2QsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQLE9BQU87SUFDSCxRQUFBLGNBQWMsRUFBRTtnQkFDWixnQkFBZ0I7Z0JBQ2hCLGFBQWE7SUFDaEIsU0FBQTtZQUNELGdCQUFnQixFQUFFLGtCQUFrQixDQUFDLGdCQUFnQjtZQUNyRCxjQUFjLEVBQUUsa0JBQWtCLENBQUMsY0FBYztZQUNqRCxjQUFjLEVBQUUsa0JBQWtCLENBQUMsY0FBYztZQUNqRCxtQkFBbUIsRUFBRSxrQkFBa0IsQ0FBQyxtQkFBbUI7WUFDM0QsZUFBZSxFQUFFLGtCQUFrQixDQUFDLGVBQWU7WUFDbkQsb0JBQW9CO0lBQ3BCLFFBQUEsc0JBQXNCLEVBQUUsa0NBQWtDO1NBQzdELENBQUE7SUFDTDs7YUM5TmdCLFdBQVcsQ0FBQyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQWUsRUFBQTs7SUFFM0QsSUFBQSxNQUFNLGNBQWMsR0FBRyxpQkFBaUIsQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNuRCxJQUFBLE1BQU0sV0FBVyxHQUFHLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUU5Q1QsQ0FBUyxDQUFDLE1BQUs7SUFDWCxRQUFBLE1BQU0sUUFBUSxHQUFHLFdBQVcsRUFBRSxDQUFDO1lBQy9CLElBQUksYUFBYSxHQUFHLFFBQVEsQ0FBQztZQUU3QixJQUFJLFFBQVEsSUFBSSxJQUFJO2dCQUNoQixPQUFPOzs7WUFLWCxNQUFNLGtCQUFrQixHQUFHLE1BQUs7SUFDNUIsWUFBQSxjQUFjLEVBQUUsQ0FBQztJQUNqQixZQUFBLE1BQU0sZUFBZSxHQUFHLFdBQVcsRUFBRSxDQUFDO2dCQUN0QyxJQUFJLGVBQWUsSUFBSSxhQUFhLEVBQUU7b0JBQ2xDLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQztvQkFDdEIsSUFBSSxlQUFlLElBQUksSUFBSTt3QkFDdkIsTUFBTSxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxhQUFhLEdBQUcsZUFBZSxDQUFDLENBQUM7SUFDakYsYUFBQTtJQUNMLFNBQUMsQ0FBQTtZQUNELElBQUksTUFBTSxHQUFHLFdBQVcsQ0FBQyxrQkFBa0IsRUFBRSxRQUFRLENBQUMsQ0FBQztJQUN2RCxRQUFBLE9BQU8sTUFBTSxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDdEMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNYOztJQ3hDTyxNQUFNLGVBQWUsR0FBRyxNQUFLO1FBQ2hDLE1BQU0sQ0FBQyxRQUFRLEVBQUUsV0FBVyxDQUFDLEdBQUdWLENBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUUvQyxNQUFNLENBQUMsU0FBUyxFQUFFLFlBQVksQ0FBQyxHQUFHQSxDQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFFOUMsV0FBVyxDQUFDLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLFlBQVksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFbEUsUUFDSXlMLGFBQUssS0FBSyxFQUFDLE1BQU0sRUFDYixRQUFBLEVBQUEsQ0FBQUEsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLHFCQUFBLEVBQTBCQyxHQUFPLENBQUEsT0FBQSxFQUFBLEVBQUEsSUFBSSxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEVBQUEsQ0FBSSxJQUFRLEVBQ3BJRCxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsK0JBQUEsRUFBbUMsU0FBUyxFQUFBLE9BQUEsRUFBTyxTQUFTLEtBQUssQ0FBQyxHQUFHLEVBQUUsR0FBRyxHQUFHLEVBQUEsR0FBQSxDQUFBLEVBQUEsQ0FBUSxDQUNuRixFQUFBLENBQUEsRUFDVDtJQUNMLENBQUM7O0lDWkQsTUFBTUUsYUFBVyxHQUFHLCtiQUErYixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUUvZCxTQUFTeEQsYUFBVyxHQUFBO1FBQ2hCLE9BQU8sTUFBTSxDQUFDLFFBQVEsQ0FBQztJQUMzQixDQUFDO0lBR0QsTUFBTSxrQkFBa0IsR0FBRzNLLENBQWEsQ0FBMkUsSUFBSyxDQUFDLENBQUE7SUFDbEgsTUFBTSxxQkFBcUIsR0FBR3FGLENBQUksQ0FBQyxNQUFLO1FBRTNDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQUMsT0FBaUMsQ0FBQyxDQUFDO1FBQ3RGLE1BQU0sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEdBQUcsUUFBUSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3ZDLE1BQU0sQ0FBQyxhQUFhLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDdEQsTUFBTSxDQUFDLGFBQWEsRUFBRSxxQkFBcUIsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUUzRCxJQUFBLE1BQU0sRUFDRixlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFDN0IsNkNBQTZDLEVBQzdDLDZDQUE2QyxFQUM3QyxjQUFjLEVBQUUsRUFBRSxnQkFBZ0IsRUFBRSxFQUNwQyxtQkFBbUIsRUFBRSxFQUFFLGdCQUFnQixFQUFFLEVBQ3pDLGdCQUFnQixFQUFFLEVBQUUsT0FBTyxFQUFFLEdBQ2hDLEdBQUcsd0NBQXdDLENBQThDO0lBQ3RGLFFBQUEsZ0JBQWdCLEVBQUUsRUFBRTtJQUNwQixRQUFBLGNBQWMsRUFBRSxFQUFFO0lBQ2xCLFFBQUEsZUFBZSxFQUFFLEVBQUU7SUFDbkIsUUFBQSxjQUFjLEVBQUUsRUFBRSxxQkFBcUIsRUFBRTFCLEdBQVcsQ0FBQyxDQUFDLEtBQW9CLEtBQUksRUFBRyxJQUFJLEtBQUssSUFBSSxJQUFJO29CQUFFLHFCQUFxQixDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRTtJQUMxSSxRQUFBLG1CQUFtQixFQUFFLEVBQUU7SUFDdkIsUUFBQSxlQUFlLEVBQUUsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLHFCQUFxQixFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsS0FBSyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUMsRUFBRTtJQUN2RyxRQUFBLGlCQUFpQixFQUFFLEVBQUk7SUFDMUIsS0FBQSxDQUFDLENBQUM7SUFFSCxJQUFBLFFBQ0lzSyxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUssU0FBUyxFQUFDLE1BQU0sRUFBQSxRQUFBLEVBQUEsQ0FDakJDLEdBQXVDLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLDRCQUFBLEVBQUEsQ0FBQSxFQUN2Q0EsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQUEsR0FBQSxDQUFBLE1BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxtQkFBQSxFQUFBLENBQThCLEVBQUssQ0FBQSxFQUV2Q0QsZ1RBR3dFQyxHQUFPLENBQUEsTUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQVUsRUFBUSxDQUFBLEVBQUEsNENBQUEsQ0FBQSxFQUFBLENBQThDLEVBRS9JRCxHQUFBLENBQUEsR0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsbVJBQUEsRUFFaUhDLEdBQWUsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsRUFBQSw4REFBQSxDQUFBLEVBQUEsQ0FDNUgsRUFDSkQsR0FBQSxDQUFBLEdBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGlMQUFBLEVBQ21MQyxHQUFrQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxXQUFBLEVBQUEsQ0FBQSxFQUFBLGdEQUFBLENBQUEsRUFBQSxDQUNqTSxFQUVKRCxHQUFBLENBQUEsR0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQ0lDLEdBQThCLENBQUEsTUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLG1CQUFBLEVBQUEsQ0FBQSxFQUFBLDhDQUFBLEVBQTRDQSw4Q0FBOEIsRUFBRSxJQUFBLEVBQUFBLEdBQUEsQ0FBQSxNQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEscUJBQUEsRUFBQSxDQUFnQyxFQUFFLElBQUEsRUFBQUEsR0FBQSxDQUFBLE1BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSx3QkFBQSxFQUFBLENBQW1DLEVBRS9LLHlKQUFBLENBQUEsRUFBQSxDQUFBLEVBRUpELEdBQ0ksQ0FBQSxHQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLE1BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxtQkFBQSxFQUFBLENBQThCLEVBQU0sUUFBQSxFQUFBQSxHQUFBLENBQUEsTUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLG1CQUFBLEVBQUEsQ0FBOEIsRUFBaUIsbUJBQUEsRUFBQUEsR0FBQSxDQUFBLE1BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxpQkFBQSxFQUFBLENBQTRCLEVBQ1UseU1BQUEsRUFBQUEsR0FBQSxDQUFBLE1BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSx3QkFBQSxFQUFBLENBQW1DLEVBQTZDLCtDQUFBLEVBQUFBLEdBQUEsQ0FBQSxNQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLENBQW9CLG1MQUVoS0EsR0FBb0IsQ0FBQSxNQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLENBQUEsRUFBQSwyREFBQSxFQUF5REEsR0FBb0IsQ0FBQSxNQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBQSxFQUFBLENBQUEsRUFBQSxzQkFBQSxDQUFBLEVBQUEsQ0FDOUosRUFDSkQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLFlBQUEsRUFBaUJDLEdBQU8sQ0FBQSxPQUFBLEVBQUEsRUFBQSxJQUFJLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFNLEVBQUEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUEsRUFBRSxFQUFBLENBQUksQ0FBUSxFQUFBLENBQUEsRUFDckpBLEdBQVEsQ0FBQSxRQUFBLEVBQUEsRUFBQSxPQUFPLEVBQUUsTUFBTSxPQUFPLENBQUMsUUFBUSxDQUFDLEVBQUEsUUFBQSxFQUFBLFNBQUEsRUFBQSxDQUFrQixFQUMxREQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGtCQUFBLEVBQXVCQyxHQUFPLENBQUEsT0FBQSxFQUFBLEVBQUEsSUFBSSxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUUsYUFBYSxJQUFJLFNBQVMsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFHLEVBQUcsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxhQUFhLEVBQUUsS0FBSyxDQUFDLENBQUMsRUFBRSxFQUFBLENBQUksQ0FBUSxFQUFBLENBQUEsRUFDeExELEdBQXVCLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsa0JBQUEsRUFBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFPLElBQUksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFFLGFBQWEsSUFBSSxTQUFTLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBTSxFQUFBLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUMsRUFBRSxFQUFBLENBQUksQ0FBUSxFQUFBLENBQUEsRUFDakxELEdBQ0ksQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxpQkFBQSxFQUFBQSxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQU9DLGVBQU8sSUFBSSxFQUFDLHlCQUF5QixFQUFDLElBQUksRUFBQyxPQUFPLEVBQUMsT0FBTyxFQUFFLGFBQWEsSUFBSSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBRyxFQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBQSxDQUFJLGlCQUFpQixFQUNsTEQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFPQyxHQUFPLENBQUEsT0FBQSxFQUFBLEVBQUEsSUFBSSxFQUFDLHlCQUF5QixFQUFDLElBQUksRUFBQyxPQUFPLEVBQUMsT0FBTyxFQUFFLGFBQWEsSUFBSSxZQUFZLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBRyxFQUFHLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUUsRUFBSSxDQUFBLEVBQUEsaURBQUEsQ0FBQSxFQUFBLENBQXVELENBQzlOLEVBQUEsQ0FBQSxFQUVSQSxHQUFDLENBQUEsa0JBQWtCLENBQUMsUUFBUSxFQUFBLEVBQUMsS0FBSyxFQUFFLDZDQUE2QyxFQUFBLFFBQUEsRUFDN0VBLEdBQVEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxJQUFDLDZDQUE2QyxDQUFDO0lBQ25ELHdCQUFBLFFBQVEsRUFBRSxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsYUFBUztnQ0FDM0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssRUFBRSxFQUFFLENBQUMsRUFBRTtvQ0FDNUIsTUFBTUEsR0FBQSxDQUFDLDBCQUEwQixFQUFDLEVBQUEsS0FBSyxFQUFFLENBQUMsRUFBQSxFQUFPLENBQUMsQ0FBSSxDQUFBO0lBQ3pELDZCQUFBOzZCQUNKLEdBQUcsQ0FBQzt5QkFDUixDQUFDLENBQUMsRUFBTyxDQUFBLEVBQUEsQ0FDZ0IsRUFDN0IsZ0JBQWdCLElBQUlELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxhQUFBLEVBQWlCLGdCQUFnQixDQUFBLEVBQUEsQ0FBTyxDQUMzRCxFQUFBLENBQUEsRUFDUjtJQUNOLENBQUMsQ0FBQyxDQUFBO0lBR0YsTUFBTSwwQkFBMEIsR0FBRzVJLENBQUksRUFBRSxDQUFDLEVBQUUsS0FBSyxFQUFxQixLQUFJO0lBQ3RFLElBQUEsTUFBTSxNQUFNLElBQUksS0FBSyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBQzVCLElBQUEsTUFBTSxDQUFDLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxNQUFNOEksYUFBVyxDQUFDLEtBQUssMERBQXlELENBQUMsQ0FBQztJQUNoSCxJQUFBLE1BQU0sc0JBQXNCLEdBQUd2SyxHQUFVLENBQUMsa0JBQWtCLENBQUMsQ0FBQztJQUM5RCxJQUFBLE1BQU0sSUFBSSxHQUFHLENBQUEsRUFBRyxVQUFVLENBQUEsZUFBQSxFQUFrQixLQUFLLENBQUcsRUFBQSxNQUFNLEdBQUcsV0FBVyxHQUFHLEVBQUUsRUFBRSxDQUFDO1FBQ2hGLE1BQU0sRUFBRSwwQ0FBMEMsRUFBRSxjQUFjLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSxlQUFlLEVBQUUsRUFBRSxRQUFRLEVBQUUsRUFBRSxHQUFHLHNCQUFzQixDQUFDLEVBQUUsWUFBWSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFLEVBQUUsY0FBYyxFQUFFLEVBQUUsTUFBTSxFQUFFLEVBQUUsT0FBTyxFQUFFLEVBQUUsRUFBRSxRQUFRLEVBQUUsZUFBRStHLGFBQVcsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUV0USxJQUFBLE1BQU0sS0FBSyxHQUFHLDBDQUEwQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQzdELFFBQ0lzRCxlQUFRLEtBQUssRUFBQSxRQUFBLEVBQUEsQ0FBRyxJQUFJLEVBQUksSUFBQSxFQUFBLFFBQVEsR0FBRyxVQUFVLEdBQUcsY0FBYyxFQUFBLElBQUEsRUFBSSxRQUFRLEdBQUcsVUFBVSxHQUFHLGNBQWMsRUFBQSxHQUFBLEVBQUVDLGtCQUFXLDBDQUEwQyxDQUFDLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxDQUFRLEVBQUUsS0FBSyxFQUFFLEVBQUUsS0FBSyxFQUFFLEtBQUssRUFBRSxFQUFBLENBQUksQ0FBSyxFQUFBLENBQUEsRUFDL047SUFDTCxDQUFDLEVBQUU7O0lDakdJLE1BQU0sY0FBYyxHQUFHLE1BQUs7UUFDL0IsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRzFMLENBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsWUFBWSxFQUFFLGVBQWUsQ0FBQyxHQUFHQSxDQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFckQsTUFBTSxDQUFDLFNBQVMsRUFBRSxZQUFZLENBQUMsR0FBR0EsQ0FBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTlDLFVBQVUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLE1BQU0sWUFBWSxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQTtJQUU3RSxJQUFBLFFBQ0l5TCxHQUFLLENBQUEsS0FBQSxFQUFBLEVBQUEsS0FBSyxFQUFDLE1BQU0sYUFDYkEsR0FBeUIsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxvQkFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksVUFBVSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEdBQUksQ0FBUSxFQUFBLENBQUEsRUFDaklELEdBQW9CLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsZUFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLE1BQU0sRUFBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksZUFBZSxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUEsQ0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUM1SEQseURBQW1DLFNBQVMsRUFBQSxPQUFBLEVBQU8sU0FBUyxLQUFLLENBQUMsR0FBRyxFQUFFLEdBQUcsR0FBRyxFQUFRLEdBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxFQUFBLENBQ25GLEVBQ1Q7SUFDTCxDQUFDOztJQ1RELE1BQU0sV0FBVyxHQUFHLCtiQUErYixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUkvZCxNQUFNLGdCQUFnQixHQUFHLE1BQUs7UUFDMUIsTUFBTSxFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUUscUJBQXFCLEVBQUUsdUJBQXVCLEVBQUUsaUJBQWlCLEVBQUUsU0FBUyxFQUFFLEdBQUcsWUFBWSxDQUFpQixFQUFFLE1BQU0sRUFBRSxNQUFNLEVBQUUsQ0FBQyxDQUFDO0lBRXhLLElBQXNCLGNBQWMsQ0FBbUIsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFMUssQ0FBTSxDQUFtQixJQUFLLENBQUMsRUFBRSxFQUFDO1FBRXBHLE1BQU0sQ0FBQyxHQUFHLGlCQUFpQixDQUFDLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLENBQUMsQ0FBQztJQUU3RCxJQUFBLFFBQ0kwSyxHQUFTLENBQUEsS0FBQSxFQUFBLEVBQUEsR0FBQSxDQUFDLGFBRUwsY0FBYyxJQUFJLElBQUksSUFBSUEsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGdCQUFBLEVBQW1CQyxzQkFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBc0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBS0QsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFLLElBQUksRUFBSSxJQUFBLEVBQUEsS0FBSyxJQUFNLENBQUMsRUFBQSxDQUFNLElBQU0sRUFDbk0sWUFBWSxJQUFJLElBQUksSUFBSUEsMkNBQW9CQSxHQUN6QyxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFPRCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsTUFBQSxFQUFBLENBQWEsRUFBQUEsR0FBYSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxNQUFBLEVBQUEsQ0FBQSxFQUFBQSwrQkFBYSxFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGVBQUEsRUFBQSxDQUFzQixJQUFLLEVBQVEsQ0FBQSxFQUNyRkEseUJBQVEsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUlELHVCQUFJQyxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUMsQ0FBQyxJQUFJLEdBQU0sRUFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBQ0EsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxDQUFDLENBQUMsSUFBSSxHQUFNLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFLLENBQUMsRUFBUyxDQUFBLENBQUEsRUFBQSxDQUMxSSxJQUFNLEVBQ2RBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFNLEVBRUwsdUJBQXVCLElBQUksSUFBSSxJQUFJRCxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEseUJBQUEsRUFBNEJDLHNCQUFLLEtBQUssQ0FBQyxJQUFJLENBQUMsdUJBQXVCLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxJQUFJQSxzQkFBSyxJQUFJLEVBQUEsQ0FBTSxDQUFDLEVBQU0sQ0FBQSxDQUFBLEVBQUEsQ0FBTSxFQUNoSixxQkFBcUIsSUFBSSxJQUFJLElBQUlELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSwwQkFBQSxFQUE2QkMsc0JBQUsscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSUEsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFBLENBQU0sQ0FBQyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQU0sRUFFNUlBLEdBQU0sQ0FBQSxJQUFBLEVBQUEsRUFBQSxDQUFBLEVBQ0wsU0FBUyxJQUFJQSxHQUFBLENBQUEsS0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFNLFNBQVMsWUFBWSxLQUFLLEdBQUcsU0FBUyxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxFQUFPLENBQUEsQ0FBQSxFQUFBLENBQ25HLEVBQ1Q7SUFDTCxDQUFDLENBQUE7SUFFRCxNQUFNLGdCQUFnQixHQUFHLE1BQUs7SUFDMUIsSUFBQSxNQUFNLEVBQUUsaUJBQWlCLEVBQUUsR0FBRyxZQUFZLENBQWlCLEVBQUUsSUFBSSxFQUFFLEVBQUUsWUFBWSxFQUFFLHNEQUFzRCxFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBRy9JLElBQUEsUUFDSUEsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFBLEdBQVMsaUJBQWlCLENBQUMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFFM0MsUUFBQSxFQUFBLG1CQUFBLEVBQUEsQ0FBQSxFQUFDO0lBQ2YsQ0FBQyxDQUFBO0lBRUQsTUFBTSwyQkFBMkIsR0FBRyxNQUFLO1FBQ3JDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3hDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLEdBQUcsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3RDLElBQUEsaUJBQWlCLENBQUM7SUFDZCxRQUFBLFFBQVEsRUFBRSxDQUFDLEdBQUcsS0FBSTtnQkFDZCxRQUFRLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQTtJQUN2QixZQUFBLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDO2FBQzFDO0lBQ0osS0FBQSxDQUFDLENBQUM7UUFFSCxNQUFNLENBQUMsV0FBVyxFQUFFLGNBQWMsQ0FBQyxHQUFHLFFBQVEsQ0FBcUIsSUFBSSxDQUFDLENBQUM7SUFFekUsSUFBQSxNQUFNLEVBQUUsbUJBQW1CLEVBQUUsR0FBRyxjQUFjLENBQWlCLEVBQUUsWUFBWSxFQUFFLGNBQWMsRUFBRSxDQUFDLENBQUM7UUFFakcsUUFDSUEsZ0JBQVMsbUJBQW1CLENBQUMsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLEVBQUUsTUFBTSxFQUFFLENBQUEsRUFBRyxDQUFDLE1BQU0sR0FBRyxHQUFHLElBQUksR0FBRyxDQUFJLEVBQUEsQ0FBQSxFQUFFLEVBQUUsQ0FBQyxFQUFBLFFBQUEsRUFDL0dBLHVCQUFNLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsRUFBQSxDQUFPLEVBQy9DLENBQUEsRUFDUjtJQUNOLENBQUMsQ0FBQTtJQUdELE1BQU0sZ0JBQWdCLEdBQUc3SSxDQUFJLENBQUMsQ0FBQyxFQUFFLEtBQUssRUFBc0IsS0FBSTtRQUU1RCxNQUFNLENBQUMsTUFBTSxFQUFFLFNBQVMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU1QyxJQUFBLE1BQU0sRUFBRSxpQkFBaUIsRUFBRSxHQUFHLFlBQVksQ0FBaUIsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLENBQUMsQ0FBQzs7SUFHbkYsSUFBQSxNQUFNLFFBQVEsR0FBRyxpQkFBaUIsQ0FBQyxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FBQztRQUNyRixJQUFJLEtBQUssSUFBSSxDQUFDO0lBQ1YsUUFBQSxPQUFPNkksY0FBTyxDQUFDO0lBRW5CLElBQUEsUUFDSUQsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFLLFNBQVMsRUFBQyxNQUFNLEVBQUEsUUFBQSxFQUFBLENBQ2pCQSxHQUFlLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsVUFBQSxFQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQU8sSUFBSSxFQUFDLFVBQVUsRUFBQyxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQU0sRUFBQSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxFQUFFLEVBQUEsQ0FBSSxDQUFRLEVBQUEsQ0FBQSxFQUM1SUEsR0FBUyxDQUFBLEtBQUEsRUFBQSxFQUFBLEdBQUEsUUFBUSxFQUNiLFFBQUEsRUFBQUEsR0FBQSxDQUFDLHFCQUFxQixFQUFDLEVBQUEsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxLQUFLLElBQUksQ0FBQyxFQUFBLENBQUksRUFDaEYsQ0FBQSxDQUFBLEVBQUEsQ0FDSixFQUNSO0lBQ04sQ0FBQyxDQUFDLENBQUM7SUFHSCxNQUFNLHFCQUFxQixHQUFHN0ksQ0FBSSxDQUFDLENBQUMsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUE0RSxLQUFJO1FBR25JLFFBQ0k0SSxzQkFDSUMsR0FBeUIsQ0FBQSxRQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsVUFBQSxFQUFBLENBQUEsRUFDekJBLHVDQUF5QixFQUN6QkEsR0FBQSxDQUFBLFFBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxVQUFBLEVBQUEsQ0FBeUIsRUFDekJELEdBQWUsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxVQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBTSxFQUFBLENBQUMsQ0FBQyxjQUFjLEVBQUUsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLEVBQUUsRUFBSSxDQUFBLENBQUEsRUFBQSxDQUFRLENBRTdJLEVBQUEsQ0FBQSxFQUNMO0lBQ04sQ0FBQyxDQUFDLENBQUM7SUFFSCxNQUFNLG9CQUFvQixHQUFHN0ksQ0FBSSxDQUFDLE1BQUs7UUFFbkMsTUFBTSxDQUFDLE9BQU8sRUFBRSxVQUFVLENBQUMsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDN0MsTUFBTSxDQUFDLFFBQVEsRUFBRSxXQUFXLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDNUMsSUFBQSxNQUFNLENBQUMsV0FBVyxFQUFFLGNBQWMsRUFBRSxjQUFjLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDdEUsTUFBTSxDQUFDLGtCQUFrQixFQUFFLHFCQUFxQixDQUFDLEdBQUcsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXBFLE1BQU0sWUFBWSxJQUFJLENBQUMsRUFBUSxFQUFFLEVBQStDLEtBQUssSUFBSSxPQUFPLENBQU8sQ0FBQyxPQUFPLEVBQUUsTUFBTSxLQUFLLE1BQU0sQ0FBQyxVQUFVLENBQUMsTUFBTSxjQUFjLEVBQUUsR0FBRyxNQUFNLEVBQUUsR0FBRyxPQUFPLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDeE0sTUFBTSxFQUNGLFNBQVMsRUFDVCxXQUFXLEVBQ1gsVUFBVSxFQUNWLFdBQVcsRUFDWCxPQUFPLEVBQ1AsUUFBUSxFQUNSLFdBQVcsRUFDWCxZQUFZLEVBQ2YsR0FBRyxlQUFlLENBQW9ELFlBQVksRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFLLEdBQUksRUFBRSxRQUFRLEVBQUUsUUFBUSxJQUFJLENBQUMsR0FBRyxTQUFTLEdBQUcsUUFBUSxFQUFFLENBQUMsQ0FBQztRQUU3SixNQUFNLE9BQU8sR0FBRyxPQUFPLEdBQUcsU0FBUyxHQUFHLFdBQVcsQ0FBQztRQUVsRCxRQUNJNEksYUFBSyxTQUFTLEVBQUMsTUFBTSxFQUNqQixRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLFFBQUEsRUFBQSxFQUFRLFFBQVEsRUFBRSxPQUFPLElBQUksa0JBQWtCLEVBQUUsT0FBTyxFQUFFLE9BQU8sMEJBQW9CLEVBQ3JGRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUEsYUFBQSxFQUFrQkMsZUFBTyxJQUFJLEVBQUMsUUFBUSxFQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsRUFBQSxDQUFJLENBQVEsRUFBQSxDQUFBLEVBQzFIRCxHQUFzQixDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGlCQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBSSxDQUFBLENBQUEsRUFBQSxDQUFRLEVBQ3BJRCxHQUE4QixDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLHlCQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLHFCQUFxQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUksQ0FBUSxFQUFBLENBQUEsRUFDMUpELHdDQUFpQkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLElBQUksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLFdBQVcsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxHQUFJLENBQVEsRUFBQSxDQUFBLEVBQzNIRCwwQkFDSUMsR0FDSSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQUQsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQyxnQ0FBYyxFQUNkQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLE9BQUEsRUFBQSxDQUFjLElBQ2IsRUFDRCxDQUFBLEVBQ1JELDBCQUNJQSxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBQSxFQUFBLENBQWtCLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBUyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDL0NELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBSUMsc0NBQW9CLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssV0FBVyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDbkRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxjQUFBLEVBQUEsQ0FBcUIsRUFBQUEsR0FBSyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxZQUFZLEdBQU0sQ0FBSyxFQUFBLENBQUEsRUFDckRELHVCQUFJQyxHQUFvQixDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxhQUFBLEVBQUEsQ0FBQSxFQUFBQSxzQkFBSyxXQUFXLEVBQUEsQ0FBTSxDQUFLLEVBQUEsQ0FBQSxFQUNuREQsR0FBSSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFVBQUEsRUFBQSxDQUFpQixFQUFBQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFFBQVEsQ0FBQyxRQUFRLEVBQUUsR0FBTSxDQUFLLEVBQUEsQ0FBQSxFQUN4REQsdUJBQUlDLEdBQW1CLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLFlBQUEsRUFBQSxDQUFBLEVBQUFBLHNCQUFLLFVBQVUsQ0FBQyxRQUFRLEVBQUUsRUFBQSxDQUFNLElBQUssQ0FDeEQsRUFBQSxDQUFBLENBQUEsRUFBQSxDQUNKLENBQ04sRUFBQSxDQUFBLEVBQ1I7SUFDTixDQUFDLENBQUMsQ0FBQztJQUVILE1BQU0sb0JBQW9CLEdBQUc3SSxDQUFJLENBQUMsTUFBSztRQUVuQyxNQUFNLENBQUMsT0FBTyxFQUFFLFVBQVUsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsUUFBUSxFQUFFLFdBQVcsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxJQUFBLE1BQU0sQ0FBQyxXQUFXLEVBQUUsY0FBYyxFQUFFLGNBQWMsQ0FBQyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN0RSxNQUFNLENBQUMsa0JBQWtCLEVBQUUscUJBQXFCLENBQUMsR0FBRyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFcEUsTUFBTSxDQUFDLElBQUksRUFBRSxPQUFPLENBQUMsR0FBRyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7UUFFckMsTUFBTSxZQUFZLEdBQUcsT0FBTyxDQUFTLEVBQUUsRUFBTyxLQUFLLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sS0FBSyxNQUFNLENBQUMsVUFBVSxDQUFDLE1BQUs7WUFDN0csSUFBSSxjQUFjLEVBQUUsRUFBRTtJQUNsQixZQUFBLE1BQU0sRUFBRSxDQUFDO0lBQ1osU0FBQTtJQUNJLGFBQUE7Z0JBQ0QsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1gsWUFBQSxPQUFPLEVBQUUsQ0FBQztJQUNiLFNBQUE7SUFDTCxLQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQztJQUViLElBQUEsTUFBTSxFQUNGLFNBQVMsRUFDVCxXQUFXLEVBQ1gsVUFBVSxFQUNWLFdBQVcsRUFDWCxjQUFjLEVBQ2QsT0FBTyxFQUNQLFFBQVEsRUFDUixXQUFXLEVBQ1gsWUFBWSxFQUNmLEdBQUcsZUFBZSxDQUFnRCxZQUFZLEVBQUUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUF3QyxLQUFPLEVBQUEsQ0FBQyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQSxFQUFFLEVBQUUsUUFBUSxFQUFFLFFBQVEsSUFBSSxDQUFDLEdBQUcsU0FBUyxHQUFHLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFHbFAsUUFDSTRJLGFBQUssU0FBUyxFQUFDLE1BQU0sRUFDakIsUUFBQSxFQUFBLENBQUFBLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxhQUFBLEVBQWtCQyxHQUFPLENBQUEsT0FBQSxFQUFBLEVBQUEsS0FBSyxFQUFFLFVBQVUsR0FBRyxjQUFjLEdBQUcsSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLElBQUksa0JBQWtCLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBSSxDQUFBLENBQUEsRUFBQSxDQUFRLEVBQzdJQSxHQUFNLENBQUEsSUFBQSxFQUFBLEVBQUEsQ0FBQSxFQUNORCxHQUFrQixDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGFBQUEsRUFBQUMsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFPLElBQUksRUFBQyxRQUFRLEVBQUMsS0FBSyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsQ0FBQyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxHQUFJLENBQVEsRUFBQSxDQUFBLEVBQzFIRCxHQUFzQixDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGlCQUFBLEVBQUFDLEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBTyxJQUFJLEVBQUMsVUFBVSxFQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsT0FBTyxFQUFFLENBQUMsSUFBSSxjQUFjLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBQSxDQUFJLElBQVEsRUFDcElELEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSx5QkFBQSxFQUE4QkMsR0FBTyxDQUFBLE9BQUEsRUFBQSxFQUFBLElBQUksRUFBQyxVQUFVLEVBQUMsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUkscUJBQXFCLENBQUMsQ0FBQyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsRUFBQSxDQUFJLElBQVEsRUFDMUpELEdBQUEsQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSxZQUFBLEVBQWlCQyxHQUFPLENBQUEsT0FBQSxFQUFBLEVBQUEsSUFBSSxFQUFDLFFBQVEsRUFBQyxLQUFLLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLElBQUksV0FBVyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLEVBQUEsQ0FBSSxJQUFRLEVBQzNIRCxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQ0lDLEdBQ0ksQ0FBQSxPQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUFELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FDSUMsR0FBYyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxPQUFBLEVBQUEsQ0FBQSxFQUNkQSxnQ0FBYyxDQUNiLEVBQUEsQ0FBQSxFQUFBLENBQ0QsRUFDUkQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQSxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBQSxFQUFBLENBQWtCLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBUyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDL0NELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBSUMsc0NBQW9CLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssV0FBVyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDbkRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxjQUFBLEVBQUEsQ0FBcUIsRUFBQUEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxZQUFZLEVBQUEsQ0FBTSxJQUFLLEVBQ3JERCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUlDLEdBQW9CLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGFBQUEsRUFBQSxDQUFBLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBVyxHQUFNLENBQUssRUFBQSxDQUFBLEVBQ25ERCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFB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
