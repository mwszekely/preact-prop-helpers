var bundle = (function (exports) {
    'use strict';

    var n,l$1,u$1,t$1,o$2,r$2,f$1={},e$2=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$1(n,l){for(var u in l)n[u]=l[u];return n}function a$1(n){var l=n.parentNode;l&&l.removeChild(n);}function h$1(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return v$1(l,f,t,o,null)}function v$1(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u$1:r};return null==r&&null!=l$1.vnode&&l$1.vnode(f),f}function p$1(n){return n.children}function d$1(n,l){this.props=n,this.context=l;}function _$1(n,l){if(null==l)return n.__?_$1(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?_$1(n):null}function k$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k$1(n)}}function b$1(n){(!n.__d&&(n.__d=!0)&&t$1.push(n)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2);}function g$2(){for(var n;g$2.__r=t$1.length;)n=t$1.sort(function(n,l){return n.__v.__b-l.__v.__b}),t$1=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=s$1({},t)).__v=t.__v+1,j$2(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?_$1(t):o,t.__h),z$1(u,t),t.__e!=o&&k$1(t)));});}function w$2(n,l,u,i,t,o,r,c,s,a){var h,y,d,k,b,g,w,x=i&&i.__k||e$2,C=x.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v$1(null,k,null,null,k):Array.isArray(k)?v$1(p$1,{children:k},null,null,null):k.__b>0?v$1(k.type,k.props,k.key,null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=x[h])||d&&k.key==d.key&&k.type===d.type)x[h]=void 0;else for(y=0;y<C;y++){if((d=x[y])&&k.key==d.key&&k.type===d.type){x[y]=void 0;break}d=null;}j$2(n,k,d=d||f$1,t,o,r,c,s,a),b=k.__e,(y=k.ref)&&d.ref!=y&&(w||(w=[]),d.ref&&w.push(d.ref,null,k),w.push(y,k.__c||b,k)),null!=b?(null==g&&(g=b),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=m$1(k,s,n):s=A$1(n,k,d,x,b,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_$1(d));}for(u.__e=g,h=C;h--;)null!=x[h]&&("function"==typeof u.type&&null!=x[h].__e&&x[h].__e==u.__d&&(u.__d=_$1(i,h+1)),N(x[h],x[h]));if(w)for(h=0;h<w.length;h++)M$1(w[h],w[++h],w[++h]);}function m$1(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l="function"==typeof i.type?m$1(i,l,u):A$1(u,i,i,t,i.__e,l));return l}function x(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){x(n,l);}):l.push(n)),l}function A$1(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function C$1(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H$1(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H$1(n,o,l[o],u[o],i);}function $$1(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c$1.test(l)?u:u+"px";}function H$1(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$$1(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$$1(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T$2:I,o):n.removeEventListener(l,o?T$2:I,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null!=u&&(!1!==u||"a"===l[0]&&"r"===l[1])?n.setAttribute(l,u):n.removeAttribute(l));}}function I(n){this.l[n.type+!1](l$1.event?l$1.event(n):n);}function T$2(n){this.l[n.type+!0](l$1.event?l$1.event(n):n);}function j$2(n,u,i,t,o,r,f,e,c){var a,h,v,y,_,k,b,g,m,x,A,C,$,H=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=l$1.__b)&&a(u);try{n:if("function"==typeof H){if(g=u.props,m=(a=H.contextType)&&t[a.__c],x=a?m?m.props.value:a.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in H&&H.prototype.render?u.__c=h=new H(g,x):(u.__c=h=new d$1(g,x),h.constructor=H,h.render=O$1),m&&m.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=H.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s$1({},h.__s)),s$1(h.__s,H.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state,v)null==H.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==H.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,k);});}if(h.context=x,h.props=g,h.__v=u,h.__P=n,A=l$1.__r,C=0,"prototype"in H&&H.prototype.render)h.state=h.__s,h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context);else do{h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++C<25);h.state=h.__s,null!=h.getChildContext&&(t=s$1(s$1({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,_)),$=null!=a&&a.type===p$1&&null==a.key?a.props.children:a,w$2(n,Array.isArray($)?$:[$],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L$1(i.__e,u,i,t,o,r,f,c);(a=l$1.diffed)&&a(u);}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l$1.__e(n,u,i);}}function z$1(n,u){l$1.__c&&l$1.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$1.__e(n,u.__v);}});}function L$1(l,u,i,t,o,r,e,c){var s,h,v,y=i.props,p=u.props,d=u.type,k=0;if("svg"===d&&(o=!0),null!=r)for(;k<r.length;k++)if((s=r[k])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[k]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(r=r&&n.call(l.childNodes),h=(y=i.props||f$1).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},k=0;k<l.attributes.length;k++)y[l.attributes[k].name]=l.attributes[k].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C$1(l,p,y,o,c),v)u.__k=[];else if(k=u.props.children,w$2(l,Array.isArray(k)?k:[k],u,i,t,o&&"foreignObject"!==d,r,e,r?r[0]:i.__k&&_$1(i,0),c),null!=r)for(k=r.length;k--;)null!=r[k]&&a$1(r[k]);c||("value"in p&&void 0!==(k=p.value)&&(k!==l.value||"progress"===d&&!k||"option"===d&&k!==y.value)&&H$1(l,"value",k,y.value,!1),"checked"in p&&void 0!==(k=p.checked)&&k!==l.checked&&H$1(l,"checked",k,y.checked,!1));}return l}function M$1(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$1.__e(n,i);}}function N(n,u,i){var t,o;if(l$1.unmount&&l$1.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M$1(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$1.__e(n,u);}t.base=t.__P=null;}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,"function"!=typeof n.type);i||null==n.__e||a$1(n.__e),n.__e=n.__d=void 0;}function O$1(n,l,u){return this.constructor(n,u)}function P$1(u,i,t){var o,r,e;l$1.__&&l$1.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,e=[],j$2(i,u=(!o&&t||i).__k=h$1(p$1,null,[u]),r||f$1,f$1,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,e,!o&&t?t:r?r.__e:i.firstChild,o),z$1(e,u);}function B(n,l){var u={__c:l="__cC"+r$2++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(b$1);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=e$2.slice,l$1={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l;}throw n}},u$1=0,d$1.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s$1({},this.state),"function"==typeof n&&(n=n(s$1({},u),this.props)),n&&s$1(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),b$1(this));},d$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),b$1(this));},d$1.prototype.render=p$1,t$1=[],g$2.__r=0,r$2=0;

    var o$1=0;function e$1(_,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:_,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--o$1,__source:f,__self:t};if("function"==typeof _&&(l=_.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return l$1.vnode&&l$1.vnode(a),a}

    var t,u,r$1,o,i=0,c=[],f=[],e=l$1.__b,a=l$1.__r,v=l$1.diffed,l=l$1.__c,m=l$1.unmount;function p(t,r){l$1.__h&&l$1.__h(u,t,i||r),i=0;var o=u.__H||(u.__H={__:[],__h:[]});return t>=o.__.length&&o.__.push({__V:f}),o.__[t]}function y(n){return i=1,d(z,n)}function d(n,r,o){var i=p(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):z(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}));}],i.__c=u),i.__}function _(r,o){var i=p(t++,3);!l$1.__s&&w$1(i.__H,o)&&(i.__=r,i.u=o,u.__H.__h.push(i));}function h(r,o){var i=p(t++,4);!l$1.__s&&w$1(i.__H,o)&&(i.__=r,i.u=o,u.__h.push(i));}function s(n){return i=5,F$1(function(){return {current:n}},[])}function F$1(n,u){var r=p(t++,7);return w$1(r.__H,u)?(r.__V=n(),r.u=u,r.__h=n,r.__V):r.__}function T$1(n,t){return i=8,F$1(function(){return n},t)}function q$1(n){var r=u.context[n.__c],o=p(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function b(){for(var t;t=c.shift();)if(t.__P)try{t.__H.__h.forEach(j$1),t.__H.__h.forEach(k),t.__H.__h=[];}catch(u){t.__H.__h=[],l$1.__e(u,t.__v);}}l$1.__b=function(n){u=null,e&&e(n);},l$1.__r=function(n){a&&a(n),t=0;var o=(u=n.__c).__H;o&&(r$1===u?(o.__h=[],u.__h=[],o.__.forEach(function(n){n.__V=f,n.u=void 0;})):(o.__h.forEach(j$1),o.__h.forEach(k),o.__h=[])),r$1=u;},l$1.diffed=function(t){v&&v(t);var i=t.__c;i&&i.__H&&(i.__H.__h.length&&(1!==c.push(i)&&o===l$1.requestAnimationFrame||((o=l$1.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),g$1&&cancelAnimationFrame(t),setTimeout(n);},r=setTimeout(u,100);g$1&&(t=requestAnimationFrame(u));})(b)),i.__H.__.forEach(function(n){n.u&&(n.__H=n.u),n.__V!==f&&(n.__=n.__V),n.u=void 0,n.__V=f;})),r$1=u=null;},l$1.__c=function(t,u){u.some(function(t){try{t.__h.forEach(j$1),t.__h=t.__h.filter(function(n){return !n.__||k(n)});}catch(r){u.some(function(n){n.__h&&(n.__h=[]);}),u=[],l$1.__e(r,t.__v);}}),l&&l(t,u);},l$1.unmount=function(t){m&&m(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{j$1(n);}catch(n){u=n;}}),u&&l$1.__e(u,r.__v));};var g$1="function"==typeof requestAnimationFrame;function j$1(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function k(n){var t=u;n.__c=n.__(),u=t;}function w$1(n,t){return !n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function z(n,t){return "function"==typeof t?t(n):t}

    function S(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function g(n,t){function e(n){var e=this.props.ref,r=e==n.ref;return !r&&e&&(e.call?e(null):e.current=null),t?!t(this.props,n)||!r:C(this.props,n)}function r(t){return this.shouldComponentUpdate=e,h$1(n,t)}return r.displayName="Memo("+(n.displayName||n.name)+")",r.prototype.isReactComponent=!0,r.__f=!0,r}(E.prototype=new d$1).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var w=l$1.__b;l$1.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),w&&w(n);};var A=l$1.__e;l$1.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);A(n,t,e,r);};var O=l$1.unmount;function T(){this.__u=0,this.t=null,this.__b=null;}function L(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function D(){this.u=null,this.o=null;}l$1.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),O&&O(n);},(T.prototype=new d$1).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=L(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=function n(t,e,r){return t&&(t.__v=null,t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)}),t.__c&&t.__c.__P===e&&(t.__e&&r.insertBefore(t.__e,t.__d),t.__c.__e=!0,t.__c.__P=r)),t}(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate();}},f=!0===t.__h;r.__u++||f||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i);},T.prototype.componentWillUnmount=function(){this.t=[];},T.prototype.render=function(n,t){if(this.__b){if(this.__v.__k){var e=document.createElement("div"),r=this.__v.__k[0].__c;this.__v.__k[0]=function n(t,e,r){return t&&(t.__c&&t.__c.__H&&(t.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),t.__c.__H=null),null!=(t=S({},t)).__c&&(t.__c.__P===r&&(t.__c.__P=e),t.__c=null),t.__k=t.__k&&t.__k.map(function(t){return n(t,e,r)})),t}(this.__b,e,r.__O=r.__P);}this.__b=null;}var u=t.__a&&h$1(p$1,null,n.fallback);return u&&(u.__h=null),[h$1(p$1,null,t.__a?null:n.children),u]};var F=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};(D.prototype=new d$1).__a=function(n){var t=this,e=L(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),F(t,n,r)):u();};e?e(o):o();}},D.prototype.render=function(n){this.u=null,this.o=new Map;var t=x(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},D.prototype.componentDidUpdate=D.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){F(n,e,t);});};var W="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,P=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|marker(?!H|W|U)|overline|paint|shape|stop|strikethrough|stroke|text(?!L)|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,$="undefined"!=typeof document,j=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(n){Object.defineProperty(d$1.prototype,n,{configurable:!0,get:function(){return this["UNSAFE_"+n]},set:function(t){Object.defineProperty(this,n,{configurable:!0,writable:!0,value:t});}});});var H=l$1.event;function Z(){}function Y(){return this.cancelBubble}function q(){return this.defaultPrevented}l$1.event=function(n){return H&&(n=H(n)),n.persist=Z,n.isPropagationStopped=Y,n.isDefaultPrevented=q,n.nativeEvent=n};var J={configurable:!0,get:function(){return this.class}},K=l$1.vnode;l$1.vnode=function(n){var t=n.type,e=n.props,r=e;if("string"==typeof t){var u=-1===t.indexOf("-");for(var o in r={},e){var i=e[o];$&&"children"===o&&"noscript"===t||"value"===o&&"defaultValue"in e&&null==i||("defaultValue"===o&&"value"in e&&null==e.value?o="value":"download"===o&&!0===i?i="":/ondoubleclick/i.test(o)?o="ondblclick":/^onchange(textarea|input)/i.test(o+t)&&!j(e.type)?o="oninput":/^onfocus$/i.test(o)?o="onfocusin":/^onblur$/i.test(o)?o="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(o)?o=o.toLowerCase():u&&P.test(o)?o=o.replace(/[A-Z0-9]/,"-$&").toLowerCase():null===i&&(i=void 0),/^oninput$/i.test(o)&&(o=o.toLowerCase(),r[o]&&(o="oninputCapture")),r[o]=i);}"select"==t&&r.multiple&&Array.isArray(r.value)&&(r.value=x(e.children).forEach(function(n){n.props.selected=-1!=r.value.indexOf(n.props.value);})),"select"==t&&null!=r.defaultValue&&(r.value=x(e.children).forEach(function(n){n.props.selected=r.multiple?-1!=r.defaultValue.indexOf(n.props.value):r.defaultValue==n.props.value;})),n.props=r,e.class!=e.className&&(J.enumerable="className"in e,null!=e.className&&(r.class=e.className),Object.defineProperty(r,"className",J));}n.$$typeof=W,K&&K(n);};var Q=l$1.__r;l$1.__r=function(n){Q&&Q(n),n.__c;};

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */
    function useEnsureStability(parentHookName, ...values) {
        useHelper(values.length, 0);
        values.forEach(useHelper);
        return;
        function useHelper(value, index) {
            // Make sure that the provided functions are perfectly stable across renders
            const helperToEnsureStability = s(value);
            const shownError = s(false);
            if (helperToEnsureStability.current != value) {
                if (!shownError.current) {
                    /* eslint-disable no-debugger */
                    debugger;
                    console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
                    shownError.current = true;
                }
            }
        }
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @returns
     */
    function usePassiveState(onChange, getInitialValue) {
        const valueRef = s(Unset$1);
        const warningRef = s(false);
        const cleanupCallbackRef = s(undefined);
        // Make sure that the provided functions are perfectly stable across renders
        useEnsureStability("usePassiveState", onChange, getInitialValue);
        // Shared between "dependency changed" and "component unmounted".
        const onShouldCleanUp = T$1(() => {
            const cleanupCallback = cleanupCallbackRef.current;
            if (cleanupCallback)
                cleanupCallback();
        }, []);
        // There are a couple places where we'd like to use our initial
        // value in place of having no value at all yet.
        // This is the shared code for that, used on mount and whenever
        // getValue is called.
        const tryEnsureValue = T$1(() => {
            if (valueRef.current === Unset$1 && getInitialValue != undefined) {
                try {
                    const initialValue = getInitialValue();
                    valueRef.current = initialValue;
                    cleanupCallbackRef.current = (onChange?.(initialValue, undefined) ?? undefined);
                }
                catch (ex) {
                    // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
                }
            }
        }, [ /* getInitialValue and onChange intentionally omitted */]);
        const getValue = T$1(() => {
            if (warningRef.current)
                console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
            // The first time we call getValue, if we haven't been given a value yet,
            // (and we were given an initial value to use)
            // return the initial value instead of nothing.
            if (valueRef.current === Unset$1)
                tryEnsureValue();
            return (valueRef.current === Unset$1 ? undefined : valueRef.current);
        }, []);
        h(() => {
            // Make sure we've run our effect at least once on mount.
            // (If we have an initial value, of course)
            tryEnsureValue();
        }, []);
        // The actual code the user calls to (possibly) run a new effect.
        const r = s({ microtaskQueued: false, arg: undefined, prevDep: undefined, handle: null });
        const setValue = T$1((arg) => {
            r.current.prevDep = valueRef.current === Unset$1 ? undefined : getValue();
            r.current.arg = arg;
            if (!r.current.microtaskQueued) {
                r.current.microtaskQueued = true;
                r.current.handle = setTimeout(() => {
                    r.current.microtaskQueued = false;
                    r.current.handle = null;
                    const prevDep = r.current.prevDep;
                    const arg = r.current.arg;
                    const dep = arg instanceof Function ? arg(prevDep) : arg;
                    if (dep !== valueRef.current) {
                        // Indicate to the user that they shouldn't call getValue during onChange
                        warningRef.current = true;
                        try {
                            // Call any registered cleanup function
                            onShouldCleanUp();
                            cleanupCallbackRef.current = (onChange?.(dep, prevDep) ?? undefined);
                            valueRef.current = dep;
                        }
                        finally {
                            // Allow the user to normally call getValue again
                            warningRef.current = false;
                        }
                    }
                }, 0);
            }
        }, []);
        return [getValue, setValue];
    }
    const Unset$1 = Symbol();
    // Easy constants for getInitialValue
    function returnTrue() { return true; }
    function returnFalse() { return false; }
    function returnNull() { return null; }
    function returnZero() { return 0; }

    function useMergedChildren({ children: lhs }, { children: rhs }) {
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return h$1(p$1, {}, lhs, rhs);
        }
    }

    function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */
    function useMergedClasses({ class: lhsClass, className: lhsClassName }, { class: rhsClass, className: rhsClassName }) {
        // Note: For the sake of forward compatibility, this function is labelled as
        // a hook, but as it uses no other hooks it technically isn't one.
        if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
            const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
            const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
            const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
            return Array.from(allClasses).join(" ");
        }
        else {
            return undefined;
        }
    }

    function processRef(instance, ref) {
        if (typeof ref === "function") {
            ref(instance);
        }
        else if (ref != null) {
            ref.current = instance;
        }
        else {
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
        }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */
    function useMergedRefs({ ref: rhs }, { ref: lhs }) {
        const combined = T$1((current) => {
            processRef(current, lhs);
            processRef(current, rhs);
        }, [lhs, rhs]);
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return combined;
        }
    }

    function styleStringToObject(style) {
        // TODO: This sucks D:
        return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
        // Easy case, when there are no styles to merge return nothing.
        if (!lhs?.style && !rhs?.style)
            return undefined;
        if (typeof lhs != typeof rhs) {
            // Easy cases, when one is null and the other isn't.
            if (lhs?.style && !rhs?.style)
                return lhs.style;
            if (!lhs?.style && rhs?.style)
                return rhs.style;
            // They're both non-null but different types.
            // Convert the string type to an object bag type and run it again.
            if (lhs?.style && rhs?.style) {
                // (useMergedStyles isn't a true hook -- this isn't a violation)
                if (typeof lhs?.style == "string")
                    return useMergedStyles({ style: styleStringToObject(lhs?.style) }, rhs);
                if (typeof rhs?.style == "string")
                    return useMergedStyles(lhs, { style: styleStringToObject(rhs?.style) });
            }
            // Logic???
            return undefined;
        }
        // They're both strings, just concatenate them.
        if (typeof lhs?.style == "string") {
            return `${lhs.style};${rhs?.style ?? ""}`;
        }
        // They're both objects, just merge them.
        return {
            ...(lhs?.style ?? {}),
            ...(rhs?.style ?? {})
        };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */
    function useMergedProps(lhsAll, rhsAll) {
        // First, separate the props we were given into two groups:
        // lhsAll and rhsAll contain all the props we were given, and
        // lhsMisc and rhsMisc contain all props *except* for the easy ones
        // like className and style that we already know how to merge.
        const { children: _lhsChildren, class: _lhsClass, className: _lhsClassName, style: _lhsStyle, ref: _lhsRef, ...lhsMisc } = lhsAll;
        const { children: _rhsChildren, class: _rhsClass, className: _rhsClassName, style: _rhsStyle, ref: _rhsRef, ...rhsMisc } = rhsAll;
        const ret = {
            ...lhsMisc,
            ref: useMergedRefs(lhsAll, rhsAll),
            style: useMergedStyles(lhsAll, rhsAll),
            className: useMergedClasses(lhsAll, rhsAll),
            children: useMergedChildren(lhsAll, rhsAll),
        };
        if (ret.ref === undefined)
            delete ret.ref;
        if (ret.style === undefined)
            delete ret.style;
        if (ret.className === undefined)
            delete ret.className;
        if (ret.children === undefined)
            delete ret.children;
        // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];
        const rhsEntries = Object.entries(rhsMisc);
        for (const [rhsKeyU, rhsValue] of rhsEntries) {
            const rhsKey = rhsKeyU;
            const lhsValue = lhsMisc[rhsKey];
            if (typeof lhsValue === "function" || typeof rhsValue === "function") {
                // They're both functions that can be merged (or one's a function and the other's null).
                // Not an *easy* case, but a well-defined one.
                const merged = mergeFunctions(lhsValue, rhsValue);
                ret[rhsKey] = merged;
            }
            else {
                // Uh...we're here because one of them's null, right?
                if (lhsValue == null && rhsValue == null) {
                    if (rhsValue === null && lhsValue === undefined)
                        ret[rhsKey] = rhsValue;
                    else
                        ret[rhsKey] = lhsValue;
                }
                if (lhsValue == null)
                    ret[rhsKey] = rhsValue;
                else if (rhsValue == null)
                    ret[rhsKey] = lhsValue;
                else if (rhsValue == lhsValue) ;
                else {
                    // Ugh.
                    // No good strategies here, just log it if requested
                    log?.(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
                    ret[rhsKey] = rhsValue;
                }
            }
        }
        return ret;
    }
    function mergeFunctions(lhs, rhs) {
        if (!lhs)
            return rhs;
        if (!rhs)
            return lhs;
        return (...args) => {
            const lv = lhs(...args);
            const rv = rhs(...args);
            if (lv instanceof Promise || rv instanceof Promise)
                return Promise.all([lv, rv]);
        };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */
    function useRefElement(args) {
        const { onElementChange, onMount, onUnmount } = (args ?? {});
        useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
        // Called (indirectly) by the ref that the element receives.
        const handler = T$1((e, prevValue) => {
            const cleanup = onElementChange?.(e, prevValue);
            if (prevValue)
                onUnmount?.(prevValue);
            if (e)
                onMount?.(e);
            return cleanup;
        }, []);
        // Let us store the actual (reference to) the element we capture
        const [getElement, setElement] = usePassiveState(handler, returnNull);
        const useRefElementProps = T$1((props) => useMergedProps({ ref: setElement }, props), []);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        return {
            useRefElementProps,
            getElement
        };
    }

    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    const microtasks = new Set();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.
    function forEachUpdater(window, map, value) {
        if (!microtasks.has(map)) {
            microtasks.add(map);
            queueMicrotask(() => {
                microtasks.delete(map);
                const updaters = map.get(window);
                if (updaters) {
                    for (const updater of updaters) {
                        updater?.(value);
                    }
                }
            });
        }
    }
    function focusout(e) {
        const window = e.target.ownerDocument.defaultView;
        if (e.relatedTarget == null) {
            forEachUpdater(window, activeElementUpdaters, null);
        }
    }
    function focusin(e) {
        const window = e.target.ownerDocument.defaultView;
        const currentlyFocusedElement = e.target;
        forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
        forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }
    function windowFocus(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, true);
        forEachUpdater(window, windowFocusedUpdaters, true);
    }
    function windowBlur(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, false);
        forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */
    function useActiveElement({ onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMount, onUnmount, onMountChange }) {
        useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, onMountChange, onMount, onUnmount);
        const { getElement, useRefElementProps } = useRefElement({
            onMount,
            onUnmount,
            onElementChange: T$1((element, prevValue) => {
                onMountChange?.(element, prevValue);
                if (element) {
                    const document = element.ownerDocument;
                    const window = document?.defaultView;
                    if ((activeElementUpdaters.get(window)?.size ?? 0) === 0) {
                        document?.addEventListener("focusin", focusin, { passive: true });
                        document?.addEventListener("focusout", focusout, { passive: true });
                        window?.addEventListener("focus", windowFocus, { passive: true });
                        window?.addEventListener("blur", windowBlur, { passive: true });
                    }
                    // Add them even if they're undefined to more easily
                    // manage the ">0 means don't add handlers" logic.
                    const localActiveElementUpdaters = activeElementUpdaters.get(window) ?? new Set();
                    const localLastActiveElementUpdaters = lastActiveElementUpdaters.get(window) ?? new Set();
                    const localWindowFocusedUpdaters = windowFocusedUpdaters.get(window) ?? new Set();
                    localActiveElementUpdaters.add(setActiveElement);
                    localLastActiveElementUpdaters.add(setLastActiveElement);
                    localWindowFocusedUpdaters.add(setWindowFocused);
                    activeElementUpdaters.set(window, localActiveElementUpdaters);
                    lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
                    windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
                    return () => {
                        activeElementUpdaters.get(window).delete(setActiveElement);
                        lastActiveElementUpdaters.get(window).delete(setLastActiveElement);
                        windowFocusedUpdaters.get(window).delete(setWindowFocused);
                        if (activeElementUpdaters.size === 0) {
                            document?.removeEventListener("focusin", focusin);
                            document?.removeEventListener("focusout", focusout);
                            window?.removeEventListener("focus", windowFocus);
                            window?.removeEventListener("blur", windowBlur);
                        }
                    };
                }
            }, [])
        });
        const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
        const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
        const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
        return { getElement, useActiveElementProps: useRefElementProps, getActiveElement, getLastActiveElement, getWindowFocused };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
    function base64(value) {
        return Table[value];
    }
    function random6Bits() {
        return Math.floor(Math.random() * 0b1000000);
    }
    function random64Bits() {
        return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */
    function generateRandomId(prefix) {
        return `${prefix ?? "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map();
    // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.
    const commitName = "diffed";
    const originalCommit = l$1[commitName];
    const newCommit = (...args) => {
        for (const [id, effectInfo] of toRun) {
            const oldInputs = previousInputs.get(id);
            if (argsChanged(oldInputs, effectInfo.inputs)) {
                effectInfo.cleanup?.();
                effectInfo.cleanup = effectInfo.effect();
                previousInputs.set(id, effectInfo.inputs);
            }
        }
        toRun.clear();
        originalCommit?.(...args);
    };
    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */
    function useBeforeLayoutEffect(effect, inputs) {
        /*(() => {
            const cleanup = useRef<void | (() => void) | null>(null);
            const prevArgsRef = useRef<Inputs>(null!);
            if (argsChanged(inputs, prevArgsRef.current)) {
                prevArgsRef.current = inputs!;
                if (cleanup.current)
                    cleanup.current();
                cleanup.current = effect();
            }
        })();*/
        const [id] = y(() => generateRandomId());
        toRun.set(id, { effect, inputs, cleanup: null });
        _(() => {
            return () => {
                toRun.delete(id);
                previousInputs.delete(id);
            };
        }, [id]);
    }
    function argsChanged(oldArgs, newArgs) {
        return !!(!oldArgs ||
            oldArgs.length !== newArgs?.length ||
            newArgs?.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */
    function useStableGetter(value) {
        const ref = s(Unset);
        useBeforeLayoutEffect(() => { ref.current = value; }, [value]);
        return T$1(() => {
            if (ref.current === Unset) {
                throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
            }
            return ref.current;
        }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */
    function useStableCallback(fn) {
        const currentCallbackGetter = useStableGetter(fn);
        return T$1((...args) => {
            return currentCallbackGetter()(...args);
        }, []);
    }

    const SharedAnimationFrameContext = B(null);
    /**
     * The (optionally non-stable) `callback` you provide will start running every frame after the component mounts.
     *
     * Passing `null` is fine and simply stops the effect until you restart it by providing a non-null callback.
     *
     * **This hook does not return anything at all, including no prop-modifying hooks**
     */
    function useAnimationFrame({ callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback ?? noop);
        const hasCallback = (callback != null);
        const sharedAnimationFrameContext = q$1(SharedAnimationFrameContext);
        _(() => {
            if (sharedAnimationFrameContext) {
                if (hasCallback) {
                    sharedAnimationFrameContext.addCallback(stableCallback);
                }
                else {
                    sharedAnimationFrameContext.removeCallback(stableCallback);
                }
            }
            else {
                if (hasCallback) {
                    // Get a wrapper around the wrapper around the callback
                    // that also calls `requestAnimationFrame` again.
                    const rafCallback = (ms) => {
                        handle = requestAnimationFrame(rafCallback);
                        stableCallback(ms);
                    };
                    let handle = requestAnimationFrame(rafCallback);
                    return () => cancelAnimationFrame(handle);
                }
            }
        }, [sharedAnimationFrameContext, hasCallback]);
    }
    // eslint-disable @typescript-eslint/no-empty-function
    function noop() { }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$5.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$4.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */
    function useState(initialState) {
        // We keep both, but overrride the `setState` functionality
        const [state, setStateP] = y(initialState);
        const ref = s(state);
        // Hijack the normal setter function 
        // to also set our ref to the new value
        const setState = T$1(value => {
            if (typeof value === "function") {
                const callback = value;
                setStateP(prevValue => {
                    const nextValue = callback(prevValue);
                    ref.current = nextValue;
                    return nextValue;
                });
            }
            else {
                ref.current = value;
                setStateP(value);
            }
        }, []);
        const getState = () => { return ref.current; };
        console.assert(ref.current === state || (typeof state === "number" && isNaN(state)));
        return [state, setState, getState];
    }

    function identity$1(...t) { return t; }
    function useThrottled(callback, wait, options) {
        const throttled = F$1(() => {
            return callback ? throttle(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.trailing]);
        _(() => {
            return () => throttled?.cancel();
        }, [throttled]);
        return throttled;
    }
    function useDebounced(callback, wait, options) {
        const debounced = F$1(() => {
            return callback ? debounce(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.maxWait, options?.trailing]);
        _(() => {
            return () => debounced?.cancel();
        }, [debounced]);
        return debounced;
    }
    /**
     * Given an async function, returns a function that's suitable for non-async APIs,
     * along with other information about the current run's status.
     *
     * See also `useAsyncHandler` for a version that's specialized for DOM event handlers.
     *
     * When called multiple times in quick succession, (i.e. before the handler has finished),
     * this works like Lodash's `throttle` function with the `wait` option always
     * set to however long the handler takes to complete. A second call to the sync function will be
     * throttled until the first call has finished. The return value of the function is the result
     * of the previous invocation, or `undefined` on the first call.
     *
     * The handler is only ever delayed if one is currently running, so, e.g. for iOS touch events the
     * first call happens in the same event handler (which means things like calls to `element.focus()`
     * will work as intended, since that fails when the event is "split up")
     *
     * Finally, because the sync handler may be invoked on a delay, any property references on the arguments
     * provided might be stale by the time it's actually invoked (e.g. accessing `event.currentTarget.checked`
     * is not stable across time because it's a "live" value -- you almost always want the value that it
     * had at the original time the handler was called). The `capture` option allows you to save that kind of
     * dynamic data at the time it runs; the `AP` and `SP` type parameters likewise control
     * the parameters the async handler and sync handler expect respectively.
     *
     */
    function useAsync(asyncHandler, options) {
        /* eslint-disable prefer-const */
        let { throttle, debounce, capture } = (options ?? {});
        capture ??= identity$1;
        // We keep, like, a lot of render-state, but it only ever triggers a re-render
        // when we start/stop an async action.
        // Keep track of this for the caller's sake -- we don't really care.
        const [currentType, setCurrentType] = useState(null);
        const [runCount, setRunCount] = useState(0);
        const [settleCount, setSettleCount] = useState(0);
        const [resolveCount, setResolveCount] = useState(0);
        const [rejectCount, setRejectCount] = useState(0);
        // Things related to current execution
        // Because we can both return and throw undefined, 
        // we need separate state to track their existance too.
        const [pending, setPending, getPending] = useState(false);
        const [result, setResult, getResult] = useState(undefined);
        const [error, setError, _getError] = useState(undefined);
        const [hasError, setHasError, _getHasError] = useState(false);
        const [hasResult, setHasResult, _getHasResult] = useState(false);
        // We implement our own throttling behavior in regards to waiting until the async handler finishes.
        // These two passive state variables keep track of that, automatically queueing/dequeuing the next handler.
        const [getQueued, setQueued] = usePassiveState(null, returnNull);
        // The actual sync handler.
        // Capture/transform the given parameters if applicable,
        // then run further logic that's debounced/throttled
        const captureArgsAndExecuteDebouncedHandler = useStableCallback(function onNewExecuteRequest(...newArgs2) {
            // Capture the arguments we were given.
            // We might use them immediately, or we might store them to `queued`,
            // but in either case we do need the captured value.
            const captured = capture(...newArgs2);
            // This is all logic that deals with the captured value instead of the raw arguments.
            // It's called in two separate circumstances,
            // and has the debounce/throttle logic already applied
            return executeHandlerWithDebounce(getPending(), ...captured);
        });
        // This is the logic that runs when the handler is *just* about to start.
        // This function itself is further transformed to be throttled/debounced if requested,
        // so this might not be called immediately after 
        const executeHandlerWithoutDebounce = useStableCallback(function onNewExecuteRequest2(enqueue, ...newArgs) {
            const onThen = (value) => { setResult(value); setHasResult(true); setHasError(false); setResolveCount(r => ++r); };
            const onCatch = (ex) => { setError(ex); setHasError(true); setHasResult(false); setRejectCount(r => ++r); };
            const onFinally = () => {
                const queued = getQueued();
                setSettleCount(s => ++s);
                if (queued) {
                    setQueued(null);
                    executeHandlerWithDebounce(false, ...queued);
                }
                else {
                    setPending(false);
                }
            };
            if (!enqueue) {
                // Nothing is pending at the moment, so we can run our function immediately.
                setRunCount(r => ++r);
                setPending(true);
                const result = asyncHandler?.(...newArgs);
                const isPromise = (result != null && typeof result == "object" && "then" in result);
                if (result == null || !isPromise) {
                    // It's synchronous and returned successfully.
                    // Bail out early.
                    onThen(result);
                    onFinally();
                    setCurrentType("sync");
                }
                else {
                    result.then(onThen).catch(onCatch).finally(onFinally);
                    setCurrentType("async");
                }
            }
            else {
                // When we're still running a previous handler,
                // just set ourselves as the next one to run and quit early.
                // Nothing more to do.
                setQueued(newArgs);
            }
            return getResult();
        });
        const executeHandlerWithT = useThrottled(!throttle ? null : executeHandlerWithoutDebounce, throttle ?? 0);
        const executeHandlerWithD = useDebounced(!debounce ? null : (executeHandlerWithT ?? executeHandlerWithoutDebounce), debounce ?? 0);
        const executeHandlerWithDebounce = (executeHandlerWithD ?? executeHandlerWithT ?? executeHandlerWithoutDebounce);
        const flushDebouncedPromise = useStableCallback(() => {
            if (executeHandlerWithDebounce && "flush" in executeHandlerWithDebounce)
                executeHandlerWithDebounce.flush();
        });
        return {
            syncHandler: captureArgsAndExecuteDebouncedHandler,
            currentType,
            pending,
            result,
            error,
            hasError,
            hasResult,
            resolveCount,
            rejectCount,
            settleCount,
            callCount: runCount,
            flushDebouncedPromise
        };
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * Note that because the handler you provide may be called with a delay, and
     * because the value of, e.g., an `<input>` element will likely be stale by the
     * time the delay is over, a `capture` function is necessary in order to
     * capture the relevant information from the DOM. Any other simple event data,
     * like `mouseX` or `shiftKey` can stay on the event itself and don't
     * need to be captured &ndash; it's never stale.
     *
     * ```tsx
     * const asyncOnInput = async (value: number, e: Event) => {
     *     [...] // Ex. send to a server and setState when done
     * };
     * const {
     *     // A sync version of asyncOnInput
     *     syncHandler,
     *     // True while the handler is running
     *     pending,
     *     // The error thrown, if any
     *     error,
     *     // Show this value while the operation's pending
     *     currentCapture,
     *     // And others, see `UseAsyncHandlerReturnType`
     *     ...rest
     * } = useAsyncHandler<HTMLInputElement>()(asyncOnInput, {
     *     // Pass in the capture function that saves event data
     *     // from being stale.
     *     capture: e => {
     *         // `capture` can have side-effects because
     *         // it's called exactly once per invocation
     *         e.preventDefault();
     *
     *         // Save this value so that it's never stale
     *         return e.currentTarget.valueAsNumber;
     *     }
     * });
     *
     * const onInput = pending? null : syncHandler;
     * ```
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     *
     * You may optionally *also* specify debounce and throttle parameters that wait until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * @see useAsync A more general version of this hook that can work with any type of handler, not just DOM event handlers.
     */
    function useAsyncHandler(asyncHandler, { capture: originalCapture, ...restAsyncOptions }) {
        // We need to differentiate between "nothing captured yet" and "`undefined` was captured"
        const [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        const [hasCapture, setHasCapture] = useState(false);
        // Wrap around the normal `useAsync` `capture` function to also
        // keep track of the last value the user actually input.
        // 
        // Without this there's no way to re-render the control with
        // it being both controlled and also having the "correct" value,
        // and at any rate also protects against sudden exceptions reverting
        // your change out from under you.
        const capture = useStableCallback((e) => {
            const captured = originalCapture(e);
            setCurrentCapture(captured);
            setHasCapture(true);
            return [captured, e];
        });
        return {
            getCurrentCapture,
            currentCapture,
            hasCapture,
            ...useAsync(asyncHandler, { capture, ...restAsyncOptions })
        };
    }

    /**
     * Wrap the native `useEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     * @param impl You can choose whether to use `useEffect` or `useLayoutEffect` by
     * passing one of them as this argument. By default, it's `useEffect`.
     */
    function useEffect(effect, inputs, impl = _) {
        const prevInputs = s(undefined);
        const effect2 = () => {
            const changes = [];
            if (inputs && prevInputs.current) {
                for (let i = 0; i < Math.max(prevInputs.current.length, inputs.length); ++i) {
                    if (prevInputs.current[i] != inputs[i])
                        changes[i] = { from: prevInputs.current[i], to: inputs[i] };
                }
            }
            const ret = effect(prevInputs.current, changes);
            prevInputs.current = inputs;
            return ret;
        };
        impl(effect2, inputs);
    }

    /**
     * Wrap the native `useLayoutEffect` to add arguments
     * that allow accessing the previous value as the first argument,
     * as well as the changes that caused the hook to be called as the second argument.
     *
     * @param effect
     * @param inputs
     */
    function useLayoutEffect(effect, inputs) {
        return useEffect(effect, inputs, h);
    }

    //export type UseManagedChildParameters<I extends {}> = { info: I };
    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */
    function useManagedChildren(parentParameters) {
        const { managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
        const getHighestIndex = T$1(() => {
            return managedChildrenArray.current.highestIndex;
        }, []);
        // All the information we have about our children is stored in this **stable** array.
        // Any mutations to this array **DO NOT** trigger any sort of a re-render.
        const managedChildrenArray = s({ arr: [], rec: {}, highestIndex: 0, lowestIndex: 0 });
        // For indirect access to each child
        // Compare getManagedChildInfo
        // TODO: The primary use for this is flaggable closest fits
        // which need to search all children for that closest fit.
        // It would be nice if there was something better for that.
        const forEachChild = T$1((f) => {
            for (const child of managedChildrenArray.current.arr) {
                f(child);
            }
            for (const field in managedChildrenArray.current.rec) {
                const child = managedChildrenArray.current.rec[field];
                if (child)
                    f(child);
            }
        }, []);
        // Retrieves the information associated with the child with the given index.
        // `undefined` if not child there, or it's unmounted.
        const getManagedChildInfo = T$1((index) => {
            if (typeof index == "number")
                return managedChildrenArray.current.arr[index];
            else
                return managedChildrenArray.current.rec[index];
        }, []);
        // tl;dr this is a way to have run useLayoutEffect once after all N children
        // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
        // ourselves because of having a `childCount` state or anything similar.
        //
        // When the child count ref updates, we want the parent to also run an effect
        // to maybe do something with all these children that just mounted.
        // The easiest way would be useEffect(..., [childCount]) but
        // that would require us having a childCount state, then calling
        // setChildCount and re-rendering every time children mount
        // (only one re-render at a time unless children are staggered, but still)
        // 
        // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
        // to emulate running ULE on the parent. Only the first child will actually queue
        // the microtask (by checking hasRemoteULE first) so that the "effect" only
        // runs once. When it's done, hasRemoteULE is reset so it can run again if
        // more children mount/unmount.
        const hasRemoteULEChildMounted = s(null);
        const remoteULEChildChangedCausers = s(new Set());
        const remoteULEChildChanged = T$1((index) => {
            if (remoteULEChildChangedCausers.current.size == 0) {
                queueMicrotask(() => {
                    onAfterChildLayoutEffect?.(remoteULEChildChangedCausers.current);
                    remoteULEChildChangedCausers.current.clear();
                });
            }
            remoteULEChildChangedCausers.current.add(index);
            return () => { };
        }, [ /* Must remain stable */]);
        const remoteULEChildMounted = T$1((index, mounted) => {
            if (!hasRemoteULEChildMounted.current) {
                hasRemoteULEChildMounted.current = {
                    mounts: new Set(),
                    unmounts: new Set(),
                };
                queueMicrotask(() => {
                    onChildrenMountChange?.(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
                    hasRemoteULEChildMounted.current = null;
                });
            }
            if (mounted) {
                managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
            }
            else {
                if (typeof index == "number") {
                    delete managedChildrenArray.current.arr[index];
                    let shave = 0;
                    while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined)
                        ++shave;
                    managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - 1 - shave, shave);
                }
                else
                    delete managedChildrenArray.current.rec[index];
            }
            hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
        }, [ /* Must remain stable */]);
        const useManagedChild = T$1(({ managedChild: info, }) => {
            // Any time our child props change, make that information available
            // the parent if they need it.
            // The parent can listen for all updates and only act on the ones it cares about,
            // and multiple children updating in the same tick will all be sent at once.
            useLayoutEffect(() => {
                // Insert this information in-place
                if (typeof info.index == "number")
                    managedChildrenArray.current.arr[info.index] = { index: info.index, flags: info.flags ?? {}, subInfo: info.subInfo };
                else
                    managedChildrenArray.current.rec[info.index] = { index: info.index, flags: info.flags ?? {}, subInfo: info.subInfo };
                return remoteULEChildChanged(info.index);
            }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
            // When we mount, notify the parent via queueMicrotask
            // (every child does this, so everything's coordinated to only queue a single microtask per tick)
            // Do the same on unmount.
            // Note: It's important that this comes AFTER remoteULEChildChanged
            // so that remoteULEChildMounted has access to all the info on mount.
            useLayoutEffect(() => {
                remoteULEChildMounted?.(info.index, true);
                return () => remoteULEChildMounted?.(info.index, false);
            }, [info.index]);
        }, [ /* Must remain stable */]);
        const managedChildren = s({
            ...{ _: managedChildrenArray.current },
            forEach: forEachChild,
            getAt: getManagedChildInfo,
            getHighestIndex: getHighestIndex,
            arraySlice: () => {
                return managedChildrenArray.current.arr.slice();
            }
        });
        return {
            useManagedChild,
            managedChildren: { children: managedChildren.current }
        };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */
    function useChildrenFlag({ children, initialIndex, closestFit, onIndexChange, key }) {
        useEnsureStability("useChildrenFlag", onIndexChange, key);
        const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, T$1(() => (initialIndex ?? (null)), []));
        const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, T$1(() => (initialIndex ?? (null)), []));
        //    const getFitNullToZero = useStableGetter(fitNullToZero);
        // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
        const getClosestFit = T$1((requestedIndex) => {
            let closestDistance = Infinity;
            let closestIndex = null;
            children.forEach(child => {
                if (child.flags?.[key]?.isValid()) {
                    const newDistance = Math.abs(child.index - requestedIndex);
                    if (newDistance < closestDistance || (newDistance == closestDistance && child.index < requestedIndex)) {
                        closestDistance = newDistance;
                        closestIndex = child.index;
                    }
                }
            });
            return closestIndex;
        }, [ /* Must remain stable! */]);
        // Any time a child mounts/unmounts, we need to double-check to see if that affects 
        // the "currently selected" (or whatever) index.  The two cases we're looking for:
        // 1. The currently selected child unmounted
        // 2. A child mounted, and it mounts with the index we're looking for
        const reevaluateClosestFit = useStableCallback(() => {
            const requestedIndex = getRequestedIndex();
            const currentIndex = getCurrentIndex();
            const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
            if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !currentChild.flags?.[key]?.isValid())) {
                currentChild?.flags?.[key].set(false);
                const closestFitIndex = getClosestFit(requestedIndex);
                setCurrentIndex(closestFitIndex);
                if (closestFitIndex != null) {
                    const closestFitChild = children.getAt(closestFitIndex);
                    console.assert(closestFitChild != null, "Internal logic???");
                    closestFitChild.flags?.[key].set(true);
                }
            }
        });
        const changeIndex = T$1((arg) => {
            const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
            //if (requestedIndex == null && getFitNullToZero())
            //    requestedIndex = 0;
            setRequestedIndex(requestedIndex);
            const currentIndex = getCurrentIndex();
            if (currentIndex == requestedIndex)
                return requestedIndex;
            let newMatchingChild = (requestedIndex == null ? null : children.getAt(requestedIndex));
            const oldMatchingChild = (currentIndex == null ? null : children.getAt(currentIndex));
            if (requestedIndex == null) {
                // Easy case
                setCurrentIndex(null);
                oldMatchingChild?.flags?.[key].set(false);
                return null;
            }
            else {
                if (newMatchingChild && newMatchingChild.flags?.[key].isValid()) {
                    setCurrentIndex(requestedIndex);
                    oldMatchingChild?.flags?.[key].set(false);
                    newMatchingChild.flags?.[key].set(true);
                    return requestedIndex;
                }
                else {
                    const closestFitIndex = getClosestFit(requestedIndex);
                    setCurrentIndex(closestFitIndex);
                    if (closestFitIndex != null) {
                        newMatchingChild = children.getAt(closestFitIndex);
                        console.assert(newMatchingChild != null, "Internal logic???");
                        oldMatchingChild?.flags?.[key].set(false);
                        newMatchingChild.flags?.[key].set(true);
                        return closestFitIndex;
                    }
                    else {
                        oldMatchingChild?.flags?.[key].set(false);
                        return null;
                    }
                }
            }
        }, []);
        useLayoutEffect(() => {
            if (initialIndex != null)
                children.getAt(initialIndex)?.flags?.[key]?.set(true);
        }, []);
        return { changeIndex, reevaluateClosestFit, getCurrentIndex };
    }
    /*export type Spread<A extends {}, B extends {}> = Omit<A, keyof B> & B;
    export function spread<A extends {}, B extends {}>(a: A, b: B): Spread<A, B> {
        return {
            ...a,
            ...b
        }
    }*/
    /*
    function test() {
        type C = { foo: "bar" };
        type K = "flag2";

        const { children, useManagedChild } = useManagedChildren<number, C, K>({ managedChildren: { onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => onChildrenMountChange(mounted, unmounted)) } });
        useManagedChild({ managedChild: { index: 0, info: { foo: "bar" }, flags: {  } } });
        const { changeIndex, getCurrentIndex, onChildrenMountChange } = useChildrenFlag<C, K>({ children, initialIndex: 0, key: "flag2" })
    }*/

    function getDocument(element) { return (element?.ownerDocument ?? document ?? window.document ?? globalThis.document); }

    function useDraggable({ effectAllowed, data, dragImage, dragImageXOffset, dragImageYOffset }) {
        const [dragging, setDragging, getDragging] = useState(false);
        const [lastDropEffect, setLastDropEffect, getLastDropEffect] = useState(null);
        const useDraggableProps = T$1((p) => {
            const ref = s(null);
            const onDragStart = (e) => {
                //e.preventDefault();
                setDragging(true);
                if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = (effectAllowed ?? "all");
                    if (dragImage)
                        e.dataTransfer.setDragImage(dragImage, dragImageXOffset ?? 0, dragImageYOffset ?? 0);
                    const entries = Object.entries(data);
                    for (const [mimeType, data] of entries) {
                        e.dataTransfer.setData(mimeType, data);
                    }
                }
            };
            const onDragEnd = (e) => {
                e.preventDefault();
                setDragging(false);
                if (e.dataTransfer) {
                    if (e.dataTransfer.dropEffect != "none") {
                        setLastDropEffect(e.dataTransfer.dropEffect);
                    }
                    else {
                        setLastDropEffect(null);
                    }
                }
            };
            return useMergedProps({
                draggable: true,
                onDragStart,
                onDragEnd,
                ref
            }, p);
        }, [effectAllowed, dragImage, dragImageXOffset, dragImageYOffset, ...Object.entries(data).flat()]);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        const ret = {
            useDraggableProps,
            dragging,
            getDragging,
            lastDropEffect,
            getLastDropEffect
        };
        return ret;
    }

    class DroppableFileError extends Error {
        fileName;
        errorType;
        constructor(fileName, base) {
            super(base?.message ?? "An unspecified error occurred reading the file.");
            this.fileName = fileName;
            this.errorType = base?.name;
        }
    }
    function useDroppable({ effect }) {
        const [filesForConsideration, setFilesForConsideration] = useState(null);
        const [stringsForConsideration, setStringsForConsideration] = useState(null);
        const [droppedFiles, setDroppedFiles] = useState(null);
        const [droppedStrings, setDroppedStrings] = useState(null);
        const [dropError, setDropError] = useState(undefined);
        // All the promises generated from the drop events.
        // Used to process multiple drop events in succession
        const dropPromisesRef = s([]);
        const [currentPromiseIndex, setCurrentPromiseIndex, getCurrentPromiseIndex] = useState(-1);
        const [promiseCount, setPromiseCount, getPromiseCount] = useState(0);
        // Any time we add a new promise, if there's no current promise running, we need to start one.
        // If there is one, then we don't need to do anything, since it runs the same check.
        _(() => {
            const currentPromiseIndex = getCurrentPromiseIndex();
            const promiseCount = getPromiseCount();
            if (promiseCount > 0) {
                if ((currentPromiseIndex + 1) < promiseCount) {
                    setCurrentPromiseIndex(i => ++i);
                }
            }
        }, [promiseCount]);
        // Anytime our current promise changes,
        // wait for it to finish, then set our state to its result.
        // Finally, check to see if there are anymore promises.
        // If there are, then increase currentPromiseCount,
        // which will trigger this again.
        //
        // This shouldn't happen *often*, but maybe in the case of
        // individually dropping a bunch of large files or something.
        _(() => {
            if (currentPromiseIndex >= 0) {
                const currentPromise = dropPromisesRef.current[currentPromiseIndex];
                currentPromise.then((info) => {
                    if (info !== null) {
                        const { files, strings } = info;
                        setDroppedFiles(files);
                        setDroppedStrings(strings);
                    }
                    // Now that we're done, are there more promises in the queue?
                    const currentPromiseIndex = getCurrentPromiseIndex();
                    const promiseCount = getPromiseCount();
                    if ((currentPromiseIndex + 1) < promiseCount) {
                        // Since this promise has started, more have been added.
                        // Run this effect again.
                        setCurrentPromiseIndex(i => ++i);
                    }
                });
            }
        }, [currentPromiseIndex]);
        const useDroppableProps = (p) => {
            //const ref = useRef<E>(null);
            // Handle collecting the current file metadata or MIME types.
            const onDragEnter = (e) => {
                e.preventDefault();
                if (e.dataTransfer) {
                    // Is there a default? I can't find one anywhere.
                    e.dataTransfer.dropEffect = (effect ?? "move");
                    const newMimeTypes = new Set();
                    const newFiles = new Array();
                    for (const item of e.dataTransfer?.items ?? []) {
                        const { kind, type } = item;
                        if (kind === "string") {
                            newMimeTypes.add(type);
                        }
                        else if (kind === "file") {
                            newFiles.push({ type: item.type });
                        }
                    }
                    setFilesForConsideration(newFiles);
                    setStringsForConsideration(newMimeTypes);
                }
            };
            // Handle resetting the current file metadata or MIME types
            const onDragLeave = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
            };
            // Boilerplate, I guess
            const onDragOver = (e) => {
                e.preventDefault();
            };
            // Handle getting the drop data asynchronously
            const onDrop = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
                const allPromises = new Array();
                const dropData = {};
                const dropFile = [];
                for (const item of e.dataTransfer?.items ?? []) {
                    const { kind, type } = item;
                    if (kind === "string") {
                        allPromises.push((new Promise((resolve, _reject) => item.getAsString(resolve))).then(str => dropData[type] = str));
                    }
                    else if (kind === "file") {
                        const file = item.getAsFile();
                        if (file) {
                            allPromises.push(new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (_) => {
                                    resolve();
                                    const data = reader.result;
                                    dropFile.push({ data, name: file.name, type: file.type, size: data.byteLength, lastModified: file.lastModified });
                                };
                                reader.onerror = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.onabort = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.readAsArrayBuffer(file);
                            }));
                            dropFile.push();
                        }
                    }
                }
                dropPromisesRef.current.push(Promise.all(allPromises).then(() => {
                    setPromiseCount(i => ++i);
                    setDropError(null);
                    return {
                        strings: dropData,
                        files: dropFile
                    };
                }).catch(ex => {
                    /* eslint-disable no-debugger */
                    debugger;
                    setPromiseCount(i => ++i);
                    setDropError(ex);
                    return null;
                }));
            };
            return useMergedProps({ onDragEnter, onDragLeave, onDragOver, onDrop }, p);
        };
        return {
            useDroppableProps,
            filesForConsideration,
            stringsForConsideration,
            droppedFiles,
            droppedStrings,
            dropError
        };
    }

    function useElementSize({ getObserveBox, onSizeChange }) {
        useEnsureStability("useElementSize", getObserveBox, onSizeChange);
        const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
        const currentObserveBox = s(undefined);
        const needANewObserver = T$1((element, observeBox) => {
            if (element) {
                const document = getDocument(element);
                const window = document.defaultView;
                const handleUpdate = () => {
                    if (element.isConnected) {
                        const { clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop } = element;
                        setSize({ clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop });
                    }
                };
                if (window && ("ResizeObserver" in window)) {
                    const observer = new ResizeObserver((_entries) => { handleUpdate(); });
                    observer.observe(element, { box: observeBox });
                    return () => observer.disconnect();
                }
                else {
                    document.addEventListener("resize", handleUpdate, { passive: true });
                    return () => document.removeEventListener("resize", handleUpdate);
                }
            }
        }, []);
        const { getElement, useRefElementProps } = useRefElement({ onElementChange: T$1((e) => needANewObserver(e, getObserveBox?.()), []) });
        _(() => {
            if (getObserveBox) {
                if (currentObserveBox.current !== getObserveBox())
                    needANewObserver(getElement(), getObserveBox());
            }
        });
        return {
            getElement,
            getSize,
            useElementSizeProps: useRefElementProps
        };
    }

    /*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot;

      // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      } // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.


      var nodeRootHost = getRootNode(node).host;
      var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);

      if (!displayCheck || displayCheck === 'full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (nodeIsAttached) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck` mode


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
    	(function (global, factory) {
    	  factory() ;
    	}(commonjsGlobal, (function () {
    	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	  /**
    	   * This work is licensed under the W3C Software and Document License
    	   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
    	   */

    	  (function () {
    	    // Return early if we're not running inside of the browser.
    	    if (typeof window === 'undefined') {
    	      return;
    	    }

    	    // Convenience function for converting NodeLists.
    	    /** @type {typeof Array.prototype.slice} */
    	    var slice = Array.prototype.slice;

    	    /**
    	     * IE has a non-standard name for "matches".
    	     * @type {typeof Element.prototype.matches}
    	     */
    	    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    	    /** @type {string} */
    	    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    	    /**
    	     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
    	     * attribute.
    	     *
    	     * Its main functions are:
    	     *
    	     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
    	     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
    	     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
    	     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
    	     *   instance exists for each focusable node which has at least one inert root as an ancestor.
    	     *
    	     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
    	     *   attribute is removed from the root node). This is handled in the destructor, which calls the
    	     *   `deregister` method on `InertManager` for each managed inert node.
    	     */

    	    var InertRoot = function () {
    	      /**
    	       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
    	       * @param {!InertManager} inertManager The global singleton InertManager object.
    	       */
    	      function InertRoot(rootElement, inertManager) {
    	        _classCallCheck(this, InertRoot);

    	        /** @type {!InertManager} */
    	        this._inertManager = inertManager;

    	        /** @type {!HTMLElement} */
    	        this._rootElement = rootElement;

    	        /**
    	         * @type {!Set<!InertNode>}
    	         * All managed focusable nodes in this InertRoot's subtree.
    	         */
    	        this._managedNodes = new Set();

    	        // Make the subtree hidden from assistive technology
    	        if (this._rootElement.hasAttribute('aria-hidden')) {
    	          /** @type {?string} */
    	          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
    	        } else {
    	          this._savedAriaHidden = null;
    	        }
    	        this._rootElement.setAttribute('aria-hidden', 'true');

    	        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
    	        this._makeSubtreeUnfocusable(this._rootElement);

    	        // Watch for:
    	        // - any additions in the subtree: make them unfocusable too
    	        // - any removals from the subtree: remove them from this inert root's managed nodes
    	        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
    	        //   element, make that node a managed node.
    	        this._observer = new MutationObserver(this._onMutation.bind(this));
    	        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
    	       * stored in this object and updates the state of all of the managed nodes.
    	       */


    	      _createClass(InertRoot, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._observer.disconnect();

    	          if (this._rootElement) {
    	            if (this._savedAriaHidden !== null) {
    	              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
    	            } else {
    	              this._rootElement.removeAttribute('aria-hidden');
    	            }
    	          }

    	          this._managedNodes.forEach(function (inertNode) {
    	            this._unmanageNode(inertNode.node);
    	          }, this);

    	          // Note we cast the nulls to the ANY type here because:
    	          // 1) We want the class properties to be declared as non-null, or else we
    	          //    need even more casts throughout this code. All bets are off if an
    	          //    instance has been destroyed and a method is called.
    	          // 2) We don't want to cast "this", because we want type-aware optimizations
    	          //    to know which properties we're setting.
    	          this._observer = /** @type {?} */null;
    	          this._rootElement = /** @type {?} */null;
    	          this._managedNodes = /** @type {?} */null;
    	          this._inertManager = /** @type {?} */null;
    	        }

    	        /**
    	         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
    	         */

    	      }, {
    	        key: '_makeSubtreeUnfocusable',


    	        /**
    	         * @param {!Node} startNode
    	         */
    	        value: function _makeSubtreeUnfocusable(startNode) {
    	          var _this2 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this2._visitNode(node);
    	          });

    	          var activeElement = document.activeElement;

    	          if (!document.body.contains(startNode)) {
    	            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
    	            var node = startNode;
    	            /** @type {!ShadowRoot|undefined} */
    	            var root = undefined;
    	            while (node) {
    	              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    	                root = /** @type {!ShadowRoot} */node;
    	                break;
    	              }
    	              node = node.parentNode;
    	            }
    	            if (root) {
    	              activeElement = root.activeElement;
    	            }
    	          }
    	          if (startNode.contains(activeElement)) {
    	            activeElement.blur();
    	            // In IE11, if an element is already focused, and then set to tabindex=-1
    	            // calling blur() will not actually move the focus.
    	            // To work around this we call focus() on the body instead.
    	            if (activeElement === document.activeElement) {
    	              document.body.focus();
    	            }
    	          }
    	        }

    	        /**
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_visitNode',
    	        value: function _visitNode(node) {
    	          if (node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */node;

    	          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
    	          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
    	          if (element !== this._rootElement && element.hasAttribute('inert')) {
    	            this._adoptInertRoot(element);
    	          }

    	          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
    	            this._manageNode(element);
    	          }
    	        }

    	        /**
    	         * Register the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_manageNode',
    	        value: function _manageNode(node) {
    	          var inertNode = this._inertManager.register(node, this);
    	          this._managedNodes.add(inertNode);
    	        }

    	        /**
    	         * Unregister the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_unmanageNode',
    	        value: function _unmanageNode(node) {
    	          var inertNode = this._inertManager.deregister(node, this);
    	          if (inertNode) {
    	            this._managedNodes['delete'](inertNode);
    	          }
    	        }

    	        /**
    	         * Unregister the entire subtree starting at `startNode`.
    	         * @param {!Node} startNode
    	         */

    	      }, {
    	        key: '_unmanageSubtree',
    	        value: function _unmanageSubtree(startNode) {
    	          var _this3 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this3._unmanageNode(node);
    	          });
    	        }

    	        /**
    	         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
    	         * @param {!HTMLElement} node
    	         */

    	      }, {
    	        key: '_adoptInertRoot',
    	        value: function _adoptInertRoot(node) {
    	          var inertSubroot = this._inertManager.getInertRoot(node);

    	          // During initialisation this inert root may not have been registered yet,
    	          // so register it now if need be.
    	          if (!inertSubroot) {
    	            this._inertManager.setInert(node, true);
    	            inertSubroot = this._inertManager.getInertRoot(node);
    	          }

    	          inertSubroot.managedNodes.forEach(function (savedInertNode) {
    	            this._manageNode(savedInertNode.node);
    	          }, this);
    	        }

    	        /**
    	         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_onMutation',
    	        value: function _onMutation(records, self) {
    	          records.forEach(function (record) {
    	            var target = /** @type {!HTMLElement} */record.target;
    	            if (record.type === 'childList') {
    	              // Manage added nodes
    	              slice.call(record.addedNodes).forEach(function (node) {
    	                this._makeSubtreeUnfocusable(node);
    	              }, this);

    	              // Un-manage removed nodes
    	              slice.call(record.removedNodes).forEach(function (node) {
    	                this._unmanageSubtree(node);
    	              }, this);
    	            } else if (record.type === 'attributes') {
    	              if (record.attributeName === 'tabindex') {
    	                // Re-initialise inert node if tabindex changes
    	                this._manageNode(target);
    	              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
    	                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
    	                // already managed nodes from this inert subroot.
    	                this._adoptInertRoot(target);
    	                var inertSubroot = this._inertManager.getInertRoot(target);
    	                this._managedNodes.forEach(function (managedNode) {
    	                  if (target.contains(managedNode.node)) {
    	                    inertSubroot._manageNode(managedNode.node);
    	                  }
    	                });
    	              }
    	            }
    	          }, this);
    	        }
    	      }, {
    	        key: 'managedNodes',
    	        get: function get() {
    	          return new Set(this._managedNodes);
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'hasSavedAriaHidden',
    	        get: function get() {
    	          return this._savedAriaHidden !== null;
    	        }

    	        /** @param {?string} ariaHidden */

    	      }, {
    	        key: 'savedAriaHidden',
    	        set: function set(ariaHidden) {
    	          this._savedAriaHidden = ariaHidden;
    	        }

    	        /** @return {?string} */
    	        ,
    	        get: function get() {
    	          return this._savedAriaHidden;
    	        }
    	      }]);

    	      return InertRoot;
    	    }();

    	    /**
    	     * `InertNode` initialises and manages a single inert node.
    	     * A node is inert if it is a descendant of one or more inert root elements.
    	     *
    	     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
    	     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
    	     * is intrinsically focusable or not.
    	     *
    	     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
    	     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
    	     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
    	     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
    	     * or removes the `tabindex` attribute if the element is intrinsically focusable.
    	     */


    	    var InertNode = function () {
    	      /**
    	       * @param {!Node} node A focusable element to be made inert.
    	       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
    	       */
    	      function InertNode(node, inertRoot) {
    	        _classCallCheck(this, InertNode);

    	        /** @type {!Node} */
    	        this._node = node;

    	        /** @type {boolean} */
    	        this._overrodeFocusMethod = false;

    	        /**
    	         * @type {!Set<!InertRoot>} The set of descendant inert roots.
    	         *    If and only if this set becomes empty, this node is no longer inert.
    	         */
    	        this._inertRoots = new Set([inertRoot]);

    	        /** @type {?number} */
    	        this._savedTabIndex = null;

    	        /** @type {boolean} */
    	        this._destroyed = false;

    	        // Save any prior tabindex info and make this node untabbable
    	        this.ensureUntabbable();
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.
    	       * This makes the managed node focusable again and deletes all of the previously stored state.
    	       */


    	      _createClass(InertNode, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._throwIfDestroyed();

    	          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
    	            var element = /** @type {!HTMLElement} */this._node;
    	            if (this._savedTabIndex !== null) {
    	              element.setAttribute('tabindex', this._savedTabIndex);
    	            } else {
    	              element.removeAttribute('tabindex');
    	            }

    	            // Use `delete` to restore native focus method.
    	            if (this._overrodeFocusMethod) {
    	              delete element.focus;
    	            }
    	          }

    	          // See note in InertRoot.destructor for why we cast these nulls to ANY.
    	          this._node = /** @type {?} */null;
    	          this._inertRoots = /** @type {?} */null;
    	          this._destroyed = true;
    	        }

    	        /**
    	         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
    	         * If the object has been destroyed, any attempt to access it will cause an exception.
    	         */

    	      }, {
    	        key: '_throwIfDestroyed',


    	        /**
    	         * Throw if user tries to access destroyed InertNode.
    	         */
    	        value: function _throwIfDestroyed() {
    	          if (this.destroyed) {
    	            throw new Error('Trying to access destroyed InertNode');
    	          }
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'ensureUntabbable',


    	        /** Save the existing tabindex value and make the node untabbable and unfocusable */
    	        value: function ensureUntabbable() {
    	          if (this.node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */this.node;
    	          if (matches.call(element, _focusableElementsString)) {
    	            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
    	              return;
    	            }

    	            if (element.hasAttribute('tabindex')) {
    	              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            }
    	            element.setAttribute('tabindex', '-1');
    	            if (element.nodeType === Node.ELEMENT_NODE) {
    	              element.focus = function () {};
    	              this._overrodeFocusMethod = true;
    	            }
    	          } else if (element.hasAttribute('tabindex')) {
    	            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            element.removeAttribute('tabindex');
    	          }
    	        }

    	        /**
    	         * Add another inert root to this inert node's set of managing inert roots.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'addInertRoot',
    	        value: function addInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots.add(inertRoot);
    	        }

    	        /**
    	         * Remove the given inert root from this inert node's set of managing inert roots.
    	         * If the set of managing inert roots becomes empty, this node is no longer inert,
    	         * so the object should be destroyed.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'removeInertRoot',
    	        value: function removeInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots['delete'](inertRoot);
    	          if (this._inertRoots.size === 0) {
    	            this.destructor();
    	          }
    	        }
    	      }, {
    	        key: 'destroyed',
    	        get: function get() {
    	          return (/** @type {!InertNode} */this._destroyed
    	          );
    	        }
    	      }, {
    	        key: 'hasSavedTabIndex',
    	        get: function get() {
    	          return this._savedTabIndex !== null;
    	        }

    	        /** @return {!Node} */

    	      }, {
    	        key: 'node',
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._node;
    	        }

    	        /** @param {?number} tabIndex */

    	      }, {
    	        key: 'savedTabIndex',
    	        set: function set(tabIndex) {
    	          this._throwIfDestroyed();
    	          this._savedTabIndex = tabIndex;
    	        }

    	        /** @return {?number} */
    	        ,
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._savedTabIndex;
    	        }
    	      }]);

    	      return InertNode;
    	    }();

    	    /**
    	     * InertManager is a per-document singleton object which manages all inert roots and nodes.
    	     *
    	     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
    	     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
    	     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
    	     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
    	     * is created for each such node, via the `_managedNodes` map.
    	     */


    	    var InertManager = function () {
    	      /**
    	       * @param {!Document} document
    	       */
    	      function InertManager(document) {
    	        _classCallCheck(this, InertManager);

    	        if (!document) {
    	          throw new Error('Missing required argument; InertManager needs to wrap a document.');
    	        }

    	        /** @type {!Document} */
    	        this._document = document;

    	        /**
    	         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertNode>}
    	         */
    	        this._managedNodes = new Map();

    	        /**
    	         * All inert roots known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertRoot>}
    	         */
    	        this._inertRoots = new Map();

    	        /**
    	         * Observer for mutations on `document.body`.
    	         * @type {!MutationObserver}
    	         */
    	        this._observer = new MutationObserver(this._watchForInert.bind(this));

    	        // Add inert style.
    	        addInertStyle(document.head || document.body || document.documentElement);

    	        // Wait for document to be loaded.
    	        if (document.readyState === 'loading') {
    	          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
    	        } else {
    	          this._onDocumentLoaded();
    	        }
    	      }

    	      /**
    	       * Set whether the given element should be an inert root or not.
    	       * @param {!HTMLElement} root
    	       * @param {boolean} inert
    	       */


    	      _createClass(InertManager, [{
    	        key: 'setInert',
    	        value: function setInert(root, inert) {
    	          if (inert) {
    	            if (this._inertRoots.has(root)) {
    	              // element is already inert
    	              return;
    	            }

    	            var inertRoot = new InertRoot(root, this);
    	            root.setAttribute('inert', '');
    	            this._inertRoots.set(root, inertRoot);
    	            // If not contained in the document, it must be in a shadowRoot.
    	            // Ensure inert styles are added there.
    	            if (!this._document.body.contains(root)) {
    	              var parent = root.parentNode;
    	              while (parent) {
    	                if (parent.nodeType === 11) {
    	                  addInertStyle(parent);
    	                }
    	                parent = parent.parentNode;
    	              }
    	            }
    	          } else {
    	            if (!this._inertRoots.has(root)) {
    	              // element is already non-inert
    	              return;
    	            }

    	            var _inertRoot = this._inertRoots.get(root);
    	            _inertRoot.destructor();
    	            this._inertRoots['delete'](root);
    	            root.removeAttribute('inert');
    	          }
    	        }

    	        /**
    	         * Get the InertRoot object corresponding to the given inert root element, if any.
    	         * @param {!Node} element
    	         * @return {!InertRoot|undefined}
    	         */

    	      }, {
    	        key: 'getInertRoot',
    	        value: function getInertRoot(element) {
    	          return this._inertRoots.get(element);
    	        }

    	        /**
    	         * Register the given InertRoot as managing the given node.
    	         * In the case where the node has a previously existing inert root, this inert root will
    	         * be added to its set of inert roots.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {!InertNode} inertNode
    	         */

    	      }, {
    	        key: 'register',
    	        value: function register(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (inertNode !== undefined) {
    	            // node was already in an inert subtree
    	            inertNode.addInertRoot(inertRoot);
    	          } else {
    	            inertNode = new InertNode(node, inertRoot);
    	          }

    	          this._managedNodes.set(node, inertNode);

    	          return inertNode;
    	        }

    	        /**
    	         * De-register the given InertRoot as managing the given inert node.
    	         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
    	         * node from the InertManager's set of managed nodes if it is destroyed.
    	         * If the node is not currently managed, this is essentially a no-op.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
    	         */

    	      }, {
    	        key: 'deregister',
    	        value: function deregister(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (!inertNode) {
    	            return null;
    	          }

    	          inertNode.removeInertRoot(inertRoot);
    	          if (inertNode.destroyed) {
    	            this._managedNodes['delete'](node);
    	          }

    	          return inertNode;
    	        }

    	        /**
    	         * Callback used when document has finished loading.
    	         */

    	      }, {
    	        key: '_onDocumentLoaded',
    	        value: function _onDocumentLoaded() {
    	          // Find all inert roots in document and make them actually inert.
    	          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
    	          inertElements.forEach(function (inertElement) {
    	            this.setInert(inertElement, true);
    	          }, this);

    	          // Comment this out to use programmatic API only.
    	          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });
    	        }

    	        /**
    	         * Callback used when mutation observer detects attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_watchForInert',
    	        value: function _watchForInert(records, self) {
    	          var _this = this;
    	          records.forEach(function (record) {
    	            switch (record.type) {
    	              case 'childList':
    	                slice.call(record.addedNodes).forEach(function (node) {
    	                  if (node.nodeType !== Node.ELEMENT_NODE) {
    	                    return;
    	                  }
    	                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
    	                  if (matches.call(node, '[inert]')) {
    	                    inertElements.unshift(node);
    	                  }
    	                  inertElements.forEach(function (inertElement) {
    	                    this.setInert(inertElement, true);
    	                  }, _this);
    	                }, _this);
    	                break;
    	              case 'attributes':
    	                if (record.attributeName !== 'inert') {
    	                  return;
    	                }
    	                var target = /** @type {!HTMLElement} */record.target;
    	                var inert = target.hasAttribute('inert');
    	                _this.setInert(target, inert);
    	                break;
    	            }
    	          }, this);
    	        }
    	      }]);

    	      return InertManager;
    	    }();

    	    /**
    	     * Recursively walk the composed tree from |node|.
    	     * @param {!Node} node
    	     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
    	     *     before descending into child nodes.
    	     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
    	     */


    	    function composedTreeWalk(node, callback, shadowRootAncestor) {
    	      if (node.nodeType == Node.ELEMENT_NODE) {
    	        var element = /** @type {!HTMLElement} */node;
    	        if (callback) {
    	          callback(element);
    	        }

    	        // Descend into node:
    	        // If it has a ShadowRoot, ignore all child elements - these will be picked
    	        // up by the <content> or <shadow> elements. Descend straight into the
    	        // ShadowRoot.
    	        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
    	        if (shadowRoot) {
    	          composedTreeWalk(shadowRoot, callback);
    	          return;
    	        }

    	        // If it is a <content> element, descend into distributed elements - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'content') {
    	          var content = /** @type {!HTMLContentElement} */element;
    	          // Verifies if ShadowDom v0 is supported.
    	          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
    	          for (var i = 0; i < distributedNodes.length; i++) {
    	            composedTreeWalk(distributedNodes[i], callback);
    	          }
    	          return;
    	        }

    	        // If it is a <slot> element, descend into assigned nodes - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'slot') {
    	          var slot = /** @type {!HTMLSlotElement} */element;
    	          // Verify if ShadowDom v1 is supported.
    	          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];
    	          for (var _i = 0; _i < _distributedNodes.length; _i++) {
    	            composedTreeWalk(_distributedNodes[_i], callback);
    	          }
    	          return;
    	        }
    	      }

    	      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
    	      // element, nor a <shadow> element recurse normally.
    	      var child = node.firstChild;
    	      while (child != null) {
    	        composedTreeWalk(child, callback);
    	        child = child.nextSibling;
    	      }
    	    }

    	    /**
    	     * Adds a style element to the node containing the inert specific styles
    	     * @param {!Node} node
    	     */
    	    function addInertStyle(node) {
    	      if (node.querySelector('style#inert-style, link#inert-style')) {
    	        return;
    	      }
    	      var style = document.createElement('style');
    	      style.setAttribute('id', 'inert-style');
    	      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
    	      node.appendChild(style);
    	    }

    	    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
    	      /** @type {!InertManager} */
    	      var inertManager = new InertManager(document);

    	      Object.defineProperty(HTMLElement.prototype, 'inert', {
    	        enumerable: true,
    	        /** @this {!HTMLElement} */
    	        get: function get() {
    	          return this.hasAttribute('inert');
    	        },
    	        /** @this {!HTMLElement} */
    	        set: function set(inert) {
    	          inertManager.setInert(this, inert);
    	        }
    	      });
    	    }
    	  })();

    	})));
    } ());

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
        var _a, _b, _c;
        /* Symbols for private properties */
        const _blockingElements = Symbol();
        const _alreadyInertElements = Symbol();
        const _topElParents = Symbol();
        const _siblingsToRestore = Symbol();
        const _parentMO = Symbol();
        /* Symbols for private static methods */
        const _topChanged = Symbol();
        const _swapInertedSibling = Symbol();
        const _inertSiblings = Symbol();
        const _restoreInertedSiblings = Symbol();
        const _getParents = Symbol();
        const _getDistributedChildren = Symbol();
        const _isInertable = Symbol();
        const _handleMutations = Symbol();
        class BlockingElementsImpl {
            constructor() {
                /**
                 * The blocking elements.
                 */
                this[_a] = [];
                /**
                 * Used to keep track of the parents of the top element, from the element
                 * itself up to body. When top changes, the old top might have been removed
                 * from the document, so we need to memoize the inerted parents' siblings
                 * in order to restore their inerteness when top changes.
                 */
                this[_b] = [];
                /**
                 * Elements that are already inert before the first blocking element is
                 * pushed.
                 */
                this[_c] = new Set();
            }
            destructor() {
                // Restore original inertness.
                this[_restoreInertedSiblings](this[_topElParents]);
                // Note we don't want to make these properties nullable on the class,
                // since then we'd need non-null casts in many places. Calling a method on
                // a BlockingElements instance after calling destructor will result in an
                // exception.
                const nullable = this;
                nullable[_blockingElements] = null;
                nullable[_topElParents] = null;
                nullable[_alreadyInertElements] = null;
            }
            get top() {
                const elems = this[_blockingElements];
                return elems[elems.length - 1] || null;
            }
            push(element) {
                if (!element || element === this.top) {
                    return;
                }
                // Remove it from the stack, we'll bring it to the top.
                this.remove(element);
                this[_topChanged](element);
                this[_blockingElements].push(element);
            }
            remove(element) {
                const i = this[_blockingElements].indexOf(element);
                if (i === -1) {
                    return false;
                }
                this[_blockingElements].splice(i, 1);
                // Top changed only if the removed element was the top element.
                if (i === this[_blockingElements].length) {
                    this[_topChanged](this.top);
                }
                return true;
            }
            pop() {
                const top = this.top;
                top && this.remove(top);
                return top;
            }
            has(element) {
                return this[_blockingElements].indexOf(element) !== -1;
            }
            /**
             * Sets `inert` to all document elements except the new top element, its
             * parents, and its distributed content.
             */
            [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
                const toKeepInert = this[_alreadyInertElements];
                const oldParents = this[_topElParents];
                // No new top, reset old top if any.
                if (!newTop) {
                    this[_restoreInertedSiblings](oldParents);
                    toKeepInert.clear();
                    this[_topElParents] = [];
                    return;
                }
                const newParents = this[_getParents](newTop);
                // New top is not contained in the main document!
                if (newParents[newParents.length - 1].parentNode !== document.body) {
                    throw Error('Non-connected element cannot be a blocking element');
                }
                // Cast here because we know we'll call _inertSiblings on newParents
                // below.
                this[_topElParents] = newParents;
                const toSkip = this[_getDistributedChildren](newTop);
                // No previous top element.
                if (!oldParents.length) {
                    this[_inertSiblings](newParents, toSkip, toKeepInert);
                    return;
                }
                let i = oldParents.length - 1;
                let j = newParents.length - 1;
                // Find common parent. Index 0 is the element itself (so stop before it).
                while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
                    i--;
                    j--;
                }
                // If up the parents tree there are 2 elements that are siblings, swap
                // the inerted sibling.
                if (oldParents[i] !== newParents[j]) {
                    this[_swapInertedSibling](oldParents[i], newParents[j]);
                }
                // Restore old parents siblings inertness.
                i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
                // Make new parents siblings inert.
                j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
            }
            /**
             * Swaps inertness between two sibling elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_swapInertedSibling](oldInert, newInert) {
                const siblingsToRestore = oldInert[_siblingsToRestore];
                // oldInert is not contained in siblings to restore, so we have to check
                // if it's inertable and if already inert.
                if (this[_isInertable](oldInert) && !oldInert.inert) {
                    oldInert.inert = true;
                    siblingsToRestore.add(oldInert);
                }
                // If newInert was already between the siblings to restore, it means it is
                // inertable and must be restored.
                if (siblingsToRestore.has(newInert)) {
                    newInert.inert = false;
                    siblingsToRestore.delete(newInert);
                }
                newInert[_parentMO] = oldInert[_parentMO];
                newInert[_siblingsToRestore] = siblingsToRestore;
                oldInert[_parentMO] = undefined;
                oldInert[_siblingsToRestore] = undefined;
            }
            /**
             * Restores original inertness to the siblings of the elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_restoreInertedSiblings](elements) {
                for (const element of elements) {
                    const mo = element[_parentMO];
                    mo.disconnect();
                    element[_parentMO] = undefined;
                    const siblings = element[_siblingsToRestore];
                    for (const sibling of siblings) {
                        sibling.inert = false;
                    }
                    element[_siblingsToRestore] = undefined;
                }
            }
            /**
             * Inerts the siblings of the elements except the elements to skip. Stores
             * the inerted siblings into the element's symbol `_siblingsToRestore`.
             * Pass `toKeepInert` to collect the already inert elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_inertSiblings](elements, toSkip, toKeepInert) {
                for (const element of elements) {
                    // Assume element is not a Document, so it must have a parentNode.
                    const parent = element.parentNode;
                    const children = parent.children;
                    const inertedSiblings = new Set();
                    for (let j = 0; j < children.length; j++) {
                        const sibling = children[j];
                        // Skip the input element, if not inertable or to be skipped.
                        if (sibling === element || !this[_isInertable](sibling) ||
                            (toSkip && toSkip.has(sibling))) {
                            continue;
                        }
                        // Should be collected since already inerted.
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                    // Store the siblings that were inerted.
                    element[_siblingsToRestore] = inertedSiblings;
                    // Observe only immediate children mutations on the parent.
                    const mo = new MutationObserver(this[_handleMutations].bind(this));
                    element[_parentMO] = mo;
                    let parentToObserve = parent;
                    // If we're using the ShadyDOM polyfill, then our parent could be a
                    // shady root, which is an object that acts like a ShadowRoot, but isn't
                    // actually a node in the real DOM. Observe the real DOM parent instead.
                    const maybeShadyRoot = parentToObserve;
                    if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
                        parentToObserve = maybeShadyRoot.host;
                    }
                    mo.observe(parentToObserve, {
                        childList: true,
                    });
                }
            }
            /**
             * Handles newly added/removed nodes by toggling their inertness.
             * It also checks if the current top Blocking Element has been removed,
             * notifying and removing it.
             */
            [_handleMutations](mutations) {
                const parents = this[_topElParents];
                const toKeepInert = this[_alreadyInertElements];
                for (const mutation of mutations) {
                    // If the target is a shadowRoot, get its host as we skip shadowRoots when
                    // computing _topElParents.
                    const target = mutation.target.host || mutation.target;
                    const idx = target === document.body ?
                        parents.length :
                        parents.indexOf(target);
                    const inertedChild = parents[idx - 1];
                    const inertedSiblings = inertedChild[_siblingsToRestore];
                    // To restore.
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        const sibling = mutation.removedNodes[i];
                        if (sibling === inertedChild) {
                            console.info('Detected removal of the top Blocking Element.');
                            this.pop();
                            return;
                        }
                        if (inertedSiblings.has(sibling)) {
                            sibling.inert = false;
                            inertedSiblings.delete(sibling);
                        }
                    }
                    // To inert.
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        const sibling = mutation.addedNodes[i];
                        if (!this[_isInertable](sibling)) {
                            continue;
                        }
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                }
            }
            /**
             * Returns if the element is inertable.
             */
            [_isInertable](element) {
                return false === /^(style|template|script)$/.test(element.localName);
            }
            /**
             * Returns the list of newParents of an element, starting from element
             * (included) up to `document.body` (excluded).
             */
            [_getParents](element) {
                const parents = [];
                let current = element;
                // Stop to body.
                while (current && current !== document.body) {
                    // Skip shadow roots.
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        parents.push(current);
                    }
                    // ShadowDom v1
                    if (current.assignedSlot) {
                        // Collect slots from deepest slot to top.
                        while (current = current.assignedSlot) {
                            parents.push(current);
                        }
                        // Continue the search on the top slot.
                        current = parents.pop();
                        continue;
                    }
                    current = current.parentNode ||
                        current.host;
                }
                return parents;
            }
            /**
             * Returns the distributed children of the element's shadow root.
             * Returns null if the element doesn't have a shadow root.
             */
            [_getDistributedChildren](element) {
                const shadowRoot = element.shadowRoot;
                if (!shadowRoot) {
                    return null;
                }
                const result = new Set();
                let i;
                let j;
                let nodes;
                const slots = shadowRoot.querySelectorAll('slot');
                if (slots.length && slots[0].assignedNodes) {
                    for (i = 0; i < slots.length; i++) {
                        nodes = slots[i].assignedNodes({
                            flatten: true,
                        });
                        for (j = 0; j < nodes.length; j++) {
                            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                                result.add(nodes[j]);
                            }
                        }
                    }
                    // No need to search for <content>.
                }
                return result;
            }
        }
        document.$blockingElements =
            new BlockingElementsImpl();
    })();

    function blockingElements() { return getDocument().$blockingElements; }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */
    function useBlockingElement(enabled, getTarget) {
        const stableGetTarget = useStableCallback(getTarget);
        /**
         * Push/pop the element from the blockingElements stack.
         */
        h(() => {
            const target = stableGetTarget();
            if (enabled) {
                // Sometimes blockingElements will fail if, for example,
                // the target element isn't connected to document.body.
                // This is rare, but it's better to fail silently with weird tabbing behavior
                // than to crash the entire application.
                try {
                    blockingElements().push(target);
                    return () => {
                        blockingElements().remove(target);
                    };
                }
                catch (ex) {
                    // Well, semi-silently.
                    console.error(ex);
                }
            }
        }, [enabled]);
    }
    function getTopElement() {
        return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap({ trapActive }) {
        const handleActiveChange = T$1((trapActive, element) => {
            if (trapActive && element) {
                let rafHandle = requestAnimationFrame(() => {
                    // TODO: This extra queueMicrotask is needed for
                    // ...reasons?
                    queueMicrotask(() => {
                        findFirstFocusable(element)?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
            else if (element) {
                // Restore the focus to the element
                // that has returned to the top of the stack
                let rafHandle = requestAnimationFrame(() => {
                    queueMicrotask(() => {
                        elementsToRestoreFocusTo.get(getTopElement())?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
        }, []);
        const { getLastActiveElement, useActiveElementProps, getElement } = useActiveElement({ onMountChange: useStableCallback((element) => handleActiveChange(trapActive, element)) });
        // When the trap becomes active, before we let the blockingElements hook run,
        // keep track of whatever's currently focused and save it.
        h(() => {
            const element = getElement();
            if (trapActive && element) {
                const document = getDocument(element);
                // Save the currently focused element
                // to whatever's currently at the top of the stack
                elementsToRestoreFocusTo.set(getTopElement(), getLastActiveElement() ?? document.body);
            }
        }, [trapActive]);
        useBlockingElement(trapActive, getElement);
        /**
         * Any time we activate or deactivate the trap,
         * change focus to something else (something in
         * the trap if it's active, or whatever we've
         * tracked in elementsToRestoreFocusTo if not)
         */
        h(() => {
            handleActiveChange(trapActive, getElement());
        }, [trapActive]);
        const useFocusTrapProps = ((props) => {
            const p1 = useActiveElementProps(props);
            const p2 = { "aria-modal": trapActive ? "true" : undefined };
            return useMergedProps(p1, p2);
        });
        return {
            useFocusTrapProps,
            getElement
        };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */
    function findFirstFocusable(element) {
        const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => (node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP) });
        const firstFocusable = treeWalker.firstChild();
        return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */
    function useForceUpdate() {
        const [, set] = y(0);
        return s(() => set(i => ++i)).current;
    }

    function useHasFocus({ onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange }) {
        useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
        const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
        const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
        const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse);
        const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse);
        const { getActiveElement, getLastActiveElement, getWindowFocused, useActiveElementProps, getElement } = useActiveElement({
            onActiveElementChange: T$1((activeElement, prevActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == activeElement));
                const focusedInner = (!!selfElement?.contains(activeElement));
                setFocused(focused);
                setFocusedInner(focusedInner);
                onActiveElementChange?.(activeElement, prevActiveElement);
            }, []),
            onLastActiveElementChange: T$1((lastActiveElement, prevLastActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == lastActiveElement));
                const focusedInner = (!!selfElement?.contains(lastActiveElement));
                setLastFocused(focused);
                setLastFocusedInner(focusedInner);
                onLastActiveElementChange?.(lastActiveElement, prevLastActiveElement);
            }, []),
            onWindowFocusedChange
        });
        const useHasFocusProps = T$1((props) => { return useActiveElementProps(props); }, []);
        return {
            useHasFocusProps,
            getElement,
            getFocused,
            getFocusedInner,
            getLastFocused,
            getLastFocusedInner,
            getActiveElement,
            getLastActiveElement,
            getWindowFocused
        };
    }

    function capitalize(str) {
        return (str[0].toUpperCase() + str.substring(1));
    }
    /**
     * Inspects the element's style and determines the logical direction that text flows.
     *
     * Certain CSS properties, like `block-size`, respect the current writing mode and text direction.
     * But `transform`, `clip`, etc. don't.
     *
     * This is provided so that CSS properties can consistently use those logical properties.
     *
     * See https://drafts.csswg.org/css-writing-modes/#logical-to-physical
     *
     * @returns An object containing the following functions:
     * * `getLogicalDirection`: retrieves a `LogicalDirectionInfo` representing the current state of the element. (Function is constant between renders)
     * * `convertElementSize`: When used in conjunction with `useElementSize`, allows you to retrieve the logical size of an element instead of the physical size.
     * * `convertToLogicalOrientation`: Based on the current direction, converts "horizontal" or "vertical" to "inline" or "block".
     * * `convertToPhysicalOrientation`:  Based on the current direction, converts "inline" or "block" to "horizontal" or "vertical".
     */
    function useLogicalDirection({ onLogicalDirectionChange }) {
        useEnsureStability("useLogicalDirection", onLogicalDirectionChange);
        const [getComputedStyles, setComputedStyles] = usePassiveState(null, returnNull);
        const { getElement, useRefElementProps } = useRefElement({
            onElementChange: T$1((element) => {
                if (element) {
                    setComputedStyles(window.getComputedStyle(element));
                }
            }, [])
        });
        // TODO: There's no way to refresh which writing mode we have once mounted.
        //   A. There's no way to watch for CSS style changes
        //   B. Calling getComputedStyle after every render for every element gets expensive fast and
        //   C. Is not necessary for most use cases that will never switch writing-mode within a single component
        //      (Those that do will need to mount and unmount the component that uses it)
        //
        // As a solution, here's a cheap workaround that checks when the element's size has changed,
        // and if so, tests if the writing mode has changed too.
        //
        // This will work for at least some number of cases, but a better solution is still needed.
        const { useElementSizeProps } = useElementSize({ onSizeChange: T$1(_ => onLogicalDirectionChange?.(getLogicalDirectionInfo()), []) });
        const getLogicalDirectionInfo = T$1(() => {
            const computedStyles = getComputedStyles();
            if (computedStyles) {
                const w = computedStyles.writingMode;
                let d = computedStyles.direction;
                const t = computedStyles.textOrientation;
                if (t == "upright")
                    d = "ltr";
                return ({ ...WritingModes[w || "horizontal-tb"][d || "ltr"] });
            }
            return null;
        }, []);
        //const [getLogicalDirectionInfo, setLogicalDirectionInfo] = usePassiveState<LogicalDirectionInfo>(onLogicalDirectionChange);
        const convertToLogicalOrientation = T$1((elementOrientation, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction?.inlineOrientation === elementOrientation)
                return "inline";
            return "block";
        }, []);
        const convertToPhysicalSide = T$1((side, direction) => {
            direction ??= getLogicalDirectionInfo();
            switch (side) {
                case "block-start":
                    return M[(direction?.blockDirection ?? "ttb")[0]];
                case "block-end":
                    return M[(direction?.blockDirection ?? "ttb")[2]];
                case "inline-start":
                    return M[(direction?.inlineDirection ?? "ltr")[0]];
                case "inline-end":
                    return M[(direction?.inlineDirection ?? "ltr")[2]];
            }
        }, []);
        const convertToLogicalSide = T$1((side, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction?.inlineOrientation === "vertical") {
                switch (side) {
                    case "top":
                        return direction.inlineDirection === "ttb" ? "inline-start" : "inline-end";
                    case "bottom":
                        return direction.inlineDirection === "btt" ? "inline-start" : "inline-end";
                    case "left":
                        return direction.blockDirection === "ltr" ? "block-start" : "block-end";
                    case "right":
                        return direction.blockDirection === "rtl" ? "block-start" : "block-end";
                }
            }
            else if (direction?.inlineOrientation === "horizontal") {
                switch (side) {
                    case "top":
                        return direction.blockDirection === "ttb" ? "block-start" : "block-end";
                    case "bottom":
                        return direction.blockDirection === "btt" ? "block-start" : "block-end";
                    case "left":
                        return direction.inlineDirection === "ltr" ? "inline-start" : "inline-end";
                    case "right":
                        return direction.inlineDirection === "rtl" ? "inline-start" : "inline-end";
                }
            }
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false);
            return "inline-start";
        }, []);
        const convertToPhysicalOrientation = T$1((elementOrientation, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (elementOrientation == "inline") {
                if (direction?.inlineOrientation == "horizontal")
                    return "horizontal";
                return "vertical";
            }
            else {
                if (direction?.blockOrientation == "vertical")
                    return "vertical";
                return "horizontal";
            }
        }, []);
        const convertElementSize = T$1((elementSize, direction) => {
            direction ??= getLogicalDirectionInfo();
            if (direction) {
                const { inlineSize, blockSize, inlineDirection, blockDirection } = direction;
                // Size is relatively simple
                const clientInlineSize = elementSize[`client${capitalize(inlineSize)}`];
                const clientBlockSize = elementSize[`client${capitalize(blockSize)}`];
                const offsetInlineSize = elementSize[`offset${capitalize(inlineSize)}`];
                const offsetBlockSize = elementSize[`offset${capitalize(blockSize)}`];
                const scrollInlineSize = elementSize[`scroll${capitalize(inlineSize)}`];
                const scrollBlockSize = elementSize[`scroll${capitalize(blockSize)}`];
                const f1 = getPhysicalLeftTop(inlineDirection);
                const f2 = getPhysicalRightBottom(inlineDirection);
                const f3 = getPhysicalLeftTop(blockDirection);
                const f4 = getPhysicalRightBottom(blockDirection);
                const clientInlineInset = elementSize[`client${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`client${capitalize(f2)}`]);
                const scrollInlineInset = elementSize[`scroll${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`scroll${capitalize(f2)}`]);
                const offsetInlineInset = elementSize[`offset${capitalize(f1)}`] == undefined ? undefined : (elementSize[`offset${capitalize(f1)}`] + (!f2 ? 0 : elementSize[`offset${capitalize(f2)}`]));
                const clientBlockInset = elementSize[`client${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`client${capitalize(f4)}`]);
                const scrollBlockInset = elementSize[`scroll${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`scroll${capitalize(f4)}`]);
                const offsetBlockInset = elementSize[`offset${capitalize(f3)}`] == undefined ? undefined : (elementSize[`offset${capitalize(f3)}`] + (!f4 ? 0 : elementSize[`offset${capitalize(f4)}`]));
                return {
                    clientInlineSize,
                    scrollInlineSize,
                    offsetInlineSize,
                    clientBlockSize,
                    scrollBlockSize,
                    offsetBlockSize,
                    clientInlineInset,
                    scrollInlineInset,
                    offsetInlineInset,
                    clientBlockInset,
                    scrollBlockInset,
                    offsetBlockInset,
                };
            }
            return null;
        }, []);
        return {
            useLogicalDirectionProps: T$1((props) => useRefElementProps(useElementSizeProps(props)), []),
            getElement,
            getLogicalDirectionInfo,
            convertToLogicalSize: convertElementSize,
            convertToLogicalOrientation,
            convertToPhysicalOrientation,
            convertToLogicalSide,
            convertToPhysicalSide
        };
    }
    // Position requires us to sometimes use one property (like `left`)
    // or sometimes two (like `left` + `width`)
    function getPhysicalLeftTop(dir) { if (dir === "ltr" || dir == "rtl")
        return "left"; return "top"; }
    function getPhysicalRightBottom(dir) { if (dir === "rtl")
        return "width"; if (dir === "btt")
        return "height"; return null; }
    // Helper for extracting info from "ltr", "ttb", etc.
    const M = {
        t: "top",
        b: "bottom",
        l: "left",
        r: "right"
    };
    const HorizontalTbLtr = {
        inlineDirection: "ltr",
        blockDirection: "ttb",
        inlineOrientation: "horizontal",
        blockOrientation: "vertical",
        inlineSize: "width",
        blockSize: "height",
        leftRightDirection: "ltr",
        overUnderDirection: "ttb"
    };
    const HorizontalTbRtl = {
        ...HorizontalTbLtr,
        inlineDirection: "rtl",
    };
    const VerticalRlLtr = {
        inlineDirection: "ttb",
        blockDirection: "rtl",
        inlineOrientation: "vertical",
        blockOrientation: "horizontal",
        inlineSize: "height",
        blockSize: "width",
        leftRightDirection: "ttb",
        overUnderDirection: "rtl"
    };
    const VerticalRlRtl = {
        ...VerticalRlLtr,
        inlineDirection: "btt"
    };
    const SidewaysRlLtr = { ...VerticalRlLtr };
    const SidewaysRlRtl = { ...VerticalRlRtl };
    const VerticalLrLtr = {
        ...VerticalRlLtr,
        blockDirection: "ltr",
    };
    const VerticalLrRtl = {
        ...VerticalRlRtl,
        blockDirection: "ltr",
    };
    const SidewaysLtLtr = {
        ...VerticalLrLtr,
        inlineDirection: "btt",
        leftRightDirection: "btt",
        overUnderDirection: "ltr"
    };
    const SidewaysLtRtl = {
        ...SidewaysLtLtr,
        inlineDirection: "ttb"
    };
    const HorizontalTb = {
        ltr: HorizontalTbLtr,
        rtl: HorizontalTbRtl
    };
    const VerticalRl = {
        ltr: VerticalRlLtr,
        rtl: VerticalRlRtl
    };
    const VerticalLr = {
        ltr: VerticalLrLtr,
        rtl: VerticalLrRtl
    };
    const SidewaysRl = {
        ltr: SidewaysRlLtr,
        rtl: SidewaysRlRtl
    };
    const SidewaysLr = {
        ltr: SidewaysLtLtr,
        rtl: SidewaysLtRtl
    };
    const WritingModes = {
        "horizontal-tb": HorizontalTb,
        "vertical-lr": VerticalLr,
        "vertical-rl": VerticalRl,
        "sideways-lr": SidewaysLr,
        "sideways-rl": SidewaysRl
    };

    function useTimeout({ timeout, callback, triggerIndex }) {
        const stableCallback = useStableCallback(() => { startTimeRef.current = null; callback(); });
        const getTimeout = useStableGetter(timeout);
        // Set any time we start timeout.
        // Unset any time the timeout completes
        const startTimeRef = s(null);
        const timeoutIsNull = (timeout == null);
        // Any time the triggerIndex changes (including on mount)
        // restart the timeout.  The timeout does NOT reset
        // when the duration or callback changes, only triggerIndex.
        _(() => {
            if (!timeoutIsNull) {
                const timeout = getTimeout();
                console.assert(timeoutIsNull == (timeout == null));
                if (timeout != null) {
                    startTimeRef.current = +(new Date());
                    const handle = setTimeout(stableCallback, timeout);
                    return () => clearTimeout(handle);
                }
            }
        }, [triggerIndex, timeoutIsNull]);
        const getElapsedTime = T$1(() => {
            return (+(new Date())) - (+(startTimeRef.current ?? new Date()));
        }, []);
        const getRemainingTime = T$1(() => {
            const timeout = getTimeout();
            return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
        }, []);
        return { getElapsedTime, getRemainingTime };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useLinearNavigation({ navigateToFirst: ntf, navigateToLast: ntl, navigateToNext: ntn, navigateToPrev: ntp, navigationDirection: nd, disableArrowKeys: dak, disableHomeEndKeys: dhek }) {
        nd ??= "either";
        const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection({});
        const navigateToFirst = useStableCallback(ntf);
        const navigateToLast = useStableCallback(ntl);
        const navigateToNext = useStableCallback(ntn);
        const navigateToPrev = useStableCallback(ntp);
        const getDisableArrowKeys = useStableGetter(dak);
        const getDisableHomeEndKeys = useStableGetter(dhek);
        const getNavigationDirection = useStableGetter(nd);
        return {
            linearNavigation: {},
            useLinearNavigationProps: T$1((props) => {
                const onKeyDown = (e) => {
                    // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                    if (e.ctrlKey || e.metaKey)
                        return;
                    const info = getLogicalDirectionInfo();
                    const navigationDirection = getNavigationDirection();
                    const disableArrowKeys = getDisableArrowKeys();
                    const disableHomeEndKeys = getDisableHomeEndKeys();
                    const allowsBlockNavigation = (navigationDirection == "block" || navigationDirection == "either");
                    const allowsInlineNavigation = (navigationDirection == "inline" || navigationDirection == "either");
                    switch (e.key) {
                        case "ArrowUp": {
                            const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.blockOrientation === "vertical" ? allowsBlockNavigation : allowsInlineNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "btt") {
                                    navigateToNext();
                                }
                                else {
                                    navigateToPrev();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowDown": {
                            const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.blockOrientation === "vertical" ? allowsBlockNavigation : allowsInlineNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "btt") {
                                    navigateToPrev();
                                }
                                else {
                                    navigateToNext();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowLeft": {
                            const propName = (info?.inlineOrientation === "horizontal" ? "inlineDirection" : "blockDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.inlineOrientation === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "rtl") {
                                    navigateToNext();
                                }
                                else {
                                    navigateToPrev();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowRight": {
                            const propName = (info?.inlineOrientation === "horizontal" ? "inlineDirection" : "blockDirection");
                            const directionAllowed = (!disableArrowKeys && (info?.inlineOrientation === "horizontal" ? allowsInlineNavigation : allowsBlockNavigation));
                            if (directionAllowed) {
                                if (info?.[propName] === "rtl") {
                                    navigateToPrev();
                                }
                                else {
                                    navigateToNext();
                                }
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                        case "Home":
                            if (!disableHomeEndKeys) {
                                navigateToFirst();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        case "End":
                            if (!disableHomeEndKeys) {
                                navigateToLast();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                    }
                };
                return useLogicalDirectionProps(useMergedProps({ onKeyDown }, props));
            }, []),
        };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useTypeaheadNavigation({ collator, getIndex, typeaheadTimeout, setIndex, noTypeahead }) {
        // For typeahead, keep track of what our current "search" string is (if we have one)
        // and also clear it every 1000 ms since the last time it changed.
        // Next, keep a mapping of typeahead values to indices for faster searching.
        // And, for the user's sake, let them know when their typeahead can't match anything anymore
        const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
        useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
        const sortedTypeaheadInfo = s([]);
        const [invalidTypeahead, setInvalidTypeahead] = useState(false);
        // Handle typeahead for input method editors as well
        // Essentially, when active, ignore further keys 
        // because we're waiting for a CompositionEnd event
        const [, setImeActive, getImeActive] = useState(false);
        // Because composition events fire *after* keydown events 
        // (but within the same task, which, TODO, could be browser-dependent),
        // we can use this to keep track of which event we're listening for on the first keydown.
        const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
        useLayoutEffect(() => {
            if (nextTypeaheadChar !== null) {
                setCurrentTypeahead(typeahead => ((typeahead ?? "") + nextTypeaheadChar));
                setNextTypeaheadChar(null);
            }
        }, [nextTypeaheadChar]);
        const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
            let compare;
            // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
            // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
            safeLhs = safeLhs.normalize("NFD");
            safeRhs = safeRhs.normalize("NFD");
            if (collator)
                compare = collator.compare(safeLhs, safeRhs);
            else
                compare = safeLhs.toLowerCase().localeCompare(safeRhs.toLowerCase() ?? "");
            return compare;
        });
        const insertingComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                return comparatorShared(lhs, rhs.text);
            }
            return lhs - rhs;
        });
        const typeaheadComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                // During typeahead, all strings longer than ours should be truncated
                // so that they're all considered equally by that point.
                return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
            }
            return lhs - rhs;
        });
        const isDisabled = useStableGetter(noTypeahead);
        const useTypeaheadNavigationProps = T$1(function ({ ...props }) {
            const onCompositionStart = (_e) => { setImeActive(true); };
            const onCompositionEnd = (e) => {
                setNextTypeaheadChar(e.data);
                setImeActive(false);
            };
            const onKeyDown = (e) => {
                if (isDisabled())
                    return;
                const imeActive = getImeActive();
                const key = e.key;
                // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                if (e.ctrlKey || e.metaKey)
                    return;
                if (!imeActive && e.key === "Backspace") {
                    // Remove the last character in a way that doesn't split UTF-16 surrogates.
                    setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                // The key property represents the typed character OR the "named key attribute" of the key pressed.
                // There's no definite way to tell the difference, but for all intents and purposes
                // there are no one-character names, and there are no non-ASCII-alpha names.
                // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
                const isCharacterKey = (key.length === 1 || !/^[A-Za-z]/.test(key));
                if (isCharacterKey) {
                    if (key == " " && (getCurrentTypeahead() ?? "").trim().length == 0) ;
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        // Note: Won't be true for the first keydown
                        // but will be overwritten before useLayoutEffect is called
                        // to actually apply the change
                        if (!imeActive)
                            setNextTypeaheadChar(key);
                    }
                }
            };
            return useMergedProps({ onKeyDown, onCompositionStart, onCompositionEnd, }, props);
        }, []);
        // Handle changes in typeahead that cause changes to the tabbable index
        _(() => {
            if (currentTypeahead && sortedTypeaheadInfo.current.length) {
                const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
                if (sortedTypeaheadIndex < 0) {
                    // The user has typed an entry that doesn't exist in the list
                    // (or more specifically "for which there is no entry that starts with that input")
                    setInvalidTypeahead(true);
                }
                else {
                    setInvalidTypeahead(false);
                    /*
                      We know roughly where, in the sorted array of strings, our next typeahead location is.
                      But roughly isn't good enough if there are multiple matches.
                      To convert our sorted index to the unsorted index we need, we have to find the first
                      element that matches us *and* (if any such exist) is *after* our current selection.

                      In other words, the only way typeahead moves backwards relative to our current
                      position is if the only other option is behind us.

                      It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
                      Though there's also a case for just going upwards to the nearest to prevent jumpiness.
                      But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
                      I dunno. Going back to the start is the simplist though.

                      Basically what this does: Starting from where we found ourselves after our binary search,
                      scan backwards and forwards through all adjacent entries that also compare equally so that
                      we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
                      (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).

                      TODO: The binary search starts this off with a solid O(log n), but one-character
                      searches are, thanks to pigeonhole principal, eventually guaranteed to become
                      O(n*log n). This is annoying but probably not easily solvable? There could be an
                      exception for one-character strings, but that's just kicking the can down
                      the road. Maybe one or two characters would be good enough though.
                    */
                    // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
                    let lowestUnsortedIndexAll = null;
                    let lowestSortedIndexAll = sortedTypeaheadIndex;
                    // These two are only set for elements that are ahead of us, but the principle's the same otherwise
                    let lowestUnsortedIndexNext = null;
                    let lowestSortedIndexNext = sortedTypeaheadIndex;
                    const updateBestFit = (u) => {
                        if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                            lowestUnsortedIndexAll = u;
                            lowestSortedIndexAll = i;
                        }
                        if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > (getIndex() ?? -Infinity)) {
                            lowestUnsortedIndexNext = u;
                            lowestSortedIndexNext = i;
                        }
                    };
                    let i = sortedTypeaheadIndex;
                    while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        --i;
                    }
                    i = sortedTypeaheadIndex;
                    while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        ++i;
                    }
                    if (lowestUnsortedIndexNext !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);
                    else if (lowestUnsortedIndexAll !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
                }
            }
        }, [currentTypeahead]);
        const useTypeaheadNavigationChild = T$1(({ index, text }) => {
            _(() => {
                if (text) {
                    // Find where to insert this item.
                    // Because all index values should be unique, the returned sortedIndex
                    // should always refer to a new location (i.e. be negative)                
                    const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                    console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                    if (sortedIndex < 0) {
                        sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, { text, unsortedIndex: index });
                    }
                    else {
                        sortedTypeaheadInfo.current.splice(sortedIndex, 0, { text, unsortedIndex: index });
                    }
                    return () => {
                        // When unmounting, find where we were and remove ourselves.
                        // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
                        const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                        console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                        if (sortedIndex >= 0) {
                            sortedTypeaheadInfo.current.splice(sortedIndex, 1);
                        }
                    };
                }
            }, [text]);
            return;
        }, []);
        return {
            useTypeaheadNavigationChild,
            useTypeaheadNavigationProps,
            typeaheadNavigation: {
                currentTypeahead,
                invalidTypeahead,
            }
        };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */
    function binarySearch(array, wanted, comparator) {
        let firstIndex = 0;
        let lastIndex = array.length - 1;
        while (firstIndex <= lastIndex) {
            const testIndex = (lastIndex + firstIndex) >> 1;
            const comparisonResult = comparator(wanted, array[testIndex]);
            if (comparisonResult > 0) {
                firstIndex = testIndex + 1;
            }
            else if (comparisonResult < 0) {
                lastIndex = testIndex - 1;
            }
            else {
                return testIndex;
            }
        }
        return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */
    function useRovingTabIndex(parentParameters) {
        let { rovingTabIndex: { initialIndex, onTabbedInTo, onTabbedOutOf, onTabbableRender, onTabbableIndexChange }, managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        initialIndex ??= 0;
        const stableOnTabbableRender = useStableCallback(onTabbableRender ?? (() => { }));
        const [_getAnyFocused, setAnyFocused] = usePassiveState(useStableCallback((newCount, oldCount) => {
            if (oldCount == 0 && newCount > 0) {
                onTabbedInTo?.();
            }
            if (newCount == 0 && (oldCount ?? 0) > 0) {
                onTabbedOutOf?.();
            }
        }), returnZero);
        // Keep track of three things related to the currently tabbable element's index:
        // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.
        const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, T$1(() => { return initialIndex ?? 0; }, []));
        const setTabbableIndex = T$1((updater, fromUserInteraction) => {
            setTabbableIndex2((prevIndex) => {
                let nextIndex = prevIndex;
                if (typeof updater === "function")
                    nextIndex = updater(prevIndex ?? null);
                else
                    nextIndex = updater;
                nextIndex = changeIndex(nextIndex);
                if (prevIndex != nextIndex) {
                    const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
                    const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
                    if (prevChild != null)
                        prevChild.subInfo.blurSelf();
                    if (nextChild != null && fromUserInteraction)
                        nextChild.subInfo.focusSelf();
                }
                return nextIndex;
            });
        }, []);
        // Any time the tabbable index changes,
        // notify the previous child that it's no longer tabbable,
        // and notify the next child that is allowed to be tabbed to.
        const parentReturnType = useManagedChildren({
            managedChildren: {
                onAfterChildLayoutEffect,
                onChildrenMountChange: useStableCallback((mounted, unmounted) => { onChildrenMountChange?.(mounted, unmounted); reevaluateClosestFit(); }),
            },
        });
        const { useManagedChild } = parentReturnType;
        const { changeIndex, reevaluateClosestFit } = useChildrenFlag({ initialIndex, children: parentReturnType.managedChildren.children, closestFit: true, key: "tabbable" });
        const useRovingTabIndexChild = T$1((childParameters) => {
            const { managedChild: { index, flags }, rovingTabIndex: { hidden, subInfo, blurSelf: blurSelfOverride, focusSelf: focusSelfOverride } } = childParameters;
            _(() => {
                reevaluateClosestFit();
            }, [!!hidden]);
            const bsOverride = useStableGetter(blurSelfOverride);
            const fsOverride = useStableGetter(focusSelfOverride);
            const focusSelf = T$1(() => {
                const fs = fsOverride();
                if (fs) {
                    console.log(`useRovingTabIndexChild[${index}].focusSelf (override)`);
                    fs();
                }
                else {
                    console.log(`useRovingTabIndexChild[${index}].focusSelf (default)`);
                    const element = getElement();
                    if (element)
                        element.focus?.();
                }
            }, []);
            const blurSelf = T$1(() => {
                const bs = bsOverride();
                if (bs) {
                    console.log(`useRovingTabIndexChild[${index}].blurSelf (override)`);
                    bs();
                }
                else {
                    console.log(`useRovingTabIndexChild[${index}].blurSelf (default)`);
                    const element = getElement();
                    if (element)
                        element.blur?.();
                }
            }, []);
            const onFocusedInnerChanged = useStableCallback((focused) => {
                setAnyFocused(prev => (focused ? ((prev ?? 0) + 1) : ((prev ?? 0) - 1)));
                if (focused) {
                    console.log(`Child ${index} has been focused and will set itself as the tabbable child`);
                    setTabbableIndex(index, true);
                }
            });
            const { getElement, useHasFocusProps } = useHasFocus({ onFocusedInnerChanged });
            const [tabbable, setTabbable, getTabbable] = useState(false);
            const tabbableFlags = s({ get: getTabbable, set: setTabbable, isValid: useStableCallback(() => !hidden) });
            useManagedChild({
                managedChild: {
                    index,
                    flags: { ...flags, tabbable: tabbableFlags.current },
                    subInfo: {
                        blurSelf,
                        focusSelf,
                        getElement,
                        hidden: !!hidden,
                        subInfo
                    }
                }
            });
            _(() => {
                if (tabbable)
                    stableOnTabbableRender(index);
            }, [tabbable, index]);
            function useRovingTabIndexChildProps(props) {
                console.assert(props.tabIndex == null);
                return useMergedProps(useHasFocusProps({ tabIndex: tabbable ? 0 : -1 }), props);
            }
            return {
                useRovingTabIndexChildProps,
                rovingTabIndex: {
                    getElement,
                    tabbable,
                    getTabbable
                }
            };
        }, [ /* Must remain stable */]);
        const focusSelf = T$1(() => {
            console.log(`useRovingTabIndex.focusSelf`);
            const index = getTabbableIndex();
            if (index != null)
                parentReturnType.managedChildren.children.getAt(index)?.subInfo.focusSelf?.();
            else
                setTabbableIndex(null, true);
        }, []);
        return {
            useRovingTabIndexChild,
            managedChildren: { children: parentReturnType.managedChildren.children },
            rovingTabIndex: {
                setTabbableIndex,
                getTabbableIndex,
                focusSelf,
            }
        };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Built-in value references. */
    var Buffer = moduleExports$1 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$1;

      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useRearrangeableChildren({ getIndex }) {
        // These are used to keep track of a mapping between unsorted index <---> sorted index.
        // These are needed for navigation with the arrow keys.
        const mangleMap = s(new Map());
        const demangleMap = s(new Map());
        const indexMangler = T$1((n) => (mangleMap.current.get(n) ?? n), []);
        const indexDemangler = T$1((n) => (demangleMap.current.get(n) ?? n), []);
        // The sort function needs to be able to update whoever has all the sortable children.
        // Because that might not be the consumer of *this* hook directly (e.g. a table uses
        // this hook, but it's tbody that actually needs updating), we need to remotely
        // get and set a forceUpdate function.
        //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
        const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
        const rearrange = T$1((sortedRows) => {
            // Update our sorted <--> unsorted indices map 
            // and rerender the whole table, basically
            for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
                const indexAsUnsorted = sortedRows[indexAsSorted].index;
                mangleMap.current.set(indexAsUnsorted, indexAsSorted);
                demangleMap.current.set(indexAsSorted, indexAsUnsorted);
            }
            getForceUpdate()?.();
        }, []);
        const useRearrangeableProps = T$1(({ children, ...props }) => {
            const forceUpdate = useForceUpdate();
            h(() => { setForceUpdate(_prev => forceUpdate); }, [forceUpdate]);
            return (useMergedProps({
                children: children
                    .slice()
                    .map(child => ({ child, mangledIndex: indexMangler(getIndex(child.props)), demangledIndex: getIndex(child.props) }))
                    .sort((lhs, rhs) => { return lhs.mangledIndex - rhs.mangledIndex; })
                    .map(({ child, mangledIndex, demangledIndex }) => {
                    return h$1(child.type, { ...child.props, key: demangledIndex, "data-mangled-index": mangledIndex, "data-unmangled-index": demangledIndex });
                })
            }, props));
        }, []);
        return { useRearrangeableProps, indexMangler, indexDemangler, mangleMap, demangleMap, rearrange };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useSortableChildren({ getIndex, getValue, compare: userCompare }) {
        const compare = (userCompare ?? defaultCompare);
        const { rearrange, useRearrangeableProps: useSortableProps, ...rest } = useRearrangeableChildren({ getIndex });
        // The actual sort function.
        const sort = T$1((managedRows, direction, ...args) => {
            const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
                const lhsValue = getValue(lhsRow, ...args);
                const rhsValue = getValue(rhsRow, ...args);
                const result = compare(lhsValue, rhsValue); // lhsRow.getManagedCells()?.[column]?.value, rhsRow.getManagedCells()?.[column]?.value);
                if (direction[0] == "d")
                    return -result;
                return result;
            });
            return rearrange(sortedRows);
        }, [ /* Must remain stable */]);
        const shuffle$1 = T$1((managedRows) => {
            const shuffledRows = shuffle(managedRows.arraySlice());
            return rearrange(shuffledRows);
        }, [ /* Must remain stable */]);
        return { useSortableProps, sort, rearrange, shuffle: shuffle$1, ...rest };
    }
    function defaultCompare(lhs, rhs) {
        return compare1(lhs, rhs);
        function compare3(lhs, rhs) {
            // Coerce strings to numbers if they seem to stay the same when serialized
            if (`${+lhs}` === lhs)
                lhs = +lhs;
            if (`${+rhs}` === rhs)
                rhs = +rhs;
            // At this point, if either argument is a string, turn the other one into one too
            if (typeof lhs === "string")
                rhs = `${rhs}`;
            if (typeof rhs === "string")
                lhs = `${lhs}`;
            console.assert(typeof lhs === typeof rhs);
            if (typeof lhs === "string")
                return lhs.localeCompare(rhs);
            if (typeof lhs === "number")
                return +lhs - +rhs;
            return 0;
        }
        function compare2(lhs, rhs) {
            if (typeof lhs === "boolean" || lhs instanceof Date)
                lhs = +lhs;
            if (typeof rhs === "boolean" || rhs instanceof Date)
                rhs = +rhs;
            return compare3(lhs, rhs);
        }
        function compare1(lhs, rhs) {
            if (lhs == null && rhs == null) {
                // They're both null
                return 0;
            }
            else if (lhs == null || rhs == null) {
                // One of the two is null -- easy case
                return lhs != null ? 1 : -1;
            }
            return compare2(lhs, rhs);
        }
    }

    function identity(t) { return t; }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */
    function useListNavigation({ managedChildren: mc, rovingTabIndex, listNavigation: { indexDemangler, indexMangler }, linearNavigation, typeaheadNavigation }) {
        indexMangler ??= identity;
        indexDemangler ??= identity;
        useEnsureStability("useListNavigation", indexMangler, indexDemangler);
        const parentReturnType = useRovingTabIndex({
            managedChildren: mc,
            rovingTabIndex
        });
        const { useRovingTabIndexChild, managedChildren: { children }, rovingTabIndex: { getTabbableIndex, setTabbableIndex } } = parentReturnType;
        const navigateToIndex = T$1((i, fromUserInteraction) => {
            if (i != null) {
                const nextIndex = tryNavigateToIndex({
                    children: children,
                    default: 0,
                    target: i,
                    searchDirection: 1,
                    indexMangler: indexMangler ?? identity,
                    indexDemangler: indexDemangler ?? identity
                });
                setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
            }
            else {
                setTabbableIndex(null, fromUserInteraction);
            }
        }, []);
        const { useTypeaheadNavigationChild, useTypeaheadNavigationProps, typeaheadNavigation: { currentTypeahead, invalidTypeahead } } = useTypeaheadNavigation({
            getIndex: getTabbableIndex,
            setIndex: T$1((index) => {
                setTabbableIndex(index, true);
            }, []),
            ...typeaheadNavigation
        });
        const { useLinearNavigationProps } = useLinearNavigation({
            navigateToPrev: T$1(() => {
                setTabbableIndex(c => {
                    return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler((c ?? 0)) - 1), searchDirection: -1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                }, true);
            }, []),
            navigateToNext: T$1(() => {
                setTabbableIndex(c => {
                    return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler(c ?? 0) + 1), searchDirection: 1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                }, true);
            }, []),
            navigateToFirst: T$1(() => { navigateToIndex(indexDemangler(0), true); }, []),
            navigateToLast: T$1(() => { navigateToIndex(indexDemangler(children.getHighestIndex()), true); }, []),
            ...linearNavigation
        });
        const useListNavigationProps = T$1((props) => {
            return useLinearNavigationProps(useTypeaheadNavigationProps(props));
        }, [useLinearNavigationProps, useTypeaheadNavigationProps]);
        const useListNavigationChild = T$1(({ managedChild: { index, flags }, rovingTabIndex: { blurSelf, focusSelf, hidden }, listNavigation: { text, subInfo } }) => {
            useTypeaheadNavigationChild({ text, index });
            const getIndex = useStableGetter(index);
            useEffect(() => {
                return () => {
                    if (getTabbableIndex() == getIndex()) {
                        navigateToIndex(index, false);
                    }
                };
            }, []);
            const { useRovingTabIndexChildProps, rovingTabIndex: { tabbable, getTabbable, getElement } } = useRovingTabIndexChild({
                managedChild: { index, flags },
                rovingTabIndex: { blurSelf, focusSelf, hidden: !!hidden, subInfo: { text, subInfo } }
            });
            const useListNavigationChildProps = function ({ ...props }) {
                return useMergedProps(useRovingTabIndexChildProps({ inert: hidden }), props);
            };
            return {
                useListNavigationChildProps,
                rovingTabIndex: {
                    tabbable,
                    getTabbable,
                    getElement
                }
            };
        }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
        return {
            useListNavigationChild,
            useListNavigationProps,
            listNavigation: { navigateToIndex },
            managedChildren: parentReturnType.managedChildren,
            rovingTabIndex: parentReturnType.rovingTabIndex,
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }
            /*listNavigation: { navigateToIndex },
            rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/
        };
    }
    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */
    function useListNavigationSingleSelection({ singleSelection: { selectedIndex }, listNavigation, managedChildren: { /*onChildrenMountChange: ocmc,*/ ...mc }, rovingTabIndex: { initialIndex, ...rovingTabIndex }, linearNavigation, typeaheadNavigation }) {
        const parentReturnType = useListNavigation({
            listNavigation,
            managedChildren: {
                ...mc,
                /*onChildrenMountChange: useStableCallback<OnChildrenMountChange<number>>((mounted, unmounted) => {
                    reevaluateClosestFit();
                    ocmc?.(mounted, unmounted);
                })*/
            },
            rovingTabIndex: {
                initialIndex: (initialIndex ?? selectedIndex ?? undefined),
                ...rovingTabIndex
            },
            linearNavigation,
            typeaheadNavigation
        });
        const { managedChildren: { children }, useListNavigationChild, useListNavigationProps, ...listRest } = parentReturnType;
        const { changeIndex: changeSelectedIndex, getCurrentIndex: getSelectedIndex,
        //reevaluateClosestFit
         } = useChildrenFlag({
            children: children,
            initialIndex: selectedIndex,
            key: "selected",
            closestFit: false
        });
        h(() => {
            changeSelectedIndex(selectedIndex);
        }, [selectedIndex]);
        return {
            managedChildren: { children },
            useListNavigationSingleSelectionChild: T$1(({ managedChild: { index, flags }, rovingTabIndex: rti, listNavigation: ls }) => {
                const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
                const selectedRef = s({ get: getIsSelected, set: setIsSelected, isValid: useStableCallback(() => !rti.hidden) });
                const { rovingTabIndex: rti_ret, useListNavigationChildProps } = useListNavigationChild({
                    managedChild: {
                        index,
                        flags: {
                            selected: selectedRef.current,
                            ...flags
                        }
                    },
                    rovingTabIndex: rti,
                    listNavigation: ls
                });
                return {
                    useListNavigationChildProps,
                    rovingTabIndex: rti_ret,
                    singleSelection: { selected: isSelected, getSelected: getIsSelected }
                };
            }, []),
            useListNavigationSingleSelectionProps: T$1((...p) => { return useListNavigationProps(...p); }, []),
            ...listRest
        };
    }
    function useSortableListNavigationSingleSelection({ linearNavigation, listNavigation, managedChildren, rovingTabIndex, singleSelection, typeaheadNavigation }) {
        const { indexDemangler, indexMangler, demangleMap, mangleMap, rearrange, sort, useSortableProps, shuffle } = useSortableChildren({
            getIndex: T$1((row) => row.index, []),
            getValue: T$1((row) => row.index, []),
            compare: T$1((lhs, rhs) => { return lhs - rhs; }, []),
        });
        const { useListNavigationSingleSelectionChild, useListNavigationSingleSelectionProps, ...rest } = useListNavigationSingleSelection({
            linearNavigation: linearNavigation,
            listNavigation: { indexDemangler, indexMangler, ...listNavigation },
            managedChildren: managedChildren,
            rovingTabIndex: rovingTabIndex,
            typeaheadNavigation: typeaheadNavigation,
            singleSelection: singleSelection
        });
        const useSortableListNavigationSingleSelectionProps = (props) => {
            return (useListNavigationSingleSelectionProps(useSortableProps(props)));
        };
        const useSortableListNavigationSingleSelectionChild = (p) => {
            return useListNavigationSingleSelectionChild(p);
        };
        return ({
            useSortableListNavigationSingleSelectionChild,
            useSortableListNavigationSingleSelectionProps,
            sortable: { sort, shuffle, rearrange, demangleMap, indexDemangler, indexMangler, mangleMap },
            ...rest
        });
    }
    function tryNavigateToIndex({ children, searchDirection, indexDemangler, indexMangler, target }) {
        const upper = children.getHighestIndex();
        const lower = 0;
        if (searchDirection === -1) {
            while ((target >= lower && (children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden))
                target = indexDemangler(indexMangler(target) - 1);
            return target < lower ? indexDemangler(lower) : target;
        }
        else if (searchDirection === 1) {
            while ((target <= upper && children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden)
                target = indexDemangler(indexMangler(target) + 1);
            return target > upper ? indexDemangler(upper) : target;
        }
        else {
            return lower;
        }
    }

    function useGridNavigation({ managedChildren: mc, rovingTabIndex: rti, listNavigation: ls, linearNavigation: ln, typeaheadNavigation: tn }) {
        const [currentColumn, setCurrentColumn, getCurrentColumn] = useState(rti.initialIndex ?? 0);
        const parentLsReturnType = useListNavigation({
            managedChildren: mc,
            rovingTabIndex: rti,
            listNavigation: ls,
            linearNavigation: { navigationDirection: "block", ...ln },
            typeaheadNavigation: tn,
        });
        const { useListNavigationChild: useListNavigationChildAsGridRow, useListNavigationProps: useListNavigationPropsAsGridParent } = parentLsReturnType;
        const useGridNavigationRow = T$1(({ asChildRow: asChild, asParentOfCells: asParent }) => {
            // Override the focusSelf that rovingTabIndex does.
            // Instead of focusing the entire row, we ask the cell that corresponds
            // to our current column to focus itself.
            const focusSelf = useStableCallback(() => {
                const c2 = getCurrentColumn();
                console.log(`row #${asChild.managedChild.index},${c2} focusSelf`);
                if (asChild.rovingTabIndex.focusSelf) {
                    asChild.rovingTabIndex.focusSelf();
                }
                else {
                    navigateToIndex(c2 ?? 0, true);
                }
            });
            const rowLsChildReturnType = useListNavigationChildAsGridRow({
                managedChild: asChild.managedChild,
                listNavigation: { ...asChild.listNavigation },
                rovingTabIndex: { ...asChild.rovingTabIndex, focusSelf }
            });
            const { rovingTabIndex: { tabbable }, useListNavigationChildProps } = rowLsChildReturnType;
            _(() => {
                if (!tabbable) {
                    navigateToIndex(null, false);
                }
            }, [tabbable]);
            const rowLsReturnType = useListNavigation({
                managedChildren: { ...asParent.managedChildren },
                rovingTabIndex: { ...asParent.rovingTabIndex },
                linearNavigation: {
                    ...asParent.linearNavigation,
                    navigationDirection: "inline",
                },
                typeaheadNavigation: { ...asParent.typeaheadNavigation, noTypeahead: true },
                listNavigation: { ...asParent.listNavigation }
            });
            const { rovingTabIndex: { setTabbableIndex }, useListNavigationChild: useGridNavigationColumn2, useListNavigationProps: useGridNavigationColumnProps, listNavigation: { navigateToIndex } } = rowLsReturnType;
            //const rowHidden = !!asChild.rovingTabIndex.hidden;
            const useGridNavigationCell = T$1(({ managedChild, listNavigation: ls, rovingTabIndex: { blurSelf: bs, focusSelf: fs, ...rti }, gridNavigation: { subInfo } }) => {
                //rti.hidden || rowHidden;
                const focusSelf = useStableCallback(() => {
                    console.log(`cell #${managedChild.index} focusSelf`);
                    setCurrentColumn(managedChild.index);
                    setTabbableIndex(managedChild.index, false);
                    if (fs)
                        fs();
                    else
                        rti_cell_ret.getElement()?.focus?.();
                });
                const blurSelf = useStableCallback(() => {
                    if (bs)
                        bs();
                    else
                        rti_cell_ret.getElement()?.blur?.();
                });
                const { useListNavigationChildProps, rovingTabIndex: rti_cell_ret } = useGridNavigationColumn2({
                    managedChild: managedChild,
                    listNavigation: { ...ls, subInfo },
                    rovingTabIndex: { blurSelf, focusSelf, ...rti }
                });
                const { useHasFocusProps } = useHasFocus({
                    onLastFocusedInnerChanged: useStableCallback((focused) => {
                        if (focused) {
                            setCurrentColumn(managedChild.index);
                            setTabbableIndex(managedChild.index, false);
                        }
                    })
                });
                const ret = {
                    gridNavigation: { getCurrentColumn },
                    rovingTabIndex: rti_cell_ret,
                    useGridNavigationCellProps: function (props) { return useListNavigationChildProps(useGridNavigationColumnProps(useHasFocusProps(props))); }
                };
                return ret;
            }, []);
            const ret = {
                asParentOfCells: {
                    linearNavigation: rowLsReturnType.linearNavigation,
                    listNavigation: rowLsReturnType.listNavigation,
                    managedChildren: rowLsReturnType.managedChildren,
                    rovingTabIndex: rowLsReturnType.rovingTabIndex,
                    typeaheadNavigation: rowLsReturnType.typeaheadNavigation,
                },
                asChildRow: rowLsChildReturnType,
                useGridNavigationCell,
                useGridNavigationRowProps: function (props) {
                    const ret = useListNavigationChildProps(props);
                    ret.tabIndex = -1;
                    return ret;
                }
            };
            return ret;
        }, []);
        return {
            gridNavigation: {
                getCurrentColumn,
                currentColumn
            },
            linearNavigation: parentLsReturnType.linearNavigation,
            listNavigation: parentLsReturnType.listNavigation,
            rovingTabIndex: parentLsReturnType.rovingTabIndex,
            typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
            managedChildren: parentLsReturnType.managedChildren,
            useGridNavigationRow,
            useGridNavigationProps: useListNavigationPropsAsGridParent,
        };
    }

    function useInterval({ interval, callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback);
        const getInterval = useStableGetter(interval);
        _(() => {
            const interval = getInterval();
            let lastDelayUsed = interval;
            if (interval == null)
                return;
            // Get a wrapper around the wrapper around the callback
            // that clears and resets the interval if it changes.
            const adjustableCallback = () => {
                stableCallback();
                const currentInterval = getInterval();
                if (currentInterval != lastDelayUsed) {
                    clearInterval(handle);
                    if (currentInterval != null)
                        handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
                }
            };
            let handle = setInterval(adjustableCallback, interval);
            return () => clearInterval(handle);
        }, []);
    }

    const DemoUseInterval = () => {
        const [interval, setInterval] = y(1000);
        const [fireCount, setFireCount] = y(0);
        useInterval({ interval, callback: () => setFireCount(i => ++i) });
        return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Interval duration: ", e$1("input", { type: "number", value: interval, onInput: e => setInterval(e.currentTarget.valueAsNumber) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const RovingChildContext = B(null);
    const DemoUseRovingTabIndex = g(() => {
        const [count, setCount] = useState(10);
        const [_lastFocusedInner, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner });
        //const forceUpdate = useForceUpdate();
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [tabbableIndex, setLocalTabbableIndex] = useState(0);
        /*const {
            indexDemangler,
            indexMangler,
            useSortableProps,
            shuffle
        } = useSortableChildren<HTMLUListElement, {}, string, [], number>({
            getIndex: useCallback((row) => row.index, []),
            getValue: useCallback((row) => row.index, []),
            compare: useCallback((lhs, rhs) => { return lhs - rhs; }, [])
        });*/
        const { managedChildren: { children }, useSortableListNavigationSingleSelectionChild, useSortableListNavigationSingleSelectionProps, rovingTabIndex: { setTabbableIndex }, typeaheadNavigation: { currentTypeahead }, sortable: { shuffle } } = useSortableListNavigationSingleSelection({
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: { onTabbableIndexChange: T$1((index) => { if (index != null)
                    setLocalTabbableIndex(index); }, []) },
            typeaheadNavigation: {},
            singleSelection: { selectedIndex }
        });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        return (e$1("div", { className: "demo", children: [e$1("h2", { children: "Keyboard & List Navigation" }), e$1("h3", { children: e$1("code", { children: "useRovingTabIndex" }) }), e$1("p", { children: ["Native HTML elements offer fantastic keyboard accessability, but cover a relatively limited number of use cases. There is no native HTML tree element, for example, that allows keyboard navigation of its items, nor is it possible to combine the keyboard navigation behavior of a ", e$1("code", { children: "<select>" }), " menu with the menu in a drawer component."] }), e$1("p", { children: ["When coming across a List or a Menu or a RadioGroup or a ToggleButtonGroup or any other \"one component made up of child components\", the usual expected behavior, at least natively, is that tabbing into the component is one action, and tabbing out is another.  Navigating ", e$1("em", { children: "within" }), " the component is done with the arrow keys or other methods."] }), e$1("p", { children: ["This is important both for accessability, but also just for general usability.  When tabbing back and forth, the ability to skip a long list without needing to trudge through ", e$1("em", { children: "every one" }), " of its child elements is extremely important."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " wraps up the functionality of a few hooks (", e$1("code", { children: "useRovingTabIndex" }), ", ", e$1("code", { children: "useLinearNavigation" }), ", ", e$1("code", { children: "useTypeaheadNavigation" }), ") to allow for ARIA-compliant navigation of lists and other similar components.  For more advanced use cases, you can use the other hooks individually."] }), e$1("p", { children: [e$1("code", { children: "useListNavigation" }), " (and ", e$1("code", { children: "useRovingTabIndex" }), ") internally use ", e$1("code", { children: "useChildManager" }), ", which is how the child elements and the parent communicate with each other. This means there are virtually no restrictions on how the DOM is set up as long as you can provide the children with the ", e$1("code", { children: "useListNavigationChild" }), " hook that's returned, usually with a simple ", e$1("code", { children: "Context" }), ". If the child element itself has a focusable element, like a button, it can also be wired up to disable itself Feel free to nest them too, as long as you are aware of your ", e$1("code", { children: "Context" }), " management (i.e. remember that you need to create a new ", e$1("code", { children: "Context" }), " for each use case)."] }), e$1("label", { children: ["# of items", e$1("input", { type: "number", value: count, min: 0, onInput: e => { e.preventDefault(); setCount(e.currentTarget.valueAsNumber); } })] }), e$1("button", { onClick: () => shuffle(children), children: "Shuffle" }), e$1("label", { children: ["Tabbable index: ", e$1("input", { type: "number", value: tabbableIndex ?? undefined, onInput: e => { e.preventDefault(); setTabbableIndex(e.currentTarget.valueAsNumber, false); } })] }), e$1(RovingChildContext.Provider, { value: useSortableListNavigationSingleSelectionChild, children: e$1("ul", { ...useHasFocusProps(useSortableListNavigationSingleSelectionProps({
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield e$1(DemoUseRovingTabIndexChild, { index: i, setSelectedIndex: setSelectedIndex }, i);
                                }
                            })())
                        })) }) }), currentTypeahead && e$1("div", { children: ["Typeahead: ", currentTypeahead] })] }));
    });
    const DemoUseRovingTabIndexChild = g((({ index, setSelectedIndex }) => {
        const hidden = (index == 7);
        const [randomWord] = useState(() => RandomWords$1[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useRovingTabIndexChild = q$1(RovingChildContext);
        const text = `${randomWord} This is item #${index}${hidden ? " (hidden)" : ""}`;
        const { useListNavigationChildProps, rovingTabIndex: { tabbable }, singleSelection: { selected } } = useRovingTabIndexChild({ managedChild: { index }, listNavigation: { subInfo: {}, text }, rovingTabIndex: { hidden } });
        const props = useListNavigationChildProps({});
        return (e$1("li", { ...props, onClick: () => setSelectedIndex(index), children: [text, " (", tabbable ? "Tabbable" : "Not tabbable", ", ", selected ? "Selected" : "Not selected", ")", e$1("input", { ...useListNavigationChildProps({ type: "number" }), style: { width: "5ch" } })] }));
    }));

    const DemoUseTimeout = () => {
        const [timeout, setTimeout] = y(1000);
        const [triggerIndex, setTriggerIndex] = y("");
        const [fireCount, setFireCount] = y(0);
        useTimeout({ timeout, triggerIndex, callback: () => setFireCount(i => ++i) });
        return (e$1("div", { class: "demo", children: [e$1("label", { children: ["Timeout duration: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Refresh key: ", e$1("input", { type: "text", value: triggerIndex, onInput: e => setTriggerIndex(e.currentTarget.value) })] }), e$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const DemoUseDroppable = () => {
        const { droppedFiles, droppedStrings, filesForConsideration, stringsForConsideration, useDroppableProps, dropError } = useDroppable({ effect: "copy" });
        useMergedProps({}, { ref: s(null) });
        const p = useDroppableProps({ className: "demo droppable" });
        return (e$1("div", { ...p, children: [droppedStrings != null && e$1("div", { children: ["Data dropped: ", e$1("ul", { children: Object.entries(droppedStrings).map(([type, value]) => e$1("li", { children: [type, ": ", value] })) })] }), droppedFiles != null && e$1("div", { children: ["Files dropped: ", e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Name" }), e$1("th", { children: "Size" }), e$1("th", { children: "Type" }), e$1("th", { children: "Last modified" })] }) }), e$1("tbody", { children: droppedFiles.map(f => e$1("tr", { children: [e$1("td", { children: f.name }), f.data.byteLength, e$1("td", { children: f.type }), e$1("td", { children: new Date(f.lastModified ?? 0) })] })) })] })] }), e$1("hr", {}), stringsForConsideration != null && e$1("div", { children: ["Data being considered: ", e$1("ul", { children: Array.from(stringsForConsideration).map(type => e$1("li", { children: type })) })] }), filesForConsideration != null && e$1("div", { children: ["Files being considered: ", e$1("ul", { children: filesForConsideration.map(f => e$1("li", { children: JSON.stringify(f) })) })] }), e$1("hr", {}), dropError && e$1("div", { children: dropError instanceof Error ? dropError.message : JSON.stringify(dropError) })] }));
    };
    const DemoUseDraggable = () => {
        const { useDraggableProps } = useDraggable({ data: { "text/plain": "This is custom draggable content of type text/plain." } });
        return (e$1("div", { ...useDraggableProps({ className: "demo" }), children: "Draggable content" }));
    };
    const DemoUseElementSizeAnimation = () => {
        const [height, setHeight] = useState(0);
        const [angle, setAngle] = useState(0);
        useAnimationFrame({
            callback: (_ms) => {
                setAngle(a => a + 0.01);
                setHeight((Math.sin(angle) + 1) / 0.5);
            }
        });
        const [elementSize, setElementSize] = useState(null);
        const { useElementSizeProps } = useElementSize({ onSizeChange: setElementSize });
        return (e$1("div", { ...useElementSizeProps({ ref: undefined, className: "demo", style: { height: `${(height * 100) + 100}px` } }), children: e$1("pre", { children: JSON.stringify(elementSize, null, 2) }) }));
    };
    const DemoUseFocusTrap = g(({ depth }) => {
        const [active, setActive] = useState(false);
        const { useFocusTrapProps } = useFocusTrap({ trapActive: active });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        const divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return e$1("div", {});
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), e$1("div", { ...divProps, children: e$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
    });
    const DemoUseFocusTrapChild = g(({ setActive, active }) => {
        return (e$1(p$1, { children: [e$1("button", { children: "Button 1" }), e$1("button", { children: "Button 2" }), e$1("button", { children: "Button 3" }), e$1("label", { children: ["Active: ", e$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
    });
    const DemoUseAsyncHandler1 = g(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const asyncOnClick = ((_v, _e) => new Promise((resolve, reject) => window.setTimeout(() => getShouldThrow() ? reject() : resolve(), timeout)));
        const { callCount, settleCount, hasCapture, syncHandler, pending, hasError, rejectCount, resolveCount } = useAsyncHandler(asyncOnClick, { capture: () => { }, debounce: debounce == 0 ? undefined : debounce });
        const onClick = pending ? undefined : syncHandler;
        return (e$1("div", { className: "demo", children: [e$1("button", { disabled: pending && disableConsecutive, onClick: onClick, children: "Click me!" }), e$1("label", { children: ["Sleep for: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Throw an error ", e$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), e$1("label", { children: ["Disabled while pending ", e$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), e$1("label", { children: ["Debounce: ", e$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Field" }), e$1("th", { children: "Value" })] }) }), e$1("tbody", { children: [e$1("tr", { children: [e$1("td", { children: "callCount" }), e$1("td", { children: callCount })] }), e$1("tr", { children: [e$1("td", { children: "settleCount" }), e$1("td", { children: settleCount })] }), e$1("tr", { children: [e$1("td", { children: "resolveCount" }), e$1("td", { children: resolveCount })] }), e$1("tr", { children: [e$1("td", { children: "rejectCount" }), e$1("td", { children: rejectCount })] }), e$1("tr", { children: [e$1("td", { children: "hasError" }), e$1("td", { children: hasError.toString() })] }), e$1("tr", { children: [e$1("td", { children: "hasCapture" }), e$1("td", { children: hasCapture.toString() })] })] })] })] }));
    });
    const DemoUseAsyncHandler2 = g(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const [text, setText] = useState("");
        const onInputAsync = async (v, _e) => new Promise((resolve, reject) => window.setTimeout(() => {
            if (getShouldThrow()) {
                reject();
            }
            else {
                setText(v);
                resolve();
            }
        }, timeout));
        const { callCount, settleCount, hasCapture, syncHandler, currentCapture, pending, hasError, rejectCount, resolveCount } = useAsyncHandler(onInputAsync, { capture: (e) => { e.preventDefault(); return e.currentTarget.value; }, debounce: debounce == 0 ? undefined : debounce });
        return (e$1("div", { className: "demo", children: [e$1("label", { children: ["Demo text: ", e$1("input", { value: hasCapture ? currentCapture : text, disabled: pending && disableConsecutive, onInput: syncHandler })] }), e$1("hr", {}), e$1("label", { children: ["Sleep for: ", e$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), e$1("label", { children: ["Throw an error ", e$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), e$1("label", { children: ["Disabled while pending ", e$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), e$1("label", { children: ["Debounce: ", e$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), e$1("table", { children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Field" }), e$1("th", { children: "Value" })] }) }), e$1("tbody", { children: [e$1("tr", { children: [e$1("td", { children: "callCount" }), e$1("td", { children: callCount })] }), e$1("tr", { children: [e$1("td", { children: "settleCount" }), e$1("td", { children: settleCount })] }), e$1("tr", { children: [e$1("td", { children: "resolveCount" }), e$1("td", { children: resolveCount })] }), e$1("tr", { children: [e$1("td", { children: "rejectCount" }), e$1("td", { children: rejectCount })] }), e$1("tr", { children: [e$1("td", { children: "hasError" }), e$1("td", { children: hasError.toString() })] }), e$1("tr", { children: [e$1("td", { children: "currentCapture" }), e$1("td", { children: currentCapture })] }), e$1("tr", { children: [e$1("td", { children: "\"Saved\" input" }), e$1("td", { children: text })] })] })] })] }));
    });
    const DemoFocus = g(() => {
        const [lastActiveElement, setLastActiveElement] = useState(null);
        const [activeElement, setActiveElement] = useState(null);
        const [windowFocused, setWindowFocused] = useState(false);
        const [focused, setFocused] = useState(false);
        const [focusedInner, setFocusedInner] = useState(false);
        const [lastFocused, setLastFocused] = useState(false);
        const [lastFocusedInner, setLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({
            onFocusedChanged: setFocused,
            onFocusedInnerChanged: setFocusedInner,
            onLastFocusedChanged: setLastFocused,
            onLastFocusedInnerChanged: setLastFocusedInner,
            onActiveElementChange: setActiveElement,
            onLastActiveElementChange: setLastActiveElement,
            onWindowFocusedChange: setWindowFocused
        });
        return (e$1("div", { class: "demo", children: [e$1("h2", { children: "useHasFocus" }), e$1("div", { ...useHasFocusProps({ style: { border: "1px solid black" }, tabIndex: 0 }), children: ["Outer ", e$1("div", { tabIndex: 0, style: { border: "1px solid black" }, children: "Inner element" })] }), e$1("div", { children: e$1("ul", { children: [e$1("li", { children: ["Strictly focused: ", focused.toString(), ", ", lastFocused.toString()] }), e$1("li", { children: ["Inner focused: ", focusedInner.toString(), ", ", lastFocusedInner.toString()] }), e$1("li", { children: ["Window focused: ", windowFocused.toString()] }), e$1("li", { children: ["activeElement: ", activeElement?.textContent] }), e$1("li", { children: ["lastActiveElement: ", lastActiveElement?.textContent] })] }) })] }));
    });
    const GridRowContext = B(null);
    const GridCellContext = B(null);
    const DemoUseGrid = g(() => {
        const [, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        const { useHasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner });
        const { useGridNavigationRow, useGridNavigationProps, gridNavigation: { currentColumn } } = useGridNavigation({
            rovingTabIndex: {},
            linearNavigation: {},
            listNavigation: {},
            typeaheadNavigation: {},
            managedChildren: {}
        });
        return (e$1("div", { class: "demo", children: [e$1("div", { children: ["Current column: ", currentColumn] }), e$1("table", { ...{ border: "2" }, style: { whiteSpace: "nowrap" }, children: [e$1("thead", { children: e$1("tr", { children: [e$1("th", { children: "Row is tabbable?" }), e$1("th", { children: "Column 1" }), e$1("th", { children: "Column 2" })] }) }), e$1("tbody", { ...useHasFocusProps(useGridNavigationProps({})), children: e$1(GridRowContext.Provider, { value: useGridNavigationRow, children: Array.from((function* () {
                                    for (let i = 0; i < 10; ++i) {
                                        yield e$1(DemoUseGridRow, { index: i }, i);
                                    }
                                })()) }) })] })] }));
    });
    const DemoUseGridRow = g((({ index }) => {
        useState(() => RandomWords[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useGridRow = q$1(GridRowContext);
        const { useGridNavigationRowProps, useGridNavigationCell, asChildRow: { rovingTabIndex: { tabbable } }, } = useGridRow({
            asChildRow: { managedChild: { index }, listNavigation: { subInfo: {}, text: "" }, rovingTabIndex: { hidden: index == 3 }, gridNavigation: { subInfo: {} } },
            asParentOfCells: { linearNavigation: {}, listNavigation: {}, rovingTabIndex: {}, typeaheadNavigation: {}, managedChildren: {} }
        });
        const props = useGridNavigationRowProps({});
        return (e$1("tr", { ...props, children: e$1(GridCellContext.Provider, { value: useGridNavigationCell, children: Array.from((function* () {
                    for (let i = 0; i < 3; ++i) {
                        yield e$1(DemoUseGridCell, { index: i, row: index, rowIsTabbable: tabbable }, i);
                    }
                })()) }) }));
    }));
    const DemoUseGridCell = (({ index, row, rowIsTabbable }) => {
        if (row >= 6 && row % 2 == 0 && index > 1)
            return null;
        let hiddenText = (row === 3) ? " (row hidden)" : "";
        const useGridCell = q$1(GridCellContext);
        const { useGridNavigationCellProps, rovingTabIndex: { tabbable: cellIsTabbable } } = useGridCell({
            listNavigation: { text: "" },
            managedChild: { index },
            rovingTabIndex: { hidden: false },
            gridNavigation: { subInfo: {} }
        });
        const props = useGridNavigationCellProps({});
        const t = (cellIsTabbable ? "(Tabbable)" : "(Not tabbable)");
        if (index === 0)
            return e$1("td", { ...props, children: rowIsTabbable.toString() });
        else {
            if (row < 6 || row % 2 != 0) {
                if (index === 1)
                    return e$1("td", { ...props, children: ["Grid cell #", index + 1, " ", t, hiddenText] });
                else
                    return e$1("td", { children: e$1("label", { children: [e$1("input", { ...props, type: "checkbox" }), " Test input ", t, hiddenText] }) });
            }
            else {
                if (index === 1)
                    return e$1("td", { ...props, colSpan: 2, children: ["Grid cell #", index + 1, ", span 2 ", t, hiddenText] });
                else
                    return null;
            }
        }
    });
    const Component = () => {
        return e$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [e$1(DemoFocus, {}), e$1("hr", {}), e$1(DemoUseGrid, {}), e$1("hr", {}), e$1(DemoUseTimeout, {}), e$1("hr", {}), e$1(DemoUseInterval, {}), e$1("hr", {}), e$1(DemoUseRovingTabIndex, {}), e$1("hr", {}), e$1(DemoUseFocusTrap, {}), e$1("hr", {}), e$1(DemoUseAsyncHandler1, {}), e$1("hr", {}), e$1(DemoUseAsyncHandler2, {}), e$1("hr", {}), e$1(DemoUseDroppable, {}), e$1("hr", {}), e$1(DemoUseDraggable, {}), e$1("hr", {}), e$1(DemoUseElementSizeAnimation, {}), e$1("hr", {}), e$1("input", {})] });
    };
    requestAnimationFrame(() => {
        P$1(e$1(Component, {}), document.getElementById("root"));
    });

    exports.DemoUseGrid = DemoUseGrid;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcmVuZGVyLmpzIiwiLi4vc3JjL3VzZS1wYXNzaXZlLXN0YXRlLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL25vZGVfbW9kdWxlcy9jbHN4L2Rpc3QvY2xzeC5tLmpzIiwiLi4vc3JjL3VzZS1tZXJnZWQtY2xhc3Nlcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1yZWZzLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLXN0eWxlcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1wcm9wcy50c3giLCIuLi9zcmMvdXNlLXJlZi1lbGVtZW50LnRzeCIsIi4uL3NyYy91c2UtYWN0aXZlLWVsZW1lbnQudHN4IiwiLi4vc3JjL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdC50c3giLCIuLi9zcmMvdXNlLXN0YWJsZS1nZXR0ZXIudHN4IiwiLi4vc3JjL3VzZS1zdGFibGUtY2FsbGJhY2sudHN4IiwiLi4vc3JjL3VzZS1hbmltYXRpb24tZnJhbWUudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2ZyZWVHbG9iYWwuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19yb290LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9ub3cuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL190cmltbWVkRW5kSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVHJpbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2dldFJhd1RhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX29iamVjdFRvU3RyaW5nLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUdldFRhZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNPYmplY3RMaWtlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1N5bWJvbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdG9OdW1iZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2RlYm91bmNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90aHJvdHRsZS5qcyIsIi4uL3NyYy91c2Utc3RhdGUudHN4IiwiLi4vc3JjL3VzZS1hc3luYy50c3giLCIuLi9zcmMvdXNlLWFzeW5jLWhhbmRsZXIudHN4IiwiLi4vc3JjL3VzZS1lZmZlY3QudHN4IiwiLi4vc3JjL3VzZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL3NyYy91c2UtY2hpbGQtbWFuYWdlci50c3giLCIuLi9zcmMvdXNlLWRvY3VtZW50LWNsYXNzLnRzeCIsIi4uL3NyYy91c2UtZHJhZ2dhYmxlLnRzeCIsIi4uL3NyYy91c2UtZHJvcHBhYmxlLnRzeCIsIi4uL3NyYy91c2UtZWxlbWVudC1zaXplLnRzeCIsIi4uL25vZGVfbW9kdWxlcy90YWJiYWJsZS9zcmMvaW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvd2ljZy1pbmVydC9kaXN0L2luZXJ0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2Jsb2NraW5nLWVsZW1lbnRzL3NyYy9ibG9ja2luZy1lbGVtZW50cy50cyIsIi4uL3NyYy91c2UtYmxvY2tpbmctZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWZvY3VzLXRyYXAudHN4IiwiLi4vc3JjL3VzZS1mb3JjZS11cGRhdGUudHN4IiwiLi4vc3JjL3VzZS1oYXMtZm9jdXMudHN4IiwiLi4vc3JjL3VzZS1sb2dpY2FsLWRpcmVjdGlvbi50c3giLCIuLi9zcmMvdXNlLXRpbWVvdXQudHN4IiwiLi4vc3JjL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2Utcm92aW5nLXRhYmluZGV4LnRzeCIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2NvcHlBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VSYW5kb20uanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19zaHVmZmxlU2VsZi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5U2h1ZmZsZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5TWFwLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUaW1lcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcmd1bWVudHMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3N0dWJGYWxzZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNCdWZmZXIuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19pc0luZGV4LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0xlbmd0aC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VJc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVW5hcnkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19ub2RlVXRpbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNUeXBlZEFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlMaWtlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzUHJvdG90eXBlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb3ZlckFyZy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25hdGl2ZUtleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNGdW5jdGlvbi5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheUxpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2tleXMuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3ZhbHVlcy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9zaHVmZmxlLmpzIiwiLi4vc3JjL3VzZS1zb3J0YWJsZS1jaGlsZHJlbi50c3giLCIuLi9zcmMvdXNlLWxpc3QtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLWdyaWQtbmF2aWdhdGlvbi50c3giLCIuLi9zcmMvdXNlLWludGVydmFsLnRzeCIsImRlbW9zL3VzZS1pbnRlcnZhbC50c3giLCJkZW1vcy91c2Utcm92aW5nLXRhYi1pbmRleC50c3giLCJkZW1vcy91c2UtdGltZW91dC50c3giLCJpbmRleC50c3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRU1QVFlfQVJSIH0gZnJvbSBcIi4vY29uc3RhbnRzXCI7XG5cbi8qKlxuICogQXNzaWduIHByb3BlcnRpZXMgZnJvbSBgcHJvcHNgIHRvIGBvYmpgXG4gKiBAdGVtcGxhdGUgTywgUCBUaGUgb2JqIGFuZCBwcm9wcyB0eXBlc1xuICogQHBhcmFtIHtPfSBvYmogVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG9cbiAqIEBwYXJhbSB7UH0gcHJvcHMgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHJldHVybnMge08gJiBQfVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduKG9iaiwgcHJvcHMpIHtcblx0Ly8gQHRzLWlnbm9yZSBXZSBjaGFuZ2UgdGhlIHR5cGUgb2YgYG9iamAgdG8gYmUgYE8gJiBQYFxuXHRmb3IgKGxldCBpIGluIHByb3BzKSBvYmpbaV0gPSBwcm9wc1tpXTtcblx0cmV0dXJuIC8qKiBAdHlwZSB7TyAmIFB9ICovIChvYmopO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIGNoaWxkIG5vZGUgZnJvbSBpdHMgcGFyZW50IGlmIGF0dGFjaGVkLiBUaGlzIGlzIGEgd29ya2Fyb3VuZCBmb3JcbiAqIElFMTEgd2hpY2ggZG9lc24ndCBzdXBwb3J0IGBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUoKWAuIFVzaW5nIHRoaXMgZnVuY3Rpb25cbiAqIGlzIHNtYWxsZXIgdGhhbiBpbmNsdWRpbmcgYSBkZWRpY2F0ZWQgcG9seWZpbGwuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gcmVtb3ZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuXG5leHBvcnQgY29uc3Qgc2xpY2UgPSBFTVBUWV9BUlIuc2xpY2U7XG4iLCJpbXBvcnQgeyBfY2F0Y2hFcnJvciB9IGZyb20gJy4vZGlmZi9jYXRjaC1lcnJvcic7XG5cbi8qKlxuICogVGhlIGBvcHRpb25gIG9iamVjdCBjYW4gcG90ZW50aWFsbHkgY29udGFpbiBjYWxsYmFjayBmdW5jdGlvbnNcbiAqIHRoYXQgYXJlIGNhbGxlZCBkdXJpbmcgdmFyaW91cyBzdGFnZXMgb2Ygb3VyIHJlbmRlcmVyLiBUaGlzIGlzIHRoZVxuICogZm91bmRhdGlvbiBvbiB3aGljaCBhbGwgb3VyIGFkZG9ucyBsaWtlIGBwcmVhY3QvZGVidWdgLCBgcHJlYWN0L2NvbXBhdGAsXG4gKiBhbmQgYHByZWFjdC9ob29rc2AgYXJlIGJhc2VkIG9uLiBTZWUgdGhlIGBPcHRpb25zYCB0eXBlIGluIGBpbnRlcm5hbC5kLnRzYFxuICogZm9yIGEgZnVsbCBsaXN0IG9mIGF2YWlsYWJsZSBvcHRpb24gaG9va3MgKG1vc3QgZWRpdG9ycy9JREVzIGFsbG93IHlvdSB0b1xuICogY3RybCtjbGljayBvciBjbWQrY2xpY2sgb24gbWFjIHRoZSB0eXBlIGRlZmluaXRpb24gYmVsb3cpLlxuICogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk9wdGlvbnN9XG4gKi9cbmNvbnN0IG9wdGlvbnMgPSB7XG5cdF9jYXRjaEVycm9yXG59O1xuXG5leHBvcnQgZGVmYXVsdCBvcHRpb25zO1xuIiwiaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIENyZWF0ZSBhbiB2aXJ0dWFsIG5vZGUgKHVzZWQgZm9yIEpTWClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBjb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbCB8IHVuZGVmaW5lZH0gW3Byb3BzXSBUaGUgcHJvcGVydGllcyBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLicpLkNvbXBvbmVudENoaWxkcmVuPn0gW2NoaWxkcmVuXSBUaGUgY2hpbGRyZW4gb2YgdGhlIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHt9LFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ2tleScpIGtleSA9IHByb3BzW2ldO1xuXHRcdGVsc2UgaWYgKGkgPT0gJ3JlZicpIHJlZiA9IHByb3BzW2ldO1xuXHRcdGVsc2Ugbm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdH1cblxuXHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRub3JtYWxpemVkUHJvcHMuY2hpbGRyZW4gPVxuXHRcdFx0YXJndW1lbnRzLmxlbmd0aCA+IDMgPyBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikgOiBjaGlsZHJlbjtcblx0fVxuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wc1xuXHQvLyBOb3RlOiB0eXBlIG1heSBiZSB1bmRlZmluZWQgaW4gZGV2ZWxvcG1lbnQsIG11c3QgbmV2ZXIgZXJyb3IgaGVyZS5cblx0aWYgKHR5cGVvZiB0eXBlID09ICdmdW5jdGlvbicgJiYgdHlwZS5kZWZhdWx0UHJvcHMgIT0gbnVsbCkge1xuXHRcdGZvciAoaSBpbiB0eXBlLmRlZmF1bHRQcm9wcykge1xuXHRcdFx0aWYgKG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHR5cGUuZGVmYXVsdFByb3BzW2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjcmVhdGVWTm9kZSh0eXBlLCBub3JtYWxpemVkUHJvcHMsIGtleSwgcmVmLCBudWxsKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBWTm9kZSAodXNlZCBpbnRlcm5hbGx5IGJ5IFByZWFjdClcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJ0eXBlXCJdfSB0eXBlIFRoZSBub2RlIG5hbWUgb3IgQ29tcG9uZW50XG4gKiBDb25zdHJ1Y3RvciBmb3IgdGhpcyB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0IHwgc3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0gcHJvcHMgVGhlIHByb3BlcnRpZXMgb2YgdGhpcyB2aXJ0dWFsIG5vZGUuXG4gKiBJZiB0aGlzIHZpcnR1YWwgbm9kZSByZXByZXNlbnRzIGEgdGV4dCBub2RlLCB0aGlzIGlzIHRoZSB0ZXh0IG9mIHRoZSBub2RlIChzdHJpbmcgb3IgbnVtYmVyKS5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyIHwgbnVsbH0ga2V5IFRoZSBrZXkgZm9yIHRoaXMgdmlydHVhbCBub2RlLCB1c2VkIHdoZW5cbiAqIGRpZmZpbmcgaXQgYWdhaW5zdCBpdHMgY2hpbGRyZW5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGVbXCJyZWZcIl19IHJlZiBUaGUgcmVmIHByb3BlcnR5IHRoYXQgd2lsbFxuICogcmVjZWl2ZSBhIHJlZmVyZW5jZSB0byBpdHMgY3JlYXRlZCBjaGlsZFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgcmVmLCBvcmlnaW5hbCkge1xuXHQvLyBWOCBzZWVtcyB0byBiZSBiZXR0ZXIgYXQgZGV0ZWN0aW5nIHR5cGUgc2hhcGVzIGlmIHRoZSBvYmplY3QgaXMgYWxsb2NhdGVkIGZyb20gdGhlIHNhbWUgY2FsbCBzaXRlXG5cdC8vIERvIG5vdCBpbmxpbmUgaW50byBjcmVhdGVFbGVtZW50IGFuZCBjb2VyY2VUb1ZOb2RlIVxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0Ly8gX25leHREb20gbXVzdCBiZSBpbml0aWFsaXplZCB0byB1bmRlZmluZWQgYi9jIGl0IHdpbGwgZXZlbnR1YWxseVxuXHRcdC8vIGJlIHNldCB0byBkb20ubmV4dFNpYmxpbmcgd2hpY2ggY2FuIHJldHVybiBgbnVsbGAgYW5kIGl0IGlzIGltcG9ydGFudFxuXHRcdC8vIHRvIGJlIGFibGUgdG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiBhbiB1bmluaXRpYWxpemVkIF9uZXh0RG9tIGFuZFxuXHRcdC8vIGEgX25leHREb20gdGhhdCBoYXMgYmVlbiBzZXQgdG8gYG51bGxgXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IG9yaWdpbmFsID09IG51bGwgPyArK3Zub2RlSWQgOiBvcmlnaW5hbFxuXHR9O1xuXG5cdC8vIE9ubHkgaW52b2tlIHRoZSB2bm9kZSBob29rIGlmIHRoaXMgd2FzICpub3QqIGEgZGlyZWN0IGNvcHk6XG5cdGlmIChvcmlnaW5hbCA9PSBudWxsICYmIG9wdGlvbnMudm5vZGUgIT0gbnVsbCkgb3B0aW9ucy52bm9kZSh2bm9kZSk7XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVmKCkge1xuXHRyZXR1cm4geyBjdXJyZW50OiBudWxsIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBGcmFnbWVudChwcm9wcykge1xuXHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB0aGUgYXJndW1lbnQgaXMgYSB2YWxpZCBQcmVhY3QgVk5vZGUuXG4gKiBAcGFyYW0geyp9IHZub2RlXG4gKiBAcmV0dXJucyB7dm5vZGUgaXMgaW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBjb25zdCBpc1ZhbGlkRWxlbWVudCA9IHZub2RlID0+XG5cdHZub2RlICE9IG51bGwgJiYgdm5vZGUuY29uc3RydWN0b3IgPT09IHVuZGVmaW5lZDtcbiIsImltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBkaWZmLCBjb21taXRSb290IH0gZnJvbSAnLi9kaWZmL2luZGV4JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuXG4vKipcbiAqIEJhc2UgQ29tcG9uZW50IGNsYXNzLiBQcm92aWRlcyBgc2V0U3RhdGUoKWAgYW5kIGBmb3JjZVVwZGF0ZSgpYCwgd2hpY2hcbiAqIHRyaWdnZXIgcmVuZGVyaW5nXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgVGhlIGluaXRpYWwgY29tcG9uZW50IHByb3BzXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBUaGUgaW5pdGlhbCBjb250ZXh0IGZyb20gcGFyZW50IGNvbXBvbmVudHMnXG4gKiBnZXRDaGlsZENvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCkge1xuXHR0aGlzLnByb3BzID0gcHJvcHM7XG5cdHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG59XG5cbi8qKlxuICogVXBkYXRlIGNvbXBvbmVudCBzdGF0ZSBhbmQgc2NoZWR1bGUgYSByZS1yZW5kZXIuXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fVxuICogQHBhcmFtIHtvYmplY3QgfCAoKHM6IG9iamVjdCwgcDogb2JqZWN0KSA9PiBvYmplY3QpfSB1cGRhdGUgQSBoYXNoIG9mIHN0YXRlXG4gKiBwcm9wZXJ0aWVzIHRvIHVwZGF0ZSB3aXRoIG5ldyB2YWx1ZXMgb3IgYSBmdW5jdGlvbiB0aGF0IGdpdmVuIHRoZSBjdXJyZW50XG4gKiBzdGF0ZSBhbmQgcHJvcHMgcmV0dXJucyBhIG5ldyBwYXJ0aWFsIHN0YXRlXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb25jZSBjb21wb25lbnQgc3RhdGUgaXNcbiAqIHVwZGF0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uKHVwZGF0ZSwgY2FsbGJhY2spIHtcblx0Ly8gb25seSBjbG9uZSBzdGF0ZSB3aGVuIGNvcHlpbmcgdG8gbmV4dFN0YXRlIHRoZSBmaXJzdCB0aW1lLlxuXHRsZXQgcztcblx0aWYgKHRoaXMuX25leHRTdGF0ZSAhPSBudWxsICYmIHRoaXMuX25leHRTdGF0ZSAhPT0gdGhpcy5zdGF0ZSkge1xuXHRcdHMgPSB0aGlzLl9uZXh0U3RhdGU7XG5cdH0gZWxzZSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgdGhpcy5zdGF0ZSk7XG5cdH1cblxuXHRpZiAodHlwZW9mIHVwZGF0ZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0Ly8gU29tZSBsaWJyYXJpZXMgbGlrZSBgaW1tZXJgIG1hcmsgdGhlIGN1cnJlbnQgc3RhdGUgYXMgcmVhZG9ubHksXG5cdFx0Ly8gcHJldmVudGluZyB1cyBmcm9tIG11dGF0aW5nIGl0LCBzbyB3ZSBuZWVkIHRvIGNsb25lIGl0LiBTZWUgIzI3MTZcblx0XHR1cGRhdGUgPSB1cGRhdGUoYXNzaWduKHt9LCBzKSwgdGhpcy5wcm9wcyk7XG5cdH1cblxuXHRpZiAodXBkYXRlKSB7XG5cdFx0YXNzaWduKHMsIHVwZGF0ZSk7XG5cdH1cblxuXHQvLyBTa2lwIHVwZGF0ZSBpZiB1cGRhdGVyIGZ1bmN0aW9uIHJldHVybmVkIG51bGxcblx0aWYgKHVwZGF0ZSA9PSBudWxsKSByZXR1cm47XG5cblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBJbW1lZGlhdGVseSBwZXJmb3JtIGEgc3luY2hyb25vdXMgcmUtcmVuZGVyIG9mIHRoZSBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gQSBmdW5jdGlvbiB0byBiZSBjYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzXG4gKiByZS1yZW5kZXJlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0aWYgKHRoaXMuX3Zub2RlKSB7XG5cdFx0Ly8gU2V0IHJlbmRlciBtb2RlIHNvIHRoYXQgd2UgY2FuIGRpZmZlcmVudGlhdGUgd2hlcmUgdGhlIHJlbmRlciByZXF1ZXN0XG5cdFx0Ly8gaXMgY29taW5nIGZyb20uIFdlIG5lZWQgdGhpcyBiZWNhdXNlIGZvcmNlVXBkYXRlIHNob3VsZCBuZXZlciBjYWxsXG5cdFx0Ly8gc2hvdWxkQ29tcG9uZW50VXBkYXRlXG5cdFx0dGhpcy5fZm9yY2UgPSB0cnVlO1xuXHRcdGlmIChjYWxsYmFjaykgdGhpcy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdGVucXVldWVSZW5kZXIodGhpcyk7XG5cdH1cbn07XG5cbi8qKlxuICogQWNjZXB0cyBgcHJvcHNgIGFuZCBgc3RhdGVgLCBhbmQgcmV0dXJucyBhIG5ldyBWaXJ0dWFsIERPTSB0cmVlIHRvIGJ1aWxkLlxuICogVmlydHVhbCBET00gaXMgZ2VuZXJhbGx5IGNvbnN0cnVjdGVkIHZpYSBbSlNYXShodHRwOi8vamFzb25mb3JtYXQuY29tL3d0Zi1pcy1qc3gpLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzIFByb3BzIChlZzogSlNYIGF0dHJpYnV0ZXMpIHJlY2VpdmVkIGZyb20gcGFyZW50XG4gKiBlbGVtZW50L2NvbXBvbmVudFxuICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIFRoZSBjb21wb25lbnQncyBjdXJyZW50IHN0YXRlXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGV4dCBDb250ZXh0IG9iamVjdCwgYXMgcmV0dXJuZWQgYnkgdGhlIG5lYXJlc3RcbiAqIGFuY2VzdG9yJ3MgYGdldENoaWxkQ29udGV4dCgpYFxuICogQHJldHVybnMge2ltcG9ydCgnLi9pbmRleCcpLkNvbXBvbmVudENoaWxkcmVuIHwgdm9pZH1cbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPSBGcmFnbWVudDtcblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHBhcmFtIHtudW1iZXIgfCBudWxsfSBbY2hpbGRJbmRleF1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvbVNpYmxpbmcodm5vZGUsIGNoaWxkSW5kZXgpIHtcblx0aWYgKGNoaWxkSW5kZXggPT0gbnVsbCkge1xuXHRcdC8vIFVzZSBjaGlsZEluZGV4PT1udWxsIGFzIGEgc2lnbmFsIHRvIHJlc3VtZSB0aGUgc2VhcmNoIGZyb20gdGhlIHZub2RlJ3Mgc2libGluZ1xuXHRcdHJldHVybiB2bm9kZS5fcGFyZW50XG5cdFx0XHQ/IGdldERvbVNpYmxpbmcodm5vZGUuX3BhcmVudCwgdm5vZGUuX3BhcmVudC5fY2hpbGRyZW4uaW5kZXhPZih2bm9kZSkgKyAxKVxuXHRcdFx0OiBudWxsO1xuXHR9XG5cblx0bGV0IHNpYmxpbmc7XG5cdGZvciAoOyBjaGlsZEluZGV4IDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XG5cdFx0c2libGluZyA9IHZub2RlLl9jaGlsZHJlbltjaGlsZEluZGV4XTtcblxuXHRcdGlmIChzaWJsaW5nICE9IG51bGwgJiYgc2libGluZy5fZG9tICE9IG51bGwpIHtcblx0XHRcdC8vIFNpbmNlIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIGtlZXBzIF9kb20gcG9pbnRlciBjb3JyZWN0LFxuXHRcdFx0Ly8gd2UgY2FuIHJlbHkgb24gX2RvbSB0byB0ZWxsIHVzIGlmIHRoaXMgc3VidHJlZSBjb250YWlucyBhXG5cdFx0XHQvLyByZW5kZXJlZCBET00gbm9kZSwgYW5kIHdoYXQgdGhlIGZpcnN0IHJlbmRlcmVkIERPTSBub2RlIGlzXG5cdFx0XHRyZXR1cm4gc2libGluZy5fZG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGdldCBoZXJlLCB3ZSBoYXZlIG5vdCBmb3VuZCBhIERPTSBub2RlIGluIHRoaXMgdm5vZGUncyBjaGlsZHJlbi5cblx0Ly8gV2UgbXVzdCByZXN1bWUgZnJvbSB0aGlzIHZub2RlJ3Mgc2libGluZyAoaW4gaXQncyBwYXJlbnQgX2NoaWxkcmVuIGFycmF5KVxuXHQvLyBPbmx5IGNsaW1iIHVwIGFuZCBzZWFyY2ggdGhlIHBhcmVudCBpZiB3ZSBhcmVuJ3Qgc2VhcmNoaW5nIHRocm91Z2ggYSBET01cblx0Ly8gVk5vZGUgKG1lYW5pbmcgd2UgcmVhY2hlZCB0aGUgRE9NIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdm5vZGUgdGhhdCBiZWdhblxuXHQvLyB0aGUgc2VhcmNoKVxuXHRyZXR1cm4gdHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyA/IGdldERvbVNpYmxpbmcodm5vZGUpIDogbnVsbDtcbn1cblxuLyoqXG4gKiBUcmlnZ2VyIGluLXBsYWNlIHJlLXJlbmRlcmluZyBvZiBhIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjb21wb25lbnQgVGhlIGNvbXBvbmVudCB0byByZXJlbmRlclxuICovXG5mdW5jdGlvbiByZW5kZXJDb21wb25lbnQoY29tcG9uZW50KSB7XG5cdGxldCB2bm9kZSA9IGNvbXBvbmVudC5fdm5vZGUsXG5cdFx0b2xkRG9tID0gdm5vZGUuX2RvbSxcblx0XHRwYXJlbnREb20gPSBjb21wb25lbnQuX3BhcmVudERvbTtcblxuXHRpZiAocGFyZW50RG9tKSB7XG5cdFx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdFx0Y29uc3Qgb2xkVk5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRvbGRWTm9kZS5fb3JpZ2luYWwgPSB2bm9kZS5fb3JpZ2luYWwgKyAxO1xuXG5cdFx0ZGlmZihcblx0XHRcdHBhcmVudERvbSxcblx0XHRcdHZub2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRjb21wb25lbnQuX2dsb2JhbENvbnRleHQsXG5cdFx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nICE9IG51bGwgPyBbb2xkRG9tXSA6IG51bGwsXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSA9PSBudWxsID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBvbGREb20sXG5cdFx0XHR2bm9kZS5faHlkcmF0aW5nXG5cdFx0KTtcblx0XHRjb21taXRSb290KGNvbW1pdFF1ZXVlLCB2bm9kZSk7XG5cblx0XHRpZiAodm5vZGUuX2RvbSAhPSBvbGREb20pIHtcblx0XHRcdHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKTtcblx0XHR9XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSkge1xuXHRpZiAoKHZub2RlID0gdm5vZGUuX3BhcmVudCkgIT0gbnVsbCAmJiB2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHR2bm9kZS5fZG9tID0gdm5vZGUuX2NvbXBvbmVudC5iYXNlID0gbnVsbDtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHZub2RlLl9jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0bGV0IGNoaWxkID0gdm5vZGUuX2NoaWxkcmVuW2ldO1xuXHRcdFx0aWYgKGNoaWxkICE9IG51bGwgJiYgY2hpbGQuX2RvbSAhPSBudWxsKSB7XG5cdFx0XHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBjaGlsZC5fZG9tO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHR9XG59XG5cbi8qKlxuICogVGhlIHJlbmRlciBxdWV1ZVxuICogQHR5cGUge0FycmF5PGltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59XG4gKi9cbmxldCByZXJlbmRlclF1ZXVlID0gW107XG5cbi8qXG4gKiBUaGUgdmFsdWUgb2YgYENvbXBvbmVudC5kZWJvdW5jZWAgbXVzdCBhc3luY2hyb25vdXNseSBpbnZva2UgdGhlIHBhc3NlZCBpbiBjYWxsYmFjay4gSXQgaXNcbiAqIGltcG9ydGFudCB0aGF0IGNvbnRyaWJ1dG9ycyB0byBQcmVhY3QgY2FuIGNvbnNpc3RlbnRseSByZWFzb24gYWJvdXQgd2hhdCBjYWxscyB0byBgc2V0U3RhdGVgLCBldGMuXG4gKiBkbywgYW5kIHdoZW4gdGhlaXIgZWZmZWN0cyB3aWxsIGJlIGFwcGxpZWQuIFNlZSB0aGUgbGlua3MgYmVsb3cgZm9yIHNvbWUgZnVydGhlciByZWFkaW5nIG9uIGRlc2lnbmluZ1xuICogYXN5bmNocm9ub3VzIEFQSXMuXG4gKiAqIFtEZXNpZ25pbmcgQVBJcyBmb3IgQXN5bmNocm9ueV0oaHR0cHM6Ly9ibG9nLml6cy5tZS8yMDEzLzA4L2Rlc2lnbmluZy1hcGlzLWZvci1hc3luY2hyb255KVxuICogKiBbQ2FsbGJhY2tzIHN5bmNocm9ub3VzIGFuZCBhc3luY2hyb25vdXNdKGh0dHBzOi8vYmxvZy5vbWV0ZXIuY29tLzIwMTEvMDcvMjQvY2FsbGJhY2tzLXN5bmNocm9ub3VzLWFuZC1hc3luY2hyb25vdXMvKVxuICovXG5cbmxldCBwcmV2RGVib3VuY2U7XG5cbi8qKlxuICogRW5xdWV1ZSBhIHJlcmVuZGVyIG9mIGEgY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gYyBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlUmVuZGVyKGMpIHtcblx0aWYgKFxuXHRcdCghYy5fZGlydHkgJiZcblx0XHRcdChjLl9kaXJ0eSA9IHRydWUpICYmXG5cdFx0XHRyZXJlbmRlclF1ZXVlLnB1c2goYykgJiZcblx0XHRcdCFwcm9jZXNzLl9yZXJlbmRlckNvdW50KyspIHx8XG5cdFx0cHJldkRlYm91bmNlICE9PSBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nXG5cdCkge1xuXHRcdHByZXZEZWJvdW5jZSA9IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmc7XG5cdFx0KHByZXZEZWJvdW5jZSB8fCBzZXRUaW1lb3V0KShwcm9jZXNzKTtcblx0fVxufVxuXG4vKiogRmx1c2ggdGhlIHJlbmRlciBxdWV1ZSBieSByZXJlbmRlcmluZyBhbGwgcXVldWVkIGNvbXBvbmVudHMgKi9cbmZ1bmN0aW9uIHByb2Nlc3MoKSB7XG5cdGxldCBxdWV1ZTtcblx0d2hpbGUgKChwcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gcmVyZW5kZXJRdWV1ZS5sZW5ndGgpKSB7XG5cdFx0cXVldWUgPSByZXJlbmRlclF1ZXVlLnNvcnQoKGEsIGIpID0+IGEuX3Zub2RlLl9kZXB0aCAtIGIuX3Zub2RlLl9kZXB0aCk7XG5cdFx0cmVyZW5kZXJRdWV1ZSA9IFtdO1xuXHRcdC8vIERvbid0IHVwZGF0ZSBgcmVuZGVyQ291bnRgIHlldC4gS2VlcCBpdHMgdmFsdWUgbm9uLXplcm8gdG8gcHJldmVudCB1bm5lY2Vzc2FyeVxuXHRcdC8vIHByb2Nlc3MoKSBjYWxscyBmcm9tIGdldHRpbmcgc2NoZWR1bGVkIHdoaWxlIGBxdWV1ZWAgaXMgc3RpbGwgYmVpbmcgY29uc3VtZWQuXG5cdFx0cXVldWUuc29tZShjID0+IHtcblx0XHRcdGlmIChjLl9kaXJ0eSkgcmVuZGVyQ29tcG9uZW50KGMpO1xuXHRcdH0pO1xuXHR9XG59XG5wcm9jZXNzLl9yZXJlbmRlckNvdW50ID0gMDtcbiIsImltcG9ydCB7IGVucXVldWVSZW5kZXIgfSBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCBsZXQgaSA9IDA7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb250ZXh0KGRlZmF1bHRWYWx1ZSwgY29udGV4dElkKSB7XG5cdGNvbnRleHRJZCA9ICdfX2NDJyArIGkrKztcblxuXHRjb25zdCBjb250ZXh0ID0ge1xuXHRcdF9pZDogY29udGV4dElkLFxuXHRcdF9kZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdENvbnN1bWVyKHByb3BzLCBjb250ZXh0VmFsdWUpIHtcblx0XHRcdC8vIHJldHVybiBwcm9wcy5jaGlsZHJlbihcblx0XHRcdC8vIFx0Y29udGV4dFtjb250ZXh0SWRdID8gY29udGV4dFtjb250ZXh0SWRdLnByb3BzLnZhbHVlIDogZGVmYXVsdFZhbHVlXG5cdFx0XHQvLyApO1xuXHRcdFx0cmV0dXJuIHByb3BzLmNoaWxkcmVuKGNvbnRleHRWYWx1ZSk7XG5cdFx0fSxcblx0XHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSAqL1xuXHRcdFByb3ZpZGVyKHByb3BzKSB7XG5cdFx0XHRpZiAoIXRoaXMuZ2V0Q2hpbGRDb250ZXh0KSB7XG5cdFx0XHRcdGxldCBzdWJzID0gW107XG5cdFx0XHRcdGxldCBjdHggPSB7fTtcblx0XHRcdFx0Y3R4W2NvbnRleHRJZF0gPSB0aGlzO1xuXG5cdFx0XHRcdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gY3R4O1xuXG5cdFx0XHRcdHRoaXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlID0gZnVuY3Rpb24oX3Byb3BzKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMucHJvcHMudmFsdWUgIT09IF9wcm9wcy52YWx1ZSkge1xuXHRcdFx0XHRcdFx0Ly8gSSB0aGluayB0aGUgZm9yY2VkIHZhbHVlIHByb3BhZ2F0aW9uIGhlcmUgd2FzIG9ubHkgbmVlZGVkIHdoZW4gYG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdgIHdhcyBiZWluZyBieXBhc3NlZDpcblx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvY29tbWl0LzRkMzM5ZmI4MDNiZWEwOWU5ZjE5OGFiZjM4Y2ExYmY4ZWE0Yjc3NzEjZGlmZi01NDY4MmNlMzgwOTM1YTcxN2U0MWI4YmZjNTQ3MzdmNlIzNThcblx0XHRcdFx0XHRcdC8vIEluIHRob3NlIGNhc2VzIHRob3VnaCwgZXZlbiB3aXRoIHRoZSB2YWx1ZSBjb3JyZWN0ZWQsIHdlJ3JlIGRvdWJsZS1yZW5kZXJpbmcgYWxsIG5vZGVzLlxuXHRcdFx0XHRcdFx0Ly8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgdGVsbCBmb2xrcyBub3QgdG8gdXNlIGZvcmNlLXN5bmMgbW9kZS5cblx0XHRcdFx0XHRcdC8vIEN1cnJlbnRseSwgdXNpbmcgYHVzZUNvbnRleHQoKWAgaW4gYSBjbGFzcyBjb21wb25lbnQgd2lsbCBvdmVyd3JpdGUgaXRzIGB0aGlzLmNvbnRleHRgIHZhbHVlLlxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHQgPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblxuXHRcdFx0XHRcdFx0Ly8gc3Vicy5zb21lKGMgPT4ge1xuXHRcdFx0XHRcdFx0Ly8gXHRjLmNvbnRleHRbY29udGV4dElkXSA9IF9wcm9wcy52YWx1ZTtcblx0XHRcdFx0XHRcdC8vIFx0ZW5xdWV1ZVJlbmRlcihjKTtcblx0XHRcdFx0XHRcdC8vIH0pO1xuXHRcdFx0XHRcdFx0c3Vicy5zb21lKGVucXVldWVSZW5kZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblxuXHRcdFx0XHR0aGlzLnN1YiA9IGMgPT4ge1xuXHRcdFx0XHRcdHN1YnMucHVzaChjKTtcblx0XHRcdFx0XHRsZXQgb2xkID0gYy5jb21wb25lbnRXaWxsVW5tb3VudDtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gKCkgPT4ge1xuXHRcdFx0XHRcdFx0c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGMpLCAxKTtcblx0XHRcdFx0XHRcdGlmIChvbGQpIG9sZC5jYWxsKGMpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcblx0XHR9XG5cdH07XG5cblx0Ly8gRGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB3aGVuIGl0XG5cdC8vIGVuY291bnRlcnMgYSBQcm92aWRlci4gVGhpcyBpcyBuZWNlc3NhcnkgdG8gc3VwcG9ydFxuXHQvLyBzZXR0aW5nIGBkaXNwbGF5TmFtZWAgb24gdGhlIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcblx0Ly8gb2Ygb24gdGhlIGNvbXBvbmVudCBpdHNlbGYuIFNlZTpcblx0Ly8gaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL2NvbnRleHQuaHRtbCNjb250ZXh0ZGlzcGxheW5hbWVcblxuXHRyZXR1cm4gKGNvbnRleHQuUHJvdmlkZXIuX2NvbnRleHRSZWYgPSBjb250ZXh0LkNvbnN1bWVyLmNvbnRleHRUeXBlID0gY29udGV4dCk7XG59XG4iLCJleHBvcnQgY29uc3QgRU1QVFlfT0JKID0ge307XG5leHBvcnQgY29uc3QgRU1QVFlfQVJSID0gW107XG5leHBvcnQgY29uc3QgSVNfTk9OX0RJTUVOU0lPTkFMID0gL2FjaXR8ZXgoPzpzfGd8bnxwfCQpfHJwaHxncmlkfG93c3xtbmN8bnR3fGluZVtjaF18em9vfF5vcmR8aXRlcmEvaTtcbiIsImltcG9ydCB7IGRpZmYsIHVubW91bnQsIGFwcGx5UmVmIH0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVWTm9kZSwgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBFTVBUWV9PQkosIEVNUFRZX0FSUiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcblxuLyoqXG4gKiBEaWZmIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB3aG9zZVxuICogY2hpbGRyZW4gYXJlIGJlaW5nIGRpZmZlZFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGRyZW5bXX0gcmVuZGVyUmVzdWx0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gbmV3UGFyZW50Vk5vZGUgVGhlIG5ldyB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3Qgb2xkUGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBvbGRQYXJlbnRWTm9kZSBUaGUgb2xkIHZpcnR1YWxcbiAqIG5vZGUgd2hvc2UgY2hpbGRyZW4gc2hvdWxkIGJlIGRpZmYnZWQgYWdhaW5zdCBuZXdQYXJlbnRWTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IGdsb2JhbENvbnRleHQgVGhlIGN1cnJlbnQgY29udGV4dCBvYmplY3QgLSBtb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIeWRyYXRpbmcgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZkNoaWxkcmVuKFxuXHRwYXJlbnREb20sXG5cdHJlbmRlclJlc3VsdCxcblx0bmV3UGFyZW50Vk5vZGUsXG5cdG9sZFBhcmVudFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IGksIGosIG9sZFZOb2RlLCBjaGlsZFZOb2RlLCBuZXdEb20sIGZpcnN0Q2hpbGREb20sIHJlZnM7XG5cblx0Ly8gVGhpcyBpcyBhIGNvbXByZXNzaW9uIG9mIG9sZFBhcmVudFZOb2RlIT1udWxsICYmIG9sZFBhcmVudFZOb2RlICE9IEVNUFRZX09CSiAmJiBvbGRQYXJlbnRWTm9kZS5fY2hpbGRyZW4gfHwgRU1QVFlfQVJSXG5cdC8vIGFzIEVNUFRZX09CSi5fY2hpbGRyZW4gc2hvdWxkIGJlIGB1bmRlZmluZWRgLlxuXHRsZXQgb2xkQ2hpbGRyZW4gPSAob2xkUGFyZW50Vk5vZGUgJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuKSB8fCBFTVBUWV9BUlI7XG5cblx0bGV0IG9sZENoaWxkcmVuTGVuZ3RoID0gb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXG5cdG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRmb3IgKGkgPSAwOyBpIDwgcmVuZGVyUmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Y2hpbGRWTm9kZSA9IHJlbmRlclJlc3VsdFtpXTtcblxuXHRcdGlmIChjaGlsZFZOb2RlID09IG51bGwgfHwgdHlwZW9mIGNoaWxkVk5vZGUgPT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gbnVsbDtcblx0XHR9XG5cdFx0Ly8gSWYgdGhpcyBuZXdWTm9kZSBpcyBiZWluZyByZXVzZWQgKGUuZy4gPGRpdj57cmV1c2V9e3JldXNlfTwvZGl2PikgaW4gdGhlIHNhbWUgZGlmZixcblx0XHQvLyBvciB3ZSBhcmUgcmVuZGVyaW5nIGEgY29tcG9uZW50IChlLmcuIHNldFN0YXRlKSBjb3B5IHRoZSBvbGRWTm9kZXMgc28gaXQgY2FuIGhhdmVcblx0XHQvLyBpdCdzIG93biBET00gJiBldGMuIHBvaW50ZXJzXG5cdFx0ZWxzZSBpZiAoXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnc3RyaW5nJyB8fFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ251bWJlcicgfHxcblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB2YWxpZC10eXBlb2Zcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdiaWdpbnQnXG5cdFx0KSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGVcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNoaWxkVk5vZGUpKSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdEZyYWdtZW50LFxuXHRcdFx0XHR7IGNoaWxkcmVuOiBjaGlsZFZOb2RlIH0sXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdG51bGxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIGlmIChjaGlsZFZOb2RlLl9kZXB0aCA+IDApIHtcblx0XHRcdC8vIFZOb2RlIGlzIGFscmVhZHkgaW4gdXNlLCBjbG9uZSBpdC4gVGhpcyBjYW4gaGFwcGVuIGluIHRoZSBmb2xsb3dpbmdcblx0XHRcdC8vIHNjZW5hcmlvOlxuXHRcdFx0Ly8gICBjb25zdCByZXVzZSA9IDxkaXYgLz5cblx0XHRcdC8vICAgPGRpdj57cmV1c2V9PHNwYW4gLz57cmV1c2V9PC9kaXY+XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY3JlYXRlVk5vZGUoXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSxcblx0XHRcdFx0Y2hpbGRWTm9kZS5wcm9wcyxcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXksXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdGNoaWxkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaGlsZFZOb2RlID0gbmV3UGFyZW50Vk5vZGUuX2NoaWxkcmVuW2ldID0gY2hpbGRWTm9kZTtcblx0XHR9XG5cblx0XHQvLyBUZXJzZXIgcmVtb3ZlcyB0aGUgYGNvbnRpbnVlYCBoZXJlIGFuZCB3cmFwcyB0aGUgbG9vcCBib2R5XG5cdFx0Ly8gaW4gYSBgaWYgKGNoaWxkVk5vZGUpIHsgLi4uIH0gY29uZGl0aW9uXG5cdFx0aWYgKGNoaWxkVk5vZGUgPT0gbnVsbCkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0Y2hpbGRWTm9kZS5fcGFyZW50ID0gbmV3UGFyZW50Vk5vZGU7XG5cdFx0Y2hpbGRWTm9kZS5fZGVwdGggPSBuZXdQYXJlbnRWTm9kZS5fZGVwdGggKyAxO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UgZmluZCBhIGNvcnJlc3BvbmRpbmcgZWxlbWVudCBpbiBvbGRDaGlsZHJlbi5cblx0XHQvLyBJZiBmb3VuZCwgZGVsZXRlIHRoZSBhcnJheSBpdGVtIGJ5IHNldHRpbmcgdG8gYHVuZGVmaW5lZGAuXG5cdFx0Ly8gV2UgdXNlIGB1bmRlZmluZWRgLCBhcyBgbnVsbGAgaXMgcmVzZXJ2ZWQgZm9yIGVtcHR5IHBsYWNlaG9sZGVyc1xuXHRcdC8vIChob2xlcykuXG5cdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltpXTtcblxuXHRcdGlmIChcblx0XHRcdG9sZFZOb2RlID09PSBudWxsIHx8XG5cdFx0XHQob2xkVk5vZGUgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5rZXkgPT0gb2xkVk5vZGUua2V5ICYmXG5cdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZSlcblx0XHQpIHtcblx0XHRcdG9sZENoaWxkcmVuW2ldID0gdW5kZWZpbmVkO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBFaXRoZXIgb2xkVk5vZGUgPT09IHVuZGVmaW5lZCBvciBvbGRDaGlsZHJlbkxlbmd0aCA+IDAsXG5cdFx0XHQvLyBzbyBhZnRlciB0aGlzIGxvb3Agb2xkVk5vZGUgPT0gbnVsbCBvciBvbGRWTm9kZSBpcyBhIHZhbGlkIHZhbHVlLlxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IG9sZENoaWxkcmVuTGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0b2xkVk5vZGUgPSBvbGRDaGlsZHJlbltqXTtcblx0XHRcdFx0Ly8gSWYgY2hpbGRWTm9kZSBpcyB1bmtleWVkLCB3ZSBvbmx5IG1hdGNoIHNpbWlsYXJseSB1bmtleWVkIG5vZGVzLCBvdGhlcndpc2Ugd2UgbWF0Y2ggYnkga2V5LlxuXHRcdFx0XHQvLyBXZSBhbHdheXMgbWF0Y2ggYnkgdHlwZSAoaW4gZWl0aGVyIGNhc2UpLlxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0b2xkVk5vZGUgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUgPT09IG9sZFZOb2RlLnR5cGVcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW5bal0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0b2xkVk5vZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdG9sZFZOb2RlID0gb2xkVk5vZGUgfHwgRU1QVFlfT0JKO1xuXG5cdFx0Ly8gTW9ycGggdGhlIG9sZCBlbGVtZW50IGludG8gdGhlIG5ldyBvbmUsIGJ1dCBkb24ndCBhcHBlbmQgaXQgdG8gdGhlIGRvbSB5ZXRcblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdGlzU3ZnLFxuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdG9sZERvbSxcblx0XHRcdGlzSHlkcmF0aW5nXG5cdFx0KTtcblxuXHRcdG5ld0RvbSA9IGNoaWxkVk5vZGUuX2RvbTtcblxuXHRcdGlmICgoaiA9IGNoaWxkVk5vZGUucmVmKSAmJiBvbGRWTm9kZS5yZWYgIT0gaikge1xuXHRcdFx0aWYgKCFyZWZzKSByZWZzID0gW107XG5cdFx0XHRpZiAob2xkVk5vZGUucmVmKSByZWZzLnB1c2gob2xkVk5vZGUucmVmLCBudWxsLCBjaGlsZFZOb2RlKTtcblx0XHRcdHJlZnMucHVzaChqLCBjaGlsZFZOb2RlLl9jb21wb25lbnQgfHwgbmV3RG9tLCBjaGlsZFZOb2RlKTtcblx0XHR9XG5cblx0XHRpZiAobmV3RG9tICE9IG51bGwpIHtcblx0XHRcdGlmIChmaXJzdENoaWxkRG9tID09IG51bGwpIHtcblx0XHRcdFx0Zmlyc3RDaGlsZERvbSA9IG5ld0RvbTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgY2hpbGRWTm9kZS50eXBlID09ICdmdW5jdGlvbicgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS5fY2hpbGRyZW4gPT09IG9sZFZOb2RlLl9jaGlsZHJlblxuXHRcdFx0KSB7XG5cdFx0XHRcdGNoaWxkVk5vZGUuX25leHREb20gPSBvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4oXG5cdFx0XHRcdFx0Y2hpbGRWTm9kZSxcblx0XHRcdFx0XHRvbGREb20sXG5cdFx0XHRcdFx0cGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGREb20gPSBwbGFjZUNoaWxkKFxuXHRcdFx0XHRcdHBhcmVudERvbSxcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZFZOb2RlLFxuXHRcdFx0XHRcdG9sZENoaWxkcmVuLFxuXHRcdFx0XHRcdG5ld0RvbSxcblx0XHRcdFx0XHRvbGREb21cblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHR5cGVvZiBuZXdQYXJlbnRWTm9kZS50eXBlID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Ly8gQmVjYXVzZSB0aGUgbmV3UGFyZW50Vk5vZGUgaXMgRnJhZ21lbnQtbGlrZSwgd2UgbmVlZCB0byBzZXQgaXQnc1xuXHRcdFx0XHQvLyBfbmV4dERvbSBwcm9wZXJ0eSB0byB0aGUgbmV4dFNpYmxpbmcgb2YgaXRzIGxhc3QgY2hpbGQgRE9NIG5vZGUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIGBvbGREb21gIGNvbnRhaW5zIHRoZSBjb3JyZWN0IHZhbHVlIGhlcmUgYmVjYXVzZSBpZiB0aGUgbGFzdCBjaGlsZFxuXHRcdFx0XHQvLyBpcyBhIEZyYWdtZW50LWxpa2UsIHRoZW4gb2xkRG9tIGhhcyBhbHJlYWR5IGJlZW4gc2V0IHRvIHRoYXQgY2hpbGQncyBfbmV4dERvbS5cblx0XHRcdFx0Ly8gSWYgdGhlIGxhc3QgY2hpbGQgaXMgYSBET00gVk5vZGUsIHRoZW4gb2xkRG9tIHdpbGwgYmUgc2V0IHRvIHRoYXQgRE9NXG5cdFx0XHRcdC8vIG5vZGUncyBuZXh0U2libGluZy5cblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBvbGREb207XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG9sZERvbSAmJlxuXHRcdFx0b2xkVk5vZGUuX2RvbSA9PSBvbGREb20gJiZcblx0XHRcdG9sZERvbS5wYXJlbnROb2RlICE9IHBhcmVudERvbVxuXHRcdCkge1xuXHRcdFx0Ly8gVGhlIGFib3ZlIGNvbmRpdGlvbiBpcyB0byBoYW5kbGUgbnVsbCBwbGFjZWhvbGRlcnMuIFNlZSB0ZXN0IGluIHBsYWNlaG9sZGVyLnRlc3QuanM6XG5cdFx0XHQvLyBgZWZmaWNpZW50bHkgcmVwbGFjZSBudWxsIHBsYWNlaG9sZGVycyBpbiBwYXJlbnQgcmVyZW5kZXJzYFxuXHRcdFx0b2xkRG9tID0gZ2V0RG9tU2libGluZyhvbGRWTm9kZSk7XG5cdFx0fVxuXHR9XG5cblx0bmV3UGFyZW50Vk5vZGUuX2RvbSA9IGZpcnN0Q2hpbGREb207XG5cblx0Ly8gUmVtb3ZlIHJlbWFpbmluZyBvbGRDaGlsZHJlbiBpZiB0aGVyZSBhcmUgYW55LlxuXHRmb3IgKGkgPSBvbGRDaGlsZHJlbkxlbmd0aDsgaS0tOyApIHtcblx0XHRpZiAob2xkQ2hpbGRyZW5baV0gIT0gbnVsbCkge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHR0eXBlb2YgbmV3UGFyZW50Vk5vZGUudHlwZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0XHRcdG9sZENoaWxkcmVuW2ldLl9kb20gIT0gbnVsbCAmJlxuXHRcdFx0XHRvbGRDaGlsZHJlbltpXS5fZG9tID09IG5ld1BhcmVudFZOb2RlLl9uZXh0RG9tXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gSWYgdGhlIG5ld1BhcmVudFZOb2RlLl9fbmV4dERvbSBwb2ludHMgdG8gYSBkb20gbm9kZSB0aGF0IGlzIGFib3V0IHRvXG5cdFx0XHRcdC8vIGJlIHVubW91bnRlZCwgdGhlbiBnZXQgdGhlIG5leHQgc2libGluZyBvZiB0aGF0IHZub2RlIGFuZCBzZXRcblx0XHRcdFx0Ly8gX25leHREb20gdG8gaXRcblx0XHRcdFx0bmV3UGFyZW50Vk5vZGUuX25leHREb20gPSBnZXREb21TaWJsaW5nKG9sZFBhcmVudFZOb2RlLCBpICsgMSk7XG5cdFx0XHR9XG5cblx0XHRcdHVubW91bnQob2xkQ2hpbGRyZW5baV0sIG9sZENoaWxkcmVuW2ldKTtcblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgcmVmcyBvbmx5IGFmdGVyIHVubW91bnRcblx0aWYgKHJlZnMpIHtcblx0XHRmb3IgKGkgPSAwOyBpIDwgcmVmcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0YXBwbHlSZWYocmVmc1tpXSwgcmVmc1srK2ldLCByZWZzWysraV0pO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiByZW9yZGVyQ2hpbGRyZW4oY2hpbGRWTm9kZSwgb2xkRG9tLCBwYXJlbnREb20pIHtcblx0Ly8gTm90ZTogVk5vZGVzIGluIG5lc3RlZCBzdXNwZW5kZWQgdHJlZXMgbWF5IGJlIG1pc3NpbmcgX2NoaWxkcmVuLlxuXHRsZXQgYyA9IGNoaWxkVk5vZGUuX2NoaWxkcmVuO1xuXHRsZXQgdG1wID0gMDtcblx0Zm9yICg7IGMgJiYgdG1wIDwgYy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0bGV0IHZub2RlID0gY1t0bXBdO1xuXHRcdGlmICh2bm9kZSkge1xuXHRcdFx0Ly8gV2UgdHlwaWNhbGx5IGVudGVyIHRoaXMgY29kZSBwYXRoIG9uIHNDVSBiYWlsb3V0LCB3aGVyZSB3ZSBjb3B5XG5cdFx0XHQvLyBvbGRWTm9kZS5fY2hpbGRyZW4gdG8gbmV3Vk5vZGUuX2NoaWxkcmVuLiBJZiB0aGF0IGlzIHRoZSBjYXNlLCB3ZSBuZWVkXG5cdFx0XHQvLyB0byB1cGRhdGUgdGhlIG9sZCBjaGlsZHJlbidzIF9wYXJlbnQgcG9pbnRlciB0byBwb2ludCB0byB0aGUgbmV3Vk5vZGVcblx0XHRcdC8vIChjaGlsZFZOb2RlIGhlcmUpLlxuXHRcdFx0dm5vZGUuX3BhcmVudCA9IGNoaWxkVk5vZGU7XG5cblx0XHRcdGlmICh0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbih2bm9kZSwgb2xkRG9tLCBwYXJlbnREb20pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2xkRG9tID0gcGxhY2VDaGlsZChcblx0XHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdFx0dm5vZGUsXG5cdFx0XHRcdFx0dm5vZGUsXG5cdFx0XHRcdFx0Yyxcblx0XHRcdFx0XHR2bm9kZS5fZG9tLFxuXHRcdFx0XHRcdG9sZERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG5cbi8qKlxuICogRmxhdHRlbiBhbmQgbG9vcCB0aHJvdWdoIHRoZSBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW59IGNoaWxkcmVuIFRoZSB1bmZsYXR0ZW5lZFxuICogY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGVbXX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ2hpbGRBcnJheShjaGlsZHJlbiwgb3V0KSB7XG5cdG91dCA9IG91dCB8fCBbXTtcblx0aWYgKGNoaWxkcmVuID09IG51bGwgfHwgdHlwZW9mIGNoaWxkcmVuID09ICdib29sZWFuJykge1xuXHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG5cdFx0Y2hpbGRyZW4uc29tZShjaGlsZCA9PiB7XG5cdFx0XHR0b0NoaWxkQXJyYXkoY2hpbGQsIG91dCk7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0b3V0LnB1c2goY2hpbGRyZW4pO1xuXHR9XG5cdHJldHVybiBvdXQ7XG59XG5cbmZ1bmN0aW9uIHBsYWNlQ2hpbGQoXG5cdHBhcmVudERvbSxcblx0Y2hpbGRWTm9kZSxcblx0b2xkVk5vZGUsXG5cdG9sZENoaWxkcmVuLFxuXHRuZXdEb20sXG5cdG9sZERvbVxuKSB7XG5cdGxldCBuZXh0RG9tO1xuXHRpZiAoY2hpbGRWTm9kZS5fbmV4dERvbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0Ly8gT25seSBGcmFnbWVudHMgb3IgY29tcG9uZW50cyB0aGF0IHJldHVybiBGcmFnbWVudCBsaWtlIFZOb2RlcyB3aWxsXG5cdFx0Ly8gaGF2ZSBhIG5vbi11bmRlZmluZWQgX25leHREb20uIENvbnRpbnVlIHRoZSBkaWZmIGZyb20gdGhlIHNpYmxpbmdcblx0XHQvLyBvZiBsYXN0IERPTSBjaGlsZCBvZiB0aGlzIGNoaWxkIFZOb2RlXG5cdFx0bmV4dERvbSA9IGNoaWxkVk5vZGUuX25leHREb207XG5cblx0XHQvLyBFYWdlcmx5IGNsZWFudXAgX25leHREb20uIFdlIGRvbid0IG5lZWQgdG8gcGVyc2lzdCB0aGUgdmFsdWUgYmVjYXVzZVxuXHRcdC8vIGl0IGlzIG9ubHkgdXNlZCBieSBgZGlmZkNoaWxkcmVuYCB0byBkZXRlcm1pbmUgd2hlcmUgdG8gcmVzdW1lIHRoZSBkaWZmIGFmdGVyXG5cdFx0Ly8gZGlmZmluZyBDb21wb25lbnRzIGFuZCBGcmFnbWVudHMuIE9uY2Ugd2Ugc3RvcmUgaXQgdGhlIG5leHRET00gbG9jYWwgdmFyLCB3ZVxuXHRcdC8vIGNhbiBjbGVhbiB1cCB0aGUgcHJvcGVydHlcblx0XHRjaGlsZFZOb2RlLl9uZXh0RG9tID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKFxuXHRcdG9sZFZOb2RlID09IG51bGwgfHxcblx0XHRuZXdEb20gIT0gb2xkRG9tIHx8XG5cdFx0bmV3RG9tLnBhcmVudE5vZGUgPT0gbnVsbFxuXHQpIHtcblx0XHRvdXRlcjogaWYgKG9sZERvbSA9PSBudWxsIHx8IG9sZERvbS5wYXJlbnROb2RlICE9PSBwYXJlbnREb20pIHtcblx0XHRcdHBhcmVudERvbS5hcHBlbmRDaGlsZChuZXdEb20pO1xuXHRcdFx0bmV4dERvbSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGBqPG9sZENoaWxkcmVuTGVuZ3RoOyBqKz0yYCBpcyBhbiBhbHRlcm5hdGl2ZSB0byBgaisrPG9sZENoaWxkcmVuTGVuZ3RoLzJgXG5cdFx0XHRmb3IgKFxuXHRcdFx0XHRsZXQgc2liRG9tID0gb2xkRG9tLCBqID0gMDtcblx0XHRcdFx0KHNpYkRvbSA9IHNpYkRvbS5uZXh0U2libGluZykgJiYgaiA8IG9sZENoaWxkcmVuLmxlbmd0aDtcblx0XHRcdFx0aiArPSAyXG5cdFx0XHQpIHtcblx0XHRcdFx0aWYgKHNpYkRvbSA9PSBuZXdEb20pIHtcblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyZW50RG9tLmluc2VydEJlZm9yZShuZXdEb20sIG9sZERvbSk7XG5cdFx0XHRuZXh0RG9tID0gb2xkRG9tO1xuXHRcdH1cblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgcHJlLWNhbGN1bGF0ZWQgdGhlIG5leHRET00gbm9kZSwgdXNlIGl0LiBFbHNlIGNhbGN1bGF0ZSBpdCBub3dcblx0Ly8gU3RyaWN0bHkgY2hlY2sgZm9yIGB1bmRlZmluZWRgIGhlcmUgY3V6IGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlIG9mIGBuZXh0RG9tYC5cblx0Ly8gU2VlIG1vcmUgZGV0YWlsIGluIGNyZWF0ZS1lbGVtZW50LmpzOmNyZWF0ZVZOb2RlXG5cdGlmIChuZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHRvbGREb20gPSBuZXh0RG9tO1xuXHR9IGVsc2Uge1xuXHRcdG9sZERvbSA9IG5ld0RvbS5uZXh0U2libGluZztcblx0fVxuXG5cdHJldHVybiBvbGREb207XG59XG4iLCJpbXBvcnQgeyBJU19OT05fRElNRU5TSU9OQUwgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi4vb3B0aW9ucyc7XG5cbi8qKlxuICogRGlmZiB0aGUgb2xkIGFuZCBuZXcgcHJvcGVydGllcyBvZiBhIFZOb2RlIGFuZCBhcHBseSBjaGFuZ2VzIHRvIHRoZSBET00gbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gZG9tIFRoZSBET00gbm9kZSB0byBhcHBseVxuICogY2hhbmdlcyB0b1xuICogQHBhcmFtIHtvYmplY3R9IG5ld1Byb3BzIFRoZSBuZXcgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBvbGRQcm9wcyBUaGUgb2xkIHByb3BzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgbm9kZSBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtib29sZWFufSBoeWRyYXRlIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb24gbW9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGlmZlByb3BzKGRvbSwgbmV3UHJvcHMsIG9sZFByb3BzLCBpc1N2ZywgaHlkcmF0ZSkge1xuXHRsZXQgaTtcblxuXHRmb3IgKGkgaW4gb2xkUHJvcHMpIHtcblx0XHRpZiAoaSAhPT0gJ2NoaWxkcmVuJyAmJiBpICE9PSAna2V5JyAmJiAhKGkgaW4gbmV3UHJvcHMpKSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG51bGwsIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG5cblx0Zm9yIChpIGluIG5ld1Byb3BzKSB7XG5cdFx0aWYgKFxuXHRcdFx0KCFoeWRyYXRlIHx8IHR5cGVvZiBuZXdQcm9wc1tpXSA9PSAnZnVuY3Rpb24nKSAmJlxuXHRcdFx0aSAhPT0gJ2NoaWxkcmVuJyAmJlxuXHRcdFx0aSAhPT0gJ2tleScgJiZcblx0XHRcdGkgIT09ICd2YWx1ZScgJiZcblx0XHRcdGkgIT09ICdjaGVja2VkJyAmJlxuXHRcdFx0b2xkUHJvcHNbaV0gIT09IG5ld1Byb3BzW2ldXG5cdFx0KSB7XG5cdFx0XHRzZXRQcm9wZXJ0eShkb20sIGksIG5ld1Byb3BzW2ldLCBvbGRQcm9wc1tpXSwgaXNTdmcpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRTdHlsZShzdHlsZSwga2V5LCB2YWx1ZSkge1xuXHRpZiAoa2V5WzBdID09PSAnLScpIHtcblx0XHRzdHlsZS5zZXRQcm9wZXJ0eShrZXksIHZhbHVlKTtcblx0fSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3R5bGVba2V5XSA9ICcnO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJyB8fCBJU19OT05fRElNRU5TSU9OQUwudGVzdChrZXkpKSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlO1xuXHR9IGVsc2Uge1xuXHRcdHN0eWxlW2tleV0gPSB2YWx1ZSArICdweCc7XG5cdH1cbn1cblxuLyoqXG4gKiBTZXQgYSBwcm9wZXJ0eSB2YWx1ZSBvbiBhIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIG1vZGlmeVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0IHRoZSBwcm9wZXJ0eSB0b1xuICogQHBhcmFtIHsqfSBvbGRWYWx1ZSBUaGUgb2xkIHZhbHVlIHRoZSBwcm9wZXJ0eSBoYWRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBET00gbm9kZSBpcyBhbiBTVkcgbm9kZSBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5KGRvbSwgbmFtZSwgdmFsdWUsIG9sZFZhbHVlLCBpc1N2Zykge1xuXHRsZXQgdXNlQ2FwdHVyZTtcblxuXHRvOiBpZiAobmFtZSA9PT0gJ3N0eWxlJykge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdGRvbS5zdHlsZS5jc3NUZXh0ID0gdmFsdWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0eXBlb2Ygb2xkVmFsdWUgPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRWYWx1ZSA9ICcnO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAob2xkVmFsdWUpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIG9sZFZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCEodmFsdWUgJiYgbmFtZSBpbiB2YWx1ZSkpIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKGRvbS5zdHlsZSwgbmFtZSwgJycpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAodmFsdWUpIHtcblx0XHRcdFx0Zm9yIChuYW1lIGluIHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKCFvbGRWYWx1ZSB8fCB2YWx1ZVtuYW1lXSAhPT0gb2xkVmFsdWVbbmFtZV0pIHtcblx0XHRcdFx0XHRcdHNldFN0eWxlKGRvbS5zdHlsZSwgbmFtZSwgdmFsdWVbbmFtZV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHQvLyBCZW5jaG1hcmsgZm9yIGNvbXBhcmlzb246IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNTc0Yzk1NGJkYjk2NWI5YTAwOTY1YWM2XG5cdGVsc2UgaWYgKG5hbWVbMF0gPT09ICdvJyAmJiBuYW1lWzFdID09PSAnbicpIHtcblx0XHR1c2VDYXB0dXJlID0gbmFtZSAhPT0gKG5hbWUgPSBuYW1lLnJlcGxhY2UoL0NhcHR1cmUkLywgJycpKTtcblxuXHRcdC8vIEluZmVyIGNvcnJlY3QgY2FzaW5nIGZvciBET00gYnVpbHQtaW4gZXZlbnRzOlxuXHRcdGlmIChuYW1lLnRvTG93ZXJDYXNlKCkgaW4gZG9tKSBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDIpO1xuXHRcdGVsc2UgbmFtZSA9IG5hbWUuc2xpY2UoMik7XG5cblx0XHRpZiAoIWRvbS5fbGlzdGVuZXJzKSBkb20uX2xpc3RlbmVycyA9IHt9O1xuXHRcdGRvbS5fbGlzdGVuZXJzW25hbWUgKyB1c2VDYXB0dXJlXSA9IHZhbHVlO1xuXG5cdFx0aWYgKHZhbHVlKSB7XG5cdFx0XHRpZiAoIW9sZFZhbHVlKSB7XG5cdFx0XHRcdGNvbnN0IGhhbmRsZXIgPSB1c2VDYXB0dXJlID8gZXZlbnRQcm94eUNhcHR1cmUgOiBldmVudFByb3h5O1xuXHRcdFx0XHRkb20uYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRkb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyLCB1c2VDYXB0dXJlKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAobmFtZSAhPT0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJykge1xuXHRcdGlmIChpc1N2Zykge1xuXHRcdFx0Ly8gTm9ybWFsaXplIGluY29ycmVjdCBwcm9wIHVzYWdlIGZvciBTVkc6XG5cdFx0XHQvLyAtIHhsaW5rOmhyZWYgLyB4bGlua0hyZWYgLS0+IGhyZWYgKHhsaW5rOmhyZWYgd2FzIHJlbW92ZWQgZnJvbSBTVkcgYW5kIGlzbid0IG5lZWRlZClcblx0XHRcdC8vIC0gY2xhc3NOYW1lIC0tPiBjbGFzc1xuXHRcdFx0bmFtZSA9IG5hbWUucmVwbGFjZSgveGxpbmsoSHw6aCkvLCAnaCcpLnJlcGxhY2UoL3NOYW1lJC8sICdzJyk7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdG5hbWUgIT09ICdocmVmJyAmJlxuXHRcdFx0bmFtZSAhPT0gJ2xpc3QnICYmXG5cdFx0XHRuYW1lICE9PSAnZm9ybScgJiZcblx0XHRcdC8vIERlZmF1bHQgdmFsdWUgaW4gYnJvd3NlcnMgaXMgYC0xYCBhbmQgYW4gZW1wdHkgc3RyaW5nIGlzXG5cdFx0XHQvLyBjYXN0IHRvIGAwYCBpbnN0ZWFkXG5cdFx0XHRuYW1lICE9PSAndGFiSW5kZXgnICYmXG5cdFx0XHRuYW1lICE9PSAnZG93bmxvYWQnICYmXG5cdFx0XHRuYW1lIGluIGRvbVxuXHRcdCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ZG9tW25hbWVdID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG5cdFx0XHRcdC8vIGxhYmVsbGVkIGJyZWFrIGlzIDFiIHNtYWxsZXIgaGVyZSB0aGFuIGEgcmV0dXJuIHN0YXRlbWVudCAoc29ycnkpXG5cdFx0XHRcdGJyZWFrIG87XG5cdFx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdH1cblxuXHRcdC8vIEFSSUEtYXR0cmlidXRlcyBoYXZlIGEgZGlmZmVyZW50IG5vdGlvbiBvZiBib29sZWFuIHZhbHVlcy5cblx0XHQvLyBUaGUgdmFsdWUgYGZhbHNlYCBpcyBkaWZmZXJlbnQgZnJvbSB0aGUgYXR0cmlidXRlIG5vdFxuXHRcdC8vIGV4aXN0aW5nIG9uIHRoZSBET00sIHNvIHdlIGNhbid0IHJlbW92ZSBpdC4gRm9yIG5vbi1ib29sZWFuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIHdlIGNvdWxkIHRyZWF0IGZhbHNlIGFzIGEgcmVtb3ZhbCwgYnV0IHRoZVxuXHRcdC8vIGFtb3VudCBvZiBleGNlcHRpb25zIHdvdWxkIGNvc3QgdXMgdG9vIG1hbnkgYnl0ZXMuIE9uIHRvcCBvZlxuXHRcdC8vIHRoYXQgb3RoZXIgVkRPTSBmcmFtZXdvcmtzIGFsc28gYWx3YXlzIHN0cmluZ2lmeSBgZmFsc2VgLlxuXG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Ly8gbmV2ZXIgc2VyaWFsaXplIGZ1bmN0aW9ucyBhcyBhdHRyaWJ1dGUgdmFsdWVzXG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHZhbHVlICE9IG51bGwgJiZcblx0XHRcdCh2YWx1ZSAhPT0gZmFsc2UgfHwgKG5hbWVbMF0gPT09ICdhJyAmJiBuYW1lWzFdID09PSAncicpKVxuXHRcdCkge1xuXHRcdFx0ZG9tLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG5cdFx0fVxuXHR9XG59XG5cbi8qKlxuICogUHJveHkgYW4gZXZlbnQgdG8gaG9va2VkIGV2ZW50IGhhbmRsZXJzXG4gKiBAcGFyYW0ge0V2ZW50fSBlIFRoZSBldmVudCBvYmplY3QgZnJvbSB0aGUgYnJvd3NlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXZlbnRQcm94eShlKSB7XG5cdHRoaXMuX2xpc3RlbmVyc1tlLnR5cGUgKyBmYWxzZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cblxuZnVuY3Rpb24gZXZlbnRQcm94eUNhcHR1cmUoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgdHJ1ZV0ob3B0aW9ucy5ldmVudCA/IG9wdGlvbnMuZXZlbnQoZSkgOiBlKTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDb21wb25lbnQsIGdldERvbVNpYmxpbmcgfSBmcm9tICcuLi9jb21wb25lbnQnO1xuaW1wb3J0IHsgRnJhZ21lbnQgfSBmcm9tICcuLi9jcmVhdGUtZWxlbWVudCc7XG5pbXBvcnQgeyBkaWZmQ2hpbGRyZW4gfSBmcm9tICcuL2NoaWxkcmVuJztcbmltcG9ydCB7IGRpZmZQcm9wcywgc2V0UHJvcGVydHkgfSBmcm9tICcuL3Byb3BzJztcbmltcG9ydCB7IGFzc2lnbiwgcmVtb3ZlTm9kZSwgc2xpY2UgfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4uL29wdGlvbnMnO1xuXG4vKipcbiAqIERpZmYgdHdvIHZpcnR1YWwgbm9kZXMgYW5kIGFwcGx5IHByb3BlciBjaGFuZ2VzIHRvIHRoZSBET01cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgcGFyZW50IG9mIHRoZSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1ZOb2RlIFRoZSBuZXcgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkVk5vZGUgVGhlIG9sZCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0LiBNb2RpZmllZCBieSBnZXRDaGlsZENvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBlbGVtZW50IGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50Pn0gZXhjZXNzRG9tQ2hpbGRyZW5cbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudD59IGNvbW1pdFF1ZXVlIExpc3Qgb2YgY29tcG9uZW50c1xuICogd2hpY2ggaGF2ZSBjYWxsYmFja3MgdG8gaW52b2tlIGluIGNvbW1pdFJvb3RcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IG9sZERvbSBUaGUgY3VycmVudCBhdHRhY2hlZCBET01cbiAqIGVsZW1lbnQgYW55IG5ldyBkb20gZWxlbWVudHMgc2hvdWxkIGJlIHBsYWNlZCBhcm91bmQuIExpa2VseSBgbnVsbGAgb24gZmlyc3RcbiAqIHJlbmRlciAoZXhjZXB0IHdoZW4gaHlkcmF0aW5nKS4gQ2FuIGJlIGEgc2libGluZyBET00gZWxlbWVudCB3aGVuIGRpZmZpbmdcbiAqIEZyYWdtZW50cyB0aGF0IGhhdmUgc2libGluZ3MuIEluIG1vc3QgY2FzZXMsIGl0IHN0YXJ0cyBvdXQgYXMgYG9sZENoaWxkcmVuWzBdLl9kb21gLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNIeWRyYXRpbmddIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmYoXG5cdHBhcmVudERvbSxcblx0bmV3Vk5vZGUsXG5cdG9sZFZOb2RlLFxuXHRnbG9iYWxDb250ZXh0LFxuXHRpc1N2Zyxcblx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdGNvbW1pdFF1ZXVlLFxuXHRvbGREb20sXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IHRtcCxcblx0XHRuZXdUeXBlID0gbmV3Vk5vZGUudHlwZTtcblxuXHQvLyBXaGVuIHBhc3NpbmcgdGhyb3VnaCBjcmVhdGVFbGVtZW50IGl0IGFzc2lnbnMgdGhlIG9iamVjdFxuXHQvLyBjb25zdHJ1Y3RvciBhcyB1bmRlZmluZWQuIFRoaXMgdG8gcHJldmVudCBKU09OLWluamVjdGlvbi5cblx0aWYgKG5ld1ZOb2RlLmNvbnN0cnVjdG9yICE9PSB1bmRlZmluZWQpIHJldHVybiBudWxsO1xuXG5cdC8vIElmIHRoZSBwcmV2aW91cyBkaWZmIGJhaWxlZCBvdXQsIHJlc3VtZSBjcmVhdGluZy9oeWRyYXRpbmcuXG5cdGlmIChvbGRWTm9kZS5faHlkcmF0aW5nICE9IG51bGwpIHtcblx0XHRpc0h5ZHJhdGluZyA9IG9sZFZOb2RlLl9oeWRyYXRpbmc7XG5cdFx0b2xkRG9tID0gbmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0Ly8gaWYgd2UgcmVzdW1lLCB3ZSB3YW50IHRoZSB0cmVlIHRvIGJlIFwidW5sb2NrZWRcIlxuXHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSBudWxsO1xuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gW29sZERvbV07XG5cdH1cblxuXHRpZiAoKHRtcCA9IG9wdGlvbnMuX2RpZmYpKSB0bXAobmV3Vk5vZGUpO1xuXG5cdHRyeSB7XG5cdFx0b3V0ZXI6IGlmICh0eXBlb2YgbmV3VHlwZSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRsZXQgYywgaXNOZXcsIG9sZFByb3BzLCBvbGRTdGF0ZSwgc25hcHNob3QsIGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbjtcblx0XHRcdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXG5cdFx0XHQvLyBOZWNlc3NhcnkgZm9yIGNyZWF0ZUNvbnRleHQgYXBpLiBTZXR0aW5nIHRoaXMgcHJvcGVydHkgd2lsbCBwYXNzXG5cdFx0XHQvLyB0aGUgY29udGV4dCB2YWx1ZSBhcyBgdGhpcy5jb250ZXh0YCBqdXN0IGZvciB0aGlzIGNvbXBvbmVudC5cblx0XHRcdHRtcCA9IG5ld1R5cGUuY29udGV4dFR5cGU7XG5cdFx0XHRsZXQgcHJvdmlkZXIgPSB0bXAgJiYgZ2xvYmFsQ29udGV4dFt0bXAuX2lkXTtcblx0XHRcdGxldCBjb21wb25lbnRDb250ZXh0ID0gdG1wXG5cdFx0XHRcdD8gcHJvdmlkZXJcblx0XHRcdFx0XHQ/IHByb3ZpZGVyLnByb3BzLnZhbHVlXG5cdFx0XHRcdFx0OiB0bXAuX2RlZmF1bHRWYWx1ZVxuXHRcdFx0XHQ6IGdsb2JhbENvbnRleHQ7XG5cblx0XHRcdC8vIEdldCBjb21wb25lbnQgYW5kIHNldCBpdCB0byBgY2Bcblx0XHRcdGlmIChvbGRWTm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRcdGMgPSBuZXdWTm9kZS5fY29tcG9uZW50ID0gb2xkVk5vZGUuX2NvbXBvbmVudDtcblx0XHRcdFx0Y2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3BlbmRpbmdFcnJvcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIEluc3RhbnRpYXRlIHRoZSBuZXcgY29tcG9uZW50XG5cdFx0XHRcdGlmICgncHJvdG90eXBlJyBpbiBuZXdUeXBlICYmIG5ld1R5cGUucHJvdG90eXBlLnJlbmRlcikge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVGhlIGNoZWNrIGFib3ZlIHZlcmlmaWVzIHRoYXQgbmV3VHlwZSBpcyBzdXBwb3NlIHRvIGJlIGNvbnN0cnVjdGVkXG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NvbXBvbmVudCA9IGMgPSBuZXcgbmV3VHlwZShuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEB0cy1pZ25vcmUgVHJ1c3QgbWUsIENvbXBvbmVudCBpbXBsZW1lbnRzIHRoZSBpbnRlcmZhY2Ugd2Ugd2FudFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IENvbXBvbmVudChuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdFx0Yy5jb25zdHJ1Y3RvciA9IG5ld1R5cGU7XG5cdFx0XHRcdFx0Yy5yZW5kZXIgPSBkb1JlbmRlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocHJvdmlkZXIpIHByb3ZpZGVyLnN1YihjKTtcblxuXHRcdFx0XHRjLnByb3BzID0gbmV3UHJvcHM7XG5cdFx0XHRcdGlmICghYy5zdGF0ZSkgYy5zdGF0ZSA9IHt9O1xuXHRcdFx0XHRjLmNvbnRleHQgPSBjb21wb25lbnRDb250ZXh0O1xuXHRcdFx0XHRjLl9nbG9iYWxDb250ZXh0ID0gZ2xvYmFsQ29udGV4dDtcblx0XHRcdFx0aXNOZXcgPSBjLl9kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzXG5cdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IG51bGwpIHtcblx0XHRcdFx0Yy5fbmV4dFN0YXRlID0gYy5zdGF0ZTtcblx0XHRcdH1cblx0XHRcdGlmIChuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyAhPSBudWxsKSB7XG5cdFx0XHRcdGlmIChjLl9uZXh0U3RhdGUgPT0gYy5zdGF0ZSkge1xuXHRcdFx0XHRcdGMuX25leHRTdGF0ZSA9IGFzc2lnbih7fSwgYy5fbmV4dFN0YXRlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGFzc2lnbihcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV3UHJvcHMsIGMuX25leHRTdGF0ZSlcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0b2xkUHJvcHMgPSBjLnByb3BzO1xuXHRcdFx0b2xkU3RhdGUgPSBjLnN0YXRlO1xuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkgYy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4uZm9yRWFjaCh2bm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUpIHZub2RlLl9wYXJlbnQgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkgYXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHR9XG5cblx0aWYgKChyID0gdm5vZGUuX2NvbXBvbmVudCkgIT0gbnVsbCkge1xuXHRcdGlmIChyLmNvbXBvbmVudFdpbGxVbm1vdW50KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgcGFyZW50Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHIuYmFzZSA9IHIuX3BhcmVudERvbSA9IG51bGw7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KHJbaV0sIHBhcmVudFZOb2RlLCB0eXBlb2Ygdm5vZGUudHlwZSAhPSAnZnVuY3Rpb24nKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSByZW1vdmVOb2RlKHZub2RlLl9kb20pO1xuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9kb20gPSB2bm9kZS5fbmV4dERvbSA9IHVuZGVmaW5lZDtcbn1cblxuLyoqIFRoZSBgLnJlbmRlcigpYCBtZXRob2QgZm9yIGEgUEZDIGJhY2tpbmcgaW5zdGFuY2UuICovXG5mdW5jdGlvbiBkb1JlbmRlcihwcm9wcywgc3RhdGUsIGNvbnRleHQpIHtcblx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IocHJvcHMsIGNvbnRleHQpO1xufVxuIiwiaW1wb3J0IHsgRU1QVFlfT0JKIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY29tbWl0Um9vdCwgZGlmZiB9IGZyb20gJy4vZGlmZi9pbmRleCc7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCB9IGZyb20gJy4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IHNsaWNlIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBSZW5kZXIgYSBQcmVhY3QgdmlydHVhbCBub2RlIGludG8gYSBET00gZWxlbWVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnRDaGlsZH0gdm5vZGUgVGhlIHZpcnR1YWwgbm9kZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50RG9tIFRoZSBET00gZWxlbWVudCB0b1xuICogcmVuZGVyIGludG9cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudCB8IG9iamVjdH0gW3JlcGxhY2VOb2RlXSBPcHRpb25hbDogQXR0ZW1wdCB0byByZS11c2UgYW5cbiAqIGV4aXN0aW5nIERPTSB0cmVlIHJvb3RlZCBhdCBgcmVwbGFjZU5vZGVgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIodm5vZGUsIHBhcmVudERvbSwgcmVwbGFjZU5vZGUpIHtcblx0aWYgKG9wdGlvbnMuX3Jvb3QpIG9wdGlvbnMuX3Jvb3Qodm5vZGUsIHBhcmVudERvbSk7XG5cblx0Ly8gV2UgYWJ1c2UgdGhlIGByZXBsYWNlTm9kZWAgcGFyYW1ldGVyIGluIGBoeWRyYXRlKClgIHRvIHNpZ25hbCBpZiB3ZSBhcmUgaW5cblx0Ly8gaHlkcmF0aW9uIG1vZGUgb3Igbm90IGJ5IHBhc3NpbmcgdGhlIGBoeWRyYXRlYCBmdW5jdGlvbiBpbnN0ZWFkIG9mIGEgRE9NXG5cdC8vIGVsZW1lbnQuLlxuXHRsZXQgaXNIeWRyYXRpbmcgPSB0eXBlb2YgcmVwbGFjZU5vZGUgPT09ICdmdW5jdGlvbic7XG5cblx0Ly8gVG8gYmUgYWJsZSB0byBzdXBwb3J0IGNhbGxpbmcgYHJlbmRlcigpYCBtdWx0aXBsZSB0aW1lcyBvbiB0aGUgc2FtZVxuXHQvLyBET00gbm9kZSwgd2UgbmVlZCB0byBvYnRhaW4gYSByZWZlcmVuY2UgdG8gdGhlIHByZXZpb3VzIHRyZWUuIFdlIGRvXG5cdC8vIHRoaXMgYnkgYXNzaWduaW5nIGEgbmV3IGBfY2hpbGRyZW5gIHByb3BlcnR5IHRvIERPTSBub2RlcyB3aGljaCBwb2ludHNcblx0Ly8gdG8gdGhlIGxhc3QgcmVuZGVyZWQgdHJlZS4gQnkgZGVmYXVsdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBwcmVzZW50LCB3aGljaFxuXHQvLyBtZWFucyB0aGF0IHdlIGFyZSBtb3VudGluZyBhIG5ldyB0cmVlIGZvciB0aGUgZmlyc3QgdGltZS5cblx0bGV0IG9sZFZOb2RlID0gaXNIeWRyYXRpbmdcblx0XHQ/IG51bGxcblx0XHQ6IChyZXBsYWNlTm9kZSAmJiByZXBsYWNlTm9kZS5fY2hpbGRyZW4pIHx8IHBhcmVudERvbS5fY2hpbGRyZW47XG5cblx0dm5vZGUgPSAoXG5cdFx0KCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZSkgfHxcblx0XHRwYXJlbnREb21cblx0KS5fY2hpbGRyZW4gPSBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBbdm5vZGVdKTtcblxuXHQvLyBMaXN0IG9mIGVmZmVjdHMgdGhhdCBuZWVkIHRvIGJlIGNhbGxlZCBhZnRlciBkaWZmaW5nLlxuXHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0ZGlmZihcblx0XHRwYXJlbnREb20sXG5cdFx0Ly8gRGV0ZXJtaW5lIHRoZSBuZXcgdm5vZGUgdHJlZSBhbmQgc3RvcmUgaXQgb24gdGhlIERPTSBlbGVtZW50IG9uXG5cdFx0Ly8gb3VyIGN1c3RvbSBgX2NoaWxkcmVuYCBwcm9wZXJ0eS5cblx0XHR2bm9kZSxcblx0XHRvbGRWTm9kZSB8fCBFTVBUWV9PQkosXG5cdFx0RU1QVFlfT0JKLFxuXHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHQhaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGVcblx0XHRcdD8gW3JlcGxhY2VOb2RlXVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkXG5cdFx0XHQ/IHNsaWNlLmNhbGwocGFyZW50RG9tLmNoaWxkTm9kZXMpXG5cdFx0XHQ6IG51bGwsXG5cdFx0Y29tbWl0UXVldWUsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IHJlcGxhY2VOb2RlXG5cdFx0XHQ6IG9sZFZOb2RlXG5cdFx0XHQ/IG9sZFZOb2RlLl9kb21cblx0XHRcdDogcGFyZW50RG9tLmZpcnN0Q2hpbGQsXG5cdFx0aXNIeWRyYXRpbmdcblx0KTtcblxuXHQvLyBGbHVzaCBhbGwgcXVldWVkIGVmZmVjdHNcblx0Y29tbWl0Um9vdChjb21taXRRdWV1ZSwgdm5vZGUpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSBhbiBleGlzdGluZyBET00gZWxlbWVudCB3aXRoIGRhdGEgZnJvbSBhIFByZWFjdCB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHVwZGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50RG9tKSB7XG5cdHJlbmRlcih2bm9kZSwgcGFyZW50RG9tLCBoeWRyYXRlKTtcbn1cbiIsIi8qKlxuICogRmluZCB0aGUgY2xvc2VzdCBlcnJvciBib3VuZGFyeSB0byBhIHRocm93biBlcnJvciBhbmQgY2FsbCBpdFxuICogQHBhcmFtIHtvYmplY3R9IGVycm9yIFRoZSB0aHJvd24gdmFsdWVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdGhhdCB0aHJld1xuICogdGhlIGVycm9yIHRoYXQgd2FzIGNhdWdodCAoZXhjZXB0IGZvciB1bm1vdW50aW5nIHdoZW4gdGhpcyBwYXJhbWV0ZXJcbiAqIGlzIHRoZSBoaWdoZXN0IHBhcmVudCB0aGF0IHdhcyBiZWluZyB1bm1vdW50ZWQpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gW29sZFZOb2RlXVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuRXJyb3JJbmZvfSBbZXJyb3JJbmZvXVxuICovXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoRXJyb3IoZXJyb3IsIHZub2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0bGV0IGNvbXBvbmVudCwgY3RvciwgaGFuZGxlZDtcblxuXHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdGlmICgoY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudCkgJiYgIWNvbXBvbmVudC5fcHJvY2Vzc2luZ0V4Y2VwdGlvbikge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcblxuXHRcdFx0XHRpZiAoY3RvciAmJiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnNldFN0YXRlKGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yKSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoICE9IG51bGwpIHtcblx0XHRcdFx0XHRjb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IsIGVycm9ySW5mbyB8fCB7fSk7XG5cdFx0XHRcdFx0aGFuZGxlZCA9IGNvbXBvbmVudC5fZGlydHk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUaGlzIGlzIGFuIGVycm9yIGJvdW5kYXJ5LiBNYXJrIGl0IGFzIGhhdmluZyBiYWlsZWQgb3V0LCBhbmQgd2hldGhlciBpdCB3YXMgbWlkLWh5ZHJhdGlvbi5cblx0XHRcdFx0aWYgKGhhbmRsZWQpIHtcblx0XHRcdFx0XHRyZXR1cm4gKGNvbXBvbmVudC5fcGVuZGluZ0Vycm9yID0gY29tcG9uZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dGhyb3cgZXJyb3I7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zLCBGcmFnbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdwcmVhY3QnKS5WTm9kZX0gVk5vZGUgKi9cblxubGV0IHZub2RlSWQgPSAwO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRoaXMgZmlsZSBleHBvcnRzIHZhcmlvdXMgbWV0aG9kcyB0aGF0IGltcGxlbWVudCBCYWJlbCdzIFwiYXV0b21hdGljXCIgSlNYIHJ1bnRpbWUgQVBJOlxuICogLSBqc3godHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4cyh0eXBlLCBwcm9wcywga2V5KVxuICogLSBqc3hERVYodHlwZSwgcHJvcHMsIGtleSwgX19zb3VyY2UsIF9fc2VsZilcbiAqXG4gKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgY3JlYXRlVk5vZGUgaGVyZSBpcyBvcHRpbWl6ZWQgZm9yIHBlcmZvcm1hbmNlLlxuICogQmVuY2htYXJrczogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81ZjZiNTRhMGI0NjMyMTAwYTdkY2QyYjNcbiAqL1xuXG4vKipcbiAqIEpTWC5FbGVtZW50IGZhY3RvcnkgdXNlZCBieSBCYWJlbCdzIHtydW50aW1lOlwiYXV0b21hdGljXCJ9IEpTWCB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7Vk5vZGVbJ3R5cGUnXX0gdHlwZVxuICogQHBhcmFtIHtWTm9kZVsncHJvcHMnXX0gcHJvcHNcbiAqIEBwYXJhbSB7Vk5vZGVbJ2tleSddfSBba2V5XVxuICogQHBhcmFtIHtzdHJpbmd9IFtfX3NlbGZdXG4gKiBAcGFyYW0ge3N0cmluZ30gW19fc291cmNlXVxuICovXG5mdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCBfX3NlbGYsIF9fc291cmNlKSB7XG5cdC8vIFdlJ2xsIHdhbnQgdG8gcHJlc2VydmUgYHJlZmAgaW4gcHJvcHMgdG8gZ2V0IHJpZCBvZiB0aGUgbmVlZCBmb3Jcblx0Ly8gZm9yd2FyZFJlZiBjb21wb25lbnRzIGluIHRoZSBmdXR1cmUsIGJ1dCB0aGF0IHNob3VsZCBoYXBwZW4gdmlhXG5cdC8vIGEgc2VwYXJhdGUgUFIuXG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSB7fSxcblx0XHRyZWYsXG5cdFx0aTtcblx0Zm9yIChpIGluIHByb3BzKSB7XG5cdFx0aWYgKGkgPT0gJ3JlZicpIHtcblx0XHRcdHJlZiA9IHByb3BzW2ldO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0XHR9XG5cdH1cblxuXHRjb25zdCB2bm9kZSA9IHtcblx0XHR0eXBlLFxuXHRcdHByb3BzOiBub3JtYWxpemVkUHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogLS12bm9kZUlkLFxuXHRcdF9fc291cmNlLFxuXHRcdF9fc2VsZlxuXHR9O1xuXG5cdC8vIElmIGEgQ29tcG9uZW50IFZOb2RlLCBjaGVjayBmb3IgYW5kIGFwcGx5IGRlZmF1bHRQcm9wcy5cblx0Ly8gTm90ZTogYHR5cGVgIGlzIG9mdGVuIGEgU3RyaW5nLCBhbmQgY2FuIGJlIGB1bmRlZmluZWRgIGluIGRldmVsb3BtZW50LlxuXHRpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgKHJlZiA9IHR5cGUuZGVmYXVsdFByb3BzKSkge1xuXHRcdGZvciAoaSBpbiByZWYpXG5cdFx0XHRpZiAodHlwZW9mIG5vcm1hbGl6ZWRQcm9wc1tpXSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcmVmW2ldO1xuXHRcdFx0fVxuXHR9XG5cblx0aWYgKG9wdGlvbnMudm5vZGUpIG9wdGlvbnMudm5vZGUodm5vZGUpO1xuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCB7XG5cdGNyZWF0ZVZOb2RlIGFzIGpzeCxcblx0Y3JlYXRlVk5vZGUgYXMganN4cyxcblx0Y3JlYXRlVk5vZGUgYXMganN4REVWLFxuXHRGcmFnbWVudFxufTtcbiIsImltcG9ydCB7IG9wdGlvbnMgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SW5kZXg7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xubGV0IHByZXZpb3VzQ29tcG9uZW50O1xuXG4vKiogQHR5cGUge251bWJlcn0gKi9cbmxldCBjdXJyZW50SG9vayA9IDA7XG5cbi8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn0gKi9cbmxldCBhZnRlclBhaW50RWZmZWN0cyA9IFtdO1xuXG5sZXQgRU1QVFkgPSBbXTtcblxubGV0IG9sZEJlZm9yZURpZmYgPSBvcHRpb25zLl9kaWZmO1xubGV0IG9sZEJlZm9yZVJlbmRlciA9IG9wdGlvbnMuX3JlbmRlcjtcbmxldCBvbGRBZnRlckRpZmYgPSBvcHRpb25zLmRpZmZlZDtcbmxldCBvbGRDb21taXQgPSBvcHRpb25zLl9jb21taXQ7XG5sZXQgb2xkQmVmb3JlVW5tb3VudCA9IG9wdGlvbnMudW5tb3VudDtcblxuY29uc3QgUkFGX1RJTUVPVVQgPSAxMDA7XG5sZXQgcHJldlJhZjtcblxub3B0aW9ucy5fZGlmZiA9IHZub2RlID0+IHtcblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGhvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH1cblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG59O1xuXG5vcHRpb25zLmRpZmZlZCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEFmdGVyRGlmZikgb2xkQWZ0ZXJEaWZmKHZub2RlKTtcblxuXHRjb25zdCBjID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGMgJiYgYy5fX2hvb2tzKSB7XG5cdFx0aWYgKGMuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMubGVuZ3RoKSBhZnRlclBhaW50KGFmdGVyUGFpbnRFZmZlY3RzLnB1c2goYykpO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKGhvb2tJdGVtID0+IHtcblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ0FyZ3MpIHtcblx0XHRcdFx0aG9va0l0ZW0uX2FyZ3MgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3M7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSAhPT0gRU1QVFkpIHtcblx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX3BlbmRpbmdWYWx1ZTtcblx0XHRcdH1cblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nQXJncyA9IHVuZGVmaW5lZDtcblx0XHRcdGhvb2tJdGVtLl9wZW5kaW5nVmFsdWUgPSBFTVBUWTtcblx0XHR9KTtcblx0fVxuXHRwcmV2aW91c0NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQgPSBudWxsO1xufTtcblxub3B0aW9ucy5fY29tbWl0ID0gKHZub2RlLCBjb21taXRRdWV1ZSkgPT4ge1xuXHRjb21taXRRdWV1ZS5zb21lKGNvbXBvbmVudCA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRjb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLmZpbHRlcihjYiA9PlxuXHRcdFx0XHRjYi5fdmFsdWUgPyBpbnZva2VFZmZlY3QoY2IpIDogdHJ1ZVxuXHRcdFx0KTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21taXRRdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzKSBjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdH0pO1xuXHRcdFx0Y29tbWl0UXVldWUgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9KTtcblxuXHRpZiAob2xkQ29tbWl0KSBvbGRDb21taXQodm5vZGUsIGNvbW1pdFF1ZXVlKTtcbn07XG5cbm9wdGlvbnMudW5tb3VudCA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVVubW91bnQpIG9sZEJlZm9yZVVubW91bnQodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRsZXQgaGFzRXJyb3JlZDtcblx0XHRjLl9faG9va3MuX2xpc3QuZm9yRWFjaChzID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGludm9rZUNsZWFudXAocyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdGhhc0Vycm9yZWQgPSBlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IG5leHRWYWx1ZSA9IGhvb2tTdGF0ZS5fcmVkdWNlcihob29rU3RhdGUuX3ZhbHVlWzBdLCBhY3Rpb24pO1xuXHRcdFx0XHRpZiAoaG9va1N0YXRlLl92YWx1ZVswXSAhPT0gbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va1N0YXRlLl92YWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdH1cblxuXHRyZXR1cm4gaG9va1N0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDMpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3R9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3QoY2FsbGJhY2ssIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA0KTtcblx0aWYgKCFvcHRpb25zLl9za2lwRWZmZWN0cyAmJiBhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSBjYWxsYmFjaztcblx0XHRzdGF0ZS5fcGVuZGluZ0FyZ3MgPSBhcmdzO1xuXG5cdFx0Y3VycmVudENvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goc3RhdGUpO1xuXHR9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWYoaW5pdGlhbFZhbHVlKSB7XG5cdGN1cnJlbnRIb29rID0gNTtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gKHsgY3VycmVudDogaW5pdGlhbFZhbHVlIH0pLCBbXSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IHJlZlxuICogQHBhcmFtIHsoKSA9PiBvYmplY3R9IGNyZWF0ZUhhbmRsZVxuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZUhhbmRsZSwgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDY7XG5cdHVzZUxheW91dEVmZmVjdChcblx0XHQoKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIHJlZiA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdHJlZihjcmVhdGVIYW5kbGUoKSk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiByZWYobnVsbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHJlZikge1xuXHRcdFx0XHRyZWYuY3VycmVudCA9IGNyZWF0ZUhhbmRsZSgpO1xuXHRcdFx0XHRyZXR1cm4gKCkgPT4gKHJlZi5jdXJyZW50ID0gbnVsbCk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRhcmdzID09IG51bGwgPyBhcmdzIDogYXJncy5jb25jYXQocmVmKVxuXHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gYW55fSBmYWN0b3J5XG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZW1vKGZhY3RvcnksIGFyZ3MpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5NZW1vSG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgNyk7XG5cdGlmIChhcmdzQ2hhbmdlZChzdGF0ZS5fYXJncywgYXJncykpIHtcblx0XHRzdGF0ZS5fcGVuZGluZ1ZhbHVlID0gZmFjdG9yeSgpO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cdFx0c3RhdGUuX2ZhY3RvcnkgPSBmYWN0b3J5O1xuXHRcdHJldHVybiBzdGF0ZS5fcGVuZGluZ1ZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHN0YXRlLl92YWx1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IGNhbGxiYWNrXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VDYWxsYmFjayhjYWxsYmFjaywgYXJncykge1xuXHRjdXJyZW50SG9vayA9IDg7XG5cdHJldHVybiB1c2VNZW1vKCgpID0+IGNhbGxiYWNrLCBhcmdzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdENvbnRleHR9IGNvbnRleHRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbnRleHQoY29udGV4dCkge1xuXHRjb25zdCBwcm92aWRlciA9IGN1cnJlbnRDb21wb25lbnQuY29udGV4dFtjb250ZXh0Ll9pZF07XG5cdC8vIFdlIGNvdWxkIHNraXAgdGhpcyBjYWxsIGhlcmUsIGJ1dCB0aGFuIHdlJ2Qgbm90IGNhbGxcblx0Ly8gYG9wdGlvbnMuX2hvb2tgLiBXZSBuZWVkIHRvIGRvIHRoYXQgaW4gb3JkZXIgdG8gbWFrZVxuXHQvLyB0aGUgZGV2dG9vbHMgYXdhcmUgb2YgdGhpcyBob29rLlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbnRleHRIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA5KTtcblx0Ly8gVGhlIGRldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3QgdG9cblx0Ly8gYmUgYWJsZSB0byBwdWxsIG9mIHRoZSBkZWZhdWx0IHZhbHVlIHdoZW4gbm8gcHJvdmlkZXJcblx0Ly8gaXMgcHJlc2VudCBpbiB0aGUgdHJlZS5cblx0c3RhdGUuX2NvbnRleHQgPSBjb250ZXh0O1xuXHRpZiAoIXByb3ZpZGVyKSByZXR1cm4gY29udGV4dC5fZGVmYXVsdFZhbHVlO1xuXHQvLyBUaGlzIGlzIHByb2JhYmx5IG5vdCBzYWZlIHRvIGNvbnZlcnQgdG8gXCIhXCJcblx0aWYgKHN0YXRlLl92YWx1ZSA9PSBudWxsKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gdHJ1ZTtcblx0XHRwcm92aWRlci5zdWIoY3VycmVudENvbXBvbmVudCk7XG5cdH1cblx0cmV0dXJuIHByb3ZpZGVyLnByb3BzLnZhbHVlO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYSBjdXN0b20gbGFiZWwgZm9yIGEgY3VzdG9tIGhvb2sgZm9yIHRoZSBkZXZ0b29scyBwYW5lbFxuICogQHR5cGUgezxUPih2YWx1ZTogVCwgY2I/OiAodmFsdWU6IFQpID0+IHN0cmluZyB8IG51bWJlcikgPT4gdm9pZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlcikge1xuXHRpZiAob3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKSB7XG5cdFx0b3B0aW9ucy51c2VEZWJ1Z1ZhbHVlKGZvcm1hdHRlciA/IGZvcm1hdHRlcih2YWx1ZSkgOiB2YWx1ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0geyhlcnJvcjogYW55KSA9PiB2b2lkfSBjYlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRXJyb3JCb3VuZGFyeShjYikge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVycm9yQm91bmRhcnlIb29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMCk7XG5cdGNvbnN0IGVyclN0YXRlID0gdXNlU3RhdGUoKTtcblx0c3RhdGUuX3ZhbHVlID0gY2I7XG5cdGlmICghY3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCkge1xuXHRcdGN1cnJlbnRDb21wb25lbnQuY29tcG9uZW50RGlkQ2F0Y2ggPSBlcnIgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVycik7XG5cdFx0XHRlcnJTdGF0ZVsxXShlcnIpO1xuXHRcdH07XG5cdH1cblx0cmV0dXJuIFtcblx0XHRlcnJTdGF0ZVswXSxcblx0XHQoKSA9PiB7XG5cdFx0XHRlcnJTdGF0ZVsxXSh1bmRlZmluZWQpO1xuXHRcdH1cblx0XTtcbn1cblxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSkgY29udGludWU7XG5cdFx0dHJ5IHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUNsZWFudXApO1xuXHRcdFx0Y29tcG9uZW50Ll9faG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlRWZmZWN0KTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cyA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH1cbn1cblxubGV0IEhBU19SQUYgPSB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09ICdmdW5jdGlvbic7XG5cbi8qKlxuICogU2NoZWR1bGUgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBicm93c2VyIGhhcyBhIGNoYW5jZSB0byBwYWludCBhIG5ldyBmcmFtZS5cbiAqIERvIHRoaXMgYnkgY29tYmluaW5nIHJlcXVlc3RBbmltYXRpb25GcmFtZSAockFGKSArIHNldFRpbWVvdXQgdG8gaW52b2tlIGEgY2FsbGJhY2sgYWZ0ZXJcbiAqIHRoZSBuZXh0IGJyb3dzZXIgZnJhbWUuXG4gKlxuICogQWxzbywgc2NoZWR1bGUgYSB0aW1lb3V0IGluIHBhcmFsbGVsIHRvIHRoZSB0aGUgckFGIHRvIGVuc3VyZSB0aGUgY2FsbGJhY2sgaXMgaW52b2tlZFxuICogZXZlbiBpZiBSQUYgZG9lc24ndCBmaXJlIChmb3IgZXhhbXBsZSBpZiB0aGUgYnJvd3NlciB0YWIgaXMgbm90IHZpc2libGUpXG4gKlxuICogQHBhcmFtIHsoKSA9PiB2b2lkfSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBhZnRlck5leHRGcmFtZShjYWxsYmFjaykge1xuXHRjb25zdCBkb25lID0gKCkgPT4ge1xuXHRcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcblx0XHRpZiAoSEFTX1JBRikgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmKTtcblx0XHRzZXRUaW1lb3V0KGNhbGxiYWNrKTtcblx0fTtcblx0Y29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoZG9uZSwgUkFGX1RJTUVPVVQpO1xuXG5cdGxldCByYWY7XG5cdGlmIChIQVNfUkFGKSB7XG5cdFx0cmFmID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGRvbmUpO1xuXHR9XG59XG5cbi8vIE5vdGU6IGlmIHNvbWVvbmUgdXNlZCBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxuLy8gdGhlbiBlZmZlY3RzIHdpbGwgQUxXQVlTIHJ1biBvbiB0aGUgTkVYVCBmcmFtZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IG9uZSwgaW5jdXJyaW5nIGEgfjE2bXMgZGVsYXkuXG4vLyBQZXJoYXBzIHRoaXMgaXMgbm90IHN1Y2ggYSBiaWcgZGVhbC5cbi8qKlxuICogU2NoZWR1bGUgYWZ0ZXJQYWludEVmZmVjdHMgZmx1c2ggYWZ0ZXIgdGhlIGJyb3dzZXIgcGFpbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbmV3UXVldWVMZW5ndGhcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJQYWludChuZXdRdWV1ZUxlbmd0aCkge1xuXHRpZiAobmV3UXVldWVMZW5ndGggPT09IDEgfHwgcHJldlJhZiAhPT0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcblx0XHRwcmV2UmFmID0gb3B0aW9ucy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0KHByZXZSYWYgfHwgYWZ0ZXJOZXh0RnJhbWUpKGZsdXNoQWZ0ZXJQYWludEVmZmVjdHMpO1xuXHR9XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5FZmZlY3RIb29rU3RhdGV9IGhvb2tcbiAqL1xuZnVuY3Rpb24gaW52b2tlQ2xlYW51cChob29rKSB7XG5cdC8vIEEgaG9vayBjbGVhbnVwIGNhbiBpbnRyb2R1Y2UgYSBjYWxsIHRvIHJlbmRlciB3aGljaCBjcmVhdGVzIGEgbmV3IHJvb3QsIHRoaXMgd2lsbCBjYWxsIG9wdGlvbnMudm5vZGVcblx0Ly8gYW5kIG1vdmUgdGhlIGN1cnJlbnRDb21wb25lbnQgYXdheS5cblx0Y29uc3QgY29tcCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cdGxldCBjbGVhbnVwID0gaG9vay5fY2xlYW51cDtcblx0aWYgKHR5cGVvZiBjbGVhbnVwID09ICdmdW5jdGlvbicpIHtcblx0XHRob29rLl9jbGVhbnVwID0gdW5kZWZpbmVkO1xuXHRcdGNsZWFudXAoKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogTWVtb2l6ZSBhIGNvbXBvbmVudCwgc28gdGhhdCBpdCBvbmx5IHVwZGF0ZXMgd2hlbiB0aGUgcHJvcHMgYWN0dWFsbHkgaGF2ZVxuICogY2hhbmdlZC4gVGhpcyB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgUmVhY3QucHVyZWAuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSBjIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gKiBAcGFyYW0geyhwcmV2OiBvYmplY3QsIG5leHQ6IG9iamVjdCkgPT4gYm9vbGVhbn0gW2NvbXBhcmVyXSBDdXN0b20gZXF1YWxpdHkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW8oYywgY29tcGFyZXIpIHtcblx0ZnVuY3Rpb24gc2hvdWxkVXBkYXRlKG5leHRQcm9wcykge1xuXHRcdGxldCByZWYgPSB0aGlzLnByb3BzLnJlZjtcblx0XHRsZXQgdXBkYXRlUmVmID0gcmVmID09IG5leHRQcm9wcy5yZWY7XG5cdFx0aWYgKCF1cGRhdGVSZWYgJiYgcmVmKSB7XG5cdFx0XHRyZWYuY2FsbCA/IHJlZihudWxsKSA6IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdH1cblxuXHRcdGlmICghY29tcGFyZXIpIHtcblx0XHRcdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhY29tcGFyZXIodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhdXBkYXRlUmVmO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVtb2VkKHByb3BzKSB7XG5cdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBzaG91bGRVcGRhdGU7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoYywgcHJvcHMpO1xuXHR9XG5cdE1lbW9lZC5kaXNwbGF5TmFtZSA9ICdNZW1vKCcgKyAoYy5kaXNwbGF5TmFtZSB8fCBjLm5hbWUpICsgJyknO1xuXHRNZW1vZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHRNZW1vZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBNZW1vZWQ7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlRWxlbWVudCwgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3Qgb2xkQ2F0Y2hFcnJvciA9IG9wdGlvbnMuX2NhdGNoRXJyb3I7XG5vcHRpb25zLl9jYXRjaEVycm9yID0gZnVuY3Rpb24oZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKSB7XG5cdGlmIChlcnJvci50aGVuKSB7XG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdFx0bGV0IGNvbXBvbmVudDtcblx0XHRsZXQgdm5vZGUgPSBuZXdWTm9kZTtcblxuXHRcdGZvciAoOyAodm5vZGUgPSB2bm9kZS5fcGFyZW50KTsgKSB7XG5cdFx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKSB7XG5cdFx0XHRcdGlmIChuZXdWTm9kZS5fZG9tID09IG51bGwpIHtcblx0XHRcdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRG9uJ3QgY2FsbCBvbGRDYXRjaEVycm9yIGlmIHdlIGZvdW5kIGEgU3VzcGVuc2Vcblx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fY2hpbGREaWRTdXNwZW5kKGVycm9yLCBuZXdWTm9kZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdG9sZENhdGNoRXJyb3IoZXJyb3IsIG5ld1ZOb2RlLCBvbGRWTm9kZSwgZXJyb3JJbmZvKTtcbn07XG5cbmNvbnN0IG9sZFVubW91bnQgPSBvcHRpb25zLnVubW91bnQ7XG5vcHRpb25zLnVubW91bnQgPSBmdW5jdGlvbih2bm9kZSkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH0gKi9cblx0Y29uc3QgY29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0aWYgKGNvbXBvbmVudCAmJiBjb21wb25lbnQuX29uUmVzb2x2ZSkge1xuXHRcdGNvbXBvbmVudC5fb25SZXNvbHZlKCk7XG5cdH1cblxuXHQvLyBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIGh5ZHJhdGluZ1xuXHQvLyBtb3N0IGxpa2VseSBpdCBpcyBiZWNhdXNlIHRoZSBjb21wb25lbnQgaXMgc3VzcGVuZGVkXG5cdC8vIHdlIHNldCB0aGUgdm5vZGUudHlwZSBhcyBgbnVsbGAgc28gdGhhdCBpdCBpcyBub3QgYSB0eXBlb2YgZnVuY3Rpb25cblx0Ly8gc28gdGhlIHVubW91bnQgd2lsbCByZW1vdmUgdGhlIHZub2RlLl9kb21cblx0aWYgKGNvbXBvbmVudCAmJiB2bm9kZS5faHlkcmF0aW5nID09PSB0cnVlKSB7XG5cdFx0dm5vZGUudHlwZSA9IG51bGw7XG5cdH1cblxuXHRpZiAob2xkVW5tb3VudCkgb2xkVW5tb3VudCh2bm9kZSk7XG59O1xuXG5mdW5jdGlvbiBkZXRhY2hlZENsb25lKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgcGFyZW50RG9tKSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICYmIHZub2RlLl9jb21wb25lbnQuX19ob29rcykge1xuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzLl9saXN0LmZvckVhY2goZWZmZWN0ID0+IHtcblx0XHRcdFx0aWYgKHR5cGVvZiBlZmZlY3QuX2NsZWFudXAgPT0gJ2Z1bmN0aW9uJykgZWZmZWN0Ll9jbGVhbnVwKCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fX2hvb2tzID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50ICE9IG51bGwpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IHBhcmVudERvbSkge1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBkZXRhY2hlZFBhcmVudDtcblx0XHRcdH1cblx0XHRcdHZub2RlLl9jb21wb25lbnQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHZub2RlLl9jaGlsZHJlbiA9XG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4gJiZcblx0XHRcdHZub2RlLl9jaGlsZHJlbi5tYXAoY2hpbGQgPT5cblx0XHRcdFx0ZGV0YWNoZWRDbG9uZShjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSlcblx0XHRcdCk7XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZU9yaWdpbmFsKHZub2RlLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpIHtcblx0aWYgKHZub2RlKSB7XG5cdFx0dm5vZGUuX29yaWdpbmFsID0gbnVsbDtcblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdHJlbW92ZU9yaWdpbmFsKGNoaWxkLCBkZXRhY2hlZFBhcmVudCwgb3JpZ2luYWxQYXJlbnQpXG5cdFx0XHQpO1xuXG5cdFx0aWYgKHZub2RlLl9jb21wb25lbnQpIHtcblx0XHRcdGlmICh2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPT09IGRldGFjaGVkUGFyZW50KSB7XG5cdFx0XHRcdGlmICh2bm9kZS5fZG9tKSB7XG5cdFx0XHRcdFx0b3JpZ2luYWxQYXJlbnQuaW5zZXJ0QmVmb3JlKHZub2RlLl9kb20sIHZub2RlLl9uZXh0RG9tKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9mb3JjZSA9IHRydWU7XG5cdFx0XHRcdHZub2RlLl9jb21wb25lbnQuX3BhcmVudERvbSA9IG9yaWdpbmFsUGFyZW50O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2bm9kZTtcbn1cblxuLy8gaGF2aW5nIGN1c3RvbSBpbmhlcml0YW5jZSBpbnN0ZWFkIG9mIGEgY2xhc3MgaGVyZSBzYXZlcyBhIGxvdCBvZiBieXRlc1xuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlKCkge1xuXHQvLyB3ZSBkbyBub3QgY2FsbCBzdXBlciBoZXJlIHRvIGdvbGYgc29tZSBieXRlcy4uLlxuXHR0aGlzLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50ID0gMDtcblx0dGhpcy5fc3VzcGVuZGVycyA9IG51bGw7XG5cdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG59XG5cbi8vIFRoaW5ncyB3ZSBkbyBoZXJlIHRvIHNhdmUgc29tZSBieXRlcyBidXQgYXJlIG5vdCBwcm9wZXIgSlMgaW5oZXJpdGFuY2U6XG4vLyAtIGNhbGwgYG5ldyBDb21wb25lbnQoKWAgYXMgdGhlIHByb3RvdHlwZVxuLy8gLSBkbyBub3Qgc2V0IGBTdXNwZW5zZS5wcm90b3R5cGUuY29uc3RydWN0b3JgIHRvIGBTdXNwZW5zZWBcblN1c3BlbnNlLnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge1Byb21pc2V9IHByb21pc2UgVGhlIHRocm93biBwcm9taXNlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlPGFueSwgYW55Pn0gc3VzcGVuZGluZ1ZOb2RlIFRoZSBzdXNwZW5kaW5nIGNvbXBvbmVudFxuICovXG5TdXNwZW5zZS5wcm90b3R5cGUuX2NoaWxkRGlkU3VzcGVuZCA9IGZ1bmN0aW9uKHByb21pc2UsIHN1c3BlbmRpbmdWTm9kZSkge1xuXHRjb25zdCBzdXNwZW5kaW5nQ29tcG9uZW50ID0gc3VzcGVuZGluZ1ZOb2RlLl9jb21wb25lbnQ7XG5cblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH0gKi9cblx0Y29uc3QgYyA9IHRoaXM7XG5cblx0aWYgKGMuX3N1c3BlbmRlcnMgPT0gbnVsbCkge1xuXHRcdGMuX3N1c3BlbmRlcnMgPSBbXTtcblx0fVxuXHRjLl9zdXNwZW5kZXJzLnB1c2goc3VzcGVuZGluZ0NvbXBvbmVudCk7XG5cblx0Y29uc3QgcmVzb2x2ZSA9IHN1c3BlbmRlZChjLl92bm9kZSk7XG5cblx0bGV0IHJlc29sdmVkID0gZmFsc2U7XG5cdGNvbnN0IG9uUmVzb2x2ZWQgPSAoKSA9PiB7XG5cdFx0aWYgKHJlc29sdmVkKSByZXR1cm47XG5cblx0XHRyZXNvbHZlZCA9IHRydWU7XG5cdFx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gbnVsbDtcblxuXHRcdGlmIChyZXNvbHZlKSB7XG5cdFx0XHRyZXNvbHZlKG9uU3VzcGVuc2lvbkNvbXBsZXRlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b25TdXNwZW5zaW9uQ29tcGxldGUoKTtcblx0XHR9XG5cdH07XG5cblx0c3VzcGVuZGluZ0NvbXBvbmVudC5fb25SZXNvbHZlID0gb25SZXNvbHZlZDtcblxuXHRjb25zdCBvblN1c3BlbnNpb25Db21wbGV0ZSA9ICgpID0+IHtcblx0XHRpZiAoIS0tYy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCkge1xuXHRcdFx0Ly8gSWYgdGhlIHN1c3BlbnNpb24gd2FzIGR1cmluZyBoeWRyYXRpb24gd2UgZG9uJ3QgbmVlZCB0byByZXN0b3JlIHRoZVxuXHRcdFx0Ly8gc3VzcGVuZGVkIGNoaWxkcmVuIGludG8gdGhlIF9jaGlsZHJlbiBhcnJheVxuXHRcdFx0aWYgKGMuc3RhdGUuX3N1c3BlbmRlZCkge1xuXHRcdFx0XHRjb25zdCBzdXNwZW5kZWRWTm9kZSA9IGMuc3RhdGUuX3N1c3BlbmRlZDtcblx0XHRcdFx0Yy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gcmVtb3ZlT3JpZ2luYWwoXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUsXG5cdFx0XHRcdFx0c3VzcGVuZGVkVk5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX29yaWdpbmFsUGFyZW50RG9tXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gbnVsbCkgfSk7XG5cblx0XHRcdGxldCBzdXNwZW5kZWQ7XG5cdFx0XHR3aGlsZSAoKHN1c3BlbmRlZCA9IGMuX3N1c3BlbmRlcnMucG9wKCkpKSB7XG5cdFx0XHRcdHN1c3BlbmRlZC5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogV2UgZG8gbm90IHNldCBgc3VzcGVuZGVkOiB0cnVlYCBkdXJpbmcgaHlkcmF0aW9uIGJlY2F1c2Ugd2Ugd2FudCB0aGUgYWN0dWFsIG1hcmt1cFxuXHQgKiB0byByZW1haW4gb24gc2NyZWVuIGFuZCBoeWRyYXRlIGl0IHdoZW4gdGhlIHN1c3BlbnNlIGFjdHVhbGx5IGdldHMgcmVzb2x2ZWQuXG5cdCAqIFdoaWxlIGluIG5vbi1oeWRyYXRpb24gY2FzZXMgdGhlIHVzdWFsIGZhbGxiYWNrIC0+IGNvbXBvbmVudCBmbG93IHdvdWxkIG9jY291ci5cblx0ICovXG5cdGNvbnN0IHdhc0h5ZHJhdGluZyA9IHN1c3BlbmRpbmdWTm9kZS5faHlkcmF0aW5nID09PSB0cnVlO1xuXHRpZiAoIWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQrKyAmJiAhd2FzSHlkcmF0aW5nKSB7XG5cdFx0Yy5zZXRTdGF0ZSh7IF9zdXNwZW5kZWQ6IChjLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBjLl92bm9kZS5fY2hpbGRyZW5bMF0pIH0pO1xuXHR9XG5cdHByb21pc2UudGhlbihvblJlc29sdmVkLCBvblJlc29sdmVkKTtcbn07XG5cblN1c3BlbnNlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHR0aGlzLl9zdXNwZW5kZXJzID0gW107XG59O1xuXG4vKipcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5TdXNwZW5zZUNvbXBvbmVudH1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnRbXCJwcm9wc1wiXX0gcHJvcHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VTdGF0ZX0gc3RhdGVcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uKHByb3BzLCBzdGF0ZSkge1xuXHRpZiAodGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyKSB7XG5cdFx0Ly8gV2hlbiB0aGUgU3VzcGVuc2UncyBfdm5vZGUgd2FzIGNyZWF0ZWQgYnkgYSBjYWxsIHRvIGNyZWF0ZVZOb2RlXG5cdFx0Ly8gKGkuZS4gZHVlIHRvIGEgc2V0U3RhdGUgZnVydGhlciB1cCBpbiB0aGUgdHJlZSlcblx0XHQvLyBpdCdzIF9jaGlsZHJlbiBwcm9wIGlzIG51bGwsIGluIHRoaXMgY2FzZSB3ZSBcImZvcmdldFwiIGFib3V0IHRoZSBwYXJrZWQgdm5vZGVzIHRvIGRldGFjaFxuXHRcdGlmICh0aGlzLl92bm9kZS5fY2hpbGRyZW4pIHtcblx0XHRcdGNvbnN0IGRldGFjaGVkUGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHRjb25zdCBkZXRhY2hlZENvbXBvbmVudCA9IHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXS5fY29tcG9uZW50O1xuXHRcdFx0dGhpcy5fdm5vZGUuX2NoaWxkcmVuWzBdID0gZGV0YWNoZWRDbG9uZShcblx0XHRcdFx0dGhpcy5fZGV0YWNoT25OZXh0UmVuZGVyLFxuXHRcdFx0XHRkZXRhY2hlZFBhcmVudCxcblx0XHRcdFx0KGRldGFjaGVkQ29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbSA9IGRldGFjaGVkQ29tcG9uZW50Ll9wYXJlbnREb20pXG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGw7XG5cdH1cblxuXHQvLyBXcmFwIGZhbGxiYWNrIHRyZWUgaW4gYSBWTm9kZSB0aGF0IHByZXZlbnRzIGl0c2VsZiBmcm9tIGJlaW5nIG1hcmtlZCBhcyBhYm9ydGluZyBtaWQtaHlkcmF0aW9uOlxuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSAqL1xuXHRjb25zdCBmYWxsYmFjayA9XG5cdFx0c3RhdGUuX3N1c3BlbmRlZCAmJiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBwcm9wcy5mYWxsYmFjayk7XG5cdGlmIChmYWxsYmFjaykgZmFsbGJhY2suX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0cmV0dXJuIFtcblx0XHRjcmVhdGVFbGVtZW50KEZyYWdtZW50LCBudWxsLCBzdGF0ZS5fc3VzcGVuZGVkID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuKSxcblx0XHRmYWxsYmFja1xuXHRdO1xufTtcblxuLyoqXG4gKiBDaGVja3MgYW5kIGNhbGxzIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgX3N1c3BlbmRlZCBtZXRob2QsIHBhc3NpbmcgaW4gdGhlXG4gKiBzdXNwZW5kZWQgdm5vZGUuIFRoaXMgaXMgYSB3YXkgZm9yIGEgcGFyZW50IChlLmcuIFN1c3BlbnNlTGlzdCkgdG8gZ2V0IG5vdGlmaWVkXG4gKiB0aGF0IG9uZSBvZiBpdHMgY2hpbGRyZW4vZGVzY2VuZGFudHMgc3VzcGVuZGVkLlxuICpcbiAqIFRoZSBwYXJlbnQgTUFZIHJldHVybiBhIGNhbGxiYWNrLiBUaGUgY2FsbGJhY2sgd2lsbCBnZXQgY2FsbGVkIHdoZW4gdGhlXG4gKiBzdXNwZW5zaW9uIHJlc29sdmVzLCBub3RpZnlpbmcgdGhlIHBhcmVudCBvZiB0aGUgZmFjdC5cbiAqIE1vcmVvdmVyLCB0aGUgY2FsbGJhY2sgZ2V0cyBmdW5jdGlvbiBgdW5zdXNwZW5kYCBhcyBhIHBhcmFtZXRlci4gVGhlIHJlc29sdmVkXG4gKiBjaGlsZCBkZXNjZW5kYW50IHdpbGwgbm90IGFjdHVhbGx5IGdldCB1bnN1c3BlbmRlZCB1bnRpbCBgdW5zdXNwZW5kYCBnZXRzIGNhbGxlZC5cbiAqIFRoaXMgaXMgYSB3YXkgZm9yIHRoZSBwYXJlbnQgdG8gZGVsYXkgdW5zdXNwZW5kaW5nLlxuICpcbiAqIElmIHRoZSBwYXJlbnQgZG9lcyBub3QgcmV0dXJuIGEgY2FsbGJhY2sgdGhlbiB0aGUgcmVzb2x2ZWQgdm5vZGVcbiAqIGdldHMgdW5zdXNwZW5kZWQgaW1tZWRpYXRlbHkgd2hlbiBpdCByZXNvbHZlcy5cbiAqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZVxuICogQHJldHVybnMgeygodW5zdXNwZW5kOiAoKSA9PiB2b2lkKSA9PiB2b2lkKT99XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdXNwZW5kZWQodm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQgPSB2bm9kZS5fcGFyZW50Ll9jb21wb25lbnQ7XG5cdHJldHVybiBjb21wb25lbnQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQgJiYgY29tcG9uZW50Ll9zdXNwZW5kZWQodm5vZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbGF6eShsb2FkZXIpIHtcblx0bGV0IHByb207XG5cdGxldCBjb21wb25lbnQ7XG5cdGxldCBlcnJvcjtcblxuXHRmdW5jdGlvbiBMYXp5KHByb3BzKSB7XG5cdFx0aWYgKCFwcm9tKSB7XG5cdFx0XHRwcm9tID0gbG9hZGVyKCk7XG5cdFx0XHRwcm9tLnRoZW4oXG5cdFx0XHRcdGV4cG9ydHMgPT4ge1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGV4cG9ydHMuZGVmYXVsdCB8fCBleHBvcnRzO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRlID0+IHtcblx0XHRcdFx0XHRlcnJvciA9IGU7XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKGVycm9yKSB7XG5cdFx0XHR0aHJvdyBlcnJvcjtcblx0XHR9XG5cblx0XHRpZiAoIWNvbXBvbmVudCkge1xuXHRcdFx0dGhyb3cgcHJvbTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcblx0fVxuXG5cdExhenkuZGlzcGxheU5hbWUgPSAnTGF6eSc7XG5cdExhenkuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBMYXp5O1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50LCB0b0NoaWxkQXJyYXkgfSBmcm9tICdwcmVhY3QnO1xuaW1wb3J0IHsgc3VzcGVuZGVkIH0gZnJvbSAnLi9zdXNwZW5zZS5qcyc7XG5cbi8vIEluZGV4ZXMgdG8gbGlua2VkIGxpc3Qgbm9kZXMgKG5vZGVzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIHRvIHNhdmUgYnl0ZXMpLlxuY29uc3QgU1VTUEVOREVEX0NPVU5UID0gMDtcbmNvbnN0IFJFU09MVkVEX0NPVU5UID0gMTtcbmNvbnN0IE5FWFRfTk9ERSA9IDI7XG5cbi8vIEhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXMuXG5leHBvcnQgZnVuY3Rpb24gU3VzcGVuc2VMaXN0KCkge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbnVsbDtcbn1cblxuLy8gTWFyayBvbmUgb2YgY2hpbGQncyBlYXJsaWVyIHN1c3BlbnNpb25zIGFzIHJlc29sdmVkLlxuLy8gU29tZSBwZW5kaW5nIGNhbGxiYWNrcyBtYXkgYmVjb21lIGNhbGxhYmxlIGR1ZSB0byB0aGlzXG4vLyAoZS5nLiB0aGUgbGFzdCBzdXNwZW5kZWQgZGVzY2VuZGFudCBnZXRzIHJlc29sdmVkIHdoZW5cbi8vIHJldmVhbE9yZGVyID09PSAndG9nZXRoZXInKS4gUHJvY2VzcyB0aG9zZSBjYWxsYmFja3MgYXMgd2VsbC5cbmNvbnN0IHJlc29sdmUgPSAobGlzdCwgY2hpbGQsIG5vZGUpID0+IHtcblx0aWYgKCsrbm9kZVtSRVNPTFZFRF9DT1VOVF0gPT09IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdC8vIFRoZSBudW1iZXIgYSBjaGlsZCAob3IgYW55IG9mIGl0cyBkZXNjZW5kYW50cykgaGFzIGJlZW4gc3VzcGVuZGVkXG5cdFx0Ly8gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHRpbWVzIGl0J3MgYmVlbiByZXNvbHZlZC4gVGhlcmVmb3JlIHdlXG5cdFx0Ly8gbWFyayB0aGUgY2hpbGQgYXMgY29tcGxldGVseSByZXNvbHZlZCBieSBkZWxldGluZyBpdCBmcm9tIC5fbWFwLlxuXHRcdC8vIFRoaXMgaXMgdXNlZCB0byBmaWd1cmUgb3V0IHdoZW4gKmFsbCogY2hpbGRyZW4gaGF2ZSBiZWVuIGNvbXBsZXRlbHlcblx0XHQvLyByZXNvbHZlZCB3aGVuIHJldmVhbE9yZGVyIGlzICd0b2dldGhlcicuXG5cdFx0bGlzdC5fbWFwLmRlbGV0ZShjaGlsZCk7XG5cdH1cblxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyBmYWxzeSB0aGVuIHdlIGNhbiBkbyBhbiBlYXJseSBleGl0LCBhcyB0aGVcblx0Ly8gY2FsbGJhY2tzIHdvbid0IGdldCBxdWV1ZWQgaW4gdGhlIG5vZGUgYW55d2F5LlxuXHQvLyBJZiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInIHRoZW4gYWxzbyBkbyBhbiBlYXJseSBleGl0XG5cdC8vIGlmIGFsbCBzdXNwZW5kZWQgZGVzY2VuZGFudHMgaGF2ZSBub3QgeWV0IGJlZW4gcmVzb2x2ZWQuXG5cdGlmIChcblx0XHQhbGlzdC5wcm9wcy5yZXZlYWxPcmRlciB8fFxuXHRcdChsaXN0LnByb3BzLnJldmVhbE9yZGVyWzBdID09PSAndCcgJiYgbGlzdC5fbWFwLnNpemUpXG5cdCkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFdhbGsgdGhlIGN1cnJlbnRseSBzdXNwZW5kZWQgY2hpbGRyZW4gaW4gb3JkZXIsIGNhbGxpbmcgdGhlaXJcblx0Ly8gc3RvcmVkIGNhbGxiYWNrcyBvbiB0aGUgd2F5LiBTdG9wIGlmIHdlIGVuY291bnRlciBhIGNoaWxkIHRoYXRcblx0Ly8gaGFzIG5vdCBiZWVuIGNvbXBsZXRlbHkgcmVzb2x2ZWQgeWV0LlxuXHRub2RlID0gbGlzdC5fbmV4dDtcblx0d2hpbGUgKG5vZGUpIHtcblx0XHR3aGlsZSAobm9kZS5sZW5ndGggPiAzKSB7XG5cdFx0XHRub2RlLnBvcCgpKCk7XG5cdFx0fVxuXHRcdGlmIChub2RlW1JFU09MVkVEX0NPVU5UXSA8IG5vZGVbU1VTUEVOREVEX0NPVU5UXSkge1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGxpc3QuX25leHQgPSBub2RlID0gbm9kZVtORVhUX05PREVdO1xuXHR9XG59O1xuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuXG5TdXNwZW5zZUxpc3QucHJvdG90eXBlLl9zdXNwZW5kZWQgPSBmdW5jdGlvbihjaGlsZCkge1xuXHRjb25zdCBsaXN0ID0gdGhpcztcblx0Y29uc3QgZGVsZWdhdGVkID0gc3VzcGVuZGVkKGxpc3QuX3Zub2RlKTtcblxuXHRsZXQgbm9kZSA9IGxpc3QuX21hcC5nZXQoY2hpbGQpO1xuXHRub2RlW1NVU1BFTkRFRF9DT1VOVF0rKztcblxuXHRyZXR1cm4gdW5zdXNwZW5kID0+IHtcblx0XHRjb25zdCB3cmFwcGVkVW5zdXNwZW5kID0gKCkgPT4ge1xuXHRcdFx0aWYgKCFsaXN0LnByb3BzLnJldmVhbE9yZGVyKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSB0aGUgdW5kZWZpbmVkIChmYWxzeSkgcmV2ZWFsT3JkZXIsIGFzIHRoZXJlXG5cdFx0XHRcdC8vIGlzIG5vIG5lZWQgdG8gY29vcmRpbmF0ZSBhIHNwZWNpZmljIG9yZGVyIG9yIHVuc3VzcGVuZHMuXG5cdFx0XHRcdHVuc3VzcGVuZCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5wdXNoKHVuc3VzcGVuZCk7XG5cdFx0XHRcdHJlc29sdmUobGlzdCwgY2hpbGQsIG5vZGUpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0aWYgKGRlbGVnYXRlZCkge1xuXHRcdFx0ZGVsZWdhdGVkKHdyYXBwZWRVbnN1c3BlbmQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3cmFwcGVkVW5zdXNwZW5kKCk7XG5cdFx0fVxuXHR9O1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcykge1xuXHR0aGlzLl9uZXh0ID0gbnVsbDtcblx0dGhpcy5fbWFwID0gbmV3IE1hcCgpO1xuXG5cdGNvbnN0IGNoaWxkcmVuID0gdG9DaGlsZEFycmF5KHByb3BzLmNoaWxkcmVuKTtcblx0aWYgKHByb3BzLnJldmVhbE9yZGVyICYmIHByb3BzLnJldmVhbE9yZGVyWzBdID09PSAnYicpIHtcblx0XHQvLyBJZiBvcmRlciA9PT0gJ2JhY2t3YXJkcycgKG9yLCB3ZWxsLCBhbnl0aGluZyBzdGFydGluZyB3aXRoIGEgJ2InKVxuXHRcdC8vIHRoZW4gZmxpcCB0aGUgY2hpbGQgbGlzdCBhcm91bmQgc28gdGhhdCB0aGUgbGFzdCBjaGlsZCB3aWxsIGJlXG5cdFx0Ly8gdGhlIGZpcnN0IGluIHRoZSBsaW5rZWQgbGlzdC5cblx0XHRjaGlsZHJlbi5yZXZlcnNlKCk7XG5cdH1cblx0Ly8gQnVpbGQgdGhlIGxpbmtlZCBsaXN0LiBJdGVyYXRlIHRocm91Z2ggdGhlIGNoaWxkcmVuIGluIHJldmVyc2Ugb3JkZXJcblx0Ly8gc28gdGhhdCBgX25leHRgIHBvaW50cyB0byB0aGUgZmlyc3QgbGlua2VkIGxpc3Qgbm9kZSB0byBiZSByZXNvbHZlZC5cblx0Zm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aDsgaS0tOyApIHtcblx0XHQvLyBDcmVhdGUgYSBuZXcgbGlua2VkIGxpc3Qgbm9kZSBhcyBhbiBhcnJheSBvZiBmb3JtOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZV1cblx0XHQvLyB3aGVyZSBzdXNwZW5kZWRfY291bnQgYW5kIHJlc29sdmVkX2NvdW50IGFyZSBudW1lcmljIGNvdW50ZXJzIGZvclxuXHRcdC8vIGtlZXBpbmcgdHJhY2sgaG93IG1hbnkgdGltZXMgYSBub2RlIGhhcyBiZWVuIHN1c3BlbmRlZCBhbmQgcmVzb2x2ZWQuXG5cdFx0Ly9cblx0XHQvLyBOb3RlIHRoYXQgc3VzcGVuZGVkX2NvdW50IHN0YXJ0cyBmcm9tIDEgaW5zdGVhZCBvZiAwLCBzbyB3ZSBjYW4gYmxvY2tcblx0XHQvLyBwcm9jZXNzaW5nIGNhbGxiYWNrcyB1bnRpbCBjb21wb25lbnREaWRNb3VudCBoYXMgYmVlbiBjYWxsZWQuIEluIGEgc2Vuc2Vcblx0XHQvLyBub2RlIGlzIHN1c3BlbmRlZCBhdCBsZWFzdCB1bnRpbCBjb21wb25lbnREaWRNb3VudCBnZXRzIGNhbGxlZCFcblx0XHQvL1xuXHRcdC8vIFBlbmRpbmcgY2FsbGJhY2tzIGFyZSBhZGRlZCB0byB0aGUgZW5kIG9mIHRoZSBub2RlOlxuXHRcdC8vIFx0W3N1c3BlbmRlZF9jb3VudCwgcmVzb2x2ZWRfY291bnQsIG5leHRfbm9kZSwgY2FsbGJhY2tfMCwgY2FsbGJhY2tfMSwgLi4uXVxuXHRcdHRoaXMuX21hcC5zZXQoY2hpbGRyZW5baV0sICh0aGlzLl9uZXh0ID0gWzEsIDAsIHRoaXMuX25leHRdKSk7XG5cdH1cblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBTdXNwZW5zZUxpc3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24oKSB7XG5cdC8vIEl0ZXJhdGUgdGhyb3VnaCBhbGwgY2hpbGRyZW4gYWZ0ZXIgbW91bnRpbmcgZm9yIHR3byByZWFzb25zOlxuXHQvLyAxLiBBcyBlYWNoIG5vZGVbU1VTUEVOREVEX0NPVU5UXSBzdGFydHMgZnJvbSAxLCB0aGlzIGl0ZXJhdGlvbiBpbmNyZWFzZXNcblx0Ly8gICAgZWFjaCBub2RlW1JFTEVBU0VEX0NPVU5UXSBieSAxLCB0aGVyZWZvcmUgYmFsYW5jaW5nIHRoZSBjb3VudGVycy5cblx0Ly8gICAgVGhlIG5vZGVzIGNhbiBub3cgYmUgY29tcGxldGVseSBjb25zdW1lZCBmcm9tIHRoZSBsaW5rZWQgbGlzdC5cblx0Ly8gMi4gSGFuZGxlIG5vZGVzIHRoYXQgbWlnaHQgaGF2ZSBnb3R0ZW4gcmVzb2x2ZWQgYmV0d2VlbiByZW5kZXIgYW5kXG5cdC8vICAgIGNvbXBvbmVudERpZE1vdW50LlxuXHR0aGlzLl9tYXAuZm9yRWFjaCgobm9kZSwgY2hpbGQpID0+IHtcblx0XHRyZXNvbHZlKHRoaXMsIGNoaWxkLCBub2RlKTtcblx0fSk7XG59O1xuIiwiaW1wb3J0IHtcblx0cmVuZGVyIGFzIHByZWFjdFJlbmRlcixcblx0aHlkcmF0ZSBhcyBwcmVhY3RIeWRyYXRlLFxuXHRvcHRpb25zLFxuXHR0b0NoaWxkQXJyYXksXG5cdENvbXBvbmVudFxufSBmcm9tICdwcmVhY3QnO1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRUxFTUVOVF9UWVBFID1cblx0KHR5cGVvZiBTeW1ib2wgIT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLmZvciAmJiBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG5cdDB4ZWFjNztcblxuY29uc3QgQ0FNRUxfUFJPUFMgPSAvXig/OmFjY2VudHxhbGlnbm1lbnR8YXJhYmljfGJhc2VsaW5lfGNhcHxjbGlwKD8hUGF0aFUpfGNvbG9yfGRvbWluYW50fGZpbGx8Zmxvb2R8Zm9udHxnbHlwaCg/IVIpfGhvcml6fG1hcmtlcig/IUh8V3xVKXxvdmVybGluZXxwYWludHxzaGFwZXxzdG9wfHN0cmlrZXRocm91Z2h8c3Ryb2tlfHRleHQoPyFMKXx1bmRlcmxpbmV8dW5pY29kZXx1bml0c3x2fHZlY3Rvcnx2ZXJ0fHdvcmR8d3JpdGluZ3x4KD8hQykpW0EtWl0vO1xuXG5jb25zdCBJU19ET00gPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuXG4vLyBJbnB1dCB0eXBlcyBmb3Igd2hpY2ggb25jaGFuZ2Ugc2hvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gb25pbnB1dC5cbi8vIHR5cGU9XCJmaWxlfGNoZWNrYm94fHJhZGlvXCIsIHBsdXMgXCJyYW5nZVwiIGluIElFMTEuXG4vLyAoSUUxMSBkb2Vzbid0IHN1cHBvcnQgU3ltYm9sLCB3aGljaCB3ZSB1c2UgaGVyZSB0byB0dXJuIGByYWRgIGludG8gYHJhYCB3aGljaCBtYXRjaGVzIFwicmFuZ2VcIilcbmNvbnN0IG9uQ2hhbmdlSW5wdXRUeXBlID0gdHlwZSA9PlxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sKCkgPT0gJ3N5bWJvbCdcblx0XHQ/IC9maWx8Y2hlfHJhZC9pXG5cdFx0OiAvZmlsfGNoZXxyYS9pXG5cdCkudGVzdCh0eXBlKTtcblxuLy8gU29tZSBsaWJyYXJpZXMgbGlrZSBgcmVhY3QtdmlydHVhbGl6ZWRgIGV4cGxpY2l0bHkgY2hlY2sgZm9yIHRoaXMuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLy8gYFVOU0FGRV8qYCBsaWZlY3ljbGUgaG9va3Ncbi8vIFByZWFjdCBvbmx5IGV2ZXIgaW52b2tlcyB0aGUgdW5wcmVmaXhlZCBtZXRob2RzLlxuLy8gSGVyZSB3ZSBwcm92aWRlIGEgYmFzZSBcImZhbGxiYWNrXCIgaW1wbGVtZW50YXRpb24gdGhhdCBjYWxscyBhbnkgZGVmaW5lZCBVTlNBRkVfIHByZWZpeGVkIG1ldGhvZC5cbi8vIC0gSWYgYSBjb21wb25lbnQgZGVmaW5lcyBpdHMgb3duIGBjb21wb25lbnREaWRNb3VudCgpYCAoaW5jbHVkaW5nIHZpYSBkZWZpbmVQcm9wZXJ0eSksIHVzZSB0aGF0LlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGBVTlNBRkVfY29tcG9uZW50RGlkTW91bnQoKWAsIGBjb21wb25lbnREaWRNb3VudGAgaXMgdGhlIGFsaWFzIGdldHRlci9zZXR0ZXIuXG4vLyAtIElmIGFueXRoaW5nIGFzc2lnbnMgdG8gYW4gYFVOU0FGRV8qYCBwcm9wZXJ0eSwgdGhlIGFzc2lnbm1lbnQgaXMgZm9yd2FyZGVkIHRvIHRoZSB1bnByZWZpeGVkIHByb3BlcnR5LlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcmVhY3Rqcy9wcmVhY3QvaXNzdWVzLzE5NDFcbltcblx0J2NvbXBvbmVudFdpbGxNb3VudCcsXG5cdCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcblx0J2NvbXBvbmVudFdpbGxVcGRhdGUnXG5dLmZvckVhY2goa2V5ID0+IHtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIGtleSwge1xuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRnZXQoKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1snVU5TQUZFXycgKyBrZXldO1xuXHRcdH0sXG5cdFx0c2V0KHYpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBrZXksIHtcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHZcblx0XHRcdH0pO1xuXHRcdH1cblx0fSk7XG59KTtcblxuLyoqXG4gKiBQcm94eSByZW5kZXIoKSBzaW5jZSBSZWFjdCByZXR1cm5zIGEgQ29tcG9uZW50IHJlZmVyZW5jZS5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlIFZOb2RlIHRyZWUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudCBET00gbm9kZSB0byByZW5kZXIgdm5vZGUgdHJlZSBpbnRvXG4gKiBAcGFyYW0geygpID0+IHZvaWR9IFtjYWxsYmFja10gT3B0aW9uYWwgY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGNhbGxlZCBhZnRlciByZW5kZXJpbmdcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQgfCBudWxsfSBUaGUgcm9vdCBjb21wb25lbnQgcmVmZXJlbmNlIG9yIG51bGxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcih2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHQvLyBSZWFjdCBkZXN0cm95cyBhbnkgZXhpc3RpbmcgRE9NIG5vZGVzLCBzZWUgIzE3Mjdcblx0Ly8gLi4uYnV0IG9ubHkgb24gdGhlIGZpcnN0IHJlbmRlciwgc2VlICMxODI4XG5cdGlmIChwYXJlbnQuX2NoaWxkcmVuID09IG51bGwpIHtcblx0XHRwYXJlbnQudGV4dENvbnRlbnQgPSAnJztcblx0fVxuXG5cdHByZWFjdFJlbmRlcih2bm9kZSwgcGFyZW50KTtcblx0aWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuXG5cdHJldHVybiB2bm9kZSA/IHZub2RlLl9jb21wb25lbnQgOiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaHlkcmF0ZSh2bm9kZSwgcGFyZW50LCBjYWxsYmFjaykge1xuXHRwcmVhY3RIeWRyYXRlKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmxldCBvbGRFdmVudEhvb2sgPSBvcHRpb25zLmV2ZW50O1xub3B0aW9ucy5ldmVudCA9IGUgPT4ge1xuXHRpZiAob2xkRXZlbnRIb29rKSBlID0gb2xkRXZlbnRIb29rKGUpO1xuXHRlLnBlcnNpc3QgPSBlbXB0eTtcblx0ZS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGlzUHJvcGFnYXRpb25TdG9wcGVkO1xuXHRlLmlzRGVmYXVsdFByZXZlbnRlZCA9IGlzRGVmYXVsdFByZXZlbnRlZDtcblx0cmV0dXJuIChlLm5hdGl2ZUV2ZW50ID0gZSk7XG59O1xuXG5mdW5jdGlvbiBlbXB0eSgpIHt9XG5cbmZ1bmN0aW9uIGlzUHJvcGFnYXRpb25TdG9wcGVkKCkge1xuXHRyZXR1cm4gdGhpcy5jYW5jZWxCdWJibGU7XG59XG5cbmZ1bmN0aW9uIGlzRGVmYXVsdFByZXZlbnRlZCgpIHtcblx0cmV0dXJuIHRoaXMuZGVmYXVsdFByZXZlbnRlZDtcbn1cblxubGV0IGNsYXNzTmFtZURlc2NyaXB0b3IgPSB7XG5cdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0Z2V0KCkge1xuXHRcdHJldHVybiB0aGlzLmNsYXNzO1xuXHR9XG59O1xuXG5sZXQgb2xkVk5vZGVIb29rID0gb3B0aW9ucy52bm9kZTtcbm9wdGlvbnMudm5vZGUgPSB2bm9kZSA9PiB7XG5cdGxldCB0eXBlID0gdm5vZGUudHlwZTtcblx0bGV0IHByb3BzID0gdm5vZGUucHJvcHM7XG5cdGxldCBub3JtYWxpemVkUHJvcHMgPSBwcm9wcztcblxuXHQvLyBvbmx5IG5vcm1hbGl6ZSBwcm9wcyBvbiBFbGVtZW50IG5vZGVzXG5cdGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRjb25zdCBub25DdXN0b21FbGVtZW50ID0gdHlwZS5pbmRleE9mKCctJykgPT09IC0xO1xuXHRcdG5vcm1hbGl6ZWRQcm9wcyA9IHt9O1xuXG5cdFx0Zm9yIChsZXQgaSBpbiBwcm9wcykge1xuXHRcdFx0bGV0IHZhbHVlID0gcHJvcHNbaV07XG5cblx0XHRcdGlmIChJU19ET00gJiYgaSA9PT0gJ2NoaWxkcmVuJyAmJiB0eXBlID09PSAnbm9zY3JpcHQnKSB7XG5cdFx0XHRcdC8vIEVtdWxhdGUgUmVhY3QncyBiZWhhdmlvciBvZiBub3QgcmVuZGVyaW5nIHRoZSBjb250ZW50cyBvZiBub3NjcmlwdCB0YWdzIG9uIHRoZSBjbGllbnQuXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAndmFsdWUnICYmICdkZWZhdWx0VmFsdWUnIGluIHByb3BzICYmIHZhbHVlID09IG51bGwpIHtcblx0XHRcdFx0Ly8gU2tpcCBhcHBseWluZyB2YWx1ZSBpZiBpdCBpcyBudWxsL3VuZGVmaW5lZCBhbmQgd2UgYWxyZWFkeSBzZXRcblx0XHRcdFx0Ly8gYSBkZWZhdWx0IHZhbHVlXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0aSA9PT0gJ2RlZmF1bHRWYWx1ZScgJiZcblx0XHRcdFx0J3ZhbHVlJyBpbiBwcm9wcyAmJlxuXHRcdFx0XHRwcm9wcy52YWx1ZSA9PSBudWxsXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgaXMgdHJlYXRlZCBhcyBhIGZhbGxiYWNrIGB2YWx1ZWAgd2hlbiBhIHZhbHVlIHByb3AgaXMgcHJlc2VudCBidXQgbnVsbC91bmRlZmluZWQuXG5cdFx0XHRcdC8vIGBkZWZhdWx0VmFsdWVgIGZvciBFbGVtZW50cyB3aXRoIG5vIHZhbHVlIHByb3AgaXMgdGhlIHNhbWUgYXMgdGhlIERPTSBkZWZhdWx0VmFsdWUgcHJvcGVydHkuXG5cdFx0XHRcdGkgPSAndmFsdWUnO1xuXHRcdFx0fSBlbHNlIGlmIChpID09PSAnZG93bmxvYWQnICYmIHZhbHVlID09PSB0cnVlKSB7XG5cdFx0XHRcdC8vIENhbGxpbmcgYHNldEF0dHJpYnV0ZWAgd2l0aCBhIHRydXRoeSB2YWx1ZSB3aWxsIGxlYWQgdG8gaXQgYmVpbmdcblx0XHRcdFx0Ly8gcGFzc2VkIGFzIGEgc3RyaW5naWZpZWQgdmFsdWUsIGUuZy4gYGRvd25sb2FkPVwidHJ1ZVwiYC4gUmVhY3Rcblx0XHRcdFx0Ly8gY29udmVydHMgaXQgdG8gYW4gZW1wdHkgc3RyaW5nIGluc3RlYWQsIG90aGVyd2lzZSB0aGUgYXR0cmlidXRlXG5cdFx0XHRcdC8vIHZhbHVlIHdpbGwgYmUgdXNlZCBhcyB0aGUgZmlsZSBuYW1lIGFuZCB0aGUgZmlsZSB3aWxsIGJlIGNhbGxlZFxuXHRcdFx0XHQvLyBcInRydWVcIiB1cG9uIGRvd25sb2FkaW5nIGl0LlxuXHRcdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdFx0fSBlbHNlIGlmICgvb25kb3VibGVjbGljay9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmRibGNsaWNrJztcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdC9eb25jaGFuZ2UodGV4dGFyZWF8aW5wdXQpL2kudGVzdChpICsgdHlwZSkgJiZcblx0XHRcdFx0IW9uQ2hhbmdlSW5wdXRUeXBlKHByb3BzLnR5cGUpXG5cdFx0XHQpIHtcblx0XHRcdFx0aSA9ICdvbmlucHV0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbmZvY3VzJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3VzaW4nO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uYmx1ciQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSAnb25mb2N1c291dCc7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb24oQW5pfFRyYXxUb3V8QmVmb3JlSW5wfENvbXBvKS8udGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0fSBlbHNlIGlmIChub25DdXN0b21FbGVtZW50ICYmIENBTUVMX1BST1BTLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9IGkucmVwbGFjZSgvW0EtWjAtOV0vLCAnLSQmJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBzdXBwb3J0IGZvciBvbklucHV0IGFuZCBvbkNoYW5nZSwgc2VlICMzNTYxXG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGFuIG9uaW5wdXQgcHJvcCBhbHJlYWR5IGNoYW5nZSBpdCB0byBvbmlucHV0Q2FwdHVyZVxuXHRcdFx0aWYgKC9eb25pbnB1dCQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0pIHtcblx0XHRcdFx0XHRpID0gJ29uaW5wdXRDYXB0dXJlJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgc3VwcG9ydCBmb3IgYXJyYXkgc2VsZWN0IHZhbHVlczogPHNlbGVjdCBtdWx0aXBsZSB2YWx1ZT17W119IC8+XG5cdFx0aWYgKFxuXHRcdFx0dHlwZSA9PSAnc2VsZWN0JyAmJlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLm11bHRpcGxlICYmXG5cdFx0XHRBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSlcblx0XHQpIHtcblx0XHRcdC8vIGZvckVhY2goKSBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHdoaWNoIHdlIGFidXNlIGhlcmUgdG8gdW5zZXQgdGhlIHZhbHVlIHByb3AuXG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkaW5nIHN1cHBvcnQgZm9yIGRlZmF1bHRWYWx1ZSBpbiBzZWxlY3QgdGFnXG5cdFx0aWYgKHR5cGUgPT0gJ3NlbGVjdCcgJiYgbm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzLm11bHRpcGxlKSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlID09IGNoaWxkLnByb3BzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2bm9kZS5wcm9wcyA9IG5vcm1hbGl6ZWRQcm9wcztcblxuXHRcdGlmIChwcm9wcy5jbGFzcyAhPSBwcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIHByb3BzO1xuXHRcdFx0aWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSBub3JtYWxpemVkUHJvcHMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsaXplZFByb3BzLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG5cdFx0fVxuXHR9XG5cblx0dm5vZGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblx0aWYgKG9sZFZOb2RlSG9vaykgb2xkVk5vZGVIb29rKHZub2RlKTtcbn07XG5cbi8vIE9ubHkgbmVlZGVkIGZvciByZWFjdC1yZWxheVxubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5jb25zdCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5vcHRpb25zLl9yZW5kZXIgPSBmdW5jdGlvbih2bm9kZSkge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSB7XG5cdFx0b2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcbn07XG5cbi8vIFRoaXMgaXMgYSB2ZXJ5IHZlcnkgcHJpdmF0ZSBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgUmVhY3QgaXRcbi8vIGlzIHVzZWQgdG8gc29ydC1vZiBkbyBydW50aW1lIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBTbyBmYXJcbi8vIG9ubHkgYHJlYWN0LXJlbGF5YCBtYWtlcyB1c2Ugb2YgaXQuIEl0IHVzZXMgaXQgdG8gcmVhZCB0aGVcbi8vIGNvbnRleHQgdmFsdWUuXG5leHBvcnQgY29uc3QgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSB7XG5cdFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IHtcblx0XHRjdXJyZW50OiB7XG5cdFx0XHRyZWFkQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50Q29tcG9uZW50Ll9nbG9iYWxDb250ZXh0W2NvbnRleHQuX2lkXS5wcm9wcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuZXhwb3J0IHR5cGUgUGFzc2l2ZVN0YXRlVXBkYXRlcjxTPiA9ICh2YWx1ZTogUyB8ICgocHJldlN0YXRlOiBTIHwgdW5kZWZpbmVkKSA9PiBTKSkgPT4gdm9pZDtcclxuZXhwb3J0IHR5cGUgT25QYXNzaXZlU3RhdGVDaGFuZ2U8VD4gPSAoKHZhbHVlOiBULCBwcmV2VmFsdWU6IFQgfCB1bmRlZmluZWQpID0+ICh2b2lkIHwgKCgpID0+IHZvaWQpKSk7XHJcblxyXG4vKipcclxuICogRGVidWcgaG9vay5cclxuICogXHJcbiAqIEdpdmVuIGEgdmFsdWUgb3Igc2V0IG9mIHZhbHVlcywgZW1pdHMgYSBjb25zb2xlIGVycm9yIGlmIGFueSBvZiB0aGVtIGNoYW5nZSBmcm9tIG9uZSByZW5kZXIgdG8gdGhlIG5leHQuXHJcbiAqIFxyXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVuc3VyZVN0YWJpbGl0eTxUIGV4dGVuZHMgYW55W10+KHBhcmVudEhvb2tOYW1lOiBzdHJpbmcsIC4uLnZhbHVlczogVCkge1xyXG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGgsIDApO1xyXG4gICAgdmFsdWVzLmZvckVhY2godXNlSGVscGVyKTtcclxuICAgIHJldHVybjtcclxuXHJcblxyXG4gICAgZnVuY3Rpb24gdXNlSGVscGVyPFU+KHZhbHVlOiBVLCBpbmRleDogbnVtYmVyKSB7XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcclxuICAgICAgICBjb25zdCBoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eSA9IHVzZVJlZih2YWx1ZSk7XHJcbiAgICAgICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICAgICAgaWYgKGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5LmN1cnJlbnQgIT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgaWYgKCFzaG93bkVycm9yLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBob29rICR7cGFyZW50SG9va05hbWV9IHJlcXVpcmVzIHNvbWUgb3IgYWxsIG9mIGl0cyBhcmd1bWVudHMgcmVtYWluIHN0YWJsZSBhY3Jvc3MgZWFjaCByZW5kZXI7IHBsZWFzZSBjaGVjayB0aGUgJHtpbmRleH0taW5kZXhlZCBhcmd1bWVudC5gKTtcclxuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBTaW1pbGFyIHRvIGB1c2VTdGF0ZWAsIGJ1dCBmb3IgdmFsdWVzIHRoYXQgYXJlbid0IFwicmVuZGVyLWltcG9ydGFudFwiICZuZGFzaDsgdXBkYXRlcyBkb24ndCBjYXVzZSBhIHJlLXJlbmRlciBhbmQgc28gdGhlIHZhbHVlIHNob3VsZG4ndCBiZSB1c2VkIGR1cmluZyByZW5kZXIgKHRob3VnaCBpdCBjZXJ0YWlubHkgY2FuLCBhdCBsZWFzdCBieSByZS1yZW5kZXJpbmcgYWdhaW4pLlxyXG4gKiBcclxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBUbyBzdW1tYXJpemUsIGl0J3MgbGlrZSBhIGB1c2VTdGF0ZWAtYHVzZUVmZmVjdGAgbWFzaHVwOlxyXG4gKiBcclxuICogMS4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB0aGlzIHZlcnNpb24gb2YgYHNldFN0YXRlYCBkb2Vzbid0IHJlLXJlbmRlciB0aGUgd2hvbGUgY29tcG9uZW50XHJcbiAqIDIuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgeW91IGNhbiBydW4gYSBmdW5jdGlvbiB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzIHRoYXQgb3B0aW9uYWxseSByZXR1cm5zIGEgY2xlYW51cCBmdW5jdGlvblxyXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXHJcbiAqIDQuIEl0J3MgbGlrZSBgdXNlRWZmZWN0YCwgZXhjZXB0IHRoZSBzaW5nbGUgXCJkZXBlbmRlbmN5XCIgaXMgYmFzZWQgb24geW91ciBjYWxscyB0byBgc2V0U3RhdGVgXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cclxuICogXHJcbiAqIEBwYXJhbSBvbkNoYW5nZSBUaGUgXCJlZmZlY3RcIiBmdW5jdGlvbiB0byBydW4gd2hlbiB0aGUgdmFsdWUgY2hhbmdlcy4gRWZmZWN0aXZlbHkgdGhlIHNhbWUgYXMgYHVzZUVmZmVjdGAncyBcImVmZmVjdFwiIGZ1bmN0aW9uLiAgTVVTVCBCRSBTVEFCTEUsIGVpdGhlciBiZWNhdXNlIGl0IGhhcyBubyBkZXBlbmRlbmNpZXMsIG9yIGJlY2F1c2UgaXQncyBmcm9tIHVzZVN0YWJsZUNhbGxiYWNrLCBidXQgdGhpcyB3aWxsIG1lYW4geW91IGNhbm5vdCB1c2UgZ2V0U3RhdGUgb3Igc2V0U3RhdGUgZHVyaW5nIHJlbmRlci5cclxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhc3NpdmVTdGF0ZTxUPihvbkNoYW5nZTogdW5kZWZpbmVkIHwgbnVsbCB8IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQ+LCBnZXRJbml0aWFsVmFsdWU/OiAoKSA9PiBUKTogcmVhZG9ubHkgW2dldFN0YXRlU3RhYmxlOiAoKSA9PiBULCBzZXRTdGF0ZVN0YWJsZTogUGFzc2l2ZVN0YXRlVXBkYXRlcjxUPl0ge1xyXG5cclxuICAgIGNvbnN0IHZhbHVlUmVmID0gdXNlUmVmPFQgfCB0eXBlb2YgVW5zZXQ+KFVuc2V0KTtcclxuICAgIGNvbnN0IHdhcm5pbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSk7XHJcblxyXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXHJcbiAgICBjb25zdCBvblNob3VsZENsZWFuVXAgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY2xlYW51cENhbGxiYWNrID0gY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcclxuICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrKCk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gVGhlcmUgYXJlIGEgY291cGxlIHBsYWNlcyB3aGVyZSB3ZSdkIGxpa2UgdG8gdXNlIG91ciBpbml0aWFsXHJcbiAgICAvLyB2YWx1ZSBpbiBwbGFjZSBvZiBoYXZpbmcgbm8gdmFsdWUgYXQgYWxsIHlldC5cclxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxyXG4gICAgLy8gZ2V0VmFsdWUgaXMgY2FsbGVkLlxyXG4gICAgY29uc3QgdHJ5RW5zdXJlVmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluaXRpYWxWYWx1ZSA9IGdldEluaXRpYWxWYWx1ZSgpO1xyXG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGNsZWFudXBDYWxsYmFja1JlZi5jdXJyZW50ID0gKG9uQ2hhbmdlPy4oaW5pdGlhbFZhbHVlLCB1bmRlZmluZWQpID8/IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XHJcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHRpb25zIGFyZSBpbnRlbnRpb25hbCB0byBhbGxvdyBiYWlsb3V0ICh3aXRob3V0IGV4cG9zaW5nIHRoZSBVbnNldCBzeW1ib2wpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbLyogZ2V0SW5pdGlhbFZhbHVlIGFuZCBvbkNoYW5nZSBpbnRlbnRpb25hbGx5IG9taXR0ZWQgKi9dKTtcclxuXHJcblxyXG4gICAgY29uc3QgZ2V0VmFsdWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgaWYgKHdhcm5pbmdSZWYuY3VycmVudClcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcclxuXHJcbiAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgd2UgY2FsbCBnZXRWYWx1ZSwgaWYgd2UgaGF2ZW4ndCBiZWVuIGdpdmVuIGEgdmFsdWUgeWV0LFxyXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcclxuICAgICAgICAvLyByZXR1cm4gdGhlIGluaXRpYWwgdmFsdWUgaW5zdGVhZCBvZiBub3RoaW5nLlxyXG4gICAgICAgIGlmICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldClcclxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcclxuXHJcbiAgICAgICAgcmV0dXJuICh2YWx1ZVJlZi5jdXJyZW50ID09PSBVbnNldCA/IHVuZGVmaW5lZCEgOiB2YWx1ZVJlZi5jdXJyZW50ISkgYXMgVDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxyXG4gICAgICAgIC8vIChJZiB3ZSBoYXZlIGFuIGluaXRpYWwgdmFsdWUsIG9mIGNvdXJzZSlcclxuICAgICAgICB0cnlFbnN1cmVWYWx1ZSgpO1xyXG5cclxuXHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gVGhlIGFjdHVhbCBjb2RlIHRoZSB1c2VyIGNhbGxzIHRvIChwb3NzaWJseSkgcnVuIGEgbmV3IGVmZmVjdC5cclxuICAgIGNvbnN0IHIgPSB1c2VSZWYoeyBtaWNyb3Rhc2tRdWV1ZWQ6IGZhbHNlLCBhcmc6IHVuZGVmaW5lZCBhcyB1bmRlZmluZWQgfCBQYXJhbWV0ZXJzPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+WzBdLCBwcmV2RGVwOiB1bmRlZmluZWQgYXMgVCB8IHVuZGVmaW5lZCwgaGFuZGxlOiBudWxsIGFzIG51bWJlciB8IG51bGwgfSk7XHJcbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChhcmcpID0+IHtcclxuICAgICAgICByLmN1cnJlbnQucHJldkRlcCA9IHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogZ2V0VmFsdWUoKTtcclxuICAgICAgICByLmN1cnJlbnQuYXJnID0gYXJnO1xyXG4gICAgICAgIGlmICghci5jdXJyZW50Lm1pY3JvdGFza1F1ZXVlZCkge1xyXG4gICAgICAgICAgICByLmN1cnJlbnQubWljcm90YXNrUXVldWVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgci5jdXJyZW50LmhhbmRsZSA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgci5jdXJyZW50Lm1pY3JvdGFza1F1ZXVlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgci5jdXJyZW50LmhhbmRsZSA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gci5jdXJyZW50LnByZXZEZXA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSByLmN1cnJlbnQuYXJnITtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlcCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHByZXZEZXAhKSA6IGFyZztcclxuICAgICAgICAgICAgICAgIGlmIChkZXAgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgdG8gdGhlIHVzZXIgdGhhdCB0aGV5IHNob3VsZG4ndCBjYWxsIGdldFZhbHVlIGR1cmluZyBvbkNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBvblNob3VsZENsZWFuVXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYW51cENhbGxiYWNrUmVmLmN1cnJlbnQgPSAob25DaGFuZ2U/LihkZXAsIHByZXZEZXApID8/IHVuZGVmaW5lZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBkZXA7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHVzZXIgdG8gbm9ybWFsbHkgY2FsbCBnZXRWYWx1ZSBhZ2FpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9LCAwKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XHJcbn1cclxuXHJcbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XHJcblxyXG4vLyBFYXN5IGNvbnN0YW50cyBmb3IgZ2V0SW5pdGlhbFZhbHVlXHJcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7IHJldHVybiBmYWxzZTsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuTnVsbCgpIHsgcmV0dXJuIG51bGw7IH1cclxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxyXG5leHBvcnQgZnVuY3Rpb24gcmV0dXJuWmVybygpIHsgcmV0dXJuIDA7IH0iLCJpbXBvcnQgeyBjcmVhdGVFbGVtZW50LCBGcmFnbWVudCwgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xyXG4gICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocztcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocztcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KEZyYWdtZW50LCB7fSwgbGhzLCByaHMpO1xyXG4gICAgfVxyXG59XHJcbiIsImZ1bmN0aW9uIHIoZSl7dmFyIHQsZixuPVwiXCI7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGV8fFwibnVtYmVyXCI9PXR5cGVvZiBlKW4rPWU7ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlpZihBcnJheS5pc0FycmF5KGUpKWZvcih0PTA7dDxlLmxlbmd0aDt0KyspZVt0XSYmKGY9cihlW3RdKSkmJihuJiYobis9XCIgXCIpLG4rPWYpO2Vsc2UgZm9yKHQgaW4gZSllW3RdJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZnVuY3Rpb24gY2xzeCgpe2Zvcih2YXIgZSx0LGY9MCxuPVwiXCI7Zjxhcmd1bWVudHMubGVuZ3RoOykoZT1hcmd1bWVudHNbZisrXSkmJih0PXIoZSkpJiYobiYmKG4rPVwiIFwiKSxuKz10KTtyZXR1cm4gbn1leHBvcnQgZGVmYXVsdCBjbHN4OyIsImltcG9ydCB7IGRlZmF1bHQgYXMgY2xzeCB9IGZyb20gXCJjbHN4XCI7XHJcbmltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVpciBgY2xhc3NgIGFuZCBgY2xhc3NOYW1lYCBwcm9wZXJ0aWVzLlxyXG4gKiBEdXBsaWNhdGUgY2xhc3NlcyBhcmUgcmVtb3ZlZCAob3JkZXIgZG9lc24ndCBtYXR0ZXIgYW55d2F5KS5cclxuICogXHJcbiAqIEBwYXJhbSBsaHMgQ2xhc3NlcyBvZiB0aGUgZmlyc3QgY29tcG9uZW50XHJcbiAqIEBwYXJhbSByaHMgQ2xhc3NlcyBvZiB0aGUgc2Vjb25kIGNvbXBvbmVudFxyXG4gKiBAcmV0dXJucyBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIGNvbWJpbmVkIGNsYXNzZXMgZnJvbSBib3RoIGFyZ3VtZW50cy5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDbGFzc2VzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyBjbGFzczogbGhzQ2xhc3MsIGNsYXNzTmFtZTogbGhzQ2xhc3NOYW1lIH06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+LCB7IGNsYXNzOiByaHNDbGFzcywgY2xhc3NOYW1lOiByaHNDbGFzc05hbWV9OiBQaWNrPGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+LCBcImNsYXNzXCIgfCBcImNsYXNzTmFtZVwiPik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XHJcblxyXG4gICAgLy8gTm90ZTogRm9yIHRoZSBzYWtlIG9mIGZvcndhcmQgY29tcGF0aWJpbGl0eSwgdGhpcyBmdW5jdGlvbiBpcyBsYWJlbGxlZCBhc1xyXG4gICAgLy8gYSBob29rLCBidXQgYXMgaXQgdXNlcyBubyBvdGhlciBob29rcyBpdCB0ZWNobmljYWxseSBpc24ndCBvbmUuXHJcblxyXG4gICAgaWYgKGxoc0NsYXNzIHx8IHJoc0NsYXNzIHx8IGxoc0NsYXNzTmFtZSB8fCByaHNDbGFzc05hbWUpIHtcclxuICAgICAgICBjb25zdCBsaHNDbGFzc2VzID0gY2xzeChsaHNDbGFzcywgbGhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgcmhzQ2xhc3NlcyA9IGNsc3gocmhzQ2xhc3MsIHJoc0NsYXNzTmFtZSkuc3BsaXQoXCIgXCIpO1xyXG4gICAgICAgIGNvbnN0IGFsbENsYXNzZXMgPSBuZXcgU2V0KFsuLi5BcnJheS5mcm9tKGxoc0NsYXNzZXMpLCAuLi5BcnJheS5mcm9tKHJoc0NsYXNzZXMpXSlcclxuXHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYWxsQ2xhc3Nlcykuam9pbihcIiBcIik7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGgsIFJlZiwgUmVmQ2FsbGJhY2ssIFJlZk9iamVjdCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuZnVuY3Rpb24gcHJvY2Vzc1JlZjxUPihpbnN0YW5jZTogVCB8IG51bGwsIHJlZjogUmVmPFQ+IHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHR5cGVvZiByZWYgPT09IFwiZnVuY3Rpb25cIikge1xyXG4gICAgICAgIHJlZihpbnN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyZWYgIT0gbnVsbCkge1xyXG4gICAgICAgIChyZWYgYXMgUmVmT2JqZWN0PFQgfCBudWxsPikuY3VycmVudCA9IGluc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSwgXCJVbmtub3duIHJlZiB0eXBlIGZvdW5kIHRoYXQgd2FzIG5laXRoZXIgYSBSZWZDYWxsYmFjayBub3IgYSBSZWZPYmplY3RcIik7XHJcbiAgICB9XHJcbn1cclxuXHJcbmludGVyZmFjZSBSPEU+IHtcclxuICAgIHJlZj86IFJlZjxFPjtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb21iaW5lcyB0d28gcmVmcyBpbnRvIG9uZS4gVGhpcyBhbGxvd3MgYSBjb21wb25lbnQgdG8gYm90aCB1c2UgaXRzIG93biByZWYgKmFuZCogZm9yd2FyZCBhIHJlZiB0aGF0IHdhcyBnaXZlbiB0byBpdC5cclxuICogQHBhcmFtIGxocyBcclxuICogQHBhcmFtIHJocyBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkUmVmczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KHsgcmVmOiByaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHsgcmVmOiBsaHMgfTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pIHtcclxuICAgIGNvbnN0IGNvbWJpbmVkOiBSZWZDYWxsYmFjazxFPiA9IHVzZUNhbGxiYWNrKChjdXJyZW50OiBFIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgbGhzKTtcclxuICAgICAgICBwcm9jZXNzUmVmKGN1cnJlbnQsIHJocyk7XHJcbiAgICB9LCBbbGhzLCByaHNdKTtcclxuXHJcbiAgICBpZiAobGhzID09IG51bGwgJiYgcmhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGxocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHJocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBsaHMhO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcblxyXG5mdW5jdGlvbiBzdHlsZVN0cmluZ1RvT2JqZWN0KHN0eWxlOiBzdHJpbmcpOiBoLkpTWC5DU1NQcm9wZXJ0aWVzIHtcclxuICAgIC8vIFRPRE86IFRoaXMgc3Vja3MgRDpcclxuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoc3R5bGUuc3BsaXQoXCI7XCIpLm1hcChzdGF0ZW1lbnQgPT4gc3RhdGVtZW50LnNwbGl0KFwiOlwiKSkpIGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxufVxyXG5cclxuLyoqXHJcbiAqIE1lcmdlcyB0d28gc3R5bGUgb2JqZWN0cywgcmV0dXJuaW5nIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBAcGFyYW0gc3R5bGUgVGhlIHVzZXItZ2l2ZW4gc3R5bGUgcHJvcCBmb3IgdGhpcyBjb21wb25lbnRcclxuICogQHBhcmFtIG9iaiBUaGUgQ1NTIHByb3BlcnRpZXMgeW91IHdhbnQgYWRkZWQgdG8gdGhlIHVzZXItZ2l2ZW4gc3R5bGVcclxuICogQHJldHVybnMgQSBDU1Mgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHByb3BlcnRpZXMgb2YgYm90aCBvYmplY3RzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyhsaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+LCByaHM6IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcInN0eWxlXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wic3R5bGVcIl0ge1xyXG5cclxuICAgIC8vIEVhc3kgY2FzZSwgd2hlbiB0aGVyZSBhcmUgbm8gc3R5bGVzIHRvIG1lcmdlIHJldHVybiBub3RoaW5nLlxyXG4gICAgaWYgKCFsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBsaHMgIT0gdHlwZW9mIHJocykge1xyXG4gICAgICAgIC8vIEVhc3kgY2FzZXMsIHdoZW4gb25lIGlzIG51bGwgYW5kIHRoZSBvdGhlciBpc24ndC5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiAhcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIGxocy5zdHlsZTtcclxuICAgICAgICBpZiAoIWxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSlcclxuICAgICAgICAgICAgcmV0dXJuIHJocy5zdHlsZTtcclxuXHJcbiAgICAgICAgLy8gVGhleSdyZSBib3RoIG5vbi1udWxsIGJ1dCBkaWZmZXJlbnQgdHlwZXMuXHJcbiAgICAgICAgLy8gQ29udmVydCB0aGUgc3RyaW5nIHR5cGUgdG8gYW4gb2JqZWN0IGJhZyB0eXBlIGFuZCBydW4gaXQgYWdhaW4uXHJcbiAgICAgICAgaWYgKGxocz8uc3R5bGUgJiYgcmhzPy5zdHlsZSkge1xyXG4gICAgICAgICAgICAvLyAodXNlTWVyZ2VkU3R5bGVzIGlzbid0IGEgdHJ1ZSBob29rIC0tIHRoaXMgaXNuJ3QgYSB2aW9sYXRpb24pXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyh7IHN0eWxlOiBzdHlsZVN0cmluZ1RvT2JqZWN0KGxocz8uc3R5bGUgYXMgc3RyaW5nKSB9LCByaHMpIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFN0eWxlcyhsaHMsIHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QocmhzPy5zdHlsZSBhcyBzdHJpbmcpIH0pIGFzIGguSlNYLkNTU1Byb3BlcnRpZXM7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBMb2dpYz8/P1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhleSdyZSBib3RoIHN0cmluZ3MsIGp1c3QgY29uY2F0ZW5hdGUgdGhlbS5cclxuICAgIGlmICh0eXBlb2YgbGhzPy5zdHlsZSA9PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke2xocy5zdHlsZX07JHtyaHM/LnN0eWxlID8/IFwiXCJ9YCBhcyB1bmtub3duIGFzIHN0cmluZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggb2JqZWN0cywganVzdCBtZXJnZSB0aGVtLlxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICAuLi4obGhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcyxcclxuICAgICAgICAuLi4ocmhzPy5zdHlsZSA/PyB7fSkgYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG4gICAgfSBhcyB1bmtub3duIGFzIGguSlNYLkNTU1Byb3BlcnRpZXNcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2hpbGRyZW4gfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNoaWxkcmVuXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZENsYXNzZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLWNsYXNzZXNcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUmVmcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcmVmc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRTdHlsZXMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXN0eWxlc1wiO1xyXG5cclxubGV0IGxvZyA9IGNvbnNvbGUud2FybjtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBlbmFibGVMb2dnaW5nUHJvcENvbmZsaWN0cyhsb2cyOiB0eXBlb2YgY29uc29sZVtcImxvZ1wiXSkge1xyXG4gICAgbG9nID0gbG9nMlxyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIEdpdmVuIHR3byBzZXRzIG9mIHByb3BzLCBtZXJnZXMgdGhlbSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxyXG4gKiBcclxuICogVGhlIGhvb2sgaXMgYXdhcmUgb2YgYW5kIGNhbiBpbnRlbGxpZ2VudGx5IG1lcmdlIGBjbGFzc05hbWVgLCBgY2xhc3NgLCBgc3R5bGVgLCBgcmVmYCwgYW5kIGFsbCBldmVudCBoYW5kbGVycy5cclxuICogQHBhcmFtIGxoczIgXHJcbiAqIEBwYXJhbSByaHMyIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRQcm9wczxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGxoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIHJoc0FsbDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiB7XHJcbiAgICAvLyBGaXJzdCwgc2VwYXJhdGUgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4gaW50byB0d28gZ3JvdXBzOlxyXG4gICAgLy8gbGhzQWxsIGFuZCByaHNBbGwgY29udGFpbiBhbGwgdGhlIHByb3BzIHdlIHdlcmUgZ2l2ZW4sIGFuZFxyXG4gICAgLy8gbGhzTWlzYyBhbmQgcmhzTWlzYyBjb250YWluIGFsbCBwcm9wcyAqZXhjZXB0KiBmb3IgdGhlIGVhc3kgb25lc1xyXG4gICAgLy8gbGlrZSBjbGFzc05hbWUgYW5kIHN0eWxlIHRoYXQgd2UgYWxyZWFkeSBrbm93IGhvdyB0byBtZXJnZS5cclxuICAgIGNvbnN0IHsgY2hpbGRyZW46IF9saHNDaGlsZHJlbiwgY2xhc3M6IF9saHNDbGFzcywgY2xhc3NOYW1lOiBfbGhzQ2xhc3NOYW1lLCBzdHlsZTogX2xoc1N0eWxlLCByZWY6IF9saHNSZWYsIC4uLmxoc01pc2MgfSA9IGxoc0FsbDtcclxuICAgIGNvbnN0IHsgY2hpbGRyZW46IF9yaHNDaGlsZHJlbiwgY2xhc3M6IF9yaHNDbGFzcywgY2xhc3NOYW1lOiBfcmhzQ2xhc3NOYW1lLCBzdHlsZTogX3Joc1N0eWxlLCByZWY6IF9yaHNSZWYsIC4uLnJoc01pc2MgfSA9IHJoc0FsbDtcclxuXHJcbiAgICBjb25zdCByZXQ6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+ID0ge1xyXG4gICAgICAgIC4uLmxoc01pc2MsXHJcbiAgICAgICAgcmVmOiB1c2VNZXJnZWRSZWZzPEU+KGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBzdHlsZTogdXNlTWVyZ2VkU3R5bGVzKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgICAgICBjbGFzc05hbWU6IHVzZU1lcmdlZENsYXNzZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNoaWxkcmVuOiB1c2VNZXJnZWRDaGlsZHJlbihsaHNBbGwsIHJoc0FsbCksXHJcbiAgICB9IGFzIGFueTtcclxuXHJcbiAgICBpZiAocmV0LnJlZiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnJlZjtcclxuICAgIGlmIChyZXQuc3R5bGUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5zdHlsZTtcclxuICAgIGlmIChyZXQuY2xhc3NOYW1lID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2xhc3NOYW1lO1xyXG4gICAgaWYgKHJldC5jaGlsZHJlbiA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LmNoaWxkcmVuO1xyXG5cclxuICAgIC8vIE5vdywgZG8gKmV2ZXJ5dGhpbmcqIGVsc2VcclxuICAgIC8vIE1lcmdlIGV2ZXJ5IHJlbWFpbmluZyBleGlzdGluZyBlbnRyeSBpbiBsaHMgd2l0aCB3aGF0IHdlJ3ZlIGFscmVhZHkgcHV0IGluIHJldC5cclxuICAgIC8vY29uc3QgbGhzRW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGxocykgYXMgW2tleW9mIFQsIFRba2V5b2YgVF1dW107XHJcbiAgICBjb25zdCByaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMocmhzTWlzYyk7XHJcblxyXG4gICAgZm9yIChjb25zdCBbcmhzS2V5VSwgcmhzVmFsdWVdIG9mIHJoc0VudHJpZXMpIHtcclxuICAgICAgICBjb25zdCByaHNLZXkgPSByaHNLZXlVIGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG5cclxuICAgICAgICBjb25zdCBsaHNWYWx1ZSA9IGxoc01pc2NbcmhzS2V5IGFzIGtleW9mIHR5cGVvZiBsaHNNaXNjXTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiByaHNWYWx1ZSA9PT0gXCJmdW5jdGlvblwiKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggZnVuY3Rpb25zIHRoYXQgY2FuIGJlIG1lcmdlZCAob3Igb25lJ3MgYSBmdW5jdGlvbiBhbmQgdGhlIG90aGVyJ3MgbnVsbCkuXHJcbiAgICAgICAgICAgIC8vIE5vdCBhbiAqZWFzeSogY2FzZSwgYnV0IGEgd2VsbC1kZWZpbmVkIG9uZS5cclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VGdW5jdGlvbnMobGhzVmFsdWUgYXMgbmV2ZXIsIHJoc1ZhbHVlIGFzIG5ldmVyKTtcclxuICAgICAgICAgICAgcmV0W3Joc0tleSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPl0gPSBtZXJnZWQgYXMgbmV2ZXI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBVaC4uLndlJ3JlIGhlcmUgYmVjYXVzZSBvbmUgb2YgdGhlbSdzIG51bGwsIHJpZ2h0P1xyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbCAmJiByaHNWYWx1ZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmhzVmFsdWUgPT09IG51bGwgJiYgbGhzVmFsdWUgPT09IHVuZGVmaW5lZClcclxuICAgICAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gbGhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGxoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IHJoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmIChyaHNWYWx1ZSA9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgZWxzZSBpZiAoKHJoc1ZhbHVlIGFzIGFueSkgPT0gbGhzVmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEkgbWVhbiwgdGhleSdyZSB0aGUgc2FtZSB2YWx1ZSBhdCBsZWFzdFxyXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZy5cclxuICAgICAgICAgICAgICAgIC8vIE5vdCByZWFsbHkgaWRlYWwgdGhvdWdoLlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVWdoLlxyXG4gICAgICAgICAgICAgICAgLy8gTm8gZ29vZCBzdHJhdGVnaWVzIGhlcmUsIGp1c3QgbG9nIGl0IGlmIHJlcXVlc3RlZFxyXG4gICAgICAgICAgICAgICAgbG9nPy4oYFRoZSBwcm9wIFwiJHtyaHNLZXl9XCIgY2Fubm90IHNpbXVsdGFuZW91c2x5IGJlIHRoZSB2YWx1ZXMgJHtsaHNWYWx1ZX0gYW5kICR7cmhzVmFsdWV9LiBPbmUgbXVzdCBiZSBjaG9zZW4gb3V0c2lkZSBvZiB1c2VNZXJnZWRQcm9wcy5gKTtcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmV0O1xyXG5cclxufVxyXG5cclxuZnVuY3Rpb24gbWVyZ2VGdW5jdGlvbnM8VCBleHRlbmRzICguLi5hcmdzOiBhbnlbXSkgPT4gYW55LCBVIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KGxoczogVCB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogVSB8IG51bGwgfCB1bmRlZmluZWQpIHtcclxuXHJcbiAgICBpZiAoIWxocylcclxuICAgICAgICByZXR1cm4gcmhzO1xyXG4gICAgaWYgKCFyaHMpXHJcbiAgICAgICAgcmV0dXJuIGxocztcclxuXHJcbiAgICByZXR1cm4gKC4uLmFyZ3M6IFBhcmFtZXRlcnM8VD4pID0+IHtcclxuICAgICAgICBjb25zdCBsdiA9IGxocyguLi5hcmdzKTtcclxuICAgICAgICBjb25zdCBydiA9IHJocyguLi5hcmdzKTtcclxuXHJcbiAgICAgICAgaWYgKGx2IGluc3RhbmNlb2YgUHJvbWlzZSB8fCBydiBpbnN0YW5jZW9mIFByb21pc2UpXHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbHYsIHJ2XSk7XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKlxyXG5mdW5jdGlvbiB0ZXN0PFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxIVE1MSW5wdXRFbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuXHJcbiAgICBjb25zdCBpZDA6IEdlbmVyaWNHZXQ8e30sIFwiaWRcIiwgc3RyaW5nPiA9IFwiXCI7XHJcbiAgICBjb25zdCBpZDM6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNDogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ1OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDY6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIC8vY29uc3QgaWQyOiBaaXBTaW5nbGU8c3RyaW5nIHwgdW5kZWZpbmVkLCBzdHJpbmcgfCB1bmRlZmluZWQ+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQxOiBaaXBPYmplY3Q8eyBpZDogdW5kZWZpbmVkIH0sIHsgaWQ6IHN0cmluZyB9PiA9IHsgaWQ6IHVuZGVmaW5lZCB9O1xyXG5cclxuICAgIHR5cGUgTTEgPSBHZW5lcmljR2V0PFAsIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIHR5cGUgTTIgPSBHZW5lcmljR2V0PHt9LCBcInN0eWxlXCIsIHN0cmluZz47XHJcbiAgICBjb25zdCBtMTogTTEgPSBcIlwiO1xyXG4gICAgY29uc3QgbTI6IE0xID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG0zOiBNMSA9IDA7XHJcblxyXG4gICAgY29uc3QgbTQ6IE0yID0gXCJcIjtcclxuICAgIGNvbnN0IG01OiBNMiA9IHVuZGVmaW5lZDtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIEJlY2F1c2UgbnVtYmVyIGlzbid0IGFzc2lnbmFibGUgdG8gc3RyaW5nXHJcbiAgICBjb25zdCBtNjogTTIgPSAwO1xyXG5cclxuICAgIGNvbnN0IHAxOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7fSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAyOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogXCJzdHJpbmdcIiB9KTtcclxuICAgIGNvbnN0IHAzOiBNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50LCB7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0+ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDQ6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7fT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7fSk7XHJcbiAgICBjb25zdCBwNSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHt9KTtcclxuICAgIGNvbnN0IHA2ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgeyBpZDogdW5kZWZpbmVkIH0pO1xyXG4gICAgY29uc3QgcDcgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG5cclxuXHJcbiAgICBwMS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHAzLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICBwNC5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBwNS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDYuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHA3LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDUuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDYuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcDcuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDUuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA1LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDYuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA3LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNy5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgaXQgd29ya3MgcmVjdXJzaXZlbHlcclxuICAgIGNvbnN0IHIxYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAxKTtcclxuICAgIGNvbnN0IHIxYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAxKTtcclxuICAgIGNvbnN0IHIyYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAyKTtcclxuICAgIGNvbnN0IHIyYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAyKTtcclxuICAgIGNvbnN0IHIzYSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHAzKTtcclxuICAgIGNvbnN0IHIzYiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHAzKTtcclxuICAgIGNvbnN0IHI0YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA0KTtcclxuICAgIGNvbnN0IHI0YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA0KTtcclxuICAgIGNvbnN0IHI1YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA1KTtcclxuICAgIGNvbnN0IHI1YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA1KTtcclxuICAgIGNvbnN0IHI2YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA2KTtcclxuICAgIGNvbnN0IHI2YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA2KTtcclxuICAgIGNvbnN0IHI3YSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHA3KTtcclxuICAgIGNvbnN0IHI3YiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHA3KTtcclxuXHJcblxyXG4gICAgcjFhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMWIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIyYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHIzYS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjNiLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBjYW4ndCBiZSBhbnl0aGluZyBidXQgdW5kZWZpbmVkXHJcbiAgICByNGEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI0Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICByNWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI1Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjZhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI3YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjVhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI1Yi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjZiLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByN2IuaWQuY29uY2F0KFwiXCIpO1xyXG5cclxuXHJcbiAgICBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjVhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjViLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI1Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjZiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI2Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdhLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3YS5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocjdiLmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHI3Yi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxufVxyXG5mdW5jdGlvbiBhY2NlcHRzTmV2ZXIobjogbmV2ZXIpIHt9XHJcbiovIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRFbGVtZW50KCk6IFQgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJlZkVsZW1lbnRQcm9wcyhwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPiB7XHJcbiAgICBvbkVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD47XHJcbiAgICBvbk1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbiAgICBvblVubW91bnQ/OiAoZWxlbWVudDogVCkgPT4gdm9pZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBhY2Nlc3NpbmcgdGhlIGVsZW1lbnQgYSByZWYgcmVmZXJlbmNlcyBhcyBzb29uIGFzIGl0IGRvZXMgc28uXHJcbiAqICpUaGlzIGhvb2sgaXRzZWxmIHJldHVybnMgYSBob29rKi0tdXNlUmVmRWxlbWVudFByb3BzIG1vZGlmaWVzIHRoZSBwcm9wcyB0aGF0IHlvdSB3ZXJlIGdvaW5nIHRvIHBhc3MgdG8gYW4gSFRNTEVsZW1lbnQsIFxyXG4gKiBhZGRpbmcgYSBSZWZDYWxsYmFjayBhbmQgbWVyZ2luZyBpdCB3aXRoIGFueSBleGlzdGluZyByZWYgdGhhdCBleGlzdGVkIG9uIHRoZSBwcm9wcy5cclxuICogXHJcbiAqIERvbid0IGZvcmdldCB0byBwcm92aWRlIHRoZSBFbGVtZW50IGFzIHRoZSB0eXBlIGFyZ3VtZW50IVxyXG4gKiBcclxuICogQHJldHVybnMgVGhlIGVsZW1lbnQsIGFuZCB0aGUgc3ViLWhvb2sgdGhhdCBtYWtlcyBpdCByZXRyaWV2YWJsZS5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWZFbGVtZW50PFQgZXh0ZW5kcyBFdmVudFRhcmdldD4oYXJncz86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+KTogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4ge1xyXG4gICAgY29uc3QgeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9ID0gKGFyZ3MgPz8ge30pO1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZVJlZkVsZW1lbnRcIiwgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xyXG5cclxuICAgIC8vIENhbGxlZCAoaW5kaXJlY3RseSkgYnkgdGhlIHJlZiB0aGF0IHRoZSBlbGVtZW50IHJlY2VpdmVzLlxyXG4gICAgY29uc3QgaGFuZGxlciA9IHVzZUNhbGxiYWNrPE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPj4oKGUsIHByZXZWYWx1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2VmFsdWUpO1xyXG4gICAgICAgIGlmIChwcmV2VmFsdWUpXHJcbiAgICAgICAgICAgIG9uVW5tb3VudD8uKHByZXZWYWx1ZSEpO1xyXG5cclxuICAgICAgICBpZiAoZSlcclxuICAgICAgICAgICAgb25Nb3VudD8uKGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gY2xlYW51cDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBMZXQgdXMgc3RvcmUgdGhlIGFjdHVhbCAocmVmZXJlbmNlIHRvKSB0aGUgZWxlbWVudCB3ZSBjYXB0dXJlXHJcbiAgICBjb25zdCBbZ2V0RWxlbWVudCwgc2V0RWxlbWVudF0gPSB1c2VQYXNzaXZlU3RhdGU8VCB8IG51bGw+KGhhbmRsZXIsIHJldHVybk51bGwpO1xyXG4gICAgY29uc3QgdXNlUmVmRWxlbWVudFByb3BzID0gdXNlQ2FsbGJhY2s8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD5bXCJ1c2VSZWZFbGVtZW50UHJvcHNcIl0+KChwcm9wcykgPT4gdXNlTWVyZ2VkUHJvcHM8VD4oeyByZWY6IHNldEVsZW1lbnQgfSwgcHJvcHMpLCBbXSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIGJvdGggdGhlIGVsZW1lbnQgYW5kIHRoZSBob29rIHRoYXQgbW9kaWZpZXMgXHJcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJlZkVsZW1lbnRQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50XHJcbiAgICB9XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XHJcbmltcG9ydCB7IHVzZVJlZkVsZW1lbnQsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBcclxuICogVGhlcmUgYXJlIHNldmVyYWwgZGlmZmVyZW50IHdheXMgdGhhdCBhIGZvY3VzIGV2ZW50IGNhbiBoYXBwZW4uICBBc3N1bWVcclxuICogdGhlIGZvbGxvd2luZyBzdGVwcyBoYXBwZW4gaW4gb3JkZXI6XHJcbiAqIFxyXG4gKiAxLiBUaGUgcGFnZSBsb2Fkcy5cclxuICogICAgKiBOb3RoaW5nIGlzIGZvY3VzZWQsIGJ1dCBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgaXMgYGJvZHlgLiBcclxuICogICAgKiBObyBmb2N1cyBldmVudHMgYXJlIGZpcmVkLlxyXG4gKiAyLiBUaGUgd2luZG93IGlzIGZvY3VzZWQsIGFuIHVuZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgdGV4dCBpcyBzZWxlY3RlZCwgZXRjLlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgcmVtYWlucyBhcyBgYm9keWAuXHJcbiAqICAgICogQSBgZm9jdXNgL2Bmb2N1c2luYCBldmVudCAqTUlHSFQqIGJlIGZpcmVkIGZvciBgYm9keWAuIERlcGVuZGluZyBvblxyXG4gKiAgICAgIHRoZSBicm93c2VyLCB0aGlzIGRlcGVuZHMgb24gd2hldGhlciB0aGUgaGFuZGxlciB3YXMgYXR0YWNoZWQgdG8gYHdpbmRvd2Agb3IgYGRvY3VtZW50YC5cclxuICogICAgICBQcm9iYWJseSBqdXN0IGJlc3QgdG8gbm90IHJlbHkgb24gaXQsIG9yIGxpc3RlbiB0byBgd2luZG93YCBmb2N1cyBldmVudHMgZGlyZWN0bHkuXHJcbiAqIDMuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxyXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBuZXcgZWxlbWVudCBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXHJcbiAqICAgICogYGZvY3Vzb3V0YCBhbmQgYGJsdXJgIGFyZSAqbm90KiBmaXJlZCBvbiBgYm9keWAuXHJcbiAqICAgICogYGZvY3VzYCBhbmQgYGZvY3VzaW5gIGFyZSBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxyXG4gKiA0LiBBIGZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIGV0Yy5cclxuICogICAgKiAqKlRoZSBgYWN0aXZlRWxlbWVudGAgaXMgc2V0IHRvIHRoZSBgYm9keWAqKiBiZWZvcmUgYW55IGV2ZW50IGV2ZW4gZmlyZXMuXHJcbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgbmV3IGVsZW1lbnQuXHJcbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBub3cgc2V0IHRvIHRoZSBuZXcgZWxlbWVudC5cclxuICogICAgKiBgZm9jdXNpbmAgaXMgZmlyZWQgb24gdGhlIG5ldyBlbGVtZW50LiBgcmVsYXRlZFRhcmdldGAgaXMgdGhlIG9sZCBlbGVtZW50LlxyXG4gKiA1LiBBbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cclxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byBgYm9keWAuXHJcbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxyXG4gKiAgICAqIGBmb2N1c2luYCBpcyAqbm90KiBmaXJlZCBvbiBgYm9keWAuXHJcbiAqIFxyXG4gKiBcclxuICogSW4gc3VtbWFyeTpcclxuICogMS4gRm9jdXMgZXZlbnRzICpkbyogbm90aWZ5IHVzIG9mIGFsbCBjaGFuZ2VzIGluIGZvY3VzLCBidXQgdGhlcmUgaXMgbm8gb25lIHNpbmdsZSBjb21wcmVoZW5zaXZlIGV2ZW50IHRoYXQgcHJvdmlkZXMgdXMgd2l0aCBhbGwgYXZhaWxhYmxlIGluZm9ybWF0aW9uLlxyXG4gKiAyLiBgZG9jdW1lbnQuYWN0aXZlRWxlbWVudGAgKmlzIG5vdCogYWx3YXlzIHRoZSBzYW1lIGFzIHdoYXQncyBiZWluZyByZWZlcmVuY2VkIGJ5IGEgZm9jdXMgZXZlbnQuIEluIHBhcnRpY3VsYXIsIGl0IG1heSBiZWNvbWUgYGJvZHlgIGF0IGFueSBhcmJpdHJhcnkgdGltZS5cclxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxyXG4gKiA0LiBBIGBibHVyYCBldmVudCB3aG9zZSBgcmVsYXRlZFRhcmdldGAgaXMgbnVsbCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSB3aWxsIGJlIG5vIGZvbGxvd2luZyBgZm9jdXNgIGV2ZW50LlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBjYWxsYmFjayBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5jb25zdCBfZHVtbXkgPSAwO1xyXG5cclxuY29uc3QgYWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlIHwgbnVsbCkgPT4gdm9pZCk+PigpO1xyXG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlKSA9PiB2b2lkKT4+KCk7XHJcbmNvbnN0IHdpbmRvd0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PHVuZGVmaW5lZCB8ICgoZm9jdXNlZDogYm9vbGVhbikgPT4gdm9pZCk+PigpO1xyXG5jb25zdCB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBib29sZWFuPigpO1xyXG5cclxuY29uc3QgbWljcm90YXNrcyA9IG5ldyBTZXQ8TWFwPGFueSwgYW55Pj4oKTtcclxuXHJcbi8vIFRoZSBmb2N1c2luIGFuZCBmb2N1c291dCBldmVudHMgb2Z0ZW4gZmlyZSBzeW5jcm9ub3VzbHkgaW4gdGhlIG1pZGRsZSBvZiBydW5uaW5nIGNvZGUuXHJcbi8vIEUuRy4gY2FsbGluZyBlbGVtZW50LmZvY3VzKCkgY2FuIGNhdXNlIGEgZm9jdXNpbiBldmVudCBoYW5kbGVyIHRvIGltbWVkaWF0ZWx5IGludGVycnVwdCB0aGF0IGNvZGUuXHJcbi8vIEZvciB0aGUgcHVycG9zZSBvZiBpbXByb3Zpbmcgc3RhYmlsaXR5LCB3ZSBkZWJvdW5jZSBhbGwgZm9jdXMgZXZlbnRzIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cclxuZnVuY3Rpb24gZm9yRWFjaFVwZGF0ZXI8VD4od2luZG93OiBXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBtYXA6IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBUKSA9PiB2b2lkKT4+LCB2YWx1ZTogVCkge1xyXG4gICAgaWYgKCFtaWNyb3Rhc2tzLmhhcyhtYXApKSB7XHJcbiAgICAgICAgbWljcm90YXNrcy5hZGQobWFwKTtcclxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgIG1pY3JvdGFza3MuZGVsZXRlKG1hcCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB1cGRhdGVycyA9IG1hcC5nZXQod2luZG93KTtcclxuICAgICAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVyPy4odmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZvY3Vzb3V0KGU6IEZvY3VzRXZlbnQpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgPT0gbnVsbCkge1xyXG4gICAgICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEp1c3Qgd2FpdCBmb3IgdGhlIGZvY3VzaW4gZXZlbnQuXHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBmb2N1c2luKGU6IEZvY3VzRXZlbnQpIHtcclxuICAgIGNvbnN0IHdpbmRvdyA9IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgY29uc3QgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpO1xyXG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIGN1cnJlbnRseUZvY3VzZWRFbGVtZW50KTtcclxuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycywgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiB3aW5kb3dGb2N1cyhlOiBGb2N1c0V2ZW50KSB7XHJcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcclxuICAgIHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgdHJ1ZSk7XHJcbiAgICBmb3JFYWNoVXBkYXRlcih3aW5kb3csIHdpbmRvd0ZvY3VzZWRVcGRhdGVycywgdHJ1ZSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHdpbmRvd0JsdXIoZTogRm9jdXNFdmVudCkge1xyXG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XHJcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGZhbHNlKTtcclxuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCBmYWxzZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy4gTXVzdCBiZSBzdGFibGUuXHJcbiAgICAgKi9cclxuICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPFQgfCBudWxsPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcyBhbmQgaXMgbm90IG51bGwuIFxyXG4gICAgICogTXVzdCBiZSBzdGFibGUuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgd2luZG93IGdhaW5zL2xvc2VzIGZvY3VzLiBNdXN0IGJlIHN0YWJsZS5cclxuICAgICAqL1xyXG4gICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8Ym9vbGVhbj47XHJcblxyXG4gICAgb25Nb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Nb3VudFwiXTtcclxuICAgIG9uVW5tb3VudD86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25Vbm1vdW50XCJdO1xyXG4gICAgb25Nb3VudENoYW5nZT86IFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25FbGVtZW50Q2hhbmdlXCJdO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQgZXh0ZW5kcyBOb2RlPiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8VD4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+IHtcclxuICAgIC8qKiBcclxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IFQgfCBudWxsO1xyXG4gICAgLyoqIFxyXG4gICAgICogUmV0dXJucyB3aGF0ZXZlciBlbGVtZW50IGlzIGN1cnJlbnRseSBmb2N1c2VkLCBvciB3aGF0ZXZlciBlbGVtZW50IHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnRcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQ6ICgpID0+IFQ7XHJcbiAgICAvKiogXHJcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB3aW5kb3cgaXRzZWxmIGhhcyBmb2N1cyBvciBub3RcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgZ2V0V2luZG93Rm9jdXNlZDogKCkgPT4gYm9vbGVhbjtcclxuXHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlQWN0aXZlRWxlbWVudFByb3BzOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyB5b3UgdG8gaW5zcGVjdCB3aGljaCBlbGVtZW50IGluIHRoZSBgZG9jdW1lbnRgIGN1cnJlbnRseSBoYXMgZm9jdXMsIHdoaWNoIHdhcyBtb3N0IHJlY2VudGx5IGZvY3VzZWQgaWYgbm9uZSBhcmUgY3VycmVudGx5LCBhbmQgd2hldGhlciBvciBub3QgdGhlIHdpbmRvdyBoYXMgZm9jdXMgYnkgcmV0dXJuaW5nIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zOlxyXG4gKiAqIGBnZXRBY3RpdmVFbGVtZW50KClgXHJcbiAqICogYGdldExhc3RBY3RpdmVFbGVtZW50KClgXHJcbiAqICogYGdldFdpbmRvd0ZvY3VzZWQoKWBcclxuICogXHJcbiAqIChUaGUgZG9jdW1lbnQncyBib2R5IHJlY2VpdmluZyBmb2N1cywgbGlrZSBpdCBkb2VzIHdoZW4geW91IGNsaWNrIG9uIGFuIGVtcHR5IGFyZWEsIGlzIGNvdW50ZWQgYXMgbm8gZWxlbWVudCBoYXZpbmcgZm9jdXMgZm9yIGFsbCBpbnRlbnRzIGFuZCBwdXJwb3NlcylcclxuICogXHJcbiAqIFRoaXMgaXMgYSBwYXNzaXZlIGhvb2ssIHNvIGJ5IGRlZmF1bHQgaXQgcmV0dXJucyBnZXR0ZXIgZnVuY3Rpb25zIHRoYXQgcmVwb3J0IHRoaXMgaW5mb3JtYXRpb24gYnV0IHRoZSBjb21wb25lbnQgd2lsbCBub3QgcmUtcmVuZGVyIGJ5IGRlZmF1bHQgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy5cclxuICogXHJcbiAqIElmIHlvdSBuZWVkIHRoZSBjb21wb25lbnQgdG8gcmUtcmVuZGVyIHdoZW4gdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMsIHVzZSB0aGUgYG9uKkNoYW5nZWAgYXJndW1lbnRzIHRvIHNldCBzb21lIHN0YXRlIG9uIHlvdXIgZW5kLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUFjdGl2ZUVsZW1lbnQ8VCBleHRlbmRzIE5vZGU+KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgb25Nb3VudENoYW5nZSB9OiBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VBY3RpdmVFbGVtZW50XCIsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBvbk1vdW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcclxuICAgICAgICBvbk1vdW50LFxyXG4gICAgICAgIG9uVW5tb3VudCxcclxuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCwgcHJldlZhbHVlOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgICAgICBvbk1vdW50Q2hhbmdlPy4oZWxlbWVudCwgcHJldlZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQ/LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICgoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpPy5zaXplID8/IDApID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIGZvY3VzaW4sIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3Vzb3V0XCIsIGZvY3Vzb3V0LCB7IHBhc3NpdmU6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHdpbmRvd0JsdXIsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBBZGQgdGhlbSBldmVuIGlmIHRoZXkncmUgdW5kZWZpbmVkIHRvIG1vcmUgZWFzaWx5XHJcbiAgICAgICAgICAgICAgICAvLyBtYW5hZ2UgdGhlIFwiPjAgbWVhbnMgZG9uJ3QgYWRkIGhhbmRsZXJzXCIgbG9naWMuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0QWN0aXZlRWxlbWVudCBhcyBTdGF0ZVVwZGF0ZXI8Tm9kZSB8IG51bGw+KTtcclxuICAgICAgICAgICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQoc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+KTtcclxuICAgICAgICAgICAgICAgIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzLmFkZChzZXRXaW5kb3dGb2N1c2VkKTtcclxuXHJcbiAgICAgICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xyXG4gICAgICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzKTtcclxuXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGUgfCBudWxsPik7XHJcbiAgICAgICAgICAgICAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKHNldExhc3RBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlPik7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpIS5kZWxldGUoc2V0V2luZG93Rm9jdXNlZCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3RpdmVFbGVtZW50VXBkYXRlcnMuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgZm9jdXNvdXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3c/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCB3aW5kb3dGb2N1cyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW10pXHJcbiAgICB9KVxyXG5cclxuICAgIGNvbnN0IFtnZXRBY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxUIHwgbnVsbD4ob25BY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0QWN0aXZlRWxlbWVudCwgc2V0TGFzdEFjdGl2ZUVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQ+KG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIHJldHVybk51bGwgYXMgKCkgPT4gbmV2ZXIpO1xyXG4gICAgY29uc3QgW2dldFdpbmRvd0ZvY3VzZWQsIHNldFdpbmRvd0ZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uV2luZG93Rm9jdXNlZENoYW5nZSwgcmV0dXJuVHJ1ZSk7XHJcblxyXG4gICAgcmV0dXJuIHsgZ2V0RWxlbWVudCwgdXNlQWN0aXZlRWxlbWVudFByb3BzOiB1c2VSZWZFbGVtZW50UHJvcHMsIGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XHJcbn1cclxuIiwiXHJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IEVmZmVjdENhbGxiYWNrLCBJbnB1dHMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcblxyXG5cclxuXHJcbmNvbnN0IFRhYmxlID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8tXCI7XHJcblxyXG5mdW5jdGlvbiBiYXNlNjQodmFsdWU6IG51bWJlcikge1xyXG4gICAgcmV0dXJuIFRhYmxlW3ZhbHVlXTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tNkJpdHMoKSB7XHJcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xyXG4gICAgcmV0dXJuIFtyYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpLCByYW5kb202Qml0cygpXSBhcyBjb25zdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSByYW5kb21seS1nZW5lcmF0ZWQgSUQgd2l0aCBhbiBvcHRpb25hbCBwcmVmaXguXHJcbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxyXG4gKiBJRHMgdGhhdCBhcmUgbm90IHZhbGlkIHVuZGVyIEhUTUw0IG1heSBiZSBnZW5lcmF0ZWQuIE9oIG5vLlxyXG4gKiBcclxuICogXHJcbiAqIChUaGlzIGlzIGhlcmUsIGluIHRoaXMgcGFydGljdWxhciBmaWxlLCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXNcclxuICogd2l0aG91dCBhbHNvIG1ha2luZyBhIHV0aWxpdGllcyBmaWxlLlxyXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlUmFuZG9tSWQocHJlZml4Pzogc3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcclxufVxyXG5cclxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xyXG5jb25zdCB0b1J1biA9IG5ldyBNYXA8c3RyaW5nLCB7IGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cywgY2xlYW51cDogbnVsbCB8IHVuZGVmaW5lZCB8IHZvaWQgfCAoKCkgPT4gdm9pZCkgfT4oKTtcclxuXHJcblxyXG4vLyBUT0RPOiBXaGV0aGVyIHRoaXMgZ29lcyBpbiBvcHRpb25zLmRpZmZlZCBvciBvcHRpb25zLl9jb21taXRcclxuLy8gaXMgYSBwb3N0LXN1c3BlbnNlIHF1ZXN0aW9uLlxyXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xyXG4vLyAqYWZ0ZXIqIHJlZnMgYXJlIGFwcGxpZWQsIGJ1dCB3ZSBuZWVkIHRvIGNvbWUgYmVmb3JlIGV2ZW4gdGhhdFxyXG4vLyBzbyBgcmVmPXtzb21lU3RhYmxlRnVuY3Rpb259YCB3b3Jrcy5cclxuLy8gXHJcbi8vIEFsc28gaXQncyBwcml2YXRlLlxyXG4vL1xyXG4vLyAuLi5cclxuLy8gV2VsbCwgdXNlRXZlbnQgb3Igd2hhdGV2ZXIgaXMgZmluYWxseSwgZmluYWxseSA0IHllYXJzIGxhdGVyIGZpbmFsbHkgaGVyZVxyXG4vLyB3aGljaCBpcyBjb29sIGFuZCBtZWFucyB3ZSB3b24ndCBuZWVkIHRoaXMgYXQgYWxsIHNvb24uXHJcbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXHJcbi8vIGNvbW1pdCBiZWluZyBwcml2YXRlIGFuZCBhbGwuXHJcbmNvbnN0IGNvbW1pdE5hbWUgPSBcImRpZmZlZFwiO1xyXG5cclxuY29uc3Qgb3JpZ2luYWxDb21taXQgPSBvcHRpb25zW2NvbW1pdE5hbWVdIGFzICh2bm9kZTogVk5vZGUsIGNvbW1pdFF1ZXVlOiBDb21wb25lbnRbXSkgPT4gdm9pZDtcclxuY29uc3QgbmV3Q29tbWl0OiB0eXBlb2Ygb3JpZ2luYWxDb21taXQgPSAoLi4uYXJncykgPT4ge1xyXG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XHJcbiAgICAgICAgY29uc3Qgb2xkSW5wdXRzID0gcHJldmlvdXNJbnB1dHMuZ2V0KGlkKTtcclxuICAgICAgICBpZiAoYXJnc0NoYW5nZWQob2xkSW5wdXRzLCBlZmZlY3RJbmZvLmlucHV0cykpIHtcclxuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcclxuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwID0gZWZmZWN0SW5mby5lZmZlY3QoKTtcclxuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuc2V0KGlkLCBlZmZlY3RJbmZvLmlucHV0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdG9SdW4uY2xlYXIoKTtcclxuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XHJcbn1cclxub3B0aW9uc1tjb21taXROYW1lXSA9IG5ld0NvbW1pdCBhcyBuZXZlclxyXG5cclxuLyoqXHJcbiAqIFNlbWktcHJpdmF0ZSBmdW5jdGlvbiB0byBhbGxvdyBzdGFibGUgY2FsbGJhY2tzIGV2ZW4gd2l0aGluIGB1c2VMYXlvdXRFZmZlY3RgIGFuZCByZWYgYXNzaWdubWVudC5cclxuICogXHJcbiAqIEV2ZXJ5IHJlbmRlciwgd2Ugc2VuZCB0aGUgYXJndW1lbnRzIHRvIGJlIGV2YWx1YXRlZCBhZnRlciBkaWZmaW5nIGhhcyBjb21wbGV0ZWQsXHJcbiAqIHdoaWNoIGhhcHBlbnMgYmVmb3JlLlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VCZWZvcmVMYXlvdXRFZmZlY3QoZWZmZWN0OiBFZmZlY3RDYWxsYmFjaywgaW5wdXRzPzogSW5wdXRzKSB7XHJcblxyXG4gICAgLyooKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSB1c2VSZWY8dm9pZCB8ICgoKSA9PiB2b2lkKSB8IG51bGw+KG51bGwpO1xyXG4gICAgICAgIGNvbnN0IHByZXZBcmdzUmVmID0gdXNlUmVmPElucHV0cz4obnVsbCEpO1xyXG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgIHByZXZBcmdzUmVmLmN1cnJlbnQgPSBpbnB1dHMhO1xyXG4gICAgICAgICAgICBpZiAoY2xlYW51cC5jdXJyZW50KVxyXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XHJcbiAgICAgICAgICAgIGNsZWFudXAuY3VycmVudCA9IGVmZmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pKCk7Ki9cclxuXHJcbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gZ2VuZXJhdGVSYW5kb21JZCgpKTtcclxuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRvUnVuLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgICAgIHByZXZpb3VzSW5wdXRzLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2lkXSlcclxufVxyXG5cclxuZnVuY3Rpb24gYXJnc0NoYW5nZWQob2xkQXJncz86IElucHV0cywgbmV3QXJncz86IElucHV0cyk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuICEhKFxyXG4gICAgICAgICFvbGRBcmdzIHx8XHJcbiAgICAgICAgb2xkQXJncy5sZW5ndGggIT09IG5ld0FyZ3M/Lmxlbmd0aCB8fFxyXG4gICAgICAgIG5ld0FyZ3M/LnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXHJcbiAgICApO1xyXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUJlZm9yZUxheW91dEVmZmVjdCB9IGZyb20gXCIuL3VzZS1iZWZvcmUtbGF5b3V0LWVmZmVjdFwiO1xuXG5jb25zdCBVbnNldCA9IFN5bWJvbChcInVuc2V0XCIpO1xuXG4vKipcbiAqIEdpdmVuIGFuIGlucHV0IHZhbHVlLCByZXR1cm5zIGEgY29uc3RhbnQgZ2V0dGVyIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgXG4gKiBpbnNpZGUgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMgd2l0aG91dCBpbmNsdWRpbmcgaXQgaW4gdGhlIGRlcGVuZGVuY3kgYXJyYXkuXG4gKiBcbiAqIFRoaXMgdXNlcyBgb3B0aW9ucy5kaWZmZWRgIGluIG9yZGVyIHRvIHJ1biBiZWZvcmUgZXZlcnl0aGluZywgZXZlblxuICogcmVmIGFzc2lnbm1lbnQuIFRoaXMgbWVhbnMgdGhpcyBnZXR0ZXIgaXMgc2FmZSB0byB1c2UgYW55d2hlcmUgKioqZXhjZXB0IHRoZSByZW5kZXIgcGhhc2UqKiouXG4gKiBcbiAqIEBwYXJhbSB2YWx1ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlR2V0dGVyPFQ+KHZhbHVlOiBUKTogKCkgPT4gVCB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmPFQ+KFVuc2V0IGFzIHVua25vd24gYXMgVCk7XG4gICAgdXNlQmVmb3JlTGF5b3V0RWZmZWN0KCgpID0+IHsgcmVmLmN1cnJlbnQgPSB2YWx1ZTsgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50IGFzIHVua25vd24gPT09IFVuc2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZhbHVlIHJldHJpZXZlZCBmcm9tIHVzZVN0YWJsZUdldHRlcigpIGNhbm5vdCBiZSBjYWxsZWQgZHVyaW5nIHJlbmRlci4nKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWYuY3VycmVudDtcbiAgICB9LCBbXSlcbn0iLCJpbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cblxuLyoqXG4gKiBBbHRlcm5hdGUgdXNlQ2FsbGJhY2soKSB3aGljaCBhbHdheXMgcmV0dXJucyB0aGUgc2FtZSAod3JhcHBlZCkgZnVuY3Rpb24gcmVmZXJlbmNlXG4gKiBzbyB0aGF0IGl0IGNhbiBiZSBleGNsdWRlZCBmcm9tIHRoZSBkZXBlbmRlbmN5IGFycmF5cyBvZiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcy5cbiAqIFxuICogRG8gbm90IHVzZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSEgIGB1c2VMYXlvdXRFZmZlY3RgIGlzIGZpbmUgdGhvdWdoLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhYmxlQ2FsbGJhY2s8VCBleHRlbmRzICguLi5fYXJnczogYW55W10pID0+IGFueT4oZm46IFQpOiBUIHtcbiAgICBjb25zdCBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIgPSB1c2VTdGFibGVHZXR0ZXI8VD4oZm4pO1xuXG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKCguLi5hcmdzOiBQYXJhbWV0ZXJzPFQ+KTogUmV0dXJuVHlwZTxUPiA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Q2FsbGJhY2tHZXR0ZXIoKSguLi5hcmdzKTtcbiAgICB9LCBbXSkgYXMgVDtcbn0iLCJpbXBvcnQgeyBDb21wb25lbnRDaGlsZHJlbiwgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG50eXBlIFJhZkNhbGxiYWNrVHlwZSA9IChtc1NpbmNlTGFzdDogbnVtYmVyLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG5cbmludGVyZmFjZSBDb250ZXh0VHlwZSB7XG4gICAgYWRkQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlLCB0YWc/OiBhbnkpID0+IHZvaWQ7XG4gICAgcmVtb3ZlQ2FsbGJhY2s6IChjYWxsYmFjazogUmFmQ2FsbGJhY2tUeXBlKSA9PiB2b2lkO1xufVxuXG5jb25zdCBTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PG51bGwgfCBDb250ZXh0VHlwZT4obnVsbCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBQcm92aWRlQmF0Y2hlZEFuaW1hdGlvbkZyYW1lcyh7IGNoaWxkcmVuIH06IHsgY2hpbGRyZW46IENvbXBvbmVudENoaWxkcmVuIH0pIHtcblxuICAgIGNvbnN0IGFkZENhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJhZGRDYWxsYmFja1wiXT4oKGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5zZXQoY2FsbGJhY2tUb0JlQmF0Y2hlZCwgdGFnKTsgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZUNhbGxiYWNrID0gdXNlQ2FsbGJhY2s8Q29udGV4dFR5cGVbXCJyZW1vdmVDYWxsYmFja1wiXT4oKGNhbGxiYWNrKSA9PiB7IGFsbENhbGxiYWNrcy5jdXJyZW50LmRlbGV0ZShjYWxsYmFjayk7IH0sIFtdKTtcblxuICAgIGNvbnN0IGNvbnRleHRJbmZvID0gdXNlUmVmPENvbnRleHRUeXBlPihudWxsISk7XG4gICAgaWYgKGNvbnRleHRJbmZvLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgY29udGV4dEluZm8uY3VycmVudCA9IHsgYWRkQ2FsbGJhY2ssIHJlbW92ZUNhbGxiYWNrIH07XG4gICAgY29uc3QgYWxsQ2FsbGJhY2tzID0gdXNlUmVmPE1hcDxSYWZDYWxsYmFja1R5cGUsIGFueT4+KG51bGwhKTtcbiAgICBpZiAoYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPT0gbnVsbClcbiAgICAgICAgYWxsQ2FsbGJhY2tzLmN1cnJlbnQgPSBuZXcgTWFwKCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBsZXQgaGFuZGxlID0gLTE7XG5cbiAgICAgICAgZnVuY3Rpb24gcmFmV2l0aEJhdGNoZWRDYWxsYmFja3MobXNTaW5jZUxhc3Q6IG51bWJlcikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbYmF0Y2hlZFJhZkNhbGxiYWNrLCB0YWddIG9mIGFsbENhbGxiYWNrcy5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlZFJhZkNhbGxiYWNrKG1zU2luY2VMYXN0LCB0YWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbEFuaW1hdGlvbkZyYW1lKGhhbmRsZSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dEluZm8uY3VycmVudH0+XG4gICAgICAgICAgICB7Y2hpbGRyZW59XG4gICAgICAgIDwvU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LlByb3ZpZGVyPilcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIHdpdGggZWZmZWN0aXZlbHkgdGhlIHNhbWUgcnVsZXMgYXMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWBcbiAgICAgKiBcbiAgICAgKiBEb2Vzbid0IG5lZWQgdG8gYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiBudWxsIHwgKChtc1NpbmNlTGFzdDogbnVtYmVyKSA9PiB2b2lkKTtcbn1cblxuLyoqXG4gKiBUaGUgKG9wdGlvbmFsbHkgbm9uLXN0YWJsZSkgYGNhbGxiYWNrYCB5b3UgcHJvdmlkZSB3aWxsIHN0YXJ0IHJ1bm5pbmcgZXZlcnkgZnJhbWUgYWZ0ZXIgdGhlIGNvbXBvbmVudCBtb3VudHMuXG4gKiBcbiAqIFBhc3NpbmcgYG51bGxgIGlzIGZpbmUgYW5kIHNpbXBseSBzdG9wcyB0aGUgZWZmZWN0IHVudGlsIHlvdSByZXN0YXJ0IGl0IGJ5IHByb3ZpZGluZyBhIG5vbi1udWxsIGNhbGxiYWNrLlxuICogXG4gKiAqKlRoaXMgaG9vayBkb2VzIG5vdCByZXR1cm4gYW55dGhpbmcgYXQgYWxsLCBpbmNsdWRpbmcgbm8gcHJvcC1tb2RpZnlpbmcgaG9va3MqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQW5pbWF0aW9uRnJhbWUoeyBjYWxsYmFjayB9OiBVc2VBbmltYXRpb25GcmFtZVBhcmFtZXRlcnMpOiB2b2lkIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2sgPz8gbm9vcCk7XG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSAoY2FsbGJhY2sgIT0gbnVsbCk7XG5cbiAgICBjb25zdCBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQgPSB1c2VDb250ZXh0KFNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0KSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuYWRkQ2FsbGJhY2soc3RhYmxlQ2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LnJlbW92ZUNhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyB0aGF0IGFsc28gY2FsbHMgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYWdhaW4uXG4gICAgICAgICAgICAgICAgY29uc3QgcmFmQ2FsbGJhY2sgPSAobXM6IG51bWJlcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBzdGFibGVDYWxsYmFjayhtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW3NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCwgaGFzQ2FsbGJhY2tdKVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc09iamVjdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbmV4cG9ydCBkZWZhdWx0IGZyZWVHbG9iYWw7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBzZWxmYC4gKi9cbnZhciBmcmVlU2VsZiA9IHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYgJiYgc2VsZi5PYmplY3QgPT09IE9iamVjdCAmJiBzZWxmO1xuXG4vKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbnZhciByb290ID0gZnJlZUdsb2JhbCB8fCBmcmVlU2VsZiB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5leHBvcnQgZGVmYXVsdCByb290O1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG5vdztcbiIsIi8qKiBVc2VkIHRvIG1hdGNoIGEgc2luZ2xlIHdoaXRlc3BhY2UgY2hhcmFjdGVyLiAqL1xudmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4vKipcbiAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAqIGNoYXJhY3RlciBvZiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpIHtcbiAgdmFyIGluZGV4ID0gc3RyaW5nLmxlbmd0aDtcblxuICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdHJpbW1lZEVuZEluZGV4O1xuIiwiaW1wb3J0IHRyaW1tZWRFbmRJbmRleCBmcm9tICcuL190cmltbWVkRW5kSW5kZXguanMnO1xuXG4vKiogVXNlZCB0byBtYXRjaCBsZWFkaW5nIHdoaXRlc3BhY2UuICovXG52YXIgcmVUcmltU3RhcnQgPSAvXlxccysvO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZ1xuICAgID8gc3RyaW5nLnNsaWNlKDAsIHRyaW1tZWRFbmRJbmRleChzdHJpbmcpICsgMSkucmVwbGFjZShyZVRyaW1TdGFydCwgJycpXG4gICAgOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUcmltO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFN5bWJvbCA9IHJvb3QuU3ltYm9sO1xuXG5leHBvcnQgZGVmYXVsdCBTeW1ib2w7XG4iLCJpbXBvcnQgU3ltYm9sIGZyb20gJy4vX1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VHZXRUYWdgIHdoaWNoIGlnbm9yZXMgYFN5bWJvbC50b1N0cmluZ1RhZ2AgdmFsdWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBnZXRSYXdUYWcodmFsdWUpIHtcbiAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgdGFnID0gdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuXG4gIHRyeSB7XG4gICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgIHZhciB1bm1hc2tlZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICBpZiAodW5tYXNrZWQpIHtcbiAgICBpZiAoaXNPd24pIHtcbiAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZ2V0UmF3VGFnO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG9iamVjdFRvU3RyaW5nO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuaW1wb3J0IGdldFJhd1RhZyBmcm9tICcuL19nZXRSYXdUYWcuanMnO1xuaW1wb3J0IG9iamVjdFRvU3RyaW5nIGZyb20gJy4vX29iamVjdFRvU3RyaW5nLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgdW5kZWZpbmVkVGFnID0gJ1tvYmplY3QgVW5kZWZpbmVkXSc7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHN5bVRvU3RyaW5nVGFnID0gU3ltYm9sID8gU3ltYm9sLnRvU3RyaW5nVGFnIDogdW5kZWZpbmVkO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRUYWdgIHdpdGhvdXQgZmFsbGJhY2tzIGZvciBidWdneSBlbnZpcm9ubWVudHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldFRhZyh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgfVxuICByZXR1cm4gKHN5bVRvU3RyaW5nVGFnICYmIHN5bVRvU3RyaW5nVGFnIGluIE9iamVjdCh2YWx1ZSkpXG4gICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgOiBvYmplY3RUb1N0cmluZyh2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VHZXRUYWc7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxuICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jztcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3RMaWtlO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1N5bWJvbDtcbiIsImltcG9ydCBiYXNlVHJpbSBmcm9tICcuL19iYXNlVHJpbS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgaXNTeW1ib2wgZnJvbSAnLi9pc1N5bWJvbC5qcyc7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE5BTiA9IDAgLyAwO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmFkIHNpZ25lZCBoZXhhZGVjaW1hbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCYWRIZXggPSAvXlstK10weFswLTlhLWZdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNCaW5hcnkgPSAvXjBiWzAxXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xudmFyIHJlSXNPY3RhbCA9IC9eMG9bMC03XSskL2k7XG5cbi8qKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB3aXRob3V0IGEgZGVwZW5kZW5jeSBvbiBgcm9vdGAuICovXG52YXIgZnJlZVBhcnNlSW50ID0gcGFyc2VJbnQ7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIG51bWJlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50b051bWJlcigzLjIpO1xuICogLy8gPT4gMy4yXG4gKlxuICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IDVlLTMyNFxuICpcbiAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICogLy8gPT4gSW5maW5pdHlcbiAqXG4gKiBfLnRvTnVtYmVyKCczLjInKTtcbiAqIC8vID0+IDMuMlxuICovXG5mdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gTkFOO1xuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICB2YXIgb3RoZXIgPSB0eXBlb2YgdmFsdWUudmFsdWVPZiA9PSAnZnVuY3Rpb24nID8gdmFsdWUudmFsdWVPZigpIDogdmFsdWU7XG4gICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgfVxuICBpZiAodHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gIH1cbiAgdmFsdWUgPSBiYXNlVHJpbSh2YWx1ZSk7XG4gIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gIHJldHVybiAoaXNCaW5hcnkgfHwgcmVJc09jdGFsLnRlc3QodmFsdWUpKVxuICAgID8gZnJlZVBhcnNlSW50KHZhbHVlLnNsaWNlKDIpLCBpc0JpbmFyeSA/IDIgOiA4KVxuICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0b051bWJlcjtcbiIsImltcG9ydCBpc09iamVjdCBmcm9tICcuL2lzT2JqZWN0LmpzJztcbmltcG9ydCBub3cgZnJvbSAnLi9ub3cuanMnO1xuaW1wb3J0IHRvTnVtYmVyIGZyb20gJy4vdG9OdW1iZXIuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgbmF0aXZlTWluID0gTWF0aC5taW47XG5cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlZCBmdW5jdGlvbiB0aGF0IGRlbGF5cyBpbnZva2luZyBgZnVuY2AgdW50aWwgYWZ0ZXIgYHdhaXRgXG4gKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAqIGludm9rZWQuIFRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgIG1ldGhvZCB0byBjYW5jZWxcbiAqIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLlxuICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gKiBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkXG4gKiB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50XG4gKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICogaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIGRlYm91bmNlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy5kZWJvdW5jZWAgYW5kIGBfLnRocm90dGxlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9ZmFsc2VdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm1heFdhaXRdXG4gKiAgVGhlIG1heGltdW0gdGltZSBgZnVuY2AgaXMgYWxsb3dlZCB0byBiZSBkZWxheWVkIGJlZm9yZSBpdCdzIGludm9rZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgY29zdGx5IGNhbGN1bGF0aW9ucyB3aGlsZSB0aGUgd2luZG93IHNpemUgaXMgaW4gZmx1eC5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gKlxuICogLy8gSW52b2tlIGBzZW5kTWFpbGAgd2hlbiBjbGlja2VkLCBkZWJvdW5jaW5nIHN1YnNlcXVlbnQgY2FsbHMuXG4gKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gKiAgICdsZWFkaW5nJzogdHJ1ZSxcbiAqICAgJ3RyYWlsaW5nJzogZmFsc2VcbiAqIH0pKTtcbiAqXG4gKiAvLyBFbnN1cmUgYGJhdGNoTG9nYCBpcyBpbnZva2VkIG9uY2UgYWZ0ZXIgMSBzZWNvbmQgb2YgZGVib3VuY2VkIGNhbGxzLlxuICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gKiB2YXIgc291cmNlID0gbmV3IEV2ZW50U291cmNlKCcvc3RyZWFtJyk7XG4gKiBqUXVlcnkoc291cmNlKS5vbignbWVzc2FnZScsIGRlYm91bmNlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyBkZWJvdW5jZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIGRlYm91bmNlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiBkZWJvdW5jZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsYXN0QXJncyxcbiAgICAgIGxhc3RUaGlzLFxuICAgICAgbWF4V2FpdCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHRpbWVySWQsXG4gICAgICBsYXN0Q2FsbFRpbWUsXG4gICAgICBsYXN0SW52b2tlVGltZSA9IDAsXG4gICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICBtYXhpbmcgPSBmYWxzZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICEhb3B0aW9ucy5sZWFkaW5nO1xuICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgIG1heFdhaXQgPSBtYXhpbmcgPyBuYXRpdmVNYXgodG9OdW1iZXIob3B0aW9ucy5tYXhXYWl0KSB8fCAwLCB3YWl0KSA6IG1heFdhaXQ7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUZ1bmModGltZSkge1xuICAgIHZhciBhcmdzID0gbGFzdEFyZ3MsXG4gICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAvLyBSZXNldCBhbnkgYG1heFdhaXRgIHRpbWVyLlxuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgLy8gSW52b2tlIHRoZSBsZWFkaW5nIGVkZ2UuXG4gICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtYWluaW5nV2FpdCh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZSxcbiAgICAgICAgdGltZVdhaXRpbmcgPSB3YWl0IC0gdGltZVNpbmNlTGFzdENhbGw7XG5cbiAgICByZXR1cm4gbWF4aW5nXG4gICAgICA/IG5hdGl2ZU1pbih0aW1lV2FpdGluZywgbWF4V2FpdCAtIHRpbWVTaW5jZUxhc3RJbnZva2UpXG4gICAgICA6IHRpbWVXYWl0aW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gc2hvdWxkSW52b2tlKHRpbWUpIHtcbiAgICB2YXIgdGltZVNpbmNlTGFzdENhbGwgPSB0aW1lIC0gbGFzdENhbGxUaW1lLFxuICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgLy8gRWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IGNhbGwsIGFjdGl2aXR5IGhhcyBzdG9wcGVkIGFuZCB3ZSdyZSBhdCB0aGVcbiAgICAvLyB0cmFpbGluZyBlZGdlLCB0aGUgc3lzdGVtIHRpbWUgaGFzIGdvbmUgYmFja3dhcmRzIGFuZCB3ZSdyZSB0cmVhdGluZ1xuICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICByZXR1cm4gKGxhc3RDYWxsVGltZSA9PT0gdW5kZWZpbmVkIHx8ICh0aW1lU2luY2VMYXN0Q2FsbCA+PSB3YWl0KSB8fFxuICAgICAgKHRpbWVTaW5jZUxhc3RDYWxsIDwgMCkgfHwgKG1heGluZyAmJiB0aW1lU2luY2VMYXN0SW52b2tlID49IG1heFdhaXQpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRpbWVyRXhwaXJlZCgpIHtcbiAgICB2YXIgdGltZSA9IG5vdygpO1xuICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgIHJldHVybiB0cmFpbGluZ0VkZ2UodGltZSk7XG4gICAgfVxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgcmVtYWluaW5nV2FpdCh0aW1lKSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgIHRpbWVySWQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBPbmx5IGludm9rZSBpZiB3ZSBoYXZlIGBsYXN0QXJnc2Agd2hpY2ggbWVhbnMgYGZ1bmNgIGhhcyBiZWVuXG4gICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgaWYgKHRyYWlsaW5nICYmIGxhc3RBcmdzKSB7XG4gICAgICByZXR1cm4gaW52b2tlRnVuYyh0aW1lKTtcbiAgICB9XG4gICAgbGFzdEFyZ3MgPSBsYXN0VGhpcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgIGlmICh0aW1lcklkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICB9XG4gICAgbGFzdEludm9rZVRpbWUgPSAwO1xuICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZWJvdW5jZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgaXNJbnZva2luZyA9IHNob3VsZEludm9rZSh0aW1lKTtcblxuICAgIGxhc3RBcmdzID0gYXJndW1lbnRzO1xuICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lO1xuXG4gICAgaWYgKGlzSW52b2tpbmcpIHtcbiAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGxlYWRpbmdFZGdlKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgIC8vIEhhbmRsZSBpbnZvY2F0aW9ucyBpbiBhIHRpZ2h0IGxvb3AuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgcmV0dXJuIGludm9rZUZ1bmMobGFzdENhbGxUaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVySWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICBkZWJvdW5jZWQuZmx1c2ggPSBmbHVzaDtcbiAgcmV0dXJuIGRlYm91bmNlZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVib3VuY2U7XG4iLCJpbXBvcnQgZGVib3VuY2UgZnJvbSAnLi9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBFcnJvciBtZXNzYWdlIGNvbnN0YW50cy4gKi9cbnZhciBGVU5DX0VSUk9SX1RFWFQgPSAnRXhwZWN0ZWQgYSBmdW5jdGlvbic7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHRocm90dGxlZCBmdW5jdGlvbiB0aGF0IG9ubHkgaW52b2tlcyBgZnVuY2AgYXQgbW9zdCBvbmNlIHBlclxuICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAqIG1ldGhvZCB0byBjYW5jZWwgZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG9cbiAqIGltbWVkaWF0ZWx5IGludm9rZSB0aGVtLiBQcm92aWRlIGBvcHRpb25zYCB0byBpbmRpY2F0ZSB3aGV0aGVyIGBmdW5jYFxuICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICogdGltZW91dC4gVGhlIGBmdW5jYCBpcyBpbnZva2VkIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZVxuICogdGhyb3R0bGVkIGZ1bmN0aW9uLiBTdWJzZXF1ZW50IGNhbGxzIHRvIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gcmV0dXJuIHRoZVxuICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICpcbiAqICoqTm90ZToqKiBJZiBgbGVhZGluZ2AgYW5kIGB0cmFpbGluZ2Agb3B0aW9ucyBhcmUgYHRydWVgLCBgZnVuY2AgaXNcbiAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gKlxuICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gKlxuICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLnRocm90dGxlYCBhbmQgYF8uZGVib3VuY2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3dhaXQ9MF0gVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdGhyb3R0bGUgaW52b2NhdGlvbnMgdG8uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxuICogQGV4YW1wbGVcbiAqXG4gKiAvLyBBdm9pZCBleGNlc3NpdmVseSB1cGRhdGluZyB0aGUgcG9zaXRpb24gd2hpbGUgc2Nyb2xsaW5nLlxuICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICpcbiAqIC8vIEludm9rZSBgcmVuZXdUb2tlbmAgd2hlbiB0aGUgY2xpY2sgZXZlbnQgaXMgZmlyZWQsIGJ1dCBub3QgbW9yZSB0aGFuIG9uY2UgZXZlcnkgNSBtaW51dGVzLlxuICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHRocm90dGxlZCk7XG4gKlxuICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdwb3BzdGF0ZScsIHRocm90dGxlZC5jYW5jZWwpO1xuICovXG5mdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gIHZhciBsZWFkaW5nID0gdHJ1ZSxcbiAgICAgIHRyYWlsaW5nID0gdHJ1ZTtcblxuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgfVxuICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBsZWFkaW5nID0gJ2xlYWRpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMubGVhZGluZyA6IGxlYWRpbmc7XG4gICAgdHJhaWxpbmcgPSAndHJhaWxpbmcnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMudHJhaWxpbmcgOiB0cmFpbGluZztcbiAgfVxuICByZXR1cm4gZGVib3VuY2UoZnVuYywgd2FpdCwge1xuICAgICdsZWFkaW5nJzogbGVhZGluZyxcbiAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgJ3RyYWlsaW5nJzogdHJhaWxpbmdcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRocm90dGxlO1xuIiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUNhbGxiYWNrLCB1c2VSZWYsIHVzZVN0YXRlIGFzIHVzZVN0YXRlUCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBTbGlnaHRseSBlbmhhbmNlZCB2ZXJzaW9uIG9mIGB1c2VTdGF0ZWAgdGhhdCBpbmNsdWRlcyBhIGdldHRlciB0aGF0IHJlbWFpbnMgY29uc3RhbnRcbiAqIChpLmUuIHlvdSBjYW4gdXNlIGl0IGluIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaXQgYmVpbmcgYSBkZXBlbmRlbmN5KS5cbiAqIFxuICogQHBhcmFtIGluaXRpYWxTdGF0ZSBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGU8VD4oaW5pdGlhbFN0YXRlOiBUIHwgKCgpID0+IFQpKTogcmVhZG9ubHkgW3ZhbHVlOiBULCBzZXRWYWx1ZTogU3RhdGVVcGRhdGVyPFQ+LCBnZXRWYWx1ZTogKCkgPT4gVF0ge1xuXG4gICAgLy8gV2Uga2VlcCBib3RoLCBidXQgb3ZlcnJyaWRlIHRoZSBgc2V0U3RhdGVgIGZ1bmN0aW9uYWxpdHlcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlUF0gPSB1c2VTdGF0ZVAoaW5pdGlhbFN0YXRlKTtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoc3RhdGUpO1xuXG4gICAgLy8gSGlqYWNrIHRoZSBub3JtYWwgc2V0dGVyIGZ1bmN0aW9uIFxuICAgIC8vIHRvIGFsc28gc2V0IG91ciByZWYgdG8gdGhlIG5ldyB2YWx1ZVxuICAgIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2s8U3RhdGVVcGRhdGVyPFQ+Pih2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB2YWx1ZSBhcyAoKF9wcmV2VmFsdWU6IFQpID0+IFQpO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHByZXZWYWx1ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gY2FsbGJhY2socHJldlZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYuY3VycmVudCA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV4dFZhbHVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZWYuY3VycmVudCA9IHZhbHVlO1xuICAgICAgICAgICAgc2V0U3RhdGVQKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IGdldFN0YXRlID0gKCkgPT4geyByZXR1cm4gcmVmLmN1cnJlbnQ7IH07XG5cblxuICAgIGNvbnNvbGUuYXNzZXJ0KHJlZi5jdXJyZW50ID09PSBzdGF0ZSB8fCAodHlwZW9mIHN0YXRlID09PSBcIm51bWJlclwiICYmIGlzTmFOKHN0YXRlKSkpO1xuICAgIHJldHVybiBbc3RhdGUsIHNldFN0YXRlLCBnZXRTdGF0ZV0gYXMgY29uc3Q7XG59IiwiXHJcbmltcG9ydCBkZWJvdW5jZSwgeyBEZWJvdW5jZWRGdW5jLCB0eXBlIERlYm91bmNlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL2RlYm91bmNlXCI7XHJcbmltcG9ydCB0aHJvdHRsZSwgeyB0eXBlIFRocm90dGxlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL3Rocm90dGxlXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbyB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG50eXBlIEZ1bmMgPSAoLi4uYXJnczogYW55KSA9PiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93bjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNQYXJhbWV0ZXJzPEFQIGV4dGVuZHMgdW5rbm93bltdLCBTUCBleHRlbmRzIHVua25vd25bXSA9IEFQPiB7XHJcbiAgICAvKipcclxuICAgICAqIElmIHByb3ZpZGVkLCBhZGRzIGEgZGVib3VuY2UgYmVoYXZpb3IgKmluIGFkZGl0aW9uKiB0b1xyXG4gICAgICogdGhlIGRlZmF1bHQgXCJ3YWl0IHVudGlsIHJlc29sdmVkXCIgdGhyb3R0bGluZyBiZWhhdmlvci5cclxuICAgICAqL1xyXG4gICAgZGVib3VuY2U/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCBgdXNlQXN5bmNgIHdpdGggYXV0by10aHJvdHRsZSBiYXNlZCBvbiBob3cgbG9uZyBpdCB0YWtlc1xyXG4gICAgICogZm9yIHRoZSBvcGVyYXRpb24gdG8gY29tcGxldGUuICBJZiB5b3Ugd291bGQgbGlrZSB0aGVyZSB0byBiZSBhXHJcbiAgICAgKiBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGFsbG93aW5nIGEgc2Vjb25kIG9wZXJhdGlvbixcclxuICAgICAqIHRoZSBgdGhyb3R0bGVgIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBhZGRpdGlvbiB0byB0aGF0IGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICB0aHJvdHRsZT86IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYW4gYXN5bmMgZnVuY3Rpb24gaXMgZGVib3VuY2VkIGR1ZSB0byBvbmUgYWxyZWFkeSBydW5uaW5nLFxyXG4gICAgICogaXQgd2lsbCBydW4gb24gYSBkZWxheSBhbmQsIGFzIGEgcmVzdWx0LCB0aGUgb3JpZ2luYWwgYXJndW1lbnRzXHJcbiAgICAgKiB0aGF0IHdlcmUgcGFzc2VkIHRvIGl0IG1heSBuZWVkIHRvIGJlIGFkanVzdGVkIHRvIGFjY291bnQgZm9yIHRoYXQuXHJcbiAgICAgKiBcclxuICAgICAqIEZvciBleGFtcGxlLCBkdXJpbmcgYG9uSW5wdXRgLCB0aGUgYHZhbHVlYCBvZiB0aGF0IGV2ZW50IGlzbid0IHN0b3JlZFxyXG4gICAgICogaW4gdGhlIGV2ZW50IGl0c2VsZiwgaXQncyBzdG9yZWQgaW4gdGhlIGBIVE1MSW5wdXRFbGVtZW50YCB0aGF0IHJhaXNlZCBpdC5cclxuICAgICAqIFNvIHdoZW4gb3VyIGhhbmRsZXIgYWN0dWFsbHkgcnVucyBhIGZldyBzZWNvbmRzIGxhdGVyLCBpdCdsbCByZWFkIHRoZSAqKm5leHQqKlxyXG4gICAgICogYGV2ZW50LmN1cnJlbnRUYXJnZXQudmFsdWVgLCBpbnN0ZWFkIG9mIHRoZSBvbmUgZnJvbSBhIGZldyBzZWNvbmRzIGFnbyBcclxuICAgICAqIHRoYXQgYWN0dWFsbHkgcmFpc2VkIHRoZSBldmVudCFcclxuICAgICAqIFxyXG4gICAgICogSWYgdGhlIGFyZ3VtZW50cyB0byB5b3VyIGhhbmRsZXIgcmVxdWlyZSByZWZlcmVuY2luZyBkYXRhIGluIHRoZSBhcmd1bWVudHNcclxuICAgICAqIHRoYXQgbWF5IGJlY29tZSBcInN0YWxlXCIgYnkgdGhlIHRpbWUgdGhlIGZ1bmN0aW9uIGFjdHVhbGx5IHJ1bnMgKGdlbmVyYWxseSBldmVudFxyXG4gICAgICogaGFuZGxlcnMgYW5kIG90aGVyIHRoaW5ncyB0aGF0IHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiBleGlzdGluZyBvYmplY3RzKSxcclxuICAgICAqIHRoZSBgY2FwdHVyZWAgcGFyYW1ldGVyIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIHRoZSBwYXJhbWV0ZXJzIHlvdSB3ZXJlIGdpdmVuXHJcbiAgICAgKiB3aGVuIHRoZSByZXF1ZXN0IHRvIHJ1biB3YXMgaW5pdGlhbGx5IG1hZGUgaW50byBwYXJhbWV0ZXJzIHRoYXQgeW91IGhhdmVcclxuICAgICAqIGd1YXJhbnRlZWQgd2lsbCBzdGlsbCBiZSBnb29kIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGFjdHVhbGx5IHJ1bnMuXHJcbiAgICAgKi9cclxuICAgIGNhcHR1cmU/OiBDYXB0dXJlRnVuY3Rpb25UeXBlPEFQLCBTUD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNSZXR1cm5UeXBlPFNQIGV4dGVuZHMgdW5rbm93bltdLCBSPiB7XHJcblxyXG4gICAgLy9wcm9taXNlOiBQcm9taXNlPEF3YWl0ZWQ8UmV0dXJuVHlwZTxGPj4+IHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gYSBoYW5kbGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcsIHRoaXMgaXMgdHJ1ZS5cclxuICAgICAqIFxyXG4gICAgICogSXQgaXMgZmFsc2UgYmVmb3JlIHRoZSBmaXJzdCBleGVjdXRpb24sIHRydWUgZHVyaW5nIHRoZVxyXG4gICAgICogZmlyc3QgZXhlY3V0aW9uLCByZW1haW5zIHRydWUgaWYgY29udGludWluZyBpbW1lZGlhdGVseVxyXG4gICAgICogaW50byBhIHNlY29uZCwgYW5kIG9ubHkgcmV0dXJucyB0byBmYWxzZSB3aGVuIGEgaGFuZGxlclxyXG4gICAgICogY29tcGxldGVzIHdpdGggbm8gaGFuZGxlciBpbiB3YWl0aW5nLlxyXG4gICAgICovXHJcbiAgICBwZW5kaW5nOiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgcnVuLlxyXG4gICAgICogRG9lcyBub3QgaW5jbHVkZSB0aW1lcyB3aGVyZSBpdCB3YXMgdGhyb3R0bGVkIG9yIGRlYm91bmNlZCBhd2F5LlxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgZm9yIGtub3dpbmcgaWYgdGhlIGhhbmRsZXIgaGFzIGJlZW4gY2FsbGVkIHlldCwgb3IgZm9yXHJcbiAgICAgKiBzZXR0aW5nIGEgbmV3IHRpbWVvdXQgdG8gc2hvdyBhIHNwaW5uZXIuXHJcbiAgICAgKi9cclxuICAgIGNhbGxDb3VudDogbnVtYmVyO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgc2V0dGxlZFxyXG4gICAgICogKHJlc29sdmVkIG9yIHJlamVjdGVkKSwgc2ltaWxhcmx5IHRvIGBjYWxsQ291bnRgLlxyXG4gICAgICogXHJcbiAgICAgKiBVc2VmdWwgZm9yIGtub3dpbmcgaWYgdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBldmVuIG9uY2UgeWV0LFxyXG4gICAgICogb3IganVzdCBmb3Igd2hlbiB0aGUgaGFuZGxlciBoYXMgZmluaXNoZWRcclxuICAgICAqL1xyXG4gICAgc2V0dGxlQ291bnQ6IG51bWJlcjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHksIFxyXG4gICAgICogc2ltaWxhcmx5IHRvIGBzZXR0bGVDb3VudGAuXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmVDb3VudDogbnVtYmVyO1xyXG5cclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGZhaWxlZCB0byBjb21wbGV0ZSwgXHJcbiAgICAgKiBzaW1pbGFybHkgdG8gYHJlc29sdmVDb3VudGAuXHJcbiAgICAgKi9cclxuICAgIHJlamVjdENvdW50OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IHJldHVybmVkIGZyb20gYSBzdWNjZXNzZnVsIGhhbmRsZXIgaW52b2NhdGlvbixcclxuICAgICAqIG9yIHVuZGVmaW5lZCBpZiBubyBoYW5kbGVyIGhhcyBzdWNjZXNzZnVsbHkgcmV0dXJuZWQgeWV0LlxyXG4gICAgICogXHJcbiAgICAgKiBJZiB0aGUgaGFuZGxlciByZWplY3RzIGFmdGVyIGhhdmluZyBzdWNjZWVkZWQgcHJldmlvdXNseSwgdGhlblxyXG4gICAgICogYHJlc3VsdGAgd2lsbCBzdGlsbCBrZWVwIGl0cyB2YWx1ZTsgaXQgd29uJ3QgYmUgXCJlcmFzZWRcIiBkdWUgdG8gdGhlIGVycm9yLlxyXG4gICAgICogVGhpcyBtZWFucyB0aGF0IGByZXN1bHRgIGFuZCBgZXJyb3JgIGNhbiBib3RoIGJlIHBvcHVsYXRlZCBhdCB0aGUgc2FtZSB0aW1lLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIGhhc1Jlc3VsdCBmb3IgaWYgYHJlc3VsdGAgYmVpbmcgYHVuZGVmaW5lZGAgbWVhbnMgaXQncyB1bmZpbmlzaGVkIG9yIHRoZSBmdW5jdGlvbiBpdHNlbGYgcmV0dXJuZWQgYHVuZGVmaW5lZGAuXHJcbiAgICAgKi9cclxuICAgIHJlc3VsdDogUiB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRydWUgd2hlbiB0aGUgbW9zdCByZWNlbnRseS1ydW4gaGFuZGxlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LFxyXG4gICAgICogYWxzbyBtZWFuaW5nIHRoYXQgdGhhdCBpdCdzIHJldHVybmVkIGEgdmFsdWUgdGhhdCB3ZSBjdXJyZW50bHkgaGF2ZS5cclxuICAgICAqIFxyXG4gICAgICogV2hpbGUgYHBlbmRpbmdgIGlzIHRydWUsICoqYGhhc1Jlc3VsdGAgYW5kIGBoYXNFcnJvcmAgbWF5IGJlIHNpbXVsdGFuZW91c2x5IHRydWUqKixcclxuICAgICAqIGJ1dCBpbiBhbGwgb3RoZXIgY2FzZXMgdGhleSdyZSBtdXR1YWxseSBleGNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGhhc1Jlc3VsdDogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSBlcnJvciB0aGUgaGFuZGxlciB0aHJldy4gYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB0aG91Z2ggbm90ZVxyXG4gICAgICogdGhhdCBgdW5kZWZpbmVkYCBpcyBhIHZhbGlkIHRoaW5nIHRvIHRocm93LCBzbyBjaGVjayBgaGFzRXJyb3JgIHRvby5cclxuICAgICAqIFxyXG4gICAgICogQHNlZSBoYXNFcnJvclxyXG4gICAgICovXHJcbiAgICBlcnJvcjogdW5rbm93bjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBtb3N0IHJlY2VudCBoYW5kbGVyIGZpbmlzaGVkIHdpdGggYW4gZXJyb3IuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2UsIHRlY2huaWNhbGx5LCBgZXJyb3JgIGNhbiBiZSBgdW5kZWZpbmVkYC5cclxuICAgICAqL1xyXG4gICAgaGFzRXJyb3I6IGJvb2xlYW47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSBhbnkgY3VycmVudGx5IGRlYm91bmNlZC1idXQtZXZlbnR1YWxseS1wZW5kaW5nIHByb21pc2VzIHRvIGltbWVkaWF0ZWx5IGJlIGNvbnNpZGVyZWQgYnkgY2FuY2VsbGluZyB0aGVpciBkZWJvdW5jZSB0aW1lb3V0LFxyXG4gICAgICogeW91IGNhbiBjYWxsIHRoaXMgZnVuY3Rpb24uICBOb3JtYWwgcHJvY2VkdXJlIGFwcGxpZXMgYXMgaWYgdGhlIGRlYm91bmNlZCBlbmRlZCBub3JtYWxseSAtLSBpZiB0aGVyZSdzIG5vIHByb21pc2Ugd2FpdGluZyBpbiB0aGUgcXVldWUsXHJcbiAgICAgKiB0aGUgZGVib3VuY2VkIHByb21pc2UgcnVucyBub3JtYWxseSwgb3RoZXJ3aXNlLCBpdCB3YWl0cyBpdHMgdHVybiB1bnRpbCB0aGUgY3VycmVudCBvbmUgZW5kcywgcG90ZW50aWFsbHkgYmVpbmcgb3ZlcndyaXR0ZW4gbGF0ZXIgb25cclxuICAgICAqIGlmIGEgbmV3IHByb21pc2UgcnVucyBvdXQgKml0cyogZGVib3VuY2UgdGltZXIgYmVmb3JlIHRoaXMgb25lIGdvdCBhIGNoYW5jZSB0byBydW4uXHJcbiAgICAgKiBcclxuICAgICAqICoqUXVhc2ktc3RhYmxlKiogKGRvbid0IHVzZSBkdXJpbmcgcmVuZGVyKVxyXG4gICAgICovXHJcbiAgICBmbHVzaERlYm91bmNlZFByb21pc2U6ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlZCBvbiB0aGUgdHlwZSBvZiBoYW5kbGVyIHBhc3NlZCBpbiwgdGhpcyByZXR1cm5lZCB2YWx1ZSB3aWxsXHJcbiAgICAgKiByZXByZXNlbnQgd2hhdCB0eXBlIG9mIGhhbmRsZXIgaXQgd2FzLCBqdXN0IGluIGNhc2UgeW91XHJcbiAgICAgKiB5b3Vyc2VsZiBuZWVkIHRvIGtub3cgdGhhdCBhbmQgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsXHJcbiAgICAgKiB0byBmaW5kIG91dCB3aXRob3V0IGl0IGFjdHVhbGx5IGJlaW5nIHJ1bi5cclxuICAgICAqIFxyXG4gICAgICogVW50aWwgYSBoYW5kbGVyIGlzIGNhbGxlZCwgdGhpcyB3aWxsIGJlIG51bGwuICBOYXR1cmFsbHksIGlmIFxyXG4gICAgICogZGlmZmVyZW50IGhhbmRsZXJzIGFyZSBwYXNzZWQgaW4sIGl0IGNhbiBmbGlwIGJhY2sgYW5kXHJcbiAgICAgKiBmb3J0aCBiZXR3ZWVuIFwiYXN5bmNcIiBhbmQgXCJzeW5jXCIgYXMgd2VsbC5cclxuICAgICAqL1xyXG4gICAgY3VycmVudFR5cGU6IG51bGwgfCBcInN5bmNcIiB8IFwiYXN5bmNcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmFuc2Zvcm1lZCB2ZXJzaW9uIG9mIHRoZSBhc3luYyBoYW5kbGVyIHByb3ZpZGVkLFxyXG4gICAgICogbm93IHN5bmNocm9ub3VzIGFuZC9vciB0aHJvdHRsZWQgYW5kL29yIGRlYm91bmNlZFxyXG4gICAgICogXHJcbiAgICAgKiAqKlF1YXNpLXN0YWJsZSoqIChkb24ndCB1c2UgZHVyaW5nIHJlbmRlcilcclxuICAgICAqL1xyXG4gICAgc3luY0hhbmRsZXI6IFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+O1xyXG59XHJcblxyXG5mdW5jdGlvbiBpZGVudGl0eTxBUCBleHRlbmRzIHVua25vd25bXSwgU1AgZXh0ZW5kcyB1bmtub3duW10+KC4uLnQ6IFNQKSB7IHJldHVybiB0IGFzIHVua25vd25bXSBhcyBBUDsgfVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbi5cclxuICogXHJcbiAqIElmIHRoZSBjYWxsYmFjayBpcyBgbnVsbGAsIHRoZW4gYG51bGxgIHdpbGwgYmUgcmV0dXJuZWQsIG90aGVyd2lzZSBgY2FsbGJhY2tgIG11c3QgYmUgc3RhYmxlIGZvciB0aGlzIHRvIHdvcmsgYXMgaW50ZW50ZWQuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhyb3R0bGVkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IFRocm90dGxlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVGhyb3R0bGVkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IFRocm90dGxlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xyXG4gICAgY29uc3QgdGhyb3R0bGVkID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gdGhyb3R0bGUoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcclxuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8udHJhaWxpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB0aHJvdHRsZWQ/LmNhbmNlbCgpO1xyXG4gICAgfSwgW3Rocm90dGxlZF0pXHJcblxyXG4gICAgcmV0dXJuIHRocm90dGxlZDtcclxufVxyXG5cclxuLyoqXHJcbiAqIFJldHVybnMgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYGRlYm91bmNlZGAgZnVuY3Rpb24uXHJcbiAqIFxyXG4gKiBJZiB0aGUgY2FsbGJhY2sgaXMgYG51bGxgLCB0aGVuIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgYGNhbGxiYWNrYCBtdXN0IGJlIHN0YWJsZSBmb3IgdGhpcyB0byB3b3JrIGFzIGludGVudGVkLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+O1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURlYm91bmNlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBEZWJvdW5jZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xyXG4gICAgY29uc3QgZGVib3VuY2VkID0gdXNlTWVtbygoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gZGVib3VuY2UoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcclxuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8ubWF4V2FpdCwgb3B0aW9ucz8udHJhaWxpbmddKTtcclxuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIHJldHVybiAoKSA9PiBkZWJvdW5jZWQ/LmNhbmNlbCgpO1xyXG4gICAgfSwgW2RlYm91bmNlZF0pXHJcblxyXG4gICAgcmV0dXJuIGRlYm91bmNlZDtcclxufVxyXG5cclxudHlwZSBTeW5jRnVuY3Rpb25UeXBlPFNQIGV4dGVuZHMgdW5rbm93bltdLCBSPiA9ICguLi5hcmdzOiBTUCkgPT4gKFIgfCB1bmRlZmluZWQpO1xyXG50eXBlIEFzeW5jRnVuY3Rpb25UeXBlPEFQIGV4dGVuZHMgdW5rbm93bltdLCBSPiA9ICgoLi4uYXJnczogQVApID0+IChSIHwgUHJvbWlzZTxSPikpO1xyXG50eXBlIEdsdWVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKGVucXVldWU6IGJvb2xlYW4sIC4uLmFyZ3M6IEFQKSA9PiBSIHwgdW5kZWZpbmVkO1xyXG50eXBlIENhcHR1cmVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+ID0gKC4uLmFyZ3M6IFNQKSA9PiBBUDtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiBhbiBhc3luYyBmdW5jdGlvbiwgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQncyBzdWl0YWJsZSBmb3Igbm9uLWFzeW5jIEFQSXMsIFxyXG4gKiBhbG9uZyB3aXRoIG90aGVyIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHJ1bidzIHN0YXR1cy5cclxuICogXHJcbiAqIFNlZSBhbHNvIGB1c2VBc3luY0hhbmRsZXJgIGZvciBhIHZlcnNpb24gdGhhdCdzIHNwZWNpYWxpemVkIGZvciBET00gZXZlbnQgaGFuZGxlcnMuXHJcbiAqIFxyXG4gKiBXaGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBxdWljayBzdWNjZXNzaW9uLCAoaS5lLiBiZWZvcmUgdGhlIGhhbmRsZXIgaGFzIGZpbmlzaGVkKSwgXHJcbiAqIHRoaXMgd29ya3MgbGlrZSBMb2Rhc2gncyBgdGhyb3R0bGVgIGZ1bmN0aW9uIHdpdGggdGhlIGB3YWl0YCBvcHRpb24gYWx3YXlzXHJcbiAqIHNldCB0byBob3dldmVyIGxvbmcgdGhlIGhhbmRsZXIgdGFrZXMgdG8gY29tcGxldGUuIEEgc2Vjb25kIGNhbGwgdG8gdGhlIHN5bmMgZnVuY3Rpb24gd2lsbCBiZSBcclxuICogdGhyb3R0bGVkIHVudGlsIHRoZSBmaXJzdCBjYWxsIGhhcyBmaW5pc2hlZC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBcclxuICogb2YgdGhlIHByZXZpb3VzIGludm9jYXRpb24sIG9yIGB1bmRlZmluZWRgIG9uIHRoZSBmaXJzdCBjYWxsLlxyXG4gKiBcclxuICogVGhlIGhhbmRsZXIgaXMgb25seSBldmVyIGRlbGF5ZWQgaWYgb25lIGlzIGN1cnJlbnRseSBydW5uaW5nLCBzbywgZS5nLiBmb3IgaU9TIHRvdWNoIGV2ZW50cyB0aGVcclxuICogZmlyc3QgY2FsbCBoYXBwZW5zIGluIHRoZSBzYW1lIGV2ZW50IGhhbmRsZXIgKHdoaWNoIG1lYW5zIHRoaW5ncyBsaWtlIGNhbGxzIHRvIGBlbGVtZW50LmZvY3VzKClgXHJcbiAqIHdpbGwgd29yayBhcyBpbnRlbmRlZCwgc2luY2UgdGhhdCBmYWlscyB3aGVuIHRoZSBldmVudCBpcyBcInNwbGl0IHVwXCIpXHJcbiAqIFxyXG4gKiBGaW5hbGx5LCBiZWNhdXNlIHRoZSBzeW5jIGhhbmRsZXIgbWF5IGJlIGludm9rZWQgb24gYSBkZWxheSwgYW55IHByb3BlcnR5IHJlZmVyZW5jZXMgb24gdGhlIGFyZ3VtZW50c1xyXG4gKiBwcm92aWRlZCBtaWdodCBiZSBzdGFsZSBieSB0aGUgdGltZSBpdCdzIGFjdHVhbGx5IGludm9rZWQgKGUuZy4gYWNjZXNzaW5nIGBldmVudC5jdXJyZW50VGFyZ2V0LmNoZWNrZWRgXHJcbiAqIGlzIG5vdCBzdGFibGUgYWNyb3NzIHRpbWUgYmVjYXVzZSBpdCdzIGEgXCJsaXZlXCIgdmFsdWUgLS0geW91IGFsbW9zdCBhbHdheXMgd2FudCB0aGUgdmFsdWUgdGhhdCBpdFxyXG4gKiBoYWQgYXQgdGhlIG9yaWdpbmFsIHRpbWUgdGhlIGhhbmRsZXIgd2FzIGNhbGxlZCkuIFRoZSBgY2FwdHVyZWAgb3B0aW9uIGFsbG93cyB5b3UgdG8gc2F2ZSB0aGF0IGtpbmQgb2ZcclxuICogZHluYW1pYyBkYXRhIGF0IHRoZSB0aW1lIGl0IHJ1bnM7IHRoZSBgQVBgIGFuZCBgU1BgIHR5cGUgcGFyYW1ldGVycyBsaWtld2lzZSBjb250cm9sXHJcbiAqIHRoZSBwYXJhbWV0ZXJzIHRoZSBhc3luYyBoYW5kbGVyIGFuZCBzeW5jIGhhbmRsZXIgZXhwZWN0IHJlc3BlY3RpdmVseS5cclxuICogXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFIsIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+KGFzeW5jSGFuZGxlcjogQXN5bmNGdW5jdGlvblR5cGU8QVAsIFI+IHwgbnVsbCwgb3B0aW9ucz86IFVzZUFzeW5jUGFyYW1ldGVyczxBUCwgU1A+KTogVXNlQXN5bmNSZXR1cm5UeXBlPFNQLCBSPiB7XHJcblxyXG5cclxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xyXG4gICAgbGV0IHsgdGhyb3R0bGUsIGRlYm91bmNlLCBjYXB0dXJlIH0gPSAob3B0aW9ucyA/PyB7fSk7XHJcbiAgICBjYXB0dXJlID8/PSBpZGVudGl0eTtcclxuXHJcbiAgICAvLyBXZSBrZWVwLCBsaWtlLCBhIGxvdCBvZiByZW5kZXItc3RhdGUsIGJ1dCBpdCBvbmx5IGV2ZXIgdHJpZ2dlcnMgYSByZS1yZW5kZXJcclxuICAgIC8vIHdoZW4gd2Ugc3RhcnQvc3RvcCBhbiBhc3luYyBhY3Rpb24uXHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aGlzIGZvciB0aGUgY2FsbGVyJ3Mgc2FrZSAtLSB3ZSBkb24ndCByZWFsbHkgY2FyZS5cclxuICAgIGNvbnN0IFtjdXJyZW50VHlwZSwgc2V0Q3VycmVudFR5cGVdID0gdXNlU3RhdGU8bnVsbCB8IFwic3luY1wiIHwgXCJhc3luY1wiPihudWxsKTtcclxuICAgIGNvbnN0IFtydW5Db3VudCwgc2V0UnVuQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2V0dGxlQ291bnQsIHNldFNldHRsZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3Jlc29sdmVDb3VudCwgc2V0UmVzb2x2ZUNvdW50XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3JlamVjdENvdW50LCBzZXRSZWplY3RDb3VudF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICAvLyBUaGluZ3MgcmVsYXRlZCB0byBjdXJyZW50IGV4ZWN1dGlvblxyXG4gICAgLy8gQmVjYXVzZSB3ZSBjYW4gYm90aCByZXR1cm4gYW5kIHRocm93IHVuZGVmaW5lZCwgXHJcbiAgICAvLyB3ZSBuZWVkIHNlcGFyYXRlIHN0YXRlIHRvIHRyYWNrIHRoZWlyIGV4aXN0YW5jZSB0b28uXHJcbiAgICBjb25zdCBbcGVuZGluZywgc2V0UGVuZGluZywgZ2V0UGVuZGluZ10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHQsIGdldFJlc3VsdF0gPSB1c2VTdGF0ZTxSPih1bmRlZmluZWQhKTtcclxuICAgIGNvbnN0IFtlcnJvciwgc2V0RXJyb3IsIF9nZXRFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duPih1bmRlZmluZWQhKTtcclxuICAgIGNvbnN0IFtoYXNFcnJvciwgc2V0SGFzRXJyb3IsIF9nZXRIYXNFcnJvcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbaGFzUmVzdWx0LCBzZXRIYXNSZXN1bHQsIF9nZXRIYXNSZXN1bHRdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIC8vIFdlIGltcGxlbWVudCBvdXIgb3duIHRocm90dGxpbmcgYmVoYXZpb3IgaW4gcmVnYXJkcyB0byB3YWl0aW5nIHVudGlsIHRoZSBhc3luYyBoYW5kbGVyIGZpbmlzaGVzLlxyXG4gICAgLy8gVGhlc2UgdHdvIHBhc3NpdmUgc3RhdGUgdmFyaWFibGVzIGtlZXAgdHJhY2sgb2YgdGhhdCwgYXV0b21hdGljYWxseSBxdWV1ZWluZy9kZXF1ZXVpbmcgdGhlIG5leHQgaGFuZGxlci5cclxuICAgIGNvbnN0IFtnZXRRdWV1ZWQsIHNldFF1ZXVlZF0gPSB1c2VQYXNzaXZlU3RhdGU8QVAgfCBudWxsPihudWxsLCByZXR1cm5OdWxsKTtcclxuXHJcblxyXG4gICAgLy8gVGhlIGFjdHVhbCBzeW5jIGhhbmRsZXIuXHJcbiAgICAvLyBDYXB0dXJlL3RyYW5zZm9ybSB0aGUgZ2l2ZW4gcGFyYW1ldGVycyBpZiBhcHBsaWNhYmxlLFxyXG4gICAgLy8gdGhlbiBydW4gZnVydGhlciBsb2dpYyB0aGF0J3MgZGVib3VuY2VkL3Rocm90dGxlZFxyXG4gICAgY29uc3QgY2FwdHVyZUFyZ3NBbmRFeGVjdXRlRGVib3VuY2VkSGFuZGxlciA9IHVzZVN0YWJsZUNhbGxiYWNrPFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+PihmdW5jdGlvbiBvbk5ld0V4ZWN1dGVSZXF1ZXN0KC4uLm5ld0FyZ3MyOiBTUCkge1xyXG5cclxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBhcmd1bWVudHMgd2Ugd2VyZSBnaXZlbi5cclxuICAgICAgICAvLyBXZSBtaWdodCB1c2UgdGhlbSBpbW1lZGlhdGVseSwgb3Igd2UgbWlnaHQgc3RvcmUgdGhlbSB0byBgcXVldWVkYCxcclxuICAgICAgICAvLyBidXQgaW4gZWl0aGVyIGNhc2Ugd2UgZG8gbmVlZCB0aGUgY2FwdHVyZWQgdmFsdWUuXHJcbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlISguLi5uZXdBcmdzMik7XHJcblxyXG4gICAgICAgIC8vIFRoaXMgaXMgYWxsIGxvZ2ljIHRoYXQgZGVhbHMgd2l0aCB0aGUgY2FwdHVyZWQgdmFsdWUgaW5zdGVhZCBvZiB0aGUgcmF3IGFyZ3VtZW50cy5cclxuICAgICAgICAvLyBJdCdzIGNhbGxlZCBpbiB0d28gc2VwYXJhdGUgY2lyY3Vtc3RhbmNlcyxcclxuICAgICAgICAvLyBhbmQgaGFzIHRoZSBkZWJvdW5jZS90aHJvdHRsZSBsb2dpYyBhbHJlYWR5IGFwcGxpZWRcclxuICAgICAgICByZXR1cm4gZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZ2V0UGVuZGluZygpLCAuLi5jYXB0dXJlZCk7XHJcblxyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVGhpcyBpcyB0aGUgbG9naWMgdGhhdCBydW5zIHdoZW4gdGhlIGhhbmRsZXIgaXMgKmp1c3QqIGFib3V0IHRvIHN0YXJ0LlxyXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpdHNlbGYgaXMgZnVydGhlciB0cmFuc2Zvcm1lZCB0byBiZSB0aHJvdHRsZWQvZGVib3VuY2VkIGlmIHJlcXVlc3RlZCxcclxuICAgIC8vIHNvIHRoaXMgbWlnaHQgbm90IGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBcclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlID0gdXNlU3RhYmxlQ2FsbGJhY2s8R2x1ZUZ1bmN0aW9uVHlwZTxBUCwgUj4+KGZ1bmN0aW9uIG9uTmV3RXhlY3V0ZVJlcXVlc3QyKGVucXVldWU6IGJvb2xlYW4sIC4uLm5ld0FyZ3M6IEFQKSB7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uVGhlbiA9ICh2YWx1ZTogUikgPT4geyBzZXRSZXN1bHQodmFsdWUpOyBzZXRIYXNSZXN1bHQodHJ1ZSk7IHNldEhhc0Vycm9yKGZhbHNlKTsgc2V0UmVzb2x2ZUNvdW50KHIgPT4gKytyKTsgfTtcclxuICAgICAgICBjb25zdCBvbkNhdGNoID0gKGV4OiBhbnkpID0+IHsgc2V0RXJyb3IoZXgpOyBzZXRIYXNFcnJvcih0cnVlKTsgc2V0SGFzUmVzdWx0KGZhbHNlKTsgc2V0UmVqZWN0Q291bnQociA9PiArK3IpOyB9O1xyXG4gICAgICAgIGNvbnN0IG9uRmluYWxseSA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcXVldWVkID0gZ2V0UXVldWVkKCk7XHJcbiAgICAgICAgICAgIHNldFNldHRsZUNvdW50KHMgPT4gKytzKTtcclxuICAgICAgICAgICAgaWYgKHF1ZXVlZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0UXVldWVkKG51bGwpO1xyXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZmFsc2UsIC4uLnF1ZXVlZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBpZiAoIWVucXVldWUpIHtcclxuICAgICAgICAgICAgLy8gTm90aGluZyBpcyBwZW5kaW5nIGF0IHRoZSBtb21lbnQsIHNvIHdlIGNhbiBydW4gb3VyIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxyXG4gICAgICAgICAgICBzZXRSdW5Db3VudChyID0+ICsrcik7XHJcbiAgICAgICAgICAgIHNldFBlbmRpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzeW5jSGFuZGxlcj8uKC4uLm5ld0FyZ3MpIGFzIFI7XHJcbiAgICAgICAgICAgIGNvbnN0IGlzUHJvbWlzZSA9IChyZXN1bHQgIT0gbnVsbCAmJiB0eXBlb2YgcmVzdWx0ID09IFwib2JqZWN0XCIgJiYgXCJ0aGVuXCIgaW4gKHJlc3VsdCBhcyB1bmtub3duIGFzIFByb21pc2U8YW55PikpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwgfHwgIWlzUHJvbWlzZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSXQncyBzeW5jaHJvbm91cyBhbmQgcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LlxyXG4gICAgICAgICAgICAgICAgLy8gQmFpbCBvdXQgZWFybHkuXHJcbiAgICAgICAgICAgICAgICBvblRoZW4ocmVzdWx0IGFzIFIpO1xyXG4gICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZShcInN5bmNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAocmVzdWx0IGFzIHVua25vd24gYXMgUHJvbWlzZTxSPikudGhlbihvblRoZW4pLmNhdGNoKG9uQ2F0Y2gpLmZpbmFsbHkob25GaW5hbGx5KTtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlKFwiYXN5bmNcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgc3RpbGwgcnVubmluZyBhIHByZXZpb3VzIGhhbmRsZXIsXHJcbiAgICAgICAgICAgIC8vIGp1c3Qgc2V0IG91cnNlbHZlcyBhcyB0aGUgbmV4dCBvbmUgdG8gcnVuIGFuZCBxdWl0IGVhcmx5LlxyXG4gICAgICAgICAgICAvLyBOb3RoaW5nIG1vcmUgdG8gZG8uXHJcbiAgICAgICAgICAgIHNldFF1ZXVlZChuZXdBcmdzKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuXHJcblxyXG4gICAgICAgIHJldHVybiBnZXRSZXN1bHQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPSB1c2VUaHJvdHRsZWQ8Tm9uTnVsbGFibGU8dHlwZW9mIGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlPj4oIXRocm90dGxlID8gbnVsbCA6IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlLCB0aHJvdHRsZSA/PyAwKTtcclxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aEQgPSB1c2VEZWJvdW5jZWQoIWRlYm91bmNlID8gbnVsbCA6IChleGVjdXRlSGFuZGxlcldpdGhUID8/IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlKSwgZGVib3VuY2UgPz8gMCk7XHJcbiAgICBjb25zdCBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZSA9IChleGVjdXRlSGFuZGxlcldpdGhEID8/IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPz8gZXhlY3V0ZUhhbmRsZXJXaXRob3V0RGVib3VuY2UpO1xyXG5cclxuICAgIGNvbnN0IGZsdXNoRGVib3VuY2VkUHJvbWlzZSA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAoZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UgJiYgXCJmbHVzaFwiIGluIGV4ZWN1dGVIYW5kbGVyV2l0aERlYm91bmNlKVxyXG4gICAgICAgICAgICBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZS5mbHVzaCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBzeW5jSGFuZGxlcjogY2FwdHVyZUFyZ3NBbmRFeGVjdXRlRGVib3VuY2VkSGFuZGxlcixcclxuICAgICAgICBjdXJyZW50VHlwZSxcclxuICAgICAgICBwZW5kaW5nLFxyXG4gICAgICAgIHJlc3VsdCxcclxuICAgICAgICBlcnJvcixcclxuICAgICAgICBoYXNFcnJvcixcclxuICAgICAgICBoYXNSZXN1bHQsXHJcbiAgICAgICAgcmVzb2x2ZUNvdW50LFxyXG4gICAgICAgIHJlamVjdENvdW50LFxyXG4gICAgICAgIHNldHRsZUNvdW50LFxyXG4gICAgICAgIGNhbGxDb3VudDogcnVuQ291bnQsXHJcbiAgICAgICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQXN5bmMsIFVzZUFzeW5jUGFyYW1ldGVycywgVXNlQXN5bmNSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWFzeW5jXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY0hhbmRsZXJQYXJhbWV0ZXJzPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4gZXh0ZW5kcyBPbWl0PFVzZUFzeW5jUGFyYW1ldGVyczxbQ2FwdHVyZVR5cGUsIEV2ZW50VHlwZV0sIFtFdmVudFR5cGVdPiwgXCJjYXB0dXJlXCI+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hhdCB0cmFuc2llbnQgaW5mb3JtYXRpb24gaXMgY2FwdHVyZWQgYnkgdGhpcyBldmVudCBcclxuICAgICAqIGFuZCBwcmVzZW50ZWQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIHRoZSBldmVudCBoYW5kbGVyP1xyXG4gICAgICogXHJcbiAgICAgKiBUaGUgXCJjYXB0dXJlXCIgcGFyYW1ldGVyIGFuc3dlcnMgdGhpcyBxdWVzdGlvbi4gVG8gaW1wbGVtZW50IGEgY2hlY2tib3gsIGZvciBleGFtcGxlLCByZXR1cm4gYHRhcmdldC5jaGVja2VkYC5cclxuICAgICAqL1xyXG4gICAgY2FwdHVyZTogKGV2ZW50OiBFdmVudFR5cGUpID0+IENhcHR1cmVUeXBlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUFzeW5jSGFuZGxlclJldHVyblR5cGU8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQsIENhcHR1cmVUeXBlPiBleHRlbmRzIFVzZUFzeW5jUmV0dXJuVHlwZTxbRXZlbnRUeXBlXSwgdm9pZD4ge1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG1vc3QgcmVjZW50bHkgY2FwdHVyZWQgdmFsdWUuIEluIG90aGVyIHdvcmRzLCByZXByZXNlbnRzIHdoYXRcclxuICAgICAqIHRoZSBjdXJyZW50IHZhbHVlIHdvdWxkIGJlIGlmIHRoaXMgb3BlcmF0aW9uIHdlcmUgc3luY2hyb25vdXMgYW5kIFxyXG4gICAgICogYW5kIGNvdWxkbid0IGZhaWwuIEl0J3MgdXNlZnVsIHRvIHByZXRlbmQgdGhpcyBpcyB0aGUgYWN0dWFsIHZhbHVlXHJcbiAgICAgKiBmb3IgYW4gaW5wdXQgZmllbGQsIGZvciBleGFtcGxlLCBzbyB0aGF0IHRoZSB2YWx1ZSBkb2Vzbid0IFwic25hcFxyXG4gICAgICogYmFja1wiIHdoaWxlIHlvdSdyZSB3YWl0aW5nIGZvciB0aGUgaGFuZGxlciB0byBmaW5pc2guXHJcbiAgICAgKiBcclxuICAgICAqIFNvbWV0aGluZyBsaWtlIGB2YWx1ZT17cGVuZGluZz8gY3VycmVudENhcHR1cmUgOiB2YWx1ZX1gIGlzIGdvb2QgZm9yIGNoZWNrYm94ZXMsXHJcbiAgICAgKiBzb21ldGhpbmcgbGlrZSBgdmFsdWU9eyhwZW5kaW5nIHx8IGhhc0ZvY3VzKT8gY3VycmVudENhcHR1cmUgOiB2YWx1ZX0gZm9yIHRleHQgZmllbGRzLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIGhhc0NhcHR1cmVcclxuICAgICAqL1xyXG4gICAgY3VycmVudENhcHR1cmU6IENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkO1xyXG5cclxuICAgIC8qKiBcclxuICAgICAqIFRoZSBhYm92ZSwgYnV0IHN0YWJsZSwgaWYgeW91IG5lZWQgdGhlIGN1cnJlbnQgY2FwdHVyZSB3aXRob3V0IGl0IGJlaW5nIGFuIGV4cGxpY2l0IGRlcGVuZGVuY3kuXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKiAgKi9cclxuICAgIGdldEN1cnJlbnRDYXB0dXJlKCk6IChDYXB0dXJlVHlwZSB8IHVuZGVmaW5lZCk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWNhdXNlIHlvdSdyZSBhbGxvd2VkIHRvIGhhdmUgYENhcHR1cmVUeXBlYCBleHRlbmQgYHVuZGVmaW5lZGAsXHJcbiAgICAgKiB5b3UgbWlnaHQgbmVlZCB0aGlzLlxyXG4gICAgICovXHJcbiAgICBoYXNDYXB0dXJlOiBib29sZWFuO1xyXG5cclxuICAgIC8vIFNhbWUgYXMgaW4gdXNlQXN5bmMsIGJ1dCB3aXRoIGEgZGlmZmVyZW50IHR5cGVcclxuICAgIC8vcHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGw7XHJcblxyXG59XHJcblxyXG4vKipcclxuICogR2l2ZW4gYW4gYXN5bmNyb25vdXMgZXZlbnQgaGFuZGxlciwgcmV0dXJucyBhIHN5bmNyb25vdXMgb25lIHRoYXQgd29ya3Mgb24gdGhlIERPTSxcclxuICogYWxvbmcgd2l0aCBzb21lIG90aGVyIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXHJcbiAqIERvZXMgbm90IG1vZGlmeSBhbnkgcHJvcHMuXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB0aGUgaGFuZGxlciB5b3UgcHJvdmlkZSBtYXkgYmUgY2FsbGVkIHdpdGggYSBkZWxheSwgYW5kIFxyXG4gKiBiZWNhdXNlIHRoZSB2YWx1ZSBvZiwgZS5nLiwgYW4gYDxpbnB1dD5gIGVsZW1lbnQgd2lsbCBsaWtlbHkgYmUgc3RhbGUgYnkgdGhlIFxyXG4gKiB0aW1lIHRoZSBkZWxheSBpcyBvdmVyLCBhIGBjYXB0dXJlYCBmdW5jdGlvbiBpcyBuZWNlc3NhcnkgaW4gb3JkZXIgdG8gXHJcbiAqIGNhcHR1cmUgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gQW55IG90aGVyIHNpbXBsZSBldmVudCBkYXRhLCBcclxuICogbGlrZSBgbW91c2VYYCBvciBgc2hpZnRLZXlgIGNhbiBzdGF5IG9uIHRoZSBldmVudCBpdHNlbGYgYW5kIGRvbid0IFxyXG4gKiBuZWVkIHRvIGJlIGNhcHR1cmVkICZuZGFzaDsgaXQncyBuZXZlciBzdGFsZS5cclxuICogXHJcbiAqIGBgYHRzeFxyXG4gKiBjb25zdCBhc3luY09uSW5wdXQgPSBhc3luYyAodmFsdWU6IG51bWJlciwgZTogRXZlbnQpID0+IHsgXHJcbiAqICAgICBbLi4uXSAvLyBFeC4gc2VuZCB0byBhIHNlcnZlciBhbmQgc2V0U3RhdGUgd2hlbiBkb25lXHJcbiAqIH07XHJcbiAqIGNvbnN0IHtcclxuICogICAgIC8vIEEgc3luYyB2ZXJzaW9uIG9mIGFzeW5jT25JbnB1dFxyXG4gKiAgICAgc3luY0hhbmRsZXIsXHJcbiAqICAgICAvLyBUcnVlIHdoaWxlIHRoZSBoYW5kbGVyIGlzIHJ1bm5pbmdcclxuICogICAgIHBlbmRpbmcsXHJcbiAqICAgICAvLyBUaGUgZXJyb3IgdGhyb3duLCBpZiBhbnlcclxuICogICAgIGVycm9yLFxyXG4gKiAgICAgLy8gU2hvdyB0aGlzIHZhbHVlIHdoaWxlIHRoZSBvcGVyYXRpb24ncyBwZW5kaW5nXHJcbiAqICAgICBjdXJyZW50Q2FwdHVyZSxcclxuICogICAgIC8vIEFuZCBvdGhlcnMsIHNlZSBgVXNlQXN5bmNIYW5kbGVyUmV0dXJuVHlwZWBcclxuICogICAgIC4uLnJlc3RcclxuICogfSA9IHVzZUFzeW5jSGFuZGxlcjxIVE1MSW5wdXRFbGVtZW50PigpKGFzeW5jT25JbnB1dCwgeyBcclxuICogICAgIC8vIFBhc3MgaW4gdGhlIGNhcHR1cmUgZnVuY3Rpb24gdGhhdCBzYXZlcyBldmVudCBkYXRhXHJcbiAqICAgICAvLyBmcm9tIGJlaW5nIHN0YWxlLlxyXG4gKiAgICAgY2FwdHVyZTogZSA9PiB7IFxyXG4gKiAgICAgICAgIC8vIGBjYXB0dXJlYCBjYW4gaGF2ZSBzaWRlLWVmZmVjdHMgYmVjYXVzZVxyXG4gKiAgICAgICAgIC8vIGl0J3MgY2FsbGVkIGV4YWN0bHkgb25jZSBwZXIgaW52b2NhdGlvblxyXG4gKiAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgXHJcbiAqIFxyXG4gKiAgICAgICAgIC8vIFNhdmUgdGhpcyB2YWx1ZSBzbyB0aGF0IGl0J3MgbmV2ZXIgc3RhbGVcclxuICogICAgICAgICByZXR1cm4gZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXI7XHJcbiAqICAgICB9XHJcbiAqIH0pO1xyXG4gKiBcclxuICogY29uc3Qgb25JbnB1dCA9IHBlbmRpbmc/IG51bGwgOiBzeW5jSGFuZGxlcjtcclxuICogYGBgXHJcbiAqIFxyXG4gKiBUaGUgaGFuZGxlciBpcyBhdXRvbWF0aWNhbGx5IHRocm90dGxlZCB0byBvbmx5IHJ1biBvbmUgYXQgYSB0aW1lLiBcclxuICogSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkLCBhbmQgdGhlbiBiZWZvcmUgaXQgZmluaXNoZXMsIGlzIGNhbGxlZCBhZ2FpbixcclxuICogaXQgd2lsbCBiZSBwdXQgb24gaG9sZCB1bnRpbCB0aGUgY3VycmVudCBvbmUgZmluaXNoZXMsIGF0IHdoaWNoIHBvaW50XHJcbiAqIHRoZSBzZWNvbmQgb25lIHdpbGwgcnVuLiAgSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkIGEgdGhpcmQgdGltZSBiZWZvcmVcclxuICogdGhlIGZpcnN0IGhhcyBmaW5pc2hlZCwgaXQgd2lsbCAqcmVwbGFjZSogdGhlIHNlY29uZCwgc28gb25seSB0aGUgbW9zdFxyXG4gKiByZWNlbnRseSBjYWxsZWQgaXRlcmF0aW9uIG9mIHRoZSBoYW5kbGVyIHdpbGwgcnVuLlxyXG4gKiBcclxuICogXHJcbiAqIFlvdSBtYXkgb3B0aW9uYWxseSAqYWxzbyogc3BlY2lmeSBkZWJvdW5jZSBhbmQgdGhyb3R0bGUgcGFyYW1ldGVycyB0aGF0IHdhaXQgdW50aWwgdGhlXHJcbiAqIHN5bmNyb25vdXMgaGFuZGxlciBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciB0aGUgc3BlY2lmaWVkIG51bWJlciBvZlxyXG4gKiBtaWxsaXNlY29uZHMsIGF0IHdoaWNoIHBvaW50IHdlICphY3R1YWxseSogcnVuIHRoZSBhc3luY3Jvbm91cyBoYW5kbGVyXHJcbiAqIGFjY29yZGluZyB0byB0aGUgbG9naWMgaW4gdGhlIHByZXZpb3VzIHBhcmFncmFwaC4gVGhpcyBpcyBpblxyXG4gKiAqYWRkaXRpb24qIHRvIHRocm90dGxpbmcgdGhlIGhhbmRsZXIsIGFuZCBkb2VzIG5vdCByZXBsYWNlIHRoYXQgYmVoYXZpb3IuXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUFzeW5jIEEgbW9yZSBnZW5lcmFsIHZlcnNpb24gb2YgdGhpcyBob29rIHRoYXQgY2FuIHdvcmsgd2l0aCBhbnkgdHlwZSBvZiBoYW5kbGVyLCBub3QganVzdCBET00gZXZlbnQgaGFuZGxlcnMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNIYW5kbGVyPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4oYXN5bmNIYW5kbGVyOiAoKGM6IENhcHR1cmVUeXBlLCBlOiBFdmVudFR5cGUpID0+IChQcm9taXNlPHZvaWQ+IHwgdm9pZCkpIHwgbnVsbCwgeyBjYXB0dXJlOiBvcmlnaW5hbENhcHR1cmUsIC4uLnJlc3RBc3luY09wdGlvbnMgfTogVXNlQXN5bmNIYW5kbGVyUGFyYW1ldGVyczxFdmVudFR5cGUsIENhcHR1cmVUeXBlPik6IFVzZUFzeW5jSGFuZGxlclJldHVyblR5cGU8RXZlbnRUeXBlLCBDYXB0dXJlVHlwZT4ge1xyXG4gICAgXHJcbiAgICAvLyBXZSBuZWVkIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBcIm5vdGhpbmcgY2FwdHVyZWQgeWV0XCIgYW5kIFwiYHVuZGVmaW5lZGAgd2FzIGNhcHR1cmVkXCJcclxuICAgIGNvbnN0IFtjdXJyZW50Q2FwdHVyZSwgc2V0Q3VycmVudENhcHR1cmUsIGdldEN1cnJlbnRDYXB0dXJlXSA9IHVzZVN0YXRlPENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG4gICAgY29uc3QgW2hhc0NhcHR1cmUsIHNldEhhc0NhcHR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgXHJcbiAgICAvLyBXcmFwIGFyb3VuZCB0aGUgbm9ybWFsIGB1c2VBc3luY2AgYGNhcHR1cmVgIGZ1bmN0aW9uIHRvIGFsc29cclxuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdmFsdWUgdGhlIHVzZXIgYWN0dWFsbHkgaW5wdXQuXHJcbiAgICAvLyBcclxuICAgIC8vIFdpdGhvdXQgdGhpcyB0aGVyZSdzIG5vIHdheSB0byByZS1yZW5kZXIgdGhlIGNvbnRyb2wgd2l0aFxyXG4gICAgLy8gaXQgYmVpbmcgYm90aCBjb250cm9sbGVkIGFuZCBhbHNvIGhhdmluZyB0aGUgXCJjb3JyZWN0XCIgdmFsdWUsXHJcbiAgICAvLyBhbmQgYXQgYW55IHJhdGUgYWxzbyBwcm90ZWN0cyBhZ2FpbnN0IHN1ZGRlbiBleGNlcHRpb25zIHJldmVydGluZ1xyXG4gICAgLy8geW91ciBjaGFuZ2Ugb3V0IGZyb20gdW5kZXIgeW91LlxyXG4gICAgY29uc3QgY2FwdHVyZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBFdmVudFR5cGUpOiBbQ2FwdHVyZVR5cGUsIEV2ZW50VHlwZV0gPT4geyBcclxuICAgICAgICBjb25zdCBjYXB0dXJlZCA9IG9yaWdpbmFsQ2FwdHVyZShlKTsgXHJcbiAgICAgICAgc2V0Q3VycmVudENhcHR1cmUoY2FwdHVyZWQpO1xyXG4gICAgICAgIHNldEhhc0NhcHR1cmUodHJ1ZSk7XHJcbiAgICAgICAgcmV0dXJuIFtjYXB0dXJlZCwgZV07XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGdldEN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgIGN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgIGhhc0NhcHR1cmUsXHJcbiAgICAgICAgLi4udXNlQXN5bmMoYXN5bmNIYW5kbGVyLCB7IGNhcHR1cmUsIC4uLnJlc3RBc3luY09wdGlvbnMgfSlcclxuICAgIH07XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbiIsImltcG9ydCB7IElucHV0cywgdXNlRWZmZWN0IGFzIHVzZUVmZmVjdE5hdGl2ZSwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuLyoqXHJcbiAqIFdyYXAgdGhlIG5hdGl2ZSBgdXNlRWZmZWN0YCB0byBhZGQgYXJndW1lbnRzIFxyXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxyXG4gKiBhcyB3ZWxsIGFzIHRoZSBjaGFuZ2VzIHRoYXQgY2F1c2VkIHRoZSBob29rIHRvIGJlIGNhbGxlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LlxyXG4gKiBcclxuICogQHBhcmFtIGVmZmVjdCBcclxuICogQHBhcmFtIGlucHV0cyBcclxuICogQHBhcmFtIGltcGwgWW91IGNhbiBjaG9vc2Ugd2hldGhlciB0byB1c2UgYHVzZUVmZmVjdGAgb3IgYHVzZUxheW91dEVmZmVjdGAgYnlcclxuICogcGFzc2luZyBvbmUgb2YgdGhlbSBhcyB0aGlzIGFyZ3VtZW50LiBCeSBkZWZhdWx0LCBpdCdzIGB1c2VFZmZlY3RgLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUVmZmVjdDxJIGV4dGVuZHMgSW5wdXRzPihlZmZlY3Q6IChwcmV2OiBJIHwgdW5kZWZpbmVkLCBjaGFuZ2VzOiBFZmZlY3RDaGFuZ2U8SSwgbnVtYmVyPltdKSA9PiAodm9pZCB8ICgoKSA9PiB2b2lkKSksIGlucHV0cz86IEksIGltcGwgPSB1c2VFZmZlY3ROYXRpdmUpIHtcclxuXHJcbiAgICBjb25zdCBwcmV2SW5wdXRzID0gdXNlUmVmPHVuZGVmaW5lZCB8IEk+KHVuZGVmaW5lZCk7XHJcbiAgICBjb25zdCBlZmZlY3QyID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNoYW5nZXM6IHsgZnJvbTogYW55LCB0bzogYW55IH1bXSA9IFtdO1xyXG4gICAgICAgIGlmIChpbnB1dHMgJiYgcHJldklucHV0cy5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgTWF0aC5tYXgocHJldklucHV0cy5jdXJyZW50Lmxlbmd0aCwgaW5wdXRzLmxlbmd0aCk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZJbnB1dHMuY3VycmVudFtpXSAhPSBpbnB1dHNbaV0pXHJcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlc1tpXSA9IHsgZnJvbTogcHJldklucHV0cy5jdXJyZW50W2ldLCB0bzogaW5wdXRzW2ldIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXQgPSBlZmZlY3QocHJldklucHV0cy5jdXJyZW50LCBjaGFuZ2VzKTtcclxuICAgICAgICBwcmV2SW5wdXRzLmN1cnJlbnQgPSBpbnB1dHM7XHJcbiAgICAgICAgcmV0dXJuIHJldDtcclxuICAgIH07XHJcblxyXG4gICAgaW1wbChlZmZlY3QyLCBpbnB1dHMpO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEVmZmVjdENoYW5nZTxJIGV4dGVuZHMgSW5wdXRzLCBOIGV4dGVuZHMgbnVtYmVyPiB7IGZyb206IElbTl0sIHRvOiBJW05dIH1cclxuIiwiaW1wb3J0IHsgSW5wdXRzLCB1c2VMYXlvdXRFZmZlY3QgYXMgdXNlTGF5b3V0RWZmZWN0TmF0aXZlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgRWZmZWN0Q2hhbmdlLCB1c2VFZmZlY3QgfSBmcm9tIFwiLi91c2UtZWZmZWN0XCI7XG5cbi8qKlxuICogV3JhcCB0aGUgbmF0aXZlIGB1c2VMYXlvdXRFZmZlY3RgIHRvIGFkZCBhcmd1bWVudHMgXG4gKiB0aGF0IGFsbG93IGFjY2Vzc2luZyB0aGUgcHJldmlvdXMgdmFsdWUgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LFxuICogYXMgd2VsbCBhcyB0aGUgY2hhbmdlcyB0aGF0IGNhdXNlZCB0aGUgaG9vayB0byBiZSBjYWxsZWQgYXMgdGhlIHNlY29uZCBhcmd1bWVudC5cbiAqIFxuICogQHBhcmFtIGVmZmVjdCBcbiAqIEBwYXJhbSBpbnB1dHMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VMYXlvdXRFZmZlY3Q8SSBleHRlbmRzIElucHV0cz4oZWZmZWN0OiAocHJldjogSSB8IHVuZGVmaW5lZCwgY2hhbmdlczogRWZmZWN0Q2hhbmdlPEksIG51bWJlcj5bXSkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpLCBpbnB1dHM/OiBJKSB7XG4gICAgcmV0dXJuIHVzZUVmZmVjdChlZmZlY3QsIGlucHV0cywgdXNlTGF5b3V0RWZmZWN0TmF0aXZlKTtcbn1cbiIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcIi4vdXNlLWxheW91dC1lZmZlY3RcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcblxyXG4vKipcclxuICogUmVtaW5kZXIgb2Ygb3JkZXIgb2YgZXhlY3V0aW9uOlxyXG4gKiBcclxuICogKiAodHJlZSBtb3VudHMpXHJcbiAqICogUGFyZW50IHJlbmRlcnNcclxuICogKiBDaGlsZHJlbiByZW5kZXJcclxuICogKiBDaGlsZHJlbiByZWNlaXZlIHJlZiAoaWYgYXBwbGljYWJsZSlcclxuICogKiBQYXJlbnQgcmVjZWl2ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxyXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXHJcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0c1xyXG4gKiBcclxuICogKiAodHJlZSB1bm1vdW50cylcclxuICogKiBQYXJlbnQgcnVucyBlZmZlY3QtY2xlYW51cFxyXG4gKiAqIFBhcmVudCBkZWxldGVzIHJlZiAoaWYgYXBwbGljYWJsZSlcclxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXHJcbiAqICogQ2hpbGQgZGVsZXRlcyByZWYgKGlmIGFwcGxpY2FibGUpXHJcbiAqIFxyXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcclxuICogKiBSZW5kZXJpbmcgc3RhcnRzIGF0IHRoZSByb290LCAgYnV0IGVmZmVjdHMgYW5kIHJlZnMgc3RhcnQgYXQgdGhlIGxlYXZlcy5cclxuICogKiByZWZzIGFyZSAqdXN1YWxseSogY2FsbGVkIGJlZm9yZSBlZmZlY3RzLCBidXQgb25seSB3aGVuIHRoYXQgSFRNTEVsZW1lbnQgcmVuZGVycy4gQmFzaWNhbGx5IGp1c3QgYSByZW1pbmRlciB0aGF0IGEgY29tcG9uZW50IGNhbiBiZSBtb3VudGVkIHdpdGhvdXQgaXQgZXhpc3RpbmcgaW4gdGhlIERPTS5cclxuICovXHJcbmNvbnN0IF9jb21tZW50cyA9IHZvaWQgKDApO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBJbmZvcm1hdGlvbiB0aGF0IGNoaWxkcmVuIGFuZCBwYXJlbnRzIHVzZSB0byBjb21tdW5pY2F0ZSB3aXRoIGVhY2ggb3RoZXIuXHJcbiAqIFxyXG4gKiAqIGBpbmRleGAgcmVmZXJzIHRvIHdoaWNoIGNoaWxkIHRoaXMgaXMuXHJcbiAqICogYGZsYWdzYCBhcmUgcXVpY2stYW5kLWVhc3kgZ2V0dGVycyBhbmQgc2V0dGVycyB0aGF0IHlvdSBjYW4gb3B0aW9uYWxseSB1c2VcclxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZEluZm88VCBleHRlbmRzIHN0cmluZyB8IG51bWJlciwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xyXG4gICAgaW5kZXg6IFQ7XHJcbiAgICBmbGFncz86IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PjtcclxuICAgIHN1YkluZm86IEM7XHJcbn1cclxuXHJcblxyXG5cclxuZXhwb3J0IHR5cGUgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChtb3VudGVkOiBTZXQ8VD4sIHVubW91bnRlZDogU2V0PFQ+KSA9PiB2b2lkKTtcclxuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZz4ge1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUnVucyBhZnRlciBvbmUgb3IgbW9yZSBjaGlsZHJlbiBoYXZlIHVwZGF0ZWQgdGhlaXIgaW5mb3JtYXRpb24gKGluZGV4LCBldGMuKS5cclxuICAgICAgICAgKiBcclxuICAgICAgICAgKiBPbmx5IG9uZSB3aWxsIHJ1biBwZXIgdGljaywganVzdCBsaWtlIGxheW91dEVmZmVjdCwgYnV0IGl0IGlzbid0XHJcbiAgICAgICAgICogKmd1YXJhbnRlZWQqIHRvIGhhdmUgYWN0dWFsbHkgYmVlbiBhIGNoYW5nZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQ+O1xyXG5cclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTYW1lIGFzIHRoZSBhYm92ZSwgYnV0IG9ubHkgZm9yIG1vdW50L3VubW91bnQgKG9yIHdoZW4gYSBjaGlsZCBjaGFuZ2VzIGl0cyBpbmRleClcclxuICAgICAgICAgKi9cclxuICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/OiBudWxsIHwgdW5kZWZpbmVkIHwgT25DaGlsZHJlbk1vdW50Q2hhbmdlPFQ+O1xyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAgIG1hbmFnZWRDaGlsZDogT21pdDxNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+LCBcInN1YkluZm9cIj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICAvKipcclxuICAgICAqIEEgaG9vayB0aGF0IG11c3QgYmUgY2FsbGVkIGJ5IGV2ZXJ5IGNoaWxkIGNvbXBvbmVudCB0aGF0XHJcbiAgICAgKiBpcyB0byBiZSBtYW5hZ2VkIGJ5IHRoaXMgb25lLiBUaGUgYXJndW1lbnQgdG8gdGhlIGhvb2tcclxuICAgICAqIGlzIGp1c3QgdGhlIGJhZyBvZiBwcm9wZXJ0aWVzIHRvIHBhc3MgdG8gdGhlIHBhcmVudCxcclxuICAgICAqIGluY2x1ZGluZyB0aGUgY2hpbGQncyBpbmRleC5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICB1c2VNYW5hZ2VkQ2hpbGQ6IFVzZU1hbmFnZWRDaGlsZDxULCBDLCBLPjtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY2hpbGQgdGhhdCByZW5kZXJlZCBpdHNlbGYgd2l0aCB0aGUgcmVxdWVzdGVkIGtleS5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKiAoZXZlbiB0aG91Z2ggaXQncyBub3QgYSBmdW5jdGlvbiwgdGhlIGlkZW50aXR5IG9mIHRoaXMgb2JqZWN0IG5ldmVyIGNoYW5nZXMpXHJcbiAgICAgKi9cclxuICAgIG1hbmFnZWRDaGlsZHJlbjoge1xyXG4gICAgICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48VCwgQywgSz47XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGUgPSB2b2lkO1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkPFQgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCwgQywgSz4pID0+IFVzZU1hbmFnZWRDaGlsZFJldHVyblR5cGU7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBYnN0cmFjdGlvbiBvdmVyIHRoZSBtYW5hZ2VkIGNoaWxkcmVuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRBdChpbmRleDogVCk6IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz4gfCB1bmRlZmluZWQ7XHJcbiAgICAvKiogU1RBQkxFICovXHJcbiAgICBnZXRIaWdoZXN0SW5kZXgoKTogbnVtYmVyO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZm9yRWFjaDogKGY6IChjaGlsZDogTWFuYWdlZENoaWxkSW5mbzxULCBDLCBLPikgPT4gdm9pZCkgPT4gdm9pZDtcclxuXHJcbiAgICAvKiogKipVTlNUQUJMRSoqLCBhbHNvIGludGVybmFsLXVzZSBvbmx5LCBhbHNvIFRPRE8gbmVlZCBhIHdvcmthcm91bmQgZm9yIHRoaXMgZm9yIHNvcnRhYmxlIGNoaWxkcmVuICovXHJcbiAgICBhcnJheVNsaWNlOiAoKSA9PiBNYW5hZ2VkQ2hpbGRJbmZvPFQsIEMsIEs+W107XHJcbn1cclxuXHJcblxyXG5cclxuXHJcbi8vZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVyczxJIGV4dGVuZHMge30+ID0geyBpbmZvOiBJIH07XHJcblxyXG4vKipcclxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxyXG4gKiBjaGlsZCBjb21wb25lbnRzIG9uY2UgdGhleSBoYXZlIHJlbmRlcmVkLlxyXG4gKiBcclxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcclxuICogYW5kIHJ1bnMgbm8gZWZmZWN0cy4gIEVhY2ggY2hpbGQgKmRvZXMqIHJ1biBhbiBlZmZlY3QsIGJ1dCB3aXRoIG5vIHN0YXRlXHJcbiAqIGNoYW5nZXMgdW5sZXNzIHlvdSBleHBsaWNpdGx5IHJlcXVlc3QgdGhlbS5cclxuICogXHJcbiAqIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBDLCBLIGV4dGVuZHMgc3RyaW5nPihwYXJlbnRQYXJhbWV0ZXJzOiBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzPFQ+KTogVXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxULCBDLCBLPiB7XHJcbiAgICAvL3R5cGUgSSA9IEkzICYgTWFuYWdlZENoaWxkSW5mb0Jhc2U8c3RyaW5nIHwgbnVtYmVyPjtcclxuICAgIHR5cGUgSW5mbyA9IE1hbmFnZWRDaGlsZEluZm88VCwgQywgSz47XHJcblxyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xyXG5cclxuICAgIGNvbnN0IGdldEhpZ2hlc3RJbmRleCA9IHVzZUNhbGxiYWNrKCgpOiBudW1iZXIgPT4ge1xyXG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXHJcbiAgICAvLyBBbnkgbXV0YXRpb25zIHRvIHRoaXMgYXJyYXkgKipETyBOT1QqKiB0cmlnZ2VyIGFueSBzb3J0IG9mIGEgcmUtcmVuZGVyLlxyXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuQXJyYXkgPSB1c2VSZWY8eyBhcnI6IEFycmF5PEluZm8+OyByZWM6IFBhcnRpYWw8UmVjb3JkPFQsIEluZm8+PjsgaGlnaGVzdEluZGV4OiBudW1iZXIsIGxvd2VzdEluZGV4OiBudW1iZXIgfT4oeyBhcnI6IFtdLCByZWM6IHt9LCBoaWdoZXN0SW5kZXg6IDAsIGxvd2VzdEluZGV4OiAwIH0pO1xyXG5cclxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxyXG4gICAgLy8gQ29tcGFyZSBnZXRNYW5hZ2VkQ2hpbGRJbmZvXHJcbiAgICAvLyBUT0RPOiBUaGUgcHJpbWFyeSB1c2UgZm9yIHRoaXMgaXMgZmxhZ2dhYmxlIGNsb3Nlc3QgZml0c1xyXG4gICAgLy8gd2hpY2ggbmVlZCB0byBzZWFyY2ggYWxsIGNoaWxkcmVuIGZvciB0aGF0IGNsb3Nlc3QgZml0LlxyXG4gICAgLy8gSXQgd291bGQgYmUgbmljZSBpZiB0aGVyZSB3YXMgc29tZXRoaW5nIGJldHRlciBmb3IgdGhhdC5cclxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyKSB7IGYoY2hpbGQpOyB9XHJcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZCBpbiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlYykge1xyXG4gICAgICAgICAgICBjb25zdCBjaGlsZDogSW5mbyB8IHVuZGVmaW5lZCA9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2ZpZWxkIGFzIGtleW9mIFJlY29yZDxULCBJbmZvPl07XHJcbiAgICAgICAgICAgIGlmIChjaGlsZClcclxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIC8vIFJldHJpZXZlcyB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSBjaGlsZCB3aXRoIHRoZSBnaXZlbiBpbmRleC5cclxuICAgIC8vIGB1bmRlZmluZWRgIGlmIG5vdCBjaGlsZCB0aGVyZSwgb3IgaXQncyB1bm1vdW50ZWQuXHJcbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8VXNlTWFuYWdlZENoaWxkcmVuUmV0dXJuVHlwZTxULCBDLCBLPltcIm1hbmFnZWRDaGlsZHJlblwiXVtcImNoaWxkcmVuXCJdW1wiZ2V0QXRcIl0+KChpbmRleDogVCkgPT4ge1xyXG4gICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl0hO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQucmVjW2luZGV4IGFzIFRdITtcclxuICAgIH0sIFtdKVxyXG5cclxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cclxuICAgIC8vIGhhdmUgbW91bnRlZCBhbmQgcnVuICp0aGVpciogdXNlTGF5b3V0RWZmZWN0LCBidXQgYWxzbyAqd2l0aG91dCogcmUtcmVuZGVyaW5nXHJcbiAgICAvLyBvdXJzZWx2ZXMgYmVjYXVzZSBvZiBoYXZpbmcgYSBgY2hpbGRDb3VudGAgc3RhdGUgb3IgYW55dGhpbmcgc2ltaWxhci5cclxuICAgIC8vXHJcbiAgICAvLyBXaGVuIHRoZSBjaGlsZCBjb3VudCByZWYgdXBkYXRlcywgd2Ugd2FudCB0aGUgcGFyZW50IHRvIGFsc28gcnVuIGFuIGVmZmVjdFxyXG4gICAgLy8gdG8gbWF5YmUgZG8gc29tZXRoaW5nIHdpdGggYWxsIHRoZXNlIGNoaWxkcmVuIHRoYXQganVzdCBtb3VudGVkLlxyXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XHJcbiAgICAvLyB0aGF0IHdvdWxkIHJlcXVpcmUgdXMgaGF2aW5nIGEgY2hpbGRDb3VudCBzdGF0ZSwgdGhlbiBjYWxsaW5nXHJcbiAgICAvLyBzZXRDaGlsZENvdW50IGFuZCByZS1yZW5kZXJpbmcgZXZlcnkgdGltZSBjaGlsZHJlbiBtb3VudFxyXG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcclxuICAgIC8vIFxyXG4gICAgLy8gQXMgYW4gYWx0ZXJuYXRlIHNvbHV0aW9uLCBhbnkgdGltZSBhIGNoaWxkIHVzZXMgVUxFIG9uIG1vdW50LCBpdCBxdWV1ZXMgYSBtaWNyb3Rhc2tcclxuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxyXG4gICAgLy8gdGhlIG1pY3JvdGFzayAoYnkgY2hlY2tpbmcgaGFzUmVtb3RlVUxFIGZpcnN0KSBzbyB0aGF0IHRoZSBcImVmZmVjdFwiIG9ubHlcclxuICAgIC8vIHJ1bnMgb25jZS4gV2hlbiBpdCdzIGRvbmUsIGhhc1JlbW90ZVVMRSBpcyByZXNldCBzbyBpdCBjYW4gcnVuIGFnYWluIGlmXHJcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXHJcbiAgICBjb25zdCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VSZWY8eyBtb3VudHM6IFNldDxUPiwgdW5tb3VudHM6IFNldDxUPiB9IHwgbnVsbD4obnVsbCk7XHJcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8VD4oKSk7XHJcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQpID0+IHtcclxuXHJcbiAgICAgICAgaWYgKHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5zaXplID09IDApIHtcclxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5jbGVhcigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZENhdXNlcnMuY3VycmVudC5hZGQoaW5kZXgpO1xyXG5cclxuICAgICAgICByZXR1cm4gKCkgPT4geyB9O1xyXG5cclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZE1vdW50ZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IFQsIG1vdW50ZWQ6IGJvb2xlYW4pOiB2b2lkID0+IHtcclxuICAgICAgICBpZiAoIWhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xyXG4gICAgICAgICAgICAgICAgbW91bnRzOiBuZXcgU2V0KCksXHJcbiAgICAgICAgICAgICAgICB1bm1vdW50czogbmV3IFNldCgpLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U/LihoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEubW91bnRzLCBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCEudW5tb3VudHMpXHJcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG1vdW50ZWQpIHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5oaWdoZXN0SW5kZXggPSBNYXRoLm1heChtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCwgaW5kZXggYXMgbnVtYmVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5kZXggPT0gXCJudW1iZXJcIikge1xyXG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XHJcbiAgICAgICAgICAgICAgICBsZXQgc2hhdmUgPSAwO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHNoYXZlIDw9IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAmJiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyclttYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmVdID09PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgICAgICAgICAgKytzaGF2ZTtcclxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLnNwbGljZShtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5sZW5ndGggLSAxIC0gc2hhdmUsIHNoYXZlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgVF07XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudFttb3VudGVkID8gXCJtb3VudHNcIiA6IFwidW5tb3VudHNcIl0uYWRkKGluZGV4KTtcclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcblxyXG4gICAgY29uc3QgdXNlTWFuYWdlZENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTWFuYWdlZENoaWxkPFQsIEMsIEs+PigoeyBtYW5hZ2VkQ2hpbGQ6IGluZm8sIH0pID0+IHtcclxuICAgICAgICAvLyBBbnkgdGltZSBvdXIgY2hpbGQgcHJvcHMgY2hhbmdlLCBtYWtlIHRoYXQgaW5mb3JtYXRpb24gYXZhaWxhYmxlXHJcbiAgICAgICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXHJcbiAgICAgICAgLy8gVGhlIHBhcmVudCBjYW4gbGlzdGVuIGZvciBhbGwgdXBkYXRlcyBhbmQgb25seSBhY3Qgb24gdGhlIG9uZXMgaXQgY2FyZXMgYWJvdXQsXHJcbiAgICAgICAgLy8gYW5kIG11bHRpcGxlIGNoaWxkcmVuIHVwZGF0aW5nIGluIHRoZSBzYW1lIHRpY2sgd2lsbCBhbGwgYmUgc2VudCBhdCBvbmNlLlxyXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEluc2VydCB0aGlzIGluZm9ybWF0aW9uIGluLXBsYWNlXHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5mby5pbmRleCA9PSBcIm51bWJlclwiKVxyXG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5mby5pbmRleCBhcyBudW1iZXJdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmZvLmluZGV4IGFzIFRdID0geyBpbmRleDogaW5mby5pbmRleCwgZmxhZ3M6IGluZm8uZmxhZ3MgPz8ge30sIHN1YkluZm86IGluZm8uc3ViSW5mbyB9O1xyXG4gICAgICAgICAgICByZXR1cm4gcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkKGluZm8uaW5kZXggYXMgVCk7XHJcbiAgICAgICAgfSwgWy4uLk9iamVjdC5lbnRyaWVzKGluZm8pLmZsYXQoOSldKTsgIC8vIDkgaXMgaW5maW5pdHksIHJpZ2h0PyBTdXJlLiBVbnJlbGF0ZWQ6IFRPRE8uXHJcblxyXG4gICAgICAgIC8vIFdoZW4gd2UgbW91bnQsIG5vdGlmeSB0aGUgcGFyZW50IHZpYSBxdWV1ZU1pY3JvdGFza1xyXG4gICAgICAgIC8vIChldmVyeSBjaGlsZCBkb2VzIHRoaXMsIHNvIGV2ZXJ5dGhpbmcncyBjb29yZGluYXRlZCB0byBvbmx5IHF1ZXVlIGEgc2luZ2xlIG1pY3JvdGFzayBwZXIgdGljaylcclxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxyXG4gICAgICAgIC8vIE5vdGU6IEl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBjb21lcyBBRlRFUiByZW1vdGVVTEVDaGlsZENoYW5nZWRcclxuICAgICAgICAvLyBzbyB0aGF0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCBoYXMgYWNjZXNzIHRvIGFsbCB0aGUgaW5mbyBvbiBtb3VudC5cclxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmZvLmluZGV4IGFzIFQsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5mby5pbmRleCBhcyBULCBmYWxzZSk7XHJcbiAgICAgICAgfSwgW2luZm8uaW5kZXhdKTtcclxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcblxyXG4gICAgY29uc3QgbWFuYWdlZENoaWxkcmVuID0gdXNlUmVmPE1hbmFnZWRDaGlsZHJlbjxULCBDLCBLPj4oe1xyXG4gICAgICAgIC4uLnsgXzogbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudCB9IGFzIHt9LFxyXG4gICAgICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZCxcclxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcclxuICAgICAgICBnZXRIaWdoZXN0SW5kZXg6IGdldEhpZ2hlc3RJbmRleCxcclxuICAgICAgICBhcnJheVNsaWNlOiAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTWFuYWdlZENoaWxkLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxyXG4gICAgfVxyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoaWNoIGNoaWxkIGlzIGNvbnNpZGVyZWQgYWN0aXZlIG9uIG1vdW50LlxyXG4gICAgICogXHJcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXHJcbiAgICAgKi9cclxuICAgIGluaXRpYWxJbmRleDogbnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gcHJvdmlkZWQsIGlmIHRoZSBnaXZlbiBhY3RpdmF0ZWRJbmRleCBkb2Vzbid0IG1hcCBvbnRvIGFueVxyXG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcclxuICAgICAqIGRvZXNuJ3QgZXhpc3QpLCB0aGUgY2xvc2VzdCBjaGlsZCB0byB0aGUgZ2l2ZW4gYWN0aXZhdGVkSW5kZXhcclxuICAgICAqIHdpbGwgaGF2ZSBpdHMgZmxhZyBzZXQgaW5zdGVhZC5cclxuICAgICAqIFxyXG4gICAgICogVXNlIHdpdGggY2F1dGlvbiwgYW5kIGNvbnNpZGVyIGhvdyBhIGNoaWxkIGhhdmluZyBpdHMgZmxhZyBzZXRcclxuICAgICAqIHdoaWxlIHRoZSBwYXJlbnQgdGhpbmtzIGl0IHNob3VsZG4ndCBiZSBjb3VsZCBjYXVzZSBpc3N1ZXMuXHJcbiAgICAgKi9cclxuICAgIC8vY2xvc2VzdEZpdD86IGJvb2xlYW47XHJcbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xyXG5cclxuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCB3aGVuZXZlciBhIG5ldyBpbmRleCBpcyBzZWxlY3RlZC5cclxuICAgICAqIFxyXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXHJcbiAgICAgKiBpZiB0aGUgcmVxdWVzdGVkIGluZGV4IGRpZG4ndCBleGlzdCBvciB3YXMgaGlkZGVuLlxyXG4gICAgICovXHJcbiAgICBvbkluZGV4Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyIHwgbnVsbD47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGNoaWxkcmVuIGhhdmUgbXVsdGlwbGUgZmxhZ3MsIHRoZSBga2V5YCBwYXJhbWV0ZXIgY29udHJvbHMgd2hpY2ggZmxhZyB3ZSdyZSBjaGVja2luZy5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBjYW4gYmUgYW55dGhpbmcgeW91IHdhbnQsIGJ1dCBtdXN0IG5vdCBjaGFuZ2UuXHJcbiAgICAgKi9cclxuICAgIGtleTogSztcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hpbGRGbGFnT3BlcmF0aW9ucyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IHJldHVybiB3aGV0aGVyIHRoZSBjdXJyZW50IGNoaWxkIGlzIGFjdGl2ZVxyXG4gICAgICovXHJcbiAgICBnZXQ6ICgpID0+IGJvb2xlYW47XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjaGlsZCBtdXN0IHNldCBpdHNlbGYgYXMgYWN0aXZlL2luYWN0aXZlLCB3aGF0ZXZlciB0aGF0IGVudGFpbHMuXHJcbiAgICAgKiBUaGlzIGNvdWxkIGJlIGFzIHNpbXBsZSBhcyBhIHNldFN0YXRlIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBzZXQ6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIE11c3QgcmV0dXJuIHRydWUgaWYgdGhpcyBjaGlsZCBpcyBhIHZhbGlkIGNhbmRpZGF0ZSB0byBiZSBmbGFnZ2VkLCBhbmQgZmFsc2UgaWYgbm90LlxyXG4gICAgICogTW9zdCBjaGlsZHJlbiBzaG91bGQgcmV0dXJuIHRydWUuIFJldHVybmluZyBmYWxzZSBpcyBvbmx5IHVzZWZ1bCB0byBtYXJrIGEgY2hpbGQgYXMgXCJpbnZhbGlkXCIgaW4gc29tZSB3YXkuXHJcbiAgICAgKiBSZW1vdmluZyBhIGNoaWxkIGZyb20gdGhlIGxpc3QgZG9lcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZywgYnV0IHRoaXMgbGV0cyB5b3Uga2VlcCB0aGUgY2hpbGQgYXJvdW5kLlxyXG4gICAgICovXHJcbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW47XHJcbn1cclxuXHJcblxyXG4vL2V4cG9ydCBpbnRlcmZhY2UgRmxhZ2dhYmxlQ2hpbGRJbmZvQjxLIGV4dGVuZHMgc3RyaW5nPiB7IGZsYWdzOiBQYXJ0aWFsPFJlY29yZDxLLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4gfSBcclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGNoYW5nZUluZGV4OiAoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IG51bWJlciB8IG51bGw7XHJcbiAgICAvKiogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKiBcclxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxyXG4gICAgICogICovXHJcbiAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdDogKCkgPT4gdm9pZDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRDdXJyZW50SW5kZXg6ICgpID0+IG51bWJlciB8IG51bGw7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBleHRlbnNpb24gdG8gdXNlTWFuYWdlZENoaWxkcmVuIHRoYXQgaGFuZGxlcyB0aGUgZm9sbG93aW5nIGNvbW1vbiBjYXNlOlxyXG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXHJcbiAqIDIuIEF0IGFueSBnaXZlbiB0aW1lLCBvbmx5IDEgb2YgdGhlbSBpcyBcInNlbGVjdGVkXCIsIFwiYWN0aXZhdGVkXCIsIFwiZm9jdXNhYmxlXCIsIHdoYXRldmVyIChvciAwIG9mIHRoZW0sIHRoYXQncyBjb29sIHRvbywganVzdCAwIG9yIDEgdGhvdWdoKS5cclxuICogMy4gVGhlIHBhcmVudCBoYXMgY29udHJvbCBvdmVyIHdobyBpcyBcInNlbGVjdGVkXCIgdmlhIGEgbnVtZXJpY2FsIGluZGV4LlxyXG4gKiBcclxuICogVGhpcyBob29rIGFsbG93cyBmb3IgbXVjaCBlYXNpZXIgY29udHJvbCBvdmVyIHNlbGVjdGlvbiBtYW5hZ2VtZW50LlxyXG4gKiBcclxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXHJcbiAqIFlvdSBuZWVkIHRvIHBhc3MgaXQgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLCBhbmQgeW91IG11c3QgcGFzcyB5b3VyIGludm9jYXRpb24gb2YgYHVzZU1hbmFnZWRDaGlsZHJlbmAgdGhlIHJldHVybmVkIGBvbkNoaWxkcmVuTW91bnRDaGFuZ2VgIGhhbmRsZXIhXHJcbiAqIFxyXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxyXG4gKiBcclxuICogXHJcbiAqIEBwYXJhbSBwYXJhbTAgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBpbml0aWFsSW5kZXgsIGNsb3Nlc3RGaXQsIG9uSW5kZXhDaGFuZ2UsIGtleSB9OiBVc2VDaGlsZHJlbkZsYWdQYXJhbWV0ZXJzPEMsIEs+KTogVXNlQ2hpbGRyZW5GbGFnUmV0dXJuVHlwZSB7XHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VDaGlsZHJlbkZsYWdcIiwgb25JbmRleENoYW5nZSwga2V5KTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Q3VycmVudEluZGV4LCBzZXRDdXJyZW50SW5kZXhdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCBudW1iZXI+KG9uSW5kZXhDaGFuZ2UsIHVzZUNhbGxiYWNrKCgpID0+IChpbml0aWFsSW5kZXggPz8gKG51bGwpKSwgW10pKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XHJcblxyXG4gICAgLy8gICAgY29uc3QgZ2V0Rml0TnVsbFRvWmVybyA9IHVzZVN0YWJsZUdldHRlcihmaXROdWxsVG9aZXJvKTtcclxuXHJcbiAgICAvLyBTaGFyZWQgYmV0d2VlbiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgYW5kIGNoYW5nZUluZGV4LCBub3QgcHVibGljIChidXQgY291bGQgYmUgSSBndWVzcylcclxuICAgIGNvbnN0IGdldENsb3Nlc3RGaXQgPSB1c2VDYWxsYmFjaygocmVxdWVzdGVkSW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgY2xvc2VzdEluZGV4OiBudW1iZXIgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcclxuXHJcbiAgICAgICAgICAgIGlmIChjaGlsZC5mbGFncz8uW2tleV0/LmlzVmFsaWQoKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RGlzdGFuY2UgPSBNYXRoLmFicyhjaGlsZC5pbmRleCAtIHJlcXVlc3RlZEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gbmV3RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdEluZGV4ID0gY2hpbGQuaW5kZXg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xyXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSEgKi9dKTtcclxuXHJcbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcclxuICAgIC8vIHRoZSBcImN1cnJlbnRseSBzZWxlY3RlZFwiIChvciB3aGF0ZXZlcikgaW5kZXguICBUaGUgdHdvIGNhc2VzIHdlJ3JlIGxvb2tpbmcgZm9yOlxyXG4gICAgLy8gMS4gVGhlIGN1cnJlbnRseSBzZWxlY3RlZCBjaGlsZCB1bm1vdW50ZWRcclxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxyXG4gICAgY29uc3QgcmVldmFsdWF0ZUNsb3Nlc3RGaXQgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVxdWVzdGVkSW5kZXggPSBnZXRSZXF1ZXN0ZWRJbmRleCgpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KGN1cnJlbnRJbmRleCk7XHJcblxyXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCAhPSBudWxsICYmIGNsb3Nlc3RGaXQgJiYgKHJlcXVlc3RlZEluZGV4ICE9IGN1cnJlbnRJbmRleCB8fCBjdXJyZW50Q2hpbGQgPT0gbnVsbCB8fCAhY3VycmVudENoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSkge1xyXG4gICAgICAgICAgICBjdXJyZW50Q2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xyXG4gICAgICAgICAgICBpZiAoY2xvc2VzdEZpdEluZGV4ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3Nlc3RGaXRDaGlsZCA9IGNoaWxkcmVuLmdldEF0KGNsb3Nlc3RGaXRJbmRleCkhO1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XHJcbiAgICAgICAgICAgICAgICBjbG9zZXN0Rml0Q2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgY29uc3QgY2hhbmdlSW5kZXggPSB1c2VDYWxsYmFjaygoYXJnOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0pID0+IHtcclxuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKGdldFJlcXVlc3RlZEluZGV4KCkpIDogYXJnO1xyXG4gICAgICAgIC8vaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxyXG4gICAgICAgIC8vICAgIHJlcXVlc3RlZEluZGV4ID0gMDtcclxuXHJcbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xyXG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPT0gcmVxdWVzdGVkSW5kZXgpXHJcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcclxuXHJcbiAgICAgICAgbGV0IG5ld01hdGNoaW5nQ2hpbGQgPSAocmVxdWVzdGVkSW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChyZXF1ZXN0ZWRJbmRleCkpO1xyXG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XHJcbiAgICAgICAgaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gRWFzeSBjYXNlXHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsKTtcclxuICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChuZXdNYXRjaGluZ0NoaWxkICYmIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5pc1ZhbGlkKCkpIHtcclxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICBuZXdNYXRjaGluZ0NoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50SW5kZXgoY2xvc2VzdEZpdEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0Rml0SW5kZXggIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmFzc2VydChuZXdNYXRjaGluZ0NoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3RGaXRJbmRleDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpbml0aWFsSW5kZXggIT0gbnVsbClcclxuICAgICAgICAgICAgY2hpbGRyZW4uZ2V0QXQoaW5pdGlhbEluZGV4KT8uZmxhZ3M/LltrZXldPy5zZXQodHJ1ZSk7XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICByZXR1cm4geyBjaGFuZ2VJbmRleCwgcmVldmFsdWF0ZUNsb3Nlc3RGaXQsIGdldEN1cnJlbnRJbmRleCB9O1xyXG59XHJcblxyXG5cclxuXHJcbi8qZXhwb3J0IHR5cGUgU3ByZWFkPEEgZXh0ZW5kcyB7fSwgQiBleHRlbmRzIHt9PiA9IE9taXQ8QSwga2V5b2YgQj4gJiBCO1xyXG5leHBvcnQgZnVuY3Rpb24gc3ByZWFkPEEgZXh0ZW5kcyB7fSwgQiBleHRlbmRzIHt9PihhOiBBLCBiOiBCKTogU3ByZWFkPEEsIEI+IHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4uYSxcclxuICAgICAgICAuLi5iXHJcbiAgICB9XHJcbn0qL1xyXG5cclxuLypcclxuZnVuY3Rpb24gdGVzdCgpIHtcclxuICAgIHR5cGUgQyA9IHsgZm9vOiBcImJhclwiIH07XHJcbiAgICB0eXBlIEsgPSBcImZsYWcyXCI7XHJcblxyXG4gICAgY29uc3QgeyBjaGlsZHJlbiwgdXNlTWFuYWdlZENoaWxkIH0gPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPih7IG1hbmFnZWRDaGlsZHJlbjogeyBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiBvbkNoaWxkcmVuTW91bnRDaGFuZ2UobW91bnRlZCwgdW5tb3VudGVkKSkgfSB9KTtcclxuICAgIHVzZU1hbmFnZWRDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleDogMCwgaW5mbzogeyBmb286IFwiYmFyXCIgfSwgZmxhZ3M6IHsgIH0gfSB9KTtcclxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIGdldEN1cnJlbnRJbmRleCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gPSB1c2VDaGlsZHJlbkZsYWc8QywgSz4oeyBjaGlsZHJlbiwgaW5pdGlhbEluZGV4OiAwLCBrZXk6IFwiZmxhZzJcIiB9KVxyXG59Ki9cclxuIiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KGVsZW1lbnQ/OiBOb2RlKSB7IHJldHVybiAoZWxlbWVudD8ub3duZXJEb2N1bWVudCA/PyBkb2N1bWVudCA/PyB3aW5kb3cuZG9jdW1lbnQgPz8gZ2xvYmFsVGhpcy5kb2N1bWVudCk7IH1cclxuXHJcbnR5cGUgUCA9IFBhcmFtZXRlcnM8dHlwZW9mIGNsc3g+O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZURvY3VtZW50Q2xhc3MoY2xhc3NOYW1lOiBQWzBdLCBhY3RpdmU/OiBib29sZWFuLCBlbGVtZW50PzogSFRNTEVsZW1lbnQpIHtcclxuICAgIGVsZW1lbnQgPz89IGdldERvY3VtZW50KCkuZG9jdW1lbnRFbGVtZW50O1xyXG4gICAgY2xhc3NOYW1lID0gY2xzeChjbGFzc05hbWUpO1xyXG5cclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKGFjdGl2ZSAhPT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChjbGFzc05hbWUgYXMgc3RyaW5nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50IS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgIH0sIFtjbGFzc05hbWUsIGFjdGl2ZSwgZWxlbWVudF0pO1xyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhZ2dhYmxlUmV0dXJuVHlwZTxFIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqVW5zdGFibGUqICovXHJcbiAgICB1c2VEcmFnZ2FibGVQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiBpcyBjdXJyZW50bHkgYmVpbmcgZHJhZ2dlZFxyXG4gICAgICovXHJcbiAgICBkcmFnZ2luZzogYm9vbGVhbjtcclxuICAgIFxyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldERyYWdnaW5nOiAoKSA9PiBib29sZWFuO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogT25jZSB0aGUgZHJhZyBlbmRzLCBpZiBpdCB3YXMgb3ZlciBhIHZhbGlkIGRyb3BwYWJsZSwgdGhpcyB3aWxsIGJlXHJcbiAgICAgKiBzZXQgdG8gdGhlIGBkcm9wRWZmZWN0YCB2YWx1ZSBpdCBoYWQuXHJcbiAgICAgKiBcclxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZWN0IHdoZW4gdGhlIGVsZW1lbnQgaGFzIGRyb3BwZWQsIFxyXG4gICAgICogYW5kIHRoZW4gd2hhdCBzaG91bGQgYmUgZG9uZSB3aXRoIGl0IChnZW5lcmFsbHkgZGVsZXRlZCBpZiB0aGUgZWZmZWN0IHdhcyBcIm1vdmVcIilcclxuICAgICAqL1xyXG4gICAgbGFzdERyb3BFZmZlY3Q6IERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsO1xyXG5cclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRMYXN0RHJvcEVmZmVjdDogKCkgPT4gKERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsKTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJhZ2dhYmxlUGFyYW1ldGVycyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHRvIHRoZSBEcmFnIGFuZCBEcm9wIEFQSSAtLSBhbGxvd3MgbGltaXRpbmcgdGhlIGFyZWFzIHRoaXMgZWxlbWVudCBjYW4gYmUgZHJvcHBlZC5cclxuICAgICAqIEZvciBleGFtcGxlLCBzZXR0aW5nIHRoaXMgdG8gXCJjb3B5TGlua1wiIHdpbGwgYWxsb3cgdGhpcyB0aGlzIHRvIGJlIGRyb3BwZWQgb250b1xyXG4gICAgICogYSBkcm9wcGFibGUgd2l0aCBhbiBlZmZlY3Qgb2YgXCJjb3B5XCIgb3IgXCJsaW5rXCIsIGJ1dCBub3QgXCJtb3ZlXCIuXHJcbiAgICAgKiBcclxuICAgICAqL1xyXG4gICAgZWZmZWN0QWxsb3dlZD86IERhdGFUcmFuc2ZlcltcImVmZmVjdEFsbG93ZWRcIl0gfCB1bmRlZmluZWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgY3VzdG9tIGRyYWcgaW1hZ2UgaW5zdGVhZCBvZiB0aGUgYnJvd3NlciBkZWZhdWx0IChhIHRyYW5zcGFyZW50IHJlbmRlciBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCwgZ2VuZXJhbGx5KVxyXG4gICAgICovXHJcbiAgICBkcmFnSW1hZ2U/OiBIVE1MQ2FudmFzRWxlbWVudCB8IEhUTUxJbWFnZUVsZW1lbnQgfCBIVE1MVmlkZW9FbGVtZW50O1xyXG4gICAgZHJhZ0ltYWdlWE9mZnNldD86IG51bWJlcjtcclxuICAgIGRyYWdJbWFnZVlPZmZzZXQ/OiBudW1iZXI7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIGEgZGljdGlvbmFyeSBtYXBwaW5nIG9mIE1JTUUgdHlwZXMgdG8gZGF0YVxyXG4gICAgICovXHJcbiAgICBkYXRhOiB7IFttaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEcmFnZ2FibGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGVmZmVjdEFsbG93ZWQsIGRhdGEsIGRyYWdJbWFnZSwgZHJhZ0ltYWdlWE9mZnNldCwgZHJhZ0ltYWdlWU9mZnNldCB9OiBVc2VEcmFnZ2FibGVQYXJhbWV0ZXJzKSB7XHJcblxyXG4gICAgY29uc3QgW2RyYWdnaW5nLCBzZXREcmFnZ2luZywgZ2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gICAgY29uc3QgW2xhc3REcm9wRWZmZWN0LCBzZXRMYXN0RHJvcEVmZmVjdCwgZ2V0TGFzdERyb3BFZmZlY3RdID0gdXNlU3RhdGU8RGF0YVRyYW5zZmVyW1wiZHJvcEVmZmVjdFwiXSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHVzZURyYWdnYWJsZVByb3BzID0gdXNlQ2FsbGJhY2soPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPj4ocDogUCkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCByZWYgPSB1c2VSZWY8RT4obnVsbCk7XHJcblxyXG4gICAgICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gKGU6IERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICAvL2UucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0RHJhZ2dpbmcodHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xyXG4gICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IChlZmZlY3RBbGxvd2VkID8/IFwiYWxsXCIpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJbWFnZSlcclxuICAgICAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoZHJhZ0ltYWdlLCBkcmFnSW1hZ2VYT2Zmc2V0ID8/IDAsIGRyYWdJbWFnZVlPZmZzZXQgPz8gMClcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoZGF0YSkgYXMgW21pbWVUeXBlOiBzdHJpbmcsIGRhdGE6IHN0cmluZ11bXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW21pbWVUeXBlLCBkYXRhXSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShtaW1lVHlwZSwgZGF0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICBjb25zdCBvbkRyYWdFbmQgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgc2V0RHJhZ2dpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ICE9IFwibm9uZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFzdERyb3BFZmZlY3QoZS5kYXRhVHJhbnNmZXIuZHJvcEVmZmVjdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRMYXN0RHJvcEVmZmVjdChudWxsKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oe1xyXG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXHJcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0LFxyXG4gICAgICAgICAgICBvbkRyYWdFbmQsXHJcbiAgICAgICAgICAgIHJlZlxyXG4gICAgICAgIH0sIHApO1xyXG5cclxuICAgIH0sIFtlZmZlY3RBbGxvd2VkLCBkcmFnSW1hZ2UsIGRyYWdJbWFnZVhPZmZzZXQsIGRyYWdJbWFnZVlPZmZzZXQsIC4uLk9iamVjdC5lbnRyaWVzKGRhdGEpLmZsYXQoKV0pO1xyXG5cclxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxyXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxyXG4gICAgY29uc3QgcmV0OiBVc2VEcmFnZ2FibGVSZXR1cm5UeXBlPEU+ID0ge1xyXG4gICAgICAgIHVzZURyYWdnYWJsZVByb3BzLFxyXG4gICAgICAgIGRyYWdnaW5nLFxyXG4gICAgICAgIGdldERyYWdnaW5nLFxyXG4gICAgICAgIGxhc3REcm9wRWZmZWN0LFxyXG4gICAgICAgIGdldExhc3REcm9wRWZmZWN0XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiByZXQ7XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlRHJvcHBhYmxlUmV0dXJuVHlwZTxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEhvb2sgZm9yIG1vZGlmeWluZyB0aGUgcHJvcHMgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byB5b3VyIGRyb3AgdGFyZ2V0IEVsZW1lbnQuXHJcbiAgICAgKiBcclxuICAgICAqICpVbnN0YWJsZSpcclxuICAgICAqL1xyXG4gICAgdXNlRHJvcHBhYmxlUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGlsZSBzb21ldGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudCwgdGhpcyB3aWxsIGNvbnRhaW4gYW55IGluZm9ybWF0aW9uIGFib3V0IGFueSBmaWxlcyBpbmNsdWRlZCBpbiB0aGF0IGRyb3AuXHJcbiAgICAgKiBPdGhlcndpc2UsIGl0J2xsIGJlIG51bGwsIG1lYW5pbmcgbm90aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBmaWxlc0ZvckNvbnNpZGVyYXRpb246IERyb3BGaWxlTWV0YWRhdGFbXSB8IG51bGw7XHJcbiAgICAvKipcclxuICAgICAqIFdoaWxlIHNvbWV0aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LCBhIGxpc3Qgb2YgYXZhaWxhYmxlIE1JTUUgdHlwZXMgZm9yIHRoZSBub24tZmlsZSBkYXRhIHdpbGwgYmUgbGlzdGVkIGhlcmUuXHJcbiAgICAgKiBPdGhlcndpc2UsIGl0J2xsIGJlIG51bGwsIG1lYW5pbmcgbm90aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LlxyXG4gICAgICovXHJcbiAgICBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbjogU2V0PHN0cmluZz4gfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBmaWxlcyBhcmUgZHJvcHBlZCBvdmVyIHRoZSBlbGVtZW50LCB0aGVpciBkYXRhIHdpbGwgYmUgZ2l2ZW4gaGVyZS5cclxuICAgICAqIFRoaXMgd2lsbCB1cGRhdGUgYXMgbmV3IGRyb3BzIGhhcHBlbi5cclxuICAgICAqL1xyXG4gICAgZHJvcHBlZEZpbGVzOiBEcm9wRmlsZVtdIHwgbnVsbDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gbm9uLWZpbGUgZGF0YSBpcyBkcm9wcGVkIG92ZXIgdGhlIGVsZW1lbnQsIHRoZWlyIGRhdGEgd2lsbCBiZSBnaXZlbiBoZXJlLlxyXG4gICAgICogVGhpcyB3aWxsIHVwZGF0ZSBhcyBuZXcgZHJvcHMgaGFwcGVuLlxyXG4gICAgICovXHJcbiAgICBkcm9wcGVkU3RyaW5nczogeyBbTWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9IHwgbnVsbDtcclxuXHJcblxyXG4gICAgZHJvcEVycm9yOiB1bmtub3duO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyb3BwYWJsZVBhcmFtZXRlcnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBNYXBzIHRvIHRoZSBEcmFnIGFuZCBEcm9wIEFQSSAtLSBlZmZlY3RpdmVseSBtZWFucyBcImFzIGNsb3NlIGFzIHBvc3NpYmxlLCB3aGF0J3MgaGFwcGVuaW5nIHRvIHRoZSBkYXRhIHdoZW4gSSBkcm9wIGl0IGhlcmU/IFxyXG4gICAgICogQW0gSSBjb3B5aW5nIGl0IGFuZCBsZWF2aW5nIHRoZSBvcmlnaW5hbCwgYW0gSSBtb3ZpbmcgaXQgYW5kIGRlbGV0aW5nIHRoZSBvcmlnaW5hbCwgb3IgYW0gSSBsaW5raW5nIGl0IHRvIHRoZSBvcmlnaW5hbD9cIlxyXG4gICAgICogXHJcbiAgICAgKiBXaGF0ZXZlciBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyB3aWxsIGhhdmUgaXRzIG93biBwZXJtaXNzaW9uIHRoYXQncyBjaGVja2VkIGFnYWluc3QgdGhpcy5cclxuICAgICAqL1xyXG4gICAgZWZmZWN0OiBEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIERyb3BGaWxlIGV4dGVuZHMgRHJvcEZpbGVNZXRhZGF0YSB7IG5hbWU6IHN0cmluZywgZGF0YTogQXJyYXlCdWZmZXIsIHNpemU6IG51bWJlciB8IHVuZGVmaW5lZCwgbGFzdE1vZGlmaWVkOiBudW1iZXIgfCB1bmRlZmluZWQgfVxyXG5leHBvcnQgaW50ZXJmYWNlIERyb3BGaWxlTWV0YWRhdGEgeyB0eXBlOiBzdHJpbmcgfCB1bmRlZmluZWQgfVxyXG5cclxuXHJcbnR5cGUgRHJvcHBhYmxlRmlsZUVycm9yVHlwZSA9IFwiSW5kZXhTaXplRXJyb3JcIiB8IFwiSGllcmFyY2h5UmVxdWVzdEVycm9yXCIgfCBcIldyb25nRG9jdW1lbnRFcnJvclwiIHwgXCJJbnZhbGlkQ2hhcmFjdGVyRXJyb3JcIiB8IFwiTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3JcIiB8IFwiTm90Rm91bmRFcnJvclwiIHwgXCJOb3RTdXBwb3J0ZWRFcnJvclwiIHwgXCJJbnZhbGlkU3RhdGVFcnJvclwiIHwgXCJJblVzZUF0dHJpYnV0ZUVycm9yXCIgfCBcIlN5bnRheEVycm9yXCIgfCBcIkludmFsaWRNb2RpZmljYXRpb25FcnJvclwiIHwgXCJOYW1lc3BhY2VFcnJvclwiIHwgXCJJbnZhbGlkQWNjZXNzRXJyb3JcIiB8IFwiVHlwZU1pc21hdGNoRXJyb3JcIiB8IFwiU2VjdXJpdHlFcnJvclwiIHwgXCJOZXR3b3JrRXJyb3JcIiB8IFwiQWJvcnRFcnJvclwiIHwgXCJVUkxNaXNtYXRjaEVycm9yXCIgfCBcIlF1b3RhRXhjZWVkZWRFcnJvclwiIHwgXCJUaW1lb3V0RXJyb3JcIiB8IFwiSW52YWxpZE5vZGVUeXBlRXJyb3JcIiB8IFwiRGF0YUNsb25lRXJyb3JcIiB8IFwiRW5jb2RpbmdFcnJvclwiIHwgXCJOb3RSZWFkYWJsZUVycm9yXCIgfCBcIlVua25vd25FcnJvclwiIHwgXCJDb25zdHJhaW50RXJyb3JcIiB8IFwiRGF0YUVycm9yXCIgfCBcIlRyYW5zYWN0aW9uSW5hY3RpdmVFcnJvclwiIHwgXCJSZWFkT25seUVycm9yXCIgfCBcIlZlcnNpb25FcnJvclwiIHwgXCJPcGVyYXRpb25FcnJvclwiIHwgXCJOb3RBbGxvd2VkRXJyb3JcIjtcclxuXHJcbmV4cG9ydCBjbGFzcyBEcm9wcGFibGVGaWxlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBmaWxlTmFtZTogc3RyaW5nO1xyXG4gICAgZXJyb3JUeXBlOiBEcm9wcGFibGVGaWxlRXJyb3JUeXBlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGZpbGVOYW1lOiBzdHJpbmcsIGJhc2U6IERPTUV4Y2VwdGlvbiB8IG51bGwpIHtcclxuICAgICAgICBzdXBlcihiYXNlPy5tZXNzYWdlID8/IFwiQW4gdW5zcGVjaWZpZWQgZXJyb3Igb2NjdXJyZWQgcmVhZGluZyB0aGUgZmlsZS5cIik7XHJcbiAgICAgICAgdGhpcy5maWxlTmFtZSA9IGZpbGVOYW1lO1xyXG4gICAgICAgIHRoaXMuZXJyb3JUeXBlID0gKGJhc2U/Lm5hbWUgYXMgRHJvcHBhYmxlRmlsZUVycm9yVHlwZSk7XHJcbiAgICB9XHJcblxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VEcm9wcGFibGU8RSBleHRlbmRzIEhUTUxFbGVtZW50Pih7IGVmZmVjdCB9OiBVc2VEcm9wcGFibGVQYXJhbWV0ZXJzKTogVXNlRHJvcHBhYmxlUmV0dXJuVHlwZTxFPiB7XHJcblxyXG4gICAgY29uc3QgW2ZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uXSA9IHVzZVN0YXRlPG51bGwgfCBEcm9wRmlsZU1ldGFkYXRhW10+KG51bGwpO1xyXG4gICAgY29uc3QgW3N0cmluZ3NGb3JDb25zaWRlcmF0aW9uLCBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbl0gPSB1c2VTdGF0ZTxudWxsIHwgU2V0PHN0cmluZz4+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IFtkcm9wcGVkRmlsZXMsIHNldERyb3BwZWRGaWxlc10gPSB1c2VTdGF0ZTxudWxsIHwgRHJvcEZpbGVbXT4obnVsbCk7XHJcbiAgICBjb25zdCBbZHJvcHBlZFN0cmluZ3MsIHNldERyb3BwZWRTdHJpbmdzXSA9IHVzZVN0YXRlPG51bGwgfCB7IFtNaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH0+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IFtkcm9wRXJyb3IsIHNldERyb3BFcnJvcl0gPSB1c2VTdGF0ZTx1bmtub3duIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuICAgIC8vIEFsbCB0aGUgcHJvbWlzZXMgZ2VuZXJhdGVkIGZyb20gdGhlIGRyb3AgZXZlbnRzLlxyXG4gICAgLy8gVXNlZCB0byBwcm9jZXNzIG11bHRpcGxlIGRyb3AgZXZlbnRzIGluIHN1Y2Nlc3Npb25cclxuICAgIGNvbnN0IGRyb3BQcm9taXNlc1JlZiA9IHVzZVJlZjxQcm9taXNlPG51bGwgfCB7IHN0cmluZ3M6IHsgW21pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfSwgZmlsZXM6IERyb3BGaWxlW10gfT5bXT4oW10pO1xyXG4gICAgY29uc3QgW2N1cnJlbnRQcm9taXNlSW5kZXgsIHNldEN1cnJlbnRQcm9taXNlSW5kZXgsIGdldEN1cnJlbnRQcm9taXNlSW5kZXhdID0gdXNlU3RhdGUoLTEpO1xyXG4gICAgY29uc3QgW3Byb21pc2VDb3VudCwgc2V0UHJvbWlzZUNvdW50LCBnZXRQcm9taXNlQ291bnRdID0gdXNlU3RhdGUoMCk7XHJcblxyXG4gICAgLy8gQW55IHRpbWUgd2UgYWRkIGEgbmV3IHByb21pc2UsIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBwcm9taXNlIHJ1bm5pbmcsIHdlIG5lZWQgdG8gc3RhcnQgb25lLlxyXG4gICAgLy8gSWYgdGhlcmUgaXMgb25lLCB0aGVuIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmcsIHNpbmNlIGl0IHJ1bnMgdGhlIHNhbWUgY2hlY2suXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlSW5kZXggPSBnZXRDdXJyZW50UHJvbWlzZUluZGV4KCk7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XHJcblxyXG4gICAgICAgIGlmIChwcm9taXNlQ291bnQgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmICgoY3VycmVudFByb21pc2VJbmRleCArIDEpIDwgcHJvbWlzZUNvdW50KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50UHJvbWlzZUluZGV4KGkgPT4gKytpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICB9LCBbcHJvbWlzZUNvdW50XSk7XHJcblxyXG4gICAgLy8gQW55dGltZSBvdXIgY3VycmVudCBwcm9taXNlIGNoYW5nZXMsXHJcbiAgICAvLyB3YWl0IGZvciBpdCB0byBmaW5pc2gsIHRoZW4gc2V0IG91ciBzdGF0ZSB0byBpdHMgcmVzdWx0LlxyXG4gICAgLy8gRmluYWxseSwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBhbnltb3JlIHByb21pc2VzLlxyXG4gICAgLy8gSWYgdGhlcmUgYXJlLCB0aGVuIGluY3JlYXNlIGN1cnJlbnRQcm9taXNlQ291bnQsXHJcbiAgICAvLyB3aGljaCB3aWxsIHRyaWdnZXIgdGhpcyBhZ2Fpbi5cclxuICAgIC8vXHJcbiAgICAvLyBUaGlzIHNob3VsZG4ndCBoYXBwZW4gKm9mdGVuKiwgYnV0IG1heWJlIGluIHRoZSBjYXNlIG9mXHJcbiAgICAvLyBpbmRpdmlkdWFsbHkgZHJvcHBpbmcgYSBidW5jaCBvZiBsYXJnZSBmaWxlcyBvciBzb21ldGhpbmcuXHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50UHJvbWlzZUluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFByb21pc2UgPSBkcm9wUHJvbWlzZXNSZWYuY3VycmVudFtjdXJyZW50UHJvbWlzZUluZGV4XTtcclxuICAgICAgICAgICAgY3VycmVudFByb21pc2UudGhlbigoaW5mbykgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChpbmZvICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBmaWxlcywgc3RyaW5ncyB9ID0gaW5mbztcclxuICAgICAgICAgICAgICAgICAgICBzZXREcm9wcGVkRmlsZXMoZmlsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BwZWRTdHJpbmdzKHN0cmluZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGRvbmUsIGFyZSB0aGVyZSBtb3JlIHByb21pc2VzIGluIHRoZSBxdWV1ZT9cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UHJvbWlzZUluZGV4ID0gZ2V0Q3VycmVudFByb21pc2VJbmRleCgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKChjdXJyZW50UHJvbWlzZUluZGV4ICsgMSkgPCBwcm9taXNlQ291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIHByb21pc2UgaGFzIHN0YXJ0ZWQsIG1vcmUgaGF2ZSBiZWVuIGFkZGVkLlxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB0aGlzIGVmZmVjdCBhZ2Fpbi5cclxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJyZW50UHJvbWlzZUluZGV4KGkgPT4gKytpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9XHJcbiAgICB9LCBbY3VycmVudFByb21pc2VJbmRleF0pXHJcblxyXG5cclxuICAgIGNvbnN0IHVzZURyb3BwYWJsZVByb3BzOiBVc2VEcm9wcGFibGVSZXR1cm5UeXBlPEU+W1widXNlRHJvcHBhYmxlUHJvcHNcIl0gPSAocCkgPT4ge1xyXG5cclxuICAgICAgICAvL2NvbnN0IHJlZiA9IHVzZVJlZjxFPihudWxsKTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGNvbGxlY3RpbmcgdGhlIGN1cnJlbnQgZmlsZSBtZXRhZGF0YSBvciBNSU1FIHR5cGVzLlxyXG4gICAgICAgIGNvbnN0IG9uRHJhZ0VudGVyID0gKGU6IERyYWdFdmVudCkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGEgZGVmYXVsdD8gSSBjYW4ndCBmaW5kIG9uZSBhbnl3aGVyZS5cclxuICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QgPSAoZWZmZWN0ID8/IFwibW92ZVwiKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNaW1lVHlwZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0ZpbGVzID0gbmV3IEFycmF5PERyb3BGaWxlTWV0YWRhdGE+KCk7XHJcblxyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGUuZGF0YVRyYW5zZmVyPy5pdGVtcyA/PyBbXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2luZCwgdHlwZSB9ID0gaXRlbTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWltZVR5cGVzLmFkZCh0eXBlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2luZCA9PT0gXCJmaWxlXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3RmlsZXMucHVzaCh7IHR5cGU6IGl0ZW0udHlwZSB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbihuZXdGaWxlcyk7XHJcbiAgICAgICAgICAgICAgICBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbihuZXdNaW1lVHlwZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIHJlc2V0dGluZyB0aGUgY3VycmVudCBmaWxlIG1ldGFkYXRhIG9yIE1JTUUgdHlwZXNcclxuICAgICAgICBjb25zdCBvbkRyYWdMZWF2ZSA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBzZXRGaWxlc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XHJcbiAgICAgICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIEJvaWxlcnBsYXRlLCBJIGd1ZXNzXHJcbiAgICAgICAgY29uc3Qgb25EcmFnT3ZlciA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSGFuZGxlIGdldHRpbmcgdGhlIGRyb3AgZGF0YSBhc3luY2hyb25vdXNseVxyXG4gICAgICAgIGNvbnN0IG9uRHJvcCA9IChlOiBEcmFnRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgICAgICAgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xyXG4gICAgICAgICAgICBzZXRTdHJpbmdzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGFsbFByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBkcm9wRGF0YTogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XHJcbiAgICAgICAgICAgIGNvbnN0IGRyb3BGaWxlOiBEcm9wRmlsZVtdID0gW107XHJcblxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZS5kYXRhVHJhbnNmZXI/Lml0ZW1zID8/IFtdKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtpbmQsIHR5cGUgfSA9IGl0ZW07XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbGxQcm9taXNlcy5wdXNoKChuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCBfcmVqZWN0KSA9PiBpdGVtLmdldEFzU3RyaW5nKHJlc29sdmUpKSkudGhlbihzdHIgPT4gZHJvcERhdGFbdHlwZV0gPSBzdHIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQgPT09IFwiZmlsZVwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUHJvbWlzZXMucHVzaChcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChfKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5yZXN1bHQgYXMgQXJyYXlCdWZmZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BGaWxlLnB1c2goeyBkYXRhLCBuYW1lOiBmaWxlLm5hbWUsIHR5cGU6IGZpbGUudHlwZSwgc2l6ZTogZGF0YS5ieXRlTGVuZ3RoLCBsYXN0TW9kaWZpZWQ6IGZpbGUubGFzdE1vZGlmaWVkIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoXykgPT4geyByZWplY3QobmV3IERyb3BwYWJsZUZpbGVFcnJvcihmaWxlLm5hbWUsIHJlYWRlci5lcnJvcikpOyB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmFib3J0ID0gKF8pID0+IHsgcmVqZWN0KG5ldyBEcm9wcGFibGVGaWxlRXJyb3IoZmlsZS5uYW1lLCByZWFkZXIuZXJyb3IpKTsgfTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZpbGUucHVzaCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgICAgIGRyb3BQcm9taXNlc1JlZi5jdXJyZW50LnB1c2goUHJvbWlzZS5hbGwoYWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgc2V0UHJvbWlzZUNvdW50KGkgPT4gKytpKTtcclxuICAgICAgICAgICAgICAgIHNldERyb3BFcnJvcihudWxsKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nczogZHJvcERhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZXM6IGRyb3BGaWxlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pLmNhdGNoKGV4ID0+IHtcclxuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXHJcbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICAgICAgICAgIHNldFByb21pc2VDb3VudChpID0+ICsraSk7XHJcbiAgICAgICAgICAgICAgICBzZXREcm9wRXJyb3IoZXgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4oeyBvbkRyYWdFbnRlciwgb25EcmFnTGVhdmUsIG9uRHJhZ092ZXIsIG9uRHJvcCB9LCBwKTtcclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB1c2VEcm9wcGFibGVQcm9wcyxcclxuICAgICAgICBmaWxlc0ZvckNvbnNpZGVyYXRpb24sXHJcbiAgICAgICAgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sXHJcbiAgICAgICAgZHJvcHBlZEZpbGVzLFxyXG4gICAgICAgIGRyb3BwZWRTdHJpbmdzLFxyXG5cclxuICAgICAgICBkcm9wRXJyb3JcclxuICAgIH1cclxufVxyXG5cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcclxuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHJldHVybk51bGwsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcclxuXHJcbmludGVyZmFjZSBVc2VFbGVtZW50U2l6ZVBhcmFtZXRlcnMge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGJyb3dzZXIgZGV0ZWN0cyBhIHNpemUgY2hhbmdlXHJcbiAgICAgKiBvbiB0aGUgZWxlbWVudC4gRG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUsIHNvIHlvdVxyXG4gICAgICogY2FuIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHRoYXQgb25seSBzZXRzIHRoZVxyXG4gICAgICogdmFsdWVzIHlvdSB1c2UgaWYgeW91J2QgbGlrZS5cclxuICAgICAqIEBwYXJhbSBzaXplSW5mbyBcclxuICAgICAqL1xyXG4gICAgb25TaXplQ2hhbmdlKHNpemVJbmZvOiBFbGVtZW50U2l6ZSk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIGNyZWF0ZWQgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKiBcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZU9ic2VydmVyL29ic2VydmUjcGFyYW1ldGVyc1xyXG4gICAgICovXHJcbiAgICBnZXRPYnNlcnZlQm94PygpOiBSZXNpemVPYnNlcnZlck9wdGlvbnNbXCJib3hcIl07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRWxlbWVudFNpemUge1xyXG4gICAgY2xpZW50V2lkdGg6IG51bWJlcjtcclxuICAgIHNjcm9sbFdpZHRoOiBudW1iZXI7XHJcbiAgICBvZmZzZXRXaWR0aDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50SGVpZ2h0OiBudW1iZXI7XHJcbiAgICBzY3JvbGxIZWlnaHQ6IG51bWJlcjtcclxuICAgIG9mZnNldEhlaWdodDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50TGVmdDogbnVtYmVyO1xyXG4gICAgc2Nyb2xsTGVmdDogbnVtYmVyO1xyXG4gICAgb2Zmc2V0TGVmdDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50VG9wOiBudW1iZXI7XHJcbiAgICBzY3JvbGxUb3A6IG51bWJlcjtcclxuICAgIG9mZnNldFRvcDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUVsZW1lbnRTaXplUmV0dXJuVHlwZTxFIGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQoKTogRSB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgZ2V0U2l6ZSgpOiBFbGVtZW50U2l6ZSB8IG51bGw7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlRWxlbWVudFNpemVQcm9wczogVXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT5bXCJ1c2VSZWZFbGVtZW50UHJvcHNcIl07XHJcbn1cclxuXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlRWxlbWVudFNpemU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZ2V0T2JzZXJ2ZUJveCwgb25TaXplQ2hhbmdlIH06IFVzZUVsZW1lbnRTaXplUGFyYW1ldGVycyk6IFVzZUVsZW1lbnRTaXplUmV0dXJuVHlwZTxFPiB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlRWxlbWVudFNpemVcIiwgZ2V0T2JzZXJ2ZUJveCwgb25TaXplQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0U2l6ZSwgc2V0U2l6ZV0gPSB1c2VQYXNzaXZlU3RhdGU8RWxlbWVudFNpemUgfCBudWxsPihvblNpemVDaGFuZ2UgYXMgT25QYXNzaXZlU3RhdGVDaGFuZ2U8RWxlbWVudFNpemUgfCBudWxsPiwgcmV0dXJuTnVsbCk7XHJcblxyXG4gICAgY29uc3QgY3VycmVudE9ic2VydmVCb3ggPSB1c2VSZWY8UmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xyXG5cclxuICAgIGNvbnN0IG5lZWRBTmV3T2JzZXJ2ZXIgPSB1c2VDYWxsYmFjaygoZWxlbWVudDogRSB8IG51bGwsIG9ic2VydmVCb3g6IFJlc2l6ZU9ic2VydmVyQm94T3B0aW9ucyB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG5cclxuICAgICAgICAgICAgY29uc3QgaGFuZGxlVXBkYXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuaXNDb25uZWN0ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSA9IChlbGVtZW50IGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0U2l6ZSh7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcblxyXG4gICAgICAgICAgICBpZiAod2luZG93ICYmIChcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKF9lbnRyaWVzKSA9PiB7IGhhbmRsZVVwZGF0ZSgpOyB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBvYnNlcnZlQm94IH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBvYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIGhhbmRsZVVwZGF0ZSwgeyBwYXNzaXZlOiB0cnVlIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtdKVxyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PEU+KHsgb25FbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjaygoZTogRSB8IG51bGwpID0+IG5lZWRBTmV3T2JzZXJ2ZXIoZSwgZ2V0T2JzZXJ2ZUJveD8uKCkpLCBbXSkgfSk7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoZ2V0T2JzZXJ2ZUJveCkge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE9ic2VydmVCb3guY3VycmVudCAhPT0gZ2V0T2JzZXJ2ZUJveCgpKVxyXG4gICAgICAgICAgICAgICAgbmVlZEFOZXdPYnNlcnZlcihnZXRFbGVtZW50KCksIGdldE9ic2VydmVCb3goKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldFNpemUsXHJcbiAgICAgICAgdXNlRWxlbWVudFNpemVQcm9wczogdXNlUmVmRWxlbWVudFByb3BzXHJcbiAgICB9XHJcblxyXG5cclxufVxyXG4iLCJjb25zdCBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICdpbnB1dCcsXG4gICdzZWxlY3QnLFxuICAndGV4dGFyZWEnLFxuICAnYVtocmVmXScsXG4gICdidXR0b24nLFxuICAnW3RhYmluZGV4XTpub3Qoc2xvdCknLFxuICAnYXVkaW9bY29udHJvbHNdJyxcbiAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsXG4gICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScsXG4gICdkZXRhaWxzJyxcbl07XG5jb25zdCBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xuXG5jb25zdCBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IG1hdGNoZXMgPSBOb0VsZW1lbnRcbiAgPyBmdW5jdGlvbiAoKSB7fVxuICA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuY29uc3QgZ2V0Um9vdE5vZGUgPVxuICAhTm9FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlXG4gICAgPyAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRSb290Tm9kZSgpXG4gICAgOiAoZWxlbWVudCkgPT4gZWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciB0byBjaGVja1xuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgbGV0IGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoXG4gICAgZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcilcbiAgKTtcbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEdldFNoYWRvd1Jvb3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVjayBmb3Igc2hhZG93IHJvb3RcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fGJvb2xlYW59IFNoYWRvd1Jvb3QgaWYgYXZhaWxhYmxlIG9yIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHNoYWRvd1Jvb3QgaXMgYXR0YWNoZWQgYnV0IG5vdCBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2hhZG93Um9vdEZpbHRlclxuICogQHBhcmFtIHtFbGVtZW50fSBzaGFkb3dIb3N0Tm9kZSB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyBzaGFkb3cgY29udGVudFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBzaGFkb3cgcm9vdCBjb3VsZCBwb3RlbnRpYWxseSBjb250YWluIHZhbGlkIGNhbmRpZGF0ZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW5kaWRhdGVzU2NvcGVcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gc2NvcGUgY29udGFpbnMgaW5uZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtFbGVtZW50W119IGNhbmRpZGF0ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEl0ZXJhdGl2ZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7R2V0U2hhZG93Um9vdHxib29sZWFufSBnZXRTaGFkb3dSb290IHRydWUgaWYgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZDsgZmFsc3kgaWYgbm90O1xuICogIGlmIGEgZnVuY3Rpb24sIGltcGxpZXMgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZCBhbmQgZWl0aGVyIHJldHVybnMgdGhlIHNoYWRvdyByb290IG9mIGFuIGVsZW1lbnRcbiAqICBvciBhIGJvb2xlYW4gc3RhdGluZyBpZiBpdCBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHJvb3RcbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBmbGF0dGVuIGlmIHRydWUgdGhlbiByZXN1bHQgd2lsbCBmbGF0dGVuIGFueSBDYW5kaWRhdGVzU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgbGlzdCBvZiBlbGVtZW50IGNvbnRhaW5lcnMgdG8gbWF0Y2ggY2FuZGlkYXRlcyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVzU2NvcGU+fVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiAoXG4gIGVsZW1lbnRzLFxuICBpbmNsdWRlQ29udGFpbmVyLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICBjb25zdCBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcbiAgd2hpbGUgKGVsZW1lbnRzVG9DaGVjay5sZW5ndGgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NMT1QnKSB7XG4gICAgICAvLyBhZGQgc2hhZG93IGRvbSBzbG90IHNjb3BlIChzbG90IGl0c2VsZiBjYW5ub3QgYmUgZm9jdXNhYmxlKVxuICAgICAgY29uc3QgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGNvbnRlbnQsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgY29uc3QgdmFsaWRDYW5kaWRhdGUgPSBtYXRjaGVzLmNhbGwoZWxlbWVudCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWxpZENhbmRpZGF0ZSAmJlxuICAgICAgICBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJlxuICAgICAgICAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpXG4gICAgICApIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPVxuICAgICAgICBlbGVtZW50LnNoYWRvd1Jvb3QgfHxcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICAodHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU2hhZG93Um9vdCA9XG4gICAgICAgICFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoc2hhZG93Um9vdCAmJiB2YWxpZFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2NvcGUgSUlGIGEgc2hhZG93IHJvb3Qgbm9kZSB3YXMgZ2l2ZW47IG90aGVyd2lzZSwgYW4gdW5kaXNjbG9zZWRcbiAgICAgICAgLy8gIHNoYWRvdyBleGlzdHMsIHNvIGxvb2sgYXQgbGlnaHQgZG9tIGNoaWxkcmVuIGFzIGZhbGxiYWNrIEJVVCBjcmVhdGUgYSBzY29wZSBmb3IgYW55XG4gICAgICAgIC8vICBjaGlsZCBjYW5kaWRhdGVzIGZvdW5kIGJlY2F1c2UgdGhleSdyZSBsaWtlbHkgc2xvdHRlZCBlbGVtZW50cyAoZWxlbWVudHMgdGhhdCBhcmVcbiAgICAgICAgLy8gIGNoaWxkcmVuIG9mIHRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgKHdoaWNoIGhhcyB0aGUgc2hhZG93KSwgaW4gdGhlIGxpZ2h0IGRvbSwgYnV0XG4gICAgICAgIC8vICBzbG90dGVkIHNvbWV3aGVyZSBfaW5zaWRlXyB0aGUgdW5kaXNjbG9zZWQgc2hhZG93KSAtLSB0aGUgc2NvcGUgaXMgY3JlYXRlZCBiZWxvdyxcbiAgICAgICAgLy8gIF9hZnRlcl8gd2UgcmV0dXJuIGZyb20gdGhpcyByZWN1cnNpdmUgY2FsbFxuICAgICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFxuICAgICAgICAgIHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm90IHNoYWRvdyBzbyBqdXN0IGRpZyBpbnRvIHRoZSBlbGVtZW50J3MgKGxpZ2h0IGRvbSkgY2hpbGRyZW5cbiAgICAgICAgLy8gIF9fd2l0aG91dF9fIGdpdmluZyB0aGUgZWxlbWVudCBzcGVjaWFsIHNjb3BlIHRyZWF0bWVudFxuICAgICAgICBlbGVtZW50c1RvQ2hlY2sudW5zaGlmdCguLi5lbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIChub2RlLCBpc1Njb3BlKSB7XG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gICAgLy8gb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwLlxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuICAgIC8vXG4gICAgLy8gaXNTY29wZSBpcyBwb3NpdGl2ZSBmb3IgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQgYnkgZGVmYXVsdFxuICAgIC8vIGhhdmUgdGFiSW5kZXggLTEsIGJ1dCBuZWVkIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgdGhlaXJcbiAgICAvLyBjb250ZW50IHRvIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgaWYgKFxuICAgICAgKGlzU2NvcGUgfHxcbiAgICAgICAgL14oQVVESU98VklERU98REVUQUlMUykkLy50ZXN0KG5vZGUudGFnTmFtZSkgfHxcbiAgICAgICAgbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkgJiZcbiAgICAgIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbmNvbnN0IHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXhcbiAgICA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlclxuICAgIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59O1xuXG5jb25zdCBpc0lucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG5cbmNvbnN0IGlzSGlkZGVuSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxuY29uc3QgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCByID1cbiAgICBub2RlLnRhZ05hbWUgPT09ICdERVRBSUxTJyAmJlxuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmFwcGx5KG5vZGUuY2hpbGRyZW4pXG4gICAgICAuc29tZSgoY2hpbGQpID0+IGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJyk7XG4gIHJldHVybiByO1xufTtcblxuY29uc3QgZ2V0Q2hlY2tlZFJhZGlvID0gZnVuY3Rpb24gKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIGNvbnN0IHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJ1xuICAgICk7XG4gIH07XG5cbiAgbGV0IHJhZGlvU2V0O1xuICBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUy5lc2NhcGUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdMb29rcyBsaWtlIHlvdSBoYXZlIGEgcmFkaW8gYnV0dG9uIHdpdGggYSBuYW1lIGF0dHJpYnV0ZSBjb250YWluaW5nIGludmFsaWQgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgYW5kIG5lZWQgdGhlIENTUy5lc2NhcGUgcG9seWZpbGw6ICVzJyxcbiAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59O1xuXG5jb25zdCBpc1JhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxuY29uc3QgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn07XG5cbmNvbnN0IGlzWmVyb0FyZWEgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xuY29uc3QgaXNIaWRkZW4gPSBmdW5jdGlvbiAobm9kZSwgeyBkaXNwbGF5Q2hlY2ssIGdldFNoYWRvd1Jvb3QgfSkge1xuICAvLyBOT1RFOiB2aXNpYmlsaXR5IHdpbGwgYmUgYHVuZGVmaW5lZGAgaWYgbm9kZSBpcyBkZXRhY2hlZCBmcm9tIHRoZSBkb2N1bWVudFxuICAvLyAgKHNlZSBub3RlcyBhYm91dCB0aGlzIGZ1cnRoZXIgZG93biksIHdoaWNoIG1lYW5zIHdlIHdpbGwgY29uc2lkZXIgaXQgdmlzaWJsZVxuICAvLyAgKHRoaXMgaXMgbGVnYWN5IGJlaGF2aW9yIGZyb20gYSB2ZXJ5IGxvbmcgd2F5IGJhY2spXG4gIC8vIE5PVEU6IHdlIGNoZWNrIHRoaXMgcmVnYXJkbGVzcyBvZiBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBiZWNhdXNlIHRoaXMgaXMgYVxuICAvLyAgX3Zpc2liaWxpdHlfIGNoZWNrLCBub3QgYSBfZGlzcGxheV8gY2hlY2tcbiAgaWYgKGdldENvbXB1dGVkU3R5bGUobm9kZSkudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGNvbnN0IGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgY29uc3Qgbm9kZVVuZGVyRGV0YWlscyA9IGlzRGlyZWN0U3VtbWFyeSA/IG5vZGUucGFyZW50RWxlbWVudCA6IG5vZGU7XG4gIGlmIChtYXRjaGVzLmNhbGwobm9kZVVuZGVyRGV0YWlscywgJ2RldGFpbHM6bm90KFtvcGVuXSkgKicpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxuICAvLyBJZiByb290Tm9kZSBpcyBzaGFkb3cgcm9vdCwgaXQnbGwgaGF2ZSBhIGhvc3QsIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBzaGFkb3dcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xuICAvLyAgYmVoYXZlIGxpa2Ugc2VsZi1jb250YWluZWQgRE9NczsgYnV0IGlmIHRoZSBzaGFkb3cncyBIT1NULCB3aGljaCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCxcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxuICAvLyAgb3IgYSBjdXN0b20gZWxlbWVudCAoaS5lLiB3ZWIgY29tcG9uZW50KS4gRWl0aGVyIHdheSwgdGhhdCdzIHRoZSBvbmUgdGhhdCBpcyBjb25zaWRlcmVkXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcbiAgLy8gIHRlc3RlZCkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIG5vdCBhIHNoYWRvdyByb290LCBpdCB3b24ndCBoYXZlIGEgaG9zdCwgYW5kIHNvIHJvb3ROb2RlIHNob3VsZCBiZSB0aGVcbiAgLy8gIGRvY3VtZW50IChwZXIgdGhlIGRvY3MpIGFuZCB3aGlsZSBpdCdzIGEgRG9jdW1lbnQtdHlwZSBvYmplY3QsIHRoYXQgZG9jdW1lbnQgZG9lcyBub3RcbiAgLy8gIGFwcGVhciB0byBiZSB0aGUgc2FtZSBhcyB0aGUgbm9kZSdzIGBvd25lckRvY3VtZW50YCBmb3Igc29tZSByZWFzb24sIHNvIGl0J3Mgc2FmZXJcbiAgLy8gIHRvIGlnbm9yZSB0aGUgcm9vdE5vZGUgYXQgdGhpcyBwb2ludCwgYW5kIHVzZSBgbm9kZS5vd25lckRvY3VtZW50YC4gT3RoZXJ3aXNlLFxuICAvLyAgdXNpbmcgYHJvb3ROb2RlLmNvbnRhaW5zKG5vZGUpYCB3aWxsIF9hbHdheXNfIGJlIHRydWUgd2UnbGwgZ2V0IGZhbHNlLXBvc2l0aXZlcyB3aGVuXG4gIC8vICBub2RlIGlzIGFjdHVhbGx5IGRldGFjaGVkLlxuICBjb25zdCBub2RlUm9vdEhvc3QgPSBnZXRSb290Tm9kZShub2RlKS5ob3N0O1xuICBjb25zdCBub2RlSXNBdHRhY2hlZCA9XG4gICAgbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHxcbiAgICBub2RlLm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZSk7XG5cbiAgaWYgKCFkaXNwbGF5Q2hlY2sgfHwgZGlzcGxheUNoZWNrID09PSAnZnVsbCcpIHtcbiAgICBpZiAodHlwZW9mIGdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZSBub2RlIHRvIGJlIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyBhbmQgdXNlIHRoZVxuICAgICAgLy8gICdub24temVyby1hcmVhJyBmYWxsYmFja1xuICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJlxuICAgICAgICAgIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkgPT09IHRydWUgLy8gY2hlY2sgaWYgdGhlcmUncyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbm9kZSBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHdoaWNoIG1lYW5zIHdlIGNhbiBvbmx5IHRyZWF0IGl0IGFzIGEgYmxhY2sgYm94LCBzbyB3ZVxuICAgICAgICAgIC8vICBmYWxsIGJhY2sgdG8gYSBub24temVyby1hcmVhIHRlc3RcbiAgICAgICAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgc2xvdFxuICAgICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgfSBlbHNlIGlmICghcGFyZW50RWxlbWVudCAmJiByb290Tm9kZSAhPT0gbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgLy8gY3Jvc3Mgc2hhZG93IGJvdW5kYXJ5XG4gICAgICAgICAgbm9kZSA9IHJvb3ROb2RlLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBub3JtYWwgZG9tXG4gICAgICAgICAgbm9kZSA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG9yaWdpbmFsTm9kZTtcbiAgICB9XG4gICAgLy8gZWxzZSwgYGdldFNoYWRvd1Jvb3RgIG1pZ2h0IGJlIHRydWUsIGJ1dCBhbGwgdGhhdCBkb2VzIGlzIGVuYWJsZSBzaGFkb3cgRE9NIHN1cHBvcnRcbiAgICAvLyAgKGkuZS4gaXQgZG9lcyBub3QgYWxzbyBwcmVzdW1lIHRoYXQgYWxsIG5vZGVzIG1pZ2h0IGhhdmUgdW5kaXNjbG9zZWQgc2hhZG93cyk7IG9yXG4gICAgLy8gIGl0IG1pZ2h0IGJlIGEgZmFsc3kgdmFsdWUsIHdoaWNoIG1lYW5zIHNoYWRvdyBET00gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxuICAgIC8vICBub3cgd2UgY2FuIGp1c3QgdGVzdCB0byBzZWUgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgdmlzaWJsZSBvciBub3QsIHByb3ZpZGVkIGl0J3NcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cbiAgICAvLyAgYGlzVGFiYmFibGUoKWAgb3IgYGlzRm9jdXNhYmxlKClgIC0tIHJlZ2FyZGxlc3Mgb2YgYGdldFNoYWRvd1Jvb3RgIG9wdGlvbiBzZXR0aW5nLlxuXG4gICAgaWYgKG5vZGVJc0F0dGFjaGVkKSB7XG4gICAgICAvLyB0aGlzIHdvcmtzIHdoZXJldmVyIHRoZSBub2RlIGlzOiBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBjbGllbnQgcmVjdCwgaXQnc1xuICAgICAgLy8gIHNvbWVob3cgZGlzcGxheWVkOyBpdCBhbHNvIGNvdmVycyB0aGUgQ1NTICdkaXNwbGF5OiBjb250ZW50cycgY2FzZSB3aGVyZSB0aGVcbiAgICAgIC8vICBub2RlIGl0c2VsZiBpcyBoaWRkZW4gaW4gcGxhY2Ugb2YgaXRzIGNvbnRlbnRzOyBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaFxuICAgICAgLy8gIHVwIHRoZSBoaWVyYXJjaHkgZWl0aGVyXG4gICAgICByZXR1cm4gIW5vZGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gRWxzZSwgdGhlIG5vZGUgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGUgYGdldENsaWVudFJlY3RzKClgXG4gICAgLy8gIEFQSSB3aWxsIF9fYWx3YXlzX18gcmV0dXJuIHplcm8gcmVjdHMgKHRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIFJlYWN0XG4gICAgLy8gIGlzIHVzZWQgdG8gcmVuZGVyIG5vZGVzIG9udG8gYSBkZXRhY2hlZCB0cmVlLCBhcyBjb25maXJtZWQgaW4gdGhpcyB0aHJlYWQ6XG4gICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTExNyNpc3N1ZWNvbW1lbnQtMjg0MjI4ODcwKVxuICAgIC8vXG4gICAgLy8gSXQgYWxzbyBtZWFucyB0aGF0IGV2ZW4gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSB3aWxsIHJldHVybiBgdW5kZWZpbmVkYFxuICAgIC8vICBiZWNhdXNlIHN0eWxlcyBhcmUgb25seSBjb21wdXRlZCBmb3Igbm9kZXMgdGhhdCBhcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgIC8vXG4gICAgLy8gTk9URTogVEhJUyBIQVMgQkVFTiBUSEUgQ0FTRSBGT1IgWUVBUlMuIEl0IGlzIG5vdCBuZXcsIG5vciBpcyBpdCBjYXVzZWQgYnkgdGFiYmFibGVcbiAgICAvLyAgc29tZWhvdy4gVGhvdWdoIGl0IHdhcyBuZXZlciBzdGF0ZWQgb2ZmaWNpYWxseSwgYW55b25lIHdobyBoYXMgZXZlciB1c2VkIHRhYmJhYmxlXG4gICAgLy8gIEFQSXMgb24gbm9kZXMgaW4gZGV0YWNoZWQgY29udGFpbmVycyBoYXMgYWN0dWFsbHkgaW1wbGljaXRseSB1c2VkIHRhYmJhYmxlIGluIHdoYXRcbiAgICAvLyAgd2FzIGxhdGVyIChhcyBvZiB2NS4yLjAgb24gQXByIDksIDIwMjEpIGNhbGxlZCBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBtb2RlIC0tIGVzc2VudGlhbGx5XG4gICAgLy8gIGNvbnNpZGVyaW5nIF9fZXZlcnl0aGluZ19fIHRvIGJlIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgaW5uYWJpbGl0eSB0byBkZXRlcm1pbmUgc3R5bGVzLlxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gJ25vbi16ZXJvLWFyZWEnKSB7XG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxuICAgIC8vICBjbGllbnQgcmVjdCwgd2UgZG9uJ3Qgc3BlY2lhbC1jYXNlIGZvciB3aGV0aGVyIHRoZSBub2RlIGlzIGF0dGFjaGVkIG9yIG5vdC4gSW5cbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXG4gICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gIH1cblxuICAvLyB2aXNpYmxlLCBhcyBmYXIgYXMgd2UgY2FuIHRlbGwsIG9yIHBlciBjdXJyZW50IGBkaXNwbGF5Q2hlY2tgIG1vZGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gZm9ybSBmaWVsZHMgKG5lc3RlZCkgaW5zaWRlIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIG5vdCBmb2N1c2FibGUvdGFiYmFibGVcbi8vICB1bmxlc3MgdGhleSBhcmUgaW4gdGhlIF9maXJzdF8gPGxlZ2VuZD4gZWxlbWVudCBvZiB0aGUgdG9wLW1vc3QgZGlzYWJsZWRcbi8vICBmaWVsZHNldFxuY29uc3QgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICAvLyBsb29rIGZvciB0aGUgZmlyc3QgPGxlZ2VuZD4gYW1vbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IDxsZWdlbmQ+IChpbiBkb2N1bWVudCBvcmRlcikgaXMgZm91bmRcbiAgICAgICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHBhcmVudE5vZGUsICdmaWVsZHNldFtkaXNhYmxlZF0gKicpXG4gICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICA6ICFjaGlsZC5jb250YWlucyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRpc2FibGVkIDxmaWVsZHNldD4gY29udGFpbmluZyBgbm9kZWAgaGFzIG5vIDxsZWdlbmQ+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvLyBlbHNlLCBub2RlJ3MgdGFiYmFibGUvZm9jdXNhYmxlIHN0YXRlIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgYSBmaWVsZHNldCdzXG4gIC8vICBlbmFibGVkL2Rpc2FibGVkIHN0YXRlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgbm9kZS5kaXNhYmxlZCB8fFxuICAgIGlzSGlkZGVuSW5wdXQobm9kZSkgfHxcbiAgICBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fFxuICAgIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICAgIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHx8XG4gICAgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8XG4gICAgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8XG4gICAgIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIChzaGFkb3dIb3N0Tm9kZSkge1xuICBjb25zdCB0YWJJbmRleCA9IHBhcnNlSW50KHNoYWRvd0hvc3ROb2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICBpZiAoaXNOYU4odGFiSW5kZXgpIHx8IHRhYkluZGV4ID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBhIGN1c3RvbSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSB0YWJpbmRleCxcbiAgLy8gYnJvd3NlcnMgd2lsbCBub3QgYWxsb3cgdGFiIHRhcmdldGluZyBzYWlkIGVsZW1lbnQncyBjaGlsZHJlbi5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG5jb25zdCBzb3J0QnlPcmRlciA9IGZ1bmN0aW9uIChjYW5kaWRhdGVzKSB7XG4gIGNvbnN0IHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgY29uc3Qgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBjb25zdCBpc1Njb3BlID0gISFpdGVtLnNjb3BlO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBpc1Njb3BlID8gaXRlbS5zY29wZSA6IGl0ZW07XG4gICAgY29uc3QgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IGlzU2NvcGUgPyBzb3J0QnlPcmRlcihpdGVtLmNhbmRpZGF0ZXMpIDogZWxlbWVudDtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGVcbiAgICAgICAgPyByZWd1bGFyVGFiYmFibGVzLnB1c2goLi4uZWxlbWVudHMpXG4gICAgICAgIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzLFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlc1xuICAgIC5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKVxuICAgIC5yZWR1Y2UoKGFjYywgc29ydGFibGUpID0+IHtcbiAgICAgIHNvcnRhYmxlLmlzU2NvcGVcbiAgICAgICAgPyBhY2MucHVzaCguLi5zb3J0YWJsZS5jb250ZW50KVxuICAgICAgICA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcblxuY29uc3QgdGFiYmFibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IGZhbHNlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgICAgc2hhZG93Um9vdEZpbHRlcjogaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGlzVGFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5jb25zdCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnNcbiAgLmNvbmNhdCgnaWZyYW1lJylcbiAgLmpvaW4oJywnKTtcblxuY29uc3QgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuZXhwb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgaXNGb2N1c2FibGUgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnaW5lcnQnLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICAgKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICAgKi9cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zbGljZX0gKi9cbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiBJRSBoYXMgYSBub24tc3RhbmRhcmQgbmFtZSBmb3IgXCJtYXRjaGVzXCIuXG4gICAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgICAqL1xuICAgIHZhciBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgICAqIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtIHRvIGNyZWF0ZSBhbmQgbWFpbnRhaW4gYSBzZXQgb2YgbWFuYWdlZCBgSW5lcnROb2RlYHMsIGluY2x1ZGluZyB3aGVuIG11dGF0aW9ucyBvY2N1ciBpbiB0aGVcbiAgICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAgICogICBmb2N1c2FibGUgbm9kZXMgd2l0aGluIGluZXJ0IHN1YnRyZWVzLiBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWBcbiAgICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAgICpcbiAgICAgKiAtIHRvIG5vdGlmeSBhbGwgbWFuYWdlZCBgSW5lcnROb2RlYHMgd2hlbiB0aGlzIHN1YnRyZWUgc3RvcHMgYmVpbmcgaW5lcnQgKGkuZS4gd2hlbiB0aGUgYGluZXJ0YFxuICAgICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgICAqL1xuXG4gICAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50IFRoZSBIVE1MRWxlbWVudCBhdCB0aGUgcm9vdCBvZiB0aGUgaW5lcnQgc3VidHJlZS5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gaW5lcnRNYW5hZ2VyO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Um9vdCwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hbmFnZU5vZGUoaW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgIC8vIDEpIFdlIHdhbnQgdGhlIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZGVjbGFyZWQgYXMgbm9uLW51bGwsIG9yIGVsc2Ugd2VcbiAgICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAgIC8vIDIpIFdlIGRvbid0IHdhbnQgdG8gY2FzdCBcInRoaXNcIiwgYmVjYXVzZSB3ZSB3YW50IHR5cGUtYXdhcmUgb3B0aW1pemF0aW9uc1xuICAgICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl92aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc3RhcnROb2RlKSkge1xuICAgICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyFTaGFkb3dSb290fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgLy8gSW4gSUUxMSwgaWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFuZCB0aGVuIHNldCB0byB0YWJpbmRleD0tMVxuICAgICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ192aXNpdE5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VTdWJ0cmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0U3Vicm9vdC5tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc2F2ZWRJbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgIC8vIE1hbmFnZSBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnaW5lcnQnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ21hbmFnZWROb2RlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRSb290O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgICAqIFRoaXMgbWFrZXMgdGhlIG1hbmFnZWQgbm9kZSBmb2N1c2FibGUgYWdhaW4gYW5kIGRlbGV0ZXMgYWxsIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCBzdGF0ZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbm9kZSAmJiB0aGlzLl9ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5fc2F2ZWRUYWJJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZSBub3RlIGluIEluZXJ0Um9vdC5kZXN0cnVjdG9yIGZvciB3aHkgd2UgY2FzdCB0aGVzZSBudWxscyB0byBBTlkuXG4gICAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9ic29sZXRlIGJlY2F1c2UgdGhlIG1hbmFnZWQgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaHJvdyBpZiB1c2VyIHRyaWVzIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdlbnN1cmVVbnRhYmJhYmxlJyxcblxuXG4gICAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMubm9kZTtcbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIElmIHRoZSBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydCxcbiAgICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHshTm9kZX0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdub2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE5vZGU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgICAqXG4gICAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE1hbmFnZXIoZG9jdW1lbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDsgSW5lcnRNYW5hZ2VyIG5lZWRzIHRvIHdyYXAgYSBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Tm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl93YXRjaEZvckluZXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBiZSBsb2FkZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0TWFuYWdlciwgW3tcbiAgICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgICBpZiAoaW5lcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCdpbmVydCcsICcnKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgICAvLyBFbnN1cmUgaW5lcnQgc3R5bGVzIGFyZSBhZGRlZCB0aGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydFJvb3R8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIG5vZGUgaGFzIGEgcHJldmlvdXNseSBleGlzdGluZyBpbmVydCByb290LCB0aGlzIGluZXJ0IHJvb3Qgd2lsbFxuICAgICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgICAgaW5lcnROb2RlLmFkZEluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbmVydCByb290IGZyb20gdGhlIEluZXJ0Tm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cywgYW5kIHJlbW92ZSB0aGUgaW5lcnRcbiAgICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gZG9jdW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbkRvY3VtZW50TG9hZGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6XG4gICAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsICdbaW5lcnRdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lICE9PSAnaW5lcnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHs/U2hhZG93Um9vdD19IHNoYWRvd1Jvb3RBbmNlc3RvciBUaGUgbmVhcmVzdCBTaGFkb3dSb290IGFuY2VzdG9yLCBpZiBhbnkuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgICB2YXIgc2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSAvKiogQHR5cGUgeyFIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Rpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBuZWl0aGVyIHRoZSBwYXJlbnQgb2YgYSBTaGFkb3dSb290LCBhIDxjb250ZW50PiBlbGVtZW50LCBhIDxzbG90PlxuICAgICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0eWxlIGVsZW1lbnQgdG8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgaW5lcnQgc3BlY2lmaWMgc3R5bGVzXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEluZXJ0U3R5bGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAnXFxuJyArICdbaW5lcnRdIHtcXG4nICsgJyAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuJyArICcgIGN1cnNvcjogZGVmYXVsdDtcXG4nICsgJ31cXG4nICsgJ1xcbicgKyAnW2luZXJ0XSwgW2luZXJ0XSAqIHtcXG4nICsgJyAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICB1c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJ31cXG4nO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFIVE1MRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2luZXJ0JykpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2luZXJ0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pKCk7XG5cbn0pKSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJpbXBvcnQgXCJ3aWNnLWluZXJ0XCI7XG5pbXBvcnQgXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyB9IGZyb20gXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG5mdW5jdGlvbiBibG9ja2luZ0VsZW1lbnRzKCkgeyByZXR1cm4gKGdldERvY3VtZW50KCkgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgfVxuLyoqXG4gKiBBbGxvd3MgYW4gZWxlbWVudCB0byB0cmFwIGZvY3VzIGJ5IGFwcGx5aW5nIHRoZSBcImluZXJ0XCIgYXR0cmlidXRlIHRvIGFsbCBzaWJsaW5nLCBhdW50LCBhbmQgdW5jbGUgbm9kZXMuXG4gKiBcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBjb25zZWN1dGl2ZSBjYWxscyB3aXRoIGEgbG9vc2VseSBhcHBsaWVkIHN0YWNrIG9wZXJhdGlvbiBcbiAqIChzcGVjaWZpY2FsbHkgdmlhIGBibG9ja2luZ0VsZW1lbnRzYCwgd2l0aCBhIHNtYWxsIHBvbHlmaWxsIGJlY2F1c2UgSSdtIG5vdCBzdXJlIGhvdyBsb25nXG4gKiBpdCdsbCB0YWtlIHRvIGZpbmQgaXRzIHdheSBpbnRvIHRoZSBzcGVjLCBpZiBldmVyKVxuICogQHBhcmFtIHRhcmdldCBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2NraW5nRWxlbWVudDxFIGV4dGVuZHMgRWxlbWVudD4oZW5hYmxlZDogYm9vbGVhbiwgZ2V0VGFyZ2V0OiAoKSA9PiAoRSB8IG51bGwpKSB7XG5cbiAgICBjb25zdCBzdGFibGVHZXRUYXJnZXQgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRUYXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogUHVzaC9wb3AgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmdFbGVtZW50cyBzdGFjay5cbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBzdGFibGVHZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIGJsb2NraW5nRWxlbWVudHMgd2lsbCBmYWlsIGlmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgZWxlbWVudCBpc24ndCBjb25uZWN0ZWQgdG8gZG9jdW1lbnQuYm9keS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmFyZSwgYnV0IGl0J3MgYmV0dGVyIHRvIGZhaWwgc2lsZW50bHkgd2l0aCB3ZWlyZCB0YWJiaW5nIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyB0aGFuIHRvIGNyYXNoIHRoZSBlbnRpcmUgYXBwbGljYXRpb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5wdXNoKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucmVtb3ZlKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gV2VsbCwgc2VtaS1zaWxlbnRseS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtlbmFibGVkXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BFbGVtZW50KCkge1xuICAgIHJldHVybiBibG9ja2luZ0VsZW1lbnRzKCkudG9wO1xufVxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IGlzRm9jdXNhYmxlIH0gZnJvbSBcInRhYmJhYmxlXCI7XHJcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgZ2V0VG9wRWxlbWVudCwgdXNlQmxvY2tpbmdFbGVtZW50IH0gZnJvbSBcIi4vdXNlLWJsb2NraW5nLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzIHsgdHJhcEFjdGl2ZTogYm9vbGVhbjsgfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+IHtcclxuICAgIC8qKiAqVW5zdGFibGUqIChyZWxpZXMgb24gdGhlIGB0cmFwQWN0aXZlYCBwcm9wKSAqL1xyXG4gICAgdXNlRm9jdXNUcmFwUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xyXG59XHJcblxyXG5jb25zdCBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8gPSBuZXcgTWFwPEVsZW1lbnQgfCBudWxsLCAoTm9kZSAmIEhUTUxPclNWR0VsZW1lbnQpPigpO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZvY3VzVHJhcDxFIGV4dGVuZHMgSFRNTEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZSB9OiBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzKTogVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFPiB7XHJcbiAgICBcclxuICAgIGNvbnN0IGhhbmRsZUFjdGl2ZUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFwQWN0aXZlOiBib29sZWFuLCBlbGVtZW50OiBFIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBleHRyYSBxdWV1ZU1pY3JvdGFzayBpcyBuZWVkZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyAuLi5yZWFzb25zP1xyXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgfSlcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZkhhbmRsZSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGVsZW1lbnQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIHRoYXQgaGFzIHJldHVybmVkIHRvIHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGxldCByYWZIYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5nZXQoZ2V0VG9wRWxlbWVudCgpKT8uZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICByYWZIYW5kbGUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyYWZIYW5kbGUpXHJcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmFmSGFuZGxlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIHVzZUFjdGl2ZUVsZW1lbnRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudDxFPih7IG9uTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCkgPT4gaGFuZGxlQWN0aXZlQ2hhbmdlKHRyYXBBY3RpdmUsIGVsZW1lbnQpKSB9KTtcclxuXHJcblxyXG4gICAgLy8gV2hlbiB0aGUgdHJhcCBiZWNvbWVzIGFjdGl2ZSwgYmVmb3JlIHdlIGxldCB0aGUgYmxvY2tpbmdFbGVtZW50cyBob29rIHJ1bixcclxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hhdGV2ZXIncyBjdXJyZW50bHkgZm9jdXNlZCBhbmQgc2F2ZSBpdC5cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICBpZiAodHJhcEFjdGl2ZSAmJiBlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XHJcblxyXG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50XHJcbiAgICAgICAgICAgIC8vIHRvIHdoYXRldmVyJ3MgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXHJcbiAgICAgICAgICAgIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUby5zZXQoZ2V0VG9wRWxlbWVudCgpLCAoZ2V0TGFzdEFjdGl2ZUVsZW1lbnQoKSBhcyAoTm9kZSAmIEhUTUxPclNWR0VsZW1lbnQpKSA/PyBkb2N1bWVudC5ib2R5KTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xyXG5cclxuICAgIHVzZUJsb2NraW5nRWxlbWVudCh0cmFwQWN0aXZlLCBnZXRFbGVtZW50KTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFueSB0aW1lIHdlIGFjdGl2YXRlIG9yIGRlYWN0aXZhdGUgdGhlIHRyYXAsXHJcbiAgICAgKiBjaGFuZ2UgZm9jdXMgdG8gc29tZXRoaW5nIGVsc2UgKHNvbWV0aGluZyBpblxyXG4gICAgICogdGhlIHRyYXAgaWYgaXQncyBhY3RpdmUsIG9yIHdoYXRldmVyIHdlJ3ZlXHJcbiAgICAgKiB0cmFja2VkIGluIGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUbyBpZiBub3QpXHJcbiAgICAgKi9cclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaGFuZGxlQWN0aXZlQ2hhbmdlKHRyYXBBY3RpdmUsIGdldEVsZW1lbnQoKSk7XHJcbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xyXG5cclxuICAgIGNvbnN0IHVzZUZvY3VzVHJhcFByb3BzID0gKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IHtcclxuICAgICAgICBjb25zdCBwMSA9IHVzZUFjdGl2ZUVsZW1lbnRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgY29uc3QgcDIgPSB7IFwiYXJpYS1tb2RhbFwiOiB0cmFwQWN0aXZlID8gXCJ0cnVlXCIgOiB1bmRlZmluZWQgfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4ocDEsIHAyKTtcclxuICAgIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUZvY3VzVHJhcFByb3BzLFxyXG4gICAgICAgIGdldEVsZW1lbnRcclxuICAgIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBjb250YWluZWQgd2l0aGluIHRoZSBnaXZlbiBub2RlLCBvciBudWxsIGlmIG5vbmUgYXJlIGZvdW5kLlxyXG4gKiBAcGFyYW0gZWxlbWVudCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQ6IE5vZGUpIHtcclxuICAgIGNvbnN0IHRyZWVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGVsZW1lbnQsIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULCB7IGFjY2VwdE5vZGU6IChub2RlKSA9PiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgaXNGb2N1c2FibGUobm9kZSkgPyBOb2RlRmlsdGVyLkZJTFRFUl9BQ0NFUFQgOiBOb2RlRmlsdGVyLkZJTFRFUl9TS0lQKSB9KVxyXG4gICAgY29uc3QgZmlyc3RGb2N1c2FibGUgPSB0cmVlV2Fsa2VyLmZpcnN0Q2hpbGQoKSBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpIHwgbnVsbDtcclxuICAgIHJldHVybiBmaXJzdEZvY3VzYWJsZTtcclxufVxyXG5cclxuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsLCB3aGVuIGNhbGxlZCwgZm9yY2UgdGhlIGNvbXBvbmVudFxuICogdGhhdCB1c2VzIHRoaXMgaG9vayB0byByZS1yZW5kZXIgaXRzZWxmLlxuICogXG4gKiBJdCdzIGEgYml0IHNtZWxseSwgc28gYmVzdCB0byB1c2Ugc3BhcmluZ2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgWywgc2V0XSA9IHVzZVN0YXRlKDApO1xuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcbn0iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQsIFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzLCBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1hY3RpdmUtZWxlbWVudFwiO1xyXG5pbXBvcnQgeyByZXR1cm5GYWxzZSwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGl0c2VsZiBjdXJyZW50bHkgaGFzIGZvY3VzLlxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIExpa2UgYGZvY3VzZWRgLCBidXQgYWxzbyAqYWRkaXRpb25hbGx5KiBpZiBhbnkgY2hpbGQgZWxlbWVudHMgYXJlIGZvY3VzZWQuXHJcbiAgICAgKiBcclxuICAgICAqIEBzZWUgc2V0Rm9jdXNlZFxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4pOiB2b2lkO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogU2ltaWxhciB0byBgc2V0Rm9jdXNlZGAsIGJ1dCBpZiB0aGVyZSBpcyBubyBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50LCBpcyBgdHJ1ZWAgaWYgdGhpcyBlbGVtZW50IHRoYXQgKmRpZCogaGF2ZSBmb2N1cyBsYXN0LlxyXG4gICAgICogXHJcbiAgICAgKiBUaGlzIGlzIGFsd2F5cyBgdHJ1ZWAgd2hpbGUgYGZvY3VzZWRgIGlzIGB0cnVlYC4gSWYgYGZvY3VzZWRgIGlzIGBmYWxzZWAsIHRoaXMgbWF5IGJlIGB0cnVlYCBvciBgZmFsc2VgLlxyXG4gICAgICovXHJcbiAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZD8oZm9jdXNlZDogYm9vbGVhbik6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21iaW5lcyB0aGUgaW1wbGljYXRpb25zIG9mIGBzZXRMYXN0Rm9jdXNlZGAgYW5kIGBzZXRGb2N1c2VkSW5uZXJgLlxyXG4gICAgICovXHJcbiAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1JldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJ1c2VSZWZFbGVtZW50UHJvcHNcIj4sIE9taXQ8VXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGU8VD4sIFwidXNlQWN0aXZlRWxlbWVudFByb3BzXCI+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBlbGVtZW50IHRvIGJlIGFibGUgdG8gdHJhY2sgaXRzIG93biBmb2N1cyBzdGF0ZVxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZUhhc0ZvY3VzUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG5cclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzPFQgZXh0ZW5kcyBOb2RlPih7IG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlIH06IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxUPik6IFVzZUhhc0ZvY3VzUmV0dXJuVHlwZTxUPiB7XHJcblxyXG4gICAgdXNlRW5zdXJlU3RhYmlsaXR5KFwidXNlSGFzRm9jdXNcIiwgb25Gb2N1c2VkQ2hhbmdlZCwgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UpO1xyXG5cclxuICAgIGNvbnN0IFtnZXRGb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZElubmVyLCBzZXRGb2N1c2VkSW5uZXJdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldExhc3RGb2N1c2VkLCBzZXRMYXN0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZENoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZElubmVyLCBzZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCwgdXNlQWN0aXZlRWxlbWVudFByb3BzLCBnZXRFbGVtZW50IH0gPSB1c2VBY3RpdmVFbGVtZW50PFQ+KHtcclxuICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE5vbk51bGxhYmxlPFVzZUFjdGl2ZUVsZW1lbnRQYXJhbWV0ZXJzPFQ+W1wib25BY3RpdmVFbGVtZW50Q2hhbmdlXCJdPj4oKGFjdGl2ZUVsZW1lbnQsIHByZXZBY3RpdmVFbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlbGZFbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkID0gKHNlbGZFbGVtZW50ICE9IG51bGwgJiYgKHNlbGZFbGVtZW50ID09IGFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZElubmVyID0gKCEhc2VsZkVsZW1lbnQ/LmNvbnRhaW5zKGFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZChmb2N1c2VkKTtcclxuICAgICAgICAgICAgc2V0Rm9jdXNlZElubmVyKGZvY3VzZWRJbm5lcik7XHJcbiAgICAgICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT8uKGFjdGl2ZUVsZW1lbnQsIHByZXZBY3RpdmVFbGVtZW50KTtcclxuICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnM8VD5bXCJvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlXCJdPj4oKGxhc3RBY3RpdmVFbGVtZW50LCBwcmV2TGFzdEFjdGl2ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZkVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gbGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZElubmVyID0gKCEhc2VsZkVsZW1lbnQ/LmNvbnRhaW5zKGxhc3RBY3RpdmVFbGVtZW50IGFzIE5vZGUgfCBudWxsKSk7XHJcbiAgICAgICAgICAgIHNldExhc3RGb2N1c2VkKGZvY3VzZWQpO1xyXG4gICAgICAgICAgICBzZXRMYXN0Rm9jdXNlZElubmVyKGZvY3VzZWRJbm5lcik7XHJcbiAgICAgICAgICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/LihsYXN0QWN0aXZlRWxlbWVudCwgcHJldkxhc3RBY3RpdmVFbGVtZW50KTtcclxuICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgb25XaW5kb3dGb2N1c2VkQ2hhbmdlXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VIYXNGb2N1c1Byb3BzID0gdXNlQ2FsbGJhY2soKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxUPikgPT4geyByZXR1cm4gdXNlQWN0aXZlRWxlbWVudFByb3BzKHByb3BzKTsgfSwgW10pO1xyXG5cclxuXHJcbiAgICByZXR1cm4geyBcclxuICAgICAgICB1c2VIYXNGb2N1c1Byb3BzLCBcclxuICAgICAgICBnZXRFbGVtZW50LCBcclxuICAgICAgICBnZXRGb2N1c2VkLCBcclxuICAgICAgICBnZXRGb2N1c2VkSW5uZXIsIFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkLCBcclxuICAgICAgICBnZXRMYXN0Rm9jdXNlZElubmVyLCBcclxuICAgICAgICBnZXRBY3RpdmVFbGVtZW50LCBcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudCwgXHJcbiAgICAgICAgZ2V0V2luZG93Rm9jdXNlZCBcclxuICAgIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRTaXplLCB1c2VFbGVtZW50U2l6ZSB9IGZyb20gXCIuL3VzZS1lbGVtZW50LXNpemVcIjtcclxuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50IH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcblxyXG4vL2V4cG9ydCB0eXBlIEJsb2NrRmxvd0RpcmVjdGlvbiA9IFwiZG93bndhcmRzXCIgfCBcImxlZnR3YXJkc1wiIHwgXCJyaWdodHdhcmRzXCI7XHJcbmV4cG9ydCB0eXBlIFBoeXNpY2FsRGlyZWN0aW9uID0gXCJsdHJcIiB8IFwicnRsXCIgfCBcInR0YlwiIHwgXCJidHRcIjtcclxuZXhwb3J0IHR5cGUgUGh5c2ljYWxPcmllbnRhdGlvbiA9IFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiO1xyXG5leHBvcnQgdHlwZSBQaHlzaWNhbFNpemUgPSBcIndpZHRoXCIgfCBcImhlaWdodFwiO1xyXG5cclxuZXhwb3J0IHR5cGUgTG9naWNhbE9yaWVudGF0aW9uID0gXCJpbmxpbmVcIiB8IFwiYmxvY2tcIjtcclxuXHJcbi8vZXhwb3J0IHR5cGUgTGluZU9yaWVudGF0aW9uID0gXCJ1cHJpZ2h0XCIgfCBcImxlZnRyaWdodFwiIHwgXCJkb3ducmlnaHRcIiB8IFwicmlnaHRyaWdodFwiO1xyXG5cclxudHlwZSBXcml0aW5nTW9kZSA9IFwiaG9yaXpvbnRhbC10YlwiIHwgXCJ2ZXJ0aWNhbC1sclwiIHwgXCJzaWRld2F5cy1ybFwiIHwgXCJ2ZXJ0aWNhbC1ybFwiIHwgXCJzaWRld2F5cy1sclwiO1xyXG50eXBlIERpcmVjdGlvbiA9IFwibHRyXCIgfCBcInJ0bFwiO1xyXG50eXBlIFRleHRPcmllbnRhdGlvbiA9IFwibWl4ZWRcIiB8IFwidXByaWdodFwiIHwgXCJzaWRld2F5c1wiO1xyXG5cclxuZnVuY3Rpb24gY2FwaXRhbGl6ZTxUIGV4dGVuZHMgc3RyaW5nPihzdHI6IFQpOiBDYXBpdGFsaXplPFQ+IHtcclxuICAgIHJldHVybiAoc3RyWzBdLnRvVXBwZXJDYXNlKCkgKyBzdHIuc3Vic3RyaW5nKDEpKSBhcyBDYXBpdGFsaXplPFQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxvZ2ljYWxEaXJlY3Rpb25QYXJhbWV0ZXJzIHtcclxuICAgIG9uTG9naWNhbERpcmVjdGlvbkNoYW5nZT8oaW5mbzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBMb2dpY2FsRWxlbWVudFNpemUge1xyXG4gICAgY2xpZW50SW5saW5lU2l6ZTogbnVtYmVyO1xyXG4gICAgc2Nyb2xsSW5saW5lU2l6ZTogbnVtYmVyO1xyXG4gICAgb2Zmc2V0SW5saW5lU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50QmxvY2tTaXplOiBudW1iZXI7XHJcbiAgICBzY3JvbGxCbG9ja1NpemU6IG51bWJlcjtcclxuICAgIG9mZnNldEJsb2NrU2l6ZTogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50SW5saW5lSW5zZXQ6IG51bWJlcjtcclxuICAgIHNjcm9sbElubGluZUluc2V0OiBudW1iZXI7XHJcbiAgICBvZmZzZXRJbmxpbmVJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG4gICAgY2xpZW50QmxvY2tJbnNldDogbnVtYmVyO1xyXG4gICAgc2Nyb2xsQmxvY2tJbnNldDogbnVtYmVyO1xyXG4gICAgb2Zmc2V0QmxvY2tJbnNldDogbnVtYmVyIHwgdW5kZWZpbmVkO1xyXG59XHJcblxyXG4vKipcclxuICogSW5zcGVjdHMgdGhlIGVsZW1lbnQncyBzdHlsZSBhbmQgZGV0ZXJtaW5lcyB0aGUgbG9naWNhbCBkaXJlY3Rpb24gdGhhdCB0ZXh0IGZsb3dzLlxyXG4gKiBcclxuICogQ2VydGFpbiBDU1MgcHJvcGVydGllcywgbGlrZSBgYmxvY2stc2l6ZWAsIHJlc3BlY3QgdGhlIGN1cnJlbnQgd3JpdGluZyBtb2RlIGFuZCB0ZXh0IGRpcmVjdGlvbi5cclxuICogQnV0IGB0cmFuc2Zvcm1gLCBgY2xpcGAsIGV0Yy4gZG9uJ3QuXHJcbiAqIFxyXG4gKiBUaGlzIGlzIHByb3ZpZGVkIHNvIHRoYXQgQ1NTIHByb3BlcnRpZXMgY2FuIGNvbnNpc3RlbnRseSB1c2UgdGhvc2UgbG9naWNhbCBwcm9wZXJ0aWVzLlxyXG4gKiBcclxuICogU2VlIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtd3JpdGluZy1tb2Rlcy8jbG9naWNhbC10by1waHlzaWNhbFxyXG4gKiBcclxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XHJcbiAqICogYGdldExvZ2ljYWxEaXJlY3Rpb25gOiByZXRyaWV2ZXMgYSBgTG9naWNhbERpcmVjdGlvbkluZm9gIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgZWxlbWVudC4gKEZ1bmN0aW9uIGlzIGNvbnN0YW50IGJldHdlZW4gcmVuZGVycylcclxuICogKiBgY29udmVydEVsZW1lbnRTaXplYDogV2hlbiB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUVsZW1lbnRTaXplYCwgYWxsb3dzIHlvdSB0byByZXRyaWV2ZSB0aGUgbG9naWNhbCBzaXplIG9mIGFuIGVsZW1lbnQgaW5zdGVhZCBvZiB0aGUgcGh5c2ljYWwgc2l6ZS4gXHJcbiAqICogYGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbmA6IEJhc2VkIG9uIHRoZSBjdXJyZW50IGRpcmVjdGlvbiwgY29udmVydHMgXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiIHRvIFwiaW5saW5lXCIgb3IgXCJibG9ja1wiLlxyXG4gKiAqIGBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uYDogIEJhc2VkIG9uIHRoZSBjdXJyZW50IGRpcmVjdGlvbiwgY29udmVydHMgXCJpbmxpbmVcIiBvciBcImJsb2NrXCIgdG8gXCJob3Jpem9udGFsXCIgb3IgXCJ2ZXJ0aWNhbFwiLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvZ2ljYWxEaXJlY3Rpb248VCBleHRlbmRzIEVsZW1lbnQ+KHsgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlIH06IFVzZUxvZ2ljYWxEaXJlY3Rpb25QYXJhbWV0ZXJzKTogVXNlTG9naWNhbERpcmVjdGlvblJldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxvZ2ljYWxEaXJlY3Rpb25cIiwgb25Mb2dpY2FsRGlyZWN0aW9uQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Q29tcHV0ZWRTdHlsZXMsIHNldENvbXB1dGVkU3R5bGVzXSA9IHVzZVBhc3NpdmVTdGF0ZTxDU1NTdHlsZURlY2xhcmF0aW9uIHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XHJcblxyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgdXNlUmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHtcclxuICAgICAgICBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlbGVtZW50OiBUIHwgbnVsbCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgc2V0Q29tcHV0ZWRTdHlsZXMod2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW10pXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBUT0RPOiBUaGVyZSdzIG5vIHdheSB0byByZWZyZXNoIHdoaWNoIHdyaXRpbmcgbW9kZSB3ZSBoYXZlIG9uY2UgbW91bnRlZC5cclxuICAgIC8vICAgQS4gVGhlcmUncyBubyB3YXkgdG8gd2F0Y2ggZm9yIENTUyBzdHlsZSBjaGFuZ2VzXHJcbiAgICAvLyAgIEIuIENhbGxpbmcgZ2V0Q29tcHV0ZWRTdHlsZSBhZnRlciBldmVyeSByZW5kZXIgZm9yIGV2ZXJ5IGVsZW1lbnQgZ2V0cyBleHBlbnNpdmUgZmFzdCBhbmRcclxuICAgIC8vICAgQy4gSXMgbm90IG5lY2Vzc2FyeSBmb3IgbW9zdCB1c2UgY2FzZXMgdGhhdCB3aWxsIG5ldmVyIHN3aXRjaCB3cml0aW5nLW1vZGUgd2l0aGluIGEgc2luZ2xlIGNvbXBvbmVudFxyXG4gICAgLy8gICAgICAoVGhvc2UgdGhhdCBkbyB3aWxsIG5lZWQgdG8gbW91bnQgYW5kIHVubW91bnQgdGhlIGNvbXBvbmVudCB0aGF0IHVzZXMgaXQpXHJcbiAgICAvL1xyXG4gICAgLy8gQXMgYSBzb2x1dGlvbiwgaGVyZSdzIGEgY2hlYXAgd29ya2Fyb3VuZCB0aGF0IGNoZWNrcyB3aGVuIHRoZSBlbGVtZW50J3Mgc2l6ZSBoYXMgY2hhbmdlZCxcclxuICAgIC8vIGFuZCBpZiBzbywgdGVzdHMgaWYgdGhlIHdyaXRpbmcgbW9kZSBoYXMgY2hhbmdlZCB0b28uXHJcbiAgICAvL1xyXG4gICAgLy8gVGhpcyB3aWxsIHdvcmsgZm9yIGF0IGxlYXN0IHNvbWUgbnVtYmVyIG9mIGNhc2VzLCBidXQgYSBiZXR0ZXIgc29sdXRpb24gaXMgc3RpbGwgbmVlZGVkLlxyXG4gICAgY29uc3QgeyB1c2VFbGVtZW50U2l6ZVByb3BzIH0gPSB1c2VFbGVtZW50U2l6ZTxUPih7IG9uU2l6ZUNoYW5nZTogdXNlQ2FsbGJhY2soXyA9PiBvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2U/LihnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpKSwgW10pIH0pXHJcblxyXG4gICAgY29uc3QgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8gPSB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29tcHV0ZWRTdHlsZXMgPSBnZXRDb21wdXRlZFN0eWxlcygpO1xyXG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlcykge1xyXG4gICAgICAgICAgICBjb25zdCB3ID0gY29tcHV0ZWRTdHlsZXMud3JpdGluZ01vZGUgYXMgV3JpdGluZ01vZGU7XHJcbiAgICAgICAgICAgIGxldCBkID0gY29tcHV0ZWRTdHlsZXMuZGlyZWN0aW9uIGFzIERpcmVjdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgdCA9IGNvbXB1dGVkU3R5bGVzLnRleHRPcmllbnRhdGlvbiBhcyBUZXh0T3JpZW50YXRpb247XHJcblxyXG4gICAgICAgICAgICBpZiAodCA9PSBcInVwcmlnaHRcIilcclxuICAgICAgICAgICAgICAgIGQgPSBcImx0clwiO1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuICh7IC4uLldyaXRpbmdNb2Rlc1t3IHx8IFwiaG9yaXpvbnRhbC10YlwiXVtkIHx8IFwibHRyXCJdIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9LCBbXSlcclxuXHJcbiAgICAvL2NvbnN0IFtnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbywgc2V0TG9naWNhbERpcmVjdGlvbkluZm9dID0gdXNlUGFzc2l2ZVN0YXRlPExvZ2ljYWxEaXJlY3Rpb25JbmZvPihvbkxvZ2ljYWxEaXJlY3Rpb25DaGFuZ2UpO1xyXG5cclxuICAgIGNvbnN0IGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IFBoeXNpY2FsT3JpZW50YXRpb24sIGRpcmVjdGlvbj86IExvZ2ljYWxEaXJlY3Rpb25JbmZvIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGRpcmVjdGlvbiA/Pz0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gZWxlbWVudE9yaWVudGF0aW9uKVxyXG4gICAgICAgICAgICByZXR1cm4gXCJpbmxpbmVcIjtcclxuICAgICAgICByZXR1cm4gXCJibG9ja1wiO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IGNvbnZlcnRUb1BoeXNpY2FsU2lkZSA9IHVzZUNhbGxiYWNrKChzaWRlOiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiLCBkaXJlY3Rpb24/OiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGwgfCB1bmRlZmluZWQpOiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiID0+IHtcclxuICAgICAgICBkaXJlY3Rpb24gPz89IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvKCk7XHJcblxyXG4gICAgICAgIHN3aXRjaCAoc2lkZSkge1xyXG4gICAgICAgICAgICBjYXNlIFwiYmxvY2stc3RhcnRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmJsb2NrRGlyZWN0aW9uID8/IFwidHRiXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcclxuICAgICAgICAgICAgY2FzZSBcImJsb2NrLWVuZFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uYmxvY2tEaXJlY3Rpb24gPz8gXCJ0dGJcIilbMl0gYXMgXCJ0XCIgfCBcImJcIiB8IFwibFwiIHwgXCJyXCJdO1xyXG5cclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1zdGFydFwiOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1bKGRpcmVjdGlvbj8uaW5saW5lRGlyZWN0aW9uID8/IFwibHRyXCIpWzBdIGFzIFwidFwiIHwgXCJiXCIgfCBcImxcIiB8IFwiclwiXTtcclxuICAgICAgICAgICAgY2FzZSBcImlubGluZS1lbmRcIjpcclxuICAgICAgICAgICAgICAgIHJldHVybiBNWyhkaXJlY3Rpb24/LmlubGluZURpcmVjdGlvbiA/PyBcImx0clwiKVsyXSBhcyBcInRcIiB8IFwiYlwiIHwgXCJsXCIgfCBcInJcIl07XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3QgY29udmVydFRvTG9naWNhbFNpZGUgPSB1c2VDYWxsYmFjaygoc2lkZTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiA9PiB7XHJcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24/LmlubGluZU9yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChzaWRlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9wXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwidHRiXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwiYnR0XCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSBcImxlZnRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmJsb2NrRGlyZWN0aW9uID09PSBcImx0clwiID8gXCJibG9jay1zdGFydFwiIDogXCJibG9jay1lbmRcIjtcclxuICAgICAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwicnRsXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbj8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcInRvcFwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwidHRiXCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBcImJvdHRvbVwiOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkaXJlY3Rpb24uYmxvY2tEaXJlY3Rpb24gPT09IFwiYnR0XCIgPyBcImJsb2NrLXN0YXJ0XCIgOiBcImJsb2NrLWVuZFwiO1xyXG5cclxuICAgICAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRpcmVjdGlvbi5pbmxpbmVEaXJlY3Rpb24gPT09IFwibHRyXCIgPyBcImlubGluZS1zdGFydFwiIDogXCJpbmxpbmUtZW5kXCI7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uLmlubGluZURpcmVjdGlvbiA9PT0gXCJydGxcIiA/IFwiaW5saW5lLXN0YXJ0XCIgOiBcImlubGluZS1lbmRcIjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cclxuICAgICAgICBkZWJ1Z2dlcjtcclxuICAgICAgICBjb25zb2xlLmFzc2VydChmYWxzZSk7XHJcbiAgICAgICAgcmV0dXJuIFwiaW5saW5lLXN0YXJ0XCI7XHJcblxyXG4gICAgfSwgW10pXHJcblxyXG4gICAgY29uc3QgY29udmVydFRvUGh5c2ljYWxPcmllbnRhdGlvbiA9IHVzZUNhbGxiYWNrKChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG4gICAgICAgIGlmIChlbGVtZW50T3JpZW50YXRpb24gPT0gXCJpbmxpbmVcIikge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uPy5pbmxpbmVPcmllbnRhdGlvbiA9PSBcImhvcml6b250YWxcIilcclxuICAgICAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcclxuICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24/LmJsb2NrT3JpZW50YXRpb24gPT0gXCJ2ZXJ0aWNhbFwiKVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwidmVydGljYWxcIjtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiBcImhvcml6b250YWxcIjtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgY29uc3QgY29udmVydEVsZW1lbnRTaXplID0gdXNlQ2FsbGJhY2soKGVsZW1lbnRTaXplOiBFbGVtZW50U2l6ZSwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKTogTG9naWNhbEVsZW1lbnRTaXplIHwgbnVsbCA9PiB7XHJcbiAgICAgICAgZGlyZWN0aW9uID8/PSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24pIHtcclxuICAgICAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUsIGlubGluZURpcmVjdGlvbiwgYmxvY2tEaXJlY3Rpb24gfSA9IGRpcmVjdGlvbjtcclxuXHJcbiAgICAgICAgICAgIC8vIFNpemUgaXMgcmVsYXRpdmVseSBzaW1wbGVcclxuICAgICAgICAgICAgY29uc3QgY2xpZW50SW5saW5lU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoaW5saW5lU2l6ZSl9YF07XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudEJsb2NrU2l6ZSA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoYmxvY2tTaXplKX1gXTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZVNpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGlubGluZVNpemUpfWBdO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRCbG9ja1NpemUgPSBlbGVtZW50U2l6ZVtgb2Zmc2V0JHtjYXBpdGFsaXplKGJsb2NrU2l6ZSl9YF07XHJcblxyXG4gICAgICAgICAgICBjb25zdCBzY3JvbGxJbmxpbmVTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShpbmxpbmVTaXplKX1gXTtcclxuICAgICAgICAgICAgY29uc3Qgc2Nyb2xsQmxvY2tTaXplID0gZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShibG9ja1NpemUpfWBdO1xyXG5cclxuXHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgZjEgPSBnZXRQaHlzaWNhbExlZnRUb3AoaW5saW5lRGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgY29uc3QgZjIgPSBnZXRQaHlzaWNhbFJpZ2h0Qm90dG9tKGlubGluZURpcmVjdGlvbik7XHJcblxyXG4gICAgICAgICAgICBjb25zdCBmMyA9IGdldFBoeXNpY2FsTGVmdFRvcChibG9ja0RpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGNvbnN0IGY0ID0gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShibG9ja0RpcmVjdGlvbik7XHJcblxyXG5cclxuICAgICAgICAgICBjb25zdCBjbGllbnRJbmxpbmVJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjEpfWBdICsgKCFmMiA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGYyKX1gXSk7XHJcbiAgICAgICAgICAgY29uc3Qgc2Nyb2xsSW5saW5lSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYxKX1gXSArICghZjIgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmMil9YF0pO1xyXG4gICAgICAgICAgIGNvbnN0IG9mZnNldElubGluZUluc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMSl9YF0gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjEpfWBdISArICghZjIgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMil9YF0hKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3QgY2xpZW50QmxvY2tJbnNldCA9IGVsZW1lbnRTaXplW2BjbGllbnQke2NhcGl0YWxpemUoZjMpfWBdICsgKCFmNCA/IDAgOiBlbGVtZW50U2l6ZVtgY2xpZW50JHtjYXBpdGFsaXplKGY0KX1gXSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcm9sbEJsb2NrSW5zZXQgPSBlbGVtZW50U2l6ZVtgc2Nyb2xsJHtjYXBpdGFsaXplKGYzKX1gXSArICghZjQgPyAwIDogZWxlbWVudFNpemVbYHNjcm9sbCR7Y2FwaXRhbGl6ZShmNCl9YF0pO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRCbG9ja0luc2V0ID0gZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmMyl9YF0gPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogKGVsZW1lbnRTaXplW2BvZmZzZXQke2NhcGl0YWxpemUoZjMpfWBdISArICghZjQgPyAwIDogZWxlbWVudFNpemVbYG9mZnNldCR7Y2FwaXRhbGl6ZShmNCl9YF0hKSk7XHJcblxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZVNpemUsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxJbmxpbmVTaXplLFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0SW5saW5lU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIHNjcm9sbEJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIG9mZnNldEJsb2NrU2l6ZSxcclxuICAgICAgICAgICAgICAgIGNsaWVudElubGluZUluc2V0LFxyXG4gICAgICAgICAgICAgICAgc2Nyb2xsSW5saW5lSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBvZmZzZXRJbmxpbmVJbnNldCxcclxuICAgICAgICAgICAgICAgIGNsaWVudEJsb2NrSW5zZXQsXHJcbiAgICAgICAgICAgICAgICBzY3JvbGxCbG9ja0luc2V0LFxyXG4gICAgICAgICAgICAgICAgb2Zmc2V0QmxvY2tJbnNldCxcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgdXNlTG9naWNhbERpcmVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+KSA9PiB1c2VSZWZFbGVtZW50UHJvcHModXNlRWxlbWVudFNpemVQcm9wcyhwcm9wcykpLCBbXSksXHJcbiAgICAgICAgZ2V0RWxlbWVudCxcclxuICAgICAgICBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbyxcclxuICAgICAgICBjb252ZXJ0VG9Mb2dpY2FsU2l6ZTogY29udmVydEVsZW1lbnRTaXplLFxyXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbixcclxuICAgICAgICBjb252ZXJ0VG9QaHlzaWNhbE9yaWVudGF0aW9uLFxyXG4gICAgICAgIGNvbnZlcnRUb0xvZ2ljYWxTaWRlLFxyXG4gICAgICAgIGNvbnZlcnRUb1BoeXNpY2FsU2lkZVxyXG4gICAgfTtcclxufVxyXG5cclxuLy8gUG9zaXRpb24gcmVxdWlyZXMgdXMgdG8gc29tZXRpbWVzIHVzZSBvbmUgcHJvcGVydHkgKGxpa2UgYGxlZnRgKVxyXG4vLyBvciBzb21ldGltZXMgdHdvIChsaWtlIGBsZWZ0YCArIGB3aWR0aGApXHJcbmZ1bmN0aW9uIGdldFBoeXNpY2FsTGVmdFRvcChkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwibHRyXCIgfHwgZGlyID09IFwicnRsXCIpIHJldHVybiBcImxlZnRcIjsgcmV0dXJuIFwidG9wXCI7IH1cclxuZnVuY3Rpb24gZ2V0UGh5c2ljYWxSaWdodEJvdHRvbShkaXI6IFBoeXNpY2FsRGlyZWN0aW9uKSB7IGlmIChkaXIgPT09IFwicnRsXCIpIHJldHVybiBcIndpZHRoXCI7IGlmIChkaXIgPT09IFwiYnR0XCIpIHJldHVybiBcImhlaWdodFwiOyByZXR1cm4gbnVsbDsgfVxyXG5cclxuLy8gSGVscGVyIGZvciBleHRyYWN0aW5nIGluZm8gZnJvbSBcImx0clwiLCBcInR0YlwiLCBldGMuXHJcbmNvbnN0IE0gPSB7XHJcbiAgICB0OiBcInRvcFwiLFxyXG4gICAgYjogXCJib3R0b21cIixcclxuICAgIGw6IFwibGVmdFwiLFxyXG4gICAgcjogXCJyaWdodFwiXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMb2dpY2FsRGlyZWN0aW9uUmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldEVsZW1lbnQ6ICgpID0+IFQgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvOiAoKSA9PiBMb2dpY2FsRGlyZWN0aW9uSW5mbyB8IG51bGw7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiB0aGUgRWxlbWVudFNpemUgaW5mbyBmcm9tIHVzZUVsZW1lbnRTaXplLCBjb252ZXJ0cyBhbGwgdGhvc2UgcGh5c2ljYWwgcHJvcGVydGllcyB0byB0aGVpciBsb2dpY2FsIGNvdW50ZXJwYXJ0cy5cclxuICAgICAqIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICovXHJcbiAgICBjb252ZXJ0VG9Mb2dpY2FsU2l6ZTogKGVsZW1lbnRTaXplOiBFbGVtZW50U2l6ZSwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBMb2dpY2FsRWxlbWVudFNpemUgfCBudWxsO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybnMgYFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiYCBpbnRvIGBcImlubGluZVwiIHwgXCJibG9ja1wiYFxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb0xvZ2ljYWxPcmllbnRhdGlvbjogKGVsZW1lbnRPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImlubGluZVwiIHwgXCJibG9ja1wiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybnMgYFwiaW5saW5lXCIgfCBcImJsb2NrXCJgIGludG8gYFwiaG9yaXpvbnRhbFwiIHwgXCJ2ZXJ0aWNhbFwiYFxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb1BoeXNpY2FsT3JpZW50YXRpb246IChlbGVtZW50T3JpZW50YXRpb246IExvZ2ljYWxPcmllbnRhdGlvbiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImhvcml6b250YWxcIiB8IFwidmVydGljYWxcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFR1cm5zIGBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiYCBpbnRvIGBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiIHwgXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiYFxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGNvbnZlcnRUb0xvZ2ljYWxTaWRlOiAoc2lkZTogXCJ0b3BcIiB8IFwiYm90dG9tXCIgfCBcImxlZnRcIiB8IFwicmlnaHRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCIgfCBcImJsb2NrLXN0YXJ0XCIgfCBcImJsb2NrLWVuZFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogVHVybnMgYFwiYmxvY2stc3RhcnRcIiB8IFwiYmxvY2stZW5kXCIgfCBcImlubGluZS1zdGFydFwiIHwgXCJpbmxpbmUtZW5kXCJgIGludG8gYFwidG9wXCIgfCBcImJvdHRvbVwiIHwgXCJsZWZ0XCIgfCBcInJpZ2h0XCJgXHJcbiAgICAgKiBcclxuICAgICAqICoqU1RBQkxFKipcclxuICAgICAqL1xyXG4gICAgY29udmVydFRvUGh5c2ljYWxTaWRlOiAoc2lkZTogXCJpbmxpbmUtc3RhcnRcIiB8IFwiaW5saW5lLWVuZFwiIHwgXCJibG9jay1zdGFydFwiIHwgXCJibG9jay1lbmRcIiwgZGlyZWN0aW9uPzogTG9naWNhbERpcmVjdGlvbkluZm8gfCBudWxsIHwgdW5kZWZpbmVkKSA9PiBcInRvcFwiIHwgXCJib3R0b21cIiB8IFwibGVmdFwiIHwgXCJyaWdodFwiO1xyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgTG9naWNhbERpcmVjdGlvbkluZm8ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXByZXNlbnRzIHRoZSBkaXJlY3Rpb24gdGV4dCBmbG93cywgZ2x5cGggYnkgZ2x5cGguICBCeSBmYXIgdGhlIG1vc3QgY29tcGxleCBwcm9wZXJ0eS5cclxuICAgICAqIFxyXG4gICAgICogfGB3cml0aW5nLW1vZGVgfGBkaXJlY3Rpb25gfFJlc3VsdHxcclxuICAgICAqIHwtLS0tLXwtLS0tLXwtLS0tLXxcclxuICAgICAqIHxgaG9yaXpvbnRhbC10YmB8YGx0cmB8YGx0cmB8XHJcbiAgICAgKiB8YGhvcml6b250YWwtdGJgfGBydGxgfGBydGxgfFxyXG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBsdHJgfGB0dGJgfFxyXG4gICAgICogfGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgfGBydGxgfGBidHRgfFxyXG4gICAgICogfGB2ZXJ0aWNhbC1scmB8YGx0cmB8YHR0YmB8XHJcbiAgICAgKiB8YHZlcnRpY2FsLWxyYHxgcnRsYHxgYnR0YHxcclxuICAgICAqIHxgc2lkZXdheXMtbHJgfGBsdHJgfGBidHRgfFxyXG4gICAgICogfGBzaWRld2F5cy1scmB8YHJ0bGB8YHR0YmB8XHJcbiAgICAgKi9cclxuICAgIGlubGluZURpcmVjdGlvbjogUGh5c2ljYWxEaXJlY3Rpb247XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBTaW1wbGlmaWVkIHZlcnNpb24gb2YgYGlubGluZURpcmVjdGlvbmA6XHJcbiAgICAgKiBcclxuICAgICAqICogYGhvcml6b250YWxgIGZvciBgaG9yaXpvbnRhbC10YmBcclxuICAgICAqICogYHZlcnRpY2FsYCBmb3IgYWxsIG90aGVyc1xyXG4gICAgICovXHJcbiAgICBpbmxpbmVPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgdGhlIGRpcmVjdGlvbiB0ZXh0IGZsb3dzLCBsaW5lIGJ5IGxpbmUuXHJcbiAgICAgKiBcclxuICAgICAqICogYHR0YmAgZm9yIGBob3Jpem9udGFsLXRiYCwgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb25cclxuICAgICAqICogYHJ0bGAgZm9yIGB2ZXJ0aWNhbC1ybGAgJiBgc2lkZXdheXMtcmxgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxyXG4gICAgICogKiBgbHRyYCBmb3IgYHZlcnRpY2FsLWxyYCAmIGBzaWRld2F5cy1scmAsIHJlZ2FyZGxlc3Mgb2YgZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGJsb2NrRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBgYmxvY2tEaXJlY3Rpb25gOlxyXG4gICAgICogXHJcbiAgICAgKiAqIGB2ZXJ0aWNhbGAgZm9yIGBob3Jpem9udGFsLXRiYFxyXG4gICAgICogKiBgaG9yaXpvbnRhbGAgZm9yIGFsbCBvdGhlcnNcclxuICAgICAqL1xyXG4gICAgYmxvY2tPcmllbnRhdGlvbjogUGh5c2ljYWxPcmllbnRhdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlcHJlc2VudHMgaG93IHlvdSBjYW4gKnBoeXNpY2FsbHkqIHJlZmVyIHRvIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IGluIHRoZSAqaW5saW5lKiBzaXplLlxyXG4gICAgICogXHJcbiAgICAgKiAqIGB3aWR0aGAgZm9yIGBob3Jpem9udGFsLXRiYCwgcmVnYXJkbGVzcyBvZiBkaXJlY3Rpb25cclxuICAgICAqICogYGhlaWdodGAgZm9yIGFsbCBvdGhlcnNcclxuICAgICAqL1xyXG4gICAgaW5saW5lU2l6ZTogUGh5c2ljYWxTaXplO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmVwcmVzZW50cyBob3cgeW91IGNhbiAqcGh5c2ljYWxseSogcmVmZXIgdG8gdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgaW4gdGhlICpibG9jayogc2l6ZS5cclxuICAgICAqIFxyXG4gICAgICogKiBgaGVpZ2h0YCBmb3IgYGhvcml6b250YWwtdGJgLCByZWdhcmRsZXNzIG9mIGRpcmVjdGlvblxyXG4gICAgICogKiBgd2lkdGhgIGZvciBhbGwgb3RoZXJzXHJcbiAgICAgKi9cclxuICAgIGJsb2NrU2l6ZTogUGh5c2ljYWxTaXplO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogRm9yIGVhY2ggZ2x5cGgsIGFzY2VuZGVycyB0byBkZXNjZW5kZXJzICpwaHlzaWNhbGx5KiBnbzpcclxuICAgICAqIFxyXG4gICAgICogKiBgdHRiYCBmb3IgYGhvcml6b250YWwtdGJgXHJcbiAgICAgKiAqIGBydGxgIGZvciBgdmVydGljYWwtcmxgLCBgdmVydGljYWwtbHJgLCAmIGBzaWRld2F5cy1ybGBcclxuICAgICAqICogYGx0cmAgZm9yIGBzaWRld2F5cy1scmBcclxuICAgICAqL1xyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBQaHlzaWNhbERpcmVjdGlvbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEZvciBlYWNoIGdseXBoLCBpdHMgXCJsZWZ0XCIgc2lkZSAodGhpbmsgb2YgdGhpcyByZWxhdGl2ZSB0byBgd3JpdGluZy1tb2RlYCBidXQgKm5vdCogcmVsYXRpdmUgdG8gYGRpcmVjdGlvbmAsIG9yIGFsdGVybmF0aXZlbHkgd2hhdCBgdGV4dC1hbGlnbjogbGVmdGAgbWVhbnMpIHRvIGl0cyBcInJpZ2h0XCIgc2lkZSAqcGh5c2ljYWxseSogZ29lcyBmcm9tOlxyXG4gICAgICogXHJcbiAgICAgKiAqIGBsdHJgIGZvciBgaG9yaXpvbnRhbC10YmBcclxuICAgICAqICogYHR0YmAgZm9yIGB2ZXJ0aWNhbC1ybGAsIGB2ZXJ0aWNhbC1scmAsICYgYHNpZGV3YXlzLXJsYFxyXG4gICAgICogKiBgYnR0YCBmb3IgYHNpZGV3YXlzLWxyYFxyXG4gICAgICovXHJcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFBoeXNpY2FsRGlyZWN0aW9uO1xyXG59XHJcblxyXG5jb25zdCBIb3Jpem9udGFsVGJMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgaW5saW5lRGlyZWN0aW9uOiBcImx0clwiLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwidHRiXCIsXHJcblxyXG4gICAgaW5saW5lT3JpZW50YXRpb246IFwiaG9yaXpvbnRhbFwiLFxyXG4gICAgYmxvY2tPcmllbnRhdGlvbjogXCJ2ZXJ0aWNhbFwiLFxyXG5cclxuICAgIGlubGluZVNpemU6IFwid2lkdGhcIixcclxuICAgIGJsb2NrU2l6ZTogXCJoZWlnaHRcIixcclxuXHJcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwibHRyXCIsXHJcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwidHRiXCJcclxufTtcclxuXHJcbmNvbnN0IEhvcml6b250YWxUYlJ0bDogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICAuLi5Ib3Jpem9udGFsVGJMdHIsXHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwicnRsXCIsXHJcbn07XHJcblxyXG5jb25zdCBWZXJ0aWNhbFJsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJ0dGJcIixcclxuICAgIGJsb2NrRGlyZWN0aW9uOiBcInJ0bFwiLFxyXG5cclxuICAgIGlubGluZU9yaWVudGF0aW9uOiBcInZlcnRpY2FsXCIsXHJcbiAgICBibG9ja09yaWVudGF0aW9uOiBcImhvcml6b250YWxcIixcclxuXHJcbiAgICBpbmxpbmVTaXplOiBcImhlaWdodFwiLFxyXG4gICAgYmxvY2tTaXplOiBcIndpZHRoXCIsXHJcblxyXG4gICAgbGVmdFJpZ2h0RGlyZWN0aW9uOiBcInR0YlwiLFxyXG4gICAgb3ZlclVuZGVyRGlyZWN0aW9uOiBcInJ0bFwiXHJcbn07XHJcblxyXG5jb25zdCBWZXJ0aWNhbFJsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIC4uLlZlcnRpY2FsUmxMdHIsXHJcbiAgICBpbmxpbmVEaXJlY3Rpb246IFwiYnR0XCJcclxufTtcclxuXHJcblxyXG5jb25zdCBTaWRld2F5c1JsTHRyOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbEx0ciB9O1xyXG5jb25zdCBTaWRld2F5c1JsUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHsgLi4uVmVydGljYWxSbFJ0bCB9O1xyXG5cclxuY29uc3QgVmVydGljYWxMckx0cjogTG9naWNhbERpcmVjdGlvbkluZm8gPSB7XHJcbiAgICAuLi5WZXJ0aWNhbFJsTHRyLFxyXG4gICAgYmxvY2tEaXJlY3Rpb246IFwibHRyXCIsXHJcbn07XHJcblxyXG5jb25zdCBWZXJ0aWNhbExyUnRsOiBMb2dpY2FsRGlyZWN0aW9uSW5mbyA9IHtcclxuICAgIC4uLlZlcnRpY2FsUmxSdGwsXHJcbiAgICBibG9ja0RpcmVjdGlvbjogXCJsdHJcIixcclxufTtcclxuXHJcbmNvbnN0IFNpZGV3YXlzTHRMdHI6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgLi4uVmVydGljYWxMckx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJidHRcIixcclxuXHJcbiAgICBsZWZ0UmlnaHREaXJlY3Rpb246IFwiYnR0XCIsXHJcbiAgICBvdmVyVW5kZXJEaXJlY3Rpb246IFwibHRyXCJcclxufTtcclxuXHJcbmNvbnN0IFNpZGV3YXlzTHRSdGw6IExvZ2ljYWxEaXJlY3Rpb25JbmZvID0ge1xyXG4gICAgLi4uU2lkZXdheXNMdEx0cixcclxuICAgIGlubGluZURpcmVjdGlvbjogXCJ0dGJcIlxyXG59O1xyXG5cclxuXHJcblxyXG5jb25zdCBIb3Jpem9udGFsVGIgPSB7XHJcbiAgICBsdHI6IEhvcml6b250YWxUYkx0cixcclxuICAgIHJ0bDogSG9yaXpvbnRhbFRiUnRsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBWZXJ0aWNhbFJsID0ge1xyXG4gICAgbHRyOiBWZXJ0aWNhbFJsTHRyLFxyXG4gICAgcnRsOiBWZXJ0aWNhbFJsUnRsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBWZXJ0aWNhbExyID0ge1xyXG4gICAgbHRyOiBWZXJ0aWNhbExyTHRyLFxyXG4gICAgcnRsOiBWZXJ0aWNhbExyUnRsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBTaWRld2F5c1JsID0ge1xyXG4gICAgbHRyOiBTaWRld2F5c1JsTHRyLFxyXG4gICAgcnRsOiBTaWRld2F5c1JsUnRsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBTaWRld2F5c0xyID0ge1xyXG4gICAgbHRyOiBTaWRld2F5c0x0THRyLFxyXG4gICAgcnRsOiBTaWRld2F5c0x0UnRsXHJcbn0gYXMgY29uc3Q7XHJcblxyXG5jb25zdCBXcml0aW5nTW9kZXMgPSB7XHJcbiAgICBcImhvcml6b250YWwtdGJcIjogSG9yaXpvbnRhbFRiLFxyXG4gICAgXCJ2ZXJ0aWNhbC1sclwiOiBWZXJ0aWNhbExyLFxyXG4gICAgXCJ2ZXJ0aWNhbC1ybFwiOiBWZXJ0aWNhbFJsLFxyXG4gICAgXCJzaWRld2F5cy1sclwiOiBTaWRld2F5c0xyLFxyXG4gICAgXCJzaWRld2F5cy1ybFwiOiBTaWRld2F5c1JsXHJcbn0gYXMgY29uc3Q7XHJcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUaW1lb3V0IHtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1zIHRvIHdhaXQgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2AuICBcbiAgICAgKiBJZiBgbnVsbGAsIGNhbmNlbHMgdGhlIHRpbWVvdXQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgdGltZW91dDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdG8gdGhpcyBwcm9wIGJldHdlZW4gcmVuZGVycyBjYW4gYmUgdXNlZCB0byBjbGVhciB0aGUgY3VycmVudCB0aW1lb3V0IGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAqL1xuICAgIHRyaWdnZXJJbmRleD86IHVua25vd247XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYHRpbWVvdXRgIG1zIGFmdGVyIG1vdW50LCBvciB0aGUgbGFzdCBjaGFuZ2UgdG8gYHRyaWdnZXJJbmRleGAuXG4gICAgICogXG4gICAgICogRG9lcyAqbm90KiBuZWVkIHRvIGJlIHN0YWJsZS4gR28gYWhlYWQgYW5kIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlVGltZW91dCh7IHRpbWVvdXQsIGNhbGxiYWNrLCB0cmlnZ2VySW5kZXggfTogVXNlVGltZW91dCkge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtbGF5b3V0LWVmZmVjdFwiO1xyXG5pbXBvcnQgeyB1c2VMb2dpY2FsRGlyZWN0aW9uIH0gZnJvbSBcIi4vdXNlLWxvZ2ljYWwtZGlyZWN0aW9uXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuL3VzZS10aW1lb3V0XCI7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4ge1xyXG4gICAgLyoqIFxyXG4gICAgICogVGhlc2UgcHJvcHMgY2FuIGJlIGF0dGF0Y2hlZCBlaXRoZXIgdG8gdGhlIHBhcmVudCBvciB0byBlYWNoIGluZGl2aWR1YWwgY2hpbGQuXHJcbiAgICAgKiBXaGljaGV2ZXIgd29ya3MgYmV0dGVyIGZvciB5b3VyIHNjZW5hcmlvLlxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqIFxyXG4gICAgICogKi9cclxuICAgIHVzZUxpbmVhck5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcclxuICAgIGxpbmVhck5hdmlnYXRpb246IHt9XHJcbn1cclxuXHJcbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBwYXJlbnQgYHVzZUxpbmVhck5hdmlnYXRpb25gICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMge1xyXG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcclxuICAgIG5hdmlnYXRlVG9QcmV2KCk6IHZvaWQ7XHJcbiAgICBuYXZpZ2F0ZVRvRmlyc3QoKTogdm9pZDtcclxuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XHJcbiAgICAvKipcclxuICAgICAqIENvbnRyb2xzIHdoaWNoIGFycm93IGtleXMgYXJlIHVzZWQgdG8gbmF2aWdhdGUgdGhyb3VnaCB0aGUgY29tcG9uZW50LlxyXG4gICAgICogUmVsYXRpdmUgdG8gdGhlIHdyaXRpbmcgbW9kZSwgc28gaW4gRW5nbGlzaCwgXCJpbmxpbmVcIiBjb3JyZXNwb25kc1xyXG4gICAgICogdG8gdGhlIGxlZnQgJiByaWdodCBhcnJvdyBrZXlzLCBhbmQgXCJibG9ja1wiIHRvIHRoZSB1cCAmIGRvd24gYXJyb3cga2V5cy5cclxuICAgICAqIFxyXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxyXG4gICAgICogXHJcbiAgICAgKiBVc2UgXCJub25lXCIgdG8gZGlzYWxsb3cgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIGluIGFueSBkaXJlY3Rpb24uXHJcbiAgICAgKi9cclxuICAgIG5hdmlnYXRpb25EaXJlY3Rpb24/OiBcImlubGluZVwiIHwgXCJibG9ja1wiIHwgXCJlaXRoZXJcIiB8IFwibm9uZVwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIHRydWUsIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlIFxyXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXHJcbiAgICAgKiBiZSB1bmFmZmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXHJcbiAgICAgKiBiZSBkaXNhYmxlZCwgYnV0IG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cyB3aWxsIGJlXHJcbiAgICAgKiB1bmFmZmVjdGVkLlxyXG4gICAgICovXHJcbiAgICBkaXNhYmxlSG9tZUVuZEtleXM/OiBib29sZWFuO1xyXG5cclxufVxyXG5cclxuXHJcbi8qKiBBcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBjaGlsZCAndXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkYCAqL1xyXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cclxuXHJcbi8qKlxyXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcclxuICogdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdGhlIGFycm93IGtleXMuXHJcbiAqIFxyXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpbmVhck5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IG5hdmlnYXRlVG9GaXJzdDogbnRmLCBuYXZpZ2F0ZVRvTGFzdDogbnRsLCBuYXZpZ2F0ZVRvTmV4dDogbnRuLCBuYXZpZ2F0ZVRvUHJldjogbnRwLCBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBuZCwgZGlzYWJsZUFycm93S2V5czogZGFrLCBkaXNhYmxlSG9tZUVuZEtleXM6IGRoZWsgfTogVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMpOiBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xyXG5cclxuICAgIG5kID8/PSBcImVpdGhlclwiO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0TG9naWNhbERpcmVjdGlvbkluZm8sIHVzZUxvZ2ljYWxEaXJlY3Rpb25Qcm9wcyB9ID0gdXNlTG9naWNhbERpcmVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe30pO1xyXG5cclxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50Zik7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTGFzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bCk7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvTmV4dCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50bik7XHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZVN0YWJsZUNhbGxiYWNrKG50cCk7XHJcbiAgICBjb25zdCBnZXREaXNhYmxlQXJyb3dLZXlzID0gdXNlU3RhYmxlR2V0dGVyKGRhayk7XHJcbiAgICBjb25zdCBnZXREaXNhYmxlSG9tZUVuZEtleXMgPSB1c2VTdGFibGVHZXR0ZXIoZGhlayk7XHJcbiAgICBjb25zdCBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uID0gdXNlU3RhYmxlR2V0dGVyKG5kKTtcclxuXHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICB1c2VMaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0+IHtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IG9uS2V5RG93biA9IChlOiBLZXlib2FyZEV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcclxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZvID0gZ2V0TG9naWNhbERpcmVjdGlvbkluZm8oKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25EaXJlY3Rpb24gPSBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlQXJyb3dLZXlzID0gZ2V0RGlzYWJsZUFycm93S2V5cygpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUhvbWVFbmRLZXlzID0gZ2V0RGlzYWJsZUhvbWVFbmRLZXlzKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3dzQmxvY2tOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJibG9ja1wiIHx8IG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJlaXRoZXJcIik7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJpbmxpbmVcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xyXG5cclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dVcFwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJidHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93RG93blwiOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BOYW1lID0gKGluZm8/LmJsb2NrT3JpZW50YXRpb24gPT09IFwidmVydGljYWxcIiA/IFwiYmxvY2tEaXJlY3Rpb25cIiA6IFwiaW5saW5lRGlyZWN0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25BbGxvd2VkID0gKCFkaXNhYmxlQXJyb3dLZXlzICYmIChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBhbGxvd3NCbG9ja05hdmlnYXRpb24gOiBhbGxvd3NJbmxpbmVOYXZpZ2F0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5mbz8uW3Byb3BOYW1lXSA9PT0gXCJidHRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9QcmV2KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0xlZnRcIjoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wTmFtZSA9IChpbmZvPy5pbmxpbmVPcmllbnRhdGlvbiA9PT0gXCJob3Jpem9udGFsXCIgPyBcImlubGluZURpcmVjdGlvblwiIDogXCJibG9ja0RpcmVjdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gYWxsb3dzSW5saW5lTmF2aWdhdGlvbiA6IGFsbG93c0Jsb2NrTmF2aWdhdGlvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8/Lltwcm9wTmFtZV0gPT09IFwicnRsXCIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd1JpZ2h0XCI6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcE5hbWUgPSAoaW5mbz8uaW5saW5lT3JpZW50YXRpb24gPT09IFwiaG9yaXpvbnRhbFwiID8gXCJpbmxpbmVEaXJlY3Rpb25cIiA6IFwiYmxvY2tEaXJlY3Rpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgKGluZm8/LmlubGluZU9yaWVudGF0aW9uID09PSBcImhvcml6b250YWxcIiA/IGFsbG93c0lubGluZU5hdmlnYXRpb24gOiBhbGxvd3NCbG9ja05hdmlnYXRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmZvPy5bcHJvcE5hbWVdID09PSBcInJ0bFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvRmlyc3QoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJFbmRcIjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkaXNhYmxlSG9tZUVuZEtleXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTG9naWNhbERpcmVjdGlvblByb3BzKHVzZU1lcmdlZFByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7IG9uS2V5RG93biB9LCBwcm9wcykpXHJcbiAgICAgICAgfSwgW10pLFxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogQ2FuIGJlIHVzZWQgb24gZWl0aGVyIHRoZSBwYXJlbnQgb3IgZWFjaCBjaGlsZCBlbGVtZW50LlxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcclxuXHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ7XHJcblxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQ6IHN0cmluZyB8IG51bGw7XHJcbiAgICAgICAgaW52YWxpZFR5cGVhaGVhZDogYm9vbGVhbiB8IG51bGw7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxFIGV4dGVuZHMgRWxlbWVudD4gPSAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcclxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycyB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBIGNvbGxhdG9yIHRvIHVzZSB3aGVuIGNvbXBhcmluZy4gSWYgbm90IHByb3ZpZGVkLCBzaW1wbHkgdXNlcyBgbG9jYWxlQ29tcGFyZWAgYWZ0ZXIgdHJhbnNmb3JtaW5nIGVhY2ggdG8gbG93ZXJjYXNlLCB3aGljaCB3aWxsLCBhdCBiZXN0LCB3b3JrIG9rYXkgaW4gRW5nbGlzaC5cclxuICAgICAqL1xyXG4gICAgY29sbGF0b3I/OiBJbnRsLkNvbGxhdG9yO1xyXG5cclxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcclxuXHJcbiAgICB0eXBlYWhlYWRUaW1lb3V0PzogbnVtYmVyO1xyXG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcclxuICAgIHNldEluZGV4KHZhbHVlOiBudW1iZXIgfCBudWxsIHwgKChwcmV2aW91c1ZhbHVlOiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKTogdm9pZDtcclxufVxyXG5cclxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRgICovXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIHtcclxuICAgIC8qKlxyXG4gICAgICogSWYgcHJvdmlkZWQsIGFsbG93cyB0aGlzIGNvbXBvbmVudCB0byBiZSBuYXZpZ2F0ZWQgdG8gYnkgdHlwaW5nIHRoaXMgc3RyaW5nLiBcclxuICAgICAqIEl0IHNob3VsZCBiZSB0aGUgc2FtZSB0ZXh0IGNvbnRlbnQgYXMgd2hhdGV2ZXIncyBkaXNwbGF5ZWQsIGlkZWFsbHkuXHJcbiAgICAgKi9cclxuICAgIHRleHQ6IHN0cmluZyB8IG51bGw7XHJcblxyXG4gICAgaW5kZXg6IG51bWJlcjtcclxufVxyXG5cclxuLyoqIFR5cGUgb2YgdGhlIGNoaWxkJ3Mgc3ViLWhvb2sgKi9cclxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkID0gKGFyZ3M6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMpID0+IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGU7XHJcblxyXG5cclxuLyoqXHJcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cclxuICogXHJcbiAqIEBzZWUgdXNlTGlzdE5hdmlnYXRpb24sIHdoaWNoIHBhY2thZ2VzIGV2ZXJ5dGhpbmcgdXAgdG9nZXRoZXIuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgY29sbGF0b3IsIGdldEluZGV4LCB0eXBlYWhlYWRUaW1lb3V0LCBzZXRJbmRleCwgbm9UeXBlYWhlYWQgfTogVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMpOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xyXG5cclxuXHJcbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxyXG4gICAgLy8gYW5kIGFsc28gY2xlYXIgaXQgZXZlcnkgMTAwMCBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IGNoYW5nZWQuXHJcbiAgICAvLyBOZXh0LCBrZWVwIGEgbWFwcGluZyBvZiB0eXBlYWhlYWQgdmFsdWVzIHRvIGluZGljZXMgZm9yIGZhc3RlciBzZWFyY2hpbmcuXHJcbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxyXG4gICAgY29uc3QgW2N1cnJlbnRUeXBlYWhlYWQsIHNldEN1cnJlbnRUeXBlYWhlYWQsIGdldEN1cnJlbnRUeXBlYWhlYWRdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XHJcbiAgICB1c2VUaW1lb3V0KHsgdGltZW91dDogdHlwZWFoZWFkVGltZW91dCA/PyAxMDAwLCBjYWxsYmFjazogKCkgPT4geyBzZXRDdXJyZW50VHlwZWFoZWFkKG51bGwpOyBzZXRJbnZhbGlkVHlwZWFoZWFkKG51bGwpOyB9LCB0cmlnZ2VySW5kZXg6IGN1cnJlbnRUeXBlYWhlYWQgfSk7XHJcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPHsgdGV4dDogc3RyaW5nLCB1bnNvcnRlZEluZGV4OiBudW1iZXIgfVtdPihbXSk7XHJcbiAgICBjb25zdCBbaW52YWxpZFR5cGVhaGVhZCwgc2V0SW52YWxpZFR5cGVhaGVhZF0gPSB1c2VTdGF0ZTxib29sZWFuIHwgbnVsbD4oZmFsc2UpO1xyXG5cclxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcclxuICAgIC8vIEVzc2VudGlhbGx5LCB3aGVuIGFjdGl2ZSwgaWdub3JlIGZ1cnRoZXIga2V5cyBcclxuICAgIC8vIGJlY2F1c2Ugd2UncmUgd2FpdGluZyBmb3IgYSBDb21wb3NpdGlvbkVuZCBldmVudFxyXG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIC8vIEJlY2F1c2UgY29tcG9zaXRpb24gZXZlbnRzIGZpcmUgKmFmdGVyKiBrZXlkb3duIGV2ZW50cyBcclxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXHJcbiAgICAvLyB3ZSBjYW4gdXNlIHRoaXMgdG8ga2VlcCB0cmFjayBvZiB3aGljaCBldmVudCB3ZSdyZSBsaXN0ZW5pbmcgZm9yIG9uIHRoZSBmaXJzdCBrZXlkb3duLlxyXG4gICAgY29uc3QgW25leHRUeXBlYWhlYWRDaGFyLCBzZXROZXh0VHlwZWFoZWFkQ2hhcl0gPSB1c2VTdGF0ZTxzdHJpbmcgfCBudWxsPihudWxsKTtcclxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgaWYgKG5leHRUeXBlYWhlYWRDaGFyICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodHlwZWFoZWFkID0+ICgodHlwZWFoZWFkID8/IFwiXCIpICsgbmV4dFR5cGVhaGVhZENoYXIpKTtcclxuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW25leHRUeXBlYWhlYWRDaGFyXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IGNvbXBhcmF0b3JTaGFyZWQgPSB1c2VTdGFibGVDYWxsYmFjaygoc2FmZUxoczogc3RyaW5nLCBzYWZlUmhzOiBzdHJpbmcpID0+IHtcclxuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xyXG4gICAgICAgIC8vIEZvciB0aGUgcHVycG9zZXMgb2YgdHlwZWFoZWFkLCBvbmx5IGNvbXBhcmUgYSBzdHJpbmcgb2YgdGhlIHNhbWUgc2l6ZSBhcyBvdXIgY3VycmVudGx5IHR5cGVkIHN0cmluZy5cclxuICAgICAgICAvLyBCeSBub3JtYWxpemluZyB0aGVtIGZpcnN0LCB3ZSBlbnN1cmUgdGhpcyBieXRlLWJ5LWJ5dGUgaGFuZGxpbmcgb2YgcmF3IGNoYXJhY3RlciBkYXRhIHdvcmtzIG91dCBva2F5LlxyXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcclxuICAgICAgICBzYWZlUmhzID0gc2FmZVJocy5ub3JtYWxpemUoXCJORkRcIilcclxuXHJcbiAgICAgICAgaWYgKGNvbGxhdG9yKVxyXG4gICAgICAgICAgICBjb21wYXJlID0gY29sbGF0b3IuY29tcGFyZShzYWZlTGhzLCBzYWZlUmhzKVxyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBpbnNlcnRpbmdDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wYXJhdG9yU2hhcmVkKGxocywgcmhzLnRleHQpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB0eXBlYWhlYWRDb21wYXJhdG9yID0gdXNlU3RhYmxlQ2FsbGJhY2soKGxoczogc3RyaW5nLCByaHM6IHsgdGV4dDogc3RyaW5nOyB1bnNvcnRlZEluZGV4OiBudW1iZXI7IH0pID0+IHtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHJocy50ZXh0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgICAgIC8vIER1cmluZyB0eXBlYWhlYWQsIGFsbCBzdHJpbmdzIGxvbmdlciB0aGFuIG91cnMgc2hvdWxkIGJlIHRydW5jYXRlZFxyXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWxsIGNvbnNpZGVyZWQgZXF1YWxseSBieSB0aGF0IHBvaW50LlxyXG4gICAgICAgICAgICByZXR1cm4gY29tcGFyYXRvclNoYXJlZChsaHMsIHJocy50ZXh0LnN1YnN0cmluZygwLCBsaHMubGVuZ3RoKSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGlzRGlzYWJsZWQgPSB1c2VTdGFibGVHZXR0ZXIobm9UeXBlYWhlYWQpO1xyXG5cclxuXHJcbiAgICBjb25zdCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IFVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoeyAuLi5wcm9wcyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xyXG5cclxuICAgICAgICBjb25zdCBvbkNvbXBvc2l0aW9uU3RhcnQgPSAoX2U6IENvbXBvc2l0aW9uRXZlbnQpID0+IHsgc2V0SW1lQWN0aXZlKHRydWUpIH07XHJcbiAgICAgICAgY29uc3Qgb25Db21wb3NpdGlvbkVuZCA9IChlOiBDb21wb3NpdGlvbkV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHNldE5leHRUeXBlYWhlYWRDaGFyKGUuZGF0YSk7XHJcbiAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25LZXlEb3duID0gKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKGlzRGlzYWJsZWQoKSlcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGltZUFjdGl2ZSA9IGdldEltZUFjdGl2ZSgpO1xyXG5cclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZS5rZXk7XHJcblxyXG4gICAgICAgICAgICAvLyBOb3QgaGFuZGxlZCBieSB0eXBlYWhlYWQgKGkuZS4gYXNzdW1lIHRoaXMgaXMgYSBrZXlib2FyZCBzaG9ydGN1dClcclxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSAmJiBlLmtleSA9PT0gXCJCYWNrc3BhY2VcIikge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHdheSB0aGF0IGRvZXNuJ3Qgc3BsaXQgVVRGLTE2IHN1cnJvZ2F0ZXMuXHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50VHlwZWFoZWFkKHQgPT4gdCA9PT0gbnVsbCA/IG51bGwgOiBbLi4udF0ucmV2ZXJzZSgpLnNsaWNlKDEpLnJldmVyc2UoKS5qb2luKFwiXCIpKTtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgcHJvcGVydHkgcmVwcmVzZW50cyB0aGUgdHlwZWQgY2hhcmFjdGVyIE9SIHRoZSBcIm5hbWVkIGtleSBhdHRyaWJ1dGVcIiBvZiB0aGUga2V5IHByZXNzZWQuXHJcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gZGVmaW5pdGUgd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UsIGJ1dCBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzXHJcbiAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBubyBvbmUtY2hhcmFjdGVyIG5hbWVzLCBhbmQgdGhlcmUgYXJlIG5vIG5vbi1BU0NJSS1hbHBoYSBuYW1lcy5cclxuICAgICAgICAgICAgLy8gVGh1cywgYW55IG9uZS1jaGFyYWN0ZXIgb3Igbm9uLUFTQ0lJIHZhbHVlIGZvciBga2V5YCBpcyAqYWxtb3N0IGNlcnRhaW5seSogYSB0eXBlZCBjaGFyYWN0ZXIuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVyS2V5ID0gKGtleS5sZW5ndGggPT09IDEgfHwgIS9eW0EtWmEtel0vLnRlc3Qoa2V5KSk7XHJcbiAgICAgICAgICAgIGlmIChpc0NoYXJhY3RlcktleSkge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIgXCIgJiYgKGdldEN1cnJlbnRUeXBlYWhlYWQoKSA/PyBcIlwiKS50cmltKCkubGVuZ3RoID09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBkbyBhbnl0aGluZyBiZWNhdXNlIGEgc3BhY2ViYXIgY2FuJ3QgZXZlciBcclxuICAgICAgICAgICAgICAgICAgICAvLyBpbml0aWF0ZSBhIHR5cGVhaGVhZCwgb25seSBjb250aW51ZSBvbmUuXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIChTcGVjaWZpY2FsbHksIGxldCB0aGUgZXZlbnQgY29udGludWUgcHJvcGFnYXRpb24gaW4gdGhpcyBjYXNlKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3RlOiBXb24ndCBiZSB0cnVlIGZvciB0aGUgZmlyc3Qga2V5ZG93blxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlZm9yZSB1c2VMYXlvdXRFZmZlY3QgaXMgY2FsbGVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gYWN0dWFsbHkgYXBwbHkgdGhlIGNoYW5nZVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghaW1lQWN0aXZlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihrZXkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxQYXJlbnRPckNoaWxkRWxlbWVudD4oeyBvbktleURvd24sIG9uQ29tcG9zaXRpb25TdGFydCwgb25Db21wb3NpdGlvbkVuZCwgfSwgcHJvcHMpO1xyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIC8vIEhhbmRsZSBjaGFuZ2VzIGluIHR5cGVhaGVhZCB0aGF0IGNhdXNlIGNoYW5nZXMgdG8gdGhlIHRhYmJhYmxlIGluZGV4XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlmIChjdXJyZW50VHlwZWFoZWFkICYmIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5sZW5ndGgpIHtcclxuXHJcblxyXG5cclxuICAgICAgICAgICAgY29uc3Qgc29ydGVkVHlwZWFoZWFkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCBjdXJyZW50VHlwZWFoZWFkLCB0eXBlYWhlYWRDb21wYXJhdG9yKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChzb3J0ZWRUeXBlYWhlYWRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSB1c2VyIGhhcyB0eXBlZCBhbiBlbnRyeSB0aGF0IGRvZXNuJ3QgZXhpc3QgaW4gdGhlIGxpc3RcclxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcclxuICAgICAgICAgICAgICAgIHNldEludmFsaWRUeXBlYWhlYWQodHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKGZhbHNlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICAgICAgICBXZSBrbm93IHJvdWdobHkgd2hlcmUsIGluIHRoZSBzb3J0ZWQgYXJyYXkgb2Ygc3RyaW5ncywgb3VyIG5leHQgdHlwZWFoZWFkIGxvY2F0aW9uIGlzLlxyXG4gICAgICAgICAgICAgICAgICBCdXQgcm91Z2hseSBpc24ndCBnb29kIGVub3VnaCBpZiB0aGVyZSBhcmUgbXVsdGlwbGUgbWF0Y2hlcy5cclxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgICAgICAgIGVsZW1lbnQgdGhhdCBtYXRjaGVzIHVzICphbmQqIChpZiBhbnkgc3VjaCBleGlzdCkgaXMgKmFmdGVyKiBvdXIgY3VycmVudCBzZWxlY3Rpb24uXHJcblxyXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcclxuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gaXMgaWYgdGhlIG9ubHkgb3RoZXIgb3B0aW9uIGlzIGJlaGluZCB1cy5cclxuXHJcbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xyXG4gICAgICAgICAgICAgICAgICBUaG91Z2ggdGhlcmUncyBhbHNvIGEgY2FzZSBmb3IganVzdCBnb2luZyB1cHdhcmRzIHRvIHRoZSBuZWFyZXN0IHRvIHByZXZlbnQganVtcGluZXNzLlxyXG4gICAgICAgICAgICAgICAgICBCdXQgaWYgeW91J3JlIGFscmVhZHkgZG9pbmcgdHlwZWFoZWFkIG9uIGFuIHVuc29ydGVkIGxpc3QsIGxpa2UsIGp1bXBpbmVzcyBjYW4ndCBiZSBhdm9pZGVkLlxyXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxyXG5cclxuICAgICAgICAgICAgICAgICAgQmFzaWNhbGx5IHdoYXQgdGhpcyBkb2VzOiBTdGFydGluZyBmcm9tIHdoZXJlIHdlIGZvdW5kIG91cnNlbHZlcyBhZnRlciBvdXIgYmluYXJ5IHNlYXJjaCxcclxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XHJcbiAgICAgICAgICAgICAgICAgIHdlIGNhbiBmaW5kIHRoZSBvbmUgd2hvc2UgYHVuc29ydGVkSW5kZXhgIGlzIHRoZSBsb3dlc3QgYW1vbmdzdCBhbGwgb3RoZXIgZXF1YWwgc3RyaW5nc1xyXG4gICAgICAgICAgICAgICAgICAoYW5kIGFsc28gdGhlIGxvd2VzdCBgdW5zb3J0ZWRJbmRleGAgeWFkZGEgeWFkZGEgZXhjZXB0IHRoYXQgaXQgY29tZXMgYWZ0ZXIgdXMpLlxyXG5cclxuICAgICAgICAgICAgICAgICAgVE9ETzogVGhlIGJpbmFyeSBzZWFyY2ggc3RhcnRzIHRoaXMgb2ZmIHdpdGggYSBzb2xpZCBPKGxvZyBuKSwgYnV0IG9uZS1jaGFyYWN0ZXIgXHJcbiAgICAgICAgICAgICAgICAgIHNlYXJjaGVzIGFyZSwgdGhhbmtzIHRvIHBpZ2VvbmhvbGUgcHJpbmNpcGFsLCBldmVudHVhbGx5IGd1YXJhbnRlZWQgdG8gYmVjb21lIFxyXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhbiBcclxuICAgICAgICAgICAgICAgICAgZXhjZXB0aW9uIGZvciBvbmUtY2hhcmFjdGVyIHN0cmluZ3MsIGJ1dCB0aGF0J3MganVzdCBraWNraW5nIHRoZSBjYW4gZG93biBcclxuICAgICAgICAgICAgICAgICAgdGhlIHJvYWQuIE1heWJlIG9uZSBvciB0d28gY2hhcmFjdGVycyB3b3VsZCBiZSBnb29kIGVub3VnaCB0aG91Z2guXHJcbiAgICAgICAgICAgICAgICAqL1xyXG5cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFVuc29ydGVkSW5kZXhBbGw6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4QWxsID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgdHdvIGFyZSBvbmx5IHNldCBmb3IgZWxlbWVudHMgdGhhdCBhcmUgYWhlYWQgb2YgdXMsIGJ1dCB0aGUgcHJpbmNpcGxlJ3MgdGhlIHNhbWUgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0VW5zb3J0ZWRJbmRleE5leHQ6IG51bWJlciB8IG51bGwgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xyXG5cclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZUJlc3RGaXQgPSAodTogbnVtYmVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4QWxsID0gdTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAoKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID09IG51bGwgfHwgdSA8IGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0KSAmJiB1ID4gKGdldEluZGV4KCkgPz8gLUluZmluaXR5KSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9IHU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IGk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGxldCBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGkgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcclxuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50Lmxlbmd0aCAmJiB0eXBlYWhlYWRDb21wYXJhdG9yKGN1cnJlbnRUeXBlYWhlYWQsIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtpXSkgPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICsraTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAobG93ZXN0VW5zb3J0ZWRJbmRleE5leHQgIT09IG51bGwpXHJcbiAgICAgICAgICAgICAgICAgICAgc2V0SW5kZXgoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2xvd2VzdFNvcnRlZEluZGV4TmV4dF0udW5zb3J0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHNldEluZGV4KHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtsb3dlc3RTb3J0ZWRJbmRleEFsbF0udW5zb3J0ZWRJbmRleCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbY3VycmVudFR5cGVhaGVhZF0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZD4oKHsgaW5kZXgsIHRleHQgfSkgPT4ge1xyXG5cclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGV4dCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpbmQgd2hlcmUgdG8gaW5zZXJ0IHRoaXMgaXRlbS5cclxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcclxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBhbHdheXMgcmVmZXIgdG8gYSBuZXcgbG9jYXRpb24gKGkuZS4gYmUgbmVnYXRpdmUpICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgY29uc3Qgc29ydGVkSW5kZXggPSBiaW5hcnlTZWFyY2goc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LCB0ZXh0LCBpbnNlcnRpbmdDb21wYXJhdG9yKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcclxuICAgICAgICAgICAgICAgIGlmIChzb3J0ZWRJbmRleCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKC1zb3J0ZWRJbmRleCAtIDEsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQuc3BsaWNlKHNvcnRlZEluZGV4LCAwLCB7IHRleHQsIHVuc29ydGVkSW5kZXg6IGluZGV4IH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQWdhaW4sIHdlIHNob3VsZCBhbHdheXMgZmluZCBvdXJzZWx2ZXMgYmVjYXVzZSB0aGVyZSBzaG91bGQgYmUgbm8gZHVwbGljYXRlIHZhbHVlcyBpZiBlYWNoIGluZGV4IGlzIHVuaXF1ZS5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRlZEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgW3RleHRdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsXHJcblxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZCxcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG4vKipcclxuICogWW91ciB1c3VhbCBiaW5hcnkgc2VhcmNoIGltcGxlbWVudGF0aW9uLlxyXG4gKiBcclxuICogSXQncyB1c2VkIGhlcmUgdG8gcXVpY2tseSBmaW5kIGEgZ29vZCBzcG90IHRvIHN0YXJ0IHNlYXJjaGluZyBmb3Igb3VyIG5leHQgdHlwZWFoZWFkIGNhbmRpZGF0ZS5cclxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2ggdGhyb3VnaFxyXG4gKiBAcGFyYW0gd2FudGVkIFRoZSB2YWx1ZSB5b3UnZCBsaWtlIHRvIGZpbmRcclxuICogQHBhcmFtIGNvbXBhcmF0b3IgQ29tcGFyZXMgYHdhbnRlZGAgd2l0aCB0aGUgY3VycmVudCB2YWx1ZSBpbiBgYXJyYXlgXHJcbiAqIEByZXR1cm5zIEEgbm9uLW5lZ2F0aXZlIHZhbHVlIGlmIGB3YW50ZWRgIHdhcyBmb3VuZCwgYW5kIGEgbmVnYXRpdmUgbnVtYmVyIGlmIG5vdC4gXHJcbiAqIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIG51bWJlciwgbWludXMgb25lLCBpcyB3aGVyZSBgd2FudGVkYCAqd291bGQqIGJlIGZvdW5kIGlmIGl0ICp3YXMqIGluIGBhcnJheWBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlTZWFyY2g8VCwgVSwgRiBleHRlbmRzIChsaHM6IFUsIHJoczogVCkgPT4gbnVtYmVyPihhcnJheTogVFtdLCB3YW50ZWQ6IFUsIGNvbXBhcmF0b3I6IEYpOiBudW1iZXIge1xyXG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xyXG4gICAgbGV0IGxhc3RJbmRleCA9IGFycmF5Lmxlbmd0aCAtIDE7XHJcbiAgICB3aGlsZSAoZmlyc3RJbmRleCA8PSBsYXN0SW5kZXgpIHtcclxuICAgICAgICBjb25zdCB0ZXN0SW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgPj4gMTtcclxuICAgICAgICBjb25zdCBjb21wYXJpc29uUmVzdWx0ID0gY29tcGFyYXRvcih3YW50ZWQsIGFycmF5W3Rlc3RJbmRleF0pO1xyXG5cclxuICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcclxuICAgICAgICAgICAgZmlyc3RJbmRleCA9IHRlc3RJbmRleCArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XHJcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IHRlc3RJbmRleCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGVzdEluZGV4O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gLWZpcnN0SW5kZXggLSAxO1xyXG59XHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xyXG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRJbmZvLCBPbkNoaWxkcmVuTW91bnRDaGFuZ2UsIHVzZUNoaWxkcmVuRmxhZywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlSGFzRm9jdXMgfSBmcm9tIFwiLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyByZXR1cm5aZXJvLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcclxuXHJcbi8vZXhwb3J0IHR5cGUgVXNlUm92aW5nVGFiSW5kZXhDaGlsZEluZm88SyBleHRlbmRzIHN0cmluZywgSSBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvQmFzZTxLPj4gPSBSZXF1aXJlZDxJPiAmIEZsYWdnYWJsZUNoaWxkSW5mbzxcInRhYmJhYmxlXCI+ICYge1xyXG4vL307XHJcblxyXG5leHBvcnQgdHlwZSBPblRhYmJhYmxlSW5kZXhDaGFuZ2UgPSAodGFiYmFibGVJbmRleDogbnVtYmVyIHwgbnVsbCkgPT4gdm9pZDtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPEUgZXh0ZW5kcyBFbGVtZW50LCBDPiB7XHJcbiAgICAvKipcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRhYmJpbmcgdGhyb3VnaCB0aGlzIGNvbXBvbmVudCB3aWxsIGNhdXNlIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgdG8gYmUgZm9jdXNlZC5cclxuICAgICAqIFxyXG4gICAgICogWW91IGNhbiBvdmVycmlkZSB0aGlzIGJlaGF2aW9yIHRvIGRvIHNvbWV0aGluZyBkaWZmZXJlbnQgaWYgeW91J2QgbGlrZS5cclxuICAgICAqL1xyXG4gICAgZm9jdXNTZWxmKCk6IHZvaWQ7XHJcblxyXG4gICAgYmx1clNlbGYoKTogdm9pZDtcclxuXHJcbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xyXG5cclxuICAgIGhpZGRlbjogYm9vbGVhbjtcclxuXHJcbiAgICBzdWJJbmZvOiBDO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyPiB7XHJcbiAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgIC8vIENhbGxlZCBkdXJpbmcgYW4gZWZmZWN0IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIHJlbmRlcmVkIGl0c2VsZiBpbiBhIHRhYmJhYmxlIHN0YXRlXHJcbiAgICAgICAgb25UYWJiYWJsZVJlbmRlcj86IChpbmRleDogbnVtYmVyKSA9PiB2b2lkO1xyXG5cclxuICAgICAgICBvblRhYmJhYmxlSW5kZXhDaGFuZ2U/OiBPblRhYmJhYmxlSW5kZXhDaGFuZ2U7XHJcblxyXG4gICAgICAgIG9uVGFiYmVkSW5Ubz86ICgpID0+IHZvaWQ7XHJcbiAgICAgICAgb25UYWJiZWRPdXRPZj86ICgpID0+IHZvaWQ7XHJcblxyXG4gICAgICAgIGluaXRpYWxJbmRleD86IG51bWJlcjtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBPbWl0PFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGU8bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4sIFwidXNlTWFuYWdlZENoaWxkXCI+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkOiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XHJcblxyXG4gICAgcm92aW5nVGFiSW5kZXg6IHtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIHNldFRhYmJhYmxlSW5kZXg6ICh1cGRhdGVyOiBQYXJhbWV0ZXJzPFN0YXRlVXBkYXRlcjxudW1iZXIgfCBudWxsPj5bMF0sIGZyb21Vc2VySW50ZXJhY3Rpb246IGJvb2xlYW4pID0+IHZvaWQ7XHJcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgICAgICBnZXRUYWJiYWJsZUluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZm9jdXNTZWxmOiAoKSA9PiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ge1xyXG4gICAgbWFuYWdlZENoaWxkOiBPbWl0PE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88YW55LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4sIFwic3ViSW5mb1wiPjtcclxuICAgIHJvdmluZ1RhYkluZGV4OiBQYXJ0aWFsPE9taXQ8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PiwgXCJnZXRFbGVtZW50XCI+PiAmIFBpY2s8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PiwgXCJzdWJJbmZvXCI+O1xyXG59XHJcblxyXG5leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+KSA9PiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XHJcbiAgICAvKiogKlVuc3RhYmxlKiAqL1xyXG4gICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD47XHJcbiAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgIHRhYmJhYmxlOiBib29sZWFuO1xyXG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICAgICAgZ2V0VGFiYmFibGUoKTogYm9vbGVhbjtcclxuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgICAgIGdldEVsZW1lbnQoKTogQ2hpbGRFbGVtZW50IHwgbnVsbDtcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBJbXBsZW1lbnRzIGEgcm92aW5nIHRhYmluZGV4IHN5c3RlbSB3aGVyZSBvbmx5IG9uZSBcImZvY3VzYWJsZVwiXHJcbiAqIGNvbXBvbmVudCBpbiBhIHNldCBpcyBhYmxlIHRvIHJlY2VpdmUgYSB0YWIgZm9jdXMuICpXaGljaCpcclxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXHJcbiAqIHJlY29tbWVuZGVkIHRvIG9mZmxvYWQgdGhhdCBsb2dpYyB0aGVuIHRvIGFub3RoZXIgaG9vaywgbGlrZVxyXG4gKiBgdXNlTGluZWFyTmF2aWdhdGlvbmAsIHdoaWNoIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGVcclxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXHJcbiAqIGxldHMgeW91IGNoYW5nZSB0aGUgdGFiYmFibGUgaW5kZXggd2l0aCB0eXBlYWhlYWQsIG9yXHJcbiAqIGB1c2VMaXN0TmF2aWdhdGlvbmAgaWYgeW91IGp1c3Qgd2FudCBldmVyeXRoaW5nIGJ1bmRsZWQgdG9nZXRoZXIuXHJcbiAqIFxyXG4gKiBOb3RlIHRoYXQgdGhlIGNoaWxkIGhvb2sgcmV0dXJuZWQgYnkgdGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWRcclxuICogYnkgZXZlcnkgY2hpbGQgdGhhdCB1c2VzIHRoaXMgcm92aW5nIHRhYmluZGV4IGxvZ2ljLiAgVGhlXHJcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXHJcbiAqIG9uIHRoZSBjaGlsZCdzIGVsZW1lbnQsIGFzIHdlbGwgYXMgYW55IG90aGVyIGVsZW1lbnRzIHlvdSdkIGxpa2VcclxuICogdG8gYmUgZXhwbGljaXRseSBtYWRlIHVudGFiYmFibGUgdG9vLlxyXG4gKiBcclxuICogYHNob3VsZEZvY3VzT25DaGFuZ2VgIHNob3VsZCByZXR1cm4gdHJ1ZSBpZiBmb2N1cyBpcyBcclxuICogY29udGFpbmVkIHdpdGhpbiB3aGF0ZXZlciBlbGVtZW50IGNvbnRhaW5zIHRoZSByb3ZpbmcgdGFiIGluZGV4LlxyXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XHJcbiAqIGBgYFxyXG4gKiBjb25zdCBbZm9jdXNlZElubmVyLCBzZXRGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xyXG4gKiBjb25zdCBmb2N1c09uQ2hhbmdlID0gKGZvY3VzZWRJbm5lciAhPSBmYWxzZSk7XHJcbiAqIGBgYFxyXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXHJcbiAqIGFueXRoaW5nIGFib3V0IHRoZSBjb250YWluZXIgZWxlbWVudCwgb25seSBjaGlsZHJlbiBlbGVtZW50cy5cclxuICogQW5kIGp1c3QgYXMgd2VsbCEgQ2hpbGRyZW4gc2hvdWxkIGJlIGFsbG93ZWQgYXQgdGhlIHJvb3QsIFxyXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJvdmluZ1RhYkluZGV4PENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+KHBhcmVudFBhcmFtZXRlcnM6IFVzZVJvdmluZ1RhYkluZGV4UGFyYW1ldGVycyk6IFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcclxuXHJcbiAgICBsZXQgeyByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmVkSW5Ubywgb25UYWJiZWRPdXRPZiwgb25UYWJiYWJsZVJlbmRlciwgb25UYWJiYWJsZUluZGV4Q2hhbmdlIH0sIG1hbmFnZWRDaGlsZHJlbjogeyBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsIG9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IH0gPSBwYXJlbnRQYXJhbWV0ZXJzO1xyXG5cclxuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcclxuICAgIGNvbnN0IHN0YWJsZU9uVGFiYmFibGVSZW5kZXIgPSB1c2VTdGFibGVDYWxsYmFjayhvblRhYmJhYmxlUmVuZGVyID8/ICgoKSA9PiB7IH0pKTtcclxuICAgIGNvbnN0IFtfZ2V0QW55Rm9jdXNlZCwgc2V0QW55Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyPih1c2VTdGFibGVDYWxsYmFjaygobmV3Q291bnQ6IG51bWJlciwgb2xkQ291bnQ6IG51bWJlciB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgIGlmIChvbGRDb3VudCA9PSAwICYmIG5ld0NvdW50ID4gMCkge1xyXG4gICAgICAgICAgICBvblRhYmJlZEluVG8/LigpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xyXG4gICAgICAgICAgICBvblRhYmJlZE91dE9mPy4oKTtcclxuICAgICAgICB9XHJcbiAgICB9KSwgcmV0dXJuWmVybyk7XHJcblxyXG4gICAgLy8gS2VlcCB0cmFjayBvZiB0aHJlZSB0aGluZ3MgcmVsYXRlZCB0byB0aGUgY3VycmVudGx5IHRhYmJhYmxlIGVsZW1lbnQncyBpbmRleDpcclxuICAgIC8vIFdoYXQgaXQgaXMsIGFuZCB3aGV0aGVyLCB3aGVuIHdlIHJlbmRlciB0aGlzIGNvbXBvbmVudCBhbmQgaXQncyBjaGFuZ2VkLCB0byBhbHNvIGZvY3VzIHRoZSBlbGVtZW50IHRoYXQgd2FzIG1hZGUgdGFiYmFibGUuXHJcbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ID8/IDAgfSwgW10pKTtcclxuICAgIGNvbnN0IHNldFRhYmJhYmxlSW5kZXggPSB1c2VDYWxsYmFjaygodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgc2V0VGFiYmFibGVJbmRleDIoKHByZXZJbmRleCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xyXG5cclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB1cGRhdGVyID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyKHByZXZJbmRleCA/PyBudWxsKTtcclxuICAgICAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICAgICAgbmV4dEluZGV4ID0gdXBkYXRlcjtcclxuXHJcbiAgICAgICAgICAgIG5leHRJbmRleCA9IGNoYW5nZUluZGV4KG5leHRJbmRleCk7XHJcblxyXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dENoaWxkID0gbmV4dEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4uZ2V0QXQobmV4dEluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDaGlsZCA9IHByZXZJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KHByZXZJbmRleCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHByZXZDaGlsZCAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgICAgIHByZXZDaGlsZC5zdWJJbmZvLmJsdXJTZWxmKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG5leHRDaGlsZCAhPSBudWxsICYmIGZyb21Vc2VySW50ZXJhY3Rpb24pXHJcbiAgICAgICAgICAgICAgICAgICAgbmV4dENoaWxkLnN1YkluZm8uZm9jdXNTZWxmKCk7XHJcblxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gbmV4dEluZGV4O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICAvLyBBbnkgdGltZSB0aGUgdGFiYmFibGUgaW5kZXggY2hhbmdlcyxcclxuICAgIC8vIG5vdGlmeSB0aGUgcHJldmlvdXMgY2hpbGQgdGhhdCBpdCdzIG5vIGxvbmdlciB0YWJiYWJsZSxcclxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cclxuICAgIGNvbnN0IHBhcmVudFJldHVyblR5cGUgPSB1c2VNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIj4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXHJcbiAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2s8T25DaGlsZHJlbk1vdW50Q2hhbmdlPG51bWJlcj4+KChtb3VudGVkLCB1bm1vdW50ZWQpID0+IHsgb25DaGlsZHJlbk1vdW50Q2hhbmdlPy4obW91bnRlZCwgdW5tb3VudGVkKTsgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTsgfSksXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlTWFuYWdlZENoaWxkIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xyXG5cclxuICAgIGNvbnN0IHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0IH0gPSB1c2VDaGlsZHJlbkZsYWc8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHsgaW5pdGlhbEluZGV4LCBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4sIGNsb3Nlc3RGaXQ6IHRydWUsIGtleTogXCJ0YWJiYWJsZVwiIH0pO1xyXG5cclxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbiwgc3ViSW5mbywgYmx1clNlbGY6IGJsdXJTZWxmT3ZlcnJpZGUsIGZvY3VzU2VsZjogZm9jdXNTZWxmT3ZlcnJpZGUgfSB9ID0gY2hpbGRQYXJhbWV0ZXJzO1xyXG5cclxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpO1xyXG4gICAgICAgIH0sIFshIWhpZGRlbl0pXHJcblxyXG5cclxuICAgICAgICBjb25zdCBic092ZXJyaWRlID0gdXNlU3RhYmxlR2V0dGVyKGJsdXJTZWxmT3ZlcnJpZGUpO1xyXG4gICAgICAgIGNvbnN0IGZzT3ZlcnJpZGUgPSB1c2VTdGFibGVHZXR0ZXIoZm9jdXNTZWxmT3ZlcnJpZGUpO1xyXG4gICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZnMgPSBmc092ZXJyaWRlKCk7XHJcbiAgICAgICAgICAgIGlmIChmcykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmZvY3VzU2VsZiAob3ZlcnJpZGUpYCk7XHJcbiAgICAgICAgICAgICAgICBmcygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmZvY3VzU2VsZiAoZGVmYXVsdClgKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudClcclxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmZvY3VzPy4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKTtcclxuICAgICAgICBjb25zdCBibHVyU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYnMgPSBic092ZXJyaWRlKCk7XHJcbiAgICAgICAgICAgIGlmIChicykge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRbJHtpbmRleH1dLmJsdXJTZWxmIChvdmVycmlkZSlgKTtcclxuICAgICAgICAgICAgICAgIGJzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFske2luZGV4fV0uYmx1clNlbGYgKGRlZmF1bHQpYCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpIGFzIChFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQpXHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5ibHVyPy4oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIFtdKTtcclxuXHJcbiAgICAgICAgY29uc3Qgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHtcclxuICAgICAgICAgICAgc2V0QW55Rm9jdXNlZChwcmV2ID0+IChmb2N1c2VkID8gKChwcmV2ID8/IDApICsgMSkgOiAoKHByZXYgPz8gMCkgLSAxKSkpO1xyXG4gICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYENoaWxkICR7aW5kZXh9IGhhcyBiZWVuIGZvY3VzZWQgYW5kIHdpbGwgc2V0IGl0c2VsZiBhcyB0aGUgdGFiYmFibGUgY2hpbGRgKTtcclxuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyBnZXRFbGVtZW50LCB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxDaGlsZEVsZW1lbnQ+KHsgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBbdGFiYmFibGUsIHNldFRhYmJhYmxlLCBnZXRUYWJiYWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICAgICAgY29uc3QgdGFiYmFibGVGbGFncyA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0VGFiYmFibGUsIHNldDogc2V0VGFiYmFibGUsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFoaWRkZW4pIH0pO1xyXG5cclxuICAgICAgICBjb25zdCBfOiB2b2lkID0gdXNlTWFuYWdlZENoaWxkKHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XHJcbiAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgIGZsYWdzOiB7IC4uLmZsYWdzLCB0YWJiYWJsZTogdGFiYmFibGVGbGFncy5jdXJyZW50IH0gYXMgUGFydGlhbDxSZWNvcmQ8RXh0cmFGbGFnS2V5cyB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+LFxyXG4gICAgICAgICAgICAgICAgc3ViSW5mbzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsdXJTZWxmLFxyXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcclxuICAgICAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbjogISFoaWRkZW4sXHJcbiAgICAgICAgICAgICAgICAgICAgc3ViSW5mb1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxyXG4gICAgICAgICAgICAgICAgc3RhYmxlT25UYWJiYWJsZVJlbmRlcihpbmRleCk7XHJcbiAgICAgICAgfSwgW3RhYmJhYmxlLCBpbmRleF0pXHJcbiAgICAgICAgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHByb3BzLnRhYkluZGV4ID09IG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8Q2hpbGRFbGVtZW50Pih1c2VIYXNGb2N1c1Byb3BzKHsgdGFiSW5kZXg6IHRhYmJhYmxlID8gMCA6IC0xIH0pLCBwcm9wcyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xyXG5cclxuICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgdXNlUm92aW5nVGFiSW5kZXguZm9jdXNTZWxmYCk7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBnZXRUYWJiYWJsZUluZGV4KCk7XHJcbiAgICAgICAgaWYgKGluZGV4ICE9IG51bGwpXHJcbiAgICAgICAgICAgIHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KGluZGV4KT8uc3ViSW5mby5mb2N1c1NlbGY/LigpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChudWxsLCB0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbiB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgICAgIGdldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgICAgIGZvY3VzU2VsZixcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxyXG4vKmZ1bmN0aW9uIHRlc3QoKSB7XHJcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXgsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIH0gPSB1c2VSb3ZpbmdUYWJJbmRleDxIVE1MRGl2RWxlbWVudCwgeyBcImZvb1wiOiBcImJhclwiIH0sIFwiZmxhZzJcIj4oeyBtYW5hZ2VkQ2hpbGRyZW46IHt9LCByb3ZpbmdUYWJJbmRleDoge30gfSk7XHJcbiAgICBjb25zdCB7IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4OiAwLCBmbGFnczoge30gfSwgcnRpOiB7IGluZm8zOiB7IGZvbzogXCJiYXJcIiB9IH0gfSk7XHJcbn0qL1xyXG4iLCIvKipcbiAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheT1bXV0gVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIHRvLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGNvcHlBcnJheShzb3VyY2UsIGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICBhcnJheSB8fCAoYXJyYXkgPSBBcnJheShsZW5ndGgpKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY29weUFycmF5O1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICBuYXRpdmVSYW5kb20gPSBNYXRoLnJhbmRvbTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gKiBmbG9hdGluZy1wb2ludCBudW1iZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbG93ZXIgVGhlIGxvd2VyIGJvdW5kLlxuICogQHBhcmFtIHtudW1iZXJ9IHVwcGVyIFRoZSB1cHBlciBib3VuZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gKi9cbmZ1bmN0aW9uIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKSB7XG4gIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VSYW5kb207XG4iLCJpbXBvcnQgYmFzZVJhbmRvbSBmcm9tICcuL19iYXNlUmFuZG9tLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT1hcnJheS5sZW5ndGhdIFRoZSBzaXplIG9mIGBhcnJheWAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZVNlbGYoYXJyYXksIHNpemUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuXG4gIHNpemUgPSBzaXplID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBzaXplO1xuICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICB2YXIgcmFuZCA9IGJhc2VSYW5kb20oaW5kZXgsIGxhc3RJbmRleCksXG4gICAgICAgIHZhbHVlID0gYXJyYXlbcmFuZF07XG5cbiAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICBhcnJheVtpbmRleF0gPSB2YWx1ZTtcbiAgfVxuICBhcnJheS5sZW5ndGggPSBzaXplO1xuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNodWZmbGVTZWxmO1xuIiwiaW1wb3J0IGNvcHlBcnJheSBmcm9tICcuL19jb3B5QXJyYXkuanMnO1xuaW1wb3J0IHNodWZmbGVTZWxmIGZyb20gJy4vX3NodWZmbGVTZWxmLmpzJztcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzaHVmZmxlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZihjb3B5QXJyYXkoYXJyYXkpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlTaHVmZmxlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWFwYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWVcbiAqIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlNYXA7XG4iLCJpbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnZhbHVlc2AgYW5kIGBfLnZhbHVlc0luYCB3aGljaCBjcmVhdGVzIGFuXG4gKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAqIG9mIGBwcm9wc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gYmFzZVZhbHVlcyhvYmplY3QsIHByb3BzKSB7XG4gIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIG9iamVjdFtrZXldO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVZhbHVlcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICogb3IgbWF4IGFycmF5IGxlbmd0aCBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gaW52b2tlIGBpdGVyYXRlZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICovXG5mdW5jdGlvbiBiYXNlVGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShuKTtcblxuICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VUaW1lcztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcmd1bWVudHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqL1xuZnVuY3Rpb24gYmFzZUlzQXJndW1lbnRzKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc0FyZ3VtZW50cztcbiIsImltcG9ydCBiYXNlSXNBcmd1bWVudHMgZnJvbSAnLi9fYmFzZUlzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgJiZcbiAgICAhcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcmd1bWVudHM7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBgZmFsc2VgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMy4wXG4gKiBAY2F0ZWdvcnkgVXRpbFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50aW1lcygyLCBfLnN0dWJGYWxzZSk7XG4gKiAvLyA9PiBbZmFsc2UsIGZhbHNlXVxuICovXG5mdW5jdGlvbiBzdHViRmFsc2UoKSB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3R1YkZhbHNlO1xuIiwiaW1wb3J0IHJvb3QgZnJvbSAnLi9fcm9vdC5qcyc7XG5pbXBvcnQgc3R1YkZhbHNlIGZyb20gJy4vc3R1YkZhbHNlLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVJc0J1ZmZlciA9IEJ1ZmZlciA/IEJ1ZmZlci5pc0J1ZmZlciA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlci5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMy4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG5leHBvcnQgZGVmYXVsdCBpc0J1ZmZlcjtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG52YXIgcmVJc1VpbnQgPSAvXig/OjB8WzEtOV1cXGQqKSQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBpbmRleC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD1NQVhfU0FGRV9JTlRFR0VSXSBUaGUgdXBwZXIgYm91bmRzIG9mIGEgdmFsaWQgaW5kZXguXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzSW5kZXgodmFsdWUsIGxlbmd0aCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgbGVuZ3RoID0gbGVuZ3RoID09IG51bGwgPyBNQVhfU0FGRV9JTlRFR0VSIDogbGVuZ3RoO1xuXG4gIHJldHVybiAhIWxlbmd0aCAmJlxuICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAodHlwZSAhPSAnc3ltYm9sJyAmJiByZUlzVWludC50ZXN0KHZhbHVlKSkpICYmXG4gICAgICAgICh2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNJbmRleDtcbiIsIi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgYXJyYXktbGlrZSBsZW5ndGguXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBsZW5ndGgsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0xlbmd0aCgzKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKEluZmluaXR5KTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aCgnMycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgIHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPD0gTUFYX1NBRkVfSU5URUdFUjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNMZW5ndGg7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgIGFycmF5VGFnID0gJ1tvYmplY3QgQXJyYXldJyxcbiAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgIGRhdGVUYWcgPSAnW29iamVjdCBEYXRlXScsXG4gICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIG1hcFRhZyA9ICdbb2JqZWN0IE1hcF0nLFxuICAgIG51bWJlclRhZyA9ICdbb2JqZWN0IE51bWJlcl0nLFxuICAgIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgIHJlZ2V4cFRhZyA9ICdbb2JqZWN0IFJlZ0V4cF0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nLFxuICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICBmbG9hdDY0VGFnID0gJ1tvYmplY3QgRmxvYXQ2NEFycmF5XScsXG4gICAgaW50OFRhZyA9ICdbb2JqZWN0IEludDhBcnJheV0nLFxuICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgIGludDMyVGFnID0gJ1tvYmplY3QgSW50MzJBcnJheV0nLFxuICAgIHVpbnQ4VGFnID0gJ1tvYmplY3QgVWludDhBcnJheV0nLFxuICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgdWludDE2VGFnID0gJ1tvYmplY3QgVWludDE2QXJyYXldJyxcbiAgICB1aW50MzJUYWcgPSAnW29iamVjdCBVaW50MzJBcnJheV0nO1xuXG4vKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG52YXIgdHlwZWRBcnJheVRhZ3MgPSB7fTtcbnR5cGVkQXJyYXlUYWdzW2Zsb2F0MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbZmxvYXQ2NFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxudHlwZWRBcnJheVRhZ3NbaW50MzJUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDhUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xudHlwZWRBcnJheVRhZ3NbYXJnc1RhZ10gPSB0eXBlZEFycmF5VGFnc1thcnJheVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbYXJyYXlCdWZmZXJUYWddID0gdHlwZWRBcnJheVRhZ3NbYm9vbFRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxudHlwZWRBcnJheVRhZ3NbZXJyb3JUYWddID0gdHlwZWRBcnJheVRhZ3NbZnVuY1RhZ10gPVxudHlwZWRBcnJheVRhZ3NbbWFwVGFnXSA9IHR5cGVkQXJyYXlUYWdzW251bWJlclRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxudHlwZWRBcnJheVRhZ3Nbc2V0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3N0cmluZ1RhZ10gPVxudHlwZWRBcnJheVRhZ3Nbd2Vha01hcFRhZ10gPSBmYWxzZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1R5cGVkQXJyYXlgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzVHlwZWRBcnJheSh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJlxuICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuYXJ5YCB3aXRob3V0IHN1cHBvcnQgZm9yIHN0b3JpbmcgbWV0YWRhdGEuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNhcCBhcmd1bWVudHMgZm9yLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlVW5hcnkoZnVuYykge1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VVbmFyeTtcbiIsImltcG9ydCBmcmVlR2xvYmFsIGZyb20gJy4vX2ZyZWVHbG9iYWwuanMnO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5leHBvcnQgZGVmYXVsdCBub2RlVXRpbDtcbiIsImltcG9ydCBiYXNlSXNUeXBlZEFycmF5IGZyb20gJy4vX2Jhc2VJc1R5cGVkQXJyYXkuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IG5vZGVVdGlsIGZyb20gJy4vX25vZGVVdGlsLmpzJztcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNUeXBlZEFycmF5ID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNUeXBlZEFycmF5O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSB0eXBlZCBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDMuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KG5ldyBVaW50OEFycmF5KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShbXSk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNUeXBlZEFycmF5ID0gbm9kZUlzVHlwZWRBcnJheSA/IGJhc2VVbmFyeShub2RlSXNUeXBlZEFycmF5KSA6IGJhc2VJc1R5cGVkQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzVHlwZWRBcnJheTtcbiIsImltcG9ydCBiYXNlVGltZXMgZnJvbSAnLi9fYmFzZVRpbWVzLmpzJztcbmltcG9ydCBpc0FyZ3VtZW50cyBmcm9tICcuL2lzQXJndW1lbnRzLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNCdWZmZXIgZnJvbSAnLi9pc0J1ZmZlci5qcyc7XG5pbXBvcnQgaXNJbmRleCBmcm9tICcuL19pc0luZGV4LmpzJztcbmltcG9ydCBpc1R5cGVkQXJyYXkgZnJvbSAnLi9pc1R5cGVkQXJyYXkuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TGlrZUtleXM7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGxpa2VseSBhIHByb3RvdHlwZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNQcm90b3R5cGUodmFsdWUpIHtcbiAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgIHByb3RvID0gKHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3Rvci5wcm90b3R5cGUpIHx8IG9iamVjdFByb3RvO1xuXG4gIHJldHVybiB2YWx1ZSA9PT0gcHJvdG87XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzUHJvdG90eXBlO1xuIiwiLyoqXG4gKiBDcmVhdGVzIGEgdW5hcnkgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGl0cyBhcmd1bWVudCB0cmFuc2Zvcm1lZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gd3JhcC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgYXJndW1lbnQgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJBcmcoZnVuYywgdHJhbnNmb3JtKSB7XG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gZnVuYyh0cmFuc2Zvcm0oYXJnKSk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG92ZXJBcmc7XG4iLCJpbXBvcnQgb3ZlckFyZyBmcm9tICcuL19vdmVyQXJnLmpzJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpO1xuXG5leHBvcnQgZGVmYXVsdCBuYXRpdmVLZXlzO1xuIiwiaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBuYXRpdmVLZXlzIGZyb20gJy4vX25hdGl2ZUtleXMuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmtleXNgIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXMob2JqZWN0KSB7XG4gIGlmICghaXNQcm90b3R5cGUob2JqZWN0KSkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYga2V5ICE9ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VLZXlzO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhc3luY1RhZyA9ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgIHByb3h5VGFnID0gJ1tvYmplY3QgUHJveHldJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYEZ1bmN0aW9uYCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oXyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0Z1bmN0aW9uKC9hYmMvKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gIC8vIGluIFNhZmFyaSA5IHdoaWNoIHJldHVybnMgJ29iamVjdCcgZm9yIHR5cGVkIGFycmF5cyBhbmQgb3RoZXIgY29uc3RydWN0b3JzLlxuICB2YXIgdGFnID0gYmFzZUdldFRhZyh2YWx1ZSk7XG4gIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzRnVuY3Rpb247XG4iLCJpbXBvcnQgaXNGdW5jdGlvbiBmcm9tICcuL2lzRnVuY3Rpb24uanMnO1xuaW1wb3J0IGlzTGVuZ3RoIGZyb20gJy4vaXNMZW5ndGguanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UuIEEgdmFsdWUgaXMgY29uc2lkZXJlZCBhcnJheS1saWtlIGlmIGl0J3NcbiAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAqIGVxdWFsIHRvIGAwYCBhbmQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUmAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNBcnJheUxpa2U7XG4iLCJpbXBvcnQgYXJyYXlMaWtlS2V5cyBmcm9tICcuL19hcnJheUxpa2VLZXlzLmpzJztcbmltcG9ydCBiYXNlS2V5cyBmcm9tICcuL19iYXNlS2V5cy5qcyc7XG5pbXBvcnQgaXNBcnJheUxpa2UgZnJvbSAnLi9pc0FycmF5TGlrZS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBrZXlzO1xuIiwiaW1wb3J0IGJhc2VWYWx1ZXMgZnJvbSAnLi9fYmFzZVZhbHVlcy5qcyc7XG5pbXBvcnQga2V5cyBmcm9tICcuL2tleXMuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8udmFsdWVzKG5ldyBGb28pO1xuICogLy8gPT4gWzEsIDJdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogXy52YWx1ZXMoJ2hpJyk7XG4gKiAvLyA9PiBbJ2gnLCAnaSddXG4gKi9cbmZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlVmFsdWVzKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsdWVzO1xuIiwiaW1wb3J0IHNodWZmbGVTZWxmIGZyb20gJy4vX3NodWZmbGVTZWxmLmpzJztcbmltcG9ydCB2YWx1ZXMgZnJvbSAnLi92YWx1ZXMuanMnO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNodWZmbGVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTaHVmZmxlO1xuIiwiaW1wb3J0IGFycmF5U2h1ZmZsZSBmcm9tICcuL19hcnJheVNodWZmbGUuanMnO1xuaW1wb3J0IGJhc2VTaHVmZmxlIGZyb20gJy4vX2Jhc2VTaHVmZmxlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBzaHVmZmxlZCB2YWx1ZXMsIHVzaW5nIGEgdmVyc2lvbiBvZiB0aGVcbiAqIFtGaXNoZXItWWF0ZXMgc2h1ZmZsZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyLVlhdGVzX3NodWZmbGUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICogLy8gPT4gWzQsIDEsIDMsIDJdXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNodWZmbGUgOiBiYXNlU2h1ZmZsZTtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNodWZmbGU7XG4iLCJpbXBvcnQgKiBhcyBfIGZyb20gXCJsb2Rhc2hcIjtcclxuaW1wb3J0IHsgaCwgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IE11dGFibGVSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgTWFuYWdlZENoaWxkSW5mbywgTWFuYWdlZENoaWxkcmVuIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcclxuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5pbXBvcnQgbG9kYXNoU2h1ZmZsZSBmcm9tIFwibG9kYXNoLWVzL3NodWZmbGVcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEdldEluZGV4PEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHJvdzogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+KSA9PiAobnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZCk7XHJcbmV4cG9ydCB0eXBlIEdldFZhbHVlPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gPSAocm93OiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4sIC4uLmFyZ3M6IEcpID0+IFY7XHJcbmV4cG9ydCB0eXBlIENvbXBhcmU8Vj4gPSAobGhzOiBWLCByaHM6IFYpID0+IG51bWJlcjtcclxuXHJcbi8qKlxyXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cclxuICovXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXN0IHJldHVybiwgZS5nLiwgdGhlIHJvdyBpbmRleCBvZiB0aGlzIGNoaWxkXHJcbiAgICAgKiAoVXN1YWxseSBqdXN0IGFuIGBpbmRleGAgcHJvcClcclxuICAgICAqL1xyXG4gICAgZ2V0SW5kZXg6IEdldEluZGV4PEMsIEs+O1xyXG59XHJcblxyXG4vKipcclxuICogQWxsIG9mIHRoZXNlIGZ1bmN0aW9ucyAqKk1VU1QqKiBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXHJcbiAqL1xyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+IHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0aGlzIGNoaWxkIHVzZXMgUkU6IHNvcnRpbmcuXHJcbiAgICAgKiBJZiB5b3UgZG9uJ3QgY2FyZSBhYm91dCBzb3J0aW5nICh5b3UganVzdCB1c2UgXHJcbiAgICAgKiB5b3VyIG93bmFyYml0cmFyeSByZW9yZGVyaW5nKSwgdGhpcyB3aWxsIG5ldmVyXHJcbiAgICAgKiBiZSB1c2VkLCBzbyBpdCBjYW4gcmV0dXJuIGFueXRoaW5nLlxyXG4gICAgICogQHBhcmFtIHJvdyBcclxuICAgICAqIEBwYXJhbSBhcmdzIFxyXG4gICAgICovXHJcbiAgICBnZXRWYWx1ZTogR2V0VmFsdWU8QywgSywgRywgVj47XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBDb250cm9scyBob3cgdmFsdWVzIGNvbXBhcmUgYWdhaW5zdCBlYWNoIG90aGVyLlxyXG4gICAgICogQHBhcmFtIGxocyBcclxuICAgICAqIEBwYXJhbSByaHMgXHJcbiAgICAgKi9cclxuICAgIGNvbXBhcmU6IENvbXBhcmU8Vj47XHJcbn1cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxyXG4gKiBcclxuICogKlRoaXMgaXMgKipzZXBhcmF0ZSoqIGZyb20gXCJtYW5hZ2VkXCIgY2hpbGRyZW4sIHdoaWNoIGNhbiBiZSBhbnkgbGV2ZWwgb2YgY2hpbGQgbmVlZGVkISBTb3J0YWJsZS9yZWFycmFuZ2VhYmxlIGNoaWxkcmVuIG11c3QgYmUgKipkaXJlY3QgZGVzY2VuZGFudHMqKiBvZiB0aGUgcGFyZW50IHRoYXQgdXNlcyB0aGlzIGhvb2shKlxyXG4gKiBcclxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxyXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXHJcbiAqIHRoaXMgaG9vayBpbXBvc2VzIHNlcmlvdXMgcmVzdHJpY3Rpb25zIG9uIGNoaWxkIHN0cnVjdHVyZSwgd2hpbGUgYHVzZUxpc3ROYXZpZ2F0aW9uYCBhbGxvd3MgYW55dGhpbmcuXHJcbiAqIFxyXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxyXG4gKiBzb3J0IGFsbCBjaGlsZHJlbiBhY2NvcmRpbmcgdG8gdGhlaXIgdmFsdWUgZnJvbSB0aGUgYGdldFZhbHVlYCBhcmd1bWVudCB5b3UgcGFzcyBpbi5cclxuICogXHJcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxyXG4gKiByZS1tYXAgZWFjaCBjaGlsZCdzIHBvc2l0aW9uIHVzaW5nIGBtYW5nbGVNYXBgIGFuZCBgZGVtYW5nbGVNYXBgLCB3aGljaCBjb252ZXJ0IGJldHdlZW5cclxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXHJcbiAqIFxyXG4gKiBBZ2FpbiwgdW5saWtlIHNvbWUgb3RoZXIgaG9va3MsICoqdGhlc2UgY2hpbGRyZW4gbXVzdCBiZSBkaXJlY3QgZGVzY2VuZGFudHMqKi4gVGhpcyBpcyBiZWNhdXNlXHJcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxyXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XHJcbiAqIHRoZXJlJ3Mgbm8gb3RoZXIgdGltZSBvciBwbGFjZSB0aGlzIGNhbiBoYXBwZW4gb3RoZXIgdGhhbiBleGFjdGx5IHdpdGhpbiB0aGUgcGFyZW50IGNvbXBvbmVudCdzIHJlbmRlciBmdW5jdGlvbi5cclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+KHsgZ2V0SW5kZXggfTogVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLPik6IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGU8UGFyZW50RWxlbWVudCwgQywgSz4ge1xyXG5cclxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYSBtYXBwaW5nIGJldHdlZW4gdW5zb3J0ZWQgaW5kZXggPC0tLT4gc29ydGVkIGluZGV4LlxyXG4gICAgLy8gVGhlc2UgYXJlIG5lZWRlZCBmb3IgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzLlxyXG4gICAgY29uc3QgbWFuZ2xlTWFwID0gdXNlUmVmKG5ldyBNYXA8bnVtYmVyLCBudW1iZXI+KCkpO1xyXG4gICAgY29uc3QgZGVtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XHJcbiAgICBjb25zdCBpbmRleE1hbmdsZXIgPSB1c2VDYWxsYmFjaygobjogbnVtYmVyKSA9PiAobWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XHJcbiAgICBjb25zdCBpbmRleERlbWFuZ2xlciA9IHVzZUNhbGxiYWNrKChuOiBudW1iZXIpID0+IChkZW1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xyXG5cclxuICAgIC8vIFRoZSBzb3J0IGZ1bmN0aW9uIG5lZWRzIHRvIGJlIGFibGUgdG8gdXBkYXRlIHdob2V2ZXIgaGFzIGFsbCB0aGUgc29ydGFibGUgY2hpbGRyZW4uXHJcbiAgICAvLyBCZWNhdXNlIHRoYXQgbWlnaHQgbm90IGJlIHRoZSBjb25zdW1lciBvZiAqdGhpcyogaG9vayBkaXJlY3RseSAoZS5nLiBhIHRhYmxlIHVzZXNcclxuICAgIC8vIHRoaXMgaG9vaywgYnV0IGl0J3MgdGJvZHkgdGhhdCBhY3R1YWxseSBuZWVkcyB1cGRhdGluZyksIHdlIG5lZWQgdG8gcmVtb3RlbHlcclxuICAgIC8vIGdldCBhbmQgc2V0IGEgZm9yY2VVcGRhdGUgZnVuY3Rpb24uXHJcbiAgICAvL2NvbnN0IFtnZXRGb3JjZVVwZGF0ZSwgc2V0Rm9yY2VVcGRhdGVdID0gdXNlUGFzc2l2ZVN0YXRlPG51bGwgfCAoKCkgPT4gdm9pZCk+KG51bGwsIHJldHVybk51bGwpO1xyXG4gICAgY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XHJcblxyXG4gICAgY29uc3QgcmVhcnJhbmdlID0gdXNlQ2FsbGJhY2soKHNvcnRlZFJvd3M6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB7XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBvdXIgc29ydGVkIDwtLT4gdW5zb3J0ZWQgaW5kaWNlcyBtYXAgXHJcbiAgICAgICAgLy8gYW5kIHJlcmVuZGVyIHRoZSB3aG9sZSB0YWJsZSwgYmFzaWNhbGx5XHJcbiAgICAgICAgZm9yIChsZXQgaW5kZXhBc1NvcnRlZCA9IDA7IGluZGV4QXNTb3J0ZWQgPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytpbmRleEFzU29ydGVkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4QXNVbnNvcnRlZCA9IHNvcnRlZFJvd3NbaW5kZXhBc1NvcnRlZF0uaW5kZXg7XHJcblxyXG4gICAgICAgICAgICBtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1Vuc29ydGVkLCBpbmRleEFzU29ydGVkKTtcclxuICAgICAgICAgICAgZGVtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1NvcnRlZCwgaW5kZXhBc1Vuc29ydGVkKTtcclxuICAgICAgICB9XHJcblxyXG5cclxuICAgICAgICBnZXRGb3JjZVVwZGF0ZSgpPy4oKTtcclxuICAgIH0sIFtdKTtcclxuXHJcbiAgICBjb25zdCB1c2VSZWFycmFuZ2VhYmxlUHJvcHMgPSB1c2VDYWxsYmFjaygoeyBjaGlsZHJlbiwgLi4ucHJvcHMgfTogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfSkgPT4ge1xyXG5cclxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHsgc2V0Rm9yY2VVcGRhdGUoX3ByZXYgPT4gZm9yY2VVcGRhdGUpOyB9LCBbZm9yY2VVcGRhdGVdKVxyXG5cclxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcclxuICAgICAgICAgICAgY2hpbGRyZW46IFxyXG4gICAgICAgICAgICAoY2hpbGRyZW4gYXMgVk5vZGU8TWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+PltdKVxyXG4gICAgICAgICAgICAuc2xpY2UoKVxyXG4gICAgICAgICAgICAubWFwKGNoaWxkID0+ICh7IGNoaWxkLCBtYW5nbGVkSW5kZXg6IGluZGV4TWFuZ2xlcihnZXRJbmRleChjaGlsZC5wcm9wcyEpISksIGRlbWFuZ2xlZEluZGV4OiBnZXRJbmRleChjaGlsZC5wcm9wcykgfSkpXHJcbiAgICAgICAgICAgIC5zb3J0KChsaHMsIHJocykgPT4geyByZXR1cm4gbGhzLm1hbmdsZWRJbmRleCAtIHJocy5tYW5nbGVkSW5kZXggfSlcclxuICAgICAgICAgICAgLm1hcCgoeyBjaGlsZCwgbWFuZ2xlZEluZGV4LCBkZW1hbmdsZWRJbmRleCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaChjaGlsZC50eXBlIGFzIGFueSwgeyAuLi5jaGlsZC5wcm9wcywga2V5OiBkZW1hbmdsZWRJbmRleCwgXCJkYXRhLW1hbmdsZWQtaW5kZXhcIjogbWFuZ2xlZEluZGV4LCBcImRhdGEtdW5tYW5nbGVkLWluZGV4XCI6IGRlbWFuZ2xlZEluZGV4IH0pO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgIH0sIHByb3BzKSk7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCBpbmRleE1hbmdsZXIsIGluZGV4RGVtYW5nbGVyLCBtYW5nbGVNYXAsIGRlbWFuZ2xlTWFwLCByZWFycmFuZ2UgfTtcclxufVxyXG5cclxuXHJcbi8qKlxyXG4gKiBIb29rIHRoYXQgYWxsb3dzIGZvciB0aGUgKipkaXJlY3QgZGVzY2VuZGFudCoqIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IHRvIGJlIHJlLW9yZGVyZWQgYW5kIHNvcnRlZC5cclxuICogXHJcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISogXHJcbiAqIFxyXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXHJcbiAqIGZ1bmN0aW9ucyB0aGF0IHRoaXMgaG9vayByZXR1cm5zLiBgdXNlTGlzdE5hdmlnYXRpb25gIGRvZXMgbm90IGRpcmVjdGx5IHVzZSB0aGlzIGhvb2sgYmVjYXVzZSwgYXMgbWVudGlvbmVkLCBcclxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cclxuICogXHJcbiAqIEJlc2lkZXMgdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgdGhhdCdzIHJldHVybmVkLCB0aGUgYHNvcnRgIGZ1bmN0aW9uIHRoYXQncyByZXR1cm5lZCB3aWxsXHJcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxyXG4gKiBcclxuICogSWYgeW91IHdhbnQgdG8gcGVyZm9ybSBzb21lIHJlLW9yZGVyaW5nIG9wZXJhdGlvbiB0aGF0J3MgKm5vdCogYSBzb3J0LCB5b3UgY2FuIG1hbnVhbGx5XHJcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxyXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cclxuICogXHJcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcclxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXHJcbiAqIEJlY2F1c2Uga2V5cyBhcmUgZ2l2ZW4gc3BlY2lhbCB0cmVhdG1lbnQgYW5kIGEgY2hpbGQgaGFzIG5vIHdheSBvZiBtb2RpZnlpbmcgaXRzIG93biBrZXlcclxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZVNvcnRhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXSwgVj4oeyBnZXRJbmRleCwgZ2V0VmFsdWUsIGNvbXBhcmU6IHVzZXJDb21wYXJlIH06IFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEssIEcsIFY+KTogVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGU8UGFyZW50RWxlbWVudCwgQywgSywgRz4ge1xyXG5cclxuICAgIGNvbnN0IGNvbXBhcmUgPSAodXNlckNvbXBhcmUgPz8gZGVmYXVsdENvbXBhcmUpO1xyXG5cclxuICAgIGNvbnN0IHsgcmVhcnJhbmdlLCB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IHVzZVNvcnRhYmxlUHJvcHMsIC4uLnJlc3QgfSA9IHVzZVJlYXJyYW5nZWFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLPih7IGdldEluZGV4IH0pO1xyXG5cclxuICAgIC8vIFRoZSBhY3R1YWwgc29ydCBmdW5jdGlvbi5cclxuICAgIGNvbnN0IHNvcnQgPSB1c2VDYWxsYmFjaygobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIiwgLi4uYXJnczogRyk6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcclxuXHJcbiAgICAgICAgY29uc3Qgc29ydGVkUm93cyA9IG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKS5zb3J0KChsaHNSb3csIHJoc1JvdykgPT4ge1xyXG5cclxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBnZXRWYWx1ZShsaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcclxuICAgICAgICAgICAgY29uc3QgcmhzVmFsdWUgPSBnZXRWYWx1ZShyaHNSb3csIC4uLmFyZ3MpIGFzIGFueTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY29tcGFyZShsaHNWYWx1ZSwgcmhzVmFsdWUpIC8vIGxoc1Jvdy5nZXRNYW5hZ2VkQ2VsbHMoKT8uW2NvbHVtbl0/LnZhbHVlLCByaHNSb3cuZ2V0TWFuYWdlZENlbGxzKCk/Lltjb2x1bW5dPy52YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gLXJlc3VsdDtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuXHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc29ydGVkUm93cyk7XHJcblxyXG4gICAgfSwgWyAvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcclxuXHJcbiAgICBjb25zdCBzaHVmZmxlID0gdXNlQ2FsbGJhY2soKG1hbmFnZWRSb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBDLCBLPik6IFByb21pc2U8dm9pZD4gfCB2b2lkID0+IHtcclxuICAgICAgICBjb25zdCBzaHVmZmxlZFJvd3MgPSBsb2Rhc2hTaHVmZmxlKG1hbmFnZWRSb3dzLmFycmF5U2xpY2UoKSlcclxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XHJcbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XHJcblxyXG4gICAgcmV0dXJuIHsgdXNlU29ydGFibGVQcm9wcywgc29ydCwgcmVhcnJhbmdlLCBzaHVmZmxlLCAuLi5yZXN0IH07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVJlYXJyYW5nZWFibGVQcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB8IHVuZGVmaW5lZDsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XHJcbiAgICAvKipcclxuICAgICAqIFBhc3MgYW4gYXJyYXkgb2Ygbm90LXNvcnRlZCBjaGlsZCBpbmZvcm1hdGlvbiB0byB0aGlzIGZ1bmN0aW9uXHJcbiAgICAgKiBhbmQgdGhlIGNoaWxkcmVuIHdpbGwgcmUtYXJyYW5nZSB0aGVtc2VsdmVzIHRvIG1hdGNoLlxyXG4gICAgICogIFxyXG4gICAgICogKipTVEFCTEUqKlxyXG4gICAgICogIFxyXG4gICAgICogXHJcbiAgICAgKi9cclxuICAgIHJlYXJyYW5nZTogKHJvd3NJbk9yZGVyOiBNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz5bXSkgPT4gdm9pZDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIG1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgRyBleHRlbmRzIGFueVtdPiBleHRlbmRzIE9taXQ8VXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDLCBLPiwgXCJ1c2VSZWFycmFuZ2VhYmxlUHJvcHNcIj4ge1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZVNvcnRhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHNvcnQ6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiLCAuLi5hcmdzOiBHKSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBzaHVmZmxlOiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+KSA9PiBQcm9taXNlPHZvaWQ+IHwgdm9pZDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGRlZmF1bHRDb21wYXJlKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG4gICAgcmV0dXJuIGNvbXBhcmUxKGxocywgcmhzKTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb21wYXJlMyhsaHM6IHN0cmluZyB8IG51bWJlciwgcmhzOiBzdHJpbmcgfCBudW1iZXIpIHtcclxuXHJcbiAgICAgICAgLy8gQ29lcmNlIHN0cmluZ3MgdG8gbnVtYmVycyBpZiB0aGV5IHNlZW0gdG8gc3RheSB0aGUgc2FtZSB3aGVuIHNlcmlhbGl6ZWRcclxuICAgICAgICBpZiAoYCR7K2xoc31gID09PSBsaHMpXHJcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XHJcbiAgICAgICAgaWYgKGAkeytyaHN9YCA9PT0gcmhzKVxyXG4gICAgICAgICAgICByaHMgPSArcmhzO1xyXG5cclxuICAgICAgICAvLyBBdCB0aGlzIHBvaW50LCBpZiBlaXRoZXIgYXJndW1lbnQgaXMgYSBzdHJpbmcsIHR1cm4gdGhlIG90aGVyIG9uZSBpbnRvIG9uZSB0b29cclxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJzdHJpbmdcIilcclxuICAgICAgICAgICAgcmhzID0gYCR7cmhzfWA7XHJcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIGxocyA9IGAke2xoc31gO1xyXG5cclxuICAgICAgICBjb25zb2xlLmFzc2VydCh0eXBlb2YgbGhzID09PSB0eXBlb2YgcmhzKTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgIHJldHVybiBsaHMubG9jYWxlQ29tcGFyZShyaHMgYXMgc3RyaW5nKTtcclxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJudW1iZXJcIilcclxuICAgICAgICAgICAgcmV0dXJuICtsaHMgLSArcmhzO1xyXG5cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUyKGxoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxocyA9PT0gXCJib29sZWFuXCIgfHwgbGhzIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICAgICAgbGhzID0gK2xocztcclxuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gXCJib29sZWFuXCIgfHwgcmhzIGluc3RhbmNlb2YgRGF0ZSlcclxuICAgICAgICAgICAgcmhzID0gK3JocztcclxuICAgICAgICByZXR1cm4gY29tcGFyZTMobGhzLCByaHMpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gY29tcGFyZTEobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBudWxsXHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCB8fCByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBPbmUgb2YgdGhlIHR3byBpcyBudWxsIC0tIGVhc3kgY2FzZVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzICE9IG51bGwgPyAxIDogLTFcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUyKGxocywgcmhzKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRyZW4sIHVzZUNoaWxkcmVuRmxhZyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCIuL3VzZS1lZmZlY3RcIjtcclxuaW1wb3J0IHsgdXNlTGluZWFyTmF2aWdhdGlvbiwgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlLCB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uLCBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Uta2V5Ym9hcmQtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcclxuaW1wb3J0IHsgdXNlRW5zdXJlU3RhYmlsaXR5IH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUm92aW5nVGFiSW5kZXgsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZSwgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGUsIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbyB9IGZyb20gXCIuL3VzZS1yb3ZpbmctdGFiaW5kZXhcIjtcclxuaW1wb3J0IHsgdXNlU29ydGFibGVDaGlsZHJlbiwgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGUgfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG5cclxuLyoqXHJcbiAqIFxyXG4gKiBUT0RPOiBUaGlzIHRhYmxlIHdhcyBzY3JhcHBlZCB3aGVuIHRoaXMgd2FzIGNoYW5nZWQgdG8ganVzdCBhY2NlcHQgYSBjb2xsYXRvciBkaXJlY3RseSxcclxuICogYnV0IGl0J3Mgbm90IGJhZCBmb3IgYSBjb2xsYXRpb24gY3Jhc2ggY291cnNlIGFuZCBJIG1pZ2h0IHVzZSBpdCBhZ2Fpbi5cclxuICogRXZlbiBqdXN0IGFzIGEgXCJ0aGlzIGlzIHdoeSBpdCdzIGltcG9ydGFudCBhbmQgZ29vZCB0byB1c2UgdGhlc2UgdGhpbmdzXCIgdGhpbmcuXHJcbiAqIFxyXG4gKiB8TGFuZy58VGFyZ2V0fFVzZXIgaW5wdXR8YGJhc2VgfGBhY2NlbnRgfGBjYXNlYHxgdmFyaWFudGB8XHJcbiAqIHwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfFxyXG4gKiB8RU58SGl8QnllfOKdjHzinYx84p2MfOKdjHxcclxuICogfEVOfEhpfEhpfOKchXzinIV84pyFfOKchXxcclxuICogfEVOfEhpfO+8qO+9iXzinIV84pyFfOKchXzinYx8XHJcbiAqIHxFTnxIaXxoaXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxFTnxIaXxIw6984pyFfOKdjHzinYx84p2MfFxyXG4gKiB8RU58w6V8YWF84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxyXG4gKiB8REF8w6V8QUF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8REF8w6V8QWF84pyFfOKchXzinYx84p2MfFxyXG4gKiB8REF8w6V8YUF84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8RU58w6V8YXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxEQXzDpXxhfOKchXzinIV84p2MfOKdjHxcclxuICogfEpQfO+qqnznnYB84pyFfOKchXzinIV84pyFfFxyXG4gKiB8SlB844KrfO+9tnzinIV84pyFfOKchXzinIV8XHJcbiAqIHxKUHzjgqt844GLfOKchXzinIV84pyFfOKdjHxcclxuICogfEpQfOOCq3zjg7V84pyFfOKchXzinIV84p2MfFxyXG4gKiB8SlB844KrfOOLlXzinIV84pyFfOKdjHzinYx8XHJcbiAqIHxKUHzjgqt844KsfOKchXzinYx84p2MfOKdjHxcclxuICogfEpQfOOCq3zlipt84p2MfOKdjHzinYx84p2MfFxyXG4gKiB8Wkh857SFfOe6onzinYx84p2MfOKdjHzinYx8XHJcbiAqIFxyXG4gKiBcclxuICogKE5vdGUgdG8gc2VsZjogQXQgc29tZSBwb2ludCwgdGhpcyBmaWxlIHdpbGwgcHJvYmFibHkgYmUgbm9ybWFsaXplZFxyXG4gKiBieSBzb21lYm9keSBhbmQg76qqIHdpbGwgdHVybiBiYWNrIGludG8g552ALilcclxuICogXHJcbiAqL1xyXG5jb25zdCBfZHVtbXk6IGFueSA9IG51bGw7XHJcblxyXG5cclxuZnVuY3Rpb24gaWRlbnRpdHk8VD4odDogVCkgeyByZXR1cm4gdDsgfVxyXG50eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcclxuXHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4ge1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG5cclxuICAgIHN1YkluZm86IEM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gZnJvbVVzZXJJbnRlcmFjdGlvbiBXaGV0aGVyIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGlzIGNoaWxkIGFzIGEgbWVhbnMgb2YgbmF2aWdhdGluZyB0byBpdC4gIEluIHRoYXQgd2FzIHRoZSBjYXNlLCB0aGUgY2hpbGQgaXMgYWxzbyBmb2N1c2VkLiBPdGhlcndpc2UsIGZvY3VzIG1vdmVzIGFzIHRoZSBicm93c2VyIGRldGVybWluZXMuXHJcbiAqL1xyXG5leHBvcnQgdHlwZSBOYXZpZ2F0ZVRvSW5kZXggPSAoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4gdm9pZDtcclxuXHJcblxyXG5cclxuXHJcbi8vICoqKiBQYXJhbWV0ZXJzIChsaXN0LCBsaXN0LXNpbmdsZSwgbGlzdC1jaGlsZCwgbGlzdC1zaW5nbGUtY2hpbGQpXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzIGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzIHtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiB7XHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoaXMgYW5kIGluZGV4RGVtYW5nbGVyIGFyZSB1c2VkIHRvIGFsbG93IGNoaWxkcmVuIHRvIGJlIG5hdmlnYXRlZCBpbiBhbiBvcmRlclxyXG4gICAgICAgICAqIHRoYXQgZG9lc24ndCBuZWNlc3NhcmlseSBtYXRjaCB0aGVpciBjaGlsZCBvcmRlciwgbGlrZSBpZiBhIGxpc3QgaXMgc29ydGVkLlxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIFVzZWQgdG8gdHVybiBhbiBcImFic29sdXRlXCIgaW5kZXggaW50byBhIFwic29ydGVkL2ZpbHRlcmVkL21hbmdsZWRcIiBvbmUuXHJcbiAgICAgICAgICogXHJcbiAgICAgICAgICogRm9yIGV4YW1wbGUsIG5hdmlnYXRlVG9GaXJzdCBtYW5nbGVzIDAgYW5kIG5hdmlnYXRlcyB0byB0aGF0IHJlc3VsdGluZyByb3cuXHJcbiAgICAgICAgICogQHBhcmFtIHJhd0luZGV4IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluZGV4TWFuZ2xlcj8ocmF3SW5kZXg6IG51bWJlcik6IG51bWJlcjtcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVXNlZCB0byB0dXJuIGEgXCJtYW5nbGVkXCIgaW5kZXggaW50byBpdCdzIFwidW5zb3J0ZWRcIiBvciBcInVubWFuZ2xlZFwiIGluZGV4LlxyXG4gICAgICAgICAqIFxyXG4gICAgICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleCxcclxuICAgICAgICAgKiBpdCBuZWVkcyB0byBiZSBkZW1hbmdsZWQgdG8gZG8gXCJub3JtYWxcIiBtYXRoIG9uIGl0LCBhbmQgdGhlbiByZS1tYW5nbGVkIChhYm92ZSlcclxuICAgICAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxyXG4gICAgICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1lZEluZGV4IFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XHJcbiAgICB9XHJcblxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogT21pdDxVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVycywgXCJnZXRJbmRleFwiIHwgXCJzZXRJbmRleFwiPjtcclxuICAgIGxpbmVhck5hdmlnYXRpb246IE9taXQ8VXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIFwibmF2aWdhdGVUb0ZpcnN0XCIgfCBcIm5hdmlnYXRlVG9MYXN0XCIgfCBcIm5hdmlnYXRlVG9OZXh0XCIgfCBcIm5hdmlnYXRlVG9QcmV2XCI+O1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzIGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzIHsgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7IH0gfVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXM+IHtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPjtcclxufVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyB8IFwic2VsZWN0ZWRcIj4geyB9XHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gKioqIFJldHVybiB0eXBlcyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xyXG4gICAgT21pdDxVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGU8Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4sIFwidXNlUm92aW5nVGFiSW5kZXhDaGlsZFwiPixcclxuICAgIE9taXQ8VXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiwgXCJ1c2VUeXBlYWhlYWROYXZpZ2F0aW9uUHJvcHNcIiB8IFwidXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkXCI+LFxyXG4gICAgT21pdDxVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+LCBcInVzZUxpbmVhck5hdmlnYXRpb25Qcm9wc1wiPiB7XHJcblxyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+O1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XHJcblxyXG4gICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4OiBOYXZpZ2F0ZVRvSW5kZXggfTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PiwgXCJ1c2VSb3ZpbmdUYWJJbmRleENoaWxkUHJvcHNcIj4ge1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2hpbGRFbGVtZW50PjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+LCBcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRcIiB8IFwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiPiB7XHJcbiAgICAvKiogKipTVEFCTEUqKiAqL1xyXG4gICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPltcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIl07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+IHtcclxuICAgIHNpbmdsZVNlbGVjdGlvbjoge1xyXG4gICAgICAgIHNlbGVjdGVkOiBib29sZWFuO1xyXG4gICAgICAgIGdldFNlbGVjdGVkKCk6IGJvb2xlYW47XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEs+KSA9PiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IHR5cGUgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGU8Q2hpbGRFbGVtZW50PjtcclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEltcGxlbWVudHMgcHJvcGVyIGtleWJvYXJkIG5hdmlnYXRpb24gZm9yIGNvbXBvbmVudHMgbGlrZSBsaXN0Ym94ZXMsIGJ1dHRvbiBncm91cHMsIG1lbnVzLCBldGMuXHJcbiAqIFxyXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXHJcbiAqIE5hdmlnYXRpbmcgZm9yd2FyZHMvYmFja3dhcmRzIGNhbiBiZSBkb25lIHdpdGggdGhlIGFycm93IGtleXMsIEhvbWUvRW5kIGtleXMsIG9yIGFueSBhbnkgdGV4dCBmb3IgdHlwZWFoZWFkIHRvIGZvY3VzIHRoZSBuZXh0IGl0ZW0gdGhhdCBtYXRjaGVzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPih7XHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxyXG4gICAgcm92aW5nVGFiSW5kZXgsXHJcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgdHlwZWFoZWFkTmF2aWdhdGlvblxyXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMpOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XHJcbiAgICBpbmRleE1hbmdsZXIgPz89IGlkZW50aXR5O1xyXG4gICAgaW5kZXhEZW1hbmdsZXIgPz89IGlkZW50aXR5O1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxpc3ROYXZpZ2F0aW9uXCIsIGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIpO1xyXG5cclxuXHJcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXhcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgbWFuYWdlZENoaWxkcmVuOiB7IGNoaWxkcmVuIH0sIHJvdmluZ1RhYkluZGV4OiB7IGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSB9ID0gcGFyZW50UmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xyXG4gICAgICAgIGlmIChpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dEluZGV4ID0gdHJ5TmF2aWdhdGVUb0luZGV4KHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGksXHJcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXHJcbiAgICAgICAgICAgICAgICBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSxcclxuICAgICAgICAgICAgICAgIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpID09IG51bGwgPyBudWxsIDogbmV4dEluZGV4LCBmcm9tVXNlckludGVyYWN0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgobnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcclxuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcclxuICAgICAgICAgICAgaW52YWxpZFR5cGVhaGVhZFxyXG4gICAgICAgIH1cclxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XHJcbiAgICAgICAgZ2V0SW5kZXg6IGdldFRhYmJhYmxlSW5kZXgsXHJcbiAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaW5kZXgsIHRydWUpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHsgdXNlTGluZWFyTmF2aWdhdGlvblByb3BzIH0gPSB1c2VMaW5lYXJOYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XHJcbiAgICAgICAgbmF2aWdhdGVUb1ByZXY6IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChjID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKChjID8/IDApKSAtIDEpLCBzZWFyY2hEaXJlY3Rpb246IC0xLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pXHJcbiAgICAgICAgICAgIH0sIHRydWUpXHJcbiAgICAgICAgfSwgW10pLFxyXG4gICAgICAgIG5hdmlnYXRlVG9OZXh0OiB1c2VDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ5TmF2aWdhdGVUb0luZGV4KHsgY2hpbGRyZW4sIGRlZmF1bHQ6IGMgPz8gMCwgdGFyZ2V0OiBpbmRleERlbWFuZ2xlciEoaW5kZXhNYW5nbGVyIShjID8/IDApICsgMSksIHNlYXJjaERpcmVjdGlvbjogMSwgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksIGluZGV4RGVtYW5nbGVyOiBpbmRleERlbWFuZ2xlciA/PyBpZGVudGl0eSB9KTtcclxuICAgICAgICAgICAgfSwgdHJ1ZSlcclxuICAgICAgICB9LCBbXSksXHJcbiAgICAgICAgbmF2aWdhdGVUb0ZpcnN0OiB1c2VDYWxsYmFjaygoKSA9PiB7IG5hdmlnYXRlVG9JbmRleChpbmRleERlbWFuZ2xlciEoMCksIHRydWUpOyB9LCBbXSksXHJcbiAgICAgICAgbmF2aWdhdGVUb0xhc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyIShjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSksIHRydWUpOyB9LCBbXSksXHJcbiAgICAgICAgLi4ubGluZWFyTmF2aWdhdGlvblxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JDaGlsZEVsZW1lbnQ+ID0+IHtcclxuICAgICAgICByZXR1cm4gdXNlTGluZWFyTmF2aWdhdGlvblByb3BzKHVzZVR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyhwcm9wcykpO1xyXG4gICAgfSwgW3VzZUxpbmVhck5hdmlnYXRpb25Qcm9wcywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvblByb3BzXSk7XHJcblxyXG5cclxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW4gfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dCwgc3ViSW5mbyB9IH0pID0+IHtcclxuXHJcbiAgICAgICAgY29uc3QgX3Y6IHZvaWQgPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQoeyB0ZXh0LCBpbmRleCB9KTtcclxuICAgICAgICBjb25zdCBnZXRJbmRleCA9IHVzZVN0YWJsZUdldHRlcihpbmRleCk7XHJcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VGFiYmFibGVJbmRleCgpID09IGdldEluZGV4KCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXgsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LCBbXSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgdXNlUm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xyXG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRUYWJiYWJsZSxcclxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCBoaWRkZW46ICEhaGlkZGVuLCBzdWJJbmZvOiB7IHRleHQsIHN1YkluZm8gfSB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wczogKHA6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4gPSBmdW5jdGlvbiAoeyAuLi5wcm9wcyB9KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxDaGlsZEVsZW1lbnQ+KHVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcygoKHsgaW5lcnQ6IGhpZGRlbiB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENoaWxkRWxlbWVudD4pKSksIHByb3BzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcclxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcclxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxyXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXHJcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9LCBbdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLCB1c2VSb3ZpbmdUYWJJbmRleENoaWxkLCBuYXZpZ2F0ZVRvSW5kZXhdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcyxcclxuXHJcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcGFyZW50UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfVxyXG4gICAgICAgIC8qbGlzdE5hdmlnYXRpb246IHsgbmF2aWdhdGVUb0luZGV4IH0sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgZm9jdXNTZWxmLCBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0sXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyBjdXJyZW50VHlwZWFoZWFkLCBpbnZhbGlkVHlwZWFoZWFkIH0qL1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBJdCdzIHZlcnkgY29tbW9uIHRvIGNvbWJpbmUgYSB0YWJiYWJsZSBsaXN0IG9mIHRoaW5ncyBhbmQgXCJzZWxlY3Rpb25cIiBvZiBvbmUgb2YgdGhvc2UgdGhpbmdzLlxyXG4gKiBcclxuICogTGlzdHMsIHJhZGlvIGJ1dHRvbnMsIHRhYnMsIGV0Yy4gZXRjLlxyXG4gKiBcclxuICogVGhpcyBpcyBhIHNob3J0Y3V0IHRoYXQgY29tYmluZXMgdGhlIHR3byB3aXRoIHRoZSBjb3JyZWN0IHR5cGluZy5cclxuICogQHBhcmFtIHBhcmFtMCBcclxuICogQHJldHVybnMgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7XHJcbiAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCB9LFxyXG4gICAgbGlzdE5hdmlnYXRpb24sXHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgLypvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG9jbWMsKi8gLi4ubWMgfSxcclxuICAgIHJvdmluZ1RhYkluZGV4OiB7IGluaXRpYWxJbmRleCwgLi4ucm92aW5nVGFiSW5kZXggfSxcclxuICAgIGxpbmVhck5hdmlnYXRpb24sXHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXHJcbn06IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyk6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XHJcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4oe1xyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge1xyXG4gICAgICAgICAgICAuLi5tYyxcclxuICAgICAgICAgICAgLypvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWV2YWx1YXRlQ2xvc2VzdEZpdCgpO1xyXG4gICAgICAgICAgICAgICAgb2NtYz8uKG1vdW50ZWQsIHVubW91bnRlZCk7XHJcbiAgICAgICAgICAgIH0pKi9cclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XHJcbiAgICAgICAgICAgIGluaXRpYWxJbmRleDogKGluaXRpYWxJbmRleCA/PyBzZWxlY3RlZEluZGV4ID8/IHVuZGVmaW5lZCksXHJcbiAgICAgICAgICAgIC4uLnJvdmluZ1RhYkluZGV4XHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkLFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXHJcbiAgICAgICAgLi4ubGlzdFJlc3RcclxuICAgIH0gPSBwYXJlbnRSZXR1cm5UeXBlO1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjaGFuZ2VJbmRleDogY2hhbmdlU2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBnZXRDdXJyZW50SW5kZXg6IGdldFNlbGVjdGVkSW5kZXgsXHJcbiAgICAgICAgLy9yZWV2YWx1YXRlQ2xvc2VzdEZpdFxyXG4gICAgfSA9IHVzZUNoaWxkcmVuRmxhZzxVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBLIHwgXCJzZWxlY3RlZFwiPih7XHJcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxyXG4gICAgICAgIGluaXRpYWxJbmRleDogc2VsZWN0ZWRJbmRleCxcclxuICAgICAgICBrZXk6IFwic2VsZWN0ZWRcIixcclxuICAgICAgICBjbG9zZXN0Rml0OiBmYWxzZVxyXG4gICAgfSk7XHJcblxyXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjaGFuZ2VTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXgpO1xyXG4gICAgfSwgW3NlbGVjdGVkSW5kZXhdKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LFxyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ6IHVzZUNhbGxiYWNrPFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogcnRpLCBsaXN0TmF2aWdhdGlvbjogbHMgfSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xyXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZFJlZiA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0SXNTZWxlY3RlZCwgc2V0OiBzZXRJc1NlbGVjdGVkLCBpc1ZhbGlkOiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiAhcnRpLmhpZGRlbikgfSk7XHJcblxyXG4gICAgICAgICAgICBjb25zdCB7XHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcclxuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1xyXG4gICAgICAgICAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHtcclxuICAgICAgICAgICAgICAgICAgICBpbmRleCxcclxuICAgICAgICAgICAgICAgICAgICBmbGFnczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZDogc2VsZWN0ZWRSZWYuY3VycmVudCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZmxhZ3NcclxuICAgICAgICAgICAgICAgICAgICB9IGFzIFBhcnRpYWw8UmVjb3JkPEsgfCBcInNlbGVjdGVkXCIgfCBcInRhYmJhYmxlXCIsIENoaWxkRmxhZ09wZXJhdGlvbnM+PlxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGksXHJcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogbHNcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX3JldCxcclxuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZDogaXNTZWxlY3RlZCwgZ2V0U2VsZWN0ZWQ6IGdldElzU2VsZWN0ZWQgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiB1c2VDYWxsYmFjaygoLi4ucDogUGFyYW1ldGVyczx0eXBlb2YgdXNlTGlzdE5hdmlnYXRpb25Qcm9wcz4pID0+IHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHMoLi4ucCkgfSwgW10pLFxyXG4gICAgICAgIC4uLmxpc3RSZXN0XHJcbiAgICB9XHJcbn1cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzIHtcclxuICAgIGxpbmVhck5hdmlnYXRpb246IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1tcImxpbmVhck5hdmlnYXRpb25cIl07XHJcbiAgICBsaXN0TmF2aWdhdGlvbjogT21pdDxVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNbXCJsaXN0TmF2aWdhdGlvblwiXSwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIj47XHJcbiAgICBtYW5hZ2VkQ2hpbGRyZW46IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1tcIm1hbmFnZWRDaGlsZHJlblwiXTtcclxuICAgIHJvdmluZ1RhYkluZGV4OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNbXCJyb3ZpbmdUYWJJbmRleFwiXTtcclxuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc1tcInR5cGVhaGVhZE5hdmlnYXRpb25cIl07XHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4gPSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLPjtcclxuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8QywgSz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENoaWxkRWxlbWVudD47XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBHIGV4dGVuZHMgYW55W10+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiwgXCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXCIgfCBcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIj4ge1xyXG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XHJcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEs+O1xyXG4gICAgc29ydGFibGU6IE9taXQ8VXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGU8YW55LCBDLCBLLCBHPiwgXCJ1c2VTb3J0YWJsZVByb3BzXCI+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgdHlwZWFoZWFkTmF2aWdhdGlvbiB9OiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycyk6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSywgW10+IHtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgaW5kZXhEZW1hbmdsZXIsXHJcbiAgICAgICAgaW5kZXhNYW5nbGVyLFxyXG4gICAgICAgIGRlbWFuZ2xlTWFwLFxyXG4gICAgICAgIG1hbmdsZU1hcCxcclxuICAgICAgICByZWFycmFuZ2UsXHJcbiAgICAgICAgc29ydCxcclxuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxyXG4gICAgICAgIHNodWZmbGVcclxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEssIFtdLCBudW1iZXI+KHtcclxuICAgICAgICBnZXRJbmRleDogdXNlQ2FsbGJhY2soKHJvdykgPT4gcm93LmluZGV4LCBbXSksXHJcbiAgICAgICAgZ2V0VmFsdWU6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxyXG4gICAgICAgIGNvbXBhcmU6IHVzZUNhbGxiYWNrKChsaHMsIHJocykgPT4geyByZXR1cm4gbGhzIC0gcmhzOyB9LCBbXSksXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7XHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcclxuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblByb3BzLFxyXG4gICAgICAgIC4uLnJlc3RcclxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsaW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBtYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMgPSAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IHtcclxuICAgICAgICByZXR1cm4gKHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHModXNlU29ydGFibGVQcm9wcyhwcm9wcykpKVxyXG4gICAgfVxyXG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkID0gKHA6IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEs+KSA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQocClcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKHtcclxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXHJcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkLFxyXG4gICAgICAgIHNvcnRhYmxlOiB7IHNvcnQsIHNodWZmbGUsIHJlYXJyYW5nZSwgZGVtYW5nbGVNYXAsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIG1hbmdsZU1hcCB9LFxyXG4gICAgICAgIC4uLnJlc3RcclxuICAgIH0pO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IHR5cGUgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGFyZ3M6IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEMsIEs+KSA9PiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZTxDaGlsZEVsZW1lbnQ+O1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVycyB7XHJcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNbXCJsaW5lYXJOYXZpZ2F0aW9uXCJdO1xyXG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzW1wibGlzdE5hdmlnYXRpb25cIl0sIFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCI+O1xyXG4gICAgbWFuYWdlZENoaWxkcmVuOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNbXCJtYW5hZ2VkQ2hpbGRyZW5cIl07XHJcbiAgICByb3ZpbmdUYWJJbmRleDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzW1wicm92aW5nVGFiSW5kZXhcIl07XHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNbXCJ0eXBlYWhlYWROYXZpZ2F0aW9uXCJdO1xyXG4gICAgc2luZ2xlU2VsZWN0aW9uOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnNbXCJzaW5nbGVTZWxlY3Rpb25cIl07XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGU8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIEcgZXh0ZW5kcyBhbnlbXT4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+LCBcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRcIiB8IFwidXNlTGlzdE5hdmlnYXRpb25Qcm9wc1wiPiB7XHJcbiAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD5cclxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XHJcbiAgICBzb3J0YWJsZTogT21pdDxVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTxhbnksIEMsIEssIEc+LCBcInVzZVNvcnRhYmxlUHJvcHNcIj47XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCBzaW5nbGVTZWxlY3Rpb24sIHR5cGVhaGVhZE5hdmlnYXRpb24gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMpOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZTxQYXJlbnRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEssIFtdPiB7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGluZGV4RGVtYW5nbGVyLFxyXG4gICAgICAgIGluZGV4TWFuZ2xlcixcclxuICAgICAgICBkZW1hbmdsZU1hcCxcclxuICAgICAgICBtYW5nbGVNYXAsXHJcbiAgICAgICAgcmVhcnJhbmdlLFxyXG4gICAgICAgIHNvcnQsXHJcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcclxuICAgICAgICBzaHVmZmxlXHJcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxQYXJlbnRFbGVtZW50LCBDLCBLLCBbXSwgbnVtYmVyPih7XHJcbiAgICAgICAgZ2V0SW5kZXg6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxyXG4gICAgICAgIGdldFZhbHVlOiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSxcclxuICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjaygobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocyAtIHJoczsgfSwgW10pLFxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcclxuICAgICAgICAuLi5yZXN0XHJcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogbGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyLCAuLi5saXN0TmF2aWdhdGlvbiB9LFxyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiByb3ZpbmdUYWJJbmRleCxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0eXBlYWhlYWROYXZpZ2F0aW9uLFxyXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc2luZ2xlU2VsZWN0aW9uXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMgPSAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IHtcclxuICAgICAgICByZXR1cm4gKHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHModXNlU29ydGFibGVQcm9wcyhwcm9wcykpKTtcclxuICAgIH1cclxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDLCBLPikgPT4ge1xyXG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAoe1xyXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcclxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMsXHJcbiAgICAgICAgc29ydGFibGU6IHsgc29ydCwgc2h1ZmZsZSwgcmVhcnJhbmdlLCBkZW1hbmdsZU1hcCwgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciwgbWFuZ2xlTWFwIH0sXHJcbiAgICAgICAgLi4ucmVzdFxyXG4gICAgfSk7XHJcblxyXG59XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJ5TmF2aWdhdGVUb0luZGV4UGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+PiwgSz47XHJcbiAgICBkZWZhdWx0OiBudW1iZXI7XHJcbiAgICB0YXJnZXQ6IG51bWJlcjtcclxuICAgIHNlYXJjaERpcmVjdGlvbjogMSB8IC0xO1xyXG4gICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XHJcbiAgICBpbmRleERlbWFuZ2xlcjogKG46IG51bWJlcikgPT4gbnVtYmVyO1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHRyeU5hdmlnYXRlVG9JbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBzZWFyY2hEaXJlY3Rpb24sIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHRhcmdldCB9OiBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSz4pIHtcclxuICAgIGNvbnN0IHVwcGVyID0gY2hpbGRyZW4uZ2V0SGlnaGVzdEluZGV4KCk7XHJcbiAgICBjb25zdCBsb3dlciA9IDA7XHJcblxyXG4gICAgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gLTEpIHtcclxuICAgICAgICB3aGlsZSAoKHRhcmdldCA+PSBsb3dlciAmJiAoY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKSlcclxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgLSAxKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRhcmdldCA8IGxvd2VyID8gaW5kZXhEZW1hbmdsZXIobG93ZXIpIDogdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc2VhcmNoRGlyZWN0aW9uID09PSAxKSB7XHJcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQgPD0gdXBwZXIgJiYgY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KSA9PSBudWxsKSB8fCAhIWNoaWxkcmVuLmdldEF0KHRhcmdldCk/LnN1YkluZm8uaGlkZGVuKVxyXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSArIDEpO1xyXG5cclxuICAgICAgICByZXR1cm4gdGFyZ2V0ID4gdXBwZXIgPyBpbmRleERlbWFuZ2xlcih1cHBlcikgOiB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG93ZXI7XHJcbiAgICB9XHJcbn1cclxuXHJcbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xyXG5pbXBvcnQgeyB1c2VMaXN0TmF2aWdhdGlvbiwgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlLCBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcclxuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XHJcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XHJcblxyXG4vKipcclxuICogR3JpZHMgYXJlIGltcGxlbWVudGVkIHVzaW5nIHR3byBzZXRzIG9mIGxpc3QgbmF2aWdhdGlvbi5cclxuICogXHJcbiAqIFRoaXMgcmVzdWx0cyBpbiBhIGxvdCBvZiB0aGluZ3Mgd2l0aCB2ZXJ5IHNpbWlsYXIgbmFtZXMgYW5kIGp1c3QgY29uZnVzaW9uIGFsbCBhcm91bmQuIFBsZWFzZSB1c2UgY2F1dGlvbi5cclxuICovXHJcblxyXG4vLyBQYXJhbWV0ZXJzIChwYXJlbnQsIHJvdywgY2VsbClcclxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMgZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgXCJsaW5lYXJOYXZpZ2F0aW9uXCI+IHtcclxuICAgIGxpbmVhck5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzW1wibGluZWFyTmF2aWdhdGlvblwiXSwgXCJuYXZpZ2F0aW9uRGlyZWN0aW9uXCI+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxDUiwgS1IgZXh0ZW5kcyBzdHJpbmc+IHtcclxuICAgIGFzQ2hpbGRSb3c6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q1IsIEtSPiwgXCJsaXN0TmF2aWdhdGlvblwiPiAmIHsgbGlzdE5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q1IsIEtSPiwgXCJzdWJJbmZvXCI+W1wibGlzdE5hdmlnYXRpb25cIl07IGdyaWROYXZpZ2F0aW9uOiB7IHN1YkluZm86IENSOyB9IH1cclxuICAgIGFzUGFyZW50T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzO1xyXG59XHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDQywgS0MgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgT21pdDxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDQywgS0M+LCBcImxpc3ROYXZpZ2F0aW9uXCI+IHtcclxuICAgIGxpc3ROYXZpZ2F0aW9uOiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENDLCBLQz5bXCJsaXN0TmF2aWdhdGlvblwiXSwgXCJzdWJJbmZvXCI+O1xyXG4gICAgZ3JpZE5hdmlnYXRpb246IHtcclxuICAgICAgICBzdWJJbmZvOiBDQztcclxuICAgIH1cclxufVxyXG5cclxuXHJcbi8vIFJldHVybiB0eXBlcyAocGFyZW50LCByb3csIGNlbGwpXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDUiwgQ0MsIEtSIGV4dGVuZHMgc3RyaW5nLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZTxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIENSLCBLUj4sIFwidXNlTGlzdE5hdmlnYXRpb25DaGlsZFwiIHwgXCJ1c2VMaXN0TmF2aWdhdGlvblByb3BzXCI+IHtcclxuICAgIGdyaWROYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgLy9yb3dzOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Um93RWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPENSPj4sIEtSPjtcclxuICAgICAgICBnZXRDdXJyZW50Q29sdW1uKCk6IG51bWJlciB8IG51bGw7XHJcbiAgICAgICAgY3VycmVudENvbHVtbjogbnVtYmVyIHwgbnVsbDtcclxuICAgIH1cclxuICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93OiBVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ1IsIENDLCBLUiwgS0M+O1xyXG4gICAgdXNlR3JpZE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPclJvd0VsZW1lbnQ+O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ0MsIEtDIGV4dGVuZHMgc3RyaW5nPiB7XHJcbiAgICBhc0NoaWxkUm93OiBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPFJvdz4sIFwidXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXCI+XHJcbiAgICBhc1BhcmVudE9mQ2VsbHM6IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlPFJvdywgQ2VsbCwgQ0MsIEtDPiwgXCJ1c2VMaXN0TmF2aWdhdGlvbkNoaWxkXCIgfCBcInVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNcIj47XHJcbiAgICAvL2NoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2VsbCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPENDPj4sIFwic2VsZWN0ZWRcIiB8IEtDPjtcclxuICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbDogVXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGwsIENDLCBLQz47XHJcbiAgICB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzOiAocHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvdz4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFJvdz47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25DZWxsUmV0dXJuVHlwZTxDZWxsIGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBPbWl0PFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlPENlbGw+LCBcInVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1wiPiB7XHJcbiAgICBncmlkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgIC8vcm93SXNUYWJiYWJsZTogYm9vbGVhbjtcclxuICAgICAgICAvL2dldFJvd0lzVGFiYmFibGUoKTogYm9vbGVhbjtcclxuICAgICAgICBnZXRDdXJyZW50Q29sdW1uKCk6IG51bWJlciB8IG51bGw7XHJcbiAgICB9XHJcbiAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDZWxsPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD47XHJcbn1cclxuXHJcblxyXG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvblJvdzxSb3cgZXh0ZW5kcyBFbGVtZW50LCBDZWxsIGV4dGVuZHMgRWxlbWVudCwgQ1IsIENDLCBLUiBleHRlbmRzIHN0cmluZywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZUdyaWROYXZpZ2F0aW9uUm93UGFyYW1ldGVyczxDUiwgS1I+KSA9PiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGU8Um93LCBDZWxsLCBDQywgS0M+O1xyXG5leHBvcnQgdHlwZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCBleHRlbmRzIEVsZW1lbnQsIENDLCBLQyBleHRlbmRzIHN0cmluZz4gPSAocDogVXNlR3JpZE5hdmlnYXRpb25DZWxsUGFyYW1ldGVyczxDQywgS0M+KSA9PiBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlPENlbGw+O1xyXG5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHcmlkTmF2aWdhdGlvbjxcclxuICAgIFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXHJcbiAgICBSb3dFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcclxuICAgIENlbGxFbGVtZW50IGV4dGVuZHMgRWxlbWVudCxcclxuICAgIFJvd1N1YkluZm8sXHJcbiAgICBDZWxsU3ViSW5mbyxcclxuICAgIFJvd0V4dHJhRmxhZ3MgZXh0ZW5kcyBzdHJpbmcsXHJcbiAgICBDZWxsRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZ1xyXG4+KHtcclxuICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXHJcbiAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxyXG4gICAgbGlzdE5hdmlnYXRpb246IGxzLFxyXG4gICAgbGluZWFyTmF2aWdhdGlvbjogbG4sXHJcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0blxyXG59OiBVc2VHcmlkTmF2aWdhdGlvblBhcmFtZXRlcnMpOiBVc2VHcmlkTmF2aWdhdGlvblJldHVyblR5cGU8UGFyZW50T3JSb3dFbGVtZW50LCBSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgUm93U3ViSW5mbywgQ2VsbFN1YkluZm8sIFJvd0V4dHJhRmxhZ3MsIENlbGxFeHRyYUZsYWdzPiB7XHJcbiAgICBjb25zdCBbY3VycmVudENvbHVtbiwgc2V0Q3VycmVudENvbHVtbiwgZ2V0Q3VycmVudENvbHVtbl0gPSB1c2VTdGF0ZTxudW1iZXIgfCBudWxsPihydGkuaW5pdGlhbEluZGV4ID8/IDApO1xyXG5cclxuICAgIGNvbnN0IHBhcmVudExzUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgUm93U3ViSW5mbywgUm93RXh0cmFGbGFncz4oe1xyXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWMsXHJcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogbHMsXHJcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImJsb2NrXCIsIC4uLmxuIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG4sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCB7IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3csIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQgfSA9IHBhcmVudExzUmV0dXJuVHlwZTtcclxuXHJcbiAgICBjb25zdCB1c2VHcmlkTmF2aWdhdGlvblJvdyA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBSb3dTdWJJbmZvLCBDZWxsU3ViSW5mbywgUm93RXh0cmFGbGFncywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBhc0NoaWxkUm93OiBhc0NoaWxkLCBhc1BhcmVudE9mQ2VsbHM6IGFzUGFyZW50IH0pID0+IHtcclxuICAgICAgICAvLyBPdmVycmlkZSB0aGUgZm9jdXNTZWxmIHRoYXQgcm92aW5nVGFiSW5kZXggZG9lcy5cclxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGZvY3VzaW5nIHRoZSBlbnRpcmUgcm93LCB3ZSBhc2sgdGhlIGNlbGwgdGhhdCBjb3JyZXNwb25kc1xyXG4gICAgICAgIC8vIHRvIG91ciBjdXJyZW50IGNvbHVtbiB0byBmb2N1cyBpdHNlbGYuXHJcbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjMiA9IGdldEN1cnJlbnRDb2x1bW4oKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYHJvdyAjJHthc0NoaWxkLm1hbmFnZWRDaGlsZC5pbmRleH0sJHtjMn0gZm9jdXNTZWxmYCk7XHJcbiAgICAgICAgICAgIGlmIChhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmZvY3VzU2VsZikge1xyXG4gICAgICAgICAgICAgICAgYXNDaGlsZC5yb3ZpbmdUYWJJbmRleC5mb2N1c1NlbGYoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChjMiA/PyAwLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjb25zdCByb3dMc0NoaWxkUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3coe1xyXG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IGFzQ2hpbGQubWFuYWdlZENoaWxkLFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc0NoaWxkLmxpc3ROYXZpZ2F0aW9uIH0sXHJcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzQ2hpbGQucm92aW5nVGFiSW5kZXgsIGZvY3VzU2VsZiB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgeyByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMgfSA9IHJvd0xzQ2hpbGRSZXR1cm5UeXBlO1xyXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGFiYmFibGUpIHtcclxuICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9JbmRleChudWxsLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LCBbdGFiYmFibGVdKTtcclxuXHJcbiAgICAgICAgY29uc3Qgcm93THNSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248Q2VsbEVsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+KHtcclxuICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7IC4uLmFzUGFyZW50Lm1hbmFnZWRDaGlsZHJlbiB9LFxyXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyAuLi5hc1BhcmVudC5yb3ZpbmdUYWJJbmRleCB9LFxyXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XHJcbiAgICAgICAgICAgICAgICAuLi5hc1BhcmVudC5saW5lYXJOYXZpZ2F0aW9uLFxyXG4gICAgICAgICAgICAgICAgbmF2aWdhdGlvbkRpcmVjdGlvbjogXCJpbmxpbmVcIixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC50eXBlYWhlYWROYXZpZ2F0aW9uLCBub1R5cGVhaGVhZDogdHJ1ZSB9LFxyXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC5saXN0TmF2aWdhdGlvbiB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIsIHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHMsIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9IH0gPSByb3dMc1JldHVyblR5cGU7XHJcblxyXG4gICAgICAgIC8vY29uc3Qgcm93SGlkZGVuID0gISFhc0NoaWxkLnJvdmluZ1RhYkluZGV4LmhpZGRlbjtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlR3JpZE5hdmlnYXRpb25DZWxsID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+PigoeyBtYW5hZ2VkQ2hpbGQsIGxpc3ROYXZpZ2F0aW9uOiBscywgcm92aW5nVGFiSW5kZXg6IHsgYmx1clNlbGY6IGJzLCBmb2N1c1NlbGY6IGZzLCAuLi5ydGkgfSwgZ3JpZE5hdmlnYXRpb246IHsgc3ViSW5mbyB9IH0pID0+IHtcclxuICAgICAgICAgICAgLy9ydGkuaGlkZGVuIHx8IHJvd0hpZGRlbjtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBjZWxsICMke21hbmFnZWRDaGlsZC5pbmRleH0gZm9jdXNTZWxmYCk7XHJcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50Q29sdW1uKG1hbmFnZWRDaGlsZC5pbmRleCk7XHJcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGZzKVxyXG4gICAgICAgICAgICAgICAgICAgIGZzKCk7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgKHJ0aV9jZWxsX3JldC5nZXRFbGVtZW50KCkgYXMgRWxlbWVudCAmIFBhcnRpYWw8SFRNTEVsZW1lbnQ+KT8uZm9jdXM/LigpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgYmx1clNlbGYgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnMpXHJcbiAgICAgICAgICAgICAgICAgICAgYnMoKTtcclxuICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAocnRpX2NlbGxfcmV0LmdldEVsZW1lbnQoKSBhcyBFbGVtZW50ICYgUGFydGlhbDxIVE1MRWxlbWVudD4pPy5ibHVyPy4oKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHtcclxuICAgICAgICAgICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcclxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfY2VsbF9yZXRcclxuICAgICAgICAgICAgfSA9IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uMih7XHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IG1hbmFnZWRDaGlsZCxcclxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IC4uLmxzLCBzdWJJbmZvIH0sXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBibHVyU2VsZiwgZm9jdXNTZWxmLCAuLi5ydGkgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8Q2VsbEVsZW1lbnQ+KHtcclxuICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG1hbmFnZWRDaGlsZC5pbmRleCwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIH0pXHJcblxyXG4gICAgICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGU8Q2VsbEVsZW1lbnQ+ID0ge1xyXG4gICAgICAgICAgICAgICAgZ3JpZE5hdmlnYXRpb246IHsgZ2V0Q3VycmVudENvbHVtbiB9LFxyXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9jZWxsX3JldCxcclxuICAgICAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiBmdW5jdGlvbiA8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPENlbGxFbGVtZW50Pj4ocHJvcHM6IFApIHsgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh1c2VHcmlkTmF2aWdhdGlvbkNvbHVtblByb3BzKHVzZUhhc0ZvY3VzUHJvcHMocHJvcHMpKSk7IH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIHJldDtcclxuXHJcbiAgICAgICAgfSwgW10pO1xyXG5cclxuICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uUm93UmV0dXJuVHlwZTxSb3dFbGVtZW50LCBDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPiA9IHtcclxuICAgICAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7XHJcbiAgICAgICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUubGlzdE5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHJvd0xzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXHJcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcm93THNSZXR1cm5UeXBlLnJvdmluZ1RhYkluZGV4LFxyXG4gICAgICAgICAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXHJcblxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBhc0NoaWxkUm93OiByb3dMc0NoaWxkUmV0dXJuVHlwZSxcclxuXHJcbiAgICAgICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCxcclxuICAgICAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3dQcm9wczogZnVuY3Rpb24gPFAgZXh0ZW5kcyBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3dFbGVtZW50Pj4ocHJvcHM6IFApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyhwcm9wcyk7XHJcbiAgICAgICAgICAgICAgICByZXQudGFiSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiByZXQ7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBncmlkTmF2aWdhdGlvbjoge1xyXG4gICAgICAgICAgICBnZXRDdXJyZW50Q29sdW1uLFxyXG4gICAgICAgICAgICBjdXJyZW50Q29sdW1uXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLmxpc3ROYXZpZ2F0aW9uLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiBwYXJlbnRMc1JldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRMc1JldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93LFxyXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQsXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VJbnRlcnZhbCB7XG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiBtcyB0byB3YWl0IGJlZm9yZSBpbnZva2luZyBgY2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGludGVydmFsOiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGB0aW1lb3V0YCBtcyBhZnRlciBtb3VudCwgb3IgdGhlIGxhc3QgY2hhbmdlIHRvIGB0cmlnZ2VySW5kZXhgLlxuICAgICAqL1xuICAgIGNhbGxiYWNrOiAoKSA9PiB2b2lkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSW50ZXJ2YWwoeyBpbnRlcnZhbCwgY2FsbGJhY2sgfTogVXNlSW50ZXJ2YWwpIHtcbiAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2l2ZW4gY2FsbGJhY2sgdGhhdCdzIHN0YWJsZVxuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgIGNvbnN0IGdldEludGVydmFsID0gdXNlU3RhYmxlR2V0dGVyKGludGVydmFsKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGludGVydmFsID0gZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgbGV0IGxhc3REZWxheVVzZWQgPSBpbnRlcnZhbDtcblxuICAgICAgICBpZiAoaW50ZXJ2YWwgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcblxuXG4gICAgICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSB3cmFwcGVyIGFyb3VuZCB0aGUgY2FsbGJhY2tcbiAgICAgICAgLy8gdGhhdCBjbGVhcnMgYW5kIHJlc2V0cyB0aGUgaW50ZXJ2YWwgaWYgaXQgY2hhbmdlcy5cbiAgICAgICAgY29uc3QgYWRqdXN0YWJsZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRJbnRlcnZhbCA9IGdldEludGVydmFsKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsICE9IGxhc3REZWxheVVzZWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbnRlcnZhbCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBoYW5kbGUgPSBzZXRJbnRlcnZhbChhZGp1c3RhYmxlQ2FsbGJhY2ssIGxhc3REZWxheVVzZWQgPSBjdXJyZW50SW50ZXJ2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBoYW5kbGUgPSBzZXRJbnRlcnZhbChhZGp1c3RhYmxlQ2FsbGJhY2ssIGludGVydmFsKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICB9LCBbXSk7XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUludGVydmFsIH0gZnJvbSBcIi4uLy4uXCI7XG5cblxuZXhwb3J0IGNvbnN0IERlbW9Vc2VJbnRlcnZhbCA9ICgpID0+IHtcbiAgICBjb25zdCBbaW50ZXJ2YWwsIHNldEludGVydmFsXSA9IHVzZVN0YXRlKDEwMDApO1xuXG4gICAgY29uc3QgW2ZpcmVDb3VudCwgc2V0RmlyZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gICAgdXNlSW50ZXJ2YWwoeyBpbnRlcnZhbCwgY2FsbGJhY2s6ICgpID0+IHNldEZpcmVDb3VudChpID0+ICsraSkgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGxhYmVsPkludGVydmFsIGR1cmF0aW9uOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtpbnRlcnZhbH0gb25JbnB1dD17ZSA9PiBzZXRJbnRlcnZhbChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxkaXY+VGhlIGNhbGxiYWNrIGhhcyBiZWVuIGNhbGxlZCB7ZmlyZUNvdW50fSB0aW1le2ZpcmVDb3VudCA9PT0gMSA/IFwiXCIgOiBcInNcIn0uPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn1cbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XHJcbmltcG9ydCB7IG1lbW8sIFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0L2NvbXBhdFwiO1xyXG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuLi8uLlwiO1xyXG5pbXBvcnQgeyB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgfSBmcm9tIFwiLi4vLi4vdXNlLWxpc3QtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuLi8uLi91c2Utc3RhdGVcIjtcclxuXHJcblxyXG5jb25zdCBSYW5kb21Xb3JkcyA9IFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlwiLnNwbGl0KFwiIFwiKTtcclxuXHJcblxyXG5cclxuY29uc3QgUm92aW5nQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8SFRNTExJRWxlbWVudCwge30sIHN0cmluZz4+KG51bGwhKVxyXG5leHBvcnQgY29uc3QgRGVtb1VzZVJvdmluZ1RhYkluZGV4ID0gbWVtbygoKSA9PiB7XHJcblxyXG4gICAgY29uc3QgW2NvdW50LCBzZXRDb3VudF0gPSB1c2VTdGF0ZSgxMCk7XHJcbiAgICBjb25zdCBbX2xhc3RGb2N1c2VkSW5uZXIsIHNldExhc3RGb2N1c2VkSW5uZXIsIF9nZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKVxyXG4gICAgY29uc3QgeyB1c2VIYXNGb2N1c1Byb3BzIH0gPSB1c2VIYXNGb2N1czxIVE1MVUxpc3RFbGVtZW50Pih7IG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldExhc3RGb2N1c2VkSW5uZXIgfSk7XHJcbiAgICAvL2NvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcclxuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xyXG4gICAgY29uc3QgW3RhYmJhYmxlSW5kZXgsIHNldExvY2FsVGFiYmFibGVJbmRleF0gPSB1c2VTdGF0ZSgwKTtcclxuXHJcbiAgICAvKmNvbnN0IHtcclxuICAgICAgICBpbmRleERlbWFuZ2xlcixcclxuICAgICAgICBpbmRleE1hbmdsZXIsXHJcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcclxuICAgICAgICBzaHVmZmxlXHJcbiAgICB9ID0gdXNlU29ydGFibGVDaGlsZHJlbjxIVE1MVUxpc3RFbGVtZW50LCB7fSwgc3RyaW5nLCBbXSwgbnVtYmVyPih7XHJcbiAgICAgICAgZ2V0SW5kZXg6IHVzZUNhbGxiYWNrKChyb3cpID0+IHJvdy5pbmRleCwgW10pLFxyXG4gICAgICAgIGdldFZhbHVlOiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSxcclxuICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjaygobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocyAtIHJoczsgfSwgW10pXHJcbiAgICB9KTsqL1xyXG5cclxuICAgIGNvbnN0IHtcclxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHsgY2hpbGRyZW4gfSxcclxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXHJcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IHNldFRhYmJhYmxlSW5kZXggfSxcclxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQgfSxcclxuICAgICAgICBzb3J0YWJsZTogeyBzaHVmZmxlIH1cclxuICAgIH0gPSB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPEhUTUxVTGlzdEVsZW1lbnQsIEhUTUxMSUVsZW1lbnQsIHt9LCBzdHJpbmc+KHtcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7fSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyIHwgbnVsbCkgPT4geyBpZiAoaW5kZXggIT0gbnVsbCkgc2V0TG9jYWxUYWJiYWJsZUluZGV4KGluZGV4KTsgfSwgW10pIH0sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkSW5kZXggfVxyXG4gICAgfSk7XHJcblxyXG5cclxuXHJcblxyXG4gICAgLy9jb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4UHJvcHMgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxVTGlzdEVsZW1lbnQsIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPih7IHRhYmJhYmxlSW5kZXgsIGZvY3VzT25DaGFuZ2U6IGZhbHNlIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vXCI+XHJcbiAgICAgICAgICAgIDxoMj5LZXlib2FyZCAmYW1wOyBMaXN0IE5hdmlnYXRpb248L2gyPlxyXG4gICAgICAgICAgICA8aDM+PGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+PC9oMz5cclxuXHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgTmF0aXZlIEhUTUwgZWxlbWVudHMgb2ZmZXIgZmFudGFzdGljIGtleWJvYXJkIGFjY2Vzc2FiaWxpdHksIGJ1dCBjb3ZlciBhIHJlbGF0aXZlbHkgbGltaXRlZCBudW1iZXIgb2YgdXNlIGNhc2VzLlxyXG4gICAgICAgICAgICAgICAgVGhlcmUgaXMgbm8gbmF0aXZlIEhUTUwgdHJlZSBlbGVtZW50LCBmb3IgZXhhbXBsZSwgdGhhdCBhbGxvd3Mga2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiBpdHMgaXRlbXMsXHJcbiAgICAgICAgICAgICAgICBub3IgaXMgaXQgcG9zc2libGUgdG8gY29tYmluZSB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiBhIDxjb2RlPntcIjxzZWxlY3Q+XCJ9PC9jb2RlPiBtZW51IHdpdGggdGhlIG1lbnUgaW4gYSBkcmF3ZXIgY29tcG9uZW50LjwvcD5cclxuXHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgV2hlbiBjb21pbmcgYWNyb3NzIGEgTGlzdCBvciBhIE1lbnUgb3IgYSBSYWRpb0dyb3VwIG9yIGEgVG9nZ2xlQnV0dG9uR3JvdXAgb3IgYW55IG90aGVyIFwib25lIGNvbXBvbmVudCBtYWRlIHVwIG9mIGNoaWxkIGNvbXBvbmVudHNcIiwgdGhlIHVzdWFsIGV4cGVjdGVkIGJlaGF2aW9yLFxyXG4gICAgICAgICAgICAgICAgYXQgbGVhc3QgbmF0aXZlbHksIGlzIHRoYXQgdGFiYmluZyBpbnRvIHRoZSBjb21wb25lbnQgaXMgb25lIGFjdGlvbiwgYW5kIHRhYmJpbmcgb3V0IGlzIGFub3RoZXIuICBOYXZpZ2F0aW5nIDxlbT53aXRoaW48L2VtPiB0aGUgY29tcG9uZW50IGlzIGRvbmUgd2l0aCB0aGUgYXJyb3cga2V5cyBvciBvdGhlciBtZXRob2RzLlxyXG4gICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDxwPlxyXG4gICAgICAgICAgICAgICAgVGhpcyBpcyBpbXBvcnRhbnQgYm90aCBmb3IgYWNjZXNzYWJpbGl0eSwgYnV0IGFsc28ganVzdCBmb3IgZ2VuZXJhbCB1c2FiaWxpdHkuICBXaGVuIHRhYmJpbmcgYmFjayBhbmQgZm9ydGgsIHRoZSBhYmlsaXR5IHRvIHNraXAgYSBsb25nIGxpc3Qgd2l0aG91dCBuZWVkaW5nIHRvIHRydWRnZSB0aHJvdWdoIDxlbT5ldmVyeSBvbmU8L2VtPiBvZiBpdHMgY2hpbGQgZWxlbWVudHMgaXMgZXh0cmVtZWx5IGltcG9ydGFudC5cclxuICAgICAgICAgICAgPC9wPlxyXG5cclxuICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICA8Y29kZT51c2VMaXN0TmF2aWdhdGlvbjwvY29kZT4gd3JhcHMgdXAgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYSBmZXcgaG9va3MgKDxjb2RlPnVzZVJvdmluZ1RhYkluZGV4PC9jb2RlPiwgPGNvZGU+dXNlTGluZWFyTmF2aWdhdGlvbjwvY29kZT4sIDxjb2RlPnVzZVR5cGVhaGVhZE5hdmlnYXRpb248L2NvZGU+KVxyXG4gICAgICAgICAgICAgICAgdG8gYWxsb3cgZm9yIEFSSUEtY29tcGxpYW50IG5hdmlnYXRpb24gb2YgbGlzdHMgYW5kIG90aGVyIHNpbWlsYXIgY29tcG9uZW50cy4gIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiB1c2UgdGhlIG90aGVyIGhvb2tzIGluZGl2aWR1YWxseS5cclxuICAgICAgICAgICAgPC9wPlxyXG5cclxuICAgICAgICAgICAgPHA+XHJcbiAgICAgICAgICAgICAgICA8Y29kZT51c2VMaXN0TmF2aWdhdGlvbjwvY29kZT4gKGFuZCA8Y29kZT51c2VSb3ZpbmdUYWJJbmRleDwvY29kZT4pIGludGVybmFsbHkgdXNlIDxjb2RlPnVzZUNoaWxkTWFuYWdlcjwvY29kZT4sIHdoaWNoIGlzIGhvdyB0aGUgY2hpbGQgZWxlbWVudHMgYW5kIHRoZSBwYXJlbnQgY29tbXVuaWNhdGUgd2l0aCBlYWNoIG90aGVyLlxyXG4gICAgICAgICAgICAgICAgVGhpcyBtZWFucyB0aGVyZSBhcmUgdmlydHVhbGx5IG5vIHJlc3RyaWN0aW9ucyBvbiBob3cgdGhlIERPTSBpcyBzZXQgdXAgYXMgbG9uZyBhcyB5b3UgY2FuIHByb3ZpZGUgdGhlIGNoaWxkcmVuIHdpdGggdGhlIDxjb2RlPnVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8L2NvZGU+IGhvb2sgdGhhdCdzIHJldHVybmVkLCB1c3VhbGx5IHdpdGggYSBzaW1wbGUgPGNvZGU+Q29udGV4dDwvY29kZT4uXHJcbiAgICAgICAgICAgICAgICBJZiB0aGUgY2hpbGQgZWxlbWVudCBpdHNlbGYgaGFzIGEgZm9jdXNhYmxlIGVsZW1lbnQsIGxpa2UgYSBidXR0b24sIGl0IGNhbiBhbHNvIGJlIHdpcmVkIHVwIHRvIGRpc2FibGUgaXRzZWxmXHJcbiAgICAgICAgICAgICAgICBGZWVsIGZyZWUgdG8gbmVzdCB0aGVtIHRvbywgYXMgbG9uZyBhcyB5b3UgYXJlIGF3YXJlIG9mIHlvdXIgPGNvZGU+Q29udGV4dDwvY29kZT4gbWFuYWdlbWVudCAoaS5lLiByZW1lbWJlciB0aGF0IHlvdSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyA8Y29kZT5Db250ZXh0PC9jb2RlPiBmb3IgZWFjaCB1c2UgY2FzZSkuXHJcbiAgICAgICAgICAgIDwvcD5cclxuICAgICAgICAgICAgPGxhYmVsPiMgb2YgaXRlbXM8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtjb3VudH0gbWluPXswfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcikgfX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8YnV0dG9uIG9uQ2xpY2s9eygpID0+IHNodWZmbGUoY2hpbGRyZW4pfT5TaHVmZmxlPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxsYWJlbD5UYWJiYWJsZSBpbmRleDogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGFiYmFibGVJbmRleCA/PyB1bmRlZmluZWR9IG9uSW5wdXQ9e2UgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IHNldFRhYmJhYmxlSW5kZXgoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIsIGZhbHNlKTsgfX0gLz48L2xhYmVsPlxyXG5cclxuICAgICAgICAgICAgPFJvdmluZ0NoaWxkQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkfT5cclxuICAgICAgICAgICAgICAgIDx1bCB7Li4udXNlSGFzRm9jdXNQcm9wcyh1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUHJvcHMoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vVXNlUm92aW5nVGFiSW5kZXhDaGlsZCBpbmRleD17aX0ga2V5PXtpfSBzZXRTZWxlY3RlZEluZGV4PXtzZXRTZWxlY3RlZEluZGV4fSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSkoKSlcclxuICAgICAgICAgICAgICAgIH0pKX0+PC91bD5cclxuICAgICAgICAgICAgPC9Sb3ZpbmdDaGlsZENvbnRleHQuUHJvdmlkZXI+XHJcbiAgICAgICAgICAgIHtjdXJyZW50VHlwZWFoZWFkICYmIDxkaXY+VHlwZWFoZWFkOiB7Y3VycmVudFR5cGVhaGVhZH08L2Rpdj59XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG59KVxyXG5cclxuY29uc3QgX1ByZWZpeCA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpcIjtcclxuY29uc3QgRGVtb1VzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSBtZW1vKCgoeyBpbmRleCwgc2V0U2VsZWN0ZWRJbmRleCB9OiB7IGluZGV4OiBudW1iZXIsIHNldFNlbGVjdGVkSW5kZXg6IFN0YXRlVXBkYXRlcjxudW1iZXI+IH0pID0+IHtcclxuICAgIGNvbnN0IGhpZGRlbiA9IChpbmRleCA9PSA3KTtcclxuICAgIGNvbnN0IFtyYW5kb21Xb3JkXSA9IHVzZVN0YXRlKCgpID0+IFJhbmRvbVdvcmRzW2luZGV4LypNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoUmFuZG9tV29yZHMubGVuZ3RoIC0gMSkpKi9dKTtcclxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDb250ZXh0KFJvdmluZ0NoaWxkQ29udGV4dCk7XHJcbiAgICBjb25zdCB0ZXh0ID0gYCR7cmFuZG9tV29yZH0gVGhpcyBpcyBpdGVtICMke2luZGV4fSR7aGlkZGVuID8gXCIgKGhpZGRlbilcIiA6IFwiXCJ9YDtcclxuICAgIGNvbnN0IHsgdXNlTGlzdE5hdmlnYXRpb25DaGlsZFByb3BzLCByb3ZpbmdUYWJJbmRleDogeyB0YWJiYWJsZSB9LCBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWQgfSB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCB9LCBsaXN0TmF2aWdhdGlvbjogeyBzdWJJbmZvOiB7fSwgdGV4dCB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW4gfSB9KTtcclxuXHJcbiAgICBjb25zdCBwcm9wcyA9IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh7fSk7XHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxsaSB7Li4ucHJvcHN9IG9uQ2xpY2s9eygpID0+IHNldFNlbGVjdGVkSW5kZXgoaW5kZXgpfT57dGV4dH0gKHt0YWJiYWJsZSA/IFwiVGFiYmFibGVcIiA6IFwiTm90IHRhYmJhYmxlXCJ9LCB7c2VsZWN0ZWQgPyBcIlNlbGVjdGVkXCIgOiBcIk5vdCBzZWxlY3RlZFwifSk8aW5wdXQgey4uLnVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyh7IHR5cGU6IFwibnVtYmVyXCIgfSkgYXMgYW55fSBzdHlsZT17eyB3aWR0aDogXCI1Y2hcIiB9fSAvPjwvbGk+XHJcbiAgICApXHJcbn0pKTsiLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VUaW1lb3V0IH0gZnJvbSBcIi4uLy4uXCI7XG5cblxuZXhwb3J0IGNvbnN0IERlbW9Vc2VUaW1lb3V0ID0gKCkgPT4ge1xuICAgIGNvbnN0IFt0aW1lb3V0LCBzZXRUaW1lb3V0XSA9IHVzZVN0YXRlKDEwMDApO1xuICAgIGNvbnN0IFt0cmlnZ2VySW5kZXgsIHNldFRyaWdnZXJJbmRleF0gPSB1c2VTdGF0ZShcIlwiKTtcblxuICAgIGNvbnN0IFtmaXJlQ291bnQsIHNldEZpcmVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0LCB0cmlnZ2VySW5kZXgsIGNhbGxiYWNrOiAoKSA9PiBzZXRGaXJlQ291bnQoaSA9PiArK2kpIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGxhYmVsPlRpbWVvdXQgZHVyYXRpb246IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RpbWVvdXR9IG9uSW5wdXQ9e2UgPT4gc2V0VGltZW91dChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5SZWZyZXNoIGtleTogPGlucHV0IHR5cGU9XCJ0ZXh0XCIgdmFsdWU9e3RyaWdnZXJJbmRleH0gb25JbnB1dD17ZSA9PiBzZXRUcmlnZ2VySW5kZXgoZS5jdXJyZW50VGFyZ2V0LnZhbHVlKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5UaGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIHtmaXJlQ291bnR9IHRpbWV7ZmlyZUNvdW50ID09PSAxID8gXCJcIiA6IFwic1wifS48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgaCwgcmVuZGVyIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcclxuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xyXG5pbXBvcnQgeyB1c2VBbmltYXRpb25GcmFtZSwgdXNlQXN5bmNIYW5kbGVyLCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSwgdXNlRWxlbWVudFNpemUsIHVzZUZvY3VzVHJhcCwgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YXRlIH0gZnJvbSBcIi4uXCI7XHJcbmltcG9ydCB7IEVsZW1lbnRTaXplIH0gZnJvbSBcIi4uL3VzZS1lbGVtZW50LXNpemVcIjtcclxuaW1wb3J0IHsgdXNlR3JpZE5hdmlnYXRpb24sIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbCwgVXNlR3JpZE5hdmlnYXRpb25Sb3cgfSBmcm9tIFwiLi4vdXNlLWdyaWQtbmF2aWdhdGlvblwiO1xyXG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuLi91c2UtaGFzLWZvY3VzXCI7XHJcbmltcG9ydCB7IERlbW9Vc2VJbnRlcnZhbCB9IGZyb20gXCIuL2RlbW9zL3VzZS1pbnRlcnZhbFwiO1xyXG5pbXBvcnQgeyBEZW1vVXNlUm92aW5nVGFiSW5kZXggfSBmcm9tIFwiLi9kZW1vcy91c2Utcm92aW5nLXRhYi1pbmRleFwiO1xyXG5pbXBvcnQgeyBEZW1vVXNlVGltZW91dCB9IGZyb20gXCIuL2RlbW9zL3VzZS10aW1lb3V0XCI7XHJcblxyXG5jb25zdCBSYW5kb21Xb3JkcyA9IFwiTG9yZW0gaXBzdW0gZG9sb3Igc2l0IGFtZXQsIGNvbnNlY3RldHVyIGFkaXBpc2NpbmcgZWxpdCwgc2VkIGRvIGVpdXNtb2QgdGVtcG9yIGluY2lkaWR1bnQgdXQgbGFib3JlIGV0IGRvbG9yZSBtYWduYSBhbGlxdWEuIFV0IGVuaW0gYWQgbWluaW0gdmVuaWFtLCBxdWlzIG5vc3RydWQgZXhlcmNpdGF0aW9uIHVsbGFtY28gbGFib3JpcyBuaXNpIHV0IGFsaXF1aXAgZXggZWEgY29tbW9kbyBjb25zZXF1YXQuIER1aXMgYXV0ZSBpcnVyZSBkb2xvciBpbiByZXByZWhlbmRlcml0IGluIHZvbHVwdGF0ZSB2ZWxpdCBlc3NlIGNpbGx1bSBkb2xvcmUgZXUgZnVnaWF0IG51bGxhIHBhcmlhdHVyLiBFeGNlcHRldXIgc2ludCBvY2NhZWNhdCBjdXBpZGF0YXQgbm9uIHByb2lkZW50LCBzdW50IGluIGN1bHBhIHF1aSBvZmZpY2lhIGRlc2VydW50IG1vbGxpdCBhbmltIGlkIGVzdCBsYWJvcnVtLlwiLnNwbGl0KFwiIFwiKTtcclxuXHJcblxyXG5cclxuY29uc3QgRGVtb1VzZURyb3BwYWJsZSA9ICgpID0+IHtcclxuICAgIGNvbnN0IHsgZHJvcHBlZEZpbGVzLCBkcm9wcGVkU3RyaW5ncywgZmlsZXNGb3JDb25zaWRlcmF0aW9uLCBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiwgdXNlRHJvcHBhYmxlUHJvcHMsIGRyb3BFcnJvciB9ID0gdXNlRHJvcHBhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGVmZmVjdDogXCJjb3B5XCIgfSk7XHJcblxyXG4gICAgY29uc3QgeyByZWY6IF9yZWYgfSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KHt9LCB7IHJlZjogdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwhKSB9KVxyXG5cclxuICAgIGNvbnN0IHAgPSB1c2VEcm9wcGFibGVQcm9wcyh7IGNsYXNzTmFtZTogXCJkZW1vIGRyb3BwYWJsZVwiIH0pO1xyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiB7Li4ucH0+XHJcblxyXG4gICAgICAgICAgICB7ZHJvcHBlZFN0cmluZ3MgIT0gbnVsbCAmJiA8ZGl2PkRhdGEgZHJvcHBlZDogPHVsPnsoT2JqZWN0LmVudHJpZXMoZHJvcHBlZFN0cmluZ3MpIGFzIFtrZXlvZiB0eXBlb2Ygc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHN0cmluZ11bXSkubWFwKChbdHlwZSwgdmFsdWVdKSA9PiA8bGk+e3R5cGV9OiB7dmFsdWV9PC9saT4pfTwvdWw+PC9kaXY+fVxyXG4gICAgICAgICAgICB7ZHJvcHBlZEZpbGVzICE9IG51bGwgJiYgPGRpdj5GaWxlcyBkcm9wcGVkOiA8dGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGhlYWQ+PHRyPjx0aD5OYW1lPC90aD48dGg+U2l6ZTwvdGg+PHRoPlR5cGU8L3RoPjx0aD5MYXN0IG1vZGlmaWVkPC90aD48L3RyPjwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+e2Ryb3BwZWRGaWxlcy5tYXAoZiA9PiA8dHI+PHRkPntmLm5hbWV9PC90ZD57Zi5kYXRhLmJ5dGVMZW5ndGh9PHRkPntmLnR5cGV9PC90ZD48dGQ+e25ldyBEYXRlKGYubGFzdE1vZGlmaWVkID8/IDApfTwvdGQ+PC90cj4pfTwvdGJvZHk+XHJcbiAgICAgICAgICAgIDwvdGFibGU+PC9kaXY+fVxyXG4gICAgICAgICAgICA8aHIgLz5cclxuXHJcbiAgICAgICAgICAgIHtzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbiAhPSBudWxsICYmIDxkaXY+RGF0YSBiZWluZyBjb25zaWRlcmVkOiA8dWw+e0FycmF5LmZyb20oc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24pLm1hcCh0eXBlID0+IDxsaT57dHlwZX08L2xpPil9PC91bD48L2Rpdj59XHJcbiAgICAgICAgICAgIHtmaWxlc0ZvckNvbnNpZGVyYXRpb24gIT0gbnVsbCAmJiA8ZGl2PkZpbGVzIGJlaW5nIGNvbnNpZGVyZWQ6IDx1bD57ZmlsZXNGb3JDb25zaWRlcmF0aW9uLm1hcChmID0+IDxsaT57SlNPTi5zdHJpbmdpZnkoZil9PC9saT4pfTwvdWw+PC9kaXY+fVxyXG5cclxuICAgICAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgICAgIHtkcm9wRXJyb3IgJiYgPGRpdj57ZHJvcEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkcm9wRXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGRyb3BFcnJvcil9PC9kaXY+fVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKVxyXG59XHJcblxyXG5jb25zdCBEZW1vVXNlRHJhZ2dhYmxlID0gKCkgPT4ge1xyXG4gICAgY29uc3QgeyB1c2VEcmFnZ2FibGVQcm9wcyB9ID0gdXNlRHJhZ2dhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGRhdGE6IHsgXCJ0ZXh0L3BsYWluXCI6IFwiVGhpcyBpcyBjdXN0b20gZHJhZ2dhYmxlIGNvbnRlbnQgb2YgdHlwZSB0ZXh0L3BsYWluLlwiIH0gfSk7XHJcblxyXG5cclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPGRpdiB7Li4udXNlRHJhZ2dhYmxlUHJvcHMoeyBjbGFzc05hbWU6IFwiZGVtb1wiIH0pfT5cclxuICAgICAgICAgICAgRHJhZ2dhYmxlIGNvbnRlbnRcclxuICAgICAgICA8L2Rpdj4pXHJcbn1cclxuXHJcbmNvbnN0IERlbW9Vc2VFbGVtZW50U2l6ZUFuaW1hdGlvbiA9ICgpID0+IHtcclxuICAgIGNvbnN0IFtoZWlnaHQsIHNldEhlaWdodF0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFthbmdsZSwgc2V0QW5nbGVdID0gdXNlU3RhdGUoMCk7XHJcbiAgICB1c2VBbmltYXRpb25GcmFtZSh7XHJcbiAgICAgICAgY2FsbGJhY2s6IChfbXMpID0+IHtcclxuICAgICAgICAgICAgc2V0QW5nbGUoYSA9PiBhICsgMC4wMSlcclxuICAgICAgICAgICAgc2V0SGVpZ2h0KChNYXRoLnNpbihhbmdsZSkgKyAxKSAvIDAuNSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgW2VsZW1lbnRTaXplLCBzZXRFbGVtZW50U2l6ZV0gPSB1c2VTdGF0ZTxFbGVtZW50U2l6ZSB8IG51bGw+KG51bGwpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcyB9ID0gdXNlRWxlbWVudFNpemU8SFRNTERpdkVsZW1lbnQ+KHsgb25TaXplQ2hhbmdlOiBzZXRFbGVtZW50U2l6ZSB9KTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgey4uLnVzZUVsZW1lbnRTaXplUHJvcHMoeyByZWY6IHVuZGVmaW5lZCwgY2xhc3NOYW1lOiBcImRlbW9cIiwgc3R5bGU6IHsgaGVpZ2h0OiBgJHsoaGVpZ2h0ICogMTAwKSArIDEwMH1weGAgfSB9KX0+XHJcbiAgICAgICAgICAgIDxwcmU+e0pTT04uc3RyaW5naWZ5KGVsZW1lbnRTaXplLCBudWxsLCAyKX08L3ByZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn1cclxuXHJcblxyXG5jb25zdCBEZW1vVXNlRm9jdXNUcmFwID0gbWVtbygoeyBkZXB0aCB9OiB7IGRlcHRoPzogbnVtYmVyIH0pID0+IHtcclxuXHJcbiAgICBjb25zdCBbYWN0aXZlLCBzZXRBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxIVE1MRGl2RWxlbWVudD4oeyB0cmFwQWN0aXZlOiBhY3RpdmUgfSk7XHJcbiAgICAvL2NvbnN0IHsgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgdXNlUm92aW5nVGFiSW5kZXhQcm9wcyB9ID0gdXNlUm92aW5nVGFiSW5kZXg8SFRNTFVMaXN0RWxlbWVudCwgUm92aW5nVGFiSW5kZXhDaGlsZEluZm8+KHsgdGFiYmFibGVJbmRleCwgZm9jdXNPbkNoYW5nZTogZmFsc2UgfSk7XHJcblxyXG4gICAgY29uc3QgZGl2UHJvcHMgPSB1c2VGb2N1c1RyYXBQcm9wcyh7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZm9jdXMtdHJhcC1kZW1vXCIgfSk7XHJcbiAgICBpZiAoZGVwdGggPT0gMilcclxuICAgICAgICByZXR1cm4gPGRpdiAvPjtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxkaXYgey4uLmRpdlByb3BzfSA+XHJcbiAgICAgICAgICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcENoaWxkIGFjdGl2ZT17YWN0aXZlfSBzZXRBY3RpdmU9e3NldEFjdGl2ZX0gZGVwdGg9e2RlcHRoID8/IDB9IC8+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5cclxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcENoaWxkID0gbWVtbygoeyBzZXRBY3RpdmUsIGFjdGl2ZSB9OiB7IGFjdGl2ZTogYm9vbGVhbiwgc2V0QWN0aXZlOiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkLCBkZXB0aDogbnVtYmVyIH0pID0+IHtcclxuXHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8PlxyXG4gICAgICAgICAgICA8YnV0dG9uPkJ1dHRvbiAxPC9idXR0b24+XHJcbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDI8L2J1dHRvbj5cclxuICAgICAgICAgICAgPGJ1dHRvbj5CdXR0b24gMzwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XHJcblxyXG4gICAgICAgIDwvPlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5jb25zdCBEZW1vVXNlQXN5bmNIYW5kbGVyMSA9IG1lbW8oKCkgPT4ge1xyXG5cclxuICAgIGNvbnN0IFt0aW1lb3V0LCBzZXRUaW1lb3V0XSA9IHVzZVN0YXRlKDEwMDApO1xyXG4gICAgY29uc3QgW2RlYm91bmNlLCBzZXREZWJvdW5jZV0gPSB1c2VTdGF0ZSgwKTtcclxuICAgIGNvbnN0IFtzaG91bGRUaHJvdywgc2V0U2hvdWxkVGhyb3csIGdldFNob3VsZFRocm93XSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtkaXNhYmxlQ29uc2VjdXRpdmUsIHNldERpc2FibGVDb25zZWN1dGl2ZV0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcblxyXG4gICAgY29uc3QgYXN5bmNPbkNsaWNrID0gKChfdjogdm9pZCwgX2U6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGdldFNob3VsZFRocm93KCkgPyByZWplY3QoKSA6IHJlc29sdmUoKSwgdGltZW91dCkpKTtcclxuICAgIGNvbnN0IHtcclxuICAgICAgICBjYWxsQ291bnQsXHJcbiAgICAgICAgc2V0dGxlQ291bnQsXHJcbiAgICAgICAgaGFzQ2FwdHVyZSxcclxuICAgICAgICBzeW5jSGFuZGxlcixcclxuICAgICAgICBwZW5kaW5nLFxyXG4gICAgICAgIGhhc0Vycm9yLFxyXG4gICAgICAgIHJlamVjdENvdW50LFxyXG4gICAgICAgIHJlc29sdmVDb3VudFxyXG4gICAgfSA9IHVzZUFzeW5jSGFuZGxlcjxoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+LCB2b2lkPihhc3luY09uQ2xpY2ssIHsgY2FwdHVyZTogKCkgPT4geyB9LCBkZWJvdW5jZTogZGVib3VuY2UgPT0gMCA/IHVuZGVmaW5lZCA6IGRlYm91bmNlIH0pO1xyXG5cclxuICAgIGNvbnN0IG9uQ2xpY2sgPSBwZW5kaW5nID8gdW5kZWZpbmVkIDogc3luY0hhbmRsZXI7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cclxuICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uQ2xpY2s9e29uQ2xpY2t9PkNsaWNrIG1lITwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8bGFiZWw+U2xlZXAgZm9yOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0aW1lb3V0fSBvbklucHV0PXtlID0+IHNldFRpbWVvdXQoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5UaHJvdyBhbiBlcnJvciA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17c2hvdWxkVGhyb3d9IG9uSW5wdXQ9e2UgPT4gc2V0U2hvdWxkVGhyb3coZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5EaXNhYmxlZCB3aGlsZSBwZW5kaW5nIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e2UgPT4gc2V0RGlzYWJsZUNvbnNlY3V0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8bGFiZWw+RGVib3VuY2U6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2RlYm91bmNlfSBvbklucHV0PXtlID0+IHNldERlYm91bmNlKGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxyXG4gICAgICAgICAgICA8dGFibGU+XHJcbiAgICAgICAgICAgICAgICA8dGhlYWQ+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+RmllbGQ8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxyXG4gICAgICAgICAgICAgICAgPHRib2R5PlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+Y2FsbENvdW50PC90ZD48dGQ+e2NhbGxDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5zZXR0bGVDb3VudDwvdGQ+PHRkPntzZXR0bGVDb3VudH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZXNvbHZlQ291bnQ8L3RkPjx0ZD57cmVzb2x2ZUNvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnJlamVjdENvdW50PC90ZD48dGQ+e3JlamVjdENvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmhhc0Vycm9yPC90ZD48dGQ+e2hhc0Vycm9yLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzQ2FwdHVyZTwvdGQ+PHRkPntoYXNDYXB0dXJlLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pO1xyXG5cclxuY29uc3QgRGVtb1VzZUFzeW5jSGFuZGxlcjIgPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcclxuICAgIGNvbnN0IFtkZWJvdW5jZSwgc2V0RGVib3VuY2VdID0gdXNlU3RhdGUoMCk7XHJcbiAgICBjb25zdCBbc2hvdWxkVGhyb3csIHNldFNob3VsZFRocm93LCBnZXRTaG91bGRUaHJvd10gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IFt0ZXh0LCBzZXRUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG5cclxuICAgIGNvbnN0IG9uSW5wdXRBc3luYyA9IGFzeW5jICh2OiBzdHJpbmcsIF9lOiBhbnkpID0+IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoZ2V0U2hvdWxkVGhyb3coKSkge1xyXG4gICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNldFRleHQodik7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCB0aW1lb3V0KSk7XHJcblxyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIGNhbGxDb3VudCxcclxuICAgICAgICBzZXR0bGVDb3VudCxcclxuICAgICAgICBoYXNDYXB0dXJlLFxyXG4gICAgICAgIHN5bmNIYW5kbGVyLFxyXG4gICAgICAgIGN1cnJlbnRDYXB0dXJlLFxyXG4gICAgICAgIHBlbmRpbmcsXHJcbiAgICAgICAgaGFzRXJyb3IsXHJcbiAgICAgICAgcmVqZWN0Q291bnQsXHJcbiAgICAgICAgcmVzb2x2ZUNvdW50XHJcbiAgICB9ID0gdXNlQXN5bmNIYW5kbGVyPGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sIHN0cmluZz4ob25JbnB1dEFzeW5jLCB7IGNhcHR1cmU6IChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgcmV0dXJuIGUuY3VycmVudFRhcmdldC52YWx1ZSB9LCBkZWJvdW5jZTogZGVib3VuY2UgPT0gMCA/IHVuZGVmaW5lZCA6IGRlYm91bmNlIH0pO1xyXG5cclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8bGFiZWw+RGVtbyB0ZXh0OiA8aW5wdXQgdmFsdWU9e2hhc0NhcHR1cmUgPyBjdXJyZW50Q2FwdHVyZSA6IHRleHR9IGRpc2FibGVkPXtwZW5kaW5nICYmIGRpc2FibGVDb25zZWN1dGl2ZX0gb25JbnB1dD17c3luY0hhbmRsZXJ9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgICAgIDxsYWJlbD5TbGVlcCBmb3I6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RpbWVvdXR9IG9uSW5wdXQ9e2UgPT4gc2V0VGltZW91dChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPlRocm93IGFuIGVycm9yIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzaG91bGRUaHJvd30gb25JbnB1dD17ZSA9PiBzZXRTaG91bGRUaHJvdyhlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cclxuICAgICAgICAgICAgPGxhYmVsPkRpc2FibGVkIHdoaWxlIHBlbmRpbmcgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIGNoZWNrZWQ9e2Rpc2FibGVDb25zZWN1dGl2ZX0gb25JbnB1dD17ZSA9PiBzZXREaXNhYmxlQ29uc2VjdXRpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDxsYWJlbD5EZWJvdW5jZTogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17ZGVib3VuY2V9IG9uSW5wdXQ9e2UgPT4gc2V0RGVib3VuY2UoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XHJcbiAgICAgICAgICAgIDx0YWJsZT5cclxuICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5GaWVsZDwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5WYWx1ZTwvdGg+XHJcbiAgICAgICAgICAgICAgICAgICAgPC90cj5cclxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA8dGJvZHk+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5jYWxsQ291bnQ8L3RkPjx0ZD57Y2FsbENvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnNldHRsZUNvdW50PC90ZD48dGQ+e3NldHRsZUNvdW50fTwvdGQ+PC90cj5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnJlc29sdmVDb3VudDwvdGQ+PHRkPntyZXNvbHZlQ291bnR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVqZWN0Q291bnQ8L3RkPjx0ZD57cmVqZWN0Q291bnR9PC90ZD48L3RyPlxyXG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzRXJyb3I8L3RkPjx0ZD57aGFzRXJyb3IudG9TdHJpbmcoKX08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5jdXJyZW50Q2FwdHVyZTwvdGQ+PHRkPntjdXJyZW50Q2FwdHVyZX08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5cIlNhdmVkXCIgaW5wdXQ8L3RkPjx0ZD57dGV4dH08L3RkPjwvdHI+XHJcbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxyXG4gICAgICAgICAgICA8L3RhYmxlPlxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgKTtcclxufSk7XHJcblxyXG5cclxuY29uc3QgRGVtb0ZvY3VzID0gbWVtbygoKSA9PiB7XHJcbiAgICBjb25zdCBbbGFzdEFjdGl2ZUVsZW1lbnQsIHNldExhc3RBY3RpdmVFbGVtZW50XSA9IHVzZVN0YXRlPChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IFthY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVN0YXRlPChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsPihudWxsKTtcclxuICAgIGNvbnN0IFt3aW5kb3dGb2N1c2VkLCBzZXRXaW5kb3dGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtmb2N1c2VkLCBzZXRGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCBbbGFzdEZvY3VzZWQsIHNldExhc3RGb2N1c2VkXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IFtsYXN0Rm9jdXNlZElubmVyLCBzZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcclxuICAgIGNvbnN0IHsgdXNlSGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8SFRNTERpdkVsZW1lbnQ+KHtcclxuICAgICAgICBvbkZvY3VzZWRDaGFuZ2VkOiBzZXRGb2N1c2VkLFxyXG4gICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogc2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIG9uTGFzdEZvY3VzZWRDaGFuZ2VkOiBzZXRMYXN0Rm9jdXNlZCxcclxuICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkOiBzZXRMYXN0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogc2V0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiBzZXRMYXN0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U6IHNldFdpbmRvd0ZvY3VzZWRcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICA8aDI+dXNlSGFzRm9jdXM8L2gyPlxyXG4gICAgICAgICAgICA8ZGl2IHsuLi51c2VIYXNGb2N1c1Byb3BzKHsgc3R5bGU6IHsgYm9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wiIH0sIHRhYkluZGV4OiAwIH0pfSA+T3V0ZXIgPGRpdiB0YWJJbmRleD17MH0gc3R5bGU9e3sgYm9yZGVyOiBcIjFweCBzb2xpZCBibGFja1wiIH19PklubmVyIGVsZW1lbnQ8L2Rpdj48L2Rpdj5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICAgIDx1bD5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+U3RyaWN0bHkgZm9jdXNlZDoge2ZvY3VzZWQudG9TdHJpbmcoKX0sIHtsYXN0Rm9jdXNlZC50b1N0cmluZygpfTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpPklubmVyIGZvY3VzZWQ6IHtmb2N1c2VkSW5uZXIudG9TdHJpbmcoKX0sIHtsYXN0Rm9jdXNlZElubmVyLnRvU3RyaW5nKCl9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+V2luZG93IGZvY3VzZWQ6IHt3aW5kb3dGb2N1c2VkLnRvU3RyaW5nKCl9PC9saT5cclxuICAgICAgICAgICAgICAgICAgICA8bGk+YWN0aXZlRWxlbWVudDoge2FjdGl2ZUVsZW1lbnQ/LnRleHRDb250ZW50fTwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgPGxpPmxhc3RBY3RpdmVFbGVtZW50OiB7bGFzdEFjdGl2ZUVsZW1lbnQ/LnRleHRDb250ZW50fTwvbGk+XHJcbiAgICAgICAgICAgICAgICA8L3VsPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIClcclxufSlcclxuXHJcblxyXG5jb25zdCBHcmlkUm93Q29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlR3JpZE5hdmlnYXRpb25Sb3c8SFRNTFRhYmxlUm93RWxlbWVudCwgSFRNTFRhYmxlQ2VsbEVsZW1lbnQsIHt9LCB7fSwgc3RyaW5nLCBzdHJpbmc+PihudWxsISk7XHJcbmNvbnN0IEdyaWRDZWxsQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQ8VXNlR3JpZE5hdmlnYXRpb25DZWxsPEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwgc3RyaW5nPj4obnVsbCEpO1xyXG5leHBvcnQgY29uc3QgRGVtb1VzZUdyaWQgPSBtZW1vKCgpID0+IHtcclxuXHJcbiAgICBjb25zdCBbLCBzZXRMYXN0Rm9jdXNlZElubmVyLCBfZ2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XHJcbiAgICBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50Pih7IG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldExhc3RGb2N1c2VkSW5uZXIgfSk7XHJcbiAgICBjb25zdCB7IHVzZUdyaWROYXZpZ2F0aW9uUm93LCB1c2VHcmlkTmF2aWdhdGlvblByb3BzLCBncmlkTmF2aWdhdGlvbjogeyBjdXJyZW50Q29sdW1uIH0gfSA9IHVzZUdyaWROYXZpZ2F0aW9uPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50LCBIVE1MVGFibGVSb3dFbGVtZW50LCBIVE1MVGFibGVDZWxsRWxlbWVudCwge30sIHt9LCBzdHJpbmcsIHN0cmluZz4oe1xyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7fSxcclxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcclxuICAgICAgICBsaXN0TmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge30sXHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7fVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICA8ZGl2IGNsYXNzPVwiZGVtb1wiPlxyXG4gICAgICAgICAgICB7PGRpdj5DdXJyZW50IGNvbHVtbjoge2N1cnJlbnRDb2x1bW59PC9kaXY+fVxyXG4gICAgICAgICAgICA8dGFibGUgey4uLnsgYm9yZGVyOiBcIjJcIiB9IGFzIHt9fSBzdHlsZT17eyB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiIH19PlxyXG5cclxuICAgICAgICAgICAgICAgIDx0aGVhZD5cclxuICAgICAgICAgICAgICAgICAgICA8dHI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5Sb3cgaXMgdGFiYmFibGU/PC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkNvbHVtbiAxPC90aD5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkNvbHVtbiAyPC90aD5cclxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxyXG4gICAgICAgICAgICAgICAgPC90aGVhZD5cclxuICAgICAgICAgICAgICAgIDx0Ym9keSB7Li4udXNlSGFzRm9jdXNQcm9wcyh1c2VHcmlkTmF2aWdhdGlvblByb3BzKHt9KSl9PlxyXG4gICAgICAgICAgICAgICAgICAgIDxHcmlkUm93Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17dXNlR3JpZE5hdmlnYXRpb25Sb3d9PlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIDxEZW1vVXNlR3JpZFJvdyBpbmRleD17aX0ga2V5PXtpfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX1cclxuICAgICAgICAgICAgICAgICAgICA8L0dyaWRSb3dDb250ZXh0LlByb3ZpZGVyPlxyXG4gICAgICAgICAgICAgICAgPC90Ym9keT5cclxuICAgICAgICAgICAgPC90YWJsZT5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICk7XHJcbn0pXHJcblxyXG5jb25zdCBfUHJlZml4ID0gXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWlwiO1xyXG5jb25zdCBEZW1vVXNlR3JpZFJvdyA9IG1lbW8oKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XHJcbiAgICBjb25zdCBbX3JhbmRvbVdvcmRdID0gdXNlU3RhdGUoKCkgPT4gUmFuZG9tV29yZHNbaW5kZXgvKk1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChSYW5kb21Xb3Jkcy5sZW5ndGggLSAxKSkqL10pO1xyXG4gICAgY29uc3QgdXNlR3JpZFJvdyA9IHVzZUNvbnRleHQoR3JpZFJvd0NvbnRleHQpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uUm93UHJvcHMsXHJcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsLFxyXG4gICAgICAgIGFzQ2hpbGRSb3c6IHsgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSB9LFxyXG4gICAgfSA9IHVzZUdyaWRSb3coe1xyXG4gICAgICAgIGFzQ2hpbGRSb3c6IHsgbWFuYWdlZENoaWxkOiB7IGluZGV4IH0sIGxpc3ROYXZpZ2F0aW9uOiB7IHN1YkluZm86IHt9LCB0ZXh0OiBcIlwiIH0sIHJvdmluZ1RhYkluZGV4OiB7IGhpZGRlbjogaW5kZXggPT0gMyB9LCBncmlkTmF2aWdhdGlvbjogeyBzdWJJbmZvOiB7fSB9IH0sXHJcbiAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7IGxpbmVhck5hdmlnYXRpb246IHt9LCBsaXN0TmF2aWdhdGlvbjoge30sIHJvdmluZ1RhYkluZGV4OiB7fSwgdHlwZWFoZWFkTmF2aWdhdGlvbjoge30sIG1hbmFnZWRDaGlsZHJlbjoge30gfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvblJvd1Byb3BzKHt9KTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgPHRyIHsuLi5wcm9wc30+XHJcbiAgICAgICAgICAgIDxHcmlkQ2VsbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUdyaWROYXZpZ2F0aW9uQ2VsbH0+XHJcbiAgICAgICAgICAgICAgICB7QXJyYXkuZnJvbSgoZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZUdyaWRDZWxsIGluZGV4PXtpfSBrZXk9e2l9IHJvdz17aW5kZXh9IHJvd0lzVGFiYmFibGU9e3RhYmJhYmxlfSAvPlxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKCkpfVxyXG4gICAgICAgICAgICA8L0dyaWRDZWxsQ29udGV4dC5Qcm92aWRlcj5cclxuICAgICAgICA8L3RyPlxyXG4gICAgKVxyXG59KSk7XHJcblxyXG5jb25zdCBEZW1vVXNlR3JpZENlbGwgPSAoKHsgaW5kZXgsIHJvdywgcm93SXNUYWJiYWJsZSB9OiB7IGluZGV4OiBudW1iZXIsIHJvdzogbnVtYmVyLCByb3dJc1RhYmJhYmxlOiBib29sZWFuIH0pID0+IHtcclxuICAgIGlmIChyb3cgPj0gNiAmJiByb3cgJSAyID09IDAgJiYgaW5kZXggPiAxKVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgIGxldCBoaWRkZW5UZXh0ID0gKHJvdyA9PT0gMyk/IFwiIChyb3cgaGlkZGVuKVwiIDogXCJcIlxyXG5cclxuICAgIGNvbnN0IHVzZUdyaWRDZWxsID0gdXNlQ29udGV4dChHcmlkQ2VsbENvbnRleHQpO1xyXG4gICAgY29uc3Qge1xyXG4gICAgICAgIHVzZUdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzLFxyXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlOiBjZWxsSXNUYWJiYWJsZSB9XHJcbiAgICB9ID0gdXNlR3JpZENlbGwoe1xyXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IHRleHQ6IFwiXCIgfSxcclxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSxcclxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW46IGZhbHNlIH0sXHJcbiAgICAgICAgZ3JpZE5hdmlnYXRpb246IHsgc3ViSW5mbzoge30gfVxyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgcHJvcHMgPSB1c2VHcmlkTmF2aWdhdGlvbkNlbGxQcm9wcyh7fSkgYXMgYW55O1xyXG5cclxuICAgIGNvbnN0IHQgPSAoY2VsbElzVGFiYmFibGUgPyBcIihUYWJiYWJsZSlcIiA6IFwiKE5vdCB0YWJiYWJsZSlcIilcclxuXHJcbiAgICBpZiAoaW5kZXggPT09IDApXHJcbiAgICAgICAgcmV0dXJuIDx0ZCB7Li4ucHJvcHN9Pntyb3dJc1RhYmJhYmxlLnRvU3RyaW5nKCl9PC90ZD5cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGlmIChyb3cgPCA2IHx8IHJvdyAlIDIgIT0gMCkge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30+R3JpZCBjZWxsICN7aW5kZXggKyAxfSB7dH17aGlkZGVuVGV4dH08L3RkPlxyXG4gICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkPjxsYWJlbD48aW5wdXQgIHsuLi5wcm9wc30gdHlwZT1cImNoZWNrYm94XCIgLz4gVGVzdCBpbnB1dCB7dH17aGlkZGVuVGV4dH08L2xhYmVsPjwvdGQ+XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDEpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gPHRkIHsuLi5wcm9wc30gY29sU3Bhbj17Mn0+R3JpZCBjZWxsICN7aW5kZXggKyAxfSwgc3BhbiAyIHt0fXtoaWRkZW5UZXh0fTwvdGQ+XHJcbiAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG5cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pXHJcblxyXG5jb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XHJcbiAgICByZXR1cm4gPGRpdiBjbGFzcz1cImZsZXhcIiBzdHlsZT17eyBmbGV4V3JhcDogXCJ3cmFwXCIgfX0+XHJcbiAgICAgICAgPERlbW9Gb2N1cyAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlR3JpZCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlVGltZW91dCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlSW50ZXJ2YWwgLz5cclxuICAgICAgICA8aHIgLz5cclxuICAgICAgICA8RGVtb1VzZVJvdmluZ1RhYkluZGV4IC8+XHJcbiAgICAgICAgPGhyIC8+XHJcblxyXG5cclxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlQXN5bmNIYW5kbGVyMSAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlQXN5bmNIYW5kbGVyMiAvPlxyXG4gICAgICAgIDxociAvPlxyXG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPERlbW9Vc2VEcmFnZ2FibGUgLz5cclxuICAgICAgICA8aHIgLz5cclxuICAgICAgICA8RGVtb1VzZUVsZW1lbnRTaXplQW5pbWF0aW9uIC8+XHJcbiAgICAgICAgPGhyIC8+XHJcbiAgICAgICAgPGlucHV0IC8+XHJcbiAgICA8L2Rpdj5cclxufVxyXG5cclxucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcclxuICAgIHJlbmRlcig8Q29tcG9uZW50IC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInJvb3RcIikhKTtcclxufSlcclxuIl0sIm5hbWVzIjpbInNsaWNlIiwib3B0aW9ucyIsInZub2RlSWQiLCJyZXJlbmRlclF1ZXVlIiwicHJldkRlYm91bmNlIiwiaSIsIkVNUFRZX09CSiIsIkVNUFRZX0FSUiIsIklTX05PTl9ESU1FTlNJT05BTCIsImFzc2lnbiIsIm9iaiIsInByb3BzIiwicmVtb3ZlTm9kZSIsIm5vZGUiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJjcmVhdGVFbGVtZW50IiwidHlwZSIsImNoaWxkcmVuIiwia2V5IiwicmVmIiwibm9ybWFsaXplZFByb3BzIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwiY2FsbCIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsImNyZWF0ZVZOb2RlIiwib3JpZ2luYWwiLCJ2bm9kZSIsImNvbnN0cnVjdG9yIiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwiZ2V0RG9tU2libGluZyIsImNoaWxkSW5kZXgiLCJpbmRleE9mIiwic2libGluZyIsInVwZGF0ZVBhcmVudERvbVBvaW50ZXJzIiwiY2hpbGQiLCJiYXNlIiwiZW5xdWV1ZVJlbmRlciIsImMiLCJwdXNoIiwicHJvY2VzcyIsImRlYm91bmNlUmVuZGVyaW5nIiwic2V0VGltZW91dCIsInF1ZXVlIiwic29ydCIsImEiLCJiIiwic29tZSIsImNvbXBvbmVudCIsImNvbW1pdFF1ZXVlIiwib2xkVk5vZGUiLCJvbGREb20iLCJwYXJlbnREb20iLCJkaWZmIiwib3duZXJTVkdFbGVtZW50IiwiY29tbWl0Um9vdCIsImRpZmZDaGlsZHJlbiIsInJlbmRlclJlc3VsdCIsIm5ld1BhcmVudFZOb2RlIiwib2xkUGFyZW50Vk5vZGUiLCJnbG9iYWxDb250ZXh0IiwiaXNTdmciLCJleGNlc3NEb21DaGlsZHJlbiIsImlzSHlkcmF0aW5nIiwiaiIsImNoaWxkVk5vZGUiLCJuZXdEb20iLCJmaXJzdENoaWxkRG9tIiwicmVmcyIsIm9sZENoaWxkcmVuIiwib2xkQ2hpbGRyZW5MZW5ndGgiLCJBcnJheSIsImlzQXJyYXkiLCJyZW9yZGVyQ2hpbGRyZW4iLCJwbGFjZUNoaWxkIiwidW5tb3VudCIsImFwcGx5UmVmIiwidG1wIiwidG9DaGlsZEFycmF5Iiwib3V0IiwibmV4dERvbSIsInNpYkRvbSIsIm91dGVyIiwiYXBwZW5kQ2hpbGQiLCJuZXh0U2libGluZyIsImluc2VydEJlZm9yZSIsImRpZmZQcm9wcyIsImRvbSIsIm5ld1Byb3BzIiwib2xkUHJvcHMiLCJoeWRyYXRlIiwic2V0UHJvcGVydHkiLCJzZXRTdHlsZSIsInN0eWxlIiwidmFsdWUiLCJ0ZXN0IiwibmFtZSIsIm9sZFZhbHVlIiwidXNlQ2FwdHVyZSIsIm8iLCJjc3NUZXh0IiwicmVwbGFjZSIsInRvTG93ZXJDYXNlIiwiX2xpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJldmVudFByb3h5Q2FwdHVyZSIsImV2ZW50UHJveHkiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsImV2ZW50IiwibmV3Vk5vZGUiLCJpc05ldyIsIm9sZFN0YXRlIiwic25hcHNob3QiLCJjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24iLCJwcm92aWRlciIsImNvbXBvbmVudENvbnRleHQiLCJyZW5kZXJIb29rIiwiY291bnQiLCJuZXdUeXBlIiwiY29udGV4dFR5cGUiLCJwcm90b3R5cGUiLCJyZW5kZXIiLCJkb1JlbmRlciIsInN1YiIsInN0YXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiZm9yRWFjaCIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJjb21wb25lbnREaWRVcGRhdGUiLCJnZXRDaGlsZENvbnRleHQiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImRpZmZFbGVtZW50Tm9kZXMiLCJkaWZmZWQiLCJyb290IiwiY2IiLCJvbGRIdG1sIiwibmV3SHRtbCIsIm5vZGVUeXBlIiwibG9jYWxOYW1lIiwiZG9jdW1lbnQiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUVsZW1lbnROUyIsImlzIiwiZGF0YSIsImNoaWxkTm9kZXMiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImF0dHJpYnV0ZXMiLCJpbm5lckhUTUwiLCJjaGVja2VkIiwiY3VycmVudCIsInBhcmVudFZOb2RlIiwic2tpcFJlbW92ZSIsInIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInRoaXMiLCJyZXBsYWNlTm9kZSIsImZpcnN0Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwiY29udGV4dElkIiwiQ29uc3VtZXIiLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInN1YnMiLCJjdHgiLCJfcHJvcHMiLCJvbGQiLCJzcGxpY2UiLCJlcnJvciIsImVycm9ySW5mbyIsImN0b3IiLCJoYW5kbGVkIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwic2V0U3RhdGUiLCJjb21wb25lbnREaWRDYXRjaCIsImlzVmFsaWRFbGVtZW50IiwidXBkYXRlIiwiY2FsbGJhY2siLCJzIiwiZm9yY2VVcGRhdGUiLCJfX3NlbGYiLCJfX3NvdXJjZSIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRDb21wb25lbnQiLCJwcmV2aW91c0NvbXBvbmVudCIsInByZXZSYWYiLCJjdXJyZW50SG9vayIsImFmdGVyUGFpbnRFZmZlY3RzIiwiRU1QVFkiLCJvbGRCZWZvcmVEaWZmIiwib2xkQmVmb3JlUmVuZGVyIiwib2xkQWZ0ZXJEaWZmIiwib2xkQ29tbWl0Iiwib2xkQmVmb3JlVW5tb3VudCIsImdldEhvb2tTdGF0ZSIsImluZGV4IiwiaG9va3MiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJhY3Rpb24iLCJuZXh0VmFsdWUiLCJ1c2VFZmZlY3QiLCJhcmdzIiwiYXJnc0NoYW5nZWQiLCJfcGVuZGluZ0FyZ3MiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwiZmFjdG9yeSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCJzaGlmdCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJob29rSXRlbSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInJhZiIsImRvbmUiLCJjbGVhclRpbWVvdXQiLCJ0aW1lb3V0IiwiSEFTX1JBRiIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiZmlsdGVyIiwiaGFzRXJyb3JlZCIsImhvb2siLCJjb21wIiwiY2xlYW51cCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwiZiIsInNoYWxsb3dEaWZmZXJzIiwiUHVyZUNvbXBvbmVudCIsInAiLCJtZW1vIiwiY29tcGFyZXIiLCJzaG91bGRVcGRhdGUiLCJuZXh0UHJvcHMiLCJ1cGRhdGVSZWYiLCJNZW1vZWQiLCJkaXNwbGF5TmFtZSIsImlzUmVhY3RDb21wb25lbnQiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsIm9sZERpZmZIb29rIiwiRm9yd2FyZGVkIiwib2xkQ2F0Y2hFcnJvciIsInRoZW4iLCJvbGRVbm1vdW50IiwiU3VzcGVuc2UiLCJfc3VzcGVuZGVycyIsInN1c3BlbmRlZCIsIlN1c3BlbnNlTGlzdCIsIl9uZXh0IiwiX21hcCIsInByb21pc2UiLCJzdXNwZW5kaW5nVk5vZGUiLCJzdXNwZW5kaW5nQ29tcG9uZW50IiwicmVzb2x2ZSIsInJlc29sdmVkIiwib25SZXNvbHZlZCIsIm9uU3VzcGVuc2lvbkNvbXBsZXRlIiwic3VzcGVuZGVkVk5vZGUiLCJyZW1vdmVPcmlnaW5hbCIsImRldGFjaGVkUGFyZW50Iiwib3JpZ2luYWxQYXJlbnQiLCJtYXAiLCJwb3AiLCJ3YXNIeWRyYXRpbmciLCJkZXRhY2hlZENvbXBvbmVudCIsImRldGFjaGVkQ2xvbmUiLCJlZmZlY3QiLCJmYWxsYmFjayIsImxpc3QiLCJkZWxldGUiLCJyZXZlYWxPcmRlciIsInNpemUiLCJkZWxlZ2F0ZWQiLCJnZXQiLCJ1bnN1c3BlbmQiLCJ3cmFwcGVkVW5zdXNwZW5kIiwiTWFwIiwicmV2ZXJzZSIsInNldCIsIl90aGlzIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiZm9yIiwiQ0FNRUxfUFJPUFMiLCJJU19ET00iLCJvbkNoYW5nZUlucHV0VHlwZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwidiIsIndyaXRhYmxlIiwib2xkRXZlbnRIb29rIiwiZW1wdHkiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImNhbmNlbEJ1YmJsZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwZXJzaXN0IiwibmF0aXZlRXZlbnQiLCJjbGFzc05hbWVEZXNjcmlwdG9yIiwiY2xhc3MiLCJvbGRWTm9kZUhvb2siLCJub25DdXN0b21FbGVtZW50IiwibXVsdGlwbGUiLCJzZWxlY3RlZCIsImNsYXNzTmFtZSIsImVudW1lcmFibGUiLCIkJHR5cGVvZiIsIlVuc2V0Iiwib2JqZWN0UHJvdG8iLCJoYXNPd25Qcm9wZXJ0eSIsIm5hdGl2ZU9iamVjdFRvU3RyaW5nIiwic3ltVG9TdHJpbmdUYWciLCJGVU5DX0VSUk9SX1RFWFQiLCJ1c2VTdGF0ZVAiLCJpZGVudGl0eSIsInVzZUVmZmVjdE5hdGl2ZSIsInVzZUxheW91dEVmZmVjdE5hdGl2ZSIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsIk5vRWxlbWVudCIsIkVsZW1lbnQiLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJnZXRSb290Tm9kZSIsImVsZW1lbnQiLCJvd25lckRvY3VtZW50IiwiaXNJbnB1dCIsInRhZ05hbWUiLCJpc0hpZGRlbklucHV0IiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJhcHBseSIsImlzWmVyb0FyZWEiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsImhlaWdodCIsImlzSGlkZGVuIiwiZGlzcGxheUNoZWNrIiwiZ2V0U2hhZG93Um9vdCIsImdldENvbXB1dGVkU3R5bGUiLCJ2aXNpYmlsaXR5IiwiaXNEaXJlY3RTdW1tYXJ5Iiwibm9kZVVuZGVyRGV0YWlscyIsInBhcmVudEVsZW1lbnQiLCJub2RlUm9vdEhvc3QiLCJob3N0Iiwibm9kZUlzQXR0YWNoZWQiLCJjb250YWlucyIsIm9yaWdpbmFsTm9kZSIsInJvb3ROb2RlIiwic2hhZG93Um9vdCIsImFzc2lnbmVkU2xvdCIsImdldENsaWVudFJlY3RzIiwiaXNEaXNhYmxlZEZyb21GaWVsZHNldCIsImRpc2FibGVkIiwiaXRlbSIsImlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUiLCJmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciIsImNvbmNhdCIsImpvaW4iLCJpc0ZvY3VzYWJsZSIsIkVycm9yIiwiYXJnc1RhZyIsImZyZWVFeHBvcnRzIiwiZnJlZU1vZHVsZSIsIm1vZHVsZUV4cG9ydHMiLCJNQVhfU0FGRV9JTlRFR0VSIiwiZnVuY1RhZyIsImgiLCJzaHVmZmxlIiwibG9kYXNoU2h1ZmZsZSIsIl9qc3hzIiwiX2pzeCIsIlJhbmRvbVdvcmRzIl0sIm1hcHBpbmdzIjoiOzs7QUEwQmFBLFFBQUFBLENBQUFBLENDZlBDLEdDUkZDLENBQUFBLEdBQUFBLENDdUtBQyxHQUFBQSxDQVdBQyxHQ25MT0MsQ0FBQUEsR0FBQUEsQ0NGRUMsR0FBWSxDQUFBLEVBQUEsQ0FDWkMsR0FBWSxDQUFBLEVBQUEsQ0FDWkMsR0FBcUIsQ0FBQSxvRUxPM0IsU0FBU0MsR0FBQUEsQ0FBT0MsQ0FBS0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFFdEIsSUFBSU4sQ0FBQUEsSUFBS00sQ0FBT0QsQ0FBQUEsQ0FBQUEsQ0FBSUwsQ0FBS00sQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTU4sQ0FDUEssQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FTdkIsU0FBU0UsR0FBQUEsQ0FBV0MsQ0FDdEJDLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQWFELEVBQUtDLFVBQ2xCQSxDQUFBQSxDQUFBQSxFQUFZQSxDQUFXQyxDQUFBQSxXQUFBQSxDQUFZRixDRVZ4QyxFQUFBLENBQUEsU0FBZ0JHLEdBQWNDLENBQUFBLENBQUFBLENBQU1OLENBQU9PLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBRXpDQyxDQUNBQyxDQUFBQSxDQUFBQSxDQUNBZixDQUhHZ0IsQ0FBQUEsQ0FBQUEsQ0FBa0IsRUFJakJoQixDQUFBQSxJQUFBQSxDQUFBQSxJQUFLTSxDQUNBLENBQUEsS0FBQSxFQUFMTixDQUFZYyxDQUFBQSxDQUFBQSxDQUFNUixDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxDQUNkLEtBQUxBLEVBQUFBLENBQUFBLENBQVllLENBQU1ULENBQUFBLENBQUFBLENBQU1OLENBQzVCZ0IsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBZ0JoQixDQUFLTSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFNTixNQUc3QmlCLFNBQVVDLENBQUFBLE1BQUFBLENBQVMsQ0FDdEJGLEdBQUFBLENBQUFBLENBQWdCSCxRQUNmSSxDQUFBQSxTQUFBQSxDQUFVQyxNQUFTLENBQUEsQ0FBQSxDQUFJdkIsQ0FBTXdCLENBQUFBLElBQUFBLENBQUtGLFNBQVcsQ0FBQSxDQUFBLENBQUEsQ0FBS0osQ0FLakMsQ0FBQSxDQUFBLFVBQUEsRUFBQSxPQUFSRCxDQUEyQyxFQUFBLElBQUEsRUFBckJBLENBQUtRLENBQUFBLFlBQUFBLENBQUFBLElBQ2hDcEIsQ0FBS1ksSUFBQUEsQ0FBQUEsQ0FBS1EsWUFDYUMsQ0FBQUEsS0FBQUEsQ0FBQUEsR0FBdkJMLENBQWdCaEIsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FDbkJnQixDQUFnQmhCLENBQUFBLENBQUFBLENBQUFBLENBQUtZLENBQUtRLENBQUFBLFlBQUFBLENBQWFwQixDQUtuQ3NCLENBQUFBLENBQUFBLENBQUFBLE9BQUFBLEdBQUFBLENBQVlWLENBQU1JLENBQUFBLENBQUFBLENBQWlCRixDQUFLQyxDQUFBQSxDQUFBQSxDQUFLLElBZTlDLENBQUEsQ0FBQSxTQUFTTyxHQUFZVixDQUFBQSxDQUFBQSxDQUFNTixDQUFPUSxDQUFBQSxDQUFBQSxDQUFLQyxDQUFLUSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUc1Q0MsQ0FBUSxDQUFBLENBQ2JaLElBQUFBLENBQUFBLENBQUFBLENBQ0FOLEtBQUFBLENBQUFBLENBQUFBLENBQ0FRLEdBQUFBLENBQUFBLENBQUFBLENBQ0FDLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQ1csSUFDRixDQUFBLEVBQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxDQUNELENBQ0YsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUtJTSxDQUNFLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxHQUFBLENBQ0EsSUFDWkksQ0FBQUEsV0FBQUEsQ0FBQUEsS0FBYUosQ0FDVSxDQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQVpFLElBQXFCMUIsR0FBVTBCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BSTNCLElBQVpBLEVBQUFBLENBQUFBLEVBQXFDLElBQWpCM0IsRUFBQUEsR0FBQUEsQ0FBUTRCLEtBQWU1QixFQUFBQSxHQUFBQSxDQUFRNEIsS0FBTUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFdERBLENBR1IsQ0FJTyxTQUFTRSxHQUFBQSxDQUFTcEIsQ0FDakJBLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQU1PLFFDNUVQLENBQUEsU0FBU2MsR0FBVXJCLENBQUFBLENBQUFBLENBQU9zQixDQUMzQnRCLENBQUFBLENBQUFBLElBQUFBLENBQUFBLEtBQUFBLENBQVFBLENBQ1JzQixDQUFBQSxJQUFBQSxDQUFBQSxPQUFBQSxDQUFVQSxFQXlFVCxDQUFBLFNBQVNDLEdBQWNMLENBQUFBLENBQUFBLENBQU9NLENBQ2xCLENBQUEsQ0FBQSxHQUFBLElBQUEsRUFBZEEsQ0FFSU4sQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FDSkssR0FBY0wsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZUEsQ0FBd0JPLENBQUFBLEVBQUFBLENBQUFBLEdBQUFBLENBQUFBLE9BQUFBLENBQVFQLENBQVMsQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUN0RSxJQUdBUSxDQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxDQUNHRixDQUFhTixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFnQk4sTUFBUVksQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FHNUIsSUFGZkUsR0FBQUEsQ0FBQUEsQ0FBVVIsQ0FBZ0JNLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBRWEsSUFBaEJFLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLE9BSWZBLENBU21CLENBQUEsR0FBQSxDQUFBLE9BQUEsVUFBQSxFQUFBLE9BQWRSLENBQU1aLENBQUFBLElBQUFBLENBQXFCaUIsR0FBY0wsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBUyxJQXVDakUsQ0FBQSxTQUFTUyxJQUF3QlQsQ0FBakMsQ0FBQSxDQUFBLElBR1d4QixDQUNKa0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FIeUIsSUFBMUJWLEdBQUFBLENBQUFBLENBQVFBLENBQThDLENBQUEsRUFBQSxDQUFBLEVBQUEsSUFBQSxFQUFwQkEsQ0FBMEIsQ0FBQSxHQUFBLENBQUEsQ0FBQSxJQUNoRUEsQ0FBYUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBaUJXLElBQU8sQ0FBQSxJQUFBLENBQzVCbkMsQ0FBSSxDQUFBLENBQUEsQ0FBR0EsQ0FBSXdCLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQWdCTixNQUFRbEIsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FFOUIsSUFEVGtDLEdBQUFBLENBQUFBLENBQVFWLENBQWdCeEIsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFDTyxJQUFka0MsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBb0IsQ0FDeENWLENBQUFBLENBQUFBLEdBQUFBLENBQWFBLENBQWlCVyxDQUFBQSxHQUFBQSxDQUFBQSxJQUFBQSxDQUFPRCxDQUtoQ0QsQ0FBQUEsR0FBQUEsQ0FBQUEsS0FBQUEsQ0FBQUEsT0FBQUEsR0FBQUEsQ0FBd0JULENBeUIxQixDQUFBLENBQUEsQ0FBQSxTQUFTWSxHQUFjQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUUxQkEsQ0FDQUEsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBVyxDQUNadkMsQ0FBQUEsRUFBQUEsR0FBQUEsQ0FBY3dDLElBQUtELENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQ2xCRSxHQUNGeEMsQ0FBQUEsR0FBQUEsRUFBQUEsRUFBQUEsR0FBQUEsR0FBaUJILEdBQVE0QyxDQUFBQSxpQkFBQUEsR0FBQUEsQ0FBQUEsQ0FFekJ6QyxHQUFlSCxDQUFBQSxHQUFBQSxDQUFRNEMsaUJBQ05DLEdBQUFBLFVBQUFBLEVBQVlGLEdBSy9CLEVBQUEsQ0FBQSxTQUFTQSxHQUNKRyxFQUFBQSxDQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxDQUNJSCxHQUF5QnpDLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQWNvQixNQUM5Q3dCLEVBQUFBLENBQUFBLENBQVE1QyxHQUFjNkMsQ0FBQUEsSUFBQUEsQ0FBSyxTQUFDQyxDQUFBQSxDQUFHQyxVQUFNRCxDQUFrQkMsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDdkQvQyxHQUFnQixDQUFBLEVBQUEsQ0FHaEI0QyxDQUFNSSxDQUFBQSxJQUFBQSxDQUFLLFNBQUFULENBQUFBLENBQUFBLENBekZiLElBQXlCVSxDQUFBQSxDQU1uQkMsQ0FDRUMsQ0FBQUEsQ0FBQUEsQ0FOSHpCLENBQ0gwQixDQUFBQSxDQUFBQSxDQUNBQyxDQXVGS2QsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0F4RkxhLENBREcxQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQURvQnVCLENBMEZRVixDQUFBQSxDQUFBQSxFQUFBQSxHQUFBQSxFQUFBQSxHQUFBQSxDQUFBQSxDQXZGL0JjLENBQVlKLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLElBR1JDLENBQWMsQ0FBQSxFQUFBLENBQUEsQ0FDWkMsQ0FBVzdDLENBQUFBLEdBQUFBLENBQU8sRUFBSW9CLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLEdBQUFBLENBQ1BBLENBQWtCLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FFdkM0QixHQUNDRCxDQUFBQSxDQUFBQSxDQUNBM0IsQ0FDQXlCLENBQUFBLENBQUFBLENBQ0FGLENBQzhCMUIsQ0FBQUEsR0FBQUEsQ0FBQUEsS0FBQUEsQ0FBQUEsR0FBOUI4QixDQUFVRSxDQUFBQSxlQUFBQSxDQUNVLElBQXBCN0IsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBMkIsQ0FBQzBCLENBQUFBLENBQUFBLENBQVUsSUFDdENGLENBQUFBLENBQUFBLENBQ1UsSUFBVkUsRUFBQUEsQ0FBQUEsQ0FBaUJyQixHQUFjTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFTMEIsQ0FDeEMxQixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUVEOEIsR0FBV04sQ0FBQUEsQ0FBQUEsQ0FBYXhCLENBRXBCQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFjMEIsQ0FDakJqQixFQUFBQSxHQUFBQSxDQUF3QlQsQ0d0SDNCLENBQUEsQ0FBQSxFQUFBLENBQUEsRUFBQSxDQUFBLFNBQWdCK0IsR0FDZkosQ0FBQUEsQ0FBQUEsQ0FDQUssQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQUMsRUFDQUMsQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQUMsQ0FDQWIsQ0FBQUEsQ0FBQUEsQ0FDQUUsQ0FDQVksQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FWRCxJQVlLOUQsQ0FBQUEsQ0FBRytELENBQUdkLENBQUFBLENBQUFBLENBQVVlLENBQVlDLENBQUFBLENBQUFBLENBQVFDLENBQWVDLENBQUFBLENBQUFBLENBSW5EQyxDQUFlVixDQUFBQSxDQUFBQSxFQUFrQkEsQ0FBNkJ4RCxDQUFBQSxHQUFBQSxFQUFBQSxHQUFBQSxDQUU5RG1FLENBQW9CRCxDQUFBQSxDQUFBQSxDQUFZbEQsTUFFcEN1QyxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUEyQixFQUN0QnpELENBQUFBLENBQUFBLENBQUksQ0FBR0EsQ0FBQUEsQ0FBQUEsQ0FBSXdELENBQWF0QyxDQUFBQSxNQUFBQSxDQUFRbEIsQ0FnRGxCLEVBQUEsQ0FBQSxHQUFBLElBQUEsR0E1Q2pCZ0UsQ0FBYVAsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBeUJ6RCxDQURyQixDQUFBLENBQUEsSUFBQSxHQUZsQmdFLENBQWFSLENBQUFBLENBQUFBLENBQWF4RCxDQUVxQixDQUFBLENBQUEsRUFBQSxTQUFBLEVBQUEsT0FBZGdFLENBQ1csQ0FBQSxJQUFBLENBTXRCLFFBQWRBLEVBQUFBLE9BQUFBLENBQUFBLEVBQ2MsUUFBZEEsRUFBQUEsT0FBQUEsQ0FBQUEsRUFFYyxRQUFkQSxFQUFBQSxPQUFBQSxDQUFBQSxDQUVvQzFDLEdBQzFDLENBQUEsSUFBQSxDQUNBMEMsQ0FDQSxDQUFBLElBQUEsQ0FDQSxJQUNBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUVTTSxLQUFNQyxDQUFBQSxPQUFBQSxDQUFRUCxDQUNtQjFDLENBQUFBLENBQUFBLEdBQUFBLENBQzFDSSxHQUNBLENBQUEsQ0FBRWIsUUFBVW1ELENBQUFBLENBQUFBLENBQUFBLENBQ1osSUFDQSxDQUFBLElBQUEsQ0FDQSxNQUVTQSxDQUFvQixDQUFBLEdBQUEsQ0FBQSxDQUFBLENBS2ExQyxHQUMxQzBDLENBQUFBLENBQUFBLENBQVdwRCxJQUNYb0QsQ0FBQUEsQ0FBQUEsQ0FBVzFELEtBQ1gwRCxDQUFBQSxDQUFBQSxDQUFXbEQsR0FDWCxDQUFBLElBQUEsQ0FDQWtELENBRzBDQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQVM1Q0EsQ0FBcUJQLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQ3JCTyxDQUFvQlAsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBd0IsQ0FTOUIsQ0FBQSxJQUFBLElBSGRSLENBQVdtQixDQUFBQSxDQUFBQSxDQUFZcEUsQ0FJckJpRCxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQUNBZSxDQUFXbEQsQ0FBQUEsR0FBQUEsRUFBT21DLENBQVNuQyxDQUFBQSxHQUFBQSxFQUMzQmtELENBQVdwRCxDQUFBQSxJQUFBQSxHQUFTcUMsQ0FBU3JDLENBQUFBLElBQUFBLENBRTlCd0QsQ0FBWXBFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEtBQUtxQixDQUlaMEMsQ0FBQUEsS0FBQUEsSUFBQUEsQ0FBQUEsQ0FBSSxDQUFHQSxDQUFBQSxDQUFBQSxDQUFJTSxDQUFtQk4sQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBSyxDQUN2Q2QsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBV21CLENBQVlMLENBQUFBLENBQUFBLENBQUFBLEdBS3RCQyxDQUFXbEQsQ0FBQUEsR0FBQUEsRUFBT21DLENBQVNuQyxDQUFBQSxHQUFBQSxFQUMzQmtELENBQVdwRCxDQUFBQSxJQUFBQSxHQUFTcUMsQ0FBU3JDLENBQUFBLElBQUFBLENBQzVCLENBQ0R3RCxDQUFBQSxDQUFZTCxDQUFLMUMsQ0FBQUEsQ0FBQUEsS0FBQUEsQ0FBQUEsQ0FBQUEsS0FBQUEsQ0FHbEI0QixDQUFXLENBQUEsS0FBQSxDQU9iRyxHQUNDRCxDQUFBQSxDQUFBQSxDQUNBYSxDQUxEZixDQUFBQSxDQUFBQSxDQUFXQSxDQUFZaEQsRUFBQUEsR0FBQUEsQ0FPdEIwRCxFQUNBQyxDQUNBQyxDQUFBQSxDQUFBQSxDQUNBYixDQUNBRSxDQUFBQSxDQUFBQSxDQUNBWSxDQUdERyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFTRCxDQUVKRCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJQyxDQUFXakQsQ0FBQUEsR0FBQUEsR0FBUWtDLENBQVNsQyxDQUFBQSxHQUFBQSxFQUFPZ0QsQ0FDdENJLEdBQUFBLENBQUFBLEdBQU1BLENBQU8sQ0FBQSxFQUFBLENBQUEsQ0FDZGxCLENBQVNsQyxDQUFBQSxHQUFBQSxFQUFLb0QsQ0FBSzdCLENBQUFBLElBQUFBLENBQUtXLENBQVNsQyxDQUFBQSxHQUFBQSxDQUFLLElBQU1pRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUNoREcsQ0FBSzdCLENBQUFBLElBQUFBLENBQUt5QixDQUFHQyxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUF5QkMsQ0FBUUQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHakMsSUFBVkMsRUFBQUEsQ0FBQUEsRUFDa0IsSUFBakJDLEVBQUFBLENBQUFBLEdBQ0hBLENBQWdCRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUlVLFVBQW5CRCxFQUFBQSxPQUFBQSxDQUFBQSxDQUFXcEQsSUFDbEJvRCxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxHQUF5QmYsQ0FFekJlLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXNCZCxDQUFTc0IsQ0FBQUEsR0FBQUEsQ0FDOUJSLENBQ0FkLENBQUFBLENBQUFBLENBQ0FDLENBR0RELENBQUFBLENBQUFBLENBQUFBLENBQVN1QixHQUNSdEIsQ0FBQUEsQ0FBQUEsQ0FDQWEsQ0FDQWYsQ0FBQUEsQ0FBQUEsQ0FDQW1CLENBQ0FILENBQUFBLENBQUFBLENBQ0FmLENBSWdDLENBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBdkJPLENBQWU3QyxDQUFBQSxJQUFBQSxHQVF6QjZDLENBQTBCUCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUczQkEsQ0FDQUQsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBaUJDLEdBQ2pCQSxDQUFPekMsQ0FBQUEsVUFBQUEsRUFBYzBDLENBSXJCRCxHQUFBQSxDQUFBQSxDQUFTckIsR0FBY29CLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLElBSXpCUSxDQUFzQlMsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHakJsRSxDQUFJcUUsQ0FBQUEsQ0FBQUEsQ0FBbUJyRSxDQUNMLEVBQUEsRUFBQSxJQUFBLEVBQWxCb0UsQ0FBWXBFLENBQUFBLENBQUFBLENBQUFBLEdBRWdCLFVBQXZCeUQsRUFBQUEsT0FBQUEsQ0FBQUEsQ0FBZTdDLElBQ0MsRUFBQSxJQUFBLEVBQXZCd0QsQ0FBWXBFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQ1pvRSxDQUFZcEUsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBV3lELENBS3ZCQSxDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUEwQjVCLEdBQWM2QixDQUFBQSxDQUFBQSxDQUFnQjFELENBQUksQ0FBQSxDQUFBLENBQUEsQ0FBQSxDQUc3RDBFLENBQVFOLENBQUFBLENBQUFBLENBQVlwRSxDQUFJb0UsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBWXBFLENBS2xDbUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsSUFDRW5FLENBQUksQ0FBQSxDQUFBLENBQUdBLENBQUltRSxDQUFBQSxDQUFBQSxDQUFLakQsTUFBUWxCLENBQUFBLENBQUFBLEVBQUFBLENBQzVCMkUsR0FBU1IsQ0FBQUEsQ0FBQUEsQ0FBS25FLENBQUltRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFPbkUsQ0FBSW1FLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQU9uRSxDQUt2QyxDQUFBLEVBQUEsQ0FBQSxTQUFTd0UsR0FBZ0JSLENBQUFBLENBQUFBLENBQVlkLENBQVFDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBQTdDLElBS00zQixDQUFBQSxDQUhEYSxDQUFJMkIsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDSlksQ0FBTSxDQUFBLENBQUEsQ0FDSHZDLENBQUt1QyxFQUFBQSxDQUFBQSxDQUFNdkMsQ0FBRW5CLENBQUFBLE1BQUFBLENBQVEwRCxLQUN2QnBELENBQVFhLENBQUFBLENBQUFBLENBQUV1QyxDQU1icEQsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZ0J3QyxDQUdmZCxDQUFBQSxDQUFBQSxDQUR3QixVQUFkMUIsRUFBQUEsT0FBQUEsQ0FBQUEsQ0FBTVosSUFDUDRELENBQUFBLEdBQUFBLENBQWdCaEQsQ0FBTzBCLENBQUFBLENBQUFBLENBQVFDLENBRS9Cc0IsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDUnRCLENBQ0EzQixDQUFBQSxDQUFBQSxDQUNBQSxDQUNBYSxDQUFBQSxDQUFBQSxDQUNBYixDQUNBMEIsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FNR0EsQ0FTRCxDQUFBLFNBQVMyQixDQUFhaEUsQ0FBQUEsQ0FBQUEsQ0FBVWlFLENBQ3RDQSxDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxDQUFNQSxDQUFPLEVBQUEsRUFBQSxDQUNHLElBQVpqRSxFQUFBQSxDQUFBQSxFQUF1QyxTQUFaQSxFQUFBQSxPQUFBQSxDQUFBQSxHQUNwQnlELEtBQU1DLENBQUFBLE9BQUFBLENBQVExRCxDQUN4QkEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBU2lDLElBQUssQ0FBQSxTQUFBWixDQUNiMkMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBYTNDLENBQU80QyxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUdyQkEsQ0FBSXhDLENBQUFBLElBQUFBLENBQUt6QixDQUVIaUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHUixTQUFTTCxHQUFBQSxDQUNSdEIsQ0FDQWEsQ0FBQUEsQ0FBQUEsQ0FDQWYsQ0FDQW1CLENBQUFBLENBQUFBLENBQ0FILENBQ0FmLENBQUFBLENBQUFBLENBQUFBLENBTkQsSUFRSzZCLENBQUFBLENBdUJHQyxDQUFpQmpCLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEtBdEJJMUMsQ0FBeEIyQyxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUlIZSxDQUFVZixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQU1WQSxXQUFzQjNDLENBQ2hCLENBQUEsS0FBQSxHQUNNLElBQVo0QixFQUFBQSxDQUFBQSxFQUNBZ0IsQ0FBVWYsRUFBQUEsQ0FBQUEsRUFDVyxJQUFyQmUsRUFBQUEsQ0FBQUEsQ0FBT3hELFVBRVB3RSxDQUFBQSxDQUFBQSxDQUFPLEdBQWMsSUFBQSxFQUFWL0IsQ0FBa0JBLEVBQUFBLENBQUFBLENBQU96QyxVQUFlMEMsR0FBQUEsQ0FBQUEsQ0FDbERBLENBQVUrQixDQUFBQSxXQUFBQSxDQUFZakIsQ0FDdEJjLENBQUFBLENBQUFBLENBQUFBLENBQVUsSUFDSixDQUFBLEtBQUEsQ0FBQSxJQUdEQyxDQUFTOUIsQ0FBQUEsQ0FBQUEsQ0FBUWEsQ0FBSSxDQUFBLENBQUEsQ0FBQSxDQUN4QmlCLENBQVNBLENBQUFBLENBQUFBLENBQU9HLFdBQWdCcEIsR0FBQUEsQ0FBQUEsQ0FBSUssQ0FBWWxELENBQUFBLE1BQUFBLENBQ2pENkMsQ0FBSyxFQUFBLENBQUEsQ0FBQSxHQUVEaUIsQ0FBVWYsRUFBQUEsQ0FBQUEsQ0FBQUEsTUFDUGdCLENBR1I5QixDQUFBQSxDQUFBQSxDQUFVaUMsWUFBYW5CLENBQUFBLENBQUFBLENBQVFmLENBQy9CNkIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBVTdCLEVBT0k3QixDQUFBQSxPQUFBQSxLQUFBQSxDQUFBQSxHQUFaMEQsQ0FDTUEsQ0FBQUEsQ0FBQUEsQ0FFQWQsQ0FBT2tCLENBQUFBLFdBQUFBLENDOVRYLFNBQVNFLEdBQUFBLENBQVVDLENBQUtDLENBQUFBLENBQUFBLENBQVVDLENBQVU1QixDQUFBQSxDQUFBQSxDQUFPNkIsQ0FDckR6RixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxJQUVDQSxDQUFLd0YsSUFBQUEsQ0FBQUEsQ0FDQyxVQUFOeEYsR0FBQUEsQ0FBQUEsRUFBMEIsS0FBTkEsR0FBQUEsQ0FBQUEsRUFBaUJBLEtBQUt1RixDQUM3Q0csRUFBQUEsR0FBQUEsQ0FBWUosQ0FBS3RGLENBQUFBLENBQUFBLENBQUcsSUFBTXdGLENBQUFBLENBQUFBLENBQVN4RixDQUFJNEQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFJcEM1RCxDQUFLdUYsSUFBQUEsQ0FBQUEsQ0FFTkUsQ0FBaUMsRUFBQSxVQUFBLEVBQUEsT0FBZkYsQ0FBU3ZGLENBQUFBLENBQUFBLENBQUFBLEVBQ3ZCLFVBQU5BLEdBQUFBLENBQUFBLEVBQ00sS0FBTkEsR0FBQUEsQ0FBQUEsRUFDTSxPQUFOQSxHQUFBQSxDQUFBQSxFQUNNLFNBQU5BLEdBQUFBLENBQUFBLEVBQ0F3RixDQUFTeEYsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBT3VGLENBQVN2RixDQUFBQSxDQUFBQSxDQUFBQSxFQUV6QjBGLEdBQVlKLENBQUFBLENBQUFBLENBQUt0RixDQUFHdUYsQ0FBQUEsQ0FBQUEsQ0FBU3ZGLENBQUl3RixDQUFBQSxDQUFBQSxDQUFBQSxDQUFTeEYsQ0FBSTRELENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBS2pELFNBQVMrQixHQUFBQSxDQUFTQyxDQUFPOUUsQ0FBQUEsQ0FBQUEsQ0FBSytFLENBQ2QsQ0FBQSxDQUFBLEdBQUEsR0FBWC9FLENBQUksQ0FBQSxDQUFBLENBQUEsQ0FDUDhFLENBQU1GLENBQUFBLFdBQUFBLENBQVk1RSxDQUFLK0UsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFdkJELENBQU05RSxDQUFBQSxDQUFBQSxDQUFBQSxDQURhLElBQVQrRSxFQUFBQSxDQUFBQSxDQUNHLEVBQ2EsQ0FBQSxRQUFBLEVBQUEsT0FBVEEsQ0FBcUIxRixFQUFBQSxHQUFBQSxDQUFtQjJGLElBQUtoRixDQUFBQSxDQUFBQSxDQUFBQSxDQUNqRCtFLENBRUFBLENBQUFBLENBQUFBLENBQVEsS0FZaEIsQ0FBQSxTQUFTSCxHQUFZSixDQUFBQSxDQUFBQSxDQUFLUyxFQUFNRixDQUFPRyxDQUFBQSxDQUFBQSxDQUFVcEMsQ0FBakQsQ0FBQSxDQUFBLElBQ0ZxQyxDQUVKQyxDQUFBQSxDQUFBQSxDQUFHLEdBQWEsT0FBQSxHQUFUSCxDQUNjLENBQUEsR0FBQSxRQUFBLEVBQUEsT0FBVEYsQ0FDVlAsQ0FBQUEsQ0FBQUEsQ0FBSU0sS0FBTU8sQ0FBQUEsT0FBQUEsQ0FBVU4sQ0FDZCxDQUFBLEtBQUEsQ0FBQSxHQUNpQixRQUFaRyxFQUFBQSxPQUFBQSxDQUFBQSxHQUNWVixDQUFJTSxDQUFBQSxLQUFBQSxDQUFNTyxPQUFVSCxDQUFBQSxDQUFBQSxDQUFXLEVBRzVCQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUNFRCxDQUFRQyxJQUFBQSxDQUFBQSxDQUNOSCxDQUFTRSxFQUFBQSxDQUFBQSxJQUFRRixDQUN0QkYsRUFBQUEsR0FBQUEsQ0FBU0wsQ0FBSU0sQ0FBQUEsS0FBQUEsQ0FBT0csQ0FBTSxDQUFBLEVBQUEsQ0FBQSxDQUFBLEdBS3pCRixDQUNFRSxDQUFBQSxJQUFBQSxDQUFBQSxJQUFRRixDQUNQRyxDQUFBQSxDQUFBQSxFQUFZSCxDQUFNRSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFVQyxDQUFTRCxDQUFBQSxDQUFBQSxDQUFBQSxFQUN6Q0osR0FBU0wsQ0FBQUEsQ0FBQUEsQ0FBSU0sS0FBT0csQ0FBQUEsQ0FBQUEsQ0FBTUYsQ0FBTUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsS0FPaEMsR0FBZ0IsR0FBQSxHQUFaQSxDQUFLLENBQUEsQ0FBQSxDQUFBLEVBQTBCLEdBQVpBLEdBQUFBLENBQUFBLENBQUssQ0FDaENFLENBQUFBLENBQUFBLENBQUFBLENBQWFGLENBQVVBLElBQUFBLENBQUFBLENBQU9BLENBQUtLLENBQUFBLE9BQUFBLENBQVEsVUFBWSxDQUFBLEVBQUEsQ0FBQSxDQUFBLENBR3hCTCxFQUEzQkEsQ0FBS00sQ0FBQUEsV0FBQUEsRUFBQUEsR0FBaUJmLENBQVlTLENBQUFBLENBQUFBLENBQUtNLFdBQWMxRyxFQUFBQSxDQUFBQSxLQUFBQSxDQUFNLENBQ25Eb0csQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBS3BHLEtBQU0sQ0FBQSxDQUFBLENBQUEsQ0FFbEIyRixDQUFJZ0IsQ0FBQUEsQ0FBQUEsR0FBWWhCLENBQUlnQixDQUFBQSxDQUFBQSxDQUFhLEVBQ3RDaEIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBSWdCLENBQVdQLENBQUFBLENBQUFBLENBQU9FLENBQWNKLENBQUFBLENBQUFBLENBQUFBLENBRWhDQSxDQUNFRyxDQUFBQSxDQUFBQSxFQUVKVixDQUFJaUIsQ0FBQUEsZ0JBQUFBLENBQWlCUixDQURMRSxDQUFBQSxDQUFBQSxDQUFhTyxHQUFvQkMsQ0FBQUEsQ0FBQUEsQ0FDYlIsQ0FJckNYLENBQUFBLENBQUFBLENBQUFBLENBQUlvQixtQkFBb0JYLENBQUFBLENBQUFBLENBRFJFLENBQWFPLENBQUFBLEdBQUFBLENBQW9CQyxDQUNWUixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxLQUVsQyxHQUFhLHlCQUFBLEdBQVRGLENBQW9DLENBQUEsQ0FBQSxHQUMxQ25DLENBSUhtQyxDQUFBQSxDQUFBQSxDQUFPQSxDQUFLSyxDQUFBQSxPQUFBQSxDQUFRLGFBQWUsQ0FBQSxHQUFBLENBQUEsQ0FBS0EsT0FBUSxDQUFBLFFBQUEsQ0FBVSxHQUNwRCxDQUFBLENBQUEsS0FBQSxHQUNHLE1BQVRMLEdBQUFBLENBQUFBLEVBQ1MsTUFBVEEsR0FBQUEsQ0FBQUEsRUFDUyxNQUFUQSxHQUFBQSxDQUFBQSxFQUdTLFVBQVRBLEdBQUFBLENBQUFBLEVBQ1MsVUFBVEEsR0FBQUEsQ0FBQUEsRUFDQUEsQ0FBUVQsSUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FHUEEsRUFBSVMsQ0FBaUIsQ0FBQSxDQUFBLElBQUEsRUFBVEYsQ0FBZ0IsQ0FBQSxFQUFBLENBQUtBLENBRTNCSyxDQUFBQSxNQUFBQSxDQUFBQSxDQUNMLE1BQU9TLENBQUFBLENBQUFBLEVBVVcsVUFBVmQsRUFBQUEsT0FBQUEsQ0FBQUEsR0FHRCxJQUFUQSxFQUFBQSxDQUFBQSxHQUFBQSxDQUNXLENBQVZBLEdBQUFBLENBQUFBLEVBQWdDLEdBQVpFLEdBQUFBLENBQUFBLENBQUssQ0FBMEIsQ0FBQSxFQUFBLEdBQUEsR0FBWkEsQ0FBSyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBRTdDVCxDQUFJc0IsQ0FBQUEsWUFBQUEsQ0FBYWIsQ0FBTUYsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFdkJQLENBQUl1QixDQUFBQSxlQUFBQSxDQUFnQmQsQ0FVdkIsQ0FBQSxFQUFBLENBQUEsQ0FBQSxTQUFTVSxDQUFXRSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUFBQSxDQUNkTCxDQUFXSyxDQUFBQSxDQUFBQSxDQUFFL0YsSUFBTyxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQU9oQixHQUFRa0gsQ0FBQUEsS0FBQUEsQ0FBUWxILEdBQVFrSCxDQUFBQSxLQUFBQSxDQUFNSCxDQUFLQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUdwRSxTQUFTSCxHQUFBQSxDQUFrQkcsQ0FDckJMLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQUFBLENBQVdLLENBQUUvRixDQUFBQSxJQUFBQSxDQUFBQSxDQUFPLENBQU1oQixDQUFBQSxDQUFBQSxHQUFBQSxDQUFRa0gsS0FBUWxILENBQUFBLEdBQUFBLENBQVFrSCxLQUFNSCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFLQSxDQ3BJbkUsRUFBQSxDQUFBLFNBQWdCdkQsR0FDZkQsQ0FBQUEsQ0FBQUEsQ0FDQTRELENBQ0E5RCxDQUFBQSxDQUFBQSxDQUNBVSxDQUNBQyxDQUFBQSxDQUFBQSxDQUNBQyxDQUNBYixDQUFBQSxDQUFBQSxDQUNBRSxFQUNBWSxDQVRELENBQUEsQ0FBQSxJQVdLYyxDQW9CRXZDLENBQUFBLENBQUFBLENBQUcyRSxDQUFPeEIsQ0FBQUEsQ0FBQUEsQ0FBVXlCLENBQVVDLENBQUFBLENBQUFBLENBQVVDLENBQ3hDNUIsQ0FBQUEsQ0FBQUEsQ0FLQTZCLENBQ0FDLENBQUFBLENBQUFBLENBaUhBQyxDQUNIQyxDQUFBQSxDQUFBQSxDQWlDRy9ELENBN0tMZ0UsQ0FBQUEsQ0FBQUEsQ0FBVVQsQ0FBU25HLENBQUFBLElBQUFBLENBQUFBLEdBQUFBLEtBSVNTLENBQXpCMEYsR0FBQUEsQ0FBQUEsQ0FBU3RGLFdBQTJCLENBQUEsT0FBTyxJQUdwQixDQUFBLElBQUEsRUFBdkJ3QixDQUNIYSxDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFjYixDQUNkQyxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFTNkQsQ0FBZ0I5RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUV6QjhELENBQXNCLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FDdEJsRCxDQUFvQixDQUFBLENBQUNYLENBR2pCMEIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTWhGLEdBQWdCZ0YsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBSW1DLENBRzlCOUIsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTyxHQUFzQixVQUFBLEVBQUEsT0FBWHVDLENBQXVCLENBQUEsQ0FBQSxHQUVwQ2pDLENBQVd3QixDQUFBQSxDQUFBQSxDQUFTekcsS0FLcEI4RyxDQUFBQSxDQUFBQSxDQUFBQSxDQURKeEMsQ0FBTTRDLENBQUFBLENBQUFBLENBQVFDLFdBQ1E5RCxHQUFBQSxDQUFBQSxDQUFjaUIsQ0FDaEN5QyxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFtQnpDLENBQ3BCd0MsQ0FBQUEsQ0FBQUEsQ0FDQ0EsQ0FBUzlHLENBQUFBLEtBQUFBLENBQU11RixLQUNmakIsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FDRGpCLENBR0NWLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBRUhrRSxHQURBOUUsQ0FBSTBFLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXNCOUQsQ0FDMEJaLENBQUFBLEdBQUFBLEVBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBR2hELFdBQWVtRixHQUFBQSxDQUFBQSxFQUFXQSxDQUFRRSxDQUFBQSxTQUFBQSxDQUFVQyxNQUUvQ1osQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBc0IxRSxDQUFJLENBQUEsSUFBSW1GLENBQVFqQyxDQUFBQSxDQUFBQSxDQUFVOEIsQ0FHaEROLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXNCMUUsQ0FBSSxDQUFBLElBQUlWLEdBQVU0RCxDQUFBQSxDQUFBQSxDQUFVOEIsQ0FDbERoRixDQUFBQSxDQUFBQSxDQUFBQSxDQUFFWixXQUFjK0YsQ0FBQUEsQ0FBQUEsQ0FDaEJuRixDQUFFc0YsQ0FBQUEsTUFBQUEsQ0FBU0MsR0FFUlIsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBVUEsQ0FBU1MsQ0FBQUEsR0FBQUEsQ0FBSXhGLEdBRTNCQSxDQUFFL0IsQ0FBQUEsS0FBQUEsQ0FBUWlGLENBQ0xsRCxDQUFBQSxDQUFBQSxDQUFFeUYsS0FBT3pGLEdBQUFBLENBQUFBLENBQUV5RixLQUFRLENBQUEsRUFBQSxDQUFBLENBQ3hCekYsQ0FBRVQsQ0FBQUEsT0FBQUEsQ0FBVXlGLENBQ1poRixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFtQnNCLENBQ25CcUQsQ0FBQUEsQ0FBQUEsQ0FBUTNFLENBQVcsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQ25CQSxDQUFxQixDQUFBLEdBQUEsQ0FBQSxFQUFBLENBQUEsQ0FJRixJQUFoQkEsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0FDSEEsQ0FBZUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBRXlGLEtBRXNCLENBQUEsQ0FBQSxJQUFBLEVBQXBDTixDQUFRTyxDQUFBQSx3QkFBQUEsR0FDUDFGLENBQWdCQSxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFFeUYsS0FDckJ6RixHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFlakMsSUFBTyxFQUFJaUMsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHM0JqQyxHQUNDaUMsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDQW1GLENBQVFPLENBQUFBLHdCQUFBQSxDQUF5QnhDLENBQVVsRCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUk3Q21ELENBQVduRCxDQUFBQSxDQUFBQSxDQUFFL0IsS0FDYjJHLENBQUFBLENBQUFBLENBQVc1RSxDQUFFeUYsQ0FBQUEsS0FBQUEsQ0FHVGQsQ0FFa0MsQ0FBQSxJQUFBLEVBQXBDUSxDQUFRTyxDQUFBQSx3QkFBQUEsRUFDZ0IsSUFBeEIxRixFQUFBQSxDQUFBQSxDQUFFMkYsa0JBRUYzRixFQUFBQSxDQUFBQSxDQUFFMkYsa0JBR3dCLEVBQUEsQ0FBQSxJQUFBLEVBQXZCM0YsQ0FBRTRGLENBQUFBLGlCQUFBQSxFQUNMNUYsQ0FBbUJDLENBQUFBLEdBQUFBLENBQUFBLElBQUFBLENBQUtELENBQUU0RixDQUFBQSxpQkFBQUEsQ0FBQUEsQ0FBQUEsS0FFckIsQ0FFK0IsR0FBQSxJQUFBLEVBQXBDVCxDQUFRTyxDQUFBQSx3QkFBQUEsRUFDUnhDLENBQWFDLEdBQUFBLENBQUFBLEVBQ2tCLElBQS9CbkQsRUFBQUEsQ0FBQUEsQ0FBRTZGLHlCQUVGN0YsRUFBQUEsQ0FBQUEsQ0FBRTZGLHlCQUEwQjNDLENBQUFBLENBQUFBLENBQVU4QixDQUlwQ2hGLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQzBCLElBQTNCQSxFQUFBQSxDQUFBQSxDQUFFOEYscUJBS0ksRUFBQSxDQUFBLENBQUEsR0FKTjlGLENBQUU4RixDQUFBQSxxQkFBQUEsQ0FDRDVDLENBQ0FsRCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUNBZ0YsQ0FFRk4sQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0FBdUI5RCxDQUN0QixDQUFBLEdBQUEsQ0FBQSxDQUNEWixDQUFFL0IsQ0FBQUEsS0FBQUEsQ0FBUWlGLENBQ1ZsRCxDQUFBQSxDQUFBQSxDQUFFeUYsS0FBUXpGLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBRU4wRSxRQUF1QjlELENBQW9CWixDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFXLENBQzFEQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFXMEUsQ0FDWEEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBZ0I5RCxDQUNoQjhELENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXFCOUQsQ0FDckI4RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFtQnFCLE9BQVEsQ0FBQSxTQUFBNUcsQ0FDdEJBLENBQUFBLENBQUFBLENBQUFBLEdBQU9BLENBQWdCdUYsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FFeEIxRSxDQUFtQm5CLENBQUFBLEdBQUFBLENBQUFBLE1BQUFBLEVBQ3RCOEIsQ0FBWVYsQ0FBQUEsSUFBQUEsQ0FBS0QsQ0FHWjRDLENBQUFBLENBQUFBLE1BQUFBLENBQUFBLENBR3NCLElBQXpCNUMsRUFBQUEsQ0FBQUEsQ0FBRWdHLG1CQUNMaEcsRUFBQUEsQ0FBQUEsQ0FBRWdHLG1CQUFvQjlDLENBQUFBLENBQUFBLENBQVVsRCxDQUFjZ0YsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHbkIsSUFBeEJoRixFQUFBQSxDQUFBQSxDQUFFaUcsa0JBQ0xqRyxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFtQkMsSUFBSyxDQUFBLFVBQUEsQ0FDdkJELENBQUVpRyxDQUFBQSxrQkFBQUEsQ0FBbUI5QyxDQUFVeUIsQ0FBQUEsQ0FBQUEsQ0FBVUMsQ0FLNUM3RSxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFFVCxPQUFVeUYsQ0FBQUEsQ0FBQUEsQ0FDWmhGLENBQUUvQixDQUFBQSxLQUFBQSxDQUFRaUYsQ0FDVmxELENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQVcwRSxDQUNYMUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBZWMsQ0FFWG1FLENBQUFBLENBQUFBLENBQWExSCxHQUNoQjJILENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQVEsQ0FDTCxDQUFBLFdBQUEsR0FBZUMsQ0FBV0EsRUFBQUEsQ0FBQUEsQ0FBUUUsU0FBVUMsQ0FBQUEsTUFBQUEsQ0FDL0N0RixDQUFFeUYsQ0FBQUEsS0FBQUEsQ0FBUXpGLE1BQ1ZBLENBQVcsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBRVBpRixDQUFZQSxFQUFBQSxDQUFBQSxDQUFXUCxDQUUzQm5DLENBQUFBLENBQUFBLENBQUFBLENBQU12QyxDQUFFc0YsQ0FBQUEsTUFBQUEsQ0FBT3RGLENBQUUvQixDQUFBQSxLQUFBQSxDQUFPK0IsQ0FBRXlGLENBQUFBLEtBQUFBLENBQU96RixDQUFFVCxDQUFBQSxPQUFBQSxDQUFBQSxDQUFBQSxLQUFBQSxFQUFBQSxDQUdsQ1MsQ0FBVyxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDUGlGLENBQVlBLEVBQUFBLENBQUFBLENBQVdQLENBRTNCbkMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTXZDLENBQUVzRixDQUFBQSxNQUFBQSxDQUFPdEYsQ0FBRS9CLENBQUFBLEtBQUFBLENBQU8rQixDQUFFeUYsQ0FBQUEsS0FBQUEsQ0FBT3pGLENBQUVULENBQUFBLE9BQUFBLENBQUFBLENBR25DUyxDQUFFeUYsQ0FBQUEsS0FBQUEsQ0FBUXpGLENBQ0ZBLENBQUFBLElBQUFBLENBQUFBLE1BQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQUFBLEVBQWNrRixDQUFRLENBQUEsRUFBQSxFQUloQ2xGLENBQUV5RixDQUFBQSxLQUFBQSxDQUFRekYsQ0FFZSxDQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQXJCQSxDQUFFa0csQ0FBQUEsZUFBQUEsR0FDTDVFLENBQWdCdkQsQ0FBQUEsR0FBQUEsQ0FBT0EsR0FBTyxDQUFBLEVBQUEsQ0FBSXVELENBQWdCdEIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBRWtHLGVBR2hEdkIsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBc0MsSUFBN0IzRSxFQUFBQSxDQUFBQSxDQUFFbUcsdUJBQ2Z0QixHQUFBQSxDQUFBQSxDQUFXN0UsQ0FBRW1HLENBQUFBLHVCQUFBQSxDQUF3QmhELENBQVV5QixDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUs1Q3pELENBREksQ0FBQSxJQUFBLEVBQVBvQixDQUFlQSxFQUFBQSxDQUFBQSxDQUFJaEUsSUFBU2MsR0FBQUEsR0FBQUEsRUFBdUIsTUFBWGtELENBQUk5RCxDQUFBQSxHQUFBQSxDQUNMOEQsQ0FBSXRFLENBQUFBLEtBQUFBLENBQU1PLFFBQVcrRCxDQUFBQSxDQUFBQSxDQUU3RHJCLEdBQ0NKLENBQUFBLENBQUFBLENBQ0FtQixLQUFNQyxDQUFBQSxPQUFBQSxDQUFRZixDQUFnQkEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBZSxDQUFDQSxDQUFBQSxDQUFBQSxDQUM5Q3VELENBQ0E5RCxDQUFBQSxDQUFBQSxDQUNBVSxDQUNBQyxDQUFBQSxDQUFBQSxDQUNBQyxDQUNBYixDQUFBQSxDQUFBQSxDQUNBRSxDQUNBWSxDQUFBQSxDQUFBQSxDQUFBQSxDQUdEekIsQ0FBRUYsQ0FBQUEsSUFBQUEsQ0FBTzRFLENBR1RBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXNCLElBRWxCMUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBbUJuQixNQUN0QjhCLEVBQUFBLENBQUFBLENBQVlWLElBQUtELENBQUFBLENBQUFBLENBQUFBLENBR2Q4RSxDQUNIOUUsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBa0JBLENBQXlCLENBQUEsRUFBQSxDQUFBLElBQUEsQ0FBQSxDQUc1Q0EsQ0FBVyxDQUFBLEdBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxLQUVVLElBQXJCd0IsRUFBQUEsQ0FBQUEsRUFDQWtELENBQXVCOUQsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFFdkI4RCxDQUFxQjlELENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQ3JCOEQsQ0FBZ0I5RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUVoQjhELENBQWdCMEIsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FDZnhGLENBQ0E4RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUNBOUQsQ0FDQVUsQ0FBQUEsQ0FBQUEsQ0FDQUMsQ0FDQUMsQ0FBQUEsQ0FBQUEsQ0FDQWIsQ0FDQWMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FJR2MsQ0FBTWhGLENBQUFBLEdBQUFBLENBQVE4SSxNQUFTOUQsR0FBQUEsQ0FBQUEsQ0FBSW1DLENBQy9CLEVBQUEsQ0FBQSxNQUFPSixHQUNSSSxDQUFxQixDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQUEsQ0FFakJqRCxDQUFvQyxFQUFBLElBQUEsRUFBckJELENBQ2xCa0QsSUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBZ0I3RCxDQUNoQjZELENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQXdCakQsQ0FDeEJELENBQUFBLENBQUFBLENBQWtCQSxDQUFrQjlCLENBQUFBLE9BQUFBLENBQVFtQixDQUFXLENBQUEsQ0FBQSxDQUFBLElBQUEsQ0FBQSxDQUl4RHRELEdBQW9CK0csQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBR0ksQ0FBVTlELENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBUzVCLFNBQVNLLEdBQUFBLENBQVdOLENBQWEyRixDQUFBQSxDQUFBQSxDQUFBQSxDQUNuQy9JLEdBQWlCQSxDQUFBQSxHQUFBQSxFQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFnQitJLENBQU0zRixDQUFBQSxDQUFBQSxDQUFBQSxDQUUzQ0EsQ0FBWUYsQ0FBQUEsSUFBQUEsQ0FBSyxTQUFBVCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUdmVyxDQUFjWCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUNkQSxDQUFxQixDQUFBLEdBQUEsQ0FBQSxFQUFBLENBQ3JCVyxDQUFZRixDQUFBQSxJQUFBQSxDQUFLLFNBQUE4RixDQUFBQSxDQUFBQSxDQUVoQkEsQ0FBR3pILENBQUFBLElBQUFBLENBQUtrQixDQUVSLEVBQUEsQ0FBQSxFQUFBLENBQUEsTUFBT3NFLENBQ1IvRyxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFvQitHLENBQUd0RSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQW1CMUIsU0FBU29HLEdBQUFBLENBQ1JuRCxDQUNBeUIsQ0FBQUEsQ0FBQUEsQ0FDQTlELENBQ0FVLENBQUFBLENBQUFBLENBQ0FDLENBQ0FDLENBQUFBLENBQUFBLENBQ0FiLENBQ0FjLENBQUFBLENBQUFBLENBQUFBLENBUkQsSUFvQlM1QixDQUFBQSxDQXNESDJHLENBQ0FDLENBQUFBLENBQUFBLENBakVEdEQsQ0FBV3ZDLENBQUFBLENBQUFBLENBQVMzQyxNQUNwQmlGLENBQVd3QixDQUFBQSxDQUFBQSxDQUFTekcsS0FDcEJ5SSxDQUFBQSxDQUFBQSxDQUFXaEMsQ0FBU25HLENBQUFBLElBQUFBLENBQ3BCWixDQUFJLENBQUEsQ0FBQSxDQUFBLEdBR1MsS0FBYitJLEdBQUFBLENBQUFBLEdBQW9CbkYsQ0FBUSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBRVAsSUFBckJDLEVBQUFBLENBQUFBLENBQUFBLEtBQ0k3RCxDQUFJNkQsQ0FBQUEsQ0FBQUEsQ0FBa0IzQyxNQUFRbEIsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsQ0FDOUJrQyxDQUFRMkIsQ0FBQUEsQ0FBQUEsQ0FBa0I3RCxDQU8vQixDQUFBLEdBQUEsY0FBQSxHQUFrQmtDLENBQVk2RyxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUM3QkEsQ0FBVzdHLENBQUFBLENBQUFBLENBQU04RyxTQUFjRCxHQUFBQSxDQUFBQSxDQUE4QixDQUFuQjdHLEdBQUFBLENBQUFBLENBQU02RyxRQUNoRCxDQUFBLENBQUEsQ0FDRHpELENBQU1wRCxDQUFBQSxDQUFBQSxDQUNOMkIsQ0FBa0I3RCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFLLElBTWYsQ0FBQSxLQUFBLENBQUEsR0FBQSxJQUFBLEVBQVBzRixDQUFhLENBQUEsQ0FBQSxHQUNDLElBQWJ5RCxHQUFBQSxDQUFBQSxDQUFBQSxPQUVJRSxRQUFTQyxDQUFBQSxjQUFBQSxDQUFlM0QsQ0FJL0JELENBQUFBLENBQUFBLENBQUFBLENBREcxQixDQUNHcUYsQ0FBQUEsUUFBQUEsQ0FBU0UsZUFDZCxDQUFBLDRCQUFBLENBRUFKLENBR0tFLENBQUFBLENBQUFBLFFBQUFBLENBQVN0SSxhQUVkb0ksQ0FBQUEsQ0FBQUEsQ0FDQXhELENBQVM2RCxDQUFBQSxFQUFBQSxFQUFNN0QsQ0FLakIxQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFvQixJQUVwQkMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBYyxFQUdFLENBQUEsR0FBQSxJQUFBLEdBQWJpRixFQUVDdkQsQ0FBYUQsR0FBQUEsQ0FBQUEsRUFBY3pCLENBQWV3QixFQUFBQSxDQUFBQSxDQUFJK0QsSUFBUzlELEdBQUFBLENBQUFBLEdBQzFERCxDQUFJK0QsQ0FBQUEsSUFBQUEsQ0FBTzlELENBRU4sQ0FBQSxDQUFBLEtBQUEsQ0FBQSxHQUVOMUIsQ0FBb0JBLENBQUFBLENBQUFBLEVBQXFCbEUsQ0FBTXdCLENBQUFBLElBQUFBLENBQUttRSxDQUFJZ0UsQ0FBQUEsVUFBQUEsQ0FBQUEsQ0FJcERULENBRkpyRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFXdkMsQ0FBUzNDLENBQUFBLEtBQUFBLEVBQVNMLEdBRU5zSixFQUFBQSx1QkFBQUEsQ0FDbkJULENBQVV2RCxDQUFBQSxDQUFBQSxDQUFTZ0UsdUJBSWxCekYsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBYSxDQUdRLEdBQUEsSUFBQSxFQUFyQkQsQ0FDSDJCLENBQUFBLElBQUFBLENBQUFBLENBQVcsRUFDTnhGLENBQUFBLENBQUFBLENBQUksQ0FBR0EsQ0FBQUEsQ0FBQUEsQ0FBSXNGLENBQUlrRSxDQUFBQSxVQUFBQSxDQUFXdEksTUFBUWxCLENBQUFBLENBQUFBLEVBQUFBLENBQ3RDd0YsQ0FBU0YsQ0FBQUEsQ0FBQUEsQ0FBSWtFLFVBQVd4SixDQUFBQSxDQUFBQSxDQUFBQSxDQUFHK0YsSUFBUVQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBSWtFLFVBQVd4SixDQUFBQSxDQUFBQSxDQUFBQSxDQUFHNkYsS0FJbkRpRCxDQUFBQSxDQUFBQSxDQUFBQSxFQUFXRCxDQUdaQyxJQUFBQSxDQUFBQSxHQUNFRCxDQUFXQyxFQUFBQSxDQUFBQSxDQUFBQSxNQUFBQSxFQUFrQkQsQ0FDL0JDLENBQUFBLE1BQUFBLEVBQUFBLENBQUFBLENBQUFBLE1BQUFBLEdBQW1CeEQsQ0FBSW1FLENBQUFBLFNBQUFBLENBQUFBLEdBRXhCbkUsQ0FBSW1FLENBQUFBLFNBQUFBLENBQWFYLENBQVdBLEVBQUFBLENBQUFBLENBQUFBLE1BQUFBLEVBQW1CLEVBS2xEekQsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBVUMsRUFBS0MsQ0FBVUMsQ0FBQUEsQ0FBQUEsQ0FBVTVCLENBQU9FLENBQUFBLENBQUFBLENBQUFBLENBR3RDZ0YsQ0FDSC9CLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXFCLEVBRXJCL0csQ0FBQUEsS0FBQUEsR0FBQUEsQ0FBQUEsQ0FBSStHLENBQVN6RyxDQUFBQSxLQUFBQSxDQUFNTyxRQUNuQjBDLENBQUFBLEdBQUFBLENBQ0MrQixDQUNBaEIsQ0FBQUEsS0FBQUEsQ0FBTUMsT0FBUXZFLENBQUFBLENBQUFBLENBQUFBLENBQUtBLENBQUksQ0FBQSxDQUFDQSxDQUN4QitHLENBQUFBLENBQUFBLENBQUFBLENBQ0E5RCxDQUNBVSxDQUFBQSxDQUFBQSxDQUNBQyxDQUFzQixFQUFBLGVBQUEsR0FBYm1GLENBQ1RsRixDQUFBQSxDQUFBQSxDQUNBYixDQUNBYSxDQUFBQSxDQUFBQSxDQUNHQSxDQUFrQixDQUFBLENBQUEsQ0FBQSxDQUNsQlosQ0FBc0JwQixDQUFBQSxHQUFBQSxFQUFBQSxHQUFBQSxDQUFjb0IsQ0FBVSxDQUFBLENBQUEsQ0FBQSxDQUNqRGEsQ0FJd0IsQ0FBQSxDQUFBLElBQUEsRUFBckJELENBQ0U3RCxDQUFBQSxJQUFBQSxDQUFBQSxDQUFJNkQsQ0FBa0IzQyxDQUFBQSxNQUFBQSxDQUFRbEIsQ0FDTixFQUFBLEVBQUEsSUFBQSxFQUF4QjZELENBQWtCN0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBWU8sR0FBV3NELENBQUFBLENBQUFBLENBQWtCN0QsQ0FNN0Q4RCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUVILE9BQVd5QixHQUFBQSxDQUFBQSxFQUFBQSxLQUNjbEUsQ0FBeEJyQixJQUFBQSxDQUFBQSxDQUFJdUYsQ0FBU00sQ0FBQUEsS0FBQUEsQ0FBQUEsR0FLYjdGLENBQU1zRixHQUFBQSxDQUFBQSxDQUFJTyxLQUNJLEVBQUEsVUFBQSxHQUFia0QsQ0FBNEIvSSxFQUFBQSxDQUFBQSxDQUFBQSxFQUlmLFFBQWIrSSxHQUFBQSxDQUFBQSxFQUF5Qi9JLElBQU13RixDQUFTSyxDQUFBQSxLQUFBQSxDQUFBQSxFQUUxQ0gsR0FBWUosQ0FBQUEsQ0FBQUEsQ0FBSyxPQUFTdEYsQ0FBQUEsQ0FBQUEsQ0FBR3dGLENBQVNLLENBQUFBLEtBQUFBLENBQUFBLENBQU8sQ0FHN0MsQ0FBQSxDQUFBLFNBQUEsR0FBYU4sQ0FDY2xFLEVBQUFBLEtBQUFBLENBQUFBLElBQTFCckIsQ0FBSXVGLENBQUFBLENBQUFBLENBQVNtRSxPQUNkMUosQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBTXNGLENBQUlvRSxDQUFBQSxPQUFBQSxFQUVWaEUsR0FBWUosQ0FBQUEsQ0FBQUEsQ0FBSyxTQUFXdEYsQ0FBQUEsQ0FBQUEsQ0FBR3dGLENBQVNrRSxDQUFBQSxPQUFBQSxDQUFBQSxDQUFTLENBSzdDcEUsQ0FBQUEsRUFBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FTUixTQUFnQlgsR0FBQUEsQ0FBUzVELENBQUs4RSxDQUFBQSxDQUFBQSxDQUFPckUsQ0FFakIsQ0FBQSxDQUFBLEdBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBUFQsQ0FBbUJBLENBQUFBLENBQUFBLENBQUk4RSxDQUM3QjlFLENBQUFBLENBQUFBLENBQUFBLENBQUk0SSxPQUFVOUQsQ0FBQUEsRUFBQUEsQ0FDbEIsTUFBT2MsQ0FBQUEsQ0FBQUEsQ0FDUi9HLEdBQW9CK0csQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBR25GLENBWXpCLEVBQUEsQ0FBQSxDQUFBLFNBQWdCa0QsQ0FBUWxELENBQUFBLENBQUFBLENBQU9vSSxDQUFhQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUE1QyxJQUNLQyxDQUFBQSxDQW9CTTlKLENBbkJOSixDQUFBQSxHQUFBQSxHQUFBQSxDQUFROEUsT0FBUzlFLEVBQUFBLEdBQUFBLENBQVE4RSxPQUFRbEQsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFaENzSSxDQUFJdEksQ0FBQUEsQ0FBQUEsQ0FBTVQsR0FDVCtJLElBQUFBLENBQUFBLENBQUVILE9BQVdHLEVBQUFBLENBQUFBLENBQUVILFVBQVluSSxDQUFZbUQsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBU21GLENBQUcsQ0FBQSxJQUFBLENBQU1GLENBR2pDLENBQUEsQ0FBQSxDQUFBLElBQUEsR0FBekJFLENBQUl0SSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUEyQixDQUMvQnNJLEdBQUFBLENBQUFBLENBQUVDLG9CQUVKRCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFFQyxvQkFDRCxHQUFBLENBQUEsTUFBT3BELENBQ1IvRyxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFvQitHLENBQUdpRCxDQUFBQSxDQUFBQSxFQUFBQSxDQUl6QkUsQ0FBRTNILENBQUFBLElBQUFBLENBQU8ySCxDQUFlLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxHQUdwQkEsQ0FBSXRJLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLElBQ0N4QixDQUFJLENBQUEsQ0FBQSxDQUFHQSxDQUFJOEosQ0FBQUEsQ0FBQUEsQ0FBRTVJLE1BQVFsQixDQUFBQSxDQUFBQSxFQUFBQSxDQUN6QjhKLENBQUU5SixDQUFBQSxDQUFBQSxDQUFBQSxFQUNMMEUsQ0FBUW9GLENBQUFBLENBQUFBLENBQUU5SixDQUFJNEosQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBa0MsVUFBZHBJLEVBQUFBLE9BQUFBLENBQUFBLENBQU1aLElBS3RDaUosQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBNEIsSUFBZHJJLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQW9CakIsR0FBV2lCLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBSWxEQSxDQUFhQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxLQUFpQkgsRUFJL0IsQ0FBQSxTQUFTdUcsR0FBU3RILENBQUFBLENBQUFBLENBQU93SCxDQUFPbEcsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FDeEJvSSxJQUFLdkksQ0FBQUEsV0FBQUEsQ0FBWW5CLENBQU9zQixDQUFBQSxDQUFBQSxDQUFBQSxDQ3JnQmhDLFNBQWdCK0YsR0FBQUEsQ0FBT25HLENBQU8yQixDQUFBQSxDQUFBQSxDQUFXOEcsQ0FBekMsQ0FBQSxDQUFBLElBTUtuRyxFQU9BYixDQVVBRCxDQUFBQSxDQUFBQSxDQXRCQXBELEdBQWVBLENBQUFBLEVBQUFBLEVBQUFBLEdBQUFBLENBQUFBLEVBQUFBLENBQWM0QixDQUFPMkIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FZcENGLENBUEFhLENBQUFBLENBQUFBLENBQUFBLENBQXFDLFVBQWhCbUcsRUFBQUEsT0FBQUEsQ0FBQUEsRUFRdEIsSUFDQ0EsQ0FBQUEsQ0FBQUEsRUFBZUEsQ0FBMEI5RyxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQVF6Q0gsQ0FBYyxDQUFBLEVBQUEsQ0FDbEJJLEdBQ0NELENBQUFBLENBQUFBLENBUkQzQixDQUNHc0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBZW1HLENBQ2pCOUcsRUFBQUEsQ0FBQUEsRUFBQUEsR0FBQUEsQ0FDYXhDLEdBQWNlLENBQUFBLEdBQUFBLENBQVUsSUFBTSxDQUFBLENBQUNGLENBUzVDeUIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBWWhELEdBQ1pBLENBQUFBLEdBQUFBLENBQUFBLEtBQzhCb0IsQ0FBOUI4QixHQUFBQSxDQUFBQSxDQUFVRSxlQUNUUyxDQUFBQSxDQUFBQSxDQUFBQSxFQUFlbUcsQ0FDYixDQUFBLENBQUNBLENBQ0RoSCxDQUFBQSxDQUFBQSxDQUFBQSxDQUNBLElBQ0FFLENBQUFBLENBQUFBLENBQVUrRyxVQUNWdkssQ0FBQUEsQ0FBQUEsQ0FBTXdCLElBQUtnQyxDQUFBQSxDQUFBQSxDQUFVbUcsVUFDckIsQ0FBQSxDQUFBLElBQUEsQ0FDSHRHLENBQ0NjLENBQUFBLENBQUFBLENBQUFBLEVBQWVtRyxDQUNiQSxDQUFBQSxDQUFBQSxDQUNBaEgsQ0FDQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDQUUsQ0FBVStHLENBQUFBLFVBQUFBLENBQ2JwRyxDQUlEUixDQUFBQSxDQUFBQSxHQUFBQSxDQUFXTixDQUFheEIsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0wzRGxCLFNBQVMySSxDQUFBQSxDQUFjQyxDQUFjQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUdyQ3pJLENBQVUsQ0FBQSxDQUFBLEdBQUEsQ0FGaEJ5SSxFQUFZLE1BQVNySyxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxFQUFBQSxDQUlMb0ssQ0FFZkUsQ0FBQUEsUUFBQUEsQ0FBQUEsU0FBU2hLLENBQU9pSyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxPQUlSakssQ0FBTU8sQ0FBQUEsUUFBQUEsQ0FBUzBKLENBR3ZCQyxDQUFBQSxDQUFBQSxDQUFBQSxRQUFBQSxDQUFBQSxTQUFTbEssQ0FFSG1LLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQ0FDLENBRkFWLENBQUFBLE9BQUFBLElBQUFBLENBQUt6QixlQUNMa0MsR0FBQUEsQ0FBQUEsQ0FBTyxFQUNQQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFNLEVBQ05MLEVBQUFBLENBQUFBLENBQUFBLENBQWFMLElBRVp6QixDQUFBQSxJQUFBQSxDQUFBQSxlQUFBQSxDQUFrQixVQUFNbUMsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FFeEJ2QyxxQkFBd0IsQ0FBQSxTQUFTd0MsQ0FDakNYLENBQUFBLENBQUFBLElBQUFBLENBQUsxSixLQUFNdUYsQ0FBQUEsS0FBQUEsR0FBVThFLENBQU85RSxDQUFBQSxLQUFBQSxFQWUvQjRFLENBQUszSCxDQUFBQSxJQUFBQSxDQUFLVixHQUlQeUYsRUFBQUEsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsR0FBQUEsQ0FBTSxTQUFBeEYsQ0FBQUEsQ0FBQUEsQ0FDVm9JLENBQUtuSSxDQUFBQSxJQUFBQSxDQUFLRCxDQUNOdUksQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBTXZJLENBQUUwSCxDQUFBQSxvQkFBQUEsQ0FDWjFILENBQUUwSCxDQUFBQSxvQkFBQUEsQ0FBdUIsVUFDeEJVLENBQUFBLENBQUFBLENBQUtJLE1BQU9KLENBQUFBLENBQUFBLENBQUsxSSxPQUFRTSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJLENBQ3pCdUksQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBS0EsQ0FBSXpKLENBQUFBLElBQUFBLENBQUtrQixDQUtkL0IsRUFBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBTU8sUUFVUGUsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBUTRJLFFBQXVCNUksQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBUTBJLFNBQVM3QyxXQUFjN0YsQ0FBQUEsQ0FBQUEsQ0p4QzFEakMsQ0FBUU8sQ0FBQUEsR0FBQUEsQ0FBVVAsS0NmekJDLENBQUFBLEdBQUFBLENBQVUsQ1NGaEIsR0FBQSxDQUFBLFNBQTRCa0wsQ0FBT3RKLENBQUFBLENBQUFBLENBQU95QixDQUFVOEgsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFBQUEsSUFFL0NoSSxDQUFXaUksQ0FBQUEsQ0FBQUEsQ0FBTUMsQ0FFYnpKLENBQUFBLENBQUFBLENBQVFBLENBQ1Z1QixDQUFBQSxFQUFBQSxFQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFZdkIsQ0FBc0J1QixDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUVyQ2lJLENBQU9qSSxDQUFBQSxDQUFBQSxDQUFVdEIsV0FFNEIsR0FBQSxJQUFBLEVBQWpDdUosQ0FBS0UsQ0FBQUEsd0JBQUFBLEdBQ2hCbkksQ0FBVW9JLENBQUFBLFFBQUFBLENBQVNILENBQUtFLENBQUFBLHdCQUFBQSxDQUF5QkosQ0FDakRHLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQVVsSSxDQUd3QixDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQUEsRUFBL0JBLENBQVVxSSxDQUFBQSxpQkFBQUEsR0FDYnJJLENBQVVxSSxDQUFBQSxpQkFBQUEsQ0FBa0JOLENBQU9DLENBQUFBLENBQUFBLEVBQWEsRUFDaERFLENBQUFBLENBQUFBLENBQUFBLENBQVVsSSxDQUlQa0ksQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FDS2xJLENBQTBCQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUVsQyxNQUFPNEQsQ0FBQUEsQ0FBQUEsQ0FDUm1FLENBQVFuRSxDQUFBQSxFQUFBQSxDQUFBQSxNQUtMbUUsQ1JuQ0hqTCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFVLENBNkZEd0wsQ0N0RWIxSixHQUFBQSxDQUFVK0YsVUFBVXlELFFBQVcsQ0FBQSxTQUFTRyxDQUFRQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUUzQ0MsQ0FFSEEsQ0FBQUEsQ0FBQUEsQ0FEc0IsSUFBbkJ4QixFQUFBQSxJQUFBQSxDQUFBQSxHQUFBQSxFQUEyQkEsSUFBb0JBLENBQUFBLEdBQUFBLEdBQUFBLElBQUFBLENBQUtsQyxLQUNuRGtDLENBQUFBLElBQUFBLENBQUFBLEdBQUFBLENBRUFBLElBQWtCNUosQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBTyxFQUFJNEosQ0FBQUEsSUFBQUEsQ0FBS2xDLEtBR2xCLENBQUEsQ0FBQSxVQUFBLEVBQUEsT0FBVndELENBR1ZBLEdBQUFBLENBQUFBLENBQVNBLENBQU9sTCxDQUFBQSxHQUFBQSxDQUFPLEVBQUlvTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFJeEIsSUFBSzFKLENBQUFBLEtBQUFBLENBQUFBLENBQUFBLENBR2pDZ0wsQ0FDSGxMLEVBQUFBLEdBQUFBLENBQU9vTCxDQUFHRixDQUFBQSxDQUFBQSxDQUFBQSxDQUlHLElBQVZBLEVBQUFBLENBQUFBLEVBRUF0QixJQUNDdUIsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsRUFBVXZCLElBQXNCMUgsQ0FBQUEsR0FBQUEsQ0FBQUEsSUFBQUEsQ0FBS2lKLENBQ3pDbkosQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBYzRILElBVWhCckksQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBVStGLFNBQVUrRCxDQUFBQSxXQUFBQSxDQUFjLFNBQVNGLENBQUFBLENBQUFBLENBQ3RDdkIsSUFJVyxDQUFBLEdBQUEsR0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUNWdUIsQ0FBVXZCLEVBQUFBLElBQUFBLENBQUFBLEdBQUFBLENBQXNCMUgsSUFBS2lKLENBQUFBLENBQUFBLENBQUFBLENBQ3pDbkosR0FBYzRILENBQUFBLElBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBY2hCckksR0FBVStGLENBQUFBLFNBQUFBLENBQVVDLE1BQVNqRyxDQUFBQSxHQUFBQSxDQXlGekI1QixHQUFnQixDQUFBLEVBQUEsQ0EyQ3BCeUMsR0FBeUIsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQ25OZHZDLEdBQUksQ0FBQSxDQUFBOztJT0VmLElBQUlILEdBQVUsQ0FBQSxDQUFBLENBcUJkLFNBQVN5QixHQUFBQSxDQUFZVixDQUFNTixDQUFBQSxDQUFBQSxDQUFPUSxDQUFLNEssQ0FBQUEsQ0FBQUEsQ0FBUUMsQ0FLN0M1SyxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUNBZixDQUZHZ0IsQ0FBQUEsQ0FBQUEsQ0FBa0IsT0FHakJoQixDQUFLTSxJQUFBQSxDQUFBQSxDQUNBLEtBQUxOLEVBQUFBLENBQUFBLENBQ0hlLENBQU1ULENBQUFBLENBQUFBLENBQU1OLENBRVpnQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFnQmhCLEdBQUtNLENBQU1OLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBSXZCd0IsQ0FBUSxDQUFBLENBQ2JaLElBQUFBLENBQUFBLENBQUFBLENBQ0FOLEtBQU9VLENBQUFBLENBQUFBLENBQ1BGLElBQUFBLENBQ0FDLENBQUFBLEdBQUFBLENBQUFBLENBQ1csQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFBLEVBQUEsQ0FDRixJQUNELENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxHQUFBLENBQ0YsSUFDSU0sQ0FBQUEsR0FBQUEsQ0FBQUEsS0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FDRSxJQUNBLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FDWkksV0FBYUosQ0FBQUEsS0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsRUFDQXhCLEdBQ2I4TCxDQUFBQSxRQUFBQSxDQUFBQSxDQUNBRCxDQUFBQSxNQUFBQSxDQUFBQSxNQUttQixVQUFUOUssRUFBQUEsT0FBQUEsQ0FBQUEsR0FBd0JHLENBQU1ILENBQUFBLENBQUFBLENBQUtRLFlBQ3hDcEIsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsSUFBS2UsQ0FDeUIsQ0FBQSxLQUFBLENBQUEsR0FBdkJDLEVBQWdCaEIsQ0FDMUJnQixDQUFBQSxHQUFBQSxDQUFBQSxDQUFnQmhCLENBQUtlLENBQUFBLENBQUFBLENBQUFBLENBQUlmLENBSXhCSixDQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxHQUFBQSxDQUFRNEIsS0FBTzVCLEVBQUFBLEdBQUFBLENBQVE0QixNQUFNQSxDQUMxQkEsQ0FBQUEsQ0FBQUEsQ0FBQUE7O0lDakVSLElBQUlvSyxDQUdBQyxDQUFBQSxDQUFBQSxDQUdBQyxHQWlCQUMsQ0FBQUEsQ0FBQUEsQ0FkQUMsQ0FBYyxDQUFBLENBQUEsQ0FHZEMsQ0FBb0IsQ0FBQSxFQUFBLENBRXBCQyxDQUFRLENBQUEsRUFBQSxDQUVSQyxDQUFnQnZNLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQ2hCd00sQ0FBa0J4TSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUNsQnlNLENBQWV6TSxDQUFBQSxHQUFBQSxDQUFROEksTUFDdkI0RCxDQUFBQSxDQUFBQSxDQUFZMU0sR0FDWjJNLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQW1CM00sR0FBUThFLENBQUFBLE9BQUFBLENBZ0cvQixTQUFTOEgsQ0FBQUEsQ0FBYUMsQ0FBTzdMLENBQUFBLENBQUFBLENBQUFBLENBQ3hCaEIsR0FDSEEsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBY2lNLEVBQWtCWSxDQUFPVCxDQUFBQSxDQUFBQSxFQUFlcEwsQ0FFdkRvTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFjLENBT1JVLENBQUFBLElBQUFBLENBQUFBLENBQ0xiLENBQ0NBLENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQTJCLENBQ3BCLEVBQUEsQ0FBQSxFQUFBLENBQUEsR0FBQSxDQUNVLEVBR2ZZLENBQUFBLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLEVBQVNDLENBQVl4TCxDQUFBQSxFQUFBQSxDQUFBQSxNQUFBQSxFQUN4QndMLENBQVlwSyxDQUFBQSxFQUFBQSxDQUFBQSxJQUFBQSxDQUFLLENBQWlCNEosR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFNUJRLENBQVlELENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLENBTWIsU0FBU0UsQ0FBQUEsQ0FBU0MsQ0FDeEJaLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQWMsQ0FDUGEsQ0FBQUEsQ0FBQUEsQ0FBV0MsQ0FBZ0JGLENBQUFBLENBQUFBLENBQUFBLENBU25DLFNBQWdCQyxDQUFBQSxDQUFXRSxDQUFTSCxDQUFBQSxDQUFBQSxDQUFjSSxPQUUzQ0MsQ0FBWVQsQ0FBQUEsQ0FBQUEsQ0FBYVosQ0FBZ0IsRUFBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLE9BQy9DcUIsQ0FBVUMsQ0FBQUEsQ0FBQUEsQ0FBV0gsQ0FDaEJFLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBQ0pBLENBQW1CLENBQUEsRUFBQSxDQUFBLENBQ2pCRCxDQUFpREEsQ0FBQUEsQ0FBQUEsQ0FBS0osQ0FBL0NFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEtBQWV6TCxDQUFXdUwsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFbEMsU0FBQU8sQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFDT0MsQ0FBWUgsQ0FBQUEsQ0FBQUEsQ0FBVUMsQ0FBU0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBaUIsQ0FBSUUsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDdERGLENBQWlCLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FBQSxHQUFPRyxDQUMzQkgsR0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBbUIsQ0FBQ0csQ0FBQUEsQ0FBV0gsQ0FBaUIsQ0FBQSxFQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FDaERBLE1BQXFCOUIsUUFBUyxDQUFBLEVBQUEsQ0FBQSxFQUFBLENBQUEsQ0FBQSxDQUtqQzhCLENBQXVCcEIsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHakJvQixDQU9ELENBQUEsRUFBQSxDQUFBLFNBQVNJLENBQVU5QixDQUFBQSxDQUFBQSxDQUFVK0IsQ0FFN0J4RixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFRMEUsQ0FBYVosQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZ0IsQ0FDdENoTSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxFQUF3QjJOLEdBQVl6RixDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFhd0YsQ0FDckR4RixDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFleUQsQ0FDZnpELENBQUFBLENBQUFBLENBQU0wRixDQUFlRixDQUFBQSxDQUFBQSxDQUVyQnpCLENBQXlDdkosQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsSUFBQUEsQ0FBS3dGLENBUXpDLENBQUEsRUFBQSxDQUFBLFNBQVMyRixDQUFnQmxDLENBQUFBLENBQUFBLENBQVUrQixDQUVuQ3hGLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQVEwRSxDQUFhWixDQUFBQSxDQUFBQSxFQUFBQSxDQUFnQixJQUN0Q2hNLEdBQXdCMk4sQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBWXpGLENBQWF3RixDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUNyRHhGLENBQWV5RCxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUNmekQsQ0FBTTBGLENBQUFBLENBQUFBLENBQWVGLENBRXJCekIsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBa0N2SixJQUFLd0YsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FJbEMsU0FBUzRGLENBQUFBLENBQU9DLENBQ3RCM0IsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBYyxDQUNQNEIsQ0FBQUEsR0FBQUEsQ0FBUSxVQUFPLENBQUEsT0FBQSxDQUFFakUsT0FBU2dFLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQWlCLEVBUW5ELENBQUEsQ0FvQk8sU0FBU0MsR0FBUUMsQ0FBQUEsQ0FBQUEsQ0FBU1AsQ0FFMUJ4RixDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFRMEUsQ0FBYVosQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBZ0IsQ0FDdkMyQixDQUFBQSxDQUFBQSxPQUFBQSxHQUFBQSxDQUFZekYsQ0FBYXdGLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQzVCeEYsTUFBc0IrRixDQUN0Qi9GLEVBQUFBLENBQUFBLENBQUFBLENBQU0wRixDQUFlRixDQUFBQSxDQUFBQSxDQUNyQnhGLENBQWlCK0YsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDVi9GLENBR0RBLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBT0QsU0FBU2dHLEdBQUFBLENBQVl2QyxDQUFVK0IsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FDckN0QixDQUFjLENBQUEsQ0FBQSxDQUNQNEIsR0FBUSxDQUFBLFVBQUEsQ0FBQSxPQUFNckMsQ0FBVStCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBTXpCLFNBQVNTLEdBQUFBLENBQVduTSxDQUNwQndGLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQVd5RSxDQUFpQmpLLENBQUFBLE9BQUFBLENBQVFBLENBS3BDa0csQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBUTBFLENBQWFaLENBQUFBLENBQUFBLEVBQUFBLENBQWdCLENBSTNDOUQsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBaUJsRyxDQUNad0YsQ0FBQUEsQ0FBQUEsRUFFZSxNQUFoQlUsQ0FDSEEsQ0FBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBZSxDQUNmVixDQUFBQSxDQUFBQSxDQUFTUyxHQUFJZ0UsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FFUHpFLENBQVM5RyxDQUFBQSxLQUFBQSxDQUFNdUYsS0FOQWpFLEVBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBNEN2QixTQUFTb00sQ0FDSmpMLEVBQUFBLENBQUFBLElBQUFBLElBQUFBLENBQUFBLENBQ0lBLENBQVlrSixDQUFBQSxDQUFBQSxDQUFrQmdDLEtBQ2hDbEwsRUFBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FFSkEsQ0FBa0NxRixDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxPQUFBQSxDQUFROEYsR0FDMUNuTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFrQ3FGLE9BQVErRixDQUFBQSxDQUFBQSxDQUFBQSxDQUMxQ3BMLFVBQW9DLEdBQ25DLENBQUEsTUFBTzRELENBQ1I1RCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFvQyxFQUNwQ25ELENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQW9CK0csQ0FBRzVELENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLENBOVMxQm5ELEdBQWdCLENBQUEsR0FBQSxDQUFBLFNBQUE0QixDQUNmcUssQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBbUIsSUFDZk0sQ0FBQUEsQ0FBQUEsRUFBZUEsQ0FBYzNLLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBR2xDNUIsR0FBa0IsQ0FBQSxHQUFBLENBQUEsU0FBQTRCLENBQ2I0SyxDQUFBQSxDQUFBQSxDQUFBQSxFQUFpQkEsQ0FBZ0I1SyxDQUFBQSxDQUFBQSxDQUFBQSxDQUdyQ29LLENBQWUsQ0FBQSxDQUFBLENBQUEsSUFFVGMsQ0FITmIsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBbUJySyxDQUlma0wsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FDQ1osR0FBc0JELEdBQUFBLENBQUFBLEVBQ3pCYSxDQUF3QixDQUFBLEdBQUEsQ0FBQSxFQUFBLENBQ3hCYixNQUFvQyxFQUNwQ2EsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBWXRFLE9BQVEsQ0FBQSxTQUFBZ0csQ0FDbkJBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXlCbEMsQ0FDekJrQyxDQUFBQSxDQUFBQSxDQUFTWixDQUFlbk0sQ0FBQUEsS0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FHekJxTCxDQUFzQnRFLENBQUFBLEdBQUFBLENBQUFBLE9BQUFBLENBQVE4RixHQUM5QnhCLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQXNCdEUsT0FBUStGLENBQUFBLENBQUFBLENBQUFBLENBQzlCekIsQ0FBd0IsQ0FBQSxHQUFBLENBQUEsRUFBQSxDQUFBLENBQUEsQ0FHMUJaLEdBQW9CRCxDQUFBQSxFQUFBQSxDQUFBQSxDQUdyQmpNLEdBQVE4SSxDQUFBQSxNQUFBQSxDQUFTLFNBQUFsSCxDQUFBQSxDQUFBQSxDQUNaNkssQ0FBY0EsRUFBQUEsQ0FBQUEsQ0FBYTdLLENBRXpCYSxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFJYixDQUNOYSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxFQUFLQSxDQUNKQSxDQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUEwQm5CLFNBbVRSLENBblQyQitLLEdBQUFBLENBQUFBLENBQWtCM0osSUFBS0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFtVDdDMEosQ0FBWW5NLEdBQUFBLEdBQUFBLENBQVF5TyxxQkFDL0N0QyxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFVbk0sR0FBUXlPLENBQUFBLHFCQUFBQSxHQXZCcEIsU0FBd0I5QyxDQUFBQSxDQUFBQSxDQUFBQSxJQVFuQitDLENBUEVDLENBQUFBLENBQUFBLENBQU8sVUFDWkMsQ0FBQUEsWUFBQUEsQ0FBYUMsQ0FDVEMsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBU0Msb0JBQXFCTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUNsQzdMLFVBQVc4SSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQUVOa0QsQ0FBVWhNLENBQUFBLFVBQUFBLENBQVc4TCxDQXhVUixDQUFBLEdBQUEsQ0FBQSxDQTJVZkcsR0FDSEosR0FBQUEsQ0FBQUEsQ0FBTUQscUJBQXNCRSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxFQWNBUCxDQXBUNUIzTCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFnQitGLFFBQVEsU0FBQWdHLENBQUFBLENBQUFBLENBQ25CQSxDQUFTWixDQUFBQSxDQUFBQSxHQUNaWSxDQUFpQkEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBU1osQ0FFdkJZLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLEdBQTJCbEMsQ0FDOUJrQyxHQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxDQUFrQkEsQ0FFbkJBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQVNaLENBQWVuTSxDQUFBQSxLQUFBQSxDQUFBQSxDQUN4QitNLENBQXlCbEMsQ0FBQUEsR0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FHM0JKLEdBQW9CRCxDQUFBQSxDQUFBQSxDQUFtQixLQUd4Q2pNLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQWtCLFNBQUM0QixDQUFBQSxDQUFPd0IsQ0FDekJBLENBQUFBLENBQUFBLENBQUFBLENBQVlGLElBQUssQ0FBQSxTQUFBQyxDQUVmQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUEyQnFGLE9BQVE4RixDQUFBQSxHQUFBQSxDQUFBQSxDQUNuQ25MLENBQTZCQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUEyQjZMLE9BQU8sU0FBQWhHLENBQUFBLENBQUFBLENBQUFBLE9BQUFBLENBQzlEQSxDQUFZdUYsQ0FBQUEsRUFBQUEsRUFBQUEsQ0FBQUEsQ0FBYXZGLENBRXpCLENBQUEsQ0FBQSxFQUFBLENBQUEsTUFBT2pDLENBQ1IzRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFZRixJQUFLLENBQUEsU0FBQVQsQ0FDWkEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0FBb0JBLENBQXFCLENBQUEsR0FBQSxDQUFBLEVBQUEsRUFBQSxDQUFBLENBQUEsQ0FFOUNXLENBQWMsQ0FBQSxFQUFBLENBQ2RwRCxHQUFvQitHLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUc1RCxDQUlyQnVKLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLEVBQVdBLENBQVU5SyxDQUFBQSxDQUFBQSxDQUFPd0IsQ0FHakNwRCxFQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFROEUsT0FBVSxDQUFBLFNBQUFsRCxDQUNiK0ssQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBa0JBLENBQWlCL0ssQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFJbENxTixDQUZDeE0sQ0FBQUEsQ0FBQUEsQ0FBSWIsTUFDTmEsQ0FBS0EsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsR0FFUkEsQ0FBZ0IrRixDQUFBQSxHQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxPQUFBQSxDQUFRLFNBQUFvRCxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUV0QjBDLEdBQWMxQyxDQUFBQSxDQUFBQSxFQUFBQSxDQUNiLE1BQU83RSxDQUFBQSxDQUFBQSxDQUNSa0ksQ0FBYWxJLENBQUFBLEVBQUFBLENBQUFBLENBQUFBLENBQUFBLENBR1hrSSxDQUFZalAsRUFBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBb0JpUCxDQUFZeE0sQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FrT2xELElBQUlxTSxHQUFBQSxDQUEwQyxVQUF6QkwsRUFBQUEsT0FBQUEscUJBQUFBLENBMkNyQixTQUFTSCxHQUFBQSxDQUFjWSxDQUdoQkMsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBT2xELENBQ1RtRCxDQUFBQSxDQUFBQSxDQUFVRixDQUNRLENBQUEsR0FBQSxDQUFBLFVBQUEsRUFBQSxPQUFYRSxDQUNWRixHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxLQUFnQnpOLENBQ2hCMk4sQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FFRG5ELEVBQW1Ca0QsRUFPcEIsQ0FBQSxTQUFTWixDQUFhVyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxJQUdmQyxDQUFPbEQsQ0FBQUEsQ0FBQUEsQ0FDYmlELENBQWdCQSxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxFQUFBQSxFQUFBQSxDQUNoQmpELENBQW1Ca0QsQ0FBQUEsRUFBQUEsQ0FPcEIsU0FBU3hCLEdBQUFBLENBQVkwQixDQUFTQyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxPQUFBQSxDQUUzQkQsQ0FDREEsRUFBQUEsQ0FBQUEsQ0FBUS9OLFNBQVdnTyxDQUFRaE8sQ0FBQUEsTUFBQUEsRUFDM0JnTyxDQUFRcE0sQ0FBQUEsSUFBQUEsQ0FBSyxTQUFDcU0sQ0FBQUEsQ0FBSzFDLENBQVUwQyxDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxHQUFRRixDQUFReEMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FJL0MsU0FBU0ssQ0FBQUEsQ0FBZXFDLENBQUtDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BQ1QsVUFBTEEsRUFBQUEsT0FBQUEsQ0FBQUEsQ0FBa0JBLEVBQUVELENBQU9DLENBQUFBLENBQUFBLENBQUFBOztJQ3habkMsU0FBU2hQLEVBQU9DLENBQUtDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBQ3RCLElBQUlOLENBQUFBLElBQUtNLEVBQU9ELENBQUlMLENBQUFBLENBQUFBLENBQUFBLENBQUtNLENBQU1OLENBQUFBLENBQUFBLENBQUFBLENBQUFBLE9BQ1BLLEVBU3ZCLFNBQVNnUCxDQUFBQSxDQUFlek0sQ0FBR0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFDNUIsSUFBSTdDLENBQUs0QyxJQUFBQSxDQUFBQSxDQUFBQSxHQUFhLFVBQU41QyxHQUFBQSxDQUFBQSxFQUFBQSxFQUFzQkEsS0FBSzZDLENBQUksQ0FBQSxDQUFBLE9BQUEsQ0FBTyxDQUN0RCxDQUFBLElBQUEsSUFBSTdDLEtBQUs2QyxDQUFhLENBQUEsR0FBQSxVQUFBLEdBQU43QyxDQUFvQjRDLEVBQUFBLENBQUFBLENBQUU1QyxLQUFPNkMsQ0FBRTdDLENBQUFBLENBQUFBLENBQUFBLENBQUksUUFBTyxDQUN4RCxDQUFBLE9BQUEsQ0FBQSxDQUFBLENDZkQsU0FBU3NQLENBQWNDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLElBQUFBLENBQ3hCalAsS0FBUWlQLENBQUFBLEVBQUFBLENDR1AsU0FBU0MsQ0FBS25OLENBQUFBLENBQUFBLENBQUdvTixDQUNkQyxDQUFBQSxDQUFBQSxTQUFBQSxDQUFBQSxDQUFhQyxPQUNqQjVPLENBQU1pSixDQUFBQSxJQUFBQSxDQUFLMUosS0FBTVMsQ0FBQUEsR0FBQUEsQ0FDakI2TyxFQUFZN08sQ0FBTzRPLEVBQUFBLENBQUFBLENBQVU1TyxHQUM1QjZPLENBQUFBLE9BQUFBLENBQUFBLENBQUFBLEVBQWE3TyxJQUNqQkEsQ0FBSUksQ0FBQUEsSUFBQUEsQ0FBT0osQ0FBSSxDQUFBLElBQUEsQ0FBQSxDQUFTQSxFQUFJNEksT0FBVSxDQUFBLElBQUEsQ0FBQSxDQUdsQzhGLENBSUdBLENBQUFBLENBQUFBLENBQUFBLENBQVN6RixLQUFLMUosS0FBT3FQLENBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQWVDLENBSHBDUCxDQUFBQSxDQUFBQSxDQUFlckYsS0FBSzFKLEtBQU9xUCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxTQU0zQkUsRUFBT3ZQLENBQ1Y2SCxDQUFBQSxDQUFBQSxPQUFBQSxJQUFBQSxDQUFBQSxxQkFBQUEsQ0FBd0J1SCxFQUN0Qi9PLEdBQWMwQixDQUFBQSxDQUFBQSxDQUFHL0IsQ0FFekJ1UCxDQUFBQSxDQUFBQSxPQUFBQSxDQUFBQSxDQUFPQyxZQUFjLE9BQVd6TixFQUFBQSxDQUFBQSxDQUFFeU4sV0FBZXpOLEVBQUFBLENBQUFBLENBQUUwRCxNQUFRLEdBQzNEOEosQ0FBQUEsQ0FBQUEsQ0FBT25JLFNBQVVxSSxDQUFBQSxnQkFBQUEsQ0FBQUEsQ0FBbUIsRUFDcENGLENBQW9CLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUNiQSxDRHZCUlAsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBYzVILFVBQVksSUFBSS9GLEdBQUFBLEVBRU5xTyxvQkFBdUIsQ0FBQSxDQUFBLENBQUEsQ0FDL0NWLEVBQWM1SCxTQUFVUyxDQUFBQSxxQkFBQUEsQ0FBd0IsU0FBUzdILENBQUFBLENBQU93SCxVQUN4RHVILENBQWVyRixDQUFBQSxJQUFBQSxDQUFLMUosS0FBT0EsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBVStPLEVBQWVyRixJQUFLbEMsQ0FBQUEsS0FBQUEsQ0FBT0EsSUVWeEUsSUFBSW1JLENBQUFBLENBQWNyUSxRQUNsQkEsR0FBZ0IsQ0FBQSxHQUFBLENBQUEsU0FBQTRCLENBQ1hBLENBQUFBLENBQUFBLENBQUFBLENBQU1aLE1BQVFZLENBQU1aLENBQUFBLElBQUFBLENBQUFBLEdBQUFBLEVBQW1CWSxDQUFNVCxDQUFBQSxHQUFBQSxHQUNoRFMsRUFBTWxCLEtBQU1TLENBQUFBLEdBQUFBLENBQU1TLENBQU1ULENBQUFBLEdBQUFBLENBQ3hCUyxFQUFNVCxHQUFNLENBQUEsSUFBQSxDQUFBLENBRVRrUCxHQUFhQSxDQUFZek8sQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FpQ3RCME8sSUN2Q0ZDLENBQUFBLENBQWdCdlEsR0FDdEJBLENBQUFBLElBQUFBLEdBQUFBLENBQUFBLEdBQUFBLENBQXNCLFNBQVNrTCxDQUFPL0QsQ0FBQUEsQ0FBQUEsQ0FBVTlELENBQVU4SCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUNyREQsRUFBTXNGLElBRUxyTixDQUFBQSxJQUFBQSxJQUFBQSxDQUFBQSxDQUNBdkIsQ0FBUXVGLENBQUFBLENBQUFBLENBRUp2RixFQUFRQSxDQUNWdUIsQ0FBQUEsRUFBQUEsRUFBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBWXZCLFFBQXFCdUIsQ0FDaEIsQ0FBQSxHQUFBLENBQUEsT0FBQSxJQUFBLEVBQWpCZ0UsUUFDSEEsQ0FBZ0I5RCxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUNoQjhELENBQXFCOUQsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FHZkYsTUFBMkIrSCxDQUFPL0QsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FJNUNvSixDQUFjckYsQ0FBQUEsQ0FBQUEsQ0FBTy9ELEVBQVU5RCxDQUFVOEgsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FHMUMsSUFBTXNGLENBQUFBLENBQWF6USxJQUFROEUsT0F1RTNCLENBQUEsU0FBZ0I0TCxDQUVnQixFQUFBLENBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUMxQkMsRUFBYyxJQUNRLENBQUEsSUFBQSxDQUFBLEdBQUEsQ0FBQSxLQUFBLENBb0lyQixTQUFTQyxDQUFBQSxDQUFVaFAsT0FFckJ1QixDQUFZdkIsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsT0FDVHVCLENBQWFBLEVBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQXdCQSxNQUFxQnZCLENBRzNELENBQUEsQ0NwT1AsU0FBZ0JpUCxDQUNWQyxFQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxDQUFRLElBQ1JDLENBQUFBLElBQUFBLENBQUFBLENBQUFBLENBQU8sTURjYi9RLEdBQVE4RSxDQUFBQSxPQUFBQSxDQUFVLFNBQVNsRCxDQUFBQSxDQUFBQSxDQUFBQSxJQUVwQnVCLEVBQVl2QixDQUNkdUIsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsRUFBYUEsT0FDaEJBLENBT0dBLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLENBQUFBLEVBQUFBLENBQWtDLElBQXJCdkIsQ0FDaEJBLENBQUFBLEdBQUFBLEdBQUFBLENBQUFBLENBQU1aLElBQU8sQ0FBQSxJQUFBLENBQUEsQ0FHVnlQLEdBQVlBLENBQVc3TyxDQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQWlFNUI4TyxDQUFTNUksQ0FBQUEsU0FBQUEsQ0FBWSxJQUFJL0YsR0FPYSxFQUFBLEdBQUEsQ0FBQSxTQUFTaVAsQ0FBU0MsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsSUFDakRDLEVBQXNCRCxDQUd0QnhPLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUkySCxJQUVXLENBQUEsSUFBQSxFQUFqQjNILEVBQUVrTyxDQUNMbE8sR0FBQUEsQ0FBQUEsQ0FBRWtPLENBQWMsQ0FBQSxFQUFBLENBQUEsQ0FFakJsTyxFQUFFa08sQ0FBWWpPLENBQUFBLElBQUFBLENBQUt3TyxDQUViQyxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUFVUCxFQUFVbk8sQ0FFdEIyTyxDQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFXLENBQ1RDLENBQUFBLENBQUFBLENBQWEsV0FDZEQsQ0FFSkEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBVyxFQUNYRixDQUFpQyxDQUFBLEdBQUEsQ0FBQSxJQUFBLENBRTdCQyxFQUNIQSxDQUFRRyxDQUFBQSxDQUFBQSxDQUFBQSxDQUVSQSxDQUlGSixFQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFpQ0csTUFFM0JDLENBQXVCLENBQUEsVUFBQSxDQUFBLEdBQUEsQ0FBQSxFQUNyQjdPLENBQTJCLENBQUEsR0FBQSxDQUFBLENBQUEsR0FHN0JBLEVBQUV5RixLQUFrQixDQUFBLEdBQUEsQ0FBQSxDQUFBLElBQ2pCcUosQ0FBaUI5TyxDQUFBQSxDQUFBQSxDQUFFeUYsVUFDekJ6RixDQUFtQixDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBNUV2QixTQUFTK08sQ0FBQUEsQ0FBZTVQLEVBQU82UCxDQUFnQkMsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FDMUM5UCxDQUNIQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFrQixLQUNsQkEsQ0FDQ0EsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFDQUEsQ0FBZ0IrUCxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxDQUFJLFNBQUFyUCxDQUNuQmtQLENBQUFBLENBQUFBLE9BQUFBLENBQUFBLENBQWVsUCxDQUFPbVAsQ0FBQUEsQ0FBQUEsQ0FBZ0JDLEtBR3BDOVAsQ0FDQ0EsQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsR0FBZ0M2UCxJQUMvQjdQLENBQ0g4UCxDQUFBQSxHQUFBQSxFQUFBQSxDQUFBQSxDQUFlbE0sYUFBYTVELENBQVlBLENBQUFBLEdBQUFBLENBQUFBLENBQUFBLENBQUFBLEdBQUFBLENBQUFBLENBRXpDQSxDQUEwQixDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQzFCQSxVQUE4QjhQLENBSzFCOVAsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0F3RG9CNFAsQ0FDdkJELENBQUFBLENBQ0FBLFVBQ0FBLENBTUVYLENBQUFBLEdBQUFBLENBQUFBLEdBQUFBLEVBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQUFBLElBRkpuTyxDQUFFOEksQ0FBQUEsUUFBQUEsQ0FBUyxLQUFlOUksQ0FBd0IsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFBLENBQUEsQ0FHMUNtTyxDQUFZbk8sQ0FBQUEsQ0FBQUEsQ0FBRWtPLEVBQVlpQixHQUNqQ2hCLEVBQUFBLEVBQUFBLENBQUFBLENBQVUvRSxXQVVQZ0csR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBOEMsSUFBL0JaLENBQ2hCeE8sQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBQUEsRUFBZ0NvUCxDQUNwQ3BQLEVBQUFBLENBQUFBLENBQUU4SSxTQUFTLENBQWU5SSxHQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUF3QkEsQ0FBbUIsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsQ0FFdEV1TyxFQUFRUixJQUFLYSxDQUFBQSxDQUFBQSxDQUFZQSxLQUcxQlgsQ0FBUzVJLENBQUFBLFNBQUFBLENBQVVxQyxxQkFBdUIsVUFDcEN3RyxDQUFBQSxJQUFBQSxDQUFBQSxDQUFBQSxDQUFjLEdBUXBCRCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFTNUksVUFBVUMsTUFBUyxDQUFBLFNBQVNySCxDQUFPd0gsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FDdkNrQyxTQUEwQixDQUl6QkEsR0FBQUEsSUFBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBdUIsQ0FDcEJxSCxJQUFBQSxDQUFBQSxDQUFpQnBJLFNBQVN0SSxhQUFjLENBQUEsS0FBQSxDQUFBLENBQ3hDK1EsRUFBb0IxSCxJQUFzQixDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsQ0FBQSxDQUFBLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxHQUFBLENBQUEsR0FBQSxDQUMxQixHQXJKekIsU0FBUzJILENBQUFBLENBQWNuUSxDQUFPNlAsQ0FBQUEsQ0FBQUEsQ0FBZ0JsTyxVQUN6QzNCLENBQ0NBLEdBQUFBLENBQUFBLENBQUFBLEdBQUFBLEVBQW9CQSxDQUN2QkEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsRUFBQUEsQ0FBK0I0RyxRQUFRLFNBQUF3SixDQUFBQSxDQUFBQSxDQUNSLFVBQW5CQSxFQUFBQSxPQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxFQUErQkEsV0FHM0NwUSxDQUEyQixDQUFBLEdBQUEsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFBLENBSUosT0FEeEJBLENBQVFwQixDQUFBQSxDQUFBQSxDQUFPLEdBQUlvQixDQUVkQSxDQUFBQSxFQUFBQSxHQUFBQSxHQUFBQSxDQUFBQSxDQUFBQSxHQUFBQSxDQUFBQSxHQUFBQSxHQUFnQzJCLENBQ25DM0IsR0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsR0FBQUEsQ0FBOEI2UCxHQUUvQjdQLENBQW1CLENBQUEsR0FBQSxDQUFBLElBQUEsQ0FBQSxDQUdwQkEsQ0FDQ0EsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFDQUEsTUFBZ0IrUCxHQUFJLENBQUEsU0FBQXJQLENBQ25CeVAsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0FBY3pQLEVBQU9tUCxDQUFnQmxPLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBSWpDM0IsQ0E0SHNCbVEsQ0FBQUEsQ0FDMUIzSCxTQUNBcUgsQ0FDQ0ssQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBdUNBLENBSWYsQ0FBQSxHQUFBLEVBQUEsQ0FBQSxJQUFBLENBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBQSxJQUt0QkcsRUFDTC9KLENBQW9CbkgsQ0FBQUEsR0FBQUEsRUFBQUEsR0FBQUEsQ0FBY2UsR0FBVSxDQUFBLElBQUEsQ0FBTXBCLEVBQU11UixRQUNyREEsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsR0FBVUEsQ0FBc0IsQ0FBQSxHQUFBLENBQUEsSUFBQSxDQUFBLENBRTdCLENBQ05sUixHQUFjZSxDQUFBQSxHQUFBQSxDQUFVLEtBQU1vRyxDQUFtQixDQUFBLEdBQUEsQ0FBQSxJQUFBLENBQU94SCxFQUFNTyxRQUM5RGdSLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENDaE1GLElBQU1kLENBQUFBLENBQVUsU0FBQ2UsQ0FBTTVQLENBQUFBLENBQUFBLENBQU8xQixDQUN2QkEsQ0FBQUEsQ0FBQUEsR0FBQUEsRUFBQUEsQ0FBQUEsQ0FkZ0IsS0FjU0EsQ0FmUixDQUFBLENBQUEsQ0FBQSxFQXFCdEJzUixDQUFLbkIsQ0FBQUEsQ0FBQUEsQ0FBS29CLE9BQU83UCxDQVFoQjRQLENBQUFBLENBQUFBLENBQUFBLENBQUt4UixNQUFNMFIsV0FDbUIsR0FBQSxHQUFBLEdBQTlCRixFQUFLeFIsS0FBTTBSLENBQUFBLFdBQUFBLENBQVksQ0FBY0YsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBS25CLEVBQUtzQixJQVFqRHpSLENBQUFBLENBQUFBLElBQUFBLENBQUFBLENBQU9zUixDQUFLcEIsQ0FBQUEsQ0FBQUEsQ0FDTGxRLEdBQU0sQ0FDTEEsS0FBQUEsQ0FBQUEsQ0FBS1UsTUFBUyxDQUFBLENBQUEsRUFDcEJWLEVBQUtnUixHQUFMaFIsRUFBQUEsRUFBQUEsQ0FBQUEsR0FFR0EsRUExQ2lCLENBMENNQSxDQUFBQSxDQUFBQSxDQUFBQSxDQTNDTCxTQThDdEJzUixDQUFLcEIsQ0FBQUEsQ0FBQUEsQ0FBUWxRLENBQU9BLENBQUFBLENBQUFBLENBNUNKLE1BbURsQmlRLENBQUFBLENBQUFBLENBQWEvSSxVQUFZLElBQUkvRixHQUFBQSxFQUFBQSxHQUFBQSxDQUVPLFNBQVNPLENBQ3RDNFAsQ0FBQUEsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBTzlILElBQ1BrSSxDQUFBQSxDQUFBQSxDQUFZMUIsRUFBVXNCLENBRXhCdFIsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBT3NSLENBQUtuQixDQUFBQSxDQUFBQSxDQUFLd0IsSUFBSWpRLENBQ3pCMUIsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FBQUEsQ0E1RHVCLENBOERoQixDQUFBLEVBQUEsQ0FBQSxTQUFBNFIsT0FDQUMsQ0FBbUIsQ0FBQSxVQUFBLENBQ25CUCxDQUFLeFIsQ0FBQUEsS0FBQUEsQ0FBTTBSLGFBS2Z4UixDQUFLOEIsQ0FBQUEsSUFBQUEsQ0FBSzhQLENBQ1ZyQixDQUFBQSxDQUFBQSxDQUFBQSxDQUFRZSxFQUFNNVAsQ0FBTzFCLENBQUFBLENBQUFBLENBQUFBLEVBSHJCNFIsQ0FNRUYsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FDSEEsRUFBVUcsQ0FFVkEsQ0FBQUEsQ0FBQUEsQ0FBQUEsR0FBQUEsQ0FBQUEsQ0FBQUEsQ0FLSDVCLENBQWEvSSxDQUFBQSxTQUFBQSxDQUFVQyxPQUFTLFNBQVNySCxDQUFBQSxDQUFBQSxDQUFBQSxJQUFBQSxDQUNuQ29RLEVBQVEsSUFDUkMsQ0FBQUEsSUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBTyxJQUFJMkIsR0FFVnpSLENBQUFBLElBQUFBLENBQUFBLENBQVdnRSxDQUFhdkUsQ0FBQUEsQ0FBQUEsQ0FBTU8sVUFDaENQLENBQU0wUixDQUFBQSxXQUFBQSxFQUF3QyxHQUF6QjFSLEdBQUFBLENBQUFBLENBQU0wUixZQUFZLENBSTFDblIsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBUzBSLE9BSUwsRUFBQSxDQUFBLElBQUEsSUFBSXZTLEVBQUlhLENBQVNLLENBQUFBLE1BQUFBLENBQVFsQixDQVl4QjJRLEVBQUFBLEVBQUFBLElBQUFBLENBQUFBLENBQUFBLENBQUs2QixJQUFJM1IsQ0FBU2IsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBS2dLLElBQUswRyxDQUFBQSxDQUFBQSxDQUFRLENBQUMsQ0FBRyxDQUFBLENBQUEsQ0FBRzFHLElBQUswRyxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxDQUFBQSxPQUUvQ3BRLEVBQU1PLFFBR2Q0UCxDQUFBQSxDQUFBQSxDQUFBQSxDQUFhL0ksU0FBVVksQ0FBQUEsa0JBQUFBLENBQXFCbUksRUFBYS9JLFNBQVVPLENBQUFBLGlCQUFBQSxDQUFvQiwyQkFPakYwSSxDQUFLdkksQ0FBQUEsT0FBQUEsQ0FBUSxTQUFDNUgsQ0FBTTBCLENBQUFBLENBQUFBLENBQUFBLENBQ3hCNk8sQ0FBUTBCLENBQUFBLENBQUFBLENBQU12USxFQUFPMUIsQ0NuSFZrUyxFQUFBQSxDQUFBQSxFQUFBQSxDQUFBQSxDQUFBQSxJQUFBQSxDQUFBQSxDQUNNLFdBQVZDLEVBQUFBLE9BQUFBLE1BQUFBLEVBQXlCQSxPQUFPQyxHQUFPRCxFQUFBQSxNQUFBQSxDQUFPQyxHQUFJLENBQUEsZUFBQSxDQUFBLEVBQzFELE1BRUtDLENBQWMsQ0FBQSxpUEFBQSxDQUVkQyxFQUE2QixXQUFiN0osRUFBQUEsT0FBQUEsUUFBQUEsQ0FLaEI4SixFQUFvQixTQUFBblMsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FBQUEsQ0FDUCxXQUFWK1IsRUFBQUEsT0FBQUEsTUFBQUEsRUFBNEMsaUJBQVpBLE1BQ3JDLEVBQUEsQ0FBQSxjQUFBLENBQ0EsYUFDRDdNLEVBQUFBLElBQUFBLENBQUtsRixJQUdSZSxHQUFVK0YsQ0FBQUEsU0FBQUEsQ0FBVXFJLGlCQUFtQixFQVN2QyxDQUFBLENBQ0Msb0JBQ0EsQ0FBQSwyQkFBQSxDQUNBLHVCQUNDM0gsT0FBUSxDQUFBLFNBQUF0SCxDQUNUa1MsQ0FBQUEsQ0FBQUEsTUFBQUEsQ0FBT0MsZUFBZXRSLEdBQVUrRixDQUFBQSxTQUFBQSxDQUFXNUcsRUFBSyxDQUMvQ29TLFlBQUFBLENBQUFBLENBQWMsRUFDZGYsR0FDUW5JLENBQUFBLFVBQUFBLENBQUFBLE9BQUFBLElBQUFBLENBQUssU0FBWWxKLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBRXpCMFIsYUFBSVcsQ0FDSEgsQ0FBQUEsQ0FBQUEsTUFBQUEsQ0FBT0MsY0FBZWpKLENBQUFBLElBQUFBLENBQU1sSixFQUFLLENBQ2hDb1MsWUFBQUEsQ0FBQUEsQ0FBYyxDQUNkRSxDQUFBQSxRQUFBQSxDQUFBQSxDQUFVLEVBQ1Z2TixLQUFPc04sQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FpQ1gsSUFBSUUsQ0FBZXpULENBQUFBLEdBQUFBLENBQVFrSCxNQVMzQixTQUFTd00sQ0FBQUEsRUFBQUEsRUFFVCxTQUFTQyxDQUFBQSxFQUFBQSxDQUFBQSxPQUNEdkosS0FBS3dKLFlBR2IsQ0FBQSxTQUFTQyxDQUNEekosRUFBQUEsQ0FBQUEsT0FBQUEsSUFBQUEsQ0FBSzBKLGlCQWZiOVQsR0FBUWtILENBQUFBLEtBQUFBLENBQVEsU0FBQUgsQ0FBQUEsQ0FBQUEsQ0FBQUEsT0FDWDBNLElBQWMxTSxDQUFJME0sQ0FBQUEsQ0FBQUEsQ0FBYTFNLElBQ25DQSxDQUFFZ04sQ0FBQUEsT0FBQUEsQ0FBVUwsRUFDWjNNLENBQUU0TSxDQUFBQSxvQkFBQUEsQ0FBdUJBLENBQ3pCNU0sQ0FBQUEsQ0FBQUEsQ0FBRThNLG1CQUFxQkEsQ0FDZjlNLENBQUFBLENBQUFBLENBQUVpTixXQUFjak4sQ0FBQUEsQ0FBQUEsQ0FBQUEsS0FhckJrTixDQUFBQSxDQUFzQixDQUN6QlgsWUFBQUEsQ0FBQUEsQ0FBYyxFQUNkZixHQUNRbkksQ0FBQUEsVUFBQUEsQ0FBQUEsT0FBQUEsSUFBQUEsQ0FBSzhKLEtBSVZDLENBQUFBLENBQUFBLENBQUFBLENBQUFBLENBQWVuVSxJQUFRNEIsTUFDM0I1QixHQUFBQSxDQUFRNEIsS0FBUSxDQUFBLFNBQUFBLE9BQ1haLENBQU9ZLENBQUFBLENBQUFBLENBQU1aLElBQ2JOLENBQUFBLENBQUFBLENBQVFrQixFQUFNbEIsS0FDZFUsQ0FBQUEsQ0FBQUEsQ0FBa0JWLENBR0YsQ0FBQSxHQUFBLFFBQUEsRUFBQSxPQUFUTSxFQUFtQixDQUN2Qm9ULElBQUFBLENBQUFBLENBQUFBLENBQTBDLElBQXZCcFQsQ0FBS21CLENBQUFBLE9BQUFBLENBQVEsU0FHakMsSUFBSS9CLENBQUFBLElBRlRnQixDQUFrQixDQUFBLEVBQUEsQ0FFSlYsRUFBTyxDQUNoQnVGLElBQUFBLENBQUFBLENBQVF2RixDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxDQUVkOFMsR0FBZ0IsVUFBTjlTLEdBQUFBLENBQUFBLEVBQTZCLFVBQVRZLEdBQUFBLENBQUFBLEVBR2pCLFVBQU5aLENBQWlCLEVBQUEsY0FBQSxHQUFrQk0sR0FBa0IsSUFBVHVGLEVBQUFBLENBQUFBLEdBS2hELGlCQUFON0YsQ0FDQSxFQUFBLE9BQUEsR0FBV00sQ0FDSSxFQUFBLElBQUEsRUFBZkEsRUFBTXVGLEtBSU43RixDQUFBQSxDQUFBQSxDQUFJLE9BQ1ksQ0FBQSxVQUFBLEdBQU5BLElBQThCLENBQVY2RixHQUFBQSxDQUFBQSxDQU05QkEsQ0FBUSxDQUFBLEVBQUEsQ0FDRSxpQkFBaUJDLElBQUs5RixDQUFBQSxDQUFBQSxDQUFBQSxDQUNoQ0EsRUFBSSxZQUVKLENBQUEsNEJBQUEsQ0FBNkI4RixLQUFLOUYsQ0FBSVksQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FDckNtUyxDQUFrQnpTLENBQUFBLENBQUFBLENBQU1NLE1BRXpCWixDQUFJLENBQUEsU0FBQSxDQUNNLFlBQWE4RixDQUFBQSxJQUFBQSxDQUFLOUYsR0FDNUJBLENBQUksQ0FBQSxXQUFBLENBQ00sV0FBWThGLENBQUFBLElBQUFBLENBQUs5RixHQUMzQkEsQ0FBSSxDQUFBLFlBQUEsQ0FDTSxrQ0FBbUM4RixDQUFBQSxJQUFBQSxDQUFLOUYsR0FDbERBLENBQUlBLENBQUFBLENBQUFBLENBQUVxRyxXQUNJMk4sRUFBQUEsQ0FBQUEsQ0FBQUEsRUFBb0JuQixFQUFZL00sSUFBSzlGLENBQUFBLENBQUFBLENBQUFBLENBQy9DQSxDQUFJQSxDQUFBQSxDQUFBQSxDQUFFb0csUUFBUSxVQUFZLENBQUEsS0FBQSxDQUFBLENBQU9DLFdBQ2IsRUFBQSxDQUFBLElBQUEsR0FBVlIsSUFDVkEsQ0FBUXhFLENBQUFBLEtBQUFBLENBQUFBLENBQUFBLENBS0wsYUFBYXlFLElBQUs5RixDQUFBQSxDQUFBQSxDQUFBQSxHQUNyQkEsRUFBSUEsQ0FBRXFHLENBQUFBLFdBQUFBLEVBQUFBLENBQ0ZyRixDQUFnQmhCLENBQUFBLENBQUFBLENBQUFBLEdBQ25CQSxFQUFJLGdCQUlOZ0IsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBQUEsQ0FBZ0JoQixDQUFLNkYsQ0FBQUEsQ0FBQUEsQ0FBQUEsRUFBQUEsQ0FLYixVQUFSakYsQ0FDQUksRUFBQUEsQ0FBQUEsQ0FBZ0JpVCxRQUNoQjNQLEVBQUFBLEtBQUFBLENBQU1DLFFBQVF2RCxDQUFnQjZFLENBQUFBLEtBQUFBLENBQUFBLEdBRzlCN0UsQ0FBZ0I2RSxDQUFBQSxLQUFBQSxDQUFRaEIsRUFBYXZFLENBQU1PLENBQUFBLFFBQUFBLENBQUFBLENBQVV1SCxPQUFRLENBQUEsU0FBQWxHLEdBQzVEQSxDQUFNNUIsQ0FBQUEsS0FBQUEsQ0FBTTRULFFBQzBDLENBQUEsQ0FBQSxDQUFBLEVBQXJEbFQsRUFBZ0I2RSxLQUFNOUQsQ0FBQUEsT0FBQUEsQ0FBUUcsQ0FBTTVCLENBQUFBLEtBQUFBLENBQU11RixXQUtqQyxRQUFSakYsRUFBQUEsQ0FBQUEsRUFBb0QsTUFBaENJLENBQWdCb0osQ0FBQUEsWUFBQUEsR0FDdkNwSixFQUFnQjZFLEtBQVFoQixDQUFBQSxDQUFBQSxDQUFhdkUsQ0FBTU8sQ0FBQUEsUUFBQUEsQ0FBQUEsQ0FBVXVILFFBQVEsU0FBQWxHLENBQUFBLENBQUFBLENBRTNEQSxDQUFNNUIsQ0FBQUEsS0FBQUEsQ0FBTTRULFNBRFRsVCxDQUFnQmlULENBQUFBLFFBQUFBLENBQUFBLENBRTBDLENBQTVEalQsRUFBQUEsQ0FBQUEsQ0FBZ0JvSixhQUFhckksT0FBUUcsQ0FBQUEsQ0FBQUEsQ0FBTTVCLEtBQU11RixDQUFBQSxLQUFBQSxDQUFBQSxDQUdqRDdFLEVBQWdCb0osWUFBZ0JsSSxFQUFBQSxDQUFBQSxDQUFNNUIsS0FBTXVGLENBQUFBLE1BQUFBLENBQUFBLENBQUFBLENBQUFBLENBS2hEckUsRUFBTWxCLEtBQVFVLENBQUFBLENBQUFBLENBRVZWLENBQU13VCxDQUFBQSxLQUFBQSxFQUFTeFQsRUFBTTZULFNBQ3hCTixHQUFBQSxDQUFBQSxDQUFvQk8sVUFBYSxDQUFBLFdBQUEsR0FBZTlULEVBQ3pCLElBQW5CQSxFQUFBQSxDQUFBQSxDQUFNNlQsWUFBbUJuVCxDQUFnQjhTLENBQUFBLEtBQUFBLENBQVF4VCxFQUFNNlQsU0FDM0RuQixDQUFBQSxDQUFBQSxNQUFBQSxDQUFPQyxjQUFlalMsQ0FBQUEsQ0FBQUEsQ0FBaUIsWUFBYTZTLENBSXREclMsQ0FBQUEsRUFBQUEsQ0FBQUEsQ0FBQUEsQ0FBTTZTLFFBQVczQixDQUFBQSxDQUFBQSxDQUVicUIsR0FBY0EsQ0FBYXZTLENBQUFBLENBQUFBLEVBQUFBLENBQUFBLENBS2hDLElBQU00SyxDQUFBQSxDQUFrQnhNLFFBQ3hCQSxHQUFrQixDQUFBLEdBQUEsQ0FBQSxTQUFTNEIsR0FDdEI0SyxDQUNIQSxFQUFBQSxDQUFBQSxDQUFnQjVLLEdBRUVBLENBQUFBLENBQUFBLElBQUFBLENBQUFBOztJQ3hOcEI7Ozs7OztJQU1HO2FBQ2Esa0JBQWtCLENBQWtCLGNBQXNCLEVBQUUsR0FBRyxNQUFTLEVBQUE7SUFDcEYsSUFBQSxTQUFTLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztJQUM1QixJQUFBLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDMUIsT0FBTztJQUdQLElBQUEsU0FBUyxTQUFTLENBQUksS0FBUSxFQUFFLEtBQWEsRUFBQTs7SUFHekMsUUFBQSxNQUFNLHVCQUF1QixHQUFHa00sQ0FBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQzlDLFFBQUEsTUFBTSxVQUFVLEdBQUdBLENBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUNqQyxRQUFBLElBQUksdUJBQXVCLENBQUMsT0FBTyxJQUFJLEtBQUssRUFBRTtJQUMxQyxZQUFBLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFOztJQUVyQixnQkFBQSxTQUFTO29CQUNULE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQSxTQUFBLEVBQVksY0FBYyxDQUE2RiwwRkFBQSxFQUFBLEtBQUssQ0FBb0Isa0JBQUEsQ0FBQSxDQUFDLENBQUM7SUFDaEssZ0JBQUEsVUFBVSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7SUFDN0IsYUFBQTtJQUNKLFNBQUE7U0FDSjtJQUNMLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFpQkc7SUFDYSxTQUFBLGVBQWUsQ0FBSSxRQUFvRCxFQUFFLGVBQXlCLEVBQUE7SUFFOUcsSUFBQSxNQUFNLFFBQVEsR0FBR0EsQ0FBTSxDQUFtQjRHLE9BQUssQ0FBQyxDQUFDO0lBQ2pELElBQUEsTUFBTSxVQUFVLEdBQUc1RyxDQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsSUFBQSxNQUFNLGtCQUFrQixHQUFHQSxDQUFNLENBQTJCLFNBQVMsQ0FBQyxDQUFDOztJQUd2RSxJQUFBLGtCQUFrQixDQUFDLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxlQUFlLENBQUMsQ0FBQzs7SUFHakUsSUFBQSxNQUFNLGVBQWUsR0FBR0ksR0FBVyxDQUFDLE1BQUs7SUFDckMsUUFBQSxNQUFNLGVBQWUsR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLENBQUM7SUFDbkQsUUFBQSxJQUFJLGVBQWU7SUFDZixZQUFBLGVBQWUsRUFBRSxDQUFDO1NBQ3pCLEVBQUUsRUFBRSxDQUFDLENBQUM7Ozs7O0lBTVAsSUFBQSxNQUFNLGNBQWMsR0FBR0EsR0FBVyxDQUFDLE1BQUs7WUFDcEMsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLd0csT0FBSyxJQUFJLGVBQWUsSUFBSSxTQUFTLEVBQUU7Z0JBQzVELElBQUk7SUFDQSxnQkFBQSxNQUFNLFlBQVksR0FBRyxlQUFlLEVBQUUsQ0FBQztJQUN2QyxnQkFBQSxRQUFRLENBQUMsT0FBTyxHQUFHLFlBQVksQ0FBQztJQUNoQyxnQkFBQSxrQkFBa0IsQ0FBQyxPQUFPLElBQUksUUFBUSxHQUFHLFlBQVksRUFBRSxTQUFTLENBQUMsSUFBSSxTQUFTLENBQUMsQ0FBQztJQUNuRixhQUFBO0lBQ0QsWUFBQSxPQUFPLEVBQUUsRUFBRTs7SUFFVixhQUFBO0lBQ0osU0FBQTtJQUNMLEtBQUMsRUFBRSwyREFBMEQsQ0FBQyxDQUFDO0lBRy9ELElBQUEsTUFBTSxRQUFRLEdBQUd4RyxHQUFXLENBQUMsTUFBSztZQUM5QixJQUFJLFVBQVUsQ0FBQyxPQUFPO0lBQ2xCLFlBQUEsT0FBTyxDQUFDLElBQUksQ0FBQyxnTUFBZ00sQ0FBQyxDQUFDOzs7O0lBS25OLFFBQUEsSUFBSSxRQUFRLENBQUMsT0FBTyxLQUFLd0csT0FBSztJQUMxQixZQUFBLGNBQWMsRUFBRSxDQUFDO0lBRXJCLFFBQUEsUUFBUSxRQUFRLENBQUMsT0FBTyxLQUFLQSxPQUFLLEdBQUcsU0FBVSxHQUFHLFFBQVEsQ0FBQyxPQUFRLEVBQU87U0FDN0UsRUFBRSxFQUFFLENBQUMsQ0FBQztRQUVQN0csQ0FBZSxDQUFDLE1BQUs7OztJQUdqQixRQUFBLGNBQWMsRUFBRSxDQUFDO1NBR3BCLEVBQUUsRUFBRSxDQUFDLENBQUM7O1FBR1AsTUFBTSxDQUFDLEdBQUdDLENBQU0sQ0FBQyxFQUFFLGVBQWUsRUFBRSxLQUFLLEVBQUUsR0FBRyxFQUFFLFNBQThELEVBQUUsT0FBTyxFQUFFLFNBQTBCLEVBQUUsTUFBTSxFQUFFLElBQXFCLEVBQUUsQ0FBQyxDQUFDO0lBQ3RMLElBQUEsTUFBTSxRQUFRLEdBQUdJLEdBQVcsQ0FBeUIsQ0FBQyxHQUFHLEtBQUk7SUFDekQsUUFBQSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxLQUFLd0csT0FBSyxHQUFHLFNBQVMsR0FBRyxRQUFRLEVBQUUsQ0FBQztJQUN4RSxRQUFBLENBQUMsQ0FBQyxPQUFPLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQztJQUNwQixRQUFBLElBQUksQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGVBQWUsRUFBRTtJQUM1QixZQUFBLENBQUMsQ0FBQyxPQUFPLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztnQkFDakMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEdBQUcsVUFBVSxDQUFDLE1BQUs7SUFDL0IsZ0JBQUEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxlQUFlLEdBQUcsS0FBSyxDQUFDO0lBQ2xDLGdCQUFBLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQztJQUN4QixnQkFBQSxNQUFNLE9BQU8sR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNsQyxnQkFBQSxNQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLEdBQUksQ0FBQztJQUMzQixnQkFBQSxNQUFNLEdBQUcsR0FBRyxHQUFHLFlBQVksUUFBUSxHQUFHLEdBQUcsQ0FBQyxPQUFRLENBQUMsR0FBRyxHQUFHLENBQUM7SUFDMUQsZ0JBQUEsSUFBSSxHQUFHLEtBQUssUUFBUSxDQUFDLE9BQU8sRUFBRTs7SUFHMUIsb0JBQUEsVUFBVSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUM7d0JBRTFCLElBQUk7O0lBRUEsd0JBQUEsZUFBZSxFQUFFLENBQUM7SUFDbEIsd0JBQUEsa0JBQWtCLENBQUMsT0FBTyxJQUFJLFFBQVEsR0FBRyxHQUFHLEVBQUUsT0FBTyxDQUFDLElBQUksU0FBUyxDQUFDLENBQUM7SUFDckUsd0JBQUEsUUFBUSxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUM7SUFFMUIscUJBQUE7SUFDTyw0QkFBQTs7SUFFSix3QkFBQSxVQUFVLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQztJQUM5QixxQkFBQTtJQUNKLGlCQUFBO2lCQUVKLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDVCxTQUFBO1NBR0osRUFBRSxFQUFFLENBQUMsQ0FBQztJQUVQLElBQUEsT0FBTyxDQUFDLFFBQVEsRUFBRSxRQUFRLENBQVUsQ0FBQztJQUN6QyxDQUFDO0lBRUQsTUFBTUEsT0FBSyxHQUFHLE1BQU0sRUFBRSxDQUFDO0lBRXZCO2FBQ2dCLFVBQVUsR0FBQSxFQUFLLE9BQU8sSUFBSSxDQUFDLEVBQUU7YUFDN0IsV0FBVyxHQUFBLEVBQUssT0FBTyxLQUFLLENBQUMsRUFBRTthQUMvQixVQUFVLEdBQUEsRUFBSyxPQUFPLElBQUksQ0FBQyxFQUFFO2FBRTdCLFVBQVUsR0FBQSxFQUFLLE9BQU8sQ0FBQyxDQUFDOztJQ3pKeEIsU0FBQSxpQkFBaUIsQ0FBQyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQXVELEVBQUUsRUFBRSxRQUFRLEVBQUUsR0FBRyxFQUFzRCxFQUFBO0lBQzNLLElBQUEsSUFBSSxHQUFHLElBQUksSUFBSSxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7SUFDNUIsUUFBQSxPQUFPLFNBQVMsQ0FBQztJQUNwQixLQUFBO2FBQ0ksSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ2xCLFFBQUEsT0FBTyxHQUFHLENBQUM7SUFDZCxLQUFBO2FBQ0ksSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFO0lBQ2xCLFFBQUEsT0FBTyxHQUFHLENBQUM7SUFDZCxLQUFBO0lBQ0ksU0FBQTtZQUNELE9BQU8zVCxHQUFhLENBQUNlLEdBQVEsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBQ2hELEtBQUE7SUFDTDs7SUNmQSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQVEsU0FBUyxJQUFJLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQzs7SUNHalc7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LGFBRUwsY0FBYyxJQUFJLElBQUksSUFBSUEsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLGdCQUFBLEVBQW1CQyxzQkFBTSxNQUFNLENBQUMsT0FBTyxDQUFDLGNBQWMsQ0FBc0QsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxLQUFLLENBQUMsS0FBS0QsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFLLElBQUksRUFBSSxJQUFBLEVBQUEsS0FBSyxJQUFNLENBQUMsRUFBQSxDQUFNLElBQU0sRUFDbk0sWUFBWSxJQUFJLElBQUksSUFBSUEsMkNBQW9CQSxHQUN6QyxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBQyxHQUFBLENBQUEsT0FBQSxFQUFBLEVBQUEsUUFBQSxFQUFPRCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsTUFBQSxFQUFBLENBQWEsRUFBQUEsR0FBYSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxNQUFBLEVBQUEsQ0FBQSxFQUFBQSwrQkFBYSxFQUFBQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGVBQUEsRUFBQSxDQUFzQixJQUFLLEVBQVEsQ0FBQSxFQUNyRkEseUJBQVEsWUFBWSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUlELHVCQUFJQyxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUMsQ0FBQyxJQUFJLEdBQU0sRUFBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBQ0EsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxDQUFDLENBQUMsSUFBSSxHQUFNLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLFlBQVksSUFBSSxDQUFDLENBQUMsRUFBTSxDQUFBLENBQUEs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LEVBQUEsRUFBQSxRQUFBLEVBQUFELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FDSUMsR0FBYyxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxPQUFBLEVBQUEsQ0FBQSxFQUNkQSxnQ0FBYyxDQUNiLEVBQUEsQ0FBQSxFQUFBLENBQ0QsRUFDUkQsR0FBQSxDQUFBLE9BQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUNJQSxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBQSxFQUFBLENBQWtCLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsU0FBUyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDL0NELEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBSUMsc0NBQW9CLEVBQUFBLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUssV0FBVyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssRUFDbkRELEdBQUksQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQUMsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxjQUFBLEVBQUEsQ0FBcUIsRUFBQUEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxZQUFZLEVBQUEsQ0FBTSxJQUFLLEVBQ3JERCxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUlDLEdBQW9CLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLGFBQUEsRUFBQSxDQUFBLEVBQUFBLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsV0FBVyxHQUFNLENBQUssRUFBQSxDQUFBLEVBQ25ERCxHQUFJLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLENBQUFDLEdBQUEsQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsVUFBQSxF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
