var bundle = (function (exports) {
    'use strict';

    var n,l$1,u$1,t,o$2,r$2,f$1={},e$1=[],c$1=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function s$1(n,l){for(var u in l)n[u]=l[u];return n}function a$1(n){var l=n.parentNode;l&&l.removeChild(n);}function h$1(l,u,i){var t,o,r,f={};for(r in u)"key"==r?t=u[r]:"ref"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),"function"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return v$1(l,f,t,o,null)}function v$1(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u$1:r};return null==r&&null!=l$1.vnode&&l$1.vnode(f),f}function p$1(n){return n.children}function d$1(n,l){this.props=n,this.context=l;}function _$2(n,l){if(null==l)return n.__?_$2(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return "function"==typeof n.type?_$2(n):null}function k$1(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return k$1(n)}}function b(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g$2.__r++||o$2!==l$1.debounceRendering)&&((o$2=l$1.debounceRendering)||setTimeout)(g$2);}function g$2(){for(var n;g$2.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=s$1({},t)).__v=t.__v+1,j$2(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?_$2(t):o,t.__h),z$2(u,t),t.__e!=o&&k$1(t)));});}function w$2(n,l,u,i,t,o,r,c,s,a){var h,y,d,k,b,g,w,x=i&&i.__k||e$1,C=x.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(k=u.__k[h]=null==(k=l[h])||"boolean"==typeof k?null:"string"==typeof k||"number"==typeof k||"bigint"==typeof k?v$1(null,k,null,null,k):Array.isArray(k)?v$1(p$1,{children:k},null,null,null):k.__b>0?v$1(k.type,k.props,k.key,k.ref?k.ref:null,k.__v):k)){if(k.__=u,k.__b=u.__b+1,null===(d=x[h])||d&&k.key==d.key&&k.type===d.type)x[h]=void 0;else for(y=0;y<C;y++){if((d=x[y])&&k.key==d.key&&k.type===d.type){x[y]=void 0;break}d=null;}j$2(n,k,d=d||f$1,t,o,r,c,s,a),b=k.__e,(y=k.ref)&&d.ref!=y&&(w||(w=[]),d.ref&&w.push(d.ref,null,k),w.push(y,k.__c||b,k)),null!=b?(null==g&&(g=b),"function"==typeof k.type&&k.__k===d.__k?k.__d=s=m$1(k,s,n):s=A$1(n,k,d,x,b,s),"function"==typeof u.type&&(u.__d=s)):s&&d.__e==s&&s.parentNode!=n&&(s=_$2(d));}for(u.__e=g,h=C;h--;)null!=x[h]&&N(x[h],x[h]);if(w)for(h=0;h<w.length;h++)M$1(w[h],w[++h],w[++h]);}function m$1(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l="function"==typeof i.type?m$1(i,l,u):A$1(u,i,i,t,i.__e,l));return l}function x$1(n,l){return l=l||[],null==n||"boolean"==typeof n||(Array.isArray(n)?n.some(function(n){x$1(n,l);}):l.push(n)),l}function A$1(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else {for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o;}return void 0!==r?r:t.nextSibling}function C$2(n,l,u,i,t){var o;for(o in u)"children"===o||"key"===o||o in l||H$1(n,o,null,u[o],i);for(o in l)t&&"function"!=typeof l[o]||"children"===o||"key"===o||"value"===o||"checked"===o||u[o]===l[o]||H$1(n,o,l[o],u[o],i);}function $(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]=null==u?"":"number"!=typeof u||c$1.test(l)?u:u+"px";}function H$1(n,l,u,i,t){var o;n:if("style"===l)if("string"==typeof u)n.style.cssText=u;else {if("string"==typeof i&&(n.style.cssText=i=""),i)for(l in i)u&&l in u||$(n.style,l,"");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l]);}else if("o"===l[0]&&"n"===l[1])o=l!==(l=l.replace(/Capture$/,"")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T$2:I$1,o):n.removeEventListener(l,o?T$2:I$1,o);else if("dangerouslySetInnerHTML"!==l){if(t)l=l.replace(/xlink(H|:h)/,"h").replace(/sName$/,"s");else if("href"!==l&&"list"!==l&&"form"!==l&&"tabIndex"!==l&&"download"!==l&&l in n)try{n[l]=null==u?"":u;break n}catch(n){}"function"==typeof u||(null==u||!1===u&&-1==l.indexOf("-")?n.removeAttribute(l):n.setAttribute(l,u));}}function I$1(n){this.l[n.type+!1](l$1.event?l$1.event(n):n);}function T$2(n){this.l[n.type+!0](l$1.event?l$1.event(n):n);}function j$2(n,u,i,t,o,r,f,e,c){var a,h,v,y,_,k,b,g,m,x,A,C,$,H=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(a=l$1.__b)&&a(u);try{n:if("function"==typeof H){g=u.props,m=(a=H.contextType)&&t[a.__c],x=a?m?m.props.value:a.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:("prototype"in H&&H.prototype.render?u.__c=h=new H(g,x):(u.__c=h=new d$1(g,x),h.constructor=H,h.render=O$1),m&&m.sub(h),h.props=g,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[],h._sb=[]),null==h.__s&&(h.__s=h.state),null!=H.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=s$1({},h.__s)),s$1(h.__s,H.getDerivedStateFromProps(g,h.__s))),y=h.props,_=h.state;for(a=0;a<h._sb.length;a++)h.__h.push(h._sb[a]),h._sb=[];if(v)null==H.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else {if(null==H.getDerivedStateFromProps&&g!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(g,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(g,h.__s,x)||u.__v===i.__v){h.props=g,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u);}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(g,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,_,k);});}if(h.context=x,h.props=g,h.__v=u,h.__P=n,A=l$1.__r,C=0,"prototype"in H&&H.prototype.render)h.state=h.__s,h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context);else do{h.__d=!1,A&&A(u),a=h.render(h.props,h.state,h.context),h.state=h.__s;}while(h.__d&&++C<25);h.state=h.__s,null!=h.getChildContext&&(t=s$1(s$1({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,_)),$=null!=a&&a.type===p$1&&null==a.key?a.props.children:a,w$2(n,Array.isArray($)?$:[$],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1;}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L$1(i.__e,u,i,t,o,r,f,c);(a=l$1.diffed)&&a(u);}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l$1.__e(n,u,i);}}function z$2(n,u){l$1.__c&&l$1.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u);});}catch(n){l$1.__e(n,u.__v);}});}function L$1(l,u,i,t,o,r,e,c){var s,h,v,y=i.props,p=u.props,d=u.type,k=0;if("svg"===d&&(o=!0),null!=r)for(;k<r.length;k++)if((s=r[k])&&"setAttribute"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[k]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS("http://www.w3.org/2000/svg",d):document.createElement(d,p.is&&p),r=null,c=!1;}if(null===d)y===p||c&&l.data===p||(l.data=p);else {if(r=r&&n.call(l.childNodes),h=(y=i.props||f$1).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},k=0;k<l.attributes.length;k++)y[l.attributes[k].name]=l.attributes[k].value;(v||h)&&(v&&(h&&v.__html==h.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||""));}if(C$2(l,p,y,o,c),v)u.__k=[];else if(k=u.props.children,w$2(l,Array.isArray(k)?k:[k],u,i,t,o&&"foreignObject"!==d,r,e,r?r[0]:i.__k&&_$2(i,0),c),null!=r)for(k=r.length;k--;)null!=r[k]&&a$1(r[k]);c||("value"in p&&void 0!==(k=p.value)&&(k!==l.value||"progress"===d&&!k||"option"===d&&k!==y.value)&&H$1(l,"value",k,y.value,!1),"checked"in p&&void 0!==(k=p.checked)&&k!==l.checked&&H$1(l,"checked",k,y.checked,!1));}return l}function M$1(n,u,i){try{"function"==typeof n?n(u):n.current=u;}catch(n){l$1.__e(n,i);}}function N(n,u,i){var t,o;if(l$1.unmount&&l$1.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M$1(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount();}catch(n){l$1.__e(n,u);}t.base=t.__P=null,n.__c=void 0;}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,i||"function"!=typeof n.type);i||null==n.__e||a$1(n.__e),n.__=n.__e=n.__d=void 0;}function O$1(n,l,u){return this.constructor(n,u)}function P(u,i,t){var o,r,e;l$1.__&&l$1.__(u,i),r=(o="function"==typeof t)?null:t&&t.__k||i.__k,e=[],j$2(i,u=(!o&&t||i).__k=h$1(p$1,null,[u]),r||f$1,f$1,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,e,!o&&t?t:r?r.__e:i.firstChild,o),z$2(e,u);}function B$2(n,l){var u={__c:l="__cC"+r$2++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(b);},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n);};}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=e$1.slice,l$1={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l;}throw n}},u$1=0,d$1.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=s$1({},this.state),"function"==typeof n&&(n=n(s$1({},u),this.props)),n&&s$1(u,n),null!=n&&this.__v&&(l&&this._sb.push(l),b(this));},d$1.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),b(this));},d$1.prototype.render=p$1,t=[],g$2.__r=0,r$2=0;

    var _$1=0;function o$1(o,e,n,t,f){var l,s,u={};for(s in e)"ref"==s?l=e[s]:u[s]=e[s];var a={type:o,props:u,key:n,ref:l,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:--_$1,__source:f,__self:t};if("function"==typeof o&&(l=o.defaultProps))for(s in l)void 0===u[s]&&(u[s]=l[s]);return l$1.vnode&&l$1.vnode(a),a}

    var r$1,u,i,o,f=0,c=[],e=[],a=l$1.__b,v=l$1.__r,l=l$1.diffed,m=l$1.__c,d=l$1.unmount;function p(t,r){l$1.__h&&l$1.__h(u,t,f||r),f=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({__V:e}),i.__[t]}function y(n){return f=1,h(C$1,n)}function h(n,t,i){var o=p(r$1++,2);if(o.t=n,!o.__c&&(o.__=[i?i(t):C$1(void 0,t),function(n){var t=o.__N?o.__N[0]:o.__[0],r=o.t(t,n);t!==r&&(o.__N=[r,o.__[1]],o.__c.setState({}));}],o.__c=u,!u.u)){u.u=!0;var f=u.shouldComponentUpdate;u.shouldComponentUpdate=function(n,t,r){if(!o.__c.__H)return !0;var u=o.__c.__H.__.filter(function(n){return n.__c});if(u.every(function(n){return !n.__N}))return !f||f.call(this,n,t,r);var i=!1;return u.forEach(function(n){if(n.__N){var t=n.__[0];n.__=n.__N,n.__N=void 0,t!==n.__[0]&&(i=!0);}}),!(!i&&o.__c.props===n)&&(!f||f.call(this,n,t,r))};}return o.__N||o.__}function s(t,i){var o=p(r$1++,3);!l$1.__s&&B$1(o.__H,i)&&(o.__=t,o.i=i,u.__H.__h.push(o));}function _(t,i){var o=p(r$1++,4);!l$1.__s&&B$1(o.__H,i)&&(o.__=t,o.i=i,u.__h.push(o));}function A(n){return f=5,T$1(function(){return {current:n}},[])}function T$1(n,t){var u=p(r$1++,7);return B$1(u.__H,t)?(u.__V=n(),u.i=t,u.__h=n,u.__V):u.__}function q$1(n,t){return f=8,T$1(function(){return n},t)}function x(n){var t=u.context[n.__c],i=p(r$1++,9);return i.c=n,t?(null==i.__&&(i.__=!0,t.sub(u)),t.props.value):n.__}function g$1(){for(var t;t=c.shift();)if(t.__P&&t.__H)try{t.__H.__h.forEach(w$1),t.__H.__h.forEach(z$1),t.__H.__h=[];}catch(r){t.__H.__h=[],l$1.__e(r,t.__v);}}l$1.__b=function(n){"function"!=typeof n.type||n.__m||n.type===p$1?n.__m||(n.__m=n.__&&n.__.__m?n.__.__m:""):n.__m=(n.__&&n.__.__m?n.__.__m:"")+(n.__&&n.__.__k?n.__.__k.indexOf(n):0),u=null,a&&a(n);},l$1.__r=function(n){v&&v(n),r$1=0;var t=(u=n.__c).__H;t&&(i===u?(t.__h=[],u.__h=[],t.__.forEach(function(n){n.__N&&(n.__=n.__N),n.__V=e,n.__N=n.i=void 0;})):(t.__h.forEach(w$1),t.__h.forEach(z$1),t.__h=[])),i=u;},l$1.diffed=function(t){l&&l(t);var r=t.__c;r&&r.__H&&(r.__H.__h.length&&(1!==c.push(r)&&o===l$1.requestAnimationFrame||((o=l$1.requestAnimationFrame)||k)(g$1)),r.__H.__.forEach(function(n){n.i&&(n.__H=n.i),n.__V!==e&&(n.__=n.__V),n.i=void 0,n.__V=e;})),i=u=null;},l$1.__c=function(t,r){r.some(function(t){try{t.__h.forEach(w$1),t.__h=t.__h.filter(function(n){return !n.__||z$1(n)});}catch(u){r.some(function(n){n.__h&&(n.__h=[]);}),r=[],l$1.__e(u,t.__v);}}),m&&m(t,r);},l$1.unmount=function(t){d&&d(t);var r,u=t.__c;u&&u.__H&&(u.__H.__.forEach(function(n){try{w$1(n);}catch(n){r=n;}}),u.__H=void 0,r&&l$1.__e(r,u.__v));};var j$1="function"==typeof requestAnimationFrame;function k(n){var t,r=function(){clearTimeout(u),j$1&&cancelAnimationFrame(t),setTimeout(n);},u=setTimeout(r,100);j$1&&(t=requestAnimationFrame(r));}function w$1(n){var t=u,r=n.__c;"function"==typeof r&&(n.__c=void 0,r()),u=t;}function z$1(n){var t=u;n.__c=n.__(),u=t;}function B$1(n,t){return !n||n.length!==t.length||t.some(function(t,r){return t!==n[r]})}function C$1(n,t){return "function"==typeof t?t(n):t}

    function g(n,t){for(var e in t)n[e]=t[e];return n}function C(n,t){for(var e in n)if("__source"!==e&&!(e in t))return !0;for(var r in t)if("__source"!==r&&n[r]!==t[r])return !0;return !1}function E(n){this.props=n;}function w(n,e){function r(n){var t=this.props.ref,r=t==n.ref;return !r&&t&&(t.call?t(null):t.current=null),e?!e(this.props,n)||!r:C(this.props,n)}function u(e){return this.shouldComponentUpdate=r,h$1(n,e)}return u.displayName="Memo("+(n.displayName||n.name)+")",u.prototype.isReactComponent=!0,u.__f=!0,u}(E.prototype=new d$1).isPureReactComponent=!0,E.prototype.shouldComponentUpdate=function(n,t){return C(this.props,n)||C(this.state,t)};var R=l$1.__b;l$1.__b=function(n){n.type&&n.type.__f&&n.ref&&(n.props.ref=n.ref,n.ref=null),R&&R(n);};var O=l$1.__e;l$1.__e=function(n,t,e,r){if(n.then)for(var u,o=t;o=o.__;)if((u=o.__c)&&u.__c)return null==t.__e&&(t.__e=e.__e,t.__k=e.__k),u.__c(n,t);O(n,t,e,r);};var T=l$1.unmount;function I(n,t,e){return n&&(n.__c&&n.__c.__H&&(n.__c.__H.__.forEach(function(n){"function"==typeof n.__c&&n.__c();}),n.__c.__H=null),null!=(n=g({},n)).__c&&(n.__c.__P===e&&(n.__c.__P=t),n.__c=null),n.__k=n.__k&&n.__k.map(function(n){return I(n,t,e)})),n}function L(n,t,e){return n&&(n.__v=null,n.__k=n.__k&&n.__k.map(function(n){return L(n,t,e)}),n.__c&&n.__c.__P===t&&(n.__e&&e.insertBefore(n.__e,n.__d),n.__c.__e=!0,n.__c.__P=e)),n}function U(){this.__u=0,this.t=null,this.__b=null;}function D(n){var t=n.__.__c;return t&&t.__a&&t.__a(n)}function M(){this.u=null,this.o=null;}l$1.unmount=function(n){var t=n.__c;t&&t.__R&&t.__R(),t&&!0===n.__h&&(n.type=null),T&&T(n);},(U.prototype=new d$1).__c=function(n,t){var e=t.__c,r=this;null==r.t&&(r.t=[]),r.t.push(e);var u=D(r.__v),o=!1,i=function(){o||(o=!0,e.__R=null,u?u(l):l());};e.__R=i;var l=function(){if(!--r.__u){if(r.state.__a){var n=r.state.__a;r.__v.__k[0]=L(n,n.__c.__P,n.__c.__O);}var t;for(r.setState({__a:r.__b=null});t=r.t.pop();)t.forceUpdate();}},c=!0===t.__h;r.__u++||c||r.setState({__a:r.__b=r.__v.__k[0]}),n.then(i,i);},U.prototype.componentWillUnmount=function(){this.t=[];},U.prototype.render=function(n,e){if(this.__b){if(this.__v.__k){var r=document.createElement("div"),o=this.__v.__k[0].__c;this.__v.__k[0]=I(this.__b,r,o.__O=o.__P);}this.__b=null;}var i=e.__a&&h$1(p$1,null,n.fallback);return i&&(i.__h=null),[h$1(p$1,null,e.__a?null:n.children),i]};var V=function(n,t,e){if(++e[1]===e[0]&&n.o.delete(t),n.props.revealOrder&&("t"!==n.props.revealOrder[0]||!n.o.size))for(e=n.u;e;){for(;e.length>3;)e.pop()();if(e[1]<e[0])break;n.u=e=e[2];}};(M.prototype=new d$1).__a=function(n){var t=this,e=D(t.__v),r=t.o.get(n);return r[0]++,function(u){var o=function(){t.props.revealOrder?(r.push(u),V(t,n,r)):u();};e?e(o):o();}},M.prototype.render=function(n){this.u=null,this.o=new Map;var t=x$1(n.children);n.revealOrder&&"b"===n.revealOrder[0]&&t.reverse();for(var e=t.length;e--;)this.o.set(t[e],this.u=[1,0,this.u]);return n.children},M.prototype.componentDidUpdate=M.prototype.componentDidMount=function(){var n=this;this.o.forEach(function(t,e){V(n,e,t);});};var j="undefined"!=typeof Symbol&&Symbol.for&&Symbol.for("react.element")||60103,z=/^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/,B="undefined"!=typeof document,H=function(n){return ("undefined"!=typeof Symbol&&"symbol"==typeof Symbol()?/fil|che|rad/i:/fil|che|ra/i).test(n)};d$1.prototype.isReactComponent={},["componentWillMount","componentWillReceiveProps","componentWillUpdate"].forEach(function(t){Object.defineProperty(d$1.prototype,t,{configurable:!0,get:function(){return this["UNSAFE_"+t]},set:function(n){Object.defineProperty(this,t,{configurable:!0,writable:!0,value:n});}});});var q=l$1.event;function G(){}function J(){return this.cancelBubble}function K(){return this.defaultPrevented}l$1.event=function(n){return q&&(n=q(n)),n.persist=G,n.isPropagationStopped=J,n.isDefaultPrevented=K,n.nativeEvent=n};var X={configurable:!0,get:function(){return this.class}},nn=l$1.vnode;l$1.vnode=function(n){var t=n.type,e=n.props,u=e;if("string"==typeof t){var o=-1===t.indexOf("-");for(var i in u={},e){var l=e[i];B&&"children"===i&&"noscript"===t||"value"===i&&"defaultValue"in e&&null==l||("defaultValue"===i&&"value"in e&&null==e.value?i="value":"download"===i&&!0===l?l="":/ondoubleclick/i.test(i)?i="ondblclick":/^onchange(textarea|input)/i.test(i+t)&&!H(e.type)?i="oninput":/^onfocus$/i.test(i)?i="onfocusin":/^onblur$/i.test(i)?i="onfocusout":/^on(Ani|Tra|Tou|BeforeInp|Compo)/.test(i)?i=i.toLowerCase():o&&z.test(i)?i=i.replace(/[A-Z0-9]/g,"-$&").toLowerCase():null===l&&(l=void 0),/^oninput$/i.test(i)&&(i=i.toLowerCase(),u[i]&&(i="oninputCapture")),u[i]=l);}"select"==t&&u.multiple&&Array.isArray(u.value)&&(u.value=x$1(e.children).forEach(function(n){n.props.selected=-1!=u.value.indexOf(n.props.value);})),"select"==t&&null!=u.defaultValue&&(u.value=x$1(e.children).forEach(function(n){n.props.selected=u.multiple?-1!=u.defaultValue.indexOf(n.props.value):u.defaultValue==n.props.value;})),n.props=u,e.class!=e.className&&(X.enumerable="className"in e,null!=e.className&&(u.class=e.className),Object.defineProperty(u,"className",X));}n.$$typeof=j,nn&&nn(n);};var tn=l$1.__r;l$1.__r=function(n){tn&&tn(n),n.__c;};

    /**
     * Debug hook.
     *
     * Given a value or set of values, emits a console error if any of them change from one render to the next.
     *
     * Eventually, when useEvent lands, we hopefully won't need this.
     */
    function useEnsureStability(parentHookName, ...values) {
        useHelper(values.length, 0);
        values.forEach(useHelper);
        return;
        function useHelper(value, index) {
            // Make sure that the provided functions are perfectly stable across renders
            const helperToEnsureStability = A(value);
            const shownError = A(false);
            if (helperToEnsureStability.current != value) {
                if (!shownError.current) {
                    /* eslint-disable no-debugger */
                    debugger;
                    console.error(`The hook ${parentHookName} requires some or all of its arguments remain stable across each render; please check the ${index}-indexed argument.`);
                    shownError.current = true;
                }
            }
        }
    }
    function debounceRendering(f) {
        (l$1.debounceRendering ?? setTimeout)(f);
    }
    /**
     * Similar to `useState`, but for values that aren't "render-important" &ndash; updates don't cause a re-render and so the value shouldn't be used during render (though it certainly can, at least by re-rendering again).
     *
     * To compensate for this, you should pass a `useEffect`-esque callback that is run whenever the value changes.  Just like `useEffect`, this callback can return a cleanup function that's run before the value changes.  If you would like to re-render when the value changes (or, say, when the value meets some criteria), this is where you'll want to put in a call to a `setState` function.
     *
     * To summarize, it's like a `useState`-`useEffect` mashup:
     *
     * 1. It's like `useState`, except this version of `setState` doesn't re-render the whole component
     * 2. It's like `useState`, except you can run a function when the value changes that optionally returns a cleanup function
     * 3. It's like `useEffect`, except you trigger the effect function "remotely" instead of it running after rendering
     * 4. It's like `useEffect`, except the single "dependency" is based on your calls to `setState`
     *
     * Note that while calling `setState` doesn't cause any re-renders, you can do that within your `onChange` function, called whenever the value changes via that `setState`.
     *
     * @param onChange The "effect" function to run when the value changes. Effectively the same as `useEffect`'s "effect" function.  MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param getInitialValue If provided, the effect will be invoked once with this value on mount. MUST BE STABLE, either because it has no dependencies, or because it's from useStableCallback, but this will mean you cannot use getState or setState during render.
     * @param customDebounceRendering By default, changes to passive state are delayed by one tick so that we only check for changes in a similar way to Preact. You can override this to, for example, always run immediately instead.
     * @returns
     */
    function usePassiveState(onChange, getInitialValue, customDebounceRendering) {
        const valueRef = A(Unset$1);
        const warningRef = A(false);
        const cleanupCallbackRef = A(undefined);
        // Make sure that the provided functions are perfectly stable across renders
        useEnsureStability("usePassiveState", onChange, getInitialValue, customDebounceRendering);
        // Shared between "dependency changed" and "component unmounted".
        const onShouldCleanUp = q$1(() => {
            const cleanupCallback = cleanupCallbackRef.current;
            if (cleanupCallback)
                cleanupCallback();
        }, []);
        // There are a couple places where we'd like to use our initial
        // value in place of having no value at all yet.
        // This is the shared code for that, used on mount and whenever
        // getValue is called.
        const tryEnsureValue = q$1(() => {
            if (valueRef.current === Unset$1 && getInitialValue != undefined) {
                try {
                    const initialValue = getInitialValue();
                    valueRef.current = initialValue;
                    cleanupCallbackRef.current = (onChange?.(initialValue, undefined) ?? undefined);
                }
                catch (ex) {
                    // Exceptions are intentional to allow bailout (without exposing the Unset symbol)
                }
            }
        }, [ /* getInitialValue and onChange intentionally omitted */]);
        const getValue = q$1(() => {
            if (warningRef.current)
                console.warn("During onChange, prefer using the (value, prevValue) arguments instead of getValue -- it's ambiguous as to if you're asking for the old or new value at this point in time for this component.");
            // The first time we call getValue, if we haven't been given a value yet,
            // (and we were given an initial value to use)
            // return the initial value instead of nothing.
            if (valueRef.current === Unset$1)
                tryEnsureValue();
            return (valueRef.current === Unset$1 ? undefined : valueRef.current);
        }, []);
        _(() => {
            // Make sure we've run our effect at least once on mount.
            // (If we have an initial value, of course)
            tryEnsureValue();
        }, []);
        // The actual code the user calls to (possibly) run a new effect.
        const r = A({ prevDep: Unset$1 });
        const setValue = q$1((arg) => {
            // Regardless of anything else, figure out what our next value is about to be.
            const nextValue = (arg instanceof Function ? arg(valueRef.current === Unset$1 ? undefined : valueRef.current) : arg);
            if (r.current.prevDep === Unset$1 && nextValue !== valueRef.current) {
                // This is the first request to change this value.
                // Evaluate the request immediately, then queue up the onChange function
                // Save our current value so that we can compare against it later
                // (if we flip back to this state, then we won't send the onChange function)
                r.current.prevDep = valueRef.current;
                // It's important to update this here (as well as below) in case customDebounceRendering invokes this immediately
                valueRef.current = nextValue;
                // Schedule the actual check and invocation of onChange later to let effects settle
                (customDebounceRendering ?? debounceRendering)(() => {
                    const nextDep = valueRef.current;
                    const prevDep = r.current.prevDep;
                    if (r.current.prevDep != valueRef.current) {
                        warningRef.current = true;
                        try {
                            // Call any registered cleanup function
                            onShouldCleanUp();
                            cleanupCallbackRef.current = (onChange?.(nextDep, prevDep === Unset$1 ? undefined : prevDep) ?? undefined);
                            valueRef.current = nextDep;
                        }
                        finally {
                            // Allow the user to normally call getValue again
                            warningRef.current = false;
                        }
                    }
                    // We've finished with everything, so mark us as being on a clean slate again.
                    r.current.prevDep = Unset$1;
                });
            }
            // Update the value immediately.
            // This will be checked against prevDep to see if we should actually call onChange
            valueRef.current = nextValue;
        }, []);
        return [getValue, setValue];
    }
    const Unset$1 = Symbol();
    // Easy constants for getInitialValue
    function returnTrue() { return true; }
    function returnFalse() { return false; }
    function returnNull() { return null; }

    /*
    const activeElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node | null) => void)>>();
    const lastActiveElementUpdaters = new Map<Window | null | undefined, Set<undefined | ((e: Node) => void)>>();
    const windowFocusedUpdaters = new Map<Window | null | undefined, Set<undefined | ((focused: boolean) => void)>>();
    const windowsFocusedUpdaters = new Map<Window | null | undefined, boolean>();*/
    const activeElementUpdaters = new Map();
    const lastActiveElementUpdaters = new Map();
    const windowFocusedUpdaters = new Map();
    const windowsFocusedUpdaters = new Map();
    //const microtasks = new Map<Set<any>, any>();
    // The focusin and focusout events often fire syncronously in the middle of running code.
    // E.G. calling element.focus() can cause a focusin event handler to immediately interrupt that code.
    // For the purpose of improving stability, we debounce all focus events to the next microtask.
    function forEachUpdater(window, map, value) {
        const updaters = map.get(window);
        if (updaters) {
            //if (!microtasks.has(updatersKey)) {
            //debounceRendering(() => {
            //const updatersKey = map.get(window)!;
            //const value = microtasks.get(updatersKey);
            //microtasks.delete(updatersKey);
            if (updaters) {
                for (const updater of updaters) {
                    const { lastSent, send } = updater;
                    if (value !== lastSent) {
                        send(value);
                        updater.lastSent = value;
                    }
                }
            }
            //});
            //}
            //microtasks.set(updatersKey, value);
        }
    }
    function focusout(e) {
        const window = e.target.ownerDocument.defaultView;
        if (e.relatedTarget == null) {
            forEachUpdater(window, activeElementUpdaters, null);
        }
    }
    function focusin(e) {
        const window = e.target.ownerDocument.defaultView;
        const currentlyFocusedElement = e.target;
        forEachUpdater(window, activeElementUpdaters, currentlyFocusedElement);
        forEachUpdater(window, lastActiveElementUpdaters, currentlyFocusedElement);
    }
    function windowFocus(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, true);
        forEachUpdater(window, windowFocusedUpdaters, true);
    }
    function windowBlur(e) {
        const window = (e.target instanceof Window ? e.target : e.currentTarget instanceof Window ? e.currentTarget : e.target.ownerDocument.defaultView);
        windowsFocusedUpdaters.set(window, false);
        forEachUpdater(window, windowFocusedUpdaters, false);
    }
    /**
     * Allows you to inspect which element in the `document` currently has focus, which was most recently focused if none are currently, and whether or not the window has focus by returning the following functions:
     * * `getActiveElement()`
     * * `getLastActiveElement()`
     * * `getWindowFocused()`
     *
     * (The document's body receiving focus, like it does when you click on an empty area, is counted as no element having focus for all intents and purposes)
     *
     * This is a passive hook, so by default it returns getter functions that report this information but the component will not re-render by default when the active element changes.
     *
     * If you need the component to re-render when the active element changes, use the `on*Change` arguments to set some state on your end.
     */
    function useActiveElement({ onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow }) {
        useEnsureStability("useActiveElement", onActiveElementChange, onLastActiveElementChange, onWindowFocusedChange, getDocument, getWindow);
        s(() => {
            const document = getDocument();
            const window = (getWindow?.(document) ?? document?.defaultView);
            if ((activeElementUpdaters.get(window)?.size ?? 0) === 0) {
                document?.addEventListener("focusin", focusin, { passive: true });
                document?.addEventListener("focusout", focusout, { passive: true });
                window?.addEventListener("focus", windowFocus, { passive: true });
                window?.addEventListener("blur", windowBlur, { passive: true });
            }
            // Add them even if they're undefined to more easily
            // manage the ">0 means don't add handlers" logic.
            const localActiveElementUpdaters = activeElementUpdaters.get(window) ?? new Set();
            const localLastActiveElementUpdaters = lastActiveElementUpdaters.get(window) ?? new Set();
            const localWindowFocusedUpdaters = windowFocusedUpdaters.get(window) ?? new Set();
            const laeu = { send: setActiveElement, lastSent: undefined };
            const llaeu = { send: setLastActiveElement, lastSent: undefined };
            const lwfu = { send: setWindowFocused, lastSent: undefined };
            localActiveElementUpdaters.add(laeu);
            localLastActiveElementUpdaters.add(llaeu);
            localWindowFocusedUpdaters.add(lwfu);
            activeElementUpdaters.set(window, localActiveElementUpdaters);
            lastActiveElementUpdaters.set(window, localLastActiveElementUpdaters);
            windowFocusedUpdaters.set(window, localWindowFocusedUpdaters);
            return () => {
                activeElementUpdaters.get(window).delete(laeu);
                lastActiveElementUpdaters.get(window).delete(laeu);
                windowFocusedUpdaters.get(window).delete(lwfu);
                if (activeElementUpdaters.size === 0) {
                    document?.removeEventListener("focusin", focusin);
                    document?.removeEventListener("focusout", focusout);
                    window?.removeEventListener("focus", windowFocus);
                    window?.removeEventListener("blur", windowBlur);
                }
            };
        }, []);
        const [getActiveElement, setActiveElement] = usePassiveState(onActiveElementChange, returnNull);
        const [getLastActiveElement, setLastActiveElement] = usePassiveState(onLastActiveElementChange, returnNull);
        const [getWindowFocused, setWindowFocused] = usePassiveState(onWindowFocusedChange, returnTrue);
        return { getActiveElement, getLastActiveElement, getWindowFocused };
    }

    const Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_-";
    function base64(value) {
        return Table[value];
    }
    function random6Bits() {
        return Math.floor(Math.random() * 0b1000000);
    }
    function random64Bits() {
        return [random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits(), random6Bits()];
    }
    /**
     * Returns a randomly-generated ID with an optional prefix.
     * Note that if the prefix is *explicitly* set to "", then
     * IDs that are not valid under HTML4 may be generated. Oh no.
     *
     *
     * (This is here, in this particular file, to avoid circular dependencies
     * without also making a utilities file.
     * Once we can remove this hook, we can put this function back with useRandomId)
     */
    function generateRandomId(prefix) {
        return `${prefix ?? "id-"}${random64Bits().map(n => base64(n)).join("")}`;
    }
    const previousInputs = new Map();
    const toRun = new Map();
    // TODO: Whether this goes in options.diffed or options._commit
    // is a post-suspense question.
    // Right now, using options._commit has the problem of running
    // *after* refs are applied, but we need to come before even that
    // so `ref={someStableFunction}` works.
    // 
    // Also it's private.
    //
    // ...
    // Well, useEvent or whatever is finally, finally 4 years later finally here
    // which is cool and means we won't need this at all soon.
    // So for now we'll stick with diff to prevent any weirdness with
    // commit being private and all.
    const commitName = "diffed";
    const originalCommit = l$1[commitName];
    const newCommit = (...args) => {
        for (const [id, effectInfo] of toRun) {
            const oldInputs = previousInputs.get(id);
            if (argsChanged(oldInputs, effectInfo.inputs)) {
                effectInfo.cleanup?.();
                effectInfo.cleanup = effectInfo.effect();
                previousInputs.set(id, effectInfo.inputs);
            }
        }
        toRun.clear();
        originalCommit?.(...args);
    };
    l$1[commitName] = newCommit;
    /**
     * Semi-private function to allow stable callbacks even within `useLayoutEffect` and ref assignment.
     *
     * Every render, we send the arguments to be evaluated after diffing has completed,
     * which happens before.
     *
     * @param effect
     * @param inputs
     */
    function useBeforeLayoutEffect(effect, inputs) {
        /*(() => {
            const cleanup = useRef<void | (() => void) | null>(null);
            const prevArgsRef = useRef<Inputs>(null!);
            if (argsChanged(inputs, prevArgsRef.current)) {
                prevArgsRef.current = inputs!;
                if (cleanup.current)
                    cleanup.current();
                cleanup.current = effect();
            }
        })();*/
        const [id] = y(() => generateRandomId());
        toRun.set(id, { effect, inputs, cleanup: null });
        s(() => {
            return () => {
                toRun.delete(id);
                previousInputs.delete(id);
            };
        }, [id]);
    }
    function argsChanged(oldArgs, newArgs) {
        return !!(!oldArgs ||
            oldArgs.length !== newArgs?.length ||
            newArgs?.some((arg, index) => arg !== oldArgs[index]));
    }

    const Unset = Symbol("unset");
    /**
     * Given an input value, returns a constant getter function that can be used
     * inside of `useEffect` and friends without including it in the dependency array.
     *
     * This uses `options.diffed` in order to run before everything, even
     * ref assignment. This means this getter is safe to use anywhere ***except the render phase***.
     *
     * @param value
     * @returns
     */
    function useStableGetter(value) {
        const ref = A(Unset);
        useBeforeLayoutEffect(() => { ref.current = value; }, [value]);
        return q$1(() => {
            if (ref.current === Unset) {
                throw new Error('Value retrieved from useStableGetter() cannot be called during render.');
            }
            return ref.current;
        }, []);
    }

    /**
     * Alternate useCallback() which always returns the same (wrapped) function reference
     * so that it can be excluded from the dependency arrays of `useEffect` and friends.
     *
     * Do not use during the render phase!  `useLayoutEffect` is fine though.
     */
    function useStableCallback(fn) {
        const currentCallbackGetter = useStableGetter(fn);
        return q$1((...args) => {
            return currentCallbackGetter()(...args);
        }, []);
    }

    const SharedAnimationFrameContext = B$2(null);
    /**
     * The (optionally non-stable) `callback` you provide will start running every frame after the component mounts.
     *
     * Passing `null` is fine and simply stops the effect until you restart it by providing a non-null callback.
     *
     * **This hook does not return anything at all, including no prop-modifying hooks**
     */
    function useAnimationFrame({ callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback ?? noop);
        const hasCallback = (callback != null);
        const sharedAnimationFrameContext = x(SharedAnimationFrameContext);
        s(() => {
            if (sharedAnimationFrameContext) {
                if (hasCallback) {
                    sharedAnimationFrameContext.addCallback(stableCallback);
                }
                else {
                    sharedAnimationFrameContext.removeCallback(stableCallback);
                }
            }
            else {
                if (hasCallback) {
                    // Get a wrapper around the wrapper around the callback
                    // that also calls `requestAnimationFrame` again.
                    const rafCallback = (ms) => {
                        handle = requestAnimationFrame(rafCallback);
                        stableCallback(ms);
                    };
                    let handle = requestAnimationFrame(rafCallback);
                    return () => cancelAnimationFrame(handle);
                }
            }
        }, [sharedAnimationFrameContext, hasCallback]);
    }
    // eslint-disable @typescript-eslint/no-empty-function
    function noop() { }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /** Detect free variable `global` from Node.js. */
    var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

    /** Detect free variable `self`. */
    var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

    /** Used as a reference to the global object. */
    var root = freeGlobal || freeSelf || Function('return this')();

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = function() {
      return root.Date.now();
    };

    /** Used to match a single whitespace character. */
    var reWhitespace = /\s/;

    /**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */
    function trimmedEndIndex(string) {
      var index = string.length;

      while (index-- && reWhitespace.test(string.charAt(index))) {}
      return index;
    }

    /** Used to match leading whitespace. */
    var reTrimStart = /^\s+/;

    /**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */
    function baseTrim(string) {
      return string
        ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
        : string;
    }

    /** Built-in value references. */
    var Symbol$1 = root.Symbol;

    /** Used for built-in method references. */
    var objectProto$5 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString$1 = objectProto$5.toString;

    /** Built-in value references. */
    var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty$3.call(value, symToStringTag$1),
          tag = value[symToStringTag$1];

      try {
        value[symToStringTag$1] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString$1.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag$1] = tag;
        } else {
          delete value[symToStringTag$1];
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$4 = Object.prototype;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto$4.toString;

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /** `Object#toString` result references. */
    var nullTag = '[object Null]',
        undefinedTag = '[object Undefined]';

    /** Built-in value references. */
    var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /** `Object#toString` result references. */
    var symbolTag = '[object Symbol]';

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /** Used as references for various `Number` constants. */
    var NAN = 0 / 0;

    /** Used to detect bad signed hexadecimal string values. */
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

    /** Used to detect binary string values. */
    var reIsBinary = /^0b[01]+$/i;

    /** Used to detect octal string values. */
    var reIsOctal = /^0o[0-7]+$/i;

    /** Built-in method references without a dependency on `root`. */
    var freeParseInt = parseInt;

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT$1 = 'Expected a function';

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeMax = Math.max,
        nativeMin = Math.min;

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT$1);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /** Error message constants. */
    var FUNC_ERROR_TEXT = 'Expected a function';

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Slightly enhanced version of `useState` that includes a getter that remains constant
     * (i.e. you can use it in `useEffect` and friends without it being a dependency).
     *
     * @param initialState
     * @returns
     */
    function useState(initialState) {
        // We keep both, but overrride the `setState` functionality
        const [state, setStateP] = y(initialState);
        const ref = A(state);
        // Hijack the normal setter function 
        // to also set our ref to the new value
        const setState = q$1(value => {
            if (typeof value === "function") {
                const callback = value;
                setStateP(prevValue => {
                    const nextValue = callback(prevValue);
                    ref.current = nextValue;
                    return nextValue;
                });
            }
            else {
                ref.current = value;
                setStateP(value);
            }
        }, []);
        const getState = () => { return ref.current; };
        console.assert(ref.current === state || (typeof state === "number" && isNaN(state)));
        return [state, setState, getState];
    }

    function identity$1(...t) { return t; }
    function useThrottled(callback, wait, options) {
        const throttled = T$1(() => {
            return callback ? throttle(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.trailing]);
        s(() => {
            return () => throttled?.cancel();
        }, [throttled]);
        return throttled;
    }
    function useDebounced(callback, wait, options) {
        const debounced = T$1(() => {
            return callback ? debounce(callback, wait, options) : null;
        }, [callback, wait, options?.leading, options?.maxWait, options?.trailing]);
        s(() => {
            return () => debounced?.cancel();
        }, [debounced]);
        return debounced;
    }
    /**
     * Given an async function, returns a function that's suitable for non-async APIs,
     * along with other information about the current run's status.
     *
     * See also `useAsyncHandler` for a version that's specialized for DOM event handlers.
     *
     * When called multiple times in quick succession, (i.e. before the handler has finished),
     * this works like Lodash's `throttle` function with the `wait` option always
     * set to however long the handler takes to complete. A second call to the sync function will be
     * throttled until the first call has finished. The return value of the function is the result
     * of the previous invocation, or `undefined` on the first call.
     *
     * The handler is only ever delayed if one is currently running, so, e.g. for iOS touch events the
     * first call happens in the same event handler (which means things like calls to `element.focus()`
     * will work as intended, since that fails when the event is "split up")
     *
     * Finally, because the sync handler may be invoked on a delay, any property references on the arguments
     * provided might be stale by the time it's actually invoked (e.g. accessing `event.currentTarget.checked`
     * is not stable across time because it's a "live" value -- you almost always want the value that it
     * had at the original time the handler was called). The `capture` option allows you to save that kind of
     * dynamic data at the time it runs; the `AP` and `SP` type parameters likewise control
     * the parameters the async handler and sync handler expect respectively.
     *
     */
    function useAsync(asyncHandler, options) {
        /* eslint-disable prefer-const */
        let { throttle, debounce, capture } = (options ?? {});
        capture ??= identity$1;
        // We keep, like, a lot of render-state, but it only ever triggers a re-render
        // when we start/stop an async action.
        // Keep track of this for the caller's sake -- we don't really care.
        const [currentType, setCurrentType] = useState(null);
        const [runCount, setRunCount] = useState(0);
        const [settleCount, setSettleCount] = useState(0);
        const [resolveCount, setResolveCount] = useState(0);
        const [rejectCount, setRejectCount] = useState(0);
        // Things related to current execution
        // Because we can both return and throw undefined, 
        // we need separate state to track their existance too.
        const [pending, setPending, getPending] = useState(false);
        const [result, setResult, getResult] = useState(undefined);
        const [error, setError, _getError] = useState(undefined);
        const [hasError, setHasError, _getHasError] = useState(false);
        const [hasResult, setHasResult, _getHasResult] = useState(false);
        // We implement our own throttling behavior in regards to waiting until the async handler finishes.
        // These two passive state variables keep track of that, automatically queueing/dequeuing the next handler.
        const [getQueued, setQueued] = usePassiveState(null, returnNull);
        // The actual sync handler.
        // Capture/transform the given parameters if applicable,
        // then run further logic that's debounced/throttled
        const captureArgsAndExecuteDebouncedHandler = useStableCallback(function onNewExecuteRequest(...newArgs2) {
            // Capture the arguments we were given.
            // We might use them immediately, or we might store them to `queued`,
            // but in either case we do need the captured value.
            const captured = capture(...newArgs2);
            // This is all logic that deals with the captured value instead of the raw arguments.
            // It's called in two separate circumstances,
            // and has the debounce/throttle logic already applied
            return executeHandlerWithDebounce(getPending(), ...captured);
        });
        // This is the logic that runs when the handler is *just* about to start.
        // This function itself is further transformed to be throttled/debounced if requested,
        // so this might not be called immediately after 
        const executeHandlerWithoutDebounce = useStableCallback(function onNewExecuteRequest2(enqueue, ...newArgs) {
            const onThen = (value) => { setResult(value); setHasResult(true); setHasError(false); setResolveCount(r => ++r); };
            const onCatch = (ex) => { setError(ex); setHasError(true); setHasResult(false); setRejectCount(r => ++r); };
            const onFinally = () => {
                const queued = getQueued();
                setSettleCount(s => ++s);
                if (queued) {
                    setQueued(null);
                    executeHandlerWithDebounce(false, ...queued);
                }
                else {
                    setPending(false);
                }
            };
            if (!enqueue) {
                // Nothing is pending at the moment, so we can run our function immediately.
                setRunCount(r => ++r);
                setPending(true);
                const result = asyncHandler?.(...newArgs);
                const isPromise = (result != null && typeof result == "object" && "then" in result);
                if (result == null || !isPromise) {
                    // It's synchronous and returned successfully.
                    // Bail out early.
                    onThen(result);
                    onFinally();
                    setCurrentType("sync");
                }
                else {
                    result.then(onThen).catch(onCatch).finally(onFinally);
                    setCurrentType("async");
                }
            }
            else {
                // When we're still running a previous handler,
                // just set ourselves as the next one to run and quit early.
                // Nothing more to do.
                setQueued(newArgs);
            }
            return getResult();
        });
        const executeHandlerWithT = useThrottled(!throttle ? null : executeHandlerWithoutDebounce, throttle ?? 0);
        const executeHandlerWithD = useDebounced(!debounce ? null : (executeHandlerWithT ?? executeHandlerWithoutDebounce), debounce ?? 0);
        const executeHandlerWithDebounce = (executeHandlerWithD ?? executeHandlerWithT ?? executeHandlerWithoutDebounce);
        const flushDebouncedPromise = useStableCallback(() => {
            if (executeHandlerWithDebounce && "flush" in executeHandlerWithDebounce)
                executeHandlerWithDebounce.flush();
        });
        return {
            syncHandler: captureArgsAndExecuteDebouncedHandler,
            currentType,
            pending,
            result,
            error,
            hasError,
            hasResult,
            resolveCount,
            rejectCount,
            settleCount,
            callCount: runCount,
            flushDebouncedPromise
        };
    }

    /**
     * Given an asyncronous event handler, returns a syncronous one that works on the DOM,
     * along with some other information related to the current state.
     * Does not modify any props.
     *
     * Note that because the handler you provide may be called with a delay, and
     * because the value of, e.g., an `<input>` element will likely be stale by the
     * time the delay is over, a `capture` function is necessary in order to
     * capture the relevant information from the DOM. Any other simple event data,
     * like `mouseX` or `shiftKey` can stay on the event itself and don't
     * need to be captured &ndash; it's never stale.
     *
     * ```tsx
     * const asyncOnInput = async (value: number, e: Event) => {
     *     [...] // Ex. send to a server and setState when done
     * };
     * const {
     *     // A sync version of asyncOnInput
     *     syncHandler,
     *     // True while the handler is running
     *     pending,
     *     // The error thrown, if any
     *     error,
     *     // Show this value while the operation's pending
     *     currentCapture,
     *     // And others, see `UseAsyncHandlerReturnType`
     *     ...rest
     * } = useAsyncHandler<HTMLInputElement>()(asyncOnInput, {
     *     // Pass in the capture function that saves event data
     *     // from being stale.
     *     capture: e => {
     *         // `capture` can have side-effects because
     *         // it's called exactly once per invocation
     *         e.preventDefault();
     *
     *         // Save this value so that it's never stale
     *         return e.currentTarget.valueAsNumber;
     *     }
     * });
     *
     * const onInput = pending? null : syncHandler;
     * ```
     *
     * The handler is automatically throttled to only run one at a time.
     * If the handler is called, and then before it finishes, is called again,
     * it will be put on hold until the current one finishes, at which point
     * the second one will run.  If the handler is called a third time before
     * the first has finished, it will *replace* the second, so only the most
     * recently called iteration of the handler will run.
     *
     *
     * You may optionally *also* specify debounce and throttle parameters that wait until the
     * syncronous handler has not been called for the specified number of
     * milliseconds, at which point we *actually* run the asyncronous handler
     * according to the logic in the previous paragraph. This is in
     * *addition* to throttling the handler, and does not replace that behavior.
     *
     * @see useAsync A more general version of this hook that can work with any type of handler, not just DOM event handlers.
     */
    function useAsyncHandler({ asyncHandler, capture: originalCapture, ...restAsyncOptions }) {
        // We need to differentiate between "nothing captured yet" and "`undefined` was captured"
        const [currentCapture, setCurrentCapture, getCurrentCapture] = useState(undefined);
        const [hasCapture, setHasCapture] = useState(false);
        // Wrap around the normal `useAsync` `capture` function to also
        // keep track of the last value the user actually input.
        // 
        // Without this there's no way to re-render the control with
        // it being both controlled and also having the "correct" value,
        // and at any rate also protects against sudden exceptions reverting
        // your change out from under you.
        const capture = useStableCallback((e) => {
            const captured = originalCapture(e);
            setCurrentCapture(captured);
            setHasCapture(true);
            return [captured, e];
        });
        return {
            getCurrentCapture,
            currentCapture,
            hasCapture,
            ...useAsync(asyncHandler, { capture, ...restAsyncOptions })
        };
    }

    /**
     * Allows a parent component to access information about certain
     * child components once they have rendered.
     *
     * This hook is designed to be lightweight, in that the parent keeps no state
     * and runs no effects.  Each child *does* run an effect, but with no state
     * changes unless you explicitly request them.
     *
     *
     */
    function useManagedChildren(parentParameters) {
        const { managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        useEnsureStability("useManagedChildren", onAfterChildLayoutEffect, onChildrenMountChange);
        const getHighestIndex = q$1(() => {
            return managedChildrenArray.current.highestIndex;
        }, []);
        // All the information we have about our children is stored in this **stable** array.
        // Any mutations to this array **DO NOT** trigger any sort of a re-render.
        const managedChildrenArray = A({ arr: [], rec: {}, highestIndex: 0, lowestIndex: 0 });
        // For indirect access to each child
        // Compare getManagedChildInfo
        // TODO: The primary use for this is flaggable closest fits
        // which needs to search all children for that closest fit.
        // It would be nice if there was something better for that.
        const forEachChild = q$1((f) => {
            for (const child of managedChildrenArray.current.arr) {
                if (child)
                    f(child);
            }
            for (const field in managedChildrenArray.current.rec) {
                const child = managedChildrenArray.current.rec[field];
                if (child)
                    f(child);
            }
        }, []);
        // Retrieves the information associated with the child with the given index.
        // `undefined` if not child there, or it's unmounted.
        const getManagedChildInfo = q$1((index) => {
            if (typeof index == "number")
                return managedChildrenArray.current.arr[index];
            else
                return managedChildrenArray.current.rec[index];
        }, []);
        // tl;dr this is a way to have run useLayoutEffect once after all N children
        // have mounted and run *their* useLayoutEffect, but also *without* re-rendering
        // ourselves because of having a `childCount` state or anything similar.
        //
        // When the child count ref updates, we want the parent to also run an effect
        // to maybe do something with all these children that just mounted.
        // The easiest way would be useEffect(..., [childCount]) but
        // that would require us having a childCount state, then calling
        // setChildCount and re-rendering every time children mount
        // (only one re-render at a time unless children are staggered, but still)
        // 
        // As an alternate solution, any time a child uses ULE on mount, it queues a microtask
        // to emulate running ULE on the parent. Only the first child will actually queue
        // the microtask (by checking hasRemoteULE first) so that the "effect" only
        // runs once. When it's done, hasRemoteULE is reset so it can run again if
        // more children mount/unmount.
        const hasRemoteULEChildMounted = A(null);
        const remoteULEChildChangedCausers = A(new Set());
        const remoteULEChildChanged = q$1((index) => {
            if (remoteULEChildChangedCausers.current.size == 0) {
                debounceRendering(() => {
                    onAfterChildLayoutEffect?.(remoteULEChildChangedCausers.current);
                    remoteULEChildChangedCausers.current.clear();
                });
            }
            remoteULEChildChangedCausers.current.add(index);
            return () => { };
        }, [ /* Must remain stable */]);
        const remoteULEChildMounted = q$1((index, mounted) => {
            if (!hasRemoteULEChildMounted.current) {
                hasRemoteULEChildMounted.current = {
                    mounts: new Set(),
                    unmounts: new Set(),
                };
                debounceRendering(() => {
                    onChildrenMountChange?.(hasRemoteULEChildMounted.current.mounts, hasRemoteULEChildMounted.current.unmounts);
                    hasRemoteULEChildMounted.current = null;
                });
            }
            if (mounted) {
                managedChildrenArray.current.highestIndex = Math.max(managedChildrenArray.current.highestIndex, index);
            }
            else {
                if (typeof index == "number") {
                    delete managedChildrenArray.current.arr[index];
                    let shave = 0;
                    while (shave <= managedChildrenArray.current.arr.length && managedChildrenArray.current.arr[managedChildrenArray.current.arr.length - 1 - shave] === undefined) {
                        ++shave;
                    }
                    managedChildrenArray.current.arr.splice(managedChildrenArray.current.arr.length - shave, shave);
                }
                else
                    delete managedChildrenArray.current.rec[index];
            }
            hasRemoteULEChildMounted.current[mounted ? "mounts" : "unmounts"].add(index);
        }, [ /* Must remain stable */]);
        const useManagedChild = q$1((info) => {
            const { managedChild: { index, flags }, subInfo } = info;
            // Any time our child props change, make that information available
            // the parent if they need it.
            // The parent can listen for all updates and only act on the ones it cares about,
            // and multiple children updating in the same tick will all be sent at once.
            _(() => {
                // Insert this information in-place
                if (typeof index == "number") {
                    managedChildrenArray.current.arr[index] = { index, flags: flags ?? {}, subInfo };
                }
                else {
                    managedChildrenArray.current.rec[index] = { index, flags: flags ?? {}, subInfo };
                }
                return remoteULEChildChanged(index);
            }, [...Object.entries(info).flat(9)]); // 9 is infinity, right? Sure. Unrelated: TODO.
            // When we mount, notify the parent via queueMicrotask
            // (every child does this, so everything's coordinated to only queue a single microtask per tick)
            // Do the same on unmount.
            // Note: It's important that this comes AFTER remoteULEChildChanged
            // so that remoteULEChildMounted has access to all the info on mount.
            _(() => {
                remoteULEChildMounted?.(index, true);
                return () => remoteULEChildMounted?.(index, false);
            }, [index]);
        }, [ /* Must remain stable */]);
        const managedChildren = A({
            ...{ _: managedChildrenArray.current },
            forEach: forEachChild,
            getAt: getManagedChildInfo,
            getHighestIndex: getHighestIndex,
            arraySlice: () => {
                return managedChildrenArray.current.arr.slice();
            }
        });
        return {
            useManagedChild,
            managedChildren: { children: managedChildren.current }
        };
    }
    /**
     * An extension to useManagedChildren that handles the following common case:
     * 1. You have a bunch of children
     * 2. At any given time, only 1 of them is "selected", "activated", "focusable", whatever (or 0 of them, that's cool too, just 0 or 1 though).
     * 3. The parent has control over who is "selected" via a numerical index.
     *
     * This hook allows for much easier control over selection management.
     *
     * Note that because you may want to use multiple flags with the same children, this hook *does not* use `useManagedChildren`!
     * You need to pass it the existing children, and you must pass your invocation of `useManagedChildren` the returned `onChildrenMountChange` handler!
     *
     * Also because of that, the types of this function are rather odd.  It's better to start off using a hook that already uses a flag, such as `useRovingTabIndex`, as an example.
     *
     *
     * @param param0
     * @returns
     */
    function useChildrenFlag({ children, initialIndex, closestFit, onIndexChange, key }) {
        useEnsureStability("useChildrenFlag", onIndexChange, key);
        const [getCurrentIndex, setCurrentIndex] = usePassiveState(onIndexChange, q$1(() => (initialIndex ?? (null)), []));
        const [getRequestedIndex, setRequestedIndex] = usePassiveState(null, q$1(() => (initialIndex ?? (null)), []));
        //    const getFitNullToZero = useStableGetter(fitNullToZero);
        // Shared between onChildrenMountChange and changeIndex, not public (but could be I guess)
        const getClosestFit = q$1((requestedIndex) => {
            let closestDistance = Infinity;
            let closestIndex = null;
            children.forEach(child => {
                if (child.flags?.[key]?.isValid()) {
                    const newDistance = Math.abs(child.index - requestedIndex);
                    if (newDistance < closestDistance || (newDistance == closestDistance && child.index < requestedIndex)) {
                        closestDistance = newDistance;
                        closestIndex = child.index;
                    }
                }
            });
            return closestIndex;
        }, [ /* Must remain stable! */]);
        // Any time a child mounts/unmounts, we need to double-check to see if that affects 
        // the "currently selected" (or whatever) index.  The two cases we're looking for:
        // 1. The currently selected child unmounted
        // 2. A child mounted, and it mounts with the index we're looking for
        const reevaluateClosestFit = useStableCallback(() => {
            const requestedIndex = getRequestedIndex();
            const currentIndex = getCurrentIndex();
            const currentChild = currentIndex == null ? null : children.getAt(currentIndex);
            if (requestedIndex != null && closestFit && (requestedIndex != currentIndex || currentChild == null || !currentChild.flags?.[key]?.isValid())) {
                currentChild?.flags?.[key].set(false);
                const closestFitIndex = getClosestFit(requestedIndex);
                setCurrentIndex(closestFitIndex);
                if (closestFitIndex != null) {
                    const closestFitChild = children.getAt(closestFitIndex);
                    console.assert(closestFitChild != null, "Internal logic???");
                    closestFitChild.flags?.[key].set(true);
                }
            }
        });
        const changeIndex = q$1((arg) => {
            const requestedIndex = arg instanceof Function ? arg(getRequestedIndex()) : arg;
            //if (requestedIndex == null && getFitNullToZero())
            //    requestedIndex = 0;
            setRequestedIndex(requestedIndex);
            const currentIndex = getCurrentIndex();
            if (currentIndex == requestedIndex)
                return requestedIndex;
            let newMatchingChild = (requestedIndex == null ? null : children.getAt(requestedIndex));
            const oldMatchingChild = (currentIndex == null ? null : children.getAt(currentIndex));
            if (requestedIndex == null) {
                // Easy case
                setCurrentIndex(null);
                oldMatchingChild?.flags?.[key].set(false);
                return null;
            }
            else {
                if (newMatchingChild && newMatchingChild.flags?.[key].isValid()) {
                    setCurrentIndex(requestedIndex);
                    oldMatchingChild?.flags?.[key].set(false);
                    newMatchingChild.flags?.[key].set(true);
                    return requestedIndex;
                }
                else {
                    const closestFitIndex = getClosestFit(requestedIndex);
                    setCurrentIndex(closestFitIndex);
                    if (closestFitIndex != null) {
                        newMatchingChild = children.getAt(closestFitIndex);
                        console.assert(newMatchingChild != null, "Internal logic???");
                        oldMatchingChild?.flags?.[key].set(false);
                        newMatchingChild.flags?.[key].set(true);
                        return closestFitIndex;
                    }
                    else {
                        oldMatchingChild?.flags?.[key].set(false);
                        return null;
                    }
                }
            }
        }, []);
        _(() => {
            if (initialIndex != null)
                children.getAt(initialIndex)?.flags?.[key]?.set(true);
        }, []);
        return { changeIndex, reevaluateClosestFit, getCurrentIndex };
    }

    function r(e){var t,f,n="";if("string"==typeof e||"number"==typeof e)n+=e;else if("object"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=" "),n+=f);else for(t in e)e[t]&&(n&&(n+=" "),n+=t);return n}function clsx(){for(var e,t,f=0,n="";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=" "),n+=t);return n}

    function getDocument$2(element) { return (element?.ownerDocument ?? document ?? window.document ?? globalThis.document); }

    function useMergedChildren({ children: lhs }, { children: rhs }) {
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return h$1(p$1, {}, lhs, rhs);
        }
    }

    /**
     * Given two sets of props, merges their `class` and `className` properties.
     * Duplicate classes are removed (order doesn't matter anyway).
     *
     * @param lhs Classes of the first component
     * @param rhs Classes of the second component
     * @returns A string representing all combined classes from both arguments.
     */
    function useMergedClasses({ class: lhsClass, className: lhsClassName }, { class: rhsClass, className: rhsClassName }) {
        // Note: For the sake of forward compatibility, this function is labelled as
        // a hook, but as it uses no other hooks it technically isn't one.
        if (lhsClass || rhsClass || lhsClassName || rhsClassName) {
            const lhsClasses = clsx(lhsClass, lhsClassName).split(" ");
            const rhsClasses = clsx(rhsClass, rhsClassName).split(" ");
            const allClasses = new Set([...Array.from(lhsClasses), ...Array.from(rhsClasses)]);
            return Array.from(allClasses).join(" ");
        }
        else {
            return undefined;
        }
    }

    function processRef(instance, ref) {
        if (typeof ref === "function") {
            ref(instance);
        }
        else if (ref != null) {
            ref.current = instance;
        }
        else {
            /* eslint-disable no-debugger */
            debugger;
            console.assert(false, "Unknown ref type found that was neither a RefCallback nor a RefObject");
        }
    }
    /**
     * Combines two refs into one. This allows a component to both use its own ref *and* forward a ref that was given to it.
     * @param lhs
     * @param rhs
     * @returns
     */
    function useMergedRefs({ ref: rhs }, { ref: lhs }) {
        const combined = q$1((current) => {
            processRef(current, lhs);
            processRef(current, rhs);
        }, [lhs, rhs]);
        if (lhs == null && rhs == null) {
            return undefined;
        }
        else if (lhs == null) {
            return rhs;
        }
        else if (rhs == null) {
            return lhs;
        }
        else {
            return combined;
        }
    }

    function styleStringToObject(style) {
        // TODO: This sucks D:
        return Object.fromEntries(style.split(";").map(statement => statement.split(":")));
    }
    /**
     * Merges two style objects, returning the result.
     *
     * @param style The user-given style prop for this component
     * @param obj The CSS properties you want added to the user-given style
     * @returns A CSS object containing the properties of both objects.
     */
    function useMergedStyles(lhs, rhs) {
        // Easy case, when there are no styles to merge return nothing.
        if (!lhs?.style && !rhs?.style)
            return undefined;
        if (typeof lhs != typeof rhs) {
            // Easy cases, when one is null and the other isn't.
            if (lhs?.style && !rhs?.style)
                return lhs.style;
            if (!lhs?.style && rhs?.style)
                return rhs.style;
            // They're both non-null but different types.
            // Convert the string type to an object bag type and run it again.
            if (lhs?.style && rhs?.style) {
                // (useMergedStyles isn't a true hook -- this isn't a violation)
                if (typeof lhs?.style == "string")
                    return useMergedStyles({ style: styleStringToObject(lhs?.style) }, rhs);
                if (typeof rhs?.style == "string")
                    return useMergedStyles(lhs, { style: styleStringToObject(rhs?.style) });
            }
            // Logic???
            return undefined;
        }
        // They're both strings, just concatenate them.
        if (typeof lhs?.style == "string") {
            return `${lhs.style};${rhs?.style ?? ""}`;
        }
        // They're both objects, just merge them.
        return {
            ...(lhs?.style ?? {}),
            ...(rhs?.style ?? {})
        };
    }

    let log = console.warn;
    /**
     * Given two sets of props, merges them and returns the result.
     *
     * The hook is aware of and can intelligently merge `className`, `class`, `style`, `ref`, and all event handlers.
     * @param lhs2
     * @param rhs2
     * @returns
     */
    function useMergedProps(lhsAll, rhsAll) {
        // First, separate the props we were given into two groups:
        // lhsAll and rhsAll contain all the props we were given, and
        // lhsMisc and rhsMisc contain all props *except* for the easy ones
        // like className and style that we already know how to merge.
        const { children: _lhsChildren, class: _lhsClass, className: _lhsClassName, style: _lhsStyle, ref: _lhsRef, ...lhsMisc } = lhsAll;
        const { children: _rhsChildren, class: _rhsClass, className: _rhsClassName, style: _rhsStyle, ref: _rhsRef, ...rhsMisc } = rhsAll;
        const ret = {
            ...lhsMisc,
            ref: useMergedRefs(lhsAll, rhsAll),
            style: useMergedStyles(lhsAll, rhsAll),
            className: useMergedClasses(lhsAll, rhsAll),
            children: useMergedChildren(lhsAll, rhsAll),
        };
        if (ret.ref === undefined)
            delete ret.ref;
        if (ret.style === undefined)
            delete ret.style;
        if (ret.className === undefined)
            delete ret.className;
        if (ret.children === undefined)
            delete ret.children;
        // Now, do *everything* else
        // Merge every remaining existing entry in lhs with what we've already put in ret.
        //const lhsEntries = Object.entries(lhs) as [keyof T, T[keyof T]][];
        const rhsEntries = Object.entries(rhsMisc);
        for (const [rhsKeyU, rhsValue] of rhsEntries) {
            const rhsKey = rhsKeyU;
            const lhsValue = lhsMisc[rhsKey];
            if (typeof lhsValue === "function" || typeof rhsValue === "function") {
                // They're both functions that can be merged (or one's a function and the other's null).
                // Not an *easy* case, but a well-defined one.
                const merged = mergeFunctions(lhsValue, rhsValue);
                ret[rhsKey] = merged;
            }
            else {
                // Uh...we're here because one of them's null, right?
                if (lhsValue == null && rhsValue == null) {
                    if (rhsValue === null && lhsValue === undefined)
                        ret[rhsKey] = rhsValue;
                    else
                        ret[rhsKey] = lhsValue;
                }
                if (lhsValue == null)
                    ret[rhsKey] = rhsValue;
                else if (rhsValue == null)
                    ret[rhsKey] = lhsValue;
                else if (rhsValue == lhsValue) ;
                else {
                    // Ugh.
                    // No good strategies here, just log it if requested
                    log?.(`The prop "${rhsKey}" cannot simultaneously be the values ${lhsValue} and ${rhsValue}. One must be chosen outside of useMergedProps.`);
                    ret[rhsKey] = rhsValue;
                }
            }
        }
        return ret;
    }
    function mergeFunctions(lhs, rhs) {
        if (!lhs)
            return rhs;
        if (!rhs)
            return lhs;
        return (...args) => {
            const lv = lhs(...args);
            const rv = rhs(...args);
            if (lv instanceof Promise || rv instanceof Promise)
                return Promise.all([lv, rv]);
        };
    }
    /*
    function test<P extends h.JSX.HTMLAttributes<HTMLInputElement>>(props: P) {

        const id0: GenericGet<{}, "id", string> = "";
        const id3: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id4: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id5: GenericGet<{ id: undefined }, "id", string> = undefined;
        const id6: GenericGet<{ id: undefined }, "id", string> = undefined;
        //const id2: ZipSingle<string | undefined, string | undefined> = undefined;
        const id1: ZipObject<{ id: undefined }, { id: string }> = { id: undefined };

        type M1 = GenericGet<P, "style", string>;
        type M2 = GenericGet<{}, "style", string>;
        const m1: M1 = "";
        const m2: M1 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m3: M1 = 0;

        const m4: M2 = "";
        const m5: M2 = undefined;
        /// @ts-expect-error    Because number isn't assignable to string
        const m6: M2 = 0;

        const p1: MergedProps<HTMLInputElement, {}, { id: string }> = useMergedProps<HTMLInputElement>()({}, { id: "string" });
        const p2: MergedProps<HTMLInputElement, { id: undefined }, { id: string }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: "string" });
        const p3: MergedProps<HTMLInputElement, { id: undefined }, { id: undefined }> = useMergedProps<HTMLInputElement>()({ id: undefined }, { id: undefined });
        const p4: MergedProps<HTMLInputElement, {}, {}> = useMergedProps<HTMLInputElement>()({}, {});
        const p5 = useMergedProps<HTMLInputElement>()(props, {});
        const p6 = useMergedProps<HTMLInputElement>()(props, { id: undefined });
        const p7 = useMergedProps<HTMLInputElement>()(props, { id: "string" });


        p1.id?.concat("");
        p2.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p3.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        p4.id?.concat("");


        p5.id?.concat("");
        p6.id?.concat("");
        p7.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        p5.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p6.id.concat("");
        /// @ts-expect-error    id must contain undefined
        p7.id.concat("");


        if (p5.allowFullScreen === undefined) {}
        else if (p5.allowFullScreen === false) {}
        else if (p5.allowFullScreen === true) {}
        else {
            acceptsNever(p5.allowFullScreen);
        }


        if (p6.allowFullScreen === undefined) {}
        else if (p6.allowFullScreen === false) {}
        else if (p6.allowFullScreen === true) {}
        else {
            acceptsNever(p6.allowFullScreen);
        }


        if (p7.allowFullScreen === undefined) {}
        else if (p7.allowFullScreen === false) {}
        else if (p7.allowFullScreen === true) {}
        else {
            acceptsNever(p7.allowFullScreen);
        }


        // Make sure it works recursively
        const r1a = useMergedProps<HTMLInputElement>()({}, p1);
        const r1b = useMergedProps<HTMLInputElement>()(props, p1);
        const r2a = useMergedProps<HTMLInputElement>()({}, p2);
        const r2b = useMergedProps<HTMLInputElement>()(props, p2);
        const r3a = useMergedProps<HTMLInputElement>()({}, p3);
        const r3b = useMergedProps<HTMLInputElement>()(props, p3);
        const r4a = useMergedProps<HTMLInputElement>()({}, p4);
        const r4b = useMergedProps<HTMLInputElement>()(props, p4);
        const r5a = useMergedProps<HTMLInputElement>()({}, p5);
        const r5b = useMergedProps<HTMLInputElement>()(props, p5);
        const r6a = useMergedProps<HTMLInputElement>()({}, p6);
        const r6b = useMergedProps<HTMLInputElement>()(props, p6);
        const r7a = useMergedProps<HTMLInputElement>()({}, p7);
        const r7b = useMergedProps<HTMLInputElement>()(props, p7);


        r1a.id?.concat("");
        r1b.id?.concat("");
        r2a.id?.concat("");
        r2b.id?.concat("");
        // @ts-expect-error    id can't be anything but undefined
        r3a.id?.concat("");
        r3b.id?.concat("");
        /// @ts-expect-error    id can't be anything but undefined
        r4a.id?.concat("");
        r4b.id?.concat("");


        r5a.id?.concat("");
        r5b.id?.concat("");
        r6a.id?.concat("");
        r6b.id?.concat("");
        r7a.id?.concat("");
        r7b.id?.concat("");

        /// @ts-expect-error    id must contain undefined
        r5a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r5b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r6b.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7a.id.concat("");
        /// @ts-expect-error    id must contain undefined
        r7b.id.concat("");


        if (r5a.allowFullScreen === undefined) {}
        else if (r5a.allowFullScreen === false) {}
        else if (r5a.allowFullScreen === true) {}
        else {
            acceptsNever(r5a.allowFullScreen);
        }


        if (r5b.allowFullScreen === undefined) {}
        else if (r5b.allowFullScreen === false) {}
        else if (r5b.allowFullScreen === true) {}
        else {
            acceptsNever(r5b.allowFullScreen);
        }


        if (r6a.allowFullScreen === undefined) {}
        else if (r6a.allowFullScreen === false) {}
        else if (r6a.allowFullScreen === true) {}
        else {
            acceptsNever(r6a.allowFullScreen);
        }


        if (r6b.allowFullScreen === undefined) {}
        else if (r6b.allowFullScreen === false) {}
        else if (r6b.allowFullScreen === true) {}
        else {
            acceptsNever(r6b.allowFullScreen);
        }


        if (r7a.allowFullScreen === undefined) {}
        else if (r7a.allowFullScreen === false) {}
        else if (r7a.allowFullScreen === true) {}
        else {
            acceptsNever(r7a.allowFullScreen);
        }


        if (r7b.allowFullScreen === undefined) {}
        else if (r7b.allowFullScreen === false) {}
        else if (r7b.allowFullScreen === true) {}
        else {
            acceptsNever(r7b.allowFullScreen);
        }

    }
    function acceptsNever(n: never) {}
    */

    function useDraggable({ effectAllowed, data, dragImage, dragImageXOffset, dragImageYOffset }) {
        const [dragging, setDragging, getDragging] = useState(false);
        const [lastDropEffect, setLastDropEffect, getLastDropEffect] = useState(null);
        const useDraggableProps = q$1((p) => {
            const ref = A(null);
            const onDragStart = (e) => {
                //e.preventDefault();
                setDragging(true);
                if (e.dataTransfer) {
                    e.dataTransfer.effectAllowed = (effectAllowed ?? "all");
                    if (dragImage)
                        e.dataTransfer.setDragImage(dragImage, dragImageXOffset ?? 0, dragImageYOffset ?? 0);
                    const entries = Object.entries(data);
                    for (const [mimeType, data] of entries) {
                        e.dataTransfer.setData(mimeType, data);
                    }
                }
            };
            const onDragEnd = (e) => {
                e.preventDefault();
                setDragging(false);
                if (e.dataTransfer) {
                    if (e.dataTransfer.dropEffect != "none") {
                        setLastDropEffect(e.dataTransfer.dropEffect);
                    }
                    else {
                        setLastDropEffect(null);
                    }
                }
            };
            return useMergedProps({
                draggable: true,
                onDragStart,
                onDragEnd,
                ref
            }, p);
        }, [effectAllowed, dragImage, dragImageXOffset, dragImageYOffset, ...Object.entries(data).flat()]);
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        const ret = {
            useDraggableProps,
            dragging,
            getDragging,
            lastDropEffect,
            getLastDropEffect
        };
        return ret;
    }

    class DroppableFileError extends Error {
        fileName;
        errorType;
        constructor(fileName, base) {
            super(base?.message ?? "An unspecified error occurred reading the file.");
            this.fileName = fileName;
            this.errorType = base?.name;
        }
    }
    function useDroppable({ effect }) {
        const [filesForConsideration, setFilesForConsideration] = useState(null);
        const [stringsForConsideration, setStringsForConsideration] = useState(null);
        const [droppedFiles, setDroppedFiles] = useState(null);
        const [droppedStrings, setDroppedStrings] = useState(null);
        const [dropError, setDropError] = useState(undefined);
        // All the promises generated from the drop events.
        // Used to process multiple drop events in succession
        const dropPromisesRef = A([]);
        const [currentPromiseIndex, setCurrentPromiseIndex, getCurrentPromiseIndex] = useState(-1);
        const [promiseCount, setPromiseCount, getPromiseCount] = useState(0);
        // Any time we add a new promise, if there's no current promise running, we need to start one.
        // If there is one, then we don't need to do anything, since it runs the same check.
        s(() => {
            const currentPromiseIndex = getCurrentPromiseIndex();
            const promiseCount = getPromiseCount();
            if (promiseCount > 0) {
                if ((currentPromiseIndex + 1) < promiseCount) {
                    setCurrentPromiseIndex(i => ++i);
                }
            }
        }, [promiseCount]);
        // Anytime our current promise changes,
        // wait for it to finish, then set our state to its result.
        // Finally, check to see if there are anymore promises.
        // If there are, then increase currentPromiseCount,
        // which will trigger this again.
        //
        // This shouldn't happen *often*, but maybe in the case of
        // individually dropping a bunch of large files or something.
        s(() => {
            if (currentPromiseIndex >= 0) {
                const currentPromise = dropPromisesRef.current[currentPromiseIndex];
                currentPromise.then((info) => {
                    if (info !== null) {
                        const { files, strings } = info;
                        setDroppedFiles(files);
                        setDroppedStrings(strings);
                    }
                    // Now that we're done, are there more promises in the queue?
                    const currentPromiseIndex = getCurrentPromiseIndex();
                    const promiseCount = getPromiseCount();
                    if ((currentPromiseIndex + 1) < promiseCount) {
                        // Since this promise has started, more have been added.
                        // Run this effect again.
                        setCurrentPromiseIndex(i => ++i);
                    }
                });
            }
        }, [currentPromiseIndex]);
        const useDroppableProps = (p) => {
            //const ref = useRef<E>(null);
            // Handle collecting the current file metadata or MIME types.
            const onDragEnter = (e) => {
                e.preventDefault();
                if (e.dataTransfer) {
                    // Is there a default? I can't find one anywhere.
                    e.dataTransfer.dropEffect = (effect ?? "move");
                    const newMimeTypes = new Set();
                    const newFiles = new Array();
                    for (const item of e.dataTransfer?.items ?? []) {
                        const { kind, type } = item;
                        if (kind === "string") {
                            newMimeTypes.add(type);
                        }
                        else if (kind === "file") {
                            newFiles.push({ type: item.type });
                        }
                    }
                    setFilesForConsideration(newFiles);
                    setStringsForConsideration(newMimeTypes);
                }
            };
            // Handle resetting the current file metadata or MIME types
            const onDragLeave = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
            };
            // Boilerplate, I guess
            const onDragOver = (e) => {
                e.preventDefault();
            };
            // Handle getting the drop data asynchronously
            const onDrop = (e) => {
                e.preventDefault();
                setFilesForConsideration(null);
                setStringsForConsideration(null);
                const allPromises = new Array();
                const dropData = {};
                const dropFile = [];
                for (const item of e.dataTransfer?.items ?? []) {
                    const { kind, type } = item;
                    if (kind === "string") {
                        allPromises.push((new Promise((resolve, _reject) => item.getAsString(resolve))).then(str => dropData[type] = str));
                    }
                    else if (kind === "file") {
                        const file = item.getAsFile();
                        if (file) {
                            allPromises.push(new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = (_) => {
                                    resolve();
                                    const data = reader.result;
                                    dropFile.push({ data, name: file.name, type: file.type, size: data.byteLength, lastModified: file.lastModified });
                                };
                                reader.onerror = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.onabort = (_) => { reject(new DroppableFileError(file.name, reader.error)); };
                                reader.readAsArrayBuffer(file);
                            }));
                            dropFile.push();
                        }
                    }
                }
                dropPromisesRef.current.push(Promise.all(allPromises).then(() => {
                    setPromiseCount(i => ++i);
                    setDropError(null);
                    return {
                        strings: dropData,
                        files: dropFile
                    };
                }).catch(ex => {
                    /* eslint-disable no-debugger */
                    debugger;
                    setPromiseCount(i => ++i);
                    setDropError(ex);
                    return null;
                }));
            };
            return useMergedProps({ onDragEnter, onDragLeave, onDragOver, onDrop }, p);
        };
        return {
            useDroppableProps,
            filesForConsideration,
            stringsForConsideration,
            droppedFiles,
            droppedStrings,
            dropError
        };
    }

    /**
     * Allows accessing the element a ref references as soon as it does so.
     * *This hook itself returns a hook*--useRefElementProps modifies the props that you were going to pass to an HTMLElement,
     * adding a RefCallback and merging it with any existing ref that existed on the props.
     *
     * Don't forget to provide the Element as the type argument!
     *
     * @returns The element, and the sub-hook that makes it retrievable.
     */
    function useRefElement(args) {
        const { onElementChange, onMount, onUnmount } = (args ?? {});
        useEnsureStability("useRefElement", onElementChange, onMount, onUnmount);
        // Called (indirectly) by the ref that the element receives.
        const handler = q$1((e, prevValue) => {
            const cleanup = onElementChange?.(e, prevValue);
            if (prevValue)
                onUnmount?.(prevValue);
            if (e)
                onMount?.(e);
            return cleanup;
        }, []);
        // Let us store the actual (reference to) the element we capture
        const [getElement, setElement] = usePassiveState(handler, returnNull, runImmediately);
        const refElementProps = { ref: setElement };
        // Return both the element and the hook that modifies 
        // the props and allows us to actually find the element
        return {
            refElementProps,
            getElement
        };
    }
    function runImmediately(f) {
        f();
    }

    function useElementSize({ getObserveBox, onSizeChange }) {
        useEnsureStability("useElementSize", getObserveBox, onSizeChange);
        const [getSize, setSize] = usePassiveState(onSizeChange, returnNull);
        const currentObserveBox = A(undefined);
        const needANewObserver = q$1((element, observeBox) => {
            if (element) {
                const document = getDocument$2(element);
                const window = document.defaultView;
                const handleUpdate = () => {
                    if (element.isConnected) {
                        const { clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop } = element;
                        setSize({ clientWidth, scrollWidth, offsetWidth, clientHeight, scrollHeight, offsetHeight, clientLeft, scrollLeft, offsetLeft, clientTop, scrollTop, offsetTop });
                    }
                };
                if (window && ("ResizeObserver" in window)) {
                    const observer = new ResizeObserver((_entries) => { handleUpdate(); });
                    observer.observe(element, { box: observeBox });
                    return () => observer.disconnect();
                }
                else {
                    document.addEventListener("resize", handleUpdate, { passive: true });
                    return () => document.removeEventListener("resize", handleUpdate);
                }
            }
        }, []);
        const { getElement, refElementProps } = useRefElement({ onElementChange: q$1((e) => needANewObserver(e, getObserveBox?.()), []) });
        s(() => {
            if (getObserveBox) {
                if (currentObserveBox.current !== getObserveBox())
                    needANewObserver(getElement(), getObserveBox());
            }
        });
        return {
            getElement,
            getSize,
            useElementSizeProps: refElementProps
        };
    }

    /**
     * Allows attaching an event handler to any *non-Preact* element, and removing it when the component using the hook unmounts. The callback does not need to be stable across renders.
     *
     * Due to typing limitations, this function must be called like this:
     *
     * `useEventHandler(element, "input")<InputEvent>(e => {})`
     *
     * The type argument is optional, but narrows down the type from "a union of all events" to whatever you specify, and errors if it doesn't exist.
     *
     * There is a separate version that attaches event handlers to a set of props.
     * It takes different event string types (onEvent vs onevent).
     *
     * @param target A *non-Preact* node to attach the event to.
     * @returns
     * *
     */
    function useGlobalHandler(target, type, handler, options) {
        // Note to self: The typing doesn't improve even if this is split up into a sub-function.
        // No matter what, it seems impossible to get the handler's event object typed perfectly.
        // It seems like it's guaranteed to always be a union of all available tupes.
        // Again, no matter what combination of sub- or sub-sub-functions used.
        let stableHandler = useStableCallback(handler ?? (() => { }));
        if (handler == null)
            stableHandler = null;
        s(() => {
            if (stableHandler) {
                target.addEventListener(type, stableHandler, options);
                return () => target.removeEventListener(type, stableHandler, options);
            }
        }, [target, type, stableHandler]);
    }

    /*!
    * tabbable 6.0.0
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    */
    var candidateSelectors = ['input', 'select', 'textarea', 'a[href]', 'button', '[tabindex]:not(slot)', 'audio[controls]', 'video[controls]', '[contenteditable]:not([contenteditable="false"])', 'details>summary:first-of-type', 'details'];
    var NoElement = typeof Element === 'undefined';
    var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
    var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
      return element.getRootNode();
    } : function (element) {
      return element.ownerDocument;
    };

    var isInput = function isInput(node) {
      return node.tagName === 'INPUT';
    };

    var isHiddenInput = function isHiddenInput(node) {
      return isInput(node) && node.type === 'hidden';
    };

    var isDetailsWithSummary = function isDetailsWithSummary(node) {
      var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
        return child.tagName === 'SUMMARY';
      });
      return r;
    };


    var isNodeAttached = function isNodeAttached(node) {
      var _nodeRootHost;

      // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
      //  (but NOT _the_ document; see second 'If' comment below for more).
      // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
      //  is attached, and the one we need to check if it's in the document or not (because the
      //  shadow, and all nodes it contains, is never considered in the document since shadows
      //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
      //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
      //  visibility, including all the nodes it contains). The host could be any normal node,
      //  or a custom element (i.e. web component). Either way, that's the one that is considered
      //  part of the document, not the shadow root, nor any of its children (i.e. the node being
      //  tested).
      // To further complicate things, we have to look all the way up until we find a shadow HOST
      //  that is attached (or find none) because the node might be in nested shadows...
      // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
      //  document (per the docs) and while it's a Document-type object, that document does not
      //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
      //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
      //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
      //  node is actually detached.
      var nodeRootHost = getRootNode(node).host;
      var attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && _nodeRootHost.ownerDocument.contains(nodeRootHost) || node.ownerDocument.contains(node));

      while (!attached && nodeRootHost) {
        var _nodeRootHost2;

        // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
        //  which means we need to get the host's host and check if that parent host is contained
        //  in (i.e. attached to) the document
        nodeRootHost = getRootNode(nodeRootHost).host;
        attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && _nodeRootHost2.ownerDocument.contains(nodeRootHost));
      }

      return attached;
    };

    var isZeroArea = function isZeroArea(node) {
      var _node$getBoundingClie = node.getBoundingClientRect(),
          width = _node$getBoundingClie.width,
          height = _node$getBoundingClie.height;

      return width === 0 && height === 0;
    };

    var isHidden = function isHidden(node, _ref) {
      var displayCheck = _ref.displayCheck,
          getShadowRoot = _ref.getShadowRoot;

      // NOTE: visibility will be `undefined` if node is detached from the document
      //  (see notes about this further down), which means we will consider it visible
      //  (this is legacy behavior from a very long way back)
      // NOTE: we check this regardless of `displayCheck="none"` because this is a
      //  _visibility_ check, not a _display_ check
      if (getComputedStyle(node).visibility === 'hidden') {
        return true;
      }

      var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
      var nodeUnderDetails = isDirectSummary ? node.parentElement : node;

      if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
        return true;
      }

      if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
        if (typeof getShadowRoot === 'function') {
          // figure out if we should consider the node to be in an undisclosed shadow and use the
          //  'non-zero-area' fallback
          var originalNode = node;

          while (node) {
            var parentElement = node.parentElement;
            var rootNode = getRootNode(node);

            if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
            ) {
              // node has an undisclosed shadow which means we can only treat it as a black box, so we
              //  fall back to a non-zero-area test
              return isZeroArea(node);
            } else if (node.assignedSlot) {
              // iterate up slot
              node = node.assignedSlot;
            } else if (!parentElement && rootNode !== node.ownerDocument) {
              // cross shadow boundary
              node = rootNode.host;
            } else {
              // iterate up normal dom
              node = parentElement;
            }
          }

          node = originalNode;
        } // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
        //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
        //  it might be a falsy value, which means shadow DOM support is disabled
        // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
        //  now we can just test to see if it would normally be visible or not, provided it's
        //  attached to the main document.
        // NOTE: We must consider case where node is inside a shadow DOM and given directly to
        //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.


        if (isNodeAttached(node)) {
          // this works wherever the node is: if there's at least one client rect, it's
          //  somehow displayed; it also covers the CSS 'display: contents' case where the
          //  node itself is hidden in place of its contents; and there's no need to search
          //  up the hierarchy either
          return !node.getClientRects().length;
        } // Else, the node isn't attached to the document, which means the `getClientRects()`
        //  API will __always__ return zero rects (this can happen, for example, if React
        //  is used to render nodes onto a detached tree, as confirmed in this thread:
        //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
        //
        // It also means that even window.getComputedStyle(node).display will return `undefined`
        //  because styles are only computed for nodes that are in the document.
        //
        // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
        //  somehow. Though it was never stated officially, anyone who has ever used tabbable
        //  APIs on nodes in detached containers has actually implicitly used tabbable in what
        //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
        //  considering __everything__ to be visible because of the innability to determine styles.
        //
        // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
        //  nodes as visible with the 'none' fallback.__


        if (displayCheck !== 'legacy-full') {
          return true; // hidden
        } // else, fallback to 'none' mode and consider the node visible

      } else if (displayCheck === 'non-zero-area') {
        // NOTE: Even though this tests that the node's client rect is non-zero to determine
        //  whether it's displayed, and that a detached node will __always__ have a zero-area
        //  client rect, we don't special-case for whether the node is attached or not. In
        //  this mode, we do want to consider nodes that have a zero area to be hidden at all
        //  times, and that includes attached or not.
        return isZeroArea(node);
      } // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
      //  it's visible


      return false;
    }; // form fields (nested) inside a disabled fieldset are not focusable/tabbable
    //  unless they are in the _first_ <legend> element of the top-most disabled
    //  fieldset


    var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
      if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
        var parentNode = node.parentElement; // check if `node` is contained in a disabled <fieldset>

        while (parentNode) {
          if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
            // look for the first <legend> among the children of the disabled <fieldset>
            for (var i = 0; i < parentNode.children.length; i++) {
              var child = parentNode.children.item(i); // when the first <legend> (in document order) is found

              if (child.tagName === 'LEGEND') {
                // if its parent <fieldset> is not nested in another disabled <fieldset>,
                // return whether `node` is a descendant of its first <legend>
                return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
              }
            } // the disabled <fieldset> containing `node` has no <legend>


            return true;
          }

          parentNode = parentNode.parentElement;
        }
      } // else, node's tabbable/focusable state should not be affected by a fieldset's
      //  enabled/disabled state


      return false;
    };

    var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
      if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
      isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
        return false;
      }

      return true;
    };

    var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');

    var isFocusable = function isFocusable(node, options) {
      options = options || {};

      if (!node) {
        throw new Error('No node provided');
      }

      if (matches.call(node, focusableCandidateSelector) === false) {
        return false;
      }

      return isNodeMatchingSelectorFocusable(options, node);
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    (function (module, exports) {
    	(function (global, factory) {
    	  factory() ;
    	}(commonjsGlobal, (function () {
    	  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

    	  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

    	  /**
    	   * This work is licensed under the W3C Software and Document License
    	   * (http://www.w3.org/Consortium/Legal/2015/copyright-software-and-document).
    	   */

    	  (function () {
    	    // Return early if we're not running inside of the browser.
    	    if (typeof window === 'undefined') {
    	      return;
    	    }

    	    // Convenience function for converting NodeLists.
    	    /** @type {typeof Array.prototype.slice} */
    	    var slice = Array.prototype.slice;

    	    /**
    	     * IE has a non-standard name for "matches".
    	     * @type {typeof Element.prototype.matches}
    	     */
    	    var matches = Element.prototype.matches || Element.prototype.msMatchesSelector;

    	    /** @type {string} */
    	    var _focusableElementsString = ['a[href]', 'area[href]', 'input:not([disabled])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'details', 'summary', 'iframe', 'object', 'embed', '[contenteditable]'].join(',');

    	    /**
    	     * `InertRoot` manages a single inert subtree, i.e. a DOM subtree whose root element has an `inert`
    	     * attribute.
    	     *
    	     * Its main functions are:
    	     *
    	     * - to create and maintain a set of managed `InertNode`s, including when mutations occur in the
    	     *   subtree. The `makeSubtreeUnfocusable()` method handles collecting `InertNode`s via registering
    	     *   each focusable node in the subtree with the singleton `InertManager` which manages all known
    	     *   focusable nodes within inert subtrees. `InertManager` ensures that a single `InertNode`
    	     *   instance exists for each focusable node which has at least one inert root as an ancestor.
    	     *
    	     * - to notify all managed `InertNode`s when this subtree stops being inert (i.e. when the `inert`
    	     *   attribute is removed from the root node). This is handled in the destructor, which calls the
    	     *   `deregister` method on `InertManager` for each managed inert node.
    	     */

    	    var InertRoot = function () {
    	      /**
    	       * @param {!HTMLElement} rootElement The HTMLElement at the root of the inert subtree.
    	       * @param {!InertManager} inertManager The global singleton InertManager object.
    	       */
    	      function InertRoot(rootElement, inertManager) {
    	        _classCallCheck(this, InertRoot);

    	        /** @type {!InertManager} */
    	        this._inertManager = inertManager;

    	        /** @type {!HTMLElement} */
    	        this._rootElement = rootElement;

    	        /**
    	         * @type {!Set<!InertNode>}
    	         * All managed focusable nodes in this InertRoot's subtree.
    	         */
    	        this._managedNodes = new Set();

    	        // Make the subtree hidden from assistive technology
    	        if (this._rootElement.hasAttribute('aria-hidden')) {
    	          /** @type {?string} */
    	          this._savedAriaHidden = this._rootElement.getAttribute('aria-hidden');
    	        } else {
    	          this._savedAriaHidden = null;
    	        }
    	        this._rootElement.setAttribute('aria-hidden', 'true');

    	        // Make all focusable elements in the subtree unfocusable and add them to _managedNodes
    	        this._makeSubtreeUnfocusable(this._rootElement);

    	        // Watch for:
    	        // - any additions in the subtree: make them unfocusable too
    	        // - any removals from the subtree: remove them from this inert root's managed nodes
    	        // - attribute changes: if `tabindex` is added, or removed from an intrinsically focusable
    	        //   element, make that node a managed node.
    	        this._observer = new MutationObserver(this._onMutation.bind(this));
    	        this._observer.observe(this._rootElement, { attributes: true, childList: true, subtree: true });
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.  This unwinds all of the state
    	       * stored in this object and updates the state of all of the managed nodes.
    	       */


    	      _createClass(InertRoot, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._observer.disconnect();

    	          if (this._rootElement) {
    	            if (this._savedAriaHidden !== null) {
    	              this._rootElement.setAttribute('aria-hidden', this._savedAriaHidden);
    	            } else {
    	              this._rootElement.removeAttribute('aria-hidden');
    	            }
    	          }

    	          this._managedNodes.forEach(function (inertNode) {
    	            this._unmanageNode(inertNode.node);
    	          }, this);

    	          // Note we cast the nulls to the ANY type here because:
    	          // 1) We want the class properties to be declared as non-null, or else we
    	          //    need even more casts throughout this code. All bets are off if an
    	          //    instance has been destroyed and a method is called.
    	          // 2) We don't want to cast "this", because we want type-aware optimizations
    	          //    to know which properties we're setting.
    	          this._observer = /** @type {?} */null;
    	          this._rootElement = /** @type {?} */null;
    	          this._managedNodes = /** @type {?} */null;
    	          this._inertManager = /** @type {?} */null;
    	        }

    	        /**
    	         * @return {!Set<!InertNode>} A copy of this InertRoot's managed nodes set.
    	         */

    	      }, {
    	        key: '_makeSubtreeUnfocusable',


    	        /**
    	         * @param {!Node} startNode
    	         */
    	        value: function _makeSubtreeUnfocusable(startNode) {
    	          var _this2 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this2._visitNode(node);
    	          });

    	          var activeElement = document.activeElement;

    	          if (!document.body.contains(startNode)) {
    	            // startNode may be in shadow DOM, so find its nearest shadowRoot to get the activeElement.
    	            var node = startNode;
    	            /** @type {!ShadowRoot|undefined} */
    	            var root = undefined;
    	            while (node) {
    	              if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    	                root = /** @type {!ShadowRoot} */node;
    	                break;
    	              }
    	              node = node.parentNode;
    	            }
    	            if (root) {
    	              activeElement = root.activeElement;
    	            }
    	          }
    	          if (startNode.contains(activeElement)) {
    	            activeElement.blur();
    	            // In IE11, if an element is already focused, and then set to tabindex=-1
    	            // calling blur() will not actually move the focus.
    	            // To work around this we call focus() on the body instead.
    	            if (activeElement === document.activeElement) {
    	              document.body.focus();
    	            }
    	          }
    	        }

    	        /**
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_visitNode',
    	        value: function _visitNode(node) {
    	          if (node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */node;

    	          // If a descendant inert root becomes un-inert, its descendants will still be inert because of
    	          // this inert root, so all of its managed nodes need to be adopted by this InertRoot.
    	          if (element !== this._rootElement && element.hasAttribute('inert')) {
    	            this._adoptInertRoot(element);
    	          }

    	          if (matches.call(element, _focusableElementsString) || element.hasAttribute('tabindex')) {
    	            this._manageNode(element);
    	          }
    	        }

    	        /**
    	         * Register the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_manageNode',
    	        value: function _manageNode(node) {
    	          var inertNode = this._inertManager.register(node, this);
    	          this._managedNodes.add(inertNode);
    	        }

    	        /**
    	         * Unregister the given node with this InertRoot and with InertManager.
    	         * @param {!Node} node
    	         */

    	      }, {
    	        key: '_unmanageNode',
    	        value: function _unmanageNode(node) {
    	          var inertNode = this._inertManager.deregister(node, this);
    	          if (inertNode) {
    	            this._managedNodes['delete'](inertNode);
    	          }
    	        }

    	        /**
    	         * Unregister the entire subtree starting at `startNode`.
    	         * @param {!Node} startNode
    	         */

    	      }, {
    	        key: '_unmanageSubtree',
    	        value: function _unmanageSubtree(startNode) {
    	          var _this3 = this;

    	          composedTreeWalk(startNode, function (node) {
    	            return _this3._unmanageNode(node);
    	          });
    	        }

    	        /**
    	         * If a descendant node is found with an `inert` attribute, adopt its managed nodes.
    	         * @param {!HTMLElement} node
    	         */

    	      }, {
    	        key: '_adoptInertRoot',
    	        value: function _adoptInertRoot(node) {
    	          var inertSubroot = this._inertManager.getInertRoot(node);

    	          // During initialisation this inert root may not have been registered yet,
    	          // so register it now if need be.
    	          if (!inertSubroot) {
    	            this._inertManager.setInert(node, true);
    	            inertSubroot = this._inertManager.getInertRoot(node);
    	          }

    	          inertSubroot.managedNodes.forEach(function (savedInertNode) {
    	            this._manageNode(savedInertNode.node);
    	          }, this);
    	        }

    	        /**
    	         * Callback used when mutation observer detects subtree additions, removals, or attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_onMutation',
    	        value: function _onMutation(records, self) {
    	          records.forEach(function (record) {
    	            var target = /** @type {!HTMLElement} */record.target;
    	            if (record.type === 'childList') {
    	              // Manage added nodes
    	              slice.call(record.addedNodes).forEach(function (node) {
    	                this._makeSubtreeUnfocusable(node);
    	              }, this);

    	              // Un-manage removed nodes
    	              slice.call(record.removedNodes).forEach(function (node) {
    	                this._unmanageSubtree(node);
    	              }, this);
    	            } else if (record.type === 'attributes') {
    	              if (record.attributeName === 'tabindex') {
    	                // Re-initialise inert node if tabindex changes
    	                this._manageNode(target);
    	              } else if (target !== this._rootElement && record.attributeName === 'inert' && target.hasAttribute('inert')) {
    	                // If a new inert root is added, adopt its managed nodes and make sure it knows about the
    	                // already managed nodes from this inert subroot.
    	                this._adoptInertRoot(target);
    	                var inertSubroot = this._inertManager.getInertRoot(target);
    	                this._managedNodes.forEach(function (managedNode) {
    	                  if (target.contains(managedNode.node)) {
    	                    inertSubroot._manageNode(managedNode.node);
    	                  }
    	                });
    	              }
    	            }
    	          }, this);
    	        }
    	      }, {
    	        key: 'managedNodes',
    	        get: function get() {
    	          return new Set(this._managedNodes);
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'hasSavedAriaHidden',
    	        get: function get() {
    	          return this._savedAriaHidden !== null;
    	        }

    	        /** @param {?string} ariaHidden */

    	      }, {
    	        key: 'savedAriaHidden',
    	        set: function set(ariaHidden) {
    	          this._savedAriaHidden = ariaHidden;
    	        }

    	        /** @return {?string} */
    	        ,
    	        get: function get() {
    	          return this._savedAriaHidden;
    	        }
    	      }]);

    	      return InertRoot;
    	    }();

    	    /**
    	     * `InertNode` initialises and manages a single inert node.
    	     * A node is inert if it is a descendant of one or more inert root elements.
    	     *
    	     * On construction, `InertNode` saves the existing `tabindex` value for the node, if any, and
    	     * either removes the `tabindex` attribute or sets it to `-1`, depending on whether the element
    	     * is intrinsically focusable or not.
    	     *
    	     * `InertNode` maintains a set of `InertRoot`s which are descendants of this `InertNode`. When an
    	     * `InertRoot` is destroyed, and calls `InertManager.deregister()`, the `InertManager` notifies the
    	     * `InertNode` via `removeInertRoot()`, which in turn destroys the `InertNode` if no `InertRoot`s
    	     * remain in the set. On destruction, `InertNode` reinstates the stored `tabindex` if one exists,
    	     * or removes the `tabindex` attribute if the element is intrinsically focusable.
    	     */


    	    var InertNode = function () {
    	      /**
    	       * @param {!Node} node A focusable element to be made inert.
    	       * @param {!InertRoot} inertRoot The inert root element associated with this inert node.
    	       */
    	      function InertNode(node, inertRoot) {
    	        _classCallCheck(this, InertNode);

    	        /** @type {!Node} */
    	        this._node = node;

    	        /** @type {boolean} */
    	        this._overrodeFocusMethod = false;

    	        /**
    	         * @type {!Set<!InertRoot>} The set of descendant inert roots.
    	         *    If and only if this set becomes empty, this node is no longer inert.
    	         */
    	        this._inertRoots = new Set([inertRoot]);

    	        /** @type {?number} */
    	        this._savedTabIndex = null;

    	        /** @type {boolean} */
    	        this._destroyed = false;

    	        // Save any prior tabindex info and make this node untabbable
    	        this.ensureUntabbable();
    	      }

    	      /**
    	       * Call this whenever this object is about to become obsolete.
    	       * This makes the managed node focusable again and deletes all of the previously stored state.
    	       */


    	      _createClass(InertNode, [{
    	        key: 'destructor',
    	        value: function destructor() {
    	          this._throwIfDestroyed();

    	          if (this._node && this._node.nodeType === Node.ELEMENT_NODE) {
    	            var element = /** @type {!HTMLElement} */this._node;
    	            if (this._savedTabIndex !== null) {
    	              element.setAttribute('tabindex', this._savedTabIndex);
    	            } else {
    	              element.removeAttribute('tabindex');
    	            }

    	            // Use `delete` to restore native focus method.
    	            if (this._overrodeFocusMethod) {
    	              delete element.focus;
    	            }
    	          }

    	          // See note in InertRoot.destructor for why we cast these nulls to ANY.
    	          this._node = /** @type {?} */null;
    	          this._inertRoots = /** @type {?} */null;
    	          this._destroyed = true;
    	        }

    	        /**
    	         * @type {boolean} Whether this object is obsolete because the managed node is no longer inert.
    	         * If the object has been destroyed, any attempt to access it will cause an exception.
    	         */

    	      }, {
    	        key: '_throwIfDestroyed',


    	        /**
    	         * Throw if user tries to access destroyed InertNode.
    	         */
    	        value: function _throwIfDestroyed() {
    	          if (this.destroyed) {
    	            throw new Error('Trying to access destroyed InertNode');
    	          }
    	        }

    	        /** @return {boolean} */

    	      }, {
    	        key: 'ensureUntabbable',


    	        /** Save the existing tabindex value and make the node untabbable and unfocusable */
    	        value: function ensureUntabbable() {
    	          if (this.node.nodeType !== Node.ELEMENT_NODE) {
    	            return;
    	          }
    	          var element = /** @type {!HTMLElement} */this.node;
    	          if (matches.call(element, _focusableElementsString)) {
    	            if ( /** @type {!HTMLElement} */element.tabIndex === -1 && this.hasSavedTabIndex) {
    	              return;
    	            }

    	            if (element.hasAttribute('tabindex')) {
    	              this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            }
    	            element.setAttribute('tabindex', '-1');
    	            if (element.nodeType === Node.ELEMENT_NODE) {
    	              element.focus = function () {};
    	              this._overrodeFocusMethod = true;
    	            }
    	          } else if (element.hasAttribute('tabindex')) {
    	            this._savedTabIndex = /** @type {!HTMLElement} */element.tabIndex;
    	            element.removeAttribute('tabindex');
    	          }
    	        }

    	        /**
    	         * Add another inert root to this inert node's set of managing inert roots.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'addInertRoot',
    	        value: function addInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots.add(inertRoot);
    	        }

    	        /**
    	         * Remove the given inert root from this inert node's set of managing inert roots.
    	         * If the set of managing inert roots becomes empty, this node is no longer inert,
    	         * so the object should be destroyed.
    	         * @param {!InertRoot} inertRoot
    	         */

    	      }, {
    	        key: 'removeInertRoot',
    	        value: function removeInertRoot(inertRoot) {
    	          this._throwIfDestroyed();
    	          this._inertRoots['delete'](inertRoot);
    	          if (this._inertRoots.size === 0) {
    	            this.destructor();
    	          }
    	        }
    	      }, {
    	        key: 'destroyed',
    	        get: function get() {
    	          return (/** @type {!InertNode} */this._destroyed
    	          );
    	        }
    	      }, {
    	        key: 'hasSavedTabIndex',
    	        get: function get() {
    	          return this._savedTabIndex !== null;
    	        }

    	        /** @return {!Node} */

    	      }, {
    	        key: 'node',
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._node;
    	        }

    	        /** @param {?number} tabIndex */

    	      }, {
    	        key: 'savedTabIndex',
    	        set: function set(tabIndex) {
    	          this._throwIfDestroyed();
    	          this._savedTabIndex = tabIndex;
    	        }

    	        /** @return {?number} */
    	        ,
    	        get: function get() {
    	          this._throwIfDestroyed();
    	          return this._savedTabIndex;
    	        }
    	      }]);

    	      return InertNode;
    	    }();

    	    /**
    	     * InertManager is a per-document singleton object which manages all inert roots and nodes.
    	     *
    	     * When an element becomes an inert root by having an `inert` attribute set and/or its `inert`
    	     * property set to `true`, the `setInert` method creates an `InertRoot` object for the element.
    	     * The `InertRoot` in turn registers itself as managing all of the element's focusable descendant
    	     * nodes via the `register()` method. The `InertManager` ensures that a single `InertNode` instance
    	     * is created for each such node, via the `_managedNodes` map.
    	     */


    	    var InertManager = function () {
    	      /**
    	       * @param {!Document} document
    	       */
    	      function InertManager(document) {
    	        _classCallCheck(this, InertManager);

    	        if (!document) {
    	          throw new Error('Missing required argument; InertManager needs to wrap a document.');
    	        }

    	        /** @type {!Document} */
    	        this._document = document;

    	        /**
    	         * All managed nodes known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertNode>}
    	         */
    	        this._managedNodes = new Map();

    	        /**
    	         * All inert roots known to this InertManager. In a map to allow looking up by Node.
    	         * @type {!Map<!Node, !InertRoot>}
    	         */
    	        this._inertRoots = new Map();

    	        /**
    	         * Observer for mutations on `document.body`.
    	         * @type {!MutationObserver}
    	         */
    	        this._observer = new MutationObserver(this._watchForInert.bind(this));

    	        // Add inert style.
    	        addInertStyle(document.head || document.body || document.documentElement);

    	        // Wait for document to be loaded.
    	        if (document.readyState === 'loading') {
    	          document.addEventListener('DOMContentLoaded', this._onDocumentLoaded.bind(this));
    	        } else {
    	          this._onDocumentLoaded();
    	        }
    	      }

    	      /**
    	       * Set whether the given element should be an inert root or not.
    	       * @param {!HTMLElement} root
    	       * @param {boolean} inert
    	       */


    	      _createClass(InertManager, [{
    	        key: 'setInert',
    	        value: function setInert(root, inert) {
    	          if (inert) {
    	            if (this._inertRoots.has(root)) {
    	              // element is already inert
    	              return;
    	            }

    	            var inertRoot = new InertRoot(root, this);
    	            root.setAttribute('inert', '');
    	            this._inertRoots.set(root, inertRoot);
    	            // If not contained in the document, it must be in a shadowRoot.
    	            // Ensure inert styles are added there.
    	            if (!this._document.body.contains(root)) {
    	              var parent = root.parentNode;
    	              while (parent) {
    	                if (parent.nodeType === 11) {
    	                  addInertStyle(parent);
    	                }
    	                parent = parent.parentNode;
    	              }
    	            }
    	          } else {
    	            if (!this._inertRoots.has(root)) {
    	              // element is already non-inert
    	              return;
    	            }

    	            var _inertRoot = this._inertRoots.get(root);
    	            _inertRoot.destructor();
    	            this._inertRoots['delete'](root);
    	            root.removeAttribute('inert');
    	          }
    	        }

    	        /**
    	         * Get the InertRoot object corresponding to the given inert root element, if any.
    	         * @param {!Node} element
    	         * @return {!InertRoot|undefined}
    	         */

    	      }, {
    	        key: 'getInertRoot',
    	        value: function getInertRoot(element) {
    	          return this._inertRoots.get(element);
    	        }

    	        /**
    	         * Register the given InertRoot as managing the given node.
    	         * In the case where the node has a previously existing inert root, this inert root will
    	         * be added to its set of inert roots.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {!InertNode} inertNode
    	         */

    	      }, {
    	        key: 'register',
    	        value: function register(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (inertNode !== undefined) {
    	            // node was already in an inert subtree
    	            inertNode.addInertRoot(inertRoot);
    	          } else {
    	            inertNode = new InertNode(node, inertRoot);
    	          }

    	          this._managedNodes.set(node, inertNode);

    	          return inertNode;
    	        }

    	        /**
    	         * De-register the given InertRoot as managing the given inert node.
    	         * Removes the inert root from the InertNode's set of managing inert roots, and remove the inert
    	         * node from the InertManager's set of managed nodes if it is destroyed.
    	         * If the node is not currently managed, this is essentially a no-op.
    	         * @param {!Node} node
    	         * @param {!InertRoot} inertRoot
    	         * @return {?InertNode} The potentially destroyed InertNode associated with this node, if any.
    	         */

    	      }, {
    	        key: 'deregister',
    	        value: function deregister(node, inertRoot) {
    	          var inertNode = this._managedNodes.get(node);
    	          if (!inertNode) {
    	            return null;
    	          }

    	          inertNode.removeInertRoot(inertRoot);
    	          if (inertNode.destroyed) {
    	            this._managedNodes['delete'](node);
    	          }

    	          return inertNode;
    	        }

    	        /**
    	         * Callback used when document has finished loading.
    	         */

    	      }, {
    	        key: '_onDocumentLoaded',
    	        value: function _onDocumentLoaded() {
    	          // Find all inert roots in document and make them actually inert.
    	          var inertElements = slice.call(this._document.querySelectorAll('[inert]'));
    	          inertElements.forEach(function (inertElement) {
    	            this.setInert(inertElement, true);
    	          }, this);

    	          // Comment this out to use programmatic API only.
    	          this._observer.observe(this._document.body || this._document.documentElement, { attributes: true, subtree: true, childList: true });
    	        }

    	        /**
    	         * Callback used when mutation observer detects attribute changes.
    	         * @param {!Array<!MutationRecord>} records
    	         * @param {!MutationObserver} self
    	         */

    	      }, {
    	        key: '_watchForInert',
    	        value: function _watchForInert(records, self) {
    	          var _this = this;
    	          records.forEach(function (record) {
    	            switch (record.type) {
    	              case 'childList':
    	                slice.call(record.addedNodes).forEach(function (node) {
    	                  if (node.nodeType !== Node.ELEMENT_NODE) {
    	                    return;
    	                  }
    	                  var inertElements = slice.call(node.querySelectorAll('[inert]'));
    	                  if (matches.call(node, '[inert]')) {
    	                    inertElements.unshift(node);
    	                  }
    	                  inertElements.forEach(function (inertElement) {
    	                    this.setInert(inertElement, true);
    	                  }, _this);
    	                }, _this);
    	                break;
    	              case 'attributes':
    	                if (record.attributeName !== 'inert') {
    	                  return;
    	                }
    	                var target = /** @type {!HTMLElement} */record.target;
    	                var inert = target.hasAttribute('inert');
    	                _this.setInert(target, inert);
    	                break;
    	            }
    	          }, this);
    	        }
    	      }]);

    	      return InertManager;
    	    }();

    	    /**
    	     * Recursively walk the composed tree from |node|.
    	     * @param {!Node} node
    	     * @param {(function (!HTMLElement))=} callback Callback to be called for each element traversed,
    	     *     before descending into child nodes.
    	     * @param {?ShadowRoot=} shadowRootAncestor The nearest ShadowRoot ancestor, if any.
    	     */


    	    function composedTreeWalk(node, callback, shadowRootAncestor) {
    	      if (node.nodeType == Node.ELEMENT_NODE) {
    	        var element = /** @type {!HTMLElement} */node;
    	        if (callback) {
    	          callback(element);
    	        }

    	        // Descend into node:
    	        // If it has a ShadowRoot, ignore all child elements - these will be picked
    	        // up by the <content> or <shadow> elements. Descend straight into the
    	        // ShadowRoot.
    	        var shadowRoot = /** @type {!HTMLElement} */element.shadowRoot;
    	        if (shadowRoot) {
    	          composedTreeWalk(shadowRoot, callback);
    	          return;
    	        }

    	        // If it is a <content> element, descend into distributed elements - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'content') {
    	          var content = /** @type {!HTMLContentElement} */element;
    	          // Verifies if ShadowDom v0 is supported.
    	          var distributedNodes = content.getDistributedNodes ? content.getDistributedNodes() : [];
    	          for (var i = 0; i < distributedNodes.length; i++) {
    	            composedTreeWalk(distributedNodes[i], callback);
    	          }
    	          return;
    	        }

    	        // If it is a <slot> element, descend into assigned nodes - these
    	        // are elements from outside the shadow root which are rendered inside the
    	        // shadow DOM.
    	        if (element.localName == 'slot') {
    	          var slot = /** @type {!HTMLSlotElement} */element;
    	          // Verify if ShadowDom v1 is supported.
    	          var _distributedNodes = slot.assignedNodes ? slot.assignedNodes({ flatten: true }) : [];
    	          for (var _i = 0; _i < _distributedNodes.length; _i++) {
    	            composedTreeWalk(_distributedNodes[_i], callback);
    	          }
    	          return;
    	        }
    	      }

    	      // If it is neither the parent of a ShadowRoot, a <content> element, a <slot>
    	      // element, nor a <shadow> element recurse normally.
    	      var child = node.firstChild;
    	      while (child != null) {
    	        composedTreeWalk(child, callback);
    	        child = child.nextSibling;
    	      }
    	    }

    	    /**
    	     * Adds a style element to the node containing the inert specific styles
    	     * @param {!Node} node
    	     */
    	    function addInertStyle(node) {
    	      if (node.querySelector('style#inert-style, link#inert-style')) {
    	        return;
    	      }
    	      var style = document.createElement('style');
    	      style.setAttribute('id', 'inert-style');
    	      style.textContent = '\n' + '[inert] {\n' + '  pointer-events: none;\n' + '  cursor: default;\n' + '}\n' + '\n' + '[inert], [inert] * {\n' + '  -webkit-user-select: none;\n' + '  -moz-user-select: none;\n' + '  -ms-user-select: none;\n' + '  user-select: none;\n' + '}\n';
    	      node.appendChild(style);
    	    }

    	    if (!HTMLElement.prototype.hasOwnProperty('inert')) {
    	      /** @type {!InertManager} */
    	      var inertManager = new InertManager(document);

    	      Object.defineProperty(HTMLElement.prototype, 'inert', {
    	        enumerable: true,
    	        /** @this {!HTMLElement} */
    	        get: function get() {
    	          return this.hasAttribute('inert');
    	        },
    	        /** @this {!HTMLElement} */
    	        set: function set(inert) {
    	          inertManager.setInert(this, inert);
    	        }
    	      });
    	    }
    	  })();

    	})));
    } ());

    /**
     * @license
     * Copyright 2016 Google Inc. All rights reserved.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    (() => {
        var _a, _b, _c;
        /* Symbols for private properties */
        const _blockingElements = Symbol();
        const _alreadyInertElements = Symbol();
        const _topElParents = Symbol();
        const _siblingsToRestore = Symbol();
        const _parentMO = Symbol();
        /* Symbols for private static methods */
        const _topChanged = Symbol();
        const _swapInertedSibling = Symbol();
        const _inertSiblings = Symbol();
        const _restoreInertedSiblings = Symbol();
        const _getParents = Symbol();
        const _getDistributedChildren = Symbol();
        const _isInertable = Symbol();
        const _handleMutations = Symbol();
        class BlockingElementsImpl {
            constructor() {
                /**
                 * The blocking elements.
                 */
                this[_a] = [];
                /**
                 * Used to keep track of the parents of the top element, from the element
                 * itself up to body. When top changes, the old top might have been removed
                 * from the document, so we need to memoize the inerted parents' siblings
                 * in order to restore their inerteness when top changes.
                 */
                this[_b] = [];
                /**
                 * Elements that are already inert before the first blocking element is
                 * pushed.
                 */
                this[_c] = new Set();
            }
            destructor() {
                // Restore original inertness.
                this[_restoreInertedSiblings](this[_topElParents]);
                // Note we don't want to make these properties nullable on the class,
                // since then we'd need non-null casts in many places. Calling a method on
                // a BlockingElements instance after calling destructor will result in an
                // exception.
                const nullable = this;
                nullable[_blockingElements] = null;
                nullable[_topElParents] = null;
                nullable[_alreadyInertElements] = null;
            }
            get top() {
                const elems = this[_blockingElements];
                return elems[elems.length - 1] || null;
            }
            push(element) {
                if (!element || element === this.top) {
                    return;
                }
                // Remove it from the stack, we'll bring it to the top.
                this.remove(element);
                this[_topChanged](element);
                this[_blockingElements].push(element);
            }
            remove(element) {
                const i = this[_blockingElements].indexOf(element);
                if (i === -1) {
                    return false;
                }
                this[_blockingElements].splice(i, 1);
                // Top changed only if the removed element was the top element.
                if (i === this[_blockingElements].length) {
                    this[_topChanged](this.top);
                }
                return true;
            }
            pop() {
                const top = this.top;
                top && this.remove(top);
                return top;
            }
            has(element) {
                return this[_blockingElements].indexOf(element) !== -1;
            }
            /**
             * Sets `inert` to all document elements except the new top element, its
             * parents, and its distributed content.
             */
            [(_a = _blockingElements, _b = _topElParents, _c = _alreadyInertElements, _topChanged)](newTop) {
                const toKeepInert = this[_alreadyInertElements];
                const oldParents = this[_topElParents];
                // No new top, reset old top if any.
                if (!newTop) {
                    this[_restoreInertedSiblings](oldParents);
                    toKeepInert.clear();
                    this[_topElParents] = [];
                    return;
                }
                const newParents = this[_getParents](newTop);
                // New top is not contained in the main document!
                if (newParents[newParents.length - 1].parentNode !== document.body) {
                    throw Error('Non-connected element cannot be a blocking element');
                }
                // Cast here because we know we'll call _inertSiblings on newParents
                // below.
                this[_topElParents] = newParents;
                const toSkip = this[_getDistributedChildren](newTop);
                // No previous top element.
                if (!oldParents.length) {
                    this[_inertSiblings](newParents, toSkip, toKeepInert);
                    return;
                }
                let i = oldParents.length - 1;
                let j = newParents.length - 1;
                // Find common parent. Index 0 is the element itself (so stop before it).
                while (i > 0 && j > 0 && oldParents[i] === newParents[j]) {
                    i--;
                    j--;
                }
                // If up the parents tree there are 2 elements that are siblings, swap
                // the inerted sibling.
                if (oldParents[i] !== newParents[j]) {
                    this[_swapInertedSibling](oldParents[i], newParents[j]);
                }
                // Restore old parents siblings inertness.
                i > 0 && this[_restoreInertedSiblings](oldParents.slice(0, i));
                // Make new parents siblings inert.
                j > 0 && this[_inertSiblings](newParents.slice(0, j), toSkip, null);
            }
            /**
             * Swaps inertness between two sibling elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_swapInertedSibling](oldInert, newInert) {
                const siblingsToRestore = oldInert[_siblingsToRestore];
                // oldInert is not contained in siblings to restore, so we have to check
                // if it's inertable and if already inert.
                if (this[_isInertable](oldInert) && !oldInert.inert) {
                    oldInert.inert = true;
                    siblingsToRestore.add(oldInert);
                }
                // If newInert was already between the siblings to restore, it means it is
                // inertable and must be restored.
                if (siblingsToRestore.has(newInert)) {
                    newInert.inert = false;
                    siblingsToRestore.delete(newInert);
                }
                newInert[_parentMO] = oldInert[_parentMO];
                newInert[_siblingsToRestore] = siblingsToRestore;
                oldInert[_parentMO] = undefined;
                oldInert[_siblingsToRestore] = undefined;
            }
            /**
             * Restores original inertness to the siblings of the elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_restoreInertedSiblings](elements) {
                for (const element of elements) {
                    const mo = element[_parentMO];
                    mo.disconnect();
                    element[_parentMO] = undefined;
                    const siblings = element[_siblingsToRestore];
                    for (const sibling of siblings) {
                        sibling.inert = false;
                    }
                    element[_siblingsToRestore] = undefined;
                }
            }
            /**
             * Inerts the siblings of the elements except the elements to skip. Stores
             * the inerted siblings into the element's symbol `_siblingsToRestore`.
             * Pass `toKeepInert` to collect the already inert elements.
             * Sets the property `inert` over the attribute since the inert spec
             * doesn't specify if it should be reflected.
             * https://html.spec.whatwg.org/multipage/interaction.html#inert
             */
            [_inertSiblings](elements, toSkip, toKeepInert) {
                for (const element of elements) {
                    // Assume element is not a Document, so it must have a parentNode.
                    const parent = element.parentNode;
                    const children = parent.children;
                    const inertedSiblings = new Set();
                    for (let j = 0; j < children.length; j++) {
                        const sibling = children[j];
                        // Skip the input element, if not inertable or to be skipped.
                        if (sibling === element || !this[_isInertable](sibling) ||
                            (toSkip && toSkip.has(sibling))) {
                            continue;
                        }
                        // Should be collected since already inerted.
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                    // Store the siblings that were inerted.
                    element[_siblingsToRestore] = inertedSiblings;
                    // Observe only immediate children mutations on the parent.
                    const mo = new MutationObserver(this[_handleMutations].bind(this));
                    element[_parentMO] = mo;
                    let parentToObserve = parent;
                    // If we're using the ShadyDOM polyfill, then our parent could be a
                    // shady root, which is an object that acts like a ShadowRoot, but isn't
                    // actually a node in the real DOM. Observe the real DOM parent instead.
                    const maybeShadyRoot = parentToObserve;
                    if (maybeShadyRoot.__shady && maybeShadyRoot.host) {
                        parentToObserve = maybeShadyRoot.host;
                    }
                    mo.observe(parentToObserve, {
                        childList: true,
                    });
                }
            }
            /**
             * Handles newly added/removed nodes by toggling their inertness.
             * It also checks if the current top Blocking Element has been removed,
             * notifying and removing it.
             */
            [_handleMutations](mutations) {
                const parents = this[_topElParents];
                const toKeepInert = this[_alreadyInertElements];
                for (const mutation of mutations) {
                    // If the target is a shadowRoot, get its host as we skip shadowRoots when
                    // computing _topElParents.
                    const target = mutation.target.host || mutation.target;
                    const idx = target === document.body ?
                        parents.length :
                        parents.indexOf(target);
                    const inertedChild = parents[idx - 1];
                    const inertedSiblings = inertedChild[_siblingsToRestore];
                    // To restore.
                    for (let i = 0; i < mutation.removedNodes.length; i++) {
                        const sibling = mutation.removedNodes[i];
                        if (sibling === inertedChild) {
                            console.info('Detected removal of the top Blocking Element.');
                            this.pop();
                            return;
                        }
                        if (inertedSiblings.has(sibling)) {
                            sibling.inert = false;
                            inertedSiblings.delete(sibling);
                        }
                    }
                    // To inert.
                    for (let i = 0; i < mutation.addedNodes.length; i++) {
                        const sibling = mutation.addedNodes[i];
                        if (!this[_isInertable](sibling)) {
                            continue;
                        }
                        if (toKeepInert && sibling.inert) {
                            toKeepInert.add(sibling);
                        }
                        else {
                            sibling.inert = true;
                            inertedSiblings.add(sibling);
                        }
                    }
                }
            }
            /**
             * Returns if the element is inertable.
             */
            [_isInertable](element) {
                return false === /^(style|template|script)$/.test(element.localName);
            }
            /**
             * Returns the list of newParents of an element, starting from element
             * (included) up to `document.body` (excluded).
             */
            [_getParents](element) {
                const parents = [];
                let current = element;
                // Stop to body.
                while (current && current !== document.body) {
                    // Skip shadow roots.
                    if (current.nodeType === Node.ELEMENT_NODE) {
                        parents.push(current);
                    }
                    // ShadowDom v1
                    if (current.assignedSlot) {
                        // Collect slots from deepest slot to top.
                        while (current = current.assignedSlot) {
                            parents.push(current);
                        }
                        // Continue the search on the top slot.
                        current = parents.pop();
                        continue;
                    }
                    current = current.parentNode ||
                        current.host;
                }
                return parents;
            }
            /**
             * Returns the distributed children of the element's shadow root.
             * Returns null if the element doesn't have a shadow root.
             */
            [_getDistributedChildren](element) {
                const shadowRoot = element.shadowRoot;
                if (!shadowRoot) {
                    return null;
                }
                const result = new Set();
                let i;
                let j;
                let nodes;
                const slots = shadowRoot.querySelectorAll('slot');
                if (slots.length && slots[0].assignedNodes) {
                    for (i = 0; i < slots.length; i++) {
                        nodes = slots[i].assignedNodes({
                            flatten: true,
                        });
                        for (j = 0; j < nodes.length; j++) {
                            if (nodes[j].nodeType === Node.ELEMENT_NODE) {
                                result.add(nodes[j]);
                            }
                        }
                    }
                    // No need to search for <content>.
                }
                return result;
            }
        }
        document.$blockingElements =
            new BlockingElementsImpl();
    })();

    function blockingElements() { return getDocument$2().$blockingElements; }
    /**
     * Allows an element to trap focus by applying the "inert" attribute to all sibling, aunt, and uncle nodes.
     *
     * Automatically handles consecutive calls with a loosely applied stack operation
     * (specifically via `blockingElements`, with a small polyfill because I'm not sure how long
     * it'll take to find its way into the spec, if ever)
     * @param target
     */
    function useBlockingElement(enabled, getTarget) {
        const stableGetTarget = useStableCallback(getTarget);
        /**
         * Push/pop the element from the blockingElements stack.
         */
        _(() => {
            const target = stableGetTarget();
            if (enabled) {
                // Sometimes blockingElements will fail if, for example,
                // the target element isn't connected to document.body.
                // This is rare, but it's better to fail silently with weird tabbing behavior
                // than to crash the entire application.
                try {
                    blockingElements().push(target);
                    return () => {
                        blockingElements().remove(target);
                    };
                }
                catch (ex) {
                    // Well, semi-silently.
                    console.error(ex);
                }
            }
        }, [enabled]);
    }
    function getTopElement() {
        return blockingElements().top;
    }

    const elementsToRestoreFocusTo = new Map();
    function useFocusTrap({ trapActive }) {
        const handleActiveChange = q$1((trapActive, element) => {
            if (trapActive && element) {
                let rafHandle = requestAnimationFrame(() => {
                    // TODO: This extra queueMicrotask is needed for
                    // ...reasons?
                    queueMicrotask(() => {
                        findFirstFocusable(element)?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
            else if (element) {
                // Restore the focus to the element
                // that has returned to the top of the stack
                let rafHandle = requestAnimationFrame(() => {
                    queueMicrotask(() => {
                        elementsToRestoreFocusTo.get(getTopElement())?.focus();
                        rafHandle = 0;
                    });
                });
                return () => {
                    if (rafHandle)
                        cancelAnimationFrame(rafHandle);
                };
            }
        }, []);
        const { getElement, refElementProps } = useRefElement({ onElementChange: useStableCallback((element) => handleActiveChange(trapActive, element)) });
        const { getLastActiveElement } = useActiveElement({ getDocument: useStableCallback(() => getElement()?.ownerDocument ?? window.document) });
        // When the trap becomes active, before we let the blockingElements hook run,
        // keep track of whatever's currently focused and save it.
        _(() => {
            const element = getElement();
            if (trapActive && element) {
                const document = getDocument$2(element);
                // Save the currently focused element
                // to whatever's currently at the top of the stack
                elementsToRestoreFocusTo.set(getTopElement(), getLastActiveElement() ?? document.body);
            }
        }, [trapActive]);
        useBlockingElement(trapActive, getElement);
        /**
         * Any time we activate or deactivate the trap,
         * change focus to something else (something in
         * the trap if it's active, or whatever we've
         * tracked in elementsToRestoreFocusTo if not)
         */
        _(() => {
            handleActiveChange(trapActive, getElement());
        }, [trapActive]);
        const useFocusTrapProps = ((props) => {
            const p1 = useMergedProps(refElementProps, props);
            const p2 = { "aria-modal": trapActive ? "true" : undefined };
            return useMergedProps(p1, p2);
        });
        return {
            useFocusTrapProps,
            getElement
        };
    }
    /**
     * Returns the first focusable element contained within the given node, or null if none are found.
     * @param element
     * @returns
     */
    function findFirstFocusable(element) {
        const treeWalker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT, { acceptNode: (node) => (node instanceof Element && isFocusable(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP) });
        const firstFocusable = treeWalker.firstChild();
        return firstFocusable;
    }

    /**
     * Returns a function that will, when called, force the component
     * that uses this hook to re-render itself.
     *
     * It's a bit smelly, so best to use sparingly.
     */
    function useForceUpdate() {
        const [, set] = y(0);
        return A(() => set(i => ++i)).current;
    }

    function useHasFocus({ onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange, getDocument, getWindow, onElementChange, onMount, onUnmount }) {
        useEnsureStability("useHasFocus", onFocusedChanged, onFocusedInnerChanged, onLastFocusedChanged, onLastFocusedInnerChanged, onLastActiveElementChange, onActiveElementChange, onWindowFocusedChange);
        const [getFocused, setFocused] = usePassiveState(onFocusedChanged, returnFalse);
        const [getFocusedInner, setFocusedInner] = usePassiveState(onFocusedInnerChanged, returnFalse);
        const [getLastFocused, setLastFocused] = usePassiveState(onLastFocusedChanged, returnFalse);
        const [getLastFocusedInner, setLastFocusedInner] = usePassiveState(onLastFocusedInnerChanged, returnFalse);
        const { getElement, refElementProps } = useRefElement({ onElementChange, onMount, onUnmount });
        const { getActiveElement, getLastActiveElement, getWindowFocused } = useActiveElement({
            getDocument,
            getWindow,
            onActiveElementChange: q$1((activeElement, prevActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == activeElement));
                const focusedInner = (!!selfElement?.contains(activeElement));
                setFocused(focused);
                setFocusedInner(focusedInner);
                onActiveElementChange?.(activeElement, prevActiveElement);
            }, []),
            onLastActiveElementChange: q$1((lastActiveElement, prevLastActiveElement) => {
                const selfElement = getElement();
                const focused = (selfElement != null && (selfElement == lastActiveElement));
                const focusedInner = (!!selfElement?.contains(lastActiveElement));
                setLastFocused(focused);
                setLastFocusedInner(focusedInner);
                onLastActiveElementChange?.(lastActiveElement, prevLastActiveElement);
            }, []),
            onWindowFocusedChange
        });
        const hasFocusProps = refElementProps;
        return {
            hasFocusProps,
            getElement,
            getFocused,
            getFocusedInner,
            getLastFocused,
            getLastFocusedInner,
            getActiveElement,
            getLastActiveElement,
            getWindowFocused
        };
    }
    function useChildrenHaveFocus({ childrenHaveFocus: { onAllLostFocus, onAnyGainedFocus }, managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } }) {
        const { managedChildren, useManagedChild } = useManagedChildren({ managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } });
        const allElementsRef = A(new Set());
        const [_getFocusCount, setFocusCount] = usePassiveState(useStableCallback((anyFocused, anyPreviouslyFocused) => {
            console.assert(anyFocused >= 0 && anyFocused <= 1);
            if (anyFocused && !anyPreviouslyFocused)
                onAnyGainedFocus?.();
            if (!anyFocused && anyPreviouslyFocused)
                onAllLostFocus?.();
        }));
        const useChildrenHaveFocusChild = q$1(({ onElementChange, onMount, onUnmount, getDocument, getWindow, onActiveElementChange, onFocusedChanged, onFocusedInnerChanged, onLastActiveElementChange, onLastFocusedChanged, onLastFocusedInnerChanged, onWindowFocusedChange, managedChild: { index, flags }, subInfo }) => {
            useManagedChild({ managedChild: { index, flags }, subInfo });
            const { hasFocusProps, ...hasFocus } = useHasFocus({
                getDocument,
                getWindow,
                onActiveElementChange,
                onElementChange: q$1((e, prev) => {
                    let r = onElementChange?.(e, prev);
                    if (e) {
                        allElementsRef.current.add(e);
                        return () => {
                            r?.();
                            allElementsRef.current.delete(e);
                        };
                    }
                }, [onElementChange]),
                onMount,
                onUnmount,
                onFocusedChanged,
                onFocusedInnerChanged,
                onLastActiveElementChange,
                onLastFocusedChanged,
                onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
                    if (focused) {
                        setFocusCount(p => (p ?? 0) + 1);
                    }
                    else if (!focused && prev) {
                        setFocusCount(p => (p ?? 0) - 1);
                    }
                    onLastFocusedInnerChanged?.(focused, prev);
                }),
                onWindowFocusedChange
            });
            return {
                childrenHaveFocusChildProps: hasFocusProps,
                ...hasFocus
            };
        }, []);
        return {
            managedChildren,
            useChildrenHaveFocusChild
        };
    }

    function useTimeout({ timeout, callback, triggerIndex }) {
        const stableCallback = useStableCallback(() => { startTimeRef.current = null; callback(); });
        const getTimeout = useStableGetter(timeout);
        // Set any time we start timeout.
        // Unset any time the timeout completes
        const startTimeRef = A(null);
        const timeoutIsNull = (timeout == null);
        // Any time the triggerIndex changes (including on mount)
        // restart the timeout.  The timeout does NOT reset
        // when the duration or callback changes, only triggerIndex.
        s(() => {
            if (!timeoutIsNull) {
                const timeout = getTimeout();
                console.assert(timeoutIsNull == (timeout == null));
                if (timeout != null) {
                    startTimeRef.current = +(new Date());
                    const handle = setTimeout(stableCallback, timeout);
                    return () => clearTimeout(handle);
                }
            }
        }, [triggerIndex, timeoutIsNull]);
        const getElapsedTime = q$1(() => {
            return (+(new Date())) - (+(startTimeRef.current ?? new Date()));
        }, []);
        const getRemainingTime = q$1(() => {
            const timeout = getTimeout();
            return timeout == null ? null : Math.max(0, timeout - getElapsedTime());
        }, []);
        return { getElapsedTime, getRemainingTime };
    }

    /** Arguments passed to the child 'useLinearNavigationChild` */
    //export interface UseLinearNavigationChildInfo { }
    /**
     * When used in tandem with `useRovingTabIndex`, allows control of
     * the tabbable index with the arrow keys.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useLinearNavigation({ linearNavigation: { navigateToFirst: ntf, navigateToLast: ntl, navigateToNext: ntn, navigateToPrev: ntp, navigationDirection: nd, disableArrowKeys: dak, disableHomeEndKeys: dhek } }) {
        nd ??= "either";
        //const { getLogicalDirectionInfo, useLogicalDirectionProps } = useLogicalDirection<ParentOrChildElement>({});
        const navigateToFirst = useStableCallback(ntf);
        const navigateToLast = useStableCallback(ntl);
        const navigateToNext = useStableCallback(ntn);
        const navigateToPrev = useStableCallback(ntp);
        const getDisableArrowKeys = useStableGetter(dak);
        const getDisableHomeEndKeys = useStableGetter(dhek);
        const getNavigationDirection = useStableGetter(nd);
        return {
            linearNavigation: {},
            linearNavigationProps: {
                onKeyDown: (e) => {
                    // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                    if (e.ctrlKey || e.metaKey)
                        return;
                    //const info = getLogicalDirectionInfo();
                    const navigationDirection = getNavigationDirection();
                    const disableArrowKeys = getDisableArrowKeys();
                    const disableHomeEndKeys = getDisableHomeEndKeys();
                    const allowsVerticalNavigation = (navigationDirection == "vertical" || navigationDirection == "either");
                    const allowsHorizontalNavigation = (navigationDirection == "horizontal" || navigationDirection == "either");
                    switch (e.key) {
                        case "ArrowUp": {
                            //const propName = (info?.blockOrientation === "vertical" ? "blockDirection" : "inlineDirection");
                            const directionAllowed = (!disableArrowKeys && allowsVerticalNavigation);
                            if (directionAllowed) {
                                navigateToPrev();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowDown": {
                            const directionAllowed = (!disableArrowKeys && allowsVerticalNavigation);
                            if (directionAllowed) {
                                navigateToNext();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowLeft": {
                            const directionAllowed = (!disableArrowKeys && allowsHorizontalNavigation);
                            if (directionAllowed) {
                                navigateToPrev();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        }
                        case "ArrowRight": {
                            const directionAllowed = (!disableArrowKeys && allowsHorizontalNavigation);
                            if (directionAllowed) {
                                navigateToNext();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            e.preventDefault();
                            e.stopPropagation();
                            break;
                        }
                        case "Home":
                            if (!disableHomeEndKeys) {
                                navigateToFirst();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                        case "End":
                            if (!disableHomeEndKeys) {
                                navigateToLast();
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            break;
                    }
                }
            }
        };
    }
    /**
     * Allows for the selection of a managed child by typing the given text associated with it.
     *
     * @see useListNavigation, which packages everything up together.
     */
    function useTypeaheadNavigation({ typeaheadNavigation: { collator, getIndex, typeaheadTimeout, setIndex, noTypeahead } }) {
        // For typeahead, keep track of what our current "search" string is (if we have one)
        // and also clear it every 1000 ms since the last time it changed.
        // Next, keep a mapping of typeahead values to indices for faster searching.
        // And, for the user's sake, let them know when their typeahead can't match anything anymore
        const [currentTypeahead, setCurrentTypeahead, getCurrentTypeahead] = useState(null);
        useTimeout({ timeout: typeaheadTimeout ?? 1000, callback: () => { setCurrentTypeahead(null); setInvalidTypeahead(null); }, triggerIndex: currentTypeahead });
        const sortedTypeaheadInfo = A([]);
        const [invalidTypeahead, setInvalidTypeahead] = useState(false);
        // Handle typeahead for input method editors as well
        // Essentially, when active, ignore further keys 
        // because we're waiting for a CompositionEnd event
        const [, setImeActive, getImeActive] = useState(false);
        // Because composition events fire *after* keydown events 
        // (but within the same task, which, TODO, could be browser-dependent),
        // we can use this to keep track of which event we're listening for on the first keydown.
        const [nextTypeaheadChar, setNextTypeaheadChar] = useState(null);
        _(() => {
            if (nextTypeaheadChar !== null) {
                setCurrentTypeahead(typeahead => ((typeahead ?? "") + nextTypeaheadChar));
                setNextTypeaheadChar(null);
            }
        }, [nextTypeaheadChar]);
        const comparatorShared = useStableCallback((safeLhs, safeRhs) => {
            let compare;
            // For the purposes of typeahead, only compare a string of the same size as our currently typed string.
            // By normalizing them first, we ensure this byte-by-byte handling of raw character data works out okay.
            safeLhs = safeLhs.normalize("NFD");
            safeRhs = safeRhs.normalize("NFD");
            if (collator)
                compare = collator.compare(safeLhs, safeRhs);
            else
                compare = safeLhs.toLowerCase().localeCompare(safeRhs.toLowerCase() ?? "");
            return compare;
        });
        const insertingComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                return comparatorShared(lhs, rhs.text);
            }
            return lhs - rhs;
        });
        const typeaheadComparator = useStableCallback((lhs, rhs) => {
            if (typeof lhs === "string" && typeof rhs.text === "string") {
                // During typeahead, all strings longer than ours should be truncated
                // so that they're all considered equally by that point.
                return comparatorShared(lhs, rhs.text.substring(0, lhs.length));
            }
            return lhs - rhs;
        });
        const isDisabled = useStableGetter(noTypeahead);
        const typeaheadNavigationProps = {
            onKeyDown: (e) => {
                if (isDisabled())
                    return;
                const imeActive = getImeActive();
                const key = e.key;
                // Not handled by typeahead (i.e. assume this is a keyboard shortcut)
                if (e.ctrlKey || e.metaKey)
                    return;
                if (!imeActive && e.key === "Backspace") {
                    // Remove the last character in a way that doesn't split UTF-16 surrogates.
                    setCurrentTypeahead(t => t === null ? null : [...t].reverse().slice(1).reverse().join(""));
                    e.preventDefault();
                    e.stopPropagation();
                    return;
                }
                // The key property represents the typed character OR the "named key attribute" of the key pressed.
                // There's no definite way to tell the difference, but for all intents and purposes
                // there are no one-character names, and there are no non-ASCII-alpha names.
                // Thus, any one-character or non-ASCII value for `key` is *almost certainly* a typed character.
                const isCharacterKey = (key.length === 1 || !/^[A-Za-z]/.test(key));
                if (isCharacterKey) {
                    if (key == " " && (getCurrentTypeahead() ?? "").trim().length == 0) ;
                    else {
                        e.preventDefault();
                        e.stopPropagation();
                        // Note: Won't be true for the first keydown
                        // but will be overwritten before useLayoutEffect is called
                        // to actually apply the change
                        if (!imeActive)
                            setNextTypeaheadChar(key);
                    }
                }
            },
            onCompositionStart: (e) => {
                setNextTypeaheadChar(e.data);
                setImeActive(false);
            },
            onCompositionEnd: (_e) => { setImeActive(true); },
        };
        // Handle changes in typeahead that cause changes to the tabbable index
        s(() => {
            if (currentTypeahead && sortedTypeaheadInfo.current.length) {
                const sortedTypeaheadIndex = binarySearch(sortedTypeaheadInfo.current, currentTypeahead, typeaheadComparator);
                if (sortedTypeaheadIndex < 0) {
                    // The user has typed an entry that doesn't exist in the list
                    // (or more specifically "for which there is no entry that starts with that input")
                    setInvalidTypeahead(true);
                }
                else {
                    setInvalidTypeahead(false);
                    /*
                      We know roughly where, in the sorted array of strings, our next typeahead location is.
                      But roughly isn't good enough if there are multiple matches.
                      To convert our sorted index to the unsorted index we need, we have to find the first
                      element that matches us *and* (if any such exist) is *after* our current selection.

                      In other words, the only way typeahead moves backwards relative to our current
                      position is if the only other option is behind us.

                      It's not specified in WAI-ARIA what to do in that case.  I suppose wrap back to the start?
                      Though there's also a case for just going upwards to the nearest to prevent jumpiness.
                      But if you're already doing typeahead on an unsorted list, like, jumpiness can't be avoided.
                      I dunno. Going back to the start is the simplist though.

                      Basically what this does: Starting from where we found ourselves after our binary search,
                      scan backwards and forwards through all adjacent entries that also compare equally so that
                      we can find the one whose `unsortedIndex` is the lowest amongst all other equal strings
                      (and also the lowest `unsortedIndex` yadda yadda except that it comes after us).

                      TODO: The binary search starts this off with a solid O(log n), but one-character
                      searches are, thanks to pigeonhole principal, eventually guaranteed to become
                      O(n*log n). This is annoying but probably not easily solvable? There could be an
                      exception for one-character strings, but that's just kicking the can down
                      the road. Maybe one or two characters would be good enough though.
                    */
                    // These are used to keep track of the candidates' positions in both our sorted array and the unsorted DOM.
                    let lowestUnsortedIndexAll = null;
                    let lowestSortedIndexAll = sortedTypeaheadIndex;
                    // These two are only set for elements that are ahead of us, but the principle's the same otherwise
                    let lowestUnsortedIndexNext = null;
                    let lowestSortedIndexNext = sortedTypeaheadIndex;
                    const updateBestFit = (u) => {
                        if (lowestUnsortedIndexAll == null || u < lowestUnsortedIndexAll) {
                            lowestUnsortedIndexAll = u;
                            lowestSortedIndexAll = i;
                        }
                        if ((lowestUnsortedIndexNext == null || u < lowestUnsortedIndexNext) && u > (getIndex() ?? -Infinity)) {
                            lowestUnsortedIndexNext = u;
                            lowestSortedIndexNext = i;
                        }
                    };
                    let i = sortedTypeaheadIndex;
                    while (i >= 0 && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        --i;
                    }
                    i = sortedTypeaheadIndex;
                    while (i < sortedTypeaheadInfo.current.length && typeaheadComparator(currentTypeahead, sortedTypeaheadInfo.current[i]) == 0) {
                        updateBestFit(sortedTypeaheadInfo.current[i].unsortedIndex);
                        ++i;
                    }
                    if (lowestUnsortedIndexNext !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexNext].unsortedIndex);
                    else if (lowestUnsortedIndexAll !== null)
                        setIndex(sortedTypeaheadInfo.current[lowestSortedIndexAll].unsortedIndex);
                }
            }
        }, [currentTypeahead]);
        const useTypeaheadNavigationChild = q$1(({ index, text }) => {
            s(() => {
                if (text) {
                    // Find where to insert this item.
                    // Because all index values should be unique, the returned sortedIndex
                    // should always refer to a new location (i.e. be negative)                
                    const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                    console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                    if (sortedIndex < 0) {
                        sortedTypeaheadInfo.current.splice(-sortedIndex - 1, 0, { text, unsortedIndex: index });
                    }
                    else {
                        sortedTypeaheadInfo.current.splice(sortedIndex, 0, { text, unsortedIndex: index });
                    }
                    return () => {
                        // When unmounting, find where we were and remove ourselves.
                        // Again, we should always find ourselves because there should be no duplicate values if each index is unique.
                        const sortedIndex = binarySearch(sortedTypeaheadInfo.current, text, insertingComparator);
                        console.assert(sortedIndex < 0 || insertingComparator(sortedTypeaheadInfo.current[sortedIndex].text, { unsortedIndex: index, text }) == 0);
                        if (sortedIndex >= 0) {
                            sortedTypeaheadInfo.current.splice(sortedIndex, 1);
                        }
                    };
                }
            }, [text]);
            return;
        }, []);
        return {
            useTypeaheadNavigationChild,
            typeaheadNavigationProps,
            typeaheadNavigation: {
                currentTypeahead,
                invalidTypeahead,
            }
        };
    }
    /**
     * Your usual binary search implementation.
     *
     * It's used here to quickly find a good spot to start searching for our next typeahead candidate.
     * @param array The array to search through
     * @param wanted The value you'd like to find
     * @param comparator Compares `wanted` with the current value in `array`
     * @returns A non-negative value if `wanted` was found, and a negative number if not.
     * The absolute value of this number, minus one, is where `wanted` *would* be found if it *was* in `array`
     */
    function binarySearch(array, wanted, comparator) {
        let firstIndex = 0;
        let lastIndex = array.length - 1;
        while (firstIndex <= lastIndex) {
            const testIndex = (lastIndex + firstIndex) >> 1;
            const comparisonResult = comparator(wanted, array[testIndex]);
            if (comparisonResult > 0) {
                firstIndex = testIndex + 1;
            }
            else if (comparisonResult < 0) {
                lastIndex = testIndex - 1;
            }
            else {
                return testIndex;
            }
        }
        return -firstIndex - 1;
    }

    /**
     * Implements a roving tabindex system where only one "focusable"
     * component in a set is able to receive a tab focus. *Which*
     * of those elements receives focus is determined by you, but it's
     * recommended to offload that logic then to another hook, like
     * `useLinearNavigation`, which lets you change the tabbable
     * element with the arrow keys, `useTypeaheadNavigation`, which
     * lets you change the tabbable index with typeahead, or
     * `useListNavigation` if you just want everything bundled together.
     *
     * Note that the child hook returned by this function must be used
     * by every child that uses this roving tabindex logic.  The
     * prop-modifying hook *that* hook returns should then be used
     * on the child's element, as well as any other elements you'd like
     * to be explicitly made untabbable too.
     *
     * `shouldFocusOnChange` should return true if focus is
     * contained within whatever element contains the roving tab index.
     * Generally as simple as the following:
     * ```
     * const [focusedInner, setFocusedInner] = useState(false);
     * const { useHasFocusProps } = useHasFocus<ParentElement>({ setFocusedInner });
     * const focusOnChange = (focusedInner != false);
     * ```
     * It's not included here because `useRovingTabIndex` doesn't know
     * anything about the container element, only children elements.
     * And just as well! Children should be allowed at the root,
     * regardless of if it's the whole app or just a given component.
     */
    function useRovingTabIndex(parentParameters) {
        let { rovingTabIndex: { initialIndex, onTabbableRender, onTabbableIndexChange }, managedChildren: { onAfterChildLayoutEffect, onChildrenMountChange } } = parentParameters;
        initialIndex ??= 0;
        const stableOnTabbableRender = useStableCallback(onTabbableRender ?? (() => { }));
        /*const [_getAnyFocused, setAnyFocused] = usePassiveState<number>(useStableCallback((newCount: number, oldCount: number | undefined) => {
            if (oldCount == 0 && newCount > 0) {
                onTabbedInTo?.();
            }

            if (newCount == 0 && (oldCount ?? 0) > 0) {
                onTabbedOutOf?.();
            }
        }), returnZero);*/
        // Keep track of three things related to the currently tabbable element's index:
        // What it is, and whether, when we render this component and it's changed, to also focus the element that was made tabbable.
        const [getTabbableIndex, setTabbableIndex2] = usePassiveState(onTabbableIndexChange, q$1(() => { return initialIndex ?? 0; }, []));
        const setTabbableIndex = q$1((updater, fromUserInteraction) => {
            setTabbableIndex2((prevIndex) => {
                let nextIndex = prevIndex;
                if (typeof updater === "function")
                    nextIndex = updater(prevIndex ?? null);
                else
                    nextIndex = updater;
                nextIndex = changeIndex(nextIndex);
                if (prevIndex != nextIndex) {
                    const nextChild = nextIndex == null ? null : parentReturnType.managedChildren.children.getAt(nextIndex);
                    //const prevChild = prevIndex == null ? null : parentReturnType.managedChildren.children.getAt(prevIndex);
                    //if (prevChild != null)
                    //    prevChild.subInfo.blurSelf();
                    if (nextChild != null && fromUserInteraction) {
                        const element = nextChild.subInfo.getElement();
                        if (element) {
                            if (document.activeElement == null || !element.contains(document.activeElement))
                                nextChild.subInfo.focusSelf();
                        }
                    }
                }
                return nextIndex;
            });
        }, []);
        // Any time the tabbable index changes,
        // notify the previous child that it's no longer tabbable,
        // and notify the next child that is allowed to be tabbed to.
        const parentReturnType = useManagedChildren({
            managedChildren: {
                onAfterChildLayoutEffect,
                onChildrenMountChange: useStableCallback((mounted, unmounted) => { onChildrenMountChange?.(mounted, unmounted); reevaluateClosestFit(); }),
            },
        });
        const { useManagedChild } = parentReturnType;
        const { changeIndex, reevaluateClosestFit } = useChildrenFlag({ initialIndex, children: parentReturnType.managedChildren.children, closestFit: true, key: "tabbable" });
        const useRovingTabIndexChild = q$1((childParameters) => {
            const { subInfo, managedChild: { index, flags }, rovingTabIndex: { hidden, focusSelf: focusSelfOverride, noModifyTabIndex } } = childParameters;
            s(() => {
                reevaluateClosestFit();
            }, [!!hidden]);
            const stableFocusSelf = useStableCallback(focusSelfOverride);
            const focusSelf = q$1(() => {
                const element = getElement();
                if (element) {
                    if (document.activeElement == null || !element.contains(document.activeElement))
                        stableFocusSelf(element);
                }
            }, []);
            const onFocusedInnerChanged = useStableCallback((focused, _prevFocused) => {
                if (focused) {
                    setTabbableIndex(index, false);
                }
            });
            const { getElement, hasFocusProps } = useHasFocus({ onFocusedInnerChanged, getDocument: q$1(() => { return (getElement()?.ownerDocument) ?? (window.document); }, []) });
            const [tabbable, setTabbable, getTabbable] = useState(false);
            const tabbableFlags = A({ get: getTabbable, set: setTabbable, isValid: useStableCallback(() => !hidden) });
            useManagedChild({
                managedChild: {
                    index,
                    flags: { ...flags, tabbable: tabbableFlags.current },
                },
                subInfo: {
                    focusSelf,
                    getElement,
                    hidden: !!hidden,
                    subInfo
                }
            });
            s(() => {
                if (tabbable)
                    stableOnTabbableRender(index);
            }, [tabbable, index]);
            const rovingTabIndexChildProps = useMergedProps(hasFocusProps, { tabIndex: noModifyTabIndex ? undefined : (tabbable ? 0 : -1) });
            return {
                rovingTabIndexChildProps,
                rovingTabIndex: {
                    getElement,
                    tabbable,
                    getTabbable
                }
            };
        }, [ /* Must remain stable */]);
        const focusSelf = q$1(() => {
            const index = getTabbableIndex();
            if (index != null)
                parentReturnType.managedChildren.children.getAt(index)?.subInfo.focusSelf?.();
            else
                setTabbableIndex(null, true);
        }, []);
        return {
            useRovingTabIndexChild,
            managedChildren: { children: parentReturnType.managedChildren.children },
            rovingTabIndex: {
                setTabbableIndex,
                getTabbableIndex,
                focusSelf,
            }
        };
    }
    /*function test() {
        const { children, focusSelf, getTabbableIndex, setTabbableIndex, useRovingTabIndexChild, } = useRovingTabIndex<HTMLDivElement, { "foo": "bar" }, "flag2">({ managedChildren: {}, rovingTabIndex: {} });
        const { } = useRovingTabIndexChild({ managedChildren: { index: 0, flags: {} }, rti: { info3: { foo: "bar" } } });
    }*/

    function identity(t) { return t; }
    /**
     * Implements proper keyboard navigation for components like listboxes, button groups, menus, etc.
     *
     * In the document order, there will be only one "focused" or "tabbable" element, making it act more like one complete unit in comparison to everything around it.
     * Navigating forwards/backwards can be done with the arrow keys, Home/End keys, or any any text for typeahead to focus the next item that matches.
     */
    function useListNavigation({ managedChildren: { onChildrenMountChange, ...mc }, rovingTabIndex, listNavigation: { indexDemangler, indexMangler }, linearNavigation, typeaheadNavigation }) {
        indexMangler ??= identity;
        indexDemangler ??= identity;
        useEnsureStability("useListNavigation", indexMangler, indexDemangler);
        const parentReturnType = useRovingTabIndex({
            managedChildren: {
                ...mc, onChildrenMountChange: q$1((m, u) => {
                    onChildrenMountChange?.(m, u);
                }, [])
            },
            rovingTabIndex
        });
        const { useRovingTabIndexChild, managedChildren: { children }, rovingTabIndex: { getTabbableIndex, setTabbableIndex } } = parentReturnType;
        const navigateToIndex = q$1((i, fromUserInteraction) => {
            if (i != null) {
                const nextIndex = tryNavigateToIndex({
                    children: children,
                    default: 0,
                    target: i,
                    searchDirection: 1,
                    indexMangler: indexMangler ?? identity,
                    indexDemangler: indexDemangler ?? identity
                });
                setTabbableIndex(i == null ? null : nextIndex, fromUserInteraction);
            }
            else {
                setTabbableIndex(null, fromUserInteraction);
            }
        }, []);
        const { useTypeaheadNavigationChild, typeaheadNavigationProps, typeaheadNavigation: { currentTypeahead, invalidTypeahead } } = useTypeaheadNavigation({
            typeaheadNavigation: {
                getIndex: getTabbableIndex,
                setIndex: q$1((index) => {
                    setTabbableIndex(index, true);
                }, []),
                ...typeaheadNavigation
            }
        });
        const { linearNavigationProps } = useLinearNavigation({
            linearNavigation: {
                navigateToPrev: q$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler((c ?? 0)) - 1), searchDirection: -1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToNext: q$1(() => {
                    setTabbableIndex(c => {
                        return tryNavigateToIndex({ children, default: c ?? 0, target: indexDemangler(indexMangler(c ?? 0) + 1), searchDirection: 1, indexMangler: indexMangler ?? identity, indexDemangler: indexDemangler ?? identity });
                    }, true);
                }, []),
                navigateToFirst: q$1(() => { navigateToIndex(indexDemangler(0), true); }, []),
                navigateToLast: q$1(() => { navigateToIndex(indexDemangler(children.getHighestIndex()), true); }, []),
                ...linearNavigation
            }
        });
        const listNavigationProps = useMergedProps(linearNavigationProps, typeaheadNavigationProps);
        const useListNavigationChild = q$1(({ managedChild: { index, flags }, rovingTabIndex: { focusSelf, hidden }, listNavigation: { text }, subInfo }) => {
            useTypeaheadNavigationChild({ text, index });
            const getIndex = useStableGetter(index);
            s(() => {
                return () => {
                    if (getTabbableIndex() == getIndex()) {
                        navigateToIndex(index, false);
                    }
                };
            }, []);
            const { rovingTabIndexChildProps, rovingTabIndex: { tabbable, getTabbable, getElement } } = useRovingTabIndexChild({
                managedChild: { index, flags },
                rovingTabIndex: { focusSelf, hidden: !!hidden },
                subInfo: { text, subInfo }
            });
            const listNavigationChildProps = useMergedProps(rovingTabIndexChildProps, { inert: hidden });
            return {
                listNavigationChildProps,
                rovingTabIndex: {
                    tabbable,
                    getTabbable,
                    getElement
                }
            };
        }, [useTypeaheadNavigationChild, useRovingTabIndexChild, navigateToIndex]);
        return {
            useListNavigationChild,
            listNavigationProps,
            listNavigation: { navigateToIndex },
            managedChildren: parentReturnType.managedChildren,
            rovingTabIndex: parentReturnType.rovingTabIndex,
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }
            /*listNavigation: { navigateToIndex },
            rovingTabIndex: { focusSelf, getTabbableIndex, setTabbableIndex },
            linearNavigation: {},
            typeaheadNavigation: { currentTypeahead, invalidTypeahead }*/
        };
    }
    function tryNavigateToIndex({ children, searchDirection, indexDemangler, indexMangler, target }) {
        const upper = children.getHighestIndex();
        const lower = 0;
        if (searchDirection === -1) {
            while ((target >= lower && (children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden))
                target = indexDemangler(indexMangler(target) - 1);
            return target < lower ? indexDemangler(lower) : target;
        }
        else if (searchDirection === 1) {
            while ((target <= upper && children.getAt(target) == null) || !!children.getAt(target)?.subInfo.hidden)
                target = indexDemangler(indexMangler(target) + 1);
            return target > upper ? indexDemangler(upper) : target;
        }
        else {
            return lower;
        }
    }

    function useGridNavigation({ managedChildren: mc, rovingTabIndex: rti, listNavigation: ls, linearNavigation: ln, typeaheadNavigation: tn, gridNavigation: { rowIndexDemangler, rowIndexMangler } }) {
        const [currentColumn, setCurrentColumn, getCurrentColumn] = useState(rti.initialIndex ?? 0);
        const { useListNavigationChild: useListNavigationChildAsGridRow, listNavigationProps: useListNavigationPropsAsGridParent, ...parentLsReturnType } = useListNavigation({
            managedChildren: mc,
            rovingTabIndex: rti,
            listNavigation: { indexDemangler: rowIndexDemangler, indexMangler: rowIndexMangler, ...ls },
            linearNavigation: { navigationDirection: "vertical", ...ln },
            typeaheadNavigation: tn,
        });
        const useGridNavigationRow = q$1(({ asChildRowOfSection: asChild, asParentRowOfCells: asParent }) => {
            // Override the focusSelf that rovingTabIndex does.
            // Instead of focusing the entire row, we ask the cell that corresponds
            // to our current column to focus itself.
            const focusSelfRow = useStableCallback(() => {
                debugger;
                const c2 = getCurrentColumn();
                navigateToColumn(c2 ?? 0, true);
            });
            const rowLsChildReturnType = useListNavigationChildAsGridRow({
                managedChild: asChild.managedChild,
                listNavigation: { ...asChild.listNavigation },
                rovingTabIndex: { ...asChild.rovingTabIndex, focusSelf: focusSelfRow },
                subInfo: { subInfo: asChild.subInfo },
            });
            const { rovingTabIndex: { tabbable }, listNavigationChildProps } = rowLsChildReturnType;
            s(() => {
                if (!tabbable) {
                    navigateToColumn(null, false);
                }
            }, [tabbable]);
            const rowLsReturnType = useListNavigation({
                managedChildren: { ...asParent.managedChildren },
                rovingTabIndex: { ...asParent.rovingTabIndex },
                linearNavigation: {
                    ...asParent.linearNavigation,
                    navigationDirection: "horizontal",
                },
                typeaheadNavigation: { ...asParent.typeaheadNavigation, noTypeahead: true },
                listNavigation: { ...asParent.listNavigation }
            });
            const { rovingTabIndex: { setTabbableIndex }, useListNavigationChild: useGridNavigationColumn2, listNavigationProps: useGridNavigationColumnProps, listNavigation: { navigateToIndex: navigateToColumn } } = rowLsReturnType;
            //const rowHidden = !!asChild.rovingTabIndex.hidden;
            const useGridNavigationCell = q$1(({ subInfo, hasFocus: { onLastFocusedInnerChanged, ...hasFocus }, managedChild, listNavigation: ls, rovingTabIndex: { focusSelf: focusSelfCell, ...rti } }) => {
                const { listNavigationChildProps, rovingTabIndex: rti_cell_ret } = useGridNavigationColumn2({
                    managedChild: managedChild,
                    listNavigation: { ...ls },
                    rovingTabIndex: { focusSelf: focusSelfCell, ...rti },
                    subInfo: { subInfo }
                });
                const { hasFocusProps } = useHasFocus({
                    onLastFocusedInnerChanged: useStableCallback((focused, prev) => {
                        onLastFocusedInnerChanged?.(focused, prev);
                        if (focused) {
                            setCurrentColumn(managedChild.index);
                            setTabbableIndex(managedChild.index, false);
                        }
                    }),
                    ...hasFocus
                });
                const ret = {
                    gridNavigation: { getCurrentColumn },
                    rovingTabIndex: rti_cell_ret,
                    gridNavigationCellProps: useMergedProps(listNavigationChildProps, hasFocusProps)
                };
                return ret;
            }, []);
            const ret = {
                asParentOfCells: {
                    linearNavigation: rowLsReturnType.linearNavigation,
                    listNavigation: rowLsReturnType.listNavigation,
                    managedChildren: rowLsReturnType.managedChildren,
                    rovingTabIndex: rowLsReturnType.rovingTabIndex,
                    typeaheadNavigation: rowLsReturnType.typeaheadNavigation,
                },
                asChildRow: rowLsChildReturnType,
                useGridNavigationCell,
                gridNavigationRowProps: useMergedProps(listNavigationChildProps, useGridNavigationColumnProps)
            };
            return ret;
        }, []);
        return {
            gridNavigation: {
                getCurrentColumn,
                currentColumn
            },
            linearNavigation: parentLsReturnType.linearNavigation,
            listNavigation: parentLsReturnType.listNavigation,
            rovingTabIndex: parentLsReturnType.rovingTabIndex,
            typeaheadNavigation: parentLsReturnType.typeaheadNavigation,
            managedChildren: parentLsReturnType.managedChildren,
            useGridNavigationRow,
            gridNavigationProps: useListNavigationPropsAsGridParent,
        };
    }

    function useInterval({ interval, callback }) {
        // Get a wrapper around the given callback that's stable
        const stableCallback = useStableCallback(callback);
        const getInterval = useStableGetter(interval);
        s(() => {
            const interval = getInterval();
            let lastDelayUsed = interval;
            if (interval == null)
                return;
            // Get a wrapper around the wrapper around the callback
            // that clears and resets the interval if it changes.
            const adjustableCallback = () => {
                stableCallback();
                const currentInterval = getInterval();
                if (currentInterval != lastDelayUsed) {
                    clearInterval(handle);
                    if (currentInterval != null)
                        handle = setInterval(adjustableCallback, lastDelayUsed = currentInterval);
                }
            };
            let handle = setInterval(adjustableCallback, interval);
            return () => clearInterval(handle);
        }, []);
    }

    /**
     * Adds the necessary event handlers to create a "press"-like event for
     * any element, whether it's a native <BUTTON> or regular <DIV>.
     *
     * Notably, the following cases are covered:
     * * The target element is properly focused, even on iOS Safari (*especially* on iOS Safari)
     * * Double-clicks won't select text.
     * * Conversely, manually selecting text won't invoke a press.
     * * Keyboard events &mdash; `enter` immediately invokes the handler, while `space` invokes it on keyup.
     * * Haptic feedback (on, like, the one browser combination that supports it &mdash; this can be disabled app-wide with `setButtonVibrate`)
     *
     * In addition, when the CSS `:active` pseudo-class would apply to a normal button
     * (i.e. when holding the spacebar or during mousedown), `{ "data-pseudo-active": "true" }`
     * is added to the props.  You can either let it pass through and style it through new CSS,
     * or inspect the returned props for it and add e.g. an `.active` class for existing CSS
     *
     * @param onClickSync
     * @param exclude Whether the polyfill shouldn't apply (can specify for specific interactions)
     */
    function usePress({ exclude, hasFocus: { onLastFocusedInnerChanged, ...hasFocus }, onClickSync, focusSelf }) {
        // A button can be activated in multiple ways, so on the off chance
        // that multiple are triggered at once, we only *actually* register
        // a press once all of our "on" signals have turned back to "off".
        // We approximate this by just incrementing when active, and
        // decrementing when deactivated.
        //
        // As an emergency failsafe, when the element loses focus,
        // this is reset back to 0.
        const [activeDuringRender, setActive, getActive] = useState(0);
        const forceUpdate = useForceUpdate();
        const { hasFocusProps, getElement } = useHasFocus({
            ...hasFocus,
            onLastFocusedInnerChanged: useStableCallback((f, p) => {
                onLastFocusedInnerChanged?.(f, p);
                if (!f) {
                    setActive(0);
                }
            })
        });
        // If we the current text selection changes to include this element
        // DURING e.g. a mousedown, then we don't want the mouseup to "count", as it were,
        // because its only purpose was selecting text, not clicking buttons.
        //
        // To catch this, any time the text selection includes us while in the middle
        // of a click, this flag is set, which cancels the activation of a press.
        // The flag is reset any time the selection is empty or the button is
        // no longer active.
        const [textSelectedDuringActivationStartTime, setTextSelectedDuringActivationStartTime] = useState(null);
        const pseudoActive = (activeDuringRender && (textSelectedDuringActivationStartTime == null));
        useGlobalHandler(document, "selectionchange", _ => {
            setTextSelectedDuringActivationStartTime(prev => nodeSelectedTextLength(getElement()) == 0 ? null : prev != null ? prev : new Date());
        });
        s(() => {
            if (activeDuringRender == 0)
                setTextSelectedDuringActivationStartTime(null);
        }, [activeDuringRender == 0]);
        const onActiveStart = useStableCallback((_) => {
            setActive(a => ++a);
        });
        const onActiveStop = useStableCallback((e) => {
            setActive(a => Math.max(0, --a));
            const currentTime = new Date();
            const timeDifference = (textSelectedDuringActivationStartTime == null ? null : +currentTime - +textSelectedDuringActivationStartTime);
            const charactersSelected = nodeSelectedTextLength(getElement());
            // If we're selecting text (heuristically determined by selecting for longer than 1/4 a second, or more than 2 characters)
            // then this isn't a press event.
            // TODO: This should measure glyphs instead of characters.
            if (charactersSelected > 1 || ((timeDifference ?? 0) > 250 && charactersSelected >= 1)) {
                e.preventDefault();
                return;
            }
            let active = getActive(); // We query if we're active *after* calling setState because we count a press iff we're now at 0.
            if (active <= 0) {
                handlePress(e);
                forceUpdate(); // TODO: Remove when issue resolved https://github.com/preactjs/preact/issues/3731
            }
        });
        const handlePress = useStableCallback((e) => {
            if (onClickSync) {
                // Note: The element is focused here because of iOS Safari.
                //
                // It's always iOS Safari.
                //
                // iOS Safari (tested on 12) downright refuses to allow 
                // elements to be manually focused UNLESS it happens within
                // an event handler like this.  It also doesn't focus
                // buttons by default when clicked, tapped, etc.
                //
                // If it becomes problematic that button-likes explicitly become
                // focused when they are pressed, then an alternative solution for
                // the question of "how do menu buttons keep their menus open"
                // and other focus-related nonsense needs to be figured out.
                //
                // For iOS Safari.
                //
                const element = getElement();
                if (element && "focus" in element)
                    focusSelf(element);
                //(element as EventTarget as HTMLElement | null)?.focus();
                // Whatever the browser was going to do with this event,
                // forget it. We're turning it into a "press" event.
                e.preventDefault();
                // Also stop anyone else from listening to this event,
                // since we're explicitly handling it.
                // (Notably, this allows labels to wrap inputs, with them
                // both having press event handlers, without double-firing)
                e.stopPropagation();
                // Haptic feedback for this press event
                try {
                    // The default implementation doesn't throw,
                    // but we should guard against user implementations that could.
                    pulse();
                }
                finally {
                    // Actually call our handler.
                    onClickSync(e);
                }
            }
        });
        const onMouseDown = useStableCallback((e) => {
            if (onClickSync && !excludes("click", exclude)) {
                // Stop double clicks from selecting text in an component that's *supposed* to be acting like a button,
                // but also don't prevent the user from selecting that text manually if they really want to
                // (which user-select: none would do, but cancelling a double click on mouseDown doesn't)
                if (e.detail > 1) {
                    e.preventDefault();
                }
                if (e.button === 0) {
                    onActiveStart(e);
                }
            }
        });
        const onMouseUp = useStableCallback((e) => {
            if (onClickSync && !excludes("click", exclude)) {
                if (e.button === 0 && getActive() > 0) {
                    onActiveStop(e);
                }
            }
        });
        const onMouseLeave = useStableCallback(() => {
            if (onClickSync && !excludes("click", exclude)) {
                setActive(0);
            }
        });
        const onKeyDown = useStableCallback((e) => {
            if (onClickSync) {
                if (e.key == " " && !excludes("space", exclude)) {
                    // We don't actually activate it on a space keydown
                    // but we do preventDefault to stop the page from scrolling.
                    onActiveStart(e);
                    e.preventDefault();
                }
                if (e.key == "Enter" && !excludes("enter", exclude)) {
                    e.preventDefault();
                    onActiveStart(e);
                    onActiveStop(e);
                }
            }
        });
        const onKeyUp = useStableCallback((e) => {
            if (onClickSync && e.key == " " && !excludes("space", exclude))
                onActiveStop(e);
        });
        const onClick = useStableCallback((e) => {
            if (onClickSync) {
                e.preventDefault();
                if (e.detail > 1) {
                    e.stopImmediatePropagation();
                    e.stopPropagation();
                }
            }
        });
        return useMergedProps(hasFocusProps, {
            onKeyDown,
            onKeyUp,
            onMouseDown,
            onMouseUp,
            onMouseLeave,
            onClick,
            style: (textSelectedDuringActivationStartTime != null) ? { cursor: "text" } : undefined,
            ...{ "data-pseudo-active": pseudoActive ? "true" : undefined }
        });
    }
    /**
     * selection.containsNode doesn't account for selection.isCollapsed,
     * so here's a workaround for that.
     *
     * We also only look for the selection end to only catch the
     * essense of a non-existant "selectionstop" event.
     *
     * @param element
     * @returns
     */
    function nodeSelectedTextLength(element) {
        if (element && element instanceof Node) {
            const selection = window.getSelection();
            for (let i = 0; i < (selection?.rangeCount ?? 0); ++i) {
                const range = selection.getRangeAt(i);
                if (element.contains(range.endContainer) && !selection?.isCollapsed) {
                    return selection.toString().length;
                }
            }
        }
        return 0;
    }
    let pulse = (("vibrate" in navigator) && (navigator.vibrate instanceof Function)) ? (() => navigator.vibrate(10)) : (() => { });
    function excludes(target, exclude) {
        if (exclude?.[target])
            return true;
        return false;
    }

    function useSingleSelection({ singleSelection: { selectedIndex, selectionMode, setSelectedIndex, children, setTabbableIndex }, childrenHaveFocus: { onAllLostFocus, onAnyGainedFocus } }) {
        const { useChildrenHaveFocusChild } = useChildrenHaveFocus({
            childrenHaveFocus: {
                onAllLostFocus: useStableCallback(() => {
                    onAllLostFocus?.();
                    if (selectedIndex != null)
                        setTabbableIndex(selectedIndex, false);
                }),
                onAnyGainedFocus
            }, managedChildren: {
                onAfterChildLayoutEffect: null,
                onChildrenMountChange: null
            }
        });
        const stableOnChange = useStableCallback(setSelectedIndex);
        const { changeIndex: changeSelectedIndex, getCurrentIndex: getSelectedIndex } = useChildrenFlag({
            children: children,
            initialIndex: selectedIndex,
            key: "selected",
            closestFit: false
        });
        _(() => {
            changeSelectedIndex(selectedIndex);
        }, [selectedIndex]);
        return {
            singleSelection: {
                getSelectedIndex,
                changeSelectedIndex
            },
            useSingleSelectionChild: q$1(({ managedChild: { index, flags }, hasFocus: { onFocusedInnerChanged, ...hasFocus }, singleSelection: { unselectable, ariaPropName, focusSelf } }) => {
                const [isSelected, setIsSelected, getIsSelected] = useState(getSelectedIndex() == index);
                const selectedRef = A({ get: getIsSelected, set: setIsSelected, isValid: useStableCallback(() => !unselectable) });
                const { childrenHaveFocusChildProps, getElement } = useChildrenHaveFocusChild({
                    onFocusedInnerChanged: useStableCallback((focused, prev) => {
                        if (focused)
                            debugger;
                        onFocusedInnerChanged?.(focused, prev);
                        if (selectionMode == 'focus' && focused) {
                            stableOnChange(getIndex(), { target: getElement(), currentTarget: getElement() });
                        }
                    }),
                    ...hasFocus,
                    managedChild: { index },
                    subInfo: undefined
                });
                const getIndex = useStableGetter(index);
                const usePressProps = usePress({
                    onClickSync: unselectable ? null : ((e) => { stableOnChange(getIndex(), e); }),
                    exclude: {},
                    hasFocus,
                    focusSelf
                });
                return {
                    flags: { ...flags, selected: selectedRef.current },
                    singleSelectionChildProps: useMergedProps(useMergedProps(usePressProps, childrenHaveFocusChildProps), { [ariaPropName]: (isSelected ?? false).toString() }),
                    singleSelection: { selected: isSelected, getSelected: getIsSelected }
                };
            }, [selectionMode]),
        };
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeFloor = Math.floor,
        nativeRandom = Math.random;

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function arrayMap(array, iteratee) {
      var index = -1,
          length = array == null ? 0 : array.length,
          result = Array(length);

      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }

    /**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /** `Object#toString` result references. */
    var argsTag$1 = '[object Arguments]';

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag$1;
    }

    /** Used for built-in method references. */
    var objectProto$3 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto$3.propertyIsEnumerable;

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty$2.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /** Detect free variable `exports`. */
    var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

    /** Built-in value references. */
    var Buffer = moduleExports$1 ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER$1 = 9007199254740991;

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER$1 : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        arrayTag = '[object Array]',
        boolTag = '[object Boolean]',
        dateTag = '[object Date]',
        errorTag = '[object Error]',
        funcTag$1 = '[object Function]',
        mapTag = '[object Map]',
        numberTag = '[object Number]',
        objectTag = '[object Object]',
        regexpTag = '[object RegExp]',
        setTag = '[object Set]',
        stringTag = '[object String]',
        weakMapTag = '[object WeakMap]';

    var arrayBufferTag = '[object ArrayBuffer]',
        dataViewTag = '[object DataView]',
        float32Tag = '[object Float32Array]',
        float64Tag = '[object Float64Array]',
        int8Tag = '[object Int8Array]',
        int16Tag = '[object Int16Array]',
        int32Tag = '[object Int32Array]',
        uint8Tag = '[object Uint8Array]',
        uint8ClampedTag = '[object Uint8ClampedArray]',
        uint16Tag = '[object Uint16Array]',
        uint32Tag = '[object Uint32Array]';

    /** Used to identify `toStringTag` values of typed arrays. */
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
    typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
    typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
    typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
    typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
    typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
    typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
    typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
    typedArrayTags[mapTag] = typedArrayTags[numberTag] =
    typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
    typedArrayTags[setTag] = typedArrayTags[stringTag] =
    typedArrayTags[weakMapTag] = false;

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }

    /** Detect free variable `exports`. */
    var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = (function() {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;

        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }());

    /* Node.js helper references. */
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /** Used for built-in method references. */
    var objectProto$2 = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty$1.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /** Used for built-in method references. */
    var objectProto$1 = Object.prototype;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$1;

      return value === proto;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /** `Object#toString` result references. */
    var asyncTag = '[object AsyncFunction]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]',
        proxyTag = '[object Proxy]';

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useRearrangeableChildren({ rearrangeableChildren: { getIndex } }) {
        // These are used to keep track of a mapping between unsorted index <---> sorted index.
        // These are needed for navigation with the arrow keys.
        const mangleMap = A(new Map());
        const demangleMap = A(new Map());
        const indexMangler = q$1((n) => (mangleMap.current.get(n) ?? n), []);
        const indexDemangler = q$1((n) => (demangleMap.current.get(n) ?? n), []);
        // The sort function needs to be able to update whoever has all the sortable children.
        // Because that might not be the consumer of *this* hook directly (e.g. a table uses
        // this hook, but it's tbody that actually needs updating), we need to remotely
        // get and set a forceUpdate function.
        //const [getForceUpdate, setForceUpdate] = usePassiveState<null | (() => void)>(null, returnNull);
        const [getForceUpdate, setForceUpdate] = usePassiveState(null, returnNull);
        const rearrange = q$1((sortedRows) => {
            // Update our sorted <--> unsorted indices map 
            // and rerender the whole table, basically
            for (let indexAsSorted = 0; indexAsSorted < sortedRows.length; ++indexAsSorted) {
                const indexAsUnsorted = sortedRows[indexAsSorted].index;
                mangleMap.current.set(indexAsUnsorted, indexAsSorted);
                demangleMap.current.set(indexAsSorted, indexAsUnsorted);
            }
            getForceUpdate()?.();
        }, []);
        const useRearrangeableProps = q$1(({ children, ...props }) => {
            console.assert(Array.isArray(children));
            const forceUpdate = useForceUpdate();
            _(() => { setForceUpdate(_prev => forceUpdate); }, [forceUpdate]);
            return (useMergedProps({
                children: children
                    .slice()
                    .map(child => ({ child, mangledIndex: indexMangler(getIndex(child.props)), demangledIndex: getIndex(child.props) }))
                    .sort((lhs, rhs) => { return lhs.mangledIndex - rhs.mangledIndex; })
                    .map(({ child, mangledIndex, demangledIndex }) => {
                    return h$1(child.type, { ...child.props, key: demangledIndex, "data-mangled-index": mangledIndex, "data-unmangled-index": demangledIndex });
                })
            }, props));
        }, []);
        return { useRearrangeableProps, rearrangeableChildren: { indexMangler, indexDemangler, mangleMap, demangleMap, rearrange } };
    }
    /**
     * Hook that allows for the **direct descendant** children of this component to be re-ordered and sorted.
     *
     * *This is **separate** from "managed" children, which can be any level of child needed! Sortable/rearrangeable children must be **direct descendants** of the parent that uses this hook!*
     *
     * It's recommended to use this in conjunction with `useListNavigation`; it takes the same `indexMangler` and `indexDemangler`
     * functions that this hook returns. `useListNavigation` does not directly use this hook because, as mentioned,
     * this hook imposes serious restrictions on child structure, while `useListNavigation` allows anything.
     *
     * Besides the prop-modifying hook that's returned, the `sort` function that's returned will
     * sort all children according to their value from the `getValue` argument you pass in.
     *
     * If you want to perform some re-ordering operation that's *not* a sort, you can manually
     * re-map each child's position using `mangleMap` and `demangleMap`, which convert between
     * sorted and unsorted index positions.
     *
     * Again, unlike some other hooks, **these children must be direct descendants**. This is because
     * the prop-modifying hook inspects the given children, then re-creates them with new `key`s.
     * Because keys are given special treatment and a child has no way of modifying its own key
     * there's no other time or place this can happen other than exactly within the parent component's render function.
     */
    function useSortableChildren({ rearrangeableChildren: { getIndex }, sortableChildren: { compare: userCompare } }) {
        const compare = (userCompare ?? defaultCompare);
        const { useRearrangeableProps: useSortableProps, ...rearrangeableChildrenReturnType } = useRearrangeableChildren({ rearrangeableChildren: { getIndex } });
        const { rearrangeableChildren: { rearrange } } = rearrangeableChildrenReturnType;
        // The actual sort function.
        const sort = q$1((managedRows, direction) => {
            const sortedRows = managedRows.arraySlice().sort((lhsRow, rhsRow) => {
                const lhsValue = lhsRow;
                const rhsValue = rhsRow;
                const result = compare(lhsValue, rhsValue);
                if (direction[0] == "d")
                    return -result;
                return result;
            });
            return rearrange(sortedRows);
        }, [ /* Must remain stable */]);
        const shuffle$1 = q$1((managedRows) => {
            const shuffledRows = shuffle(managedRows.arraySlice());
            return rearrange(shuffledRows);
        }, [ /* Must remain stable */]);
        return {
            useSortableProps,
            sortableChildren: { sort, shuffle: shuffle$1 },
            rearrangeableChildren: rearrangeableChildrenReturnType.rearrangeableChildren
        };
    }
    function defaultCompare(lhs, rhs) {
        return compare1(lhs, rhs);
        function compare3(lhs, rhs) {
            // Coerce strings to numbers if they seem to stay the same when serialized
            if (`${+lhs}` === lhs)
                lhs = +lhs;
            if (`${+rhs}` === rhs)
                rhs = +rhs;
            // At this point, if either argument is a string, turn the other one into one too
            if (typeof lhs === "string")
                rhs = `${rhs}`;
            if (typeof rhs === "string")
                lhs = `${lhs}`;
            console.assert(typeof lhs === typeof rhs);
            if (typeof lhs === "string")
                return lhs.localeCompare(rhs);
            if (typeof lhs === "number")
                return +lhs - +rhs;
            return 0;
        }
        function compare2(lhs, rhs) {
            if (typeof lhs === "boolean" || lhs instanceof Date)
                lhs = +lhs;
            if (typeof rhs === "boolean" || rhs instanceof Date)
                rhs = +rhs;
            return compare3(lhs, rhs);
        }
        function compare1(lhs, rhs) {
            if (lhs == null && rhs == null) {
                // They're both null
                return 0;
            }
            else if (lhs == null || rhs == null) {
                // One of the two is null -- easy case
                return lhs != null ? 1 : -1;
            }
            return compare2(lhs, rhs);
        }
    }

    /**
     * It's very common to combine a tabbable list of things and "selection" of one of those things.
     *
     * Lists, radio buttons, tabs, etc. etc.
     *
     * This is a shortcut that combines the two with the correct typing.
     * @param param0
     * @returns
     */
    function useListNavigationSingleSelection({ singleSelection: { selectedIndex, selectionMode, setSelectedIndex }, listNavigation, managedChildren, rovingTabIndex: { ...rovingTabIndex }, linearNavigation, typeaheadNavigation, childrenHaveFocus: { onAllLostFocus, onAnyGainedFocus } }) {
        const parentReturnType = useListNavigation({
            listNavigation,
            managedChildren,
            rovingTabIndex: {
                initialIndex: (selectedIndex ?? undefined),
                ...rovingTabIndex
            },
            linearNavigation,
            typeaheadNavigation
        });
        useStableGetter(selectionMode);
        const { useSingleSelectionChild, ...singleSelectionInfo } = useSingleSelection({
            singleSelection: {
                children: parentReturnType.managedChildren.children,
                selectedIndex,
                selectionMode,
                setSelectedIndex,
                setTabbableIndex: parentReturnType.rovingTabIndex.setTabbableIndex
            },
            childrenHaveFocus: { onAllLostFocus, onAnyGainedFocus }
        });
        useStableCallback(setSelectedIndex);
        const { useListNavigationChild, listNavigationProps, ...listRest } = parentReturnType;
        return {
            useListNavigationSingleSelectionChild: q$1(({ managedChild: { index, flags }, rovingTabIndex: rti, listNavigation: ls, hasFocus, singleSelection: { focusSelf, unselectable, ...ss }, subInfo }) => {
                unselectable ||= (rti.hidden ?? false);
                const { singleSelectionChildProps, flags: ssflags, ...singleSelectionInfo } = useSingleSelectionChild({
                    managedChild: { index, flags },
                    hasFocus,
                    singleSelection: { ...ss, focusSelf, unselectable }
                });
                const { rovingTabIndex: rti_ret, listNavigationChildProps } = useListNavigationChild({
                    managedChild: {
                        index,
                        flags: {
                            ...ssflags,
                            ...flags
                        }
                    },
                    rovingTabIndex: rti,
                    listNavigation: ls,
                    subInfo,
                });
                return {
                    listNavigationSingleSelectionChildProps: useMergedProps(singleSelectionChildProps, listNavigationChildProps),
                    rovingTabIndex: rti_ret,
                    singleSelection: singleSelectionInfo.singleSelection
                };
            }, [useSingleSelectionChild]),
            listNavigationSingleSelectionProps: listNavigationProps,
            ...listRest,
            ...singleSelectionInfo
        };
    }
    function useSortableListNavigationSingleSelection({ linearNavigation, listNavigation, managedChildren, rovingTabIndex, singleSelection, typeaheadNavigation, childrenHaveFocus }) {
        const { useSortableProps, ...sortableReturnType } = useSortableChildren({
            rearrangeableChildren: { getIndex: q$1((row) => row.index, []) },
            sortableChildren: {
                compare: q$1((lhs, rhs) => { return lhs.index - rhs.index; }, []),
            }
        });
        const { rearrangeableChildren: { indexDemangler, indexMangler } } = sortableReturnType;
        const { useListNavigationSingleSelectionChild, listNavigationSingleSelectionProps, ...listNavReturnType } = useListNavigationSingleSelection({
            linearNavigation: linearNavigation,
            listNavigation: { indexDemangler, indexMangler, ...listNavigation },
            managedChildren: managedChildren,
            rovingTabIndex: rovingTabIndex,
            typeaheadNavigation: typeaheadNavigation,
            singleSelection: singleSelection,
            childrenHaveFocus: childrenHaveFocus
        });
        const useSortableListNavigationSingleSelectionProps = (props) => {
            return useSortableProps(useMergedProps(listNavigationSingleSelectionProps, props));
        };
        const useSortableListNavigationSingleSelectionChild = (p) => {
            return useListNavigationSingleSelectionChild(p);
        };
        return ({
            useSortableListNavigationSingleSelectionChild,
            useSortableListNavigationSingleSelectionProps,
            //sortable: { sort, shuffle, rearrange, demangleMap, indexDemangler, indexMangler, mangleMap },
            ...sortableReturnType,
            ...listNavReturnType
        });
    }

    const DemoUseInterval = () => {
        const [interval, setInterval] = y(1000);
        const [fireCount, setFireCount] = y(0);
        useInterval({ interval, callback: () => setFireCount(i => ++i) });
        return (o$1("div", { class: "demo", children: [o$1("label", { children: ["Interval duration: ", o$1("input", { type: "number", value: interval, onInput: e => setInterval(e.currentTarget.valueAsNumber) })] }), o$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords$1 = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    function getDocument$1() {
        return window.document;
    }
    const ListNavigationSingleSelectionChildContext = B$2(null);
    const DemoUseRovingTabIndex = w(() => {
        const [selectionMode, setSelectionMode] = useState("activation");
        const [count, setCount] = useState(10);
        const [selectedIndex, setSelectedIndex] = useState(0);
        const [tabbableIndex, setLocalTabbableIndex] = useState(0);
        const { managedChildren: { children }, useSortableListNavigationSingleSelectionChild, useSortableListNavigationSingleSelectionProps, rovingTabIndex: { setTabbableIndex }, typeaheadNavigation: { currentTypeahead }, sortableChildren: { shuffle }, } = useSortableListNavigationSingleSelection({
            linearNavigation: {},
            listNavigation: {},
            managedChildren: {},
            rovingTabIndex: { onTabbableIndexChange: q$1((index) => { if (index != null)
                    setLocalTabbableIndex(index); }, []) },
            typeaheadNavigation: {},
            singleSelection: { selectedIndex, selectionMode, setSelectedIndex: (i, _e) => setSelectedIndex(i) },
            childrenHaveFocus: {}
        });
        return (o$1("div", { className: "demo", children: [o$1("h2", { children: "Keyboard & List Navigation" }), o$1("h3", { children: o$1("code", { children: "useRovingTabIndex" }) }), o$1("p", { children: ["Native HTML elements offer fantastic keyboard accessability, but cover a relatively limited number of use cases. There is no native HTML tree element, for example, that allows keyboard navigation of its items, nor is it possible to combine the keyboard navigation behavior of a ", o$1("code", { children: "<select>" }), " menu with the menu in a drawer component."] }), o$1("p", { children: ["When coming across a List or a Menu or a RadioGroup or a ToggleButtonGroup or any other \"one component made up of child components\", the usual expected behavior, at least natively, is that tabbing into the component is one action, and tabbing out is another.  Navigating ", o$1("em", { children: "within" }), " the component is done with the arrow keys or other methods."] }), o$1("p", { children: ["This is important both for accessability, but also just for general usability.  When tabbing back and forth, the ability to skip a long list without needing to trudge through ", o$1("em", { children: "every one" }), " of its child elements is extremely important."] }), o$1("p", { children: [o$1("code", { children: "useListNavigation" }), " wraps up the functionality of a few hooks (", o$1("code", { children: "useRovingTabIndex" }), ", ", o$1("code", { children: "useLinearNavigation" }), ", ", o$1("code", { children: "useTypeaheadNavigation" }), ") to allow for ARIA-compliant navigation of lists and other similar components.  For more advanced use cases, you can use the other hooks individually."] }), o$1("p", { children: [o$1("code", { children: "useListNavigation" }), " (and ", o$1("code", { children: "useRovingTabIndex" }), ") internally use ", o$1("code", { children: "useChildManager" }), ", which is how the child elements and the parent communicate with each other. This means there are virtually no restrictions on how the DOM is set up as long as you can provide the children with the ", o$1("code", { children: "useListNavigationChild" }), " hook that's returned, usually with a simple ", o$1("code", { children: "Context" }), ". If the child element itself has a focusable element, like a button, it can also be wired up to disable itself Feel free to nest them too, as long as you are aware of your ", o$1("code", { children: "Context" }), " management (i.e. remember that you need to create a new ", o$1("code", { children: "Context" }), " for each use case)."] }), o$1("label", { children: ["# of items", o$1("input", { type: "number", value: count, min: 0, onInput: e => { e.preventDefault(); setCount(e.currentTarget.valueAsNumber); } })] }), o$1("button", { onClick: () => shuffle(children), children: "Shuffle" }), o$1("label", { children: ["Tabbable index: ", o$1("input", { type: "number", value: tabbableIndex ?? undefined, onInput: e => { e.preventDefault(); setTabbableIndex(e.currentTarget.valueAsNumber, false); } })] }), o$1("label", { children: ["Selected index: ", o$1("input", { type: "number", value: selectedIndex ?? undefined, onInput: e => { e.preventDefault(); setSelectedIndex(e.currentTarget.valueAsNumber); } })] }), o$1("label", { children: ["Selection mode:", o$1("label", { children: [o$1("input", { name: "rti-demo-selection-mode", type: "radio", checked: selectionMode == 'focus', onInput: e => { e.preventDefault(); setSelectionMode("focus"); } }), " On focus"] }), o$1("label", { children: [o$1("input", { name: "rti-demo-selection-mode", type: "radio", checked: selectionMode == 'activation', onInput: e => { e.preventDefault(); setSelectionMode("activation"); } }), " On activation (click, tap, Enter, Space, etc.)"] })] }), o$1(ListNavigationSingleSelectionChildContext.Provider, { value: useSortableListNavigationSingleSelectionChild, children: o$1("ul", { ...(useSortableListNavigationSingleSelectionProps({
                            children: Array.from((function* () {
                                for (let i = 0; i < count; ++i) {
                                    yield o$1(DemoUseRovingTabIndexChild, { index: i }, i);
                                }
                            })())
                        })) }) }), currentTypeahead && o$1("div", { children: ["Typeahead: ", currentTypeahead] })] }));
    });
    const DemoUseRovingTabIndexChild = w((({ index }) => {
        const hidden = (index == 7);
        const [randomWord] = useState(() => RandomWords$1[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useListNavigationSingleSelectionChild = x(ListNavigationSingleSelectionChildContext);
        const text = `${randomWord} This is item #${index}${hidden ? " (hidden)" : ""}`;
        const focusSelf = q$1((e) => { e.focus(); }, []);
        const { listNavigationSingleSelectionChildProps, rovingTabIndex: { tabbable }, singleSelection: { selected } } = useListNavigationSingleSelectionChild({
            managedChild: { index },
            listNavigation: { text },
            rovingTabIndex: { hidden, focusSelf },
            subInfo: {},
            hasFocus: { getDocument: getDocument$1 },
            singleSelection: { ariaPropName: "aria-selected", unselectable: hidden, focusSelf: e => e.focus() }
        });
        const props = listNavigationSingleSelectionChildProps;
        return (o$1("li", { ...props, children: [text, " (", tabbable ? "Tabbable" : "Not tabbable", ", ", selected ? "Selected" : "Not selected", ")", o$1("input", { ...useMergedProps(listNavigationSingleSelectionChildProps, { type: "number" }), style: { width: "5ch" } })] }));
    }));

    const DemoUseTimeout = () => {
        const [timeout, setTimeout] = y(1000);
        const [triggerIndex, setTriggerIndex] = y("");
        const [fireCount, setFireCount] = y(0);
        useTimeout({ timeout, triggerIndex, callback: () => setFireCount(i => ++i) });
        return (o$1("div", { class: "demo", children: [o$1("label", { children: ["Timeout duration: ", o$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), o$1("label", { children: ["Refresh key: ", o$1("input", { type: "text", value: triggerIndex, onInput: e => setTriggerIndex(e.currentTarget.value) })] }), o$1("div", { children: ["The callback has been called ", fireCount, " time", fireCount === 1 ? "" : "s", "."] })] }));
    };

    const RandomWords = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.".split(" ");
    const DemoUseDroppable = () => {
        const { droppedFiles, droppedStrings, filesForConsideration, stringsForConsideration, useDroppableProps, dropError } = useDroppable({ effect: "copy" });
        useMergedProps({}, { ref: A(null) });
        const p = useDroppableProps({ className: "demo droppable" });
        return (o$1("div", { ...p, children: [droppedStrings != null && o$1("div", { children: ["Data dropped: ", o$1("ul", { children: Object.entries(droppedStrings).map(([type, value]) => o$1("li", { children: [type, ": ", value] })) })] }), droppedFiles != null && o$1("div", { children: ["Files dropped: ", o$1("table", { children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Name" }), o$1("th", { children: "Size" }), o$1("th", { children: "Type" }), o$1("th", { children: "Last modified" })] }) }), o$1("tbody", { children: droppedFiles.map(f => o$1("tr", { children: [o$1("td", { children: f.name }), f.data.byteLength, o$1("td", { children: f.type }), o$1("td", { children: new Date(f.lastModified ?? 0) })] })) })] })] }), o$1("hr", {}), stringsForConsideration != null && o$1("div", { children: ["Data being considered: ", o$1("ul", { children: Array.from(stringsForConsideration).map(type => o$1("li", { children: type })) })] }), filesForConsideration != null && o$1("div", { children: ["Files being considered: ", o$1("ul", { children: filesForConsideration.map(f => o$1("li", { children: JSON.stringify(f) })) })] }), o$1("hr", {}), dropError && o$1("div", { children: dropError instanceof Error ? dropError.message : JSON.stringify(dropError) })] }));
    };
    const DemoUseDraggable = () => {
        const { useDraggableProps } = useDraggable({ data: { "text/plain": "This is custom draggable content of type text/plain." } });
        return (o$1("div", { ...useDraggableProps({ className: "demo" }), children: "Draggable content" }));
    };
    const DemoUseElementSizeAnimation = () => {
        const [height, setHeight] = useState(0);
        const [angle, setAngle] = useState(0);
        useAnimationFrame({
            callback: (_ms) => {
                setAngle(a => a + 0.01);
                setHeight((Math.sin(angle) + 1) / 0.5);
            }
        });
        const [elementSize, setElementSize] = useState(null);
        const { useElementSizeProps } = useElementSize({ onSizeChange: setElementSize });
        return (o$1("div", { ...useMergedProps(useElementSizeProps, { ref: undefined, className: "demo", style: { height: `${(height * 100) + 100}px` } }), children: o$1("pre", { children: JSON.stringify(elementSize, null, 2) }) }));
    };
    const DemoUseFocusTrap = w(({ depth }) => {
        const [active, setActive] = useState(false);
        const { useFocusTrapProps } = useFocusTrap({ trapActive: active });
        //const { useRovingTabIndexChild, useRovingTabIndexProps } = useRovingTabIndex<HTMLUListElement, RovingTabIndexChildInfo>({ tabbableIndex, focusOnChange: false });
        const divProps = useFocusTrapProps({ ref: undefined, className: "focus-trap-demo" });
        if (depth == 2)
            return o$1("div", {});
        return (o$1("div", { className: "demo", children: [o$1("label", { children: ["Active: ", o$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] }), o$1("div", { ...divProps, children: o$1(DemoUseFocusTrapChild, { active: active, setActive: setActive, depth: depth ?? 0 }) })] }));
    });
    const DemoUseFocusTrapChild = w(({ setActive, active }) => {
        return (o$1(p$1, { children: [o$1("button", { children: "Button 1" }), o$1("button", { children: "Button 2" }), o$1("button", { children: "Button 3" }), o$1("label", { children: ["Active: ", o$1("input", { type: "checkbox", checked: active, onInput: e => { e.preventDefault(); setActive(e.currentTarget.checked); } })] })] }));
    });
    const DemoUseAsyncHandler1 = w(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const asyncOnClick = ((_v, _e) => new Promise((resolve, reject) => window.setTimeout(() => getShouldThrow() ? reject() : resolve(), timeout)));
        const { callCount, settleCount, hasCapture, syncHandler, pending, hasError, rejectCount, resolveCount } = useAsyncHandler({ asyncHandler: asyncOnClick, capture: () => { }, debounce: debounce == 0 ? undefined : debounce });
        const onClick = pending ? undefined : syncHandler;
        return (o$1("div", { className: "demo", children: [o$1("button", { disabled: pending && disableConsecutive, onClick: onClick, children: "Click me!" }), o$1("label", { children: ["Sleep for: ", o$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), o$1("label", { children: ["Throw an error ", o$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), o$1("label", { children: ["Disabled while pending ", o$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), o$1("label", { children: ["Debounce: ", o$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), o$1("table", { children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Field" }), o$1("th", { children: "Value" })] }) }), o$1("tbody", { children: [o$1("tr", { children: [o$1("td", { children: "callCount" }), o$1("td", { children: callCount })] }), o$1("tr", { children: [o$1("td", { children: "settleCount" }), o$1("td", { children: settleCount })] }), o$1("tr", { children: [o$1("td", { children: "resolveCount" }), o$1("td", { children: resolveCount })] }), o$1("tr", { children: [o$1("td", { children: "rejectCount" }), o$1("td", { children: rejectCount })] }), o$1("tr", { children: [o$1("td", { children: "hasError" }), o$1("td", { children: hasError.toString() })] }), o$1("tr", { children: [o$1("td", { children: "hasCapture" }), o$1("td", { children: hasCapture.toString() })] })] })] })] }));
    });
    const DemoUseAsyncHandler2 = w(() => {
        const [timeout, setTimeout] = useState(1000);
        const [debounce, setDebounce] = useState(0);
        const [shouldThrow, setShouldThrow, getShouldThrow] = useState(false);
        const [disableConsecutive, setDisableConsecutive] = useState(false);
        const [text, setText] = useState("");
        const onInputAsync = async (v, _e) => new Promise((resolve, reject) => window.setTimeout(() => {
            if (getShouldThrow()) {
                reject();
            }
            else {
                setText(v);
                resolve();
            }
        }, timeout));
        const { callCount, settleCount, hasCapture, syncHandler, currentCapture, pending, hasError, rejectCount, resolveCount } = useAsyncHandler({ asyncHandler: onInputAsync, capture: (e) => { e.preventDefault(); return e.currentTarget.value; }, debounce: debounce == 0 ? undefined : debounce });
        return (o$1("div", { className: "demo", children: [o$1("label", { children: ["Demo text: ", o$1("input", { value: hasCapture ? currentCapture : text, disabled: pending && disableConsecutive, onInput: syncHandler })] }), o$1("hr", {}), o$1("label", { children: ["Sleep for: ", o$1("input", { type: "number", value: timeout, onInput: e => setTimeout(e.currentTarget.valueAsNumber) })] }), o$1("label", { children: ["Throw an error ", o$1("input", { type: "checkbox", checked: shouldThrow, onInput: e => setShouldThrow(e.currentTarget.checked) })] }), o$1("label", { children: ["Disabled while pending ", o$1("input", { type: "checkbox", checked: disableConsecutive, onInput: e => setDisableConsecutive(e.currentTarget.checked) })] }), o$1("label", { children: ["Debounce: ", o$1("input", { type: "number", value: debounce, onInput: e => setDebounce(e.currentTarget.valueAsNumber) })] }), o$1("table", { children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Field" }), o$1("th", { children: "Value" })] }) }), o$1("tbody", { children: [o$1("tr", { children: [o$1("td", { children: "callCount" }), o$1("td", { children: callCount })] }), o$1("tr", { children: [o$1("td", { children: "settleCount" }), o$1("td", { children: settleCount })] }), o$1("tr", { children: [o$1("td", { children: "resolveCount" }), o$1("td", { children: resolveCount })] }), o$1("tr", { children: [o$1("td", { children: "rejectCount" }), o$1("td", { children: rejectCount })] }), o$1("tr", { children: [o$1("td", { children: "hasError" }), o$1("td", { children: hasError.toString() })] }), o$1("tr", { children: [o$1("td", { children: "currentCapture" }), o$1("td", { children: currentCapture })] }), o$1("tr", { children: [o$1("td", { children: "\"Saved\" input" }), o$1("td", { children: text })] })] })] })] }));
    });
    function getDocument() {
        return window.document;
    }
    const DemoFocus = w(() => {
        const [lastActiveElement, setLastActiveElement] = useState(null);
        const [activeElement, setActiveElement] = useState(null);
        const [windowFocused, setWindowFocused] = useState(false);
        const [focused, setFocused] = useState(false);
        const [focusedInner, setFocusedInner] = useState(false);
        const [lastFocused, setLastFocused] = useState(false);
        const [lastFocusedInner, setLastFocusedInner] = useState(false);
        const { hasFocusProps } = useHasFocus({
            getDocument,
            onFocusedChanged: setFocused,
            onFocusedInnerChanged: setFocusedInner,
            onLastFocusedChanged: setLastFocused,
            onLastFocusedInnerChanged: setLastFocusedInner,
            onActiveElementChange: setActiveElement,
            onLastActiveElementChange: setLastActiveElement,
            onWindowFocusedChange: setWindowFocused
        });
        return (o$1("div", { class: "demo", children: [o$1("h2", { children: "useHasFocus" }), o$1("div", { ...useMergedProps(hasFocusProps, { style: { border: "1px solid black" }, tabIndex: 0 }), children: ["Outer ", o$1("div", { tabIndex: 0, style: { border: "1px solid black" }, children: "Inner element" })] }), o$1("div", { children: o$1("ul", { children: [o$1("li", { children: ["Strictly focused: ", focused.toString(), ", ", lastFocused.toString()] }), o$1("li", { children: ["Inner focused: ", focusedInner.toString(), ", ", lastFocusedInner.toString()] }), o$1("li", { children: ["Window focused: ", windowFocused.toString()] }), o$1("li", { children: ["activeElement: ", activeElement?.textContent] }), o$1("li", { children: ["lastActiveElement: ", lastActiveElement?.textContent] })] }) })] }));
    });
    const GridRowContext = B$2(null);
    const GridCellContext = B$2(null);
    const DemoUseGrid = w(() => {
        const [, setLastFocusedInner, _getLastFocusedInner] = useState(false);
        const { hasFocusProps } = useHasFocus({ onLastFocusedInnerChanged: setLastFocusedInner, getDocument });
        const { useGridNavigationRow, gridNavigationProps, gridNavigation: { currentColumn } } = useGridNavigation({
            rovingTabIndex: {},
            linearNavigation: {},
            listNavigation: {},
            typeaheadNavigation: {},
            managedChildren: {},
            gridNavigation: {}
        });
        return (o$1("div", { class: "demo", children: [o$1("div", { children: ["Current column: ", currentColumn] }), o$1("table", { ...{ border: "2" }, style: { whiteSpace: "nowrap" }, children: [o$1("thead", { children: o$1("tr", { children: [o$1("th", { children: "Row is tabbable?" }), o$1("th", { children: "Column 1" }), o$1("th", { children: "Column 2" })] }) }), o$1("tbody", { ...useMergedProps(hasFocusProps, gridNavigationProps), children: o$1(GridRowContext.Provider, { value: useGridNavigationRow, children: Array.from((function* () {
                                    for (let i = 0; i < 10; ++i) {
                                        yield o$1(DemoUseGridRow, { index: i }, i);
                                    }
                                })()) }) })] })] }));
    });
    const DemoUseGridRow = w((({ index }) => {
        useState(() => RandomWords[index /*Math.floor(Math.random() * (RandomWords.length - 1))*/]);
        const useGridRow = x(GridRowContext);
        const { gridNavigationRowProps, useGridNavigationCell, asChildRow: { rovingTabIndex: { tabbable } }, } = useGridRow({
            asChildRowOfSection: { managedChild: { index }, listNavigation: { text: "" }, rovingTabIndex: { hidden: index == 3 }, subInfo: {} },
            asParentRowOfCells: { linearNavigation: {}, listNavigation: {}, rovingTabIndex: {}, typeaheadNavigation: {}, managedChildren: {} },
        });
        const props = gridNavigationRowProps;
        return (o$1("tr", { ...props, children: o$1(GridCellContext.Provider, { value: useGridNavigationCell, children: Array.from((function* () {
                    for (let i = 0; i < 3; ++i) {
                        yield o$1(DemoUseGridCell, { index: i, row: index, rowIsTabbable: tabbable }, i);
                    }
                })()) }) }));
    }));
    const DemoUseGridCell = (({ index, row, rowIsTabbable }) => {
        if (row >= 6 && row % 2 == 0 && index > 1)
            return null;
        let hiddenText = (row === 3) ? " (row hidden)" : "";
        const useGridCell = x(GridCellContext);
        const { gridNavigationCellProps, rovingTabIndex: { tabbable: cellIsTabbable } } = useGridCell({
            listNavigation: { text: "" },
            managedChild: { index },
            rovingTabIndex: { hidden: false, focusSelf: q$1(e => e.focus(), []) },
            hasFocus: { getDocument },
            subInfo: {},
        });
        const props = gridNavigationCellProps;
        const t = (cellIsTabbable ? "(Tabbable)" : "(Not tabbable)");
        if (index === 0)
            return o$1("td", { ...props, children: rowIsTabbable.toString() });
        else {
            if (row < 6 || row % 2 != 0) {
                if (index === 1)
                    return o$1("td", { ...props, children: ["Grid cell #", index + 1, " ", t, hiddenText] });
                else
                    return o$1("td", { children: o$1("label", { children: [o$1("input", { ...props, type: "checkbox" }), " Test input ", t, hiddenText] }) });
            }
            else {
                if (index === 1)
                    return o$1("td", { ...props, colSpan: 2, children: ["Grid cell #", index + 1, ", span 2 ", t, hiddenText] });
                else
                    return null;
            }
        }
    });
    const Component = () => {
        return o$1("div", { class: "flex", style: { flexWrap: "wrap" }, children: [o$1(DemoFocus, {}), o$1("hr", {}), o$1(DemoUseGrid, {}), o$1("hr", {}), o$1(DemoUseTimeout, {}), o$1("hr", {}), o$1(DemoUseInterval, {}), o$1("hr", {}), o$1(DemoUseRovingTabIndex, {}), o$1("hr", {}), o$1(DemoUseFocusTrap, {}), o$1("hr", {}), o$1(DemoUseAsyncHandler1, {}), o$1("hr", {}), o$1(DemoUseAsyncHandler2, {}), o$1("hr", {}), o$1(DemoUseDroppable, {}), o$1("hr", {}), o$1(DemoUseDraggable, {}), o$1("hr", {}), o$1(DemoUseElementSizeAnimation, {}), o$1("hr", {}), o$1("input", {})] });
    };
    requestAnimationFrame(() => {
        P(o$1(Component, {}), document.getElementById("root"));
    });

    exports.DemoUseGrid = DemoUseGrid;

    Object.defineProperty(exports, '__esModule', { value: true });

    return exports;

})({});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlcyI6WyJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvb3B0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2NyZWF0ZS1lbGVtZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvY3JlYXRlLWNvbnRleHQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9jb25zdGFudHMuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9zcmMvZGlmZi9wcm9wcy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3Qvc3JjL2RpZmYvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9yZW5kZXIuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L3NyYy9kaWZmL2NhdGNoLWVycm9yLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9qc3gtcnVudGltZS9zcmMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2hvb2tzL3NyYy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL1B1cmVDb21wb25lbnQuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvbWVtby5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9mb3J3YXJkUmVmLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL0NoaWxkcmVuLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLmpzIiwibm9kZV9tb2R1bGVzL3ByZWFjdC9jb21wYXQvc3JjL3N1c3BlbnNlLWxpc3QuanMiLCJub2RlX21vZHVsZXMvcHJlYWN0L2NvbXBhdC9zcmMvcG9ydGFscy5qcyIsIm5vZGVfbW9kdWxlcy9wcmVhY3QvY29tcGF0L3NyYy9yZW5kZXIuanMiLCIuLi9zcmMvdXNlLXBhc3NpdmUtc3RhdGUudHN4IiwiLi4vc3JjL3VzZS1hY3RpdmUtZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWJlZm9yZS1sYXlvdXQtZWZmZWN0LnRzeCIsIi4uL3NyYy91c2Utc3RhYmxlLWdldHRlci50c3giLCIuLi9zcmMvdXNlLXN0YWJsZS1jYWxsYmFjay50c3giLCIuLi9zcmMvdXNlLWFuaW1hdGlvbi1mcmFtZS50c3giLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzT2JqZWN0LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZnJlZUdsb2JhbC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3Jvb3QuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25vdy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3RyaW1tZWRFbmRJbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VUcmltLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fZ2V0UmF3VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fb2JqZWN0VG9TdHJpbmcuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlR2V0VGFnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc09iamVjdExpa2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzU3ltYm9sLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy90b051bWJlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZGVib3VuY2UuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3Rocm90dGxlLmpzIiwiLi4vc3JjL3VzZS1zdGF0ZS50c3giLCIuLi9zcmMvdXNlLWFzeW5jLnRzeCIsIi4uL3NyYy91c2UtYXN5bmMtaGFuZGxlci50c3giLCIuLi9zcmMvdXNlLWNoaWxkLW1hbmFnZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL2Nsc3gvZGlzdC9jbHN4Lm0uanMiLCIuLi9zcmMvdXNlLWRvY3VtZW50LWNsYXNzLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLWNoaWxkcmVuLnRzeCIsIi4uL3NyYy91c2UtbWVyZ2VkLWNsYXNzZXMudHN4IiwiLi4vc3JjL3VzZS1tZXJnZWQtcmVmcy50c3giLCIuLi9zcmMvdXNlLW1lcmdlZC1zdHlsZXMudHN4IiwiLi4vc3JjL3VzZS1tZXJnZWQtcHJvcHMudHN4IiwiLi4vc3JjL3VzZS1kcmFnZ2FibGUudHN4IiwiLi4vc3JjL3VzZS1kcm9wcGFibGUudHN4IiwiLi4vc3JjL3VzZS1yZWYtZWxlbWVudC50c3giLCIuLi9zcmMvdXNlLWVsZW1lbnQtc2l6ZS50c3giLCIuLi9zcmMvdXNlLWV2ZW50LWhhbmRsZXIudHN4IiwiLi4vbm9kZV9tb2R1bGVzL3RhYmJhYmxlL3NyYy9pbmRleC5qcyIsIi4uL25vZGVfbW9kdWxlcy93aWNnLWluZXJ0L2Rpc3QvaW5lcnQuanMiLCIuLi9ub2RlX21vZHVsZXMvYmxvY2tpbmctZWxlbWVudHMvc3JjL2Jsb2NraW5nLWVsZW1lbnRzLnRzIiwiLi4vc3JjL3VzZS1ibG9ja2luZy1lbGVtZW50LnRzeCIsIi4uL3NyYy91c2UtZm9jdXMtdHJhcC50c3giLCIuLi9zcmMvdXNlLWZvcmNlLXVwZGF0ZS50c3giLCIuLi9zcmMvdXNlLWhhcy1mb2N1cy50c3giLCIuLi9zcmMvdXNlLXRpbWVvdXQudHN4IiwiLi4vc3JjL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2Utcm92aW5nLXRhYmluZGV4LnRzeCIsIi4uL3NyYy91c2UtbGlzdC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2UtZ3JpZC1uYXZpZ2F0aW9uLnRzeCIsIi4uL3NyYy91c2UtaW50ZXJ2YWwudHN4IiwiLi4vc3JjL3VzZS1wcmVzcy50c3giLCIuLi9zcmMvdXNlLXNpbmdsZS1zZWxlY3Rpb24udHN4IiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY29weUFycmF5LmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVJhbmRvbS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX3NodWZmbGVTZWxmLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlTaHVmZmxlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYXJyYXlNYXAuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlVmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVRpbWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzQXJndW1lbnRzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FyZ3VtZW50cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvaXNBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvc3R1YkZhbHNlLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0J1ZmZlci5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2lzSW5kZXguanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2lzTGVuZ3RoLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzVHlwZWRBcnJheS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VVbmFyeS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX25vZGVVdGlsLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1R5cGVkQXJyYXkuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUxpa2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9faXNQcm90b3R5cGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19vdmVyQXJnLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fbmF0aXZlS2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VLZXlzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0Z1bmN0aW9uLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc0FycmF5TGlrZS5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMva2V5cy5qcyIsIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdmFsdWVzLmpzIiwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZVNodWZmbGUuanMiLCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NodWZmbGUuanMiLCIuLi9zcmMvdXNlLXNvcnRhYmxlLWNoaWxkcmVuLnRzeCIsIi4uL3NyYy91c2UtbGlzdC1uYXZpZ2F0aW9uLWRlcml2ZWQudHN4IiwiZGVtb3MvdXNlLWludGVydmFsLnRzeCIsImRlbW9zL3VzZS1yb3ZpbmctdGFiLWluZGV4LnRzeCIsImRlbW9zL3VzZS10aW1lb3V0LnRzeCIsImluZGV4LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFTVBUWV9BUlIgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcblxuLyoqXG4gKiBBc3NpZ24gcHJvcGVydGllcyBmcm9tIGBwcm9wc2AgdG8gYG9iamBcbiAqIEB0ZW1wbGF0ZSBPLCBQIFRoZSBvYmogYW5kIHByb3BzIHR5cGVzXG4gKiBAcGFyYW0ge099IG9iaiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0b1xuICogQHBhcmFtIHtQfSBwcm9wcyBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcmV0dXJucyB7TyAmIFB9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ24ob2JqLCBwcm9wcykge1xuXHQvLyBAdHMtaWdub3JlIFdlIGNoYW5nZSB0aGUgdHlwZSBvZiBgb2JqYCB0byBiZSBgTyAmIFBgXG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogUmVtb3ZlIGEgY2hpbGQgbm9kZSBmcm9tIGl0cyBwYXJlbnQgaWYgYXR0YWNoZWQuIFRoaXMgaXMgYSB3b3JrYXJvdW5kIGZvclxuICogSUUxMSB3aGljaCBkb2Vzbid0IHN1cHBvcnQgYEVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSgpYC4gVXNpbmcgdGhpcyBmdW5jdGlvblxuICogaXMgc21hbGxlciB0aGFuIGluY2x1ZGluZyBhIGRlZGljYXRlZCBwb2x5ZmlsbC5cbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUaGUgbm9kZSB0byByZW1vdmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGUobm9kZSkge1xuXHRsZXQgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcblx0aWYgKHBhcmVudE5vZGUpIHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG59XG5cbmV4cG9ydCBjb25zdCBzbGljZSA9IEVNUFRZX0FSUi5zbGljZTtcbiIsImltcG9ydCB7IF9jYXRjaEVycm9yIH0gZnJvbSAnLi9kaWZmL2NhdGNoLWVycm9yJztcblxuLyoqXG4gKiBUaGUgYG9wdGlvbmAgb2JqZWN0IGNhbiBwb3RlbnRpYWxseSBjb250YWluIGNhbGxiYWNrIGZ1bmN0aW9uc1xuICogdGhhdCBhcmUgY2FsbGVkIGR1cmluZyB2YXJpb3VzIHN0YWdlcyBvZiBvdXIgcmVuZGVyZXIuIFRoaXMgaXMgdGhlXG4gKiBmb3VuZGF0aW9uIG9uIHdoaWNoIGFsbCBvdXIgYWRkb25zIGxpa2UgYHByZWFjdC9kZWJ1Z2AsIGBwcmVhY3QvY29tcGF0YCxcbiAqIGFuZCBgcHJlYWN0L2hvb2tzYCBhcmUgYmFzZWQgb24uIFNlZSB0aGUgYE9wdGlvbnNgIHR5cGUgaW4gYGludGVybmFsLmQudHNgXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIG9wdGlvbiBob29rcyAobW9zdCBlZGl0b3JzL0lERXMgYWxsb3cgeW91IHRvXG4gKiBjdHJsK2NsaWNrIG9yIGNtZCtjbGljayBvbiBtYWMgdGhlIHR5cGUgZGVmaW5pdGlvbiBiZWxvdykuXG4gKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuT3B0aW9uc31cbiAqL1xuY29uc3Qgb3B0aW9ucyA9IHtcblx0X2NhdGNoRXJyb3Jcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG9wdGlvbnM7XG4iLCJpbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuL29wdGlvbnMnO1xuXG5sZXQgdm5vZGVJZCA9IDA7XG5cbi8qKlxuICogQ3JlYXRlIGFuIHZpcnR1YWwgbm9kZSAodXNlZCBmb3IgSlNYKVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIGNvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkfSBbcHJvcHNdIFRoZSBwcm9wZXJ0aWVzIG9mIHRoZSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuJykuQ29tcG9uZW50Q2hpbGRyZW4+fSBbY2hpbGRyZW5dIFRoZSBjaGlsZHJlbiBvZiB0aGUgdmlydHVhbCBub2RlXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRpO1xuXHRmb3IgKGkgaW4gcHJvcHMpIHtcblx0XHRpZiAoaSA9PSAna2V5Jykga2V5ID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBpZiAoaSA9PSAncmVmJykgcmVmID0gcHJvcHNbaV07XG5cdFx0ZWxzZSBub3JtYWxpemVkUHJvcHNbaV0gPSBwcm9wc1tpXTtcblx0fVxuXG5cdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuXHRcdG5vcm1hbGl6ZWRQcm9wcy5jaGlsZHJlbiA9XG5cdFx0XHRhcmd1bWVudHMubGVuZ3RoID4gMyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IGNoaWxkcmVuO1xuXHR9XG5cblx0Ly8gSWYgYSBDb21wb25lbnQgVk5vZGUsIGNoZWNrIGZvciBhbmQgYXBwbHkgZGVmYXVsdFByb3BzXG5cdC8vIE5vdGU6IHR5cGUgbWF5IGJlIHVuZGVmaW5lZCBpbiBkZXZlbG9wbWVudCwgbXVzdCBuZXZlciBlcnJvciBoZXJlLlxuXHRpZiAodHlwZW9mIHR5cGUgPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlLmRlZmF1bHRQcm9wcyAhPSBudWxsKSB7XG5cdFx0Zm9yIChpIGluIHR5cGUuZGVmYXVsdFByb3BzKSB7XG5cdFx0XHRpZiAobm9ybWFsaXplZFByb3BzW2ldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gdHlwZS5kZWZhdWx0UHJvcHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNyZWF0ZVZOb2RlKHR5cGUsIG5vcm1hbGl6ZWRQcm9wcywga2V5LCByZWYsIG51bGwpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZOb2RlICh1c2VkIGludGVybmFsbHkgYnkgUHJlYWN0KVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInR5cGVcIl19IHR5cGUgVGhlIG5vZGUgbmFtZSBvciBDb21wb25lbnRcbiAqIENvbnN0cnVjdG9yIGZvciB0aGlzIHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtvYmplY3QgfCBzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBwcm9wcyBUaGUgcHJvcGVydGllcyBvZiB0aGlzIHZpcnR1YWwgbm9kZS5cbiAqIElmIHRoaXMgdmlydHVhbCBub2RlIHJlcHJlc2VudHMgYSB0ZXh0IG5vZGUsIHRoaXMgaXMgdGhlIHRleHQgb2YgdGhlIG5vZGUgKHN0cmluZyBvciBudW1iZXIpLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXIgfCBudWxsfSBrZXkgVGhlIGtleSBmb3IgdGhpcyB2aXJ0dWFsIG5vZGUsIHVzZWQgd2hlblxuICogZGlmZmluZyBpdCBhZ2FpbnN0IGl0cyBjaGlsZHJlblxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZVtcInJlZlwiXX0gcmVmIFRoZSByZWYgcHJvcGVydHkgdGhhdCB3aWxsXG4gKiByZWNlaXZlIGEgcmVmZXJlbmNlIHRvIGl0cyBjcmVhdGVkIGNoaWxkXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVWTm9kZSh0eXBlLCBwcm9wcywga2V5LCByZWYsIG9yaWdpbmFsKSB7XG5cdC8vIFY4IHNlZW1zIHRvIGJlIGJldHRlciBhdCBkZXRlY3RpbmcgdHlwZSBzaGFwZXMgaWYgdGhlIG9iamVjdCBpcyBhbGxvY2F0ZWQgZnJvbSB0aGUgc2FtZSBjYWxsIHNpdGVcblx0Ly8gRG8gbm90IGlubGluZSBpbnRvIGNyZWF0ZUVsZW1lbnQgYW5kIGNvZXJjZVRvVk5vZGUhXG5cdGNvbnN0IHZub2RlID0ge1xuXHRcdHR5cGUsXG5cdFx0cHJvcHMsXG5cdFx0a2V5LFxuXHRcdHJlZixcblx0XHRfY2hpbGRyZW46IG51bGwsXG5cdFx0X3BhcmVudDogbnVsbCxcblx0XHRfZGVwdGg6IDAsXG5cdFx0X2RvbTogbnVsbCxcblx0XHQvLyBfbmV4dERvbSBtdXN0IGJlIGluaXRpYWxpemVkIHRvIHVuZGVmaW5lZCBiL2MgaXQgd2lsbCBldmVudHVhbGx5XG5cdFx0Ly8gYmUgc2V0IHRvIGRvbS5uZXh0U2libGluZyB3aGljaCBjYW4gcmV0dXJuIGBudWxsYCBhbmQgaXQgaXMgaW1wb3J0YW50XG5cdFx0Ly8gdG8gYmUgYWJsZSB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIGFuIHVuaW5pdGlhbGl6ZWQgX25leHREb20gYW5kXG5cdFx0Ly8gYSBfbmV4dERvbSB0aGF0IGhhcyBiZWVuIHNldCB0byBgbnVsbGBcblx0XHRfbmV4dERvbTogdW5kZWZpbmVkLFxuXHRcdF9jb21wb25lbnQ6IG51bGwsXG5cdFx0X2h5ZHJhdGluZzogbnVsbCxcblx0XHRjb25zdHJ1Y3RvcjogdW5kZWZpbmVkLFxuXHRcdF9vcmlnaW5hbDogb3JpZ2luYWwgPT0gbnVsbCA/ICsrdm5vZGVJZCA6IG9yaWdpbmFsXG5cdH07XG5cblx0Ly8gT25seSBpbnZva2UgdGhlIHZub2RlIGhvb2sgaWYgdGhpcyB3YXMgKm5vdCogYSBkaXJlY3QgY29weTpcblx0aWYgKG9yaWdpbmFsID09IG51bGwgJiYgb3B0aW9ucy52bm9kZSAhPSBudWxsKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSZWYoKSB7XG5cdHJldHVybiB7IGN1cnJlbnQ6IG51bGwgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIEZyYWdtZW50KHByb3BzKSB7XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIFByZWFjdCBWTm9kZS5cbiAqIEBwYXJhbSB7Kn0gdm5vZGVcbiAqIEByZXR1cm5zIHt2bm9kZSBpcyBpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlzVmFsaWRFbGVtZW50ID0gdm5vZGUgPT5cblx0dm5vZGUgIT0gbnVsbCAmJiB2bm9kZS5jb25zdHJ1Y3RvciA9PT0gdW5kZWZpbmVkO1xuIiwiaW1wb3J0IHsgYXNzaWduIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGRpZmYsIGNvbW1pdFJvb3QgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IG9wdGlvbnMgZnJvbSAnLi9vcHRpb25zJztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi9jcmVhdGUtZWxlbWVudCc7XG5cbi8qKlxuICogQmFzZSBDb21wb25lbnQgY2xhc3MuIFByb3ZpZGVzIGBzZXRTdGF0ZSgpYCBhbmQgYGZvcmNlVXBkYXRlKClgLCB3aGljaFxuICogdHJpZ2dlciByZW5kZXJpbmdcbiAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBUaGUgaW5pdGlhbCBjb21wb25lbnQgcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IFRoZSBpbml0aWFsIGNvbnRleHQgZnJvbSBwYXJlbnQgY29tcG9uZW50cydcbiAqIGdldENoaWxkQ29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XG5cdHRoaXMucHJvcHMgPSBwcm9wcztcblx0dGhpcy5jb250ZXh0ID0gY29udGV4dDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgY29tcG9uZW50IHN0YXRlIGFuZCBzY2hlZHVsZSBhIHJlLXJlbmRlci5cbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8ICgoczogb2JqZWN0LCBwOiBvYmplY3QpID0+IG9iamVjdCl9IHVwZGF0ZSBBIGhhc2ggb2Ygc3RhdGVcbiAqIHByb3BlcnRpZXMgdG8gdXBkYXRlIHdpdGggbmV3IHZhbHVlcyBvciBhIGZ1bmN0aW9uIHRoYXQgZ2l2ZW4gdGhlIGN1cnJlbnRcbiAqIHN0YXRlIGFuZCBwcm9wcyByZXR1cm5zIGEgbmV3IHBhcnRpYWwgc3RhdGVcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBvbmNlIGNvbXBvbmVudCBzdGF0ZSBpc1xuICogdXBkYXRlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24odXBkYXRlLCBjYWxsYmFjaykge1xuXHQvLyBvbmx5IGNsb25lIHN0YXRlIHdoZW4gY29weWluZyB0byBuZXh0U3RhdGUgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBzO1xuXHRpZiAodGhpcy5fbmV4dFN0YXRlICE9IG51bGwgJiYgdGhpcy5fbmV4dFN0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG5cdFx0cyA9IHRoaXMuX25leHRTdGF0ZTtcblx0fSBlbHNlIHtcblx0XHRzID0gdGhpcy5fbmV4dFN0YXRlID0gYXNzaWduKHt9LCB0aGlzLnN0YXRlKTtcblx0fVxuXG5cdGlmICh0eXBlb2YgdXBkYXRlID09ICdmdW5jdGlvbicpIHtcblx0XHQvLyBTb21lIGxpYnJhcmllcyBsaWtlIGBpbW1lcmAgbWFyayB0aGUgY3VycmVudCBzdGF0ZSBhcyByZWFkb25seSxcblx0XHQvLyBwcmV2ZW50aW5nIHVzIGZyb20gbXV0YXRpbmcgaXQsIHNvIHdlIG5lZWQgdG8gY2xvbmUgaXQuIFNlZSAjMjcxNlxuXHRcdHVwZGF0ZSA9IHVwZGF0ZShhc3NpZ24oe30sIHMpLCB0aGlzLnByb3BzKTtcblx0fVxuXG5cdGlmICh1cGRhdGUpIHtcblx0XHRhc3NpZ24ocywgdXBkYXRlKTtcblx0fVxuXG5cdC8vIFNraXAgdXBkYXRlIGlmIHVwZGF0ZXIgZnVuY3Rpb24gcmV0dXJuZWQgbnVsbFxuXHRpZiAodXBkYXRlID09IG51bGwpIHJldHVybjtcblxuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHRpZiAoY2FsbGJhY2spIHtcblx0XHRcdHRoaXMuX3N0YXRlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuXHRcdH1cblx0XHRlbnF1ZXVlUmVuZGVyKHRoaXMpO1xuXHR9XG59O1xuXG4vKipcbiAqIEltbWVkaWF0ZWx5IHBlcmZvcm0gYSBzeW5jaHJvbm91cyByZS1yZW5kZXIgb2YgdGhlIGNvbXBvbmVudFxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudH1cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBhZnRlciBjb21wb25lbnQgaXNcbiAqIHJlLXJlbmRlcmVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRpZiAodGhpcy5fdm5vZGUpIHtcblx0XHQvLyBTZXQgcmVuZGVyIG1vZGUgc28gdGhhdCB3ZSBjYW4gZGlmZmVyZW50aWF0ZSB3aGVyZSB0aGUgcmVuZGVyIHJlcXVlc3Rcblx0XHQvLyBpcyBjb21pbmcgZnJvbS4gV2UgbmVlZCB0aGlzIGJlY2F1c2UgZm9yY2VVcGRhdGUgc2hvdWxkIG5ldmVyIGNhbGxcblx0XHQvLyBzaG91bGRDb21wb25lbnRVcGRhdGVcblx0XHR0aGlzLl9mb3JjZSA9IHRydWU7XG5cdFx0aWYgKGNhbGxiYWNrKSB0aGlzLl9yZW5kZXJDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG5cdFx0ZW5xdWV1ZVJlbmRlcih0aGlzKTtcblx0fVxufTtcblxuLyoqXG4gKiBBY2NlcHRzIGBwcm9wc2AgYW5kIGBzdGF0ZWAsIGFuZCByZXR1cm5zIGEgbmV3IFZpcnR1YWwgRE9NIHRyZWUgdG8gYnVpbGQuXG4gKiBWaXJ0dWFsIERPTSBpcyBnZW5lcmFsbHkgY29uc3RydWN0ZWQgdmlhIFtKU1hdKGh0dHA6Ly9qYXNvbmZvcm1hdC5jb20vd3RmLWlzLWpzeCkuXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgUHJvcHMgKGVnOiBKU1ggYXR0cmlidXRlcykgcmVjZWl2ZWQgZnJvbSBwYXJlbnRcbiAqIGVsZW1lbnQvY29tcG9uZW50XG4gKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgVGhlIGNvbXBvbmVudCdzIGN1cnJlbnQgc3RhdGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0IENvbnRleHQgb2JqZWN0LCBhcyByZXR1cm5lZCBieSB0aGUgbmVhcmVzdFxuICogYW5jZXN0b3IncyBgZ2V0Q2hpbGRDb250ZXh0KClgXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuL2luZGV4JykuQ29tcG9uZW50Q2hpbGRyZW4gfCB2b2lkfVxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnJlbmRlciA9IEZyYWdtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKiBAcGFyYW0ge251bWJlciB8IG51bGx9IFtjaGlsZEluZGV4XVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RG9tU2libGluZyh2bm9kZSwgY2hpbGRJbmRleCkge1xuXHRpZiAoY2hpbGRJbmRleCA9PSBudWxsKSB7XG5cdFx0Ly8gVXNlIGNoaWxkSW5kZXg9PW51bGwgYXMgYSBzaWduYWwgdG8gcmVzdW1lIHRoZSBzZWFyY2ggZnJvbSB0aGUgdm5vZGUncyBzaWJsaW5nXG5cdFx0cmV0dXJuIHZub2RlLl9wYXJlbnRcblx0XHRcdD8gZ2V0RG9tU2libGluZyh2bm9kZS5fcGFyZW50LCB2bm9kZS5fcGFyZW50Ll9jaGlsZHJlbi5pbmRleE9mKHZub2RlKSArIDEpXG5cdFx0XHQ6IG51bGw7XG5cdH1cblxuXHRsZXQgc2libGluZztcblx0Zm9yICg7IGNoaWxkSW5kZXggPCB2bm9kZS5fY2hpbGRyZW4ubGVuZ3RoOyBjaGlsZEluZGV4KyspIHtcblx0XHRzaWJsaW5nID0gdm5vZGUuX2NoaWxkcmVuW2NoaWxkSW5kZXhdO1xuXG5cdFx0aWYgKHNpYmxpbmcgIT0gbnVsbCAmJiBzaWJsaW5nLl9kb20gIT0gbnVsbCkge1xuXHRcdFx0Ly8gU2luY2UgdXBkYXRlUGFyZW50RG9tUG9pbnRlcnMga2VlcHMgX2RvbSBwb2ludGVyIGNvcnJlY3QsXG5cdFx0XHQvLyB3ZSBjYW4gcmVseSBvbiBfZG9tIHRvIHRlbGwgdXMgaWYgdGhpcyBzdWJ0cmVlIGNvbnRhaW5zIGFcblx0XHRcdC8vIHJlbmRlcmVkIERPTSBub2RlLCBhbmQgd2hhdCB0aGUgZmlyc3QgcmVuZGVyZWQgRE9NIG5vZGUgaXNcblx0XHRcdHJldHVybiBzaWJsaW5nLl9kb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgZ2V0IGhlcmUsIHdlIGhhdmUgbm90IGZvdW5kIGEgRE9NIG5vZGUgaW4gdGhpcyB2bm9kZSdzIGNoaWxkcmVuLlxuXHQvLyBXZSBtdXN0IHJlc3VtZSBmcm9tIHRoaXMgdm5vZGUncyBzaWJsaW5nIChpbiBpdCdzIHBhcmVudCBfY2hpbGRyZW4gYXJyYXkpXG5cdC8vIE9ubHkgY2xpbWIgdXAgYW5kIHNlYXJjaCB0aGUgcGFyZW50IGlmIHdlIGFyZW4ndCBzZWFyY2hpbmcgdGhyb3VnaCBhIERPTVxuXHQvLyBWTm9kZSAobWVhbmluZyB3ZSByZWFjaGVkIHRoZSBET00gcGFyZW50IG9mIHRoZSBvcmlnaW5hbCB2bm9kZSB0aGF0IGJlZ2FuXG5cdC8vIHRoZSBzZWFyY2gpXG5cdHJldHVybiB0eXBlb2Ygdm5vZGUudHlwZSA9PSAnZnVuY3Rpb24nID8gZ2V0RG9tU2libGluZyh2bm9kZSkgOiBudWxsO1xufVxuXG4vKipcbiAqIFRyaWdnZXIgaW4tcGxhY2UgcmUtcmVuZGVyaW5nIG9mIGEgY29tcG9uZW50LlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9IGNvbXBvbmVudCBUaGUgY29tcG9uZW50IHRvIHJlcmVuZGVyXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckNvbXBvbmVudChjb21wb25lbnQpIHtcblx0bGV0IHZub2RlID0gY29tcG9uZW50Ll92bm9kZSxcblx0XHRvbGREb20gPSB2bm9kZS5fZG9tLFxuXHRcdHBhcmVudERvbSA9IGNvbXBvbmVudC5fcGFyZW50RG9tO1xuXG5cdGlmIChwYXJlbnREb20pIHtcblx0XHRsZXQgY29tbWl0UXVldWUgPSBbXTtcblx0XHRjb25zdCBvbGRWTm9kZSA9IGFzc2lnbih7fSwgdm5vZGUpO1xuXHRcdG9sZFZOb2RlLl9vcmlnaW5hbCA9IHZub2RlLl9vcmlnaW5hbCArIDE7XG5cblx0XHRkaWZmKFxuXHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0dm5vZGUsXG5cdFx0XHRvbGRWTm9kZSxcblx0XHRcdGNvbXBvbmVudC5fZ2xvYmFsQ29udGV4dCxcblx0XHRcdHBhcmVudERvbS5vd25lclNWR0VsZW1lbnQgIT09IHVuZGVmaW5lZCxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmcgIT0gbnVsbCA/IFtvbGREb21dIDogbnVsbCxcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tID09IG51bGwgPyBnZXREb21TaWJsaW5nKHZub2RlKSA6IG9sZERvbSxcblx0XHRcdHZub2RlLl9oeWRyYXRpbmdcblx0XHQpO1xuXHRcdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcblxuXHRcdGlmICh2bm9kZS5fZG9tICE9IG9sZERvbSkge1xuXHRcdFx0dXBkYXRlUGFyZW50RG9tUG9pbnRlcnModm5vZGUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuVk5vZGV9IHZub2RlXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZVBhcmVudERvbVBvaW50ZXJzKHZub2RlKSB7XG5cdGlmICgodm5vZGUgPSB2bm9kZS5fcGFyZW50KSAhPSBudWxsICYmIHZub2RlLl9jb21wb25lbnQgIT0gbnVsbCkge1xuXHRcdHZub2RlLl9kb20gPSB2bm9kZS5fY29tcG9uZW50LmJhc2UgPSBudWxsO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdm5vZGUuX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRsZXQgY2hpbGQgPSB2bm9kZS5fY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQgIT0gbnVsbCAmJiBjaGlsZC5fZG9tICE9IG51bGwpIHtcblx0XHRcdFx0dm5vZGUuX2RvbSA9IHZub2RlLl9jb21wb25lbnQuYmFzZSA9IGNoaWxkLl9kb207XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB1cGRhdGVQYXJlbnREb21Qb2ludGVycyh2bm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBUaGUgcmVuZGVyIHF1ZXVlXG4gKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Pn1cbiAqL1xubGV0IHJlcmVuZGVyUXVldWUgPSBbXTtcblxuLypcbiAqIFRoZSB2YWx1ZSBvZiBgQ29tcG9uZW50LmRlYm91bmNlYCBtdXN0IGFzeW5jaHJvbm91c2x5IGludm9rZSB0aGUgcGFzc2VkIGluIGNhbGxiYWNrLiBJdCBpc1xuICogaW1wb3J0YW50IHRoYXQgY29udHJpYnV0b3JzIHRvIFByZWFjdCBjYW4gY29uc2lzdGVudGx5IHJlYXNvbiBhYm91dCB3aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAsIGV0Yy5cbiAqIGRvLCBhbmQgd2hlbiB0aGVpciBlZmZlY3RzIHdpbGwgYmUgYXBwbGllZC4gU2VlIHRoZSBsaW5rcyBiZWxvdyBmb3Igc29tZSBmdXJ0aGVyIHJlYWRpbmcgb24gZGVzaWduaW5nXG4gKiBhc3luY2hyb25vdXMgQVBJcy5cbiAqICogW0Rlc2lnbmluZyBBUElzIGZvciBBc3luY2hyb255XShodHRwczovL2Jsb2cuaXpzLm1lLzIwMTMvMDgvZGVzaWduaW5nLWFwaXMtZm9yLWFzeW5jaHJvbnkpXG4gKiAqIFtDYWxsYmFja3Mgc3luY2hyb25vdXMgYW5kIGFzeW5jaHJvbm91c10oaHR0cHM6Ly9ibG9nLm9tZXRlci5jb20vMjAxMS8wNy8yNC9jYWxsYmFja3Mtc3luY2hyb25vdXMtYW5kLWFzeW5jaHJvbm91cy8pXG4gKi9cblxubGV0IHByZXZEZWJvdW5jZTtcblxuLyoqXG4gKiBFbnF1ZXVlIGEgcmVyZW5kZXIgb2YgYSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSBjIFRoZSBjb21wb25lbnQgdG8gcmVyZW5kZXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVucXVldWVSZW5kZXIoYykge1xuXHRpZiAoXG5cdFx0KCFjLl9kaXJ0eSAmJlxuXHRcdFx0KGMuX2RpcnR5ID0gdHJ1ZSkgJiZcblx0XHRcdHJlcmVuZGVyUXVldWUucHVzaChjKSAmJlxuXHRcdFx0IXByb2Nlc3MuX3JlcmVuZGVyQ291bnQrKykgfHxcblx0XHRwcmV2RGVib3VuY2UgIT09IG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmdcblx0KSB7XG5cdFx0cHJldkRlYm91bmNlID0gb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZztcblx0XHQocHJldkRlYm91bmNlIHx8IHNldFRpbWVvdXQpKHByb2Nlc3MpO1xuXHR9XG59XG5cbi8qKiBGbHVzaCB0aGUgcmVuZGVyIHF1ZXVlIGJ5IHJlcmVuZGVyaW5nIGFsbCBxdWV1ZWQgY29tcG9uZW50cyAqL1xuZnVuY3Rpb24gcHJvY2VzcygpIHtcblx0bGV0IHF1ZXVlO1xuXHR3aGlsZSAoKHByb2Nlc3MuX3JlcmVuZGVyQ291bnQgPSByZXJlbmRlclF1ZXVlLmxlbmd0aCkpIHtcblx0XHRxdWV1ZSA9IHJlcmVuZGVyUXVldWUuc29ydCgoYSwgYikgPT4gYS5fdm5vZGUuX2RlcHRoIC0gYi5fdm5vZGUuX2RlcHRoKTtcblx0XHRyZXJlbmRlclF1ZXVlID0gW107XG5cdFx0Ly8gRG9uJ3QgdXBkYXRlIGByZW5kZXJDb3VudGAgeWV0LiBLZWVwIGl0cyB2YWx1ZSBub24temVybyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5XG5cdFx0Ly8gcHJvY2VzcygpIGNhbGxzIGZyb20gZ2V0dGluZyBzY2hlZHVsZWQgd2hpbGUgYHF1ZXVlYCBpcyBzdGlsbCBiZWluZyBjb25zdW1lZC5cblx0XHRxdWV1ZS5zb21lKGMgPT4ge1xuXHRcdFx0aWYgKGMuX2RpcnR5KSByZW5kZXJDb21wb25lbnQoYyk7XG5cdFx0fSk7XG5cdH1cbn1cblxucHJvY2Vzcy5fcmVyZW5kZXJDb3VudCA9IDA7XG4iLCJpbXBvcnQgeyBlbnF1ZXVlUmVuZGVyIH0gZnJvbSAnLi9jb21wb25lbnQnO1xuXG5leHBvcnQgbGV0IGkgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIGNvbnRleHRJZCkge1xuXHRjb250ZXh0SWQgPSAnX19jQycgKyBpKys7XG5cblx0Y29uc3QgY29udGV4dCA9IHtcblx0XHRfaWQ6IGNvbnRleHRJZCxcblx0XHRfZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWUsXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gKi9cblx0XHRDb25zdW1lcihwcm9wcywgY29udGV4dFZhbHVlKSB7XG5cdFx0XHQvLyByZXR1cm4gcHJvcHMuY2hpbGRyZW4oXG5cdFx0XHQvLyBcdGNvbnRleHRbY29udGV4dElkXSA/IGNvbnRleHRbY29udGV4dElkXS5wcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZVxuXHRcdFx0Ly8gKTtcblx0XHRcdHJldHVybiBwcm9wcy5jaGlsZHJlbihjb250ZXh0VmFsdWUpO1xuXHRcdH0sXG5cdFx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH0gKi9cblx0XHRQcm92aWRlcihwcm9wcykge1xuXHRcdFx0aWYgKCF0aGlzLmdldENoaWxkQ29udGV4dCkge1xuXHRcdFx0XHRsZXQgc3VicyA9IFtdO1xuXHRcdFx0XHRsZXQgY3R4ID0ge307XG5cdFx0XHRcdGN0eFtjb250ZXh0SWRdID0gdGhpcztcblxuXHRcdFx0XHR0aGlzLmdldENoaWxkQ29udGV4dCA9ICgpID0+IGN0eDtcblxuXHRcdFx0XHR0aGlzLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uKF9wcm9wcykge1xuXHRcdFx0XHRcdGlmICh0aGlzLnByb3BzLnZhbHVlICE9PSBfcHJvcHMudmFsdWUpIHtcblx0XHRcdFx0XHRcdC8vIEkgdGhpbmsgdGhlIGZvcmNlZCB2YWx1ZSBwcm9wYWdhdGlvbiBoZXJlIHdhcyBvbmx5IG5lZWRlZCB3aGVuIGBvcHRpb25zLmRlYm91bmNlUmVuZGVyaW5nYCB3YXMgYmVpbmcgYnlwYXNzZWQ6XG5cdFx0XHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcHJlYWN0anMvcHJlYWN0L2NvbW1pdC80ZDMzOWZiODAzYmVhMDllOWYxOThhYmYzOGNhMWJmOGVhNGI3NzcxI2RpZmYtNTQ2ODJjZTM4MDkzNWE3MTdlNDFiOGJmYzU0NzM3ZjZSMzU4XG5cdFx0XHRcdFx0XHQvLyBJbiB0aG9zZSBjYXNlcyB0aG91Z2gsIGV2ZW4gd2l0aCB0aGUgdmFsdWUgY29ycmVjdGVkLCB3ZSdyZSBkb3VibGUtcmVuZGVyaW5nIGFsbCBub2Rlcy5cblx0XHRcdFx0XHRcdC8vIEl0IG1pZ2h0IGJlIGJldHRlciB0byBqdXN0IHRlbGwgZm9sa3Mgbm90IHRvIHVzZSBmb3JjZS1zeW5jIG1vZGUuXG5cdFx0XHRcdFx0XHQvLyBDdXJyZW50bHksIHVzaW5nIGB1c2VDb250ZXh0KClgIGluIGEgY2xhc3MgY29tcG9uZW50IHdpbGwgb3ZlcndyaXRlIGl0cyBgdGhpcy5jb250ZXh0YCB2YWx1ZS5cblx0XHRcdFx0XHRcdC8vIHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdC8vIFx0Yy5jb250ZXh0ID0gX3Byb3BzLnZhbHVlO1xuXHRcdFx0XHRcdFx0Ly8gXHRlbnF1ZXVlUmVuZGVyKGMpO1xuXHRcdFx0XHRcdFx0Ly8gfSk7XG5cblx0XHRcdFx0XHRcdC8vIHN1YnMuc29tZShjID0+IHtcblx0XHRcdFx0XHRcdC8vIFx0Yy5jb250ZXh0W2NvbnRleHRJZF0gPSBfcHJvcHMudmFsdWU7XG5cdFx0XHRcdFx0XHQvLyBcdGVucXVldWVSZW5kZXIoYyk7XG5cdFx0XHRcdFx0XHQvLyB9KTtcblx0XHRcdFx0XHRcdHN1YnMuc29tZShlbnF1ZXVlUmVuZGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0dGhpcy5zdWIgPSBjID0+IHtcblx0XHRcdFx0XHRzdWJzLnB1c2goYyk7XG5cdFx0XHRcdFx0bGV0IG9sZCA9IGMuY29tcG9uZW50V2lsbFVubW91bnQ7XG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsVW5tb3VudCA9ICgpID0+IHtcblx0XHRcdFx0XHRcdHN1YnMuc3BsaWNlKHN1YnMuaW5kZXhPZihjKSwgMSk7XG5cdFx0XHRcdFx0XHRpZiAob2xkKSBvbGQuY2FsbChjKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gcHJvcHMuY2hpbGRyZW47XG5cdFx0fVxuXHR9O1xuXG5cdC8vIERldnRvb2xzIG5lZWRzIGFjY2VzcyB0byB0aGUgY29udGV4dCBvYmplY3Qgd2hlbiBpdFxuXHQvLyBlbmNvdW50ZXJzIGEgUHJvdmlkZXIuIFRoaXMgaXMgbmVjZXNzYXJ5IHRvIHN1cHBvcnRcblx0Ly8gc2V0dGluZyBgZGlzcGxheU5hbWVgIG9uIHRoZSBjb250ZXh0IG9iamVjdCBpbnN0ZWFkXG5cdC8vIG9mIG9uIHRoZSBjb21wb25lbnQgaXRzZWxmLiBTZWU6XG5cdC8vIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwjY29udGV4dGRpc3BsYXluYW1lXG5cblx0cmV0dXJuIChjb250ZXh0LlByb3ZpZGVyLl9jb250ZXh0UmVmID0gY29udGV4dC5Db25zdW1lci5jb250ZXh0VHlwZSA9IGNvbnRleHQpO1xufVxuIiwiZXhwb3J0IGNvbnN0IEVNUFRZX09CSiA9IHt9O1xuZXhwb3J0IGNvbnN0IEVNUFRZX0FSUiA9IFtdO1xuZXhwb3J0IGNvbnN0IElTX05PTl9ESU1FTlNJT05BTCA9IC9hY2l0fGV4KD86c3xnfG58cHwkKXxycGh8Z3JpZHxvd3N8bW5jfG50d3xpbmVbY2hdfHpvb3xeb3JkfGl0ZXJhL2k7XG4iLCJpbXBvcnQgeyBkaWZmLCB1bm1vdW50LCBhcHBseVJlZiB9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlVk5vZGUsIEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgRU1QVFlfT0JKLCBFTVBUWV9BUlIgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0RG9tU2libGluZyB9IGZyb20gJy4uL2NvbXBvbmVudCc7XG5cbi8qKlxuICogRGlmZiB0aGUgY2hpbGRyZW4gb2YgYSB2aXJ0dWFsIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgd2hvc2VcbiAqIGNoaWxkcmVuIGFyZSBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkcmVuW119IHJlbmRlclJlc3VsdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG5ld1BhcmVudFZOb2RlIFRoZSBuZXcgdmlydHVhbFxuICogbm9kZSB3aG9zZSBjaGlsZHJlbiBzaG91bGQgYmUgZGlmZidlZCBhZ2FpbnN0IG9sZFBhcmVudFZOb2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gb2xkUGFyZW50Vk5vZGUgVGhlIG9sZCB2aXJ0dWFsXG4gKiBub2RlIHdob3NlIGNoaWxkcmVuIHNob3VsZCBiZSBkaWZmJ2VkIGFnYWluc3QgbmV3UGFyZW50Vk5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBnbG9iYWxDb250ZXh0IFRoZSBjdXJyZW50IGNvbnRleHQgb2JqZWN0IC0gbW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgRE9NIG5vZGUgaXMgYW4gU1ZHIG5vZGVcbiAqIEBwYXJhbSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQ+fSBleGNlc3NEb21DaGlsZHJlblxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuQ29tcG9uZW50Pn0gY29tbWl0UXVldWUgTGlzdCBvZiBjb21wb25lbnRzXG4gKiB3aGljaCBoYXZlIGNhbGxiYWNrcyB0byBpbnZva2UgaW4gY29tbWl0Um9vdFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gb2xkRG9tIFRoZSBjdXJyZW50IGF0dGFjaGVkIERPTVxuICogZWxlbWVudCBhbnkgbmV3IGRvbSBlbGVtZW50cyBzaG91bGQgYmUgcGxhY2VkIGFyb3VuZC4gTGlrZWx5IGBudWxsYCBvbiBmaXJzdFxuICogcmVuZGVyIChleGNlcHQgd2hlbiBoeWRyYXRpbmcpLiBDYW4gYmUgYSBzaWJsaW5nIERPTSBlbGVtZW50IHdoZW4gZGlmZmluZ1xuICogRnJhZ21lbnRzIHRoYXQgaGF2ZSBzaWJsaW5ncy4gSW4gbW9zdCBjYXNlcywgaXQgc3RhcnRzIG91dCBhcyBgb2xkQ2hpbGRyZW5bMF0uX2RvbWAuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpZmZDaGlsZHJlbihcblx0cGFyZW50RG9tLFxuXHRyZW5kZXJSZXN1bHQsXG5cdG5ld1BhcmVudFZOb2RlLFxuXHRvbGRQYXJlbnRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCBpLCBqLCBvbGRWTm9kZSwgY2hpbGRWTm9kZSwgbmV3RG9tLCBmaXJzdENoaWxkRG9tLCByZWZzO1xuXG5cdC8vIFRoaXMgaXMgYSBjb21wcmVzc2lvbiBvZiBvbGRQYXJlbnRWTm9kZSE9bnVsbCAmJiBvbGRQYXJlbnRWTm9kZSAhPSBFTVBUWV9PQkogJiYgb2xkUGFyZW50Vk5vZGUuX2NoaWxkcmVuIHx8IEVNUFRZX0FSUlxuXHQvLyBhcyBFTVBUWV9PQkouX2NoaWxkcmVuIHNob3VsZCBiZSBgdW5kZWZpbmVkYC5cblx0bGV0IG9sZENoaWxkcmVuID0gKG9sZFBhcmVudFZOb2RlICYmIG9sZFBhcmVudFZOb2RlLl9jaGlsZHJlbikgfHwgRU1QVFlfQVJSO1xuXG5cdGxldCBvbGRDaGlsZHJlbkxlbmd0aCA9IG9sZENoaWxkcmVuLmxlbmd0aDtcblxuXHRuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW4gPSBbXTtcblx0Zm9yIChpID0gMDsgaSA8IHJlbmRlclJlc3VsdC5sZW5ndGg7IGkrKykge1xuXHRcdGNoaWxkVk5vZGUgPSByZW5kZXJSZXN1bHRbaV07XG5cblx0XHRpZiAoY2hpbGRWTm9kZSA9PSBudWxsIHx8IHR5cGVvZiBjaGlsZFZOb2RlID09ICdib29sZWFuJykge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IG51bGw7XG5cdFx0fVxuXHRcdC8vIElmIHRoaXMgbmV3Vk5vZGUgaXMgYmVpbmcgcmV1c2VkIChlLmcuIDxkaXY+e3JldXNlfXtyZXVzZX08L2Rpdj4pIGluIHRoZSBzYW1lIGRpZmYsXG5cdFx0Ly8gb3Igd2UgYXJlIHJlbmRlcmluZyBhIGNvbXBvbmVudCAoZS5nLiBzZXRTdGF0ZSkgY29weSB0aGUgb2xkVk5vZGVzIHNvIGl0IGNhbiBoYXZlXG5cdFx0Ly8gaXQncyBvd24gRE9NICYgZXRjLiBwb2ludGVyc1xuXHRcdGVsc2UgaWYgKFxuXHRcdFx0dHlwZW9mIGNoaWxkVk5vZGUgPT0gJ3N0cmluZycgfHxcblx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlID09ICdudW1iZXInIHx8XG5cdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdmFsaWQtdHlwZW9mXG5cdFx0XHR0eXBlb2YgY2hpbGRWTm9kZSA9PSAnYmlnaW50J1xuXHRcdCkge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNyZWF0ZVZOb2RlKFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRjaGlsZFZOb2RlXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZFZOb2RlKSkge1xuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNyZWF0ZVZOb2RlKFxuXHRcdFx0XHRGcmFnbWVudCxcblx0XHRcdFx0eyBjaGlsZHJlbjogY2hpbGRWTm9kZSB9LFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRudWxsXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSBpZiAoY2hpbGRWTm9kZS5fZGVwdGggPiAwKSB7XG5cdFx0XHQvLyBWTm9kZSBpcyBhbHJlYWR5IGluIHVzZSwgY2xvbmUgaXQuIFRoaXMgY2FuIGhhcHBlbiBpbiB0aGUgZm9sbG93aW5nXG5cdFx0XHQvLyBzY2VuYXJpbzpcblx0XHRcdC8vICAgY29uc3QgcmV1c2UgPSA8ZGl2IC8+XG5cdFx0XHQvLyAgIDxkaXY+e3JldXNlfTxzcGFuIC8+e3JldXNlfTwvZGl2PlxuXHRcdFx0Y2hpbGRWTm9kZSA9IG5ld1BhcmVudFZOb2RlLl9jaGlsZHJlbltpXSA9IGNyZWF0ZVZOb2RlKFxuXHRcdFx0XHRjaGlsZFZOb2RlLnR5cGUsXG5cdFx0XHRcdGNoaWxkVk5vZGUucHJvcHMsXG5cdFx0XHRcdGNoaWxkVk5vZGUua2V5LFxuXHRcdFx0XHRjaGlsZFZOb2RlLnJlZiA/IGNoaWxkVk5vZGUucmVmIDogbnVsbCxcblx0XHRcdFx0Y2hpbGRWTm9kZS5fb3JpZ2luYWxcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoaWxkVk5vZGUgPSBuZXdQYXJlbnRWTm9kZS5fY2hpbGRyZW5baV0gPSBjaGlsZFZOb2RlO1xuXHRcdH1cblxuXHRcdC8vIFRlcnNlciByZW1vdmVzIHRoZSBgY29udGludWVgIGhlcmUgYW5kIHdyYXBzIHRoZSBsb29wIGJvZHlcblx0XHQvLyBpbiBhIGBpZiAoY2hpbGRWTm9kZSkgeyAuLi4gfSBjb25kaXRpb25cblx0XHRpZiAoY2hpbGRWTm9kZSA9PSBudWxsKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRjaGlsZFZOb2RlLl9wYXJlbnQgPSBuZXdQYXJlbnRWTm9kZTtcblx0XHRjaGlsZFZOb2RlLl9kZXB0aCA9IG5ld1BhcmVudFZOb2RlLl9kZXB0aCArIDE7XG5cblx0XHQvLyBDaGVjayBpZiB3ZSBmaW5kIGEgY29ycmVzcG9uZGluZyBlbGVtZW50IGluIG9sZENoaWxkcmVuLlxuXHRcdC8vIElmIGZvdW5kLCBkZWxldGUgdGhlIGFycmF5IGl0ZW0gYnkgc2V0dGluZyB0byBgdW5kZWZpbmVkYC5cblx0XHQvLyBXZSB1c2UgYHVuZGVmaW5lZGAsIGFzIGBudWxsYCBpcyByZXNlcnZlZCBmb3IgZW1wdHkgcGxhY2Vob2xkZXJzXG5cdFx0Ly8gKGhvbGVzKS5cblx0XHRvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2ldO1xuXG5cdFx0aWYgKFxuXHRcdFx0b2xkVk5vZGUgPT09IG51bGwgfHxcblx0XHRcdChvbGRWTm9kZSAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLmtleSA9PSBvbGRWTm9kZS5rZXkgJiZcblx0XHRcdFx0Y2hpbGRWTm9kZS50eXBlID09PSBvbGRWTm9kZS50eXBlKVxuXHRcdCkge1xuXHRcdFx0b2xkQ2hpbGRyZW5baV0gPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEVpdGhlciBvbGRWTm9kZSA9PT0gdW5kZWZpbmVkIG9yIG9sZENoaWxkcmVuTGVuZ3RoID4gMCxcblx0XHRcdC8vIHNvIGFmdGVyIHRoaXMgbG9vcCBvbGRWTm9kZSA9PSBudWxsIG9yIG9sZFZOb2RlIGlzIGEgdmFsaWQgdmFsdWUuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgb2xkQ2hpbGRyZW5MZW5ndGg7IGorKykge1xuXHRcdFx0XHRvbGRWTm9kZSA9IG9sZENoaWxkcmVuW2pdO1xuXHRcdFx0XHQvLyBJZiBjaGlsZFZOb2RlIGlzIHVua2V5ZWQsIHdlIG9ubHkgbWF0Y2ggc2ltaWxhcmx5IHVua2V5ZWQgbm9kZXMsIG90aGVyd2lzZSB3ZSBtYXRjaCBieSBrZXkuXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBtYXRjaCBieSB0eXBlIChpbiBlaXRoZXIgY2FzZSkuXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRvbGRWTm9kZSAmJlxuXHRcdFx0XHRcdGNoaWxkVk5vZGUua2V5ID09IG9sZFZOb2RlLmtleSAmJlxuXHRcdFx0XHRcdGNoaWxkVk5vZGUudHlwZSA9PT0gb2xkVk5vZGUudHlwZVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRvbGRDaGlsZHJlbltqXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRvbGRWTm9kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0b2xkVk5vZGUgPSBvbGRWTm9kZSB8fCBFTVBUWV9PQko7XG5cblx0XHQvLyBNb3JwaCB0aGUgb2xkIGVsZW1lbnQgaW50byB0aGUgbmV3IG9uZSwgYnV0IGRvbid0IGFwcGVuZCBpdCB0byB0aGUgZG9tIHlldFxuXHRcdGRpZmYoXG5cdFx0XHRwYXJlbnREb20sXG5cdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRnbG9iYWxDb250ZXh0LFxuXHRcdFx0aXNTdmcsXG5cdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0b2xkRG9tLFxuXHRcdFx0aXNIeWRyYXRpbmdcblx0XHQpO1xuXG5cdFx0bmV3RG9tID0gY2hpbGRWTm9kZS5fZG9tO1xuXG5cdFx0aWYgKChqID0gY2hpbGRWTm9kZS5yZWYpICYmIG9sZFZOb2RlLnJlZiAhPSBqKSB7XG5cdFx0XHRpZiAoIXJlZnMpIHJlZnMgPSBbXTtcblx0XHRcdGlmIChvbGRWTm9kZS5yZWYpIHJlZnMucHVzaChvbGRWTm9kZS5yZWYsIG51bGwsIGNoaWxkVk5vZGUpO1xuXHRcdFx0cmVmcy5wdXNoKGosIGNoaWxkVk5vZGUuX2NvbXBvbmVudCB8fCBuZXdEb20sIGNoaWxkVk5vZGUpO1xuXHRcdH1cblxuXHRcdGlmIChuZXdEb20gIT0gbnVsbCkge1xuXHRcdFx0aWYgKGZpcnN0Q2hpbGREb20gPT0gbnVsbCkge1xuXHRcdFx0XHRmaXJzdENoaWxkRG9tID0gbmV3RG9tO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHR5cGVvZiBjaGlsZFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdFx0XHRjaGlsZFZOb2RlLl9jaGlsZHJlbiA9PT0gb2xkVk5vZGUuX2NoaWxkcmVuXG5cdFx0XHQpIHtcblx0XHRcdFx0Y2hpbGRWTm9kZS5fbmV4dERvbSA9IG9sZERvbSA9IHJlb3JkZXJDaGlsZHJlbihcblx0XHRcdFx0XHRjaGlsZFZOb2RlLFxuXHRcdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0XHRwYXJlbnREb21cblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZERvbSA9IHBsYWNlQ2hpbGQoXG5cdFx0XHRcdFx0cGFyZW50RG9tLFxuXHRcdFx0XHRcdGNoaWxkVk5vZGUsXG5cdFx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdFx0b2xkQ2hpbGRyZW4sXG5cdFx0XHRcdFx0bmV3RG9tLFxuXHRcdFx0XHRcdG9sZERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodHlwZW9mIG5ld1BhcmVudFZOb2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvLyBCZWNhdXNlIHRoZSBuZXdQYXJlbnRWTm9kZSBpcyBGcmFnbWVudC1saWtlLCB3ZSBuZWVkIHRvIHNldCBpdCdzXG5cdFx0XHRcdC8vIF9uZXh0RG9tIHByb3BlcnR5IHRvIHRoZSBuZXh0U2libGluZyBvZiBpdHMgbGFzdCBjaGlsZCBET00gbm9kZS5cblx0XHRcdFx0Ly9cblx0XHRcdFx0Ly8gYG9sZERvbWAgY29udGFpbnMgdGhlIGNvcnJlY3QgdmFsdWUgaGVyZSBiZWNhdXNlIGlmIHRoZSBsYXN0IGNoaWxkXG5cdFx0XHRcdC8vIGlzIGEgRnJhZ21lbnQtbGlrZSwgdGhlbiBvbGREb20gaGFzIGFscmVhZHkgYmVlbiBzZXQgdG8gdGhhdCBjaGlsZCdzIF9uZXh0RG9tLlxuXHRcdFx0XHQvLyBJZiB0aGUgbGFzdCBjaGlsZCBpcyBhIERPTSBWTm9kZSwgdGhlbiBvbGREb20gd2lsbCBiZSBzZXQgdG8gdGhhdCBET01cblx0XHRcdFx0Ly8gbm9kZSdzIG5leHRTaWJsaW5nLlxuXHRcdFx0XHRuZXdQYXJlbnRWTm9kZS5fbmV4dERvbSA9IG9sZERvbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0b2xkRG9tICYmXG5cdFx0XHRvbGRWTm9kZS5fZG9tID09IG9sZERvbSAmJlxuXHRcdFx0b2xkRG9tLnBhcmVudE5vZGUgIT0gcGFyZW50RG9tXG5cdFx0KSB7XG5cdFx0XHQvLyBUaGUgYWJvdmUgY29uZGl0aW9uIGlzIHRvIGhhbmRsZSBudWxsIHBsYWNlaG9sZGVycy4gU2VlIHRlc3QgaW4gcGxhY2Vob2xkZXIudGVzdC5qczpcblx0XHRcdC8vIGBlZmZpY2llbnRseSByZXBsYWNlIG51bGwgcGxhY2Vob2xkZXJzIGluIHBhcmVudCByZXJlbmRlcnNgXG5cdFx0XHRvbGREb20gPSBnZXREb21TaWJsaW5nKG9sZFZOb2RlKTtcblx0XHR9XG5cdH1cblxuXHRuZXdQYXJlbnRWTm9kZS5fZG9tID0gZmlyc3RDaGlsZERvbTtcblxuXHQvLyBSZW1vdmUgcmVtYWluaW5nIG9sZENoaWxkcmVuIGlmIHRoZXJlIGFyZSBhbnkuXG5cdGZvciAoaSA9IG9sZENoaWxkcmVuTGVuZ3RoOyBpLS07ICkge1xuXHRcdGlmIChvbGRDaGlsZHJlbltpXSAhPSBudWxsKSB7XG5cdFx0XHR1bm1vdW50KG9sZENoaWxkcmVuW2ldLCBvbGRDaGlsZHJlbltpXSk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHJlZnMgb25seSBhZnRlciB1bm1vdW50XG5cdGlmIChyZWZzKSB7XG5cdFx0Zm9yIChpID0gMDsgaSA8IHJlZnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGFwcGx5UmVmKHJlZnNbaV0sIHJlZnNbKytpXSwgcmVmc1srK2ldKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVvcmRlckNoaWxkcmVuKGNoaWxkVk5vZGUsIG9sZERvbSwgcGFyZW50RG9tKSB7XG5cdC8vIE5vdGU6IFZOb2RlcyBpbiBuZXN0ZWQgc3VzcGVuZGVkIHRyZWVzIG1heSBiZSBtaXNzaW5nIF9jaGlsZHJlbi5cblx0bGV0IGMgPSBjaGlsZFZOb2RlLl9jaGlsZHJlbjtcblx0bGV0IHRtcCA9IDA7XG5cdGZvciAoOyBjICYmIHRtcCA8IGMubGVuZ3RoOyB0bXArKykge1xuXHRcdGxldCB2bm9kZSA9IGNbdG1wXTtcblx0XHRpZiAodm5vZGUpIHtcblx0XHRcdC8vIFdlIHR5cGljYWxseSBlbnRlciB0aGlzIGNvZGUgcGF0aCBvbiBzQ1UgYmFpbG91dCwgd2hlcmUgd2UgY29weVxuXHRcdFx0Ly8gb2xkVk5vZGUuX2NoaWxkcmVuIHRvIG5ld1ZOb2RlLl9jaGlsZHJlbi4gSWYgdGhhdCBpcyB0aGUgY2FzZSwgd2UgbmVlZFxuXHRcdFx0Ly8gdG8gdXBkYXRlIHRoZSBvbGQgY2hpbGRyZW4ncyBfcGFyZW50IHBvaW50ZXIgdG8gcG9pbnQgdG8gdGhlIG5ld1ZOb2RlXG5cdFx0XHQvLyAoY2hpbGRWTm9kZSBoZXJlKS5cblx0XHRcdHZub2RlLl9wYXJlbnQgPSBjaGlsZFZOb2RlO1xuXG5cdFx0XHRpZiAodHlwZW9mIHZub2RlLnR5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRvbGREb20gPSByZW9yZGVyQ2hpbGRyZW4odm5vZGUsIG9sZERvbSwgcGFyZW50RG9tKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZERvbSA9IHBsYWNlQ2hpbGQocGFyZW50RG9tLCB2bm9kZSwgdm5vZGUsIGMsIHZub2RlLl9kb20sIG9sZERvbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG9sZERvbTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGFuZCBsb29wIHRocm91Z2ggdGhlIGNoaWxkcmVuIG9mIGEgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW5kZXgnKS5Db21wb25lbnRDaGlsZHJlbn0gY2hpbGRyZW4gVGhlIHVuZmxhdHRlbmVkXG4gKiBjaGlsZHJlbiBvZiBhIHZpcnR1YWwgbm9kZVxuICogQHJldHVybnMge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZVtdfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9DaGlsZEFycmF5KGNoaWxkcmVuLCBvdXQpIHtcblx0b3V0ID0gb3V0IHx8IFtdO1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCB8fCB0eXBlb2YgY2hpbGRyZW4gPT0gJ2Jvb2xlYW4nKSB7XG5cdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcblx0XHRjaGlsZHJlbi5zb21lKGNoaWxkID0+IHtcblx0XHRcdHRvQ2hpbGRBcnJheShjaGlsZCwgb3V0KTtcblx0XHR9KTtcblx0fSBlbHNlIHtcblx0XHRvdXQucHVzaChjaGlsZHJlbik7XG5cdH1cblx0cmV0dXJuIG91dDtcbn1cblxuZnVuY3Rpb24gcGxhY2VDaGlsZChcblx0cGFyZW50RG9tLFxuXHRjaGlsZFZOb2RlLFxuXHRvbGRWTm9kZSxcblx0b2xkQ2hpbGRyZW4sXG5cdG5ld0RvbSxcblx0b2xkRG9tXG4pIHtcblx0bGV0IG5leHREb207XG5cdGlmIChjaGlsZFZOb2RlLl9uZXh0RG9tICE9PSB1bmRlZmluZWQpIHtcblx0XHQvLyBPbmx5IEZyYWdtZW50cyBvciBjb21wb25lbnRzIHRoYXQgcmV0dXJuIEZyYWdtZW50IGxpa2UgVk5vZGVzIHdpbGxcblx0XHQvLyBoYXZlIGEgbm9uLXVuZGVmaW5lZCBfbmV4dERvbS4gQ29udGludWUgdGhlIGRpZmYgZnJvbSB0aGUgc2libGluZ1xuXHRcdC8vIG9mIGxhc3QgRE9NIGNoaWxkIG9mIHRoaXMgY2hpbGQgVk5vZGVcblx0XHRuZXh0RG9tID0gY2hpbGRWTm9kZS5fbmV4dERvbTtcblxuXHRcdC8vIEVhZ2VybHkgY2xlYW51cCBfbmV4dERvbS4gV2UgZG9uJ3QgbmVlZCB0byBwZXJzaXN0IHRoZSB2YWx1ZSBiZWNhdXNlXG5cdFx0Ly8gaXQgaXMgb25seSB1c2VkIGJ5IGBkaWZmQ2hpbGRyZW5gIHRvIGRldGVybWluZSB3aGVyZSB0byByZXN1bWUgdGhlIGRpZmYgYWZ0ZXJcblx0XHQvLyBkaWZmaW5nIENvbXBvbmVudHMgYW5kIEZyYWdtZW50cy4gT25jZSB3ZSBzdG9yZSBpdCB0aGUgbmV4dERPTSBsb2NhbCB2YXIsIHdlXG5cdFx0Ly8gY2FuIGNsZWFuIHVwIHRoZSBwcm9wZXJ0eVxuXHRcdGNoaWxkVk5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG5cdH0gZWxzZSBpZiAoXG5cdFx0b2xkVk5vZGUgPT0gbnVsbCB8fFxuXHRcdG5ld0RvbSAhPSBvbGREb20gfHxcblx0XHRuZXdEb20ucGFyZW50Tm9kZSA9PSBudWxsXG5cdCkge1xuXHRcdG91dGVyOiBpZiAob2xkRG9tID09IG51bGwgfHwgb2xkRG9tLnBhcmVudE5vZGUgIT09IHBhcmVudERvbSkge1xuXHRcdFx0cGFyZW50RG9tLmFwcGVuZENoaWxkKG5ld0RvbSk7XG5cdFx0XHRuZXh0RG9tID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gYGo8b2xkQ2hpbGRyZW5MZW5ndGg7IGorPTJgIGlzIGFuIGFsdGVybmF0aXZlIHRvIGBqKys8b2xkQ2hpbGRyZW5MZW5ndGgvMmBcblx0XHRcdGZvciAoXG5cdFx0XHRcdGxldCBzaWJEb20gPSBvbGREb20sIGogPSAwO1xuXHRcdFx0XHQoc2liRG9tID0gc2liRG9tLm5leHRTaWJsaW5nKSAmJiBqIDwgb2xkQ2hpbGRyZW4ubGVuZ3RoO1xuXHRcdFx0XHRqICs9IDJcblx0XHRcdCkge1xuXHRcdFx0XHRpZiAoc2liRG9tID09IG5ld0RvbSkge1xuXHRcdFx0XHRcdGJyZWFrIG91dGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnREb20uaW5zZXJ0QmVmb3JlKG5ld0RvbSwgb2xkRG9tKTtcblx0XHRcdG5leHREb20gPSBvbGREb207XG5cdFx0fVxuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBwcmUtY2FsY3VsYXRlZCB0aGUgbmV4dERPTSBub2RlLCB1c2UgaXQuIEVsc2UgY2FsY3VsYXRlIGl0IG5vd1xuXHQvLyBTdHJpY3RseSBjaGVjayBmb3IgYHVuZGVmaW5lZGAgaGVyZSBjdXogYG51bGxgIGlzIGEgdmFsaWQgdmFsdWUgb2YgYG5leHREb21gLlxuXHQvLyBTZWUgbW9yZSBkZXRhaWwgaW4gY3JlYXRlLWVsZW1lbnQuanM6Y3JlYXRlVk5vZGVcblx0aWYgKG5leHREb20gIT09IHVuZGVmaW5lZCkge1xuXHRcdG9sZERvbSA9IG5leHREb207XG5cdH0gZWxzZSB7XG5cdFx0b2xkRG9tID0gbmV3RG9tLm5leHRTaWJsaW5nO1xuXHR9XG5cblx0cmV0dXJuIG9sZERvbTtcbn1cbiIsImltcG9ydCB7IElTX05PTl9ESU1FTlNJT05BTCB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHRoZSBvbGQgYW5kIG5ldyBwcm9wZXJ0aWVzIG9mIGEgVk5vZGUgYW5kIGFwcGx5IGNoYW5nZXMgdG8gdGhlIERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBkb20gVGhlIERPTSBub2RlIHRvIGFwcGx5XG4gKiBjaGFuZ2VzIHRvXG4gKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHMgVGhlIG5ldyBwcm9wc1xuICogQHBhcmFtIHtvYmplY3R9IG9sZFByb3BzIFRoZSBvbGQgcHJvcHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNTdmcgV2hldGhlciBvciBub3QgdGhpcyBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGh5ZHJhdGUgV2hldGhlciBvciBub3Qgd2UgYXJlIGluIGh5ZHJhdGlvbiBtb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmUHJvcHMoZG9tLCBuZXdQcm9wcywgb2xkUHJvcHMsIGlzU3ZnLCBoeWRyYXRlKSB7XG5cdGxldCBpO1xuXG5cdGZvciAoaSBpbiBvbGRQcm9wcykge1xuXHRcdGlmIChpICE9PSAnY2hpbGRyZW4nICYmIGkgIT09ICdrZXknICYmICEoaSBpbiBuZXdQcm9wcykpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbnVsbCwgb2xkUHJvcHNbaV0sIGlzU3ZnKTtcblx0XHR9XG5cdH1cblxuXHRmb3IgKGkgaW4gbmV3UHJvcHMpIHtcblx0XHRpZiAoXG5cdFx0XHQoIWh5ZHJhdGUgfHwgdHlwZW9mIG5ld1Byb3BzW2ldID09ICdmdW5jdGlvbicpICYmXG5cdFx0XHRpICE9PSAnY2hpbGRyZW4nICYmXG5cdFx0XHRpICE9PSAna2V5JyAmJlxuXHRcdFx0aSAhPT0gJ3ZhbHVlJyAmJlxuXHRcdFx0aSAhPT0gJ2NoZWNrZWQnICYmXG5cdFx0XHRvbGRQcm9wc1tpXSAhPT0gbmV3UHJvcHNbaV1cblx0XHQpIHtcblx0XHRcdHNldFByb3BlcnR5KGRvbSwgaSwgbmV3UHJvcHNbaV0sIG9sZFByb3BzW2ldLCBpc1N2Zyk7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHNldFN0eWxlKHN0eWxlLCBrZXksIHZhbHVlKSB7XG5cdGlmIChrZXlbMF0gPT09ICctJykge1xuXHRcdHN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUpO1xuXHR9IGVsc2UgaWYgKHZhbHVlID09IG51bGwpIHtcblx0XHRzdHlsZVtrZXldID0gJyc7XG5cdH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlICE9ICdudW1iZXInIHx8IElTX05PTl9ESU1FTlNJT05BTC50ZXN0KGtleSkpIHtcblx0XHRzdHlsZVtrZXldID0gdmFsdWU7XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGVba2V5XSA9IHZhbHVlICsgJ3B4Jztcblx0fVxufVxuXG4vKipcbiAqIFNldCBhIHByb3BlcnR5IHZhbHVlIG9uIGEgRE9NIG5vZGVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIG5vZGUgdG8gbW9kaWZ5XG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gc2V0XG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHByb3BlcnR5IHRvXG4gKiBAcGFyYW0geyp9IG9sZFZhbHVlIFRoZSBvbGQgdmFsdWUgdGhlIHByb3BlcnR5IGhhZFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlIG9yIG5vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvcGVydHkoZG9tLCBuYW1lLCB2YWx1ZSwgb2xkVmFsdWUsIGlzU3ZnKSB7XG5cdGxldCB1c2VDYXB0dXJlO1xuXG5cdG86IGlmIChuYW1lID09PSAnc3R5bGUnKSB7XG5cdFx0aWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0ZG9tLnN0eWxlLmNzc1RleHQgPSB2YWx1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHR5cGVvZiBvbGRWYWx1ZSA9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRkb20uc3R5bGUuY3NzVGV4dCA9IG9sZFZhbHVlID0gJyc7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvbGRWYWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gb2xkVmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoISh2YWx1ZSAmJiBuYW1lIGluIHZhbHVlKSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCAnJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICh2YWx1ZSkge1xuXHRcdFx0XHRmb3IgKG5hbWUgaW4gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoIW9sZFZhbHVlIHx8IHZhbHVlW25hbWVdICE9PSBvbGRWYWx1ZVtuYW1lXSkge1xuXHRcdFx0XHRcdFx0c2V0U3R5bGUoZG9tLnN0eWxlLCBuYW1lLCB2YWx1ZVtuYW1lXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdC8vIEJlbmNobWFyayBmb3IgY29tcGFyaXNvbjogaHR0cHM6Ly9lc2JlbmNoLmNvbS9iZW5jaC81NzRjOTU0YmRiOTY1YjlhMDA5NjVhYzZcblx0ZWxzZSBpZiAobmFtZVswXSA9PT0gJ28nICYmIG5hbWVbMV0gPT09ICduJykge1xuXHRcdHVzZUNhcHR1cmUgPSBuYW1lICE9PSAobmFtZSA9IG5hbWUucmVwbGFjZSgvQ2FwdHVyZSQvLCAnJykpO1xuXG5cdFx0Ly8gSW5mZXIgY29ycmVjdCBjYXNpbmcgZm9yIERPTSBidWlsdC1pbiBldmVudHM6XG5cdFx0aWYgKG5hbWUudG9Mb3dlckNhc2UoKSBpbiBkb20pIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMik7XG5cdFx0ZWxzZSBuYW1lID0gbmFtZS5zbGljZSgyKTtcblxuXHRcdGlmICghZG9tLl9saXN0ZW5lcnMpIGRvbS5fbGlzdGVuZXJzID0ge307XG5cdFx0ZG9tLl9saXN0ZW5lcnNbbmFtZSArIHVzZUNhcHR1cmVdID0gdmFsdWU7XG5cblx0XHRpZiAodmFsdWUpIHtcblx0XHRcdGlmICghb2xkVmFsdWUpIHtcblx0XHRcdFx0Y29uc3QgaGFuZGxlciA9IHVzZUNhcHR1cmUgPyBldmVudFByb3h5Q2FwdHVyZSA6IGV2ZW50UHJveHk7XG5cdFx0XHRcdGRvbS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBoYW5kbGVyID0gdXNlQ2FwdHVyZSA/IGV2ZW50UHJveHlDYXB0dXJlIDogZXZlbnRQcm94eTtcblx0XHRcdGRvbS5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIsIHVzZUNhcHR1cmUpO1xuXHRcdH1cblx0fSBlbHNlIGlmIChuYW1lICE9PSAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnKSB7XG5cdFx0aWYgKGlzU3ZnKSB7XG5cdFx0XHQvLyBOb3JtYWxpemUgaW5jb3JyZWN0IHByb3AgdXNhZ2UgZm9yIFNWRzpcblx0XHRcdC8vIC0geGxpbms6aHJlZiAvIHhsaW5rSHJlZiAtLT4gaHJlZiAoeGxpbms6aHJlZiB3YXMgcmVtb3ZlZCBmcm9tIFNWRyBhbmQgaXNuJ3QgbmVlZGVkKVxuXHRcdFx0Ly8gLSBjbGFzc05hbWUgLS0+IGNsYXNzXG5cdFx0XHRuYW1lID0gbmFtZS5yZXBsYWNlKC94bGluayhIfDpoKS8sICdoJykucmVwbGFjZSgvc05hbWUkLywgJ3MnKTtcblx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0bmFtZSAhPT0gJ2hyZWYnICYmXG5cdFx0XHRuYW1lICE9PSAnbGlzdCcgJiZcblx0XHRcdG5hbWUgIT09ICdmb3JtJyAmJlxuXHRcdFx0Ly8gRGVmYXVsdCB2YWx1ZSBpbiBicm93c2VycyBpcyBgLTFgIGFuZCBhbiBlbXB0eSBzdHJpbmcgaXNcblx0XHRcdC8vIGNhc3QgdG8gYDBgIGluc3RlYWRcblx0XHRcdG5hbWUgIT09ICd0YWJJbmRleCcgJiZcblx0XHRcdG5hbWUgIT09ICdkb3dubG9hZCcgJiZcblx0XHRcdG5hbWUgaW4gZG9tXG5cdFx0KSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkb21bbmFtZV0gPSB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcblx0XHRcdFx0Ly8gbGFiZWxsZWQgYnJlYWsgaXMgMWIgc21hbGxlciBoZXJlIHRoYW4gYSByZXR1cm4gc3RhdGVtZW50IChzb3JyeSlcblx0XHRcdFx0YnJlYWsgbztcblx0XHRcdH0gY2F0Y2ggKGUpIHt9XG5cdFx0fVxuXG5cdFx0Ly8gQVJJQS1hdHRyaWJ1dGVzIGhhdmUgYSBkaWZmZXJlbnQgbm90aW9uIG9mIGJvb2xlYW4gdmFsdWVzLlxuXHRcdC8vIFRoZSB2YWx1ZSBgZmFsc2VgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhdHRyaWJ1dGUgbm90XG5cdFx0Ly8gZXhpc3Rpbmcgb24gdGhlIERPTSwgc28gd2UgY2FuJ3QgcmVtb3ZlIGl0LiBGb3Igbm9uLWJvb2xlYW5cblx0XHQvLyBBUklBLWF0dHJpYnV0ZXMgd2UgY291bGQgdHJlYXQgZmFsc2UgYXMgYSByZW1vdmFsLCBidXQgdGhlXG5cdFx0Ly8gYW1vdW50IG9mIGV4Y2VwdGlvbnMgd291bGQgY29zdCB1cyB0b28gbWFueSBieXRlcy4gT24gdG9wIG9mXG5cdFx0Ly8gdGhhdCBvdGhlciBWRE9NIGZyYW1ld29ya3MgYWxzbyBhbHdheXMgc3RyaW5naWZ5IGBmYWxzZWAuXG5cblx0XHRpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHQvLyBuZXZlciBzZXJpYWxpemUgZnVuY3Rpb25zIGFzIGF0dHJpYnV0ZSB2YWx1ZXNcblx0XHR9IGVsc2UgaWYgKHZhbHVlICE9IG51bGwgJiYgKHZhbHVlICE9PSBmYWxzZSB8fCBuYW1lLmluZGV4T2YoJy0nKSAhPSAtMSkpIHtcblx0XHRcdGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkb20ucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIFByb3h5IGFuIGV2ZW50IHRvIGhvb2tlZCBldmVudCBoYW5kbGVyc1xuICogQHBhcmFtIHtFdmVudH0gZSBUaGUgZXZlbnQgb2JqZWN0IGZyb20gdGhlIGJyb3dzZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50UHJveHkoZSkge1xuXHR0aGlzLl9saXN0ZW5lcnNbZS50eXBlICsgZmFsc2VdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG59XG5cbmZ1bmN0aW9uIGV2ZW50UHJveHlDYXB0dXJlKGUpIHtcblx0dGhpcy5fbGlzdGVuZXJzW2UudHlwZSArIHRydWVdKG9wdGlvbnMuZXZlbnQgPyBvcHRpb25zLmV2ZW50KGUpIDogZSk7XG59XG4iLCJpbXBvcnQgeyBFTVBUWV9PQkogfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBnZXREb21TaWJsaW5nIH0gZnJvbSAnLi4vY29tcG9uZW50JztcbmltcG9ydCB7IEZyYWdtZW50IH0gZnJvbSAnLi4vY3JlYXRlLWVsZW1lbnQnO1xuaW1wb3J0IHsgZGlmZkNoaWxkcmVuIH0gZnJvbSAnLi9jaGlsZHJlbic7XG5pbXBvcnQgeyBkaWZmUHJvcHMsIHNldFByb3BlcnR5IH0gZnJvbSAnLi9wcm9wcyc7XG5pbXBvcnQgeyBhc3NpZ24sIHJlbW92ZU5vZGUsIHNsaWNlIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgb3B0aW9ucyBmcm9tICcuLi9vcHRpb25zJztcblxuLyoqXG4gKiBEaWZmIHR3byB2aXJ0dWFsIG5vZGVzIGFuZCBhcHBseSBwcm9wZXIgY2hhbmdlcyB0byB0aGUgRE9NXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIHBhcmVudCBvZiB0aGUgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdC4gTW9kaWZpZWQgYnkgZ2V0Q2hpbGRDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3ZnIFdoZXRoZXIgb3Igbm90IHRoaXMgZWxlbWVudCBpcyBhbiBTVkcgbm9kZVxuICogQHBhcmFtIHtBcnJheTxpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudD59IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBvbGREb20gVGhlIGN1cnJlbnQgYXR0YWNoZWQgRE9NXG4gKiBlbGVtZW50IGFueSBuZXcgZG9tIGVsZW1lbnRzIHNob3VsZCBiZSBwbGFjZWQgYXJvdW5kLiBMaWtlbHkgYG51bGxgIG9uIGZpcnN0XG4gKiByZW5kZXIgKGV4Y2VwdCB3aGVuIGh5ZHJhdGluZykuIENhbiBiZSBhIHNpYmxpbmcgRE9NIGVsZW1lbnQgd2hlbiBkaWZmaW5nXG4gKiBGcmFnbWVudHMgdGhhdCBoYXZlIHNpYmxpbmdzLiBJbiBtb3N0IGNhc2VzLCBpdCBzdGFydHMgb3V0IGFzIGBvbGRDaGlsZHJlblswXS5fZG9tYC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzSHlkcmF0aW5nXSBXaGV0aGVyIG9yIG5vdCB3ZSBhcmUgaW4gaHlkcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaWZmKFxuXHRwYXJlbnREb20sXG5cdG5ld1ZOb2RlLFxuXHRvbGRWTm9kZSxcblx0Z2xvYmFsQ29udGV4dCxcblx0aXNTdmcsXG5cdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRjb21taXRRdWV1ZSxcblx0b2xkRG9tLFxuXHRpc0h5ZHJhdGluZ1xuKSB7XG5cdGxldCB0bXAsXG5cdFx0bmV3VHlwZSA9IG5ld1ZOb2RlLnR5cGU7XG5cblx0Ly8gV2hlbiBwYXNzaW5nIHRocm91Z2ggY3JlYXRlRWxlbWVudCBpdCBhc3NpZ25zIHRoZSBvYmplY3Rcblx0Ly8gY29uc3RydWN0b3IgYXMgdW5kZWZpbmVkLiBUaGlzIHRvIHByZXZlbnQgSlNPTi1pbmplY3Rpb24uXG5cdGlmIChuZXdWTm9kZS5jb25zdHJ1Y3RvciAhPT0gdW5kZWZpbmVkKSByZXR1cm4gbnVsbDtcblxuXHQvLyBJZiB0aGUgcHJldmlvdXMgZGlmZiBiYWlsZWQgb3V0LCByZXN1bWUgY3JlYXRpbmcvaHlkcmF0aW5nLlxuXHRpZiAob2xkVk5vZGUuX2h5ZHJhdGluZyAhPSBudWxsKSB7XG5cdFx0aXNIeWRyYXRpbmcgPSBvbGRWTm9kZS5faHlkcmF0aW5nO1xuXHRcdG9sZERvbSA9IG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdC8vIGlmIHdlIHJlc3VtZSwgd2Ugd2FudCB0aGUgdHJlZSB0byBiZSBcInVubG9ja2VkXCJcblx0XHRuZXdWTm9kZS5faHlkcmF0aW5nID0gbnVsbDtcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IFtvbGREb21dO1xuXHR9XG5cblx0aWYgKCh0bXAgPSBvcHRpb25zLl9kaWZmKSkgdG1wKG5ld1ZOb2RlKTtcblxuXHR0cnkge1xuXHRcdG91dGVyOiBpZiAodHlwZW9mIG5ld1R5cGUgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0bGV0IGMsIGlzTmV3LCBvbGRQcm9wcywgb2xkU3RhdGUsIHNuYXBzaG90LCBjbGVhclByb2Nlc3NpbmdFeGNlcHRpb247XG5cdFx0XHRsZXQgbmV3UHJvcHMgPSBuZXdWTm9kZS5wcm9wcztcblxuXHRcdFx0Ly8gTmVjZXNzYXJ5IGZvciBjcmVhdGVDb250ZXh0IGFwaS4gU2V0dGluZyB0aGlzIHByb3BlcnR5IHdpbGwgcGFzc1xuXHRcdFx0Ly8gdGhlIGNvbnRleHQgdmFsdWUgYXMgYHRoaXMuY29udGV4dGAganVzdCBmb3IgdGhpcyBjb21wb25lbnQuXG5cdFx0XHR0bXAgPSBuZXdUeXBlLmNvbnRleHRUeXBlO1xuXHRcdFx0bGV0IHByb3ZpZGVyID0gdG1wICYmIGdsb2JhbENvbnRleHRbdG1wLl9pZF07XG5cdFx0XHRsZXQgY29tcG9uZW50Q29udGV4dCA9IHRtcFxuXHRcdFx0XHQ/IHByb3ZpZGVyXG5cdFx0XHRcdFx0PyBwcm92aWRlci5wcm9wcy52YWx1ZVxuXHRcdFx0XHRcdDogdG1wLl9kZWZhdWx0VmFsdWVcblx0XHRcdFx0OiBnbG9iYWxDb250ZXh0O1xuXG5cdFx0XHQvLyBHZXQgY29tcG9uZW50IGFuZCBzZXQgaXQgdG8gYGNgXG5cdFx0XHRpZiAob2xkVk5vZGUuX2NvbXBvbmVudCkge1xuXHRcdFx0XHRjID0gbmV3Vk5vZGUuX2NvbXBvbmVudCA9IG9sZFZOb2RlLl9jb21wb25lbnQ7XG5cdFx0XHRcdGNsZWFyUHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IGMuX3Byb2Nlc3NpbmdFeGNlcHRpb24gPSBjLl9wZW5kaW5nRXJyb3I7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBJbnN0YW50aWF0ZSB0aGUgbmV3IGNvbXBvbmVudFxuXHRcdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRoZSBjaGVjayBhYm92ZSB2ZXJpZmllcyB0aGF0IG5ld1R5cGUgaXMgc3VwcG9zZSB0byBiZSBjb25zdHJ1Y3RlZFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jb21wb25lbnQgPSBjID0gbmV3IG5ld1R5cGUobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdHMtaWdub3JlIFRydXN0IG1lLCBDb21wb25lbnQgaW1wbGVtZW50cyB0aGUgaW50ZXJmYWNlIHdlIHdhbnRcblx0XHRcdFx0XHRuZXdWTm9kZS5fY29tcG9uZW50ID0gYyA9IG5ldyBDb21wb25lbnQobmV3UHJvcHMsIGNvbXBvbmVudENvbnRleHQpO1xuXHRcdFx0XHRcdGMuY29uc3RydWN0b3IgPSBuZXdUeXBlO1xuXHRcdFx0XHRcdGMucmVuZGVyID0gZG9SZW5kZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHByb3ZpZGVyKSBwcm92aWRlci5zdWIoYyk7XG5cblx0XHRcdFx0Yy5wcm9wcyA9IG5ld1Byb3BzO1xuXHRcdFx0XHRpZiAoIWMuc3RhdGUpIGMuc3RhdGUgPSB7fTtcblx0XHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdFx0Yy5fZ2xvYmFsQ29udGV4dCA9IGdsb2JhbENvbnRleHQ7XG5cdFx0XHRcdGlzTmV3ID0gYy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdFx0Yy5fc3RhdGVDYWxsYmFja3MgPSBbXTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW52b2tlIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc1xuXHRcdFx0aWYgKGMuX25leHRTdGF0ZSA9PSBudWxsKSB7XG5cdFx0XHRcdGMuX25leHRTdGF0ZSA9IGMuc3RhdGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT0gbnVsbCkge1xuXHRcdFx0XHRpZiAoYy5fbmV4dFN0YXRlID09IGMuc3RhdGUpIHtcblx0XHRcdFx0XHRjLl9uZXh0U3RhdGUgPSBhc3NpZ24oe30sIGMuX25leHRTdGF0ZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRhc3NpZ24oXG5cdFx0XHRcdFx0Yy5fbmV4dFN0YXRlLFxuXHRcdFx0XHRcdG5ld1R5cGUuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKG5ld1Byb3BzLCBjLl9uZXh0U3RhdGUpXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdG9sZFByb3BzID0gYy5wcm9wcztcblx0XHRcdG9sZFN0YXRlID0gYy5zdGF0ZTtcblxuXHRcdFx0Zm9yICh0bXAgPSAwOyB0bXAgPCBjLl9zdGF0ZUNhbGxiYWNrcy5sZW5ndGg7IHRtcCsrKSB7XG5cdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuX3N0YXRlQ2FsbGJhY2tzW3RtcF0pO1xuXHRcdFx0XHRjLl9zdGF0ZUNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbnZva2UgcHJlLXJlbmRlciBsaWZlY3ljbGUgbWV0aG9kc1xuXHRcdFx0aWYgKGlzTmV3KSB7XG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHRuZXdUeXBlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PSBudWxsICYmXG5cdFx0XHRcdFx0Yy5jb21wb25lbnRXaWxsTW91bnQgIT0gbnVsbFxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRjLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGMuY29tcG9uZW50RGlkTW91bnQgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuX3JlbmRlckNhbGxiYWNrcy5wdXNoKGMuY29tcG9uZW50RGlkTW91bnQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0bmV3VHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT0gbnVsbCAmJlxuXHRcdFx0XHRcdG5ld1Byb3BzICE9PSBvbGRQcm9wcyAmJlxuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyAhPSBudWxsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgY29tcG9uZW50Q29udGV4dCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0KCFjLl9mb3JjZSAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUgIT0gbnVsbCAmJlxuXHRcdFx0XHRcdFx0Yy5zaG91bGRDb21wb25lbnRVcGRhdGUoXG5cdFx0XHRcdFx0XHRcdG5ld1Byb3BzLFxuXHRcdFx0XHRcdFx0XHRjLl9uZXh0U3RhdGUsXG5cdFx0XHRcdFx0XHRcdGNvbXBvbmVudENvbnRleHRcblx0XHRcdFx0XHRcdCkgPT09IGZhbHNlKSB8fFxuXHRcdFx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdFx0XHRjLnN0YXRlID0gYy5fbmV4dFN0YXRlO1xuXHRcdFx0XHRcdC8vIE1vcmUgaW5mbyBhYm91dCB0aGlzIGhlcmU6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL0pvdmlEZUNyb29jay9iZWM1ZjJjZTkzNTQ0ZDJlNjA3MGVmOGUwMDM2ZTRlOFxuXHRcdFx0XHRcdGlmIChuZXdWTm9kZS5fb3JpZ2luYWwgIT09IG9sZFZOb2RlLl9vcmlnaW5hbCkgYy5fZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0XHRjLl92bm9kZSA9IG5ld1ZOb2RlO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9kb20gPSBvbGRWTm9kZS5fZG9tO1xuXHRcdFx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IG9sZFZOb2RlLl9jaGlsZHJlbjtcblx0XHRcdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4uZm9yRWFjaCh2bm9kZSA9PiB7XG5cdFx0XHRcdFx0XHRpZiAodm5vZGUpIHZub2RlLl9wYXJlbnQgPSBuZXdWTm9kZTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRpZiAoYy5fcmVuZGVyQ2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRcdFx0Y29tbWl0UXVldWUucHVzaChjKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhayBvdXRlcjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudFdpbGxVcGRhdGUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGMuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgYy5fbmV4dFN0YXRlLCBjb21wb25lbnRDb250ZXh0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChjLmNvbXBvbmVudERpZFVwZGF0ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Yy5fcmVuZGVyQ2FsbGJhY2tzLnB1c2goKCkgPT4ge1xuXHRcdFx0XHRcdFx0Yy5jb21wb25lbnREaWRVcGRhdGUob2xkUHJvcHMsIG9sZFN0YXRlLCBzbmFwc2hvdCk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Yy5jb250ZXh0ID0gY29tcG9uZW50Q29udGV4dDtcblx0XHRcdGMucHJvcHMgPSBuZXdQcm9wcztcblx0XHRcdGMuX3Zub2RlID0gbmV3Vk5vZGU7XG5cdFx0XHRjLl9wYXJlbnREb20gPSBwYXJlbnREb207XG5cblx0XHRcdGxldCByZW5kZXJIb29rID0gb3B0aW9ucy5fcmVuZGVyLFxuXHRcdFx0XHRjb3VudCA9IDA7XG5cdFx0XHRpZiAoJ3Byb3RvdHlwZScgaW4gbmV3VHlwZSAmJiBuZXdUeXBlLnByb3RvdHlwZS5yZW5kZXIpIHtcblx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0Yy5fZGlydHkgPSBmYWxzZTtcblxuXHRcdFx0XHRpZiAocmVuZGVySG9vaykgcmVuZGVySG9vayhuZXdWTm9kZSk7XG5cblx0XHRcdFx0dG1wID0gYy5yZW5kZXIoYy5wcm9wcywgYy5zdGF0ZSwgYy5jb250ZXh0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjLl9kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHRcdGlmIChyZW5kZXJIb29rKSByZW5kZXJIb29rKG5ld1ZOb2RlKTtcblxuXHRcdFx0XHRcdHRtcCA9IGMucmVuZGVyKGMucHJvcHMsIGMuc3RhdGUsIGMuY29udGV4dCk7XG5cblx0XHRcdFx0XHQvLyBIYW5kbGUgc2V0U3RhdGUgY2FsbGVkIGluIHJlbmRlciwgc2VlICMyNTUzXG5cdFx0XHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblx0XHRcdFx0fSB3aGlsZSAoYy5fZGlydHkgJiYgKytjb3VudCA8IDI1KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSGFuZGxlIHNldFN0YXRlIGNhbGxlZCBpbiByZW5kZXIsIHNlZSAjMjU1M1xuXHRcdFx0Yy5zdGF0ZSA9IGMuX25leHRTdGF0ZTtcblxuXHRcdFx0aWYgKGMuZ2V0Q2hpbGRDb250ZXh0ICE9IG51bGwpIHtcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCA9IGFzc2lnbihhc3NpZ24oe30sIGdsb2JhbENvbnRleHQpLCBjLmdldENoaWxkQ29udGV4dCgpKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFpc05ldyAmJiBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9IG51bGwpIHtcblx0XHRcdFx0c25hcHNob3QgPSBjLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKG9sZFByb3BzLCBvbGRTdGF0ZSk7XG5cdFx0XHR9XG5cblx0XHRcdGxldCBpc1RvcExldmVsRnJhZ21lbnQgPVxuXHRcdFx0XHR0bXAgIT0gbnVsbCAmJiB0bXAudHlwZSA9PT0gRnJhZ21lbnQgJiYgdG1wLmtleSA9PSBudWxsO1xuXHRcdFx0bGV0IHJlbmRlclJlc3VsdCA9IGlzVG9wTGV2ZWxGcmFnbWVudCA/IHRtcC5wcm9wcy5jaGlsZHJlbiA6IHRtcDtcblxuXHRcdFx0ZGlmZkNoaWxkcmVuKFxuXHRcdFx0XHRwYXJlbnREb20sXG5cdFx0XHRcdEFycmF5LmlzQXJyYXkocmVuZGVyUmVzdWx0KSA/IHJlbmRlclJlc3VsdCA6IFtyZW5kZXJSZXN1bHRdLFxuXHRcdFx0XHRuZXdWTm9kZSxcblx0XHRcdFx0b2xkVk5vZGUsXG5cdFx0XHRcdGdsb2JhbENvbnRleHQsXG5cdFx0XHRcdGlzU3ZnLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlbixcblx0XHRcdFx0Y29tbWl0UXVldWUsXG5cdFx0XHRcdG9sZERvbSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdGMuYmFzZSA9IG5ld1ZOb2RlLl9kb207XG5cblx0XHRcdC8vIFdlIHN1Y2Nlc3NmdWxseSByZW5kZXJlZCB0aGlzIFZOb2RlLCB1bnNldCBhbnkgc3RvcmVkIGh5ZHJhdGlvbi9iYWlsb3V0IHN0YXRlOlxuXHRcdFx0bmV3Vk5vZGUuX2h5ZHJhdGluZyA9IG51bGw7XG5cblx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MubGVuZ3RoKSB7XG5cdFx0XHRcdGNvbW1pdFF1ZXVlLnB1c2goYyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChjbGVhclByb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdFx0Yy5fcGVuZGluZ0Vycm9yID0gYy5fcHJvY2Vzc2luZ0V4Y2VwdGlvbiA9IG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGMuX2ZvcmNlID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID09IG51bGwgJiZcblx0XHRcdG5ld1ZOb2RlLl9vcmlnaW5hbCA9PT0gb2xkVk5vZGUuX29yaWdpbmFsXG5cdFx0KSB7XG5cdFx0XHRuZXdWTm9kZS5fY2hpbGRyZW4gPSBvbGRWTm9kZS5fY2hpbGRyZW47XG5cdFx0XHRuZXdWTm9kZS5fZG9tID0gb2xkVk5vZGUuX2RvbTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IGRpZmZFbGVtZW50Tm9kZXMoXG5cdFx0XHRcdG9sZFZOb2RlLl9kb20sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcsXG5cdFx0XHRcdGV4Y2Vzc0RvbUNoaWxkcmVuLFxuXHRcdFx0XHRjb21taXRRdWV1ZSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKCh0bXAgPSBvcHRpb25zLmRpZmZlZCkpIHRtcChuZXdWTm9kZSk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRuZXdWTm9kZS5fb3JpZ2luYWwgPSBudWxsO1xuXHRcdC8vIGlmIGh5ZHJhdGluZyBvciBjcmVhdGluZyBpbml0aWFsIHRyZWUsIGJhaWxvdXQgcHJlc2VydmVzIERPTTpcblx0XHRpZiAoaXNIeWRyYXRpbmcgfHwgZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZERvbTtcblx0XHRcdG5ld1ZOb2RlLl9oeWRyYXRpbmcgPSAhIWlzSHlkcmF0aW5nO1xuXHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5bZXhjZXNzRG9tQ2hpbGRyZW4uaW5kZXhPZihvbGREb20pXSA9IG51bGw7XG5cdFx0XHQvLyBeIGNvdWxkIHBvc3NpYmx5IGJlIHNpbXBsaWZpZWQgdG86XG5cdFx0XHQvLyBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGggPSAwO1xuXHRcdH1cblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIG5ld1ZOb2RlLCBvbGRWTm9kZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gcm9vdFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tbWl0Um9vdChjb21taXRRdWV1ZSwgcm9vdCkge1xuXHRpZiAob3B0aW9ucy5fY29tbWl0KSBvcHRpb25zLl9jb21taXQocm9vdCwgY29tbWl0UXVldWUpO1xuXG5cdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgUmV1c2UgdGhlIGNvbW1pdFF1ZXVlIHZhcmlhYmxlIGhlcmUgc28gdGhlIHR5cGUgY2hhbmdlc1xuXHRcdFx0Y29tbWl0UXVldWUgPSBjLl9yZW5kZXJDYWxsYmFja3M7XG5cdFx0XHRjLl9yZW5kZXJDYWxsYmFja3MgPSBbXTtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoY2IgPT4ge1xuXHRcdFx0XHQvLyBAdHMtaWdub3JlIFNlZSBhYm92ZSB0cy1pZ25vcmUgb24gY29tbWl0UXVldWVcblx0XHRcdFx0Y2IuY2FsbChjKTtcblx0XHRcdH0pO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgYy5fdm5vZGUpO1xuXHRcdH1cblx0fSk7XG59XG5cbi8qKlxuICogRGlmZiB0d28gdmlydHVhbCBub2RlcyByZXByZXNlbnRpbmcgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGRvbSBUaGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nXG4gKiB0aGUgdmlydHVhbCBub2RlcyBiZWluZyBkaWZmZWRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBuZXdWTm9kZSBUaGUgbmV3IHZpcnR1YWwgbm9kZVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IG9sZFZOb2RlIFRoZSBvbGQgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZ2xvYmFsQ29udGV4dCBUaGUgY3VycmVudCBjb250ZXh0IG9iamVjdFxuICogQHBhcmFtIHtib29sZWFufSBpc1N2ZyBXaGV0aGVyIG9yIG5vdCB0aGlzIERPTSBub2RlIGlzIGFuIFNWRyBub2RlXG4gKiBAcGFyYW0geyp9IGV4Y2Vzc0RvbUNoaWxkcmVuXG4gKiBAcGFyYW0ge0FycmF5PGltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSBjb21taXRRdWV1ZSBMaXN0IG9mIGNvbXBvbmVudHNcbiAqIHdoaWNoIGhhdmUgY2FsbGJhY2tzIHRvIGludm9rZSBpbiBjb21taXRSb290XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlzSHlkcmF0aW5nIFdoZXRoZXIgb3Igbm90IHdlIGFyZSBpbiBoeWRyYXRpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZGlmZkVsZW1lbnROb2Rlcyhcblx0ZG9tLFxuXHRuZXdWTm9kZSxcblx0b2xkVk5vZGUsXG5cdGdsb2JhbENvbnRleHQsXG5cdGlzU3ZnLFxuXHRleGNlc3NEb21DaGlsZHJlbixcblx0Y29tbWl0UXVldWUsXG5cdGlzSHlkcmF0aW5nXG4pIHtcblx0bGV0IG9sZFByb3BzID0gb2xkVk5vZGUucHJvcHM7XG5cdGxldCBuZXdQcm9wcyA9IG5ld1ZOb2RlLnByb3BzO1xuXHRsZXQgbm9kZVR5cGUgPSBuZXdWTm9kZS50eXBlO1xuXHRsZXQgaSA9IDA7XG5cblx0Ly8gVHJhY2tzIGVudGVyaW5nIGFuZCBleGl0aW5nIFNWRyBuYW1lc3BhY2Ugd2hlbiBkZXNjZW5kaW5nIHRocm91Z2ggdGhlIHRyZWUuXG5cdGlmIChub2RlVHlwZSA9PT0gJ3N2ZycpIGlzU3ZnID0gdHJ1ZTtcblxuXHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdGZvciAoOyBpIDwgZXhjZXNzRG9tQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGNoaWxkID0gZXhjZXNzRG9tQ2hpbGRyZW5baV07XG5cblx0XHRcdC8vIGlmIG5ld1ZOb2RlIG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiBvciB0aGUgYGRvbWBcblx0XHRcdC8vIGFyZ3VtZW50IG1hdGNoZXMgYW4gZWxlbWVudCBpbiBleGNlc3NEb21DaGlsZHJlbiwgcmVtb3ZlIGl0IGZyb21cblx0XHRcdC8vIGV4Y2Vzc0RvbUNoaWxkcmVuIHNvIGl0IGlzbid0IGxhdGVyIHJlbW92ZWQgaW4gZGlmZkNoaWxkcmVuXG5cdFx0XHRpZiAoXG5cdFx0XHRcdGNoaWxkICYmXG5cdFx0XHRcdCdzZXRBdHRyaWJ1dGUnIGluIGNoaWxkID09PSAhIW5vZGVUeXBlICYmXG5cdFx0XHRcdChub2RlVHlwZSA/IGNoaWxkLmxvY2FsTmFtZSA9PT0gbm9kZVR5cGUgOiBjaGlsZC5ub2RlVHlwZSA9PT0gMylcblx0XHRcdCkge1xuXHRcdFx0XHRkb20gPSBjaGlsZDtcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW5baV0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoZG9tID09IG51bGwpIHtcblx0XHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHRcdC8vIEB0cy1pZ25vcmUgY3JlYXRlVGV4dE5vZGUgcmV0dXJucyBUZXh0LCB3ZSBleHBlY3QgUHJlYWN0RWxlbWVudFxuXHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5ld1Byb3BzKTtcblx0XHR9XG5cblx0XHRpZiAoaXNTdmcpIHtcblx0XHRcdGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhcblx0XHRcdFx0J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZVxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcblx0XHRcdFx0Ly8gQHRzLWlnbm9yZSBXZSBrbm93IGBuZXdWTm9kZS50eXBlYCBpcyBhIHN0cmluZ1xuXHRcdFx0XHRub2RlVHlwZSxcblx0XHRcdFx0bmV3UHJvcHMuaXMgJiYgbmV3UHJvcHNcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0Ly8gd2UgY3JlYXRlZCBhIG5ldyBwYXJlbnQsIHNvIG5vbmUgb2YgdGhlIHByZXZpb3VzbHkgYXR0YWNoZWQgY2hpbGRyZW4gY2FuIGJlIHJldXNlZDpcblx0XHRleGNlc3NEb21DaGlsZHJlbiA9IG51bGw7XG5cdFx0Ly8gd2UgYXJlIGNyZWF0aW5nIGEgbmV3IG5vZGUsIHNvIHdlIGNhbiBhc3N1bWUgdGhpcyBpcyBhIG5ldyBzdWJ0cmVlIChpbiBjYXNlIHdlIGFyZSBoeWRyYXRpbmcpLCB0aGlzIGRlb3B0cyB0aGUgaHlkcmF0ZVxuXHRcdGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cdH1cblxuXHRpZiAobm9kZVR5cGUgPT09IG51bGwpIHtcblx0XHQvLyBEdXJpbmcgaHlkcmF0aW9uLCB3ZSBzdGlsbCBoYXZlIHRvIHNwbGl0IG1lcmdlZCB0ZXh0IGZyb20gU1NSJ2QgSFRNTC5cblx0XHRpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzICYmICghaXNIeWRyYXRpbmcgfHwgZG9tLmRhdGEgIT09IG5ld1Byb3BzKSkge1xuXHRcdFx0ZG9tLmRhdGEgPSBuZXdQcm9wcztcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gSWYgZXhjZXNzRG9tQ2hpbGRyZW4gd2FzIG5vdCBudWxsLCByZXBvcHVsYXRlIGl0IHdpdGggdGhlIGN1cnJlbnQgZWxlbWVudCdzIGNoaWxkcmVuOlxuXHRcdGV4Y2Vzc0RvbUNoaWxkcmVuID0gZXhjZXNzRG9tQ2hpbGRyZW4gJiYgc2xpY2UuY2FsbChkb20uY2hpbGROb2Rlcyk7XG5cblx0XHRvbGRQcm9wcyA9IG9sZFZOb2RlLnByb3BzIHx8IEVNUFRZX09CSjtcblxuXHRcdGxldCBvbGRIdG1sID0gb2xkUHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG5cdFx0bGV0IG5ld0h0bWwgPSBuZXdQcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTDtcblxuXHRcdC8vIER1cmluZyBoeWRyYXRpb24sIHByb3BzIGFyZSBub3QgZGlmZmVkIGF0IGFsbCAoaW5jbHVkaW5nIGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKVxuXHRcdC8vIEBUT0RPIHdlIHNob3VsZCB3YXJuIGluIGRlYnVnIG1vZGUgd2hlbiBwcm9wcyBkb24ndCBtYXRjaCBoZXJlLlxuXHRcdGlmICghaXNIeWRyYXRpbmcpIHtcblx0XHRcdC8vIEJ1dCwgaWYgd2UgYXJlIGluIGEgc2l0dWF0aW9uIHdoZXJlIHdlIGFyZSB1c2luZyBleGlzdGluZyBET00gKGUuZy4gcmVwbGFjZU5vZGUpXG5cdFx0XHQvLyB3ZSBzaG91bGQgcmVhZCB0aGUgZXhpc3RpbmcgRE9NIGF0dHJpYnV0ZXMgdG8gZGlmZiB0aGVtXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRvbGRQcm9wcyA9IHt9O1xuXHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgZG9tLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRvbGRQcm9wc1tkb20uYXR0cmlidXRlc1tpXS5uYW1lXSA9IGRvbS5hdHRyaWJ1dGVzW2ldLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChuZXdIdG1sIHx8IG9sZEh0bWwpIHtcblx0XHRcdFx0Ly8gQXZvaWQgcmUtYXBwbHlpbmcgdGhlIHNhbWUgJ19faHRtbCcgaWYgaXQgZGlkIG5vdCBjaGFuZ2VkIGJldHdlZW4gcmUtcmVuZGVyXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHQhbmV3SHRtbCB8fFxuXHRcdFx0XHRcdCgoIW9sZEh0bWwgfHwgbmV3SHRtbC5fX2h0bWwgIT0gb2xkSHRtbC5fX2h0bWwpICYmXG5cdFx0XHRcdFx0XHRuZXdIdG1sLl9faHRtbCAhPT0gZG9tLmlubmVySFRNTClcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0ZG9tLmlubmVySFRNTCA9IChuZXdIdG1sICYmIG5ld0h0bWwuX19odG1sKSB8fCAnJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGRpZmZQcm9wcyhkb20sIG5ld1Byb3BzLCBvbGRQcm9wcywgaXNTdmcsIGlzSHlkcmF0aW5nKTtcblxuXHRcdC8vIElmIHRoZSBuZXcgdm5vZGUgZGlkbid0IGhhdmUgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwsIGRpZmYgaXRzIGNoaWxkcmVuXG5cdFx0aWYgKG5ld0h0bWwpIHtcblx0XHRcdG5ld1ZOb2RlLl9jaGlsZHJlbiA9IFtdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpID0gbmV3Vk5vZGUucHJvcHMuY2hpbGRyZW47XG5cdFx0XHRkaWZmQ2hpbGRyZW4oXG5cdFx0XHRcdGRvbSxcblx0XHRcdFx0QXJyYXkuaXNBcnJheShpKSA/IGkgOiBbaV0sXG5cdFx0XHRcdG5ld1ZOb2RlLFxuXHRcdFx0XHRvbGRWTm9kZSxcblx0XHRcdFx0Z2xvYmFsQ29udGV4dCxcblx0XHRcdFx0aXNTdmcgJiYgbm9kZVR5cGUgIT09ICdmb3JlaWduT2JqZWN0Jyxcblx0XHRcdFx0ZXhjZXNzRG9tQ2hpbGRyZW4sXG5cdFx0XHRcdGNvbW1pdFF1ZXVlLFxuXHRcdFx0XHRleGNlc3NEb21DaGlsZHJlblxuXHRcdFx0XHRcdD8gZXhjZXNzRG9tQ2hpbGRyZW5bMF1cblx0XHRcdFx0XHQ6IG9sZFZOb2RlLl9jaGlsZHJlbiAmJiBnZXREb21TaWJsaW5nKG9sZFZOb2RlLCAwKSxcblx0XHRcdFx0aXNIeWRyYXRpbmdcblx0XHRcdCk7XG5cblx0XHRcdC8vIFJlbW92ZSBjaGlsZHJlbiB0aGF0IGFyZSBub3QgcGFydCBvZiBhbnkgdm5vZGUuXG5cdFx0XHRpZiAoZXhjZXNzRG9tQ2hpbGRyZW4gIT0gbnVsbCkge1xuXHRcdFx0XHRmb3IgKGkgPSBleGNlc3NEb21DaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0XHRcdFx0aWYgKGV4Y2Vzc0RvbUNoaWxkcmVuW2ldICE9IG51bGwpIHJlbW92ZU5vZGUoZXhjZXNzRG9tQ2hpbGRyZW5baV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gKGFzIGFib3ZlLCBkb24ndCBkaWZmIHByb3BzIGR1cmluZyBoeWRyYXRpb24pXG5cdFx0aWYgKCFpc0h5ZHJhdGluZykge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHQndmFsdWUnIGluIG5ld1Byb3BzICYmXG5cdFx0XHRcdChpID0gbmV3UHJvcHMudmFsdWUpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0Ly8gIzI3NTYgRm9yIHRoZSA8cHJvZ3Jlc3M+LWVsZW1lbnQgdGhlIGluaXRpYWwgdmFsdWUgaXMgMCxcblx0XHRcdFx0Ly8gZGVzcGl0ZSB0aGUgYXR0cmlidXRlIG5vdCBiZWluZyBwcmVzZW50LiBXaGVuIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gaXMgbWlzc2luZyB0aGUgcHJvZ3Jlc3MgYmFyIGlzIHRyZWF0ZWQgYXMgaW5kZXRlcm1pbmF0ZS5cblx0XHRcdFx0Ly8gVG8gZml4IHRoYXQgd2UnbGwgYWx3YXlzIHVwZGF0ZSBpdCB3aGVuIGl0IGlzIDAgZm9yIHByb2dyZXNzIGVsZW1lbnRzXG5cdFx0XHRcdChpICE9PSBkb20udmFsdWUgfHxcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdwcm9ncmVzcycgJiYgIWkpIHx8XG5cdFx0XHRcdFx0Ly8gVGhpcyBpcyBvbmx5IGZvciBJRSAxMSB0byBmaXggPHNlbGVjdD4gdmFsdWUgbm90IGJlaW5nIHVwZGF0ZWQuXG5cdFx0XHRcdFx0Ly8gVG8gYXZvaWQgYSBzdGFsZSBzZWxlY3QgdmFsdWUgd2UgbmVlZCB0byBzZXQgdGhlIG9wdGlvbi52YWx1ZVxuXHRcdFx0XHRcdC8vIGFnYWluLCB3aGljaCB0cmlnZ2VycyBJRTExIHRvIHJlLWV2YWx1YXRlIHRoZSBzZWxlY3QgdmFsdWVcblx0XHRcdFx0XHQobm9kZVR5cGUgPT09ICdvcHRpb24nICYmIGkgIT09IG9sZFByb3BzLnZhbHVlKSlcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICd2YWx1ZScsIGksIG9sZFByb3BzLnZhbHVlLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoXG5cdFx0XHRcdCdjaGVja2VkJyBpbiBuZXdQcm9wcyAmJlxuXHRcdFx0XHQoaSA9IG5ld1Byb3BzLmNoZWNrZWQpICE9PSB1bmRlZmluZWQgJiZcblx0XHRcdFx0aSAhPT0gZG9tLmNoZWNrZWRcblx0XHRcdCkge1xuXHRcdFx0XHRzZXRQcm9wZXJ0eShkb20sICdjaGVja2VkJywgaSwgb2xkUHJvcHMuY2hlY2tlZCwgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBkb207XG59XG5cbi8qKlxuICogSW52b2tlIG9yIHVwZGF0ZSBhIHJlZiwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgaXQgaXMgYSBmdW5jdGlvbiBvciBvYmplY3QgcmVmLlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHJlZlxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UmVmKHJlZiwgdmFsdWUsIHZub2RlKSB7XG5cdHRyeSB7XG5cdFx0aWYgKHR5cGVvZiByZWYgPT0gJ2Z1bmN0aW9uJykgcmVmKHZhbHVlKTtcblx0XHRlbHNlIHJlZi5jdXJyZW50ID0gdmFsdWU7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHZub2RlKTtcblx0fVxufVxuXG4vKipcbiAqIFVubW91bnQgYSB2aXJ0dWFsIG5vZGUgZnJvbSB0aGUgdHJlZSBhbmQgYXBwbHkgRE9NIGNoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHVubW91bnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLlZOb2RlfSBwYXJlbnRWTm9kZSBUaGUgcGFyZW50IG9mIHRoZSBWTm9kZSB0aGF0XG4gKiBpbml0aWF0ZWQgdGhlIHVubW91bnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBSZW1vdmVdIEZsYWcgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIHBhcmVudCBub2RlIG9mIHRoZVxuICogY3VycmVudCBlbGVtZW50IGlzIGFscmVhZHkgZGV0YWNoZWQgZnJvbSB0aGUgRE9NLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdW5tb3VudCh2bm9kZSwgcGFyZW50Vk5vZGUsIHNraXBSZW1vdmUpIHtcblx0bGV0IHI7XG5cdGlmIChvcHRpb25zLnVubW91bnQpIG9wdGlvbnMudW5tb3VudCh2bm9kZSk7XG5cblx0aWYgKChyID0gdm5vZGUucmVmKSkge1xuXHRcdGlmICghci5jdXJyZW50IHx8IHIuY3VycmVudCA9PT0gdm5vZGUuX2RvbSkge1xuXHRcdFx0YXBwbHlSZWYociwgbnVsbCwgcGFyZW50Vk5vZGUpO1xuXHRcdH1cblx0fVxuXG5cdGlmICgociA9IHZub2RlLl9jb21wb25lbnQpICE9IG51bGwpIHtcblx0XHRpZiAoci5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0ci5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRvcHRpb25zLl9jYXRjaEVycm9yKGUsIHBhcmVudFZOb2RlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyLmJhc2UgPSByLl9wYXJlbnREb20gPSBudWxsO1xuXHRcdHZub2RlLl9jb21wb25lbnQgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRpZiAoKHIgPSB2bm9kZS5fY2hpbGRyZW4pKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAocltpXSkge1xuXHRcdFx0XHR1bm1vdW50KHJbaV0sIHBhcmVudFZOb2RlLCBza2lwUmVtb3ZlIHx8IHR5cGVvZiB2bm9kZS50eXBlICE9PSAnZnVuY3Rpb24nKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIXNraXBSZW1vdmUgJiYgdm5vZGUuX2RvbSAhPSBudWxsKSB7XG5cdFx0cmVtb3ZlTm9kZSh2bm9kZS5fZG9tKTtcblx0fVxuXG5cdC8vIE11c3QgYmUgc2V0IHRvIGB1bmRlZmluZWRgIHRvIHByb3Blcmx5IGNsZWFuIHVwIGBfbmV4dERvbWBcblx0Ly8gZm9yIHdoaWNoIGBudWxsYCBpcyBhIHZhbGlkIHZhbHVlLiBTZWUgY29tbWVudCBpbiBgY3JlYXRlLWVsZW1lbnQuanNgXG5cdHZub2RlLl9wYXJlbnQgPSB2bm9kZS5fZG9tID0gdm5vZGUuX25leHREb20gPSB1bmRlZmluZWQ7XG59XG5cbi8qKiBUaGUgYC5yZW5kZXIoKWAgbWV0aG9kIGZvciBhIFBGQyBiYWNraW5nIGluc3RhbmNlLiAqL1xuZnVuY3Rpb24gZG9SZW5kZXIocHJvcHMsIHN0YXRlLCBjb250ZXh0KSB7XG5cdHJldHVybiB0aGlzLmNvbnN0cnVjdG9yKHByb3BzLCBjb250ZXh0KTtcbn1cbiIsImltcG9ydCB7IEVNUFRZX09CSiB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbW1pdFJvb3QsIGRpZmYgfSBmcm9tICcuL2RpZmYvaW5kZXgnO1xuaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQgfSBmcm9tICcuL2NyZWF0ZS1lbGVtZW50JztcbmltcG9ydCBvcHRpb25zIGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBzbGljZSB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogUmVuZGVyIGEgUHJlYWN0IHZpcnR1YWwgbm9kZSBpbnRvIGEgRE9NIGVsZW1lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50Q2hpbGR9IHZub2RlIFRoZSB2aXJ0dWFsIG5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IHBhcmVudERvbSBUaGUgRE9NIGVsZW1lbnQgdG9cbiAqIHJlbmRlciBpbnRvXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnQgfCBvYmplY3R9IFtyZXBsYWNlTm9kZV0gT3B0aW9uYWw6IEF0dGVtcHQgdG8gcmUtdXNlIGFuXG4gKiBleGlzdGluZyBET00gdHJlZSByb290ZWQgYXQgYHJlcGxhY2VOb2RlYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnREb20sIHJlcGxhY2VOb2RlKSB7XG5cdGlmIChvcHRpb25zLl9yb290KSBvcHRpb25zLl9yb290KHZub2RlLCBwYXJlbnREb20pO1xuXG5cdC8vIFdlIGFidXNlIHRoZSBgcmVwbGFjZU5vZGVgIHBhcmFtZXRlciBpbiBgaHlkcmF0ZSgpYCB0byBzaWduYWwgaWYgd2UgYXJlIGluXG5cdC8vIGh5ZHJhdGlvbiBtb2RlIG9yIG5vdCBieSBwYXNzaW5nIHRoZSBgaHlkcmF0ZWAgZnVuY3Rpb24gaW5zdGVhZCBvZiBhIERPTVxuXHQvLyBlbGVtZW50Li5cblx0bGV0IGlzSHlkcmF0aW5nID0gdHlwZW9mIHJlcGxhY2VOb2RlID09PSAnZnVuY3Rpb24nO1xuXG5cdC8vIFRvIGJlIGFibGUgdG8gc3VwcG9ydCBjYWxsaW5nIGByZW5kZXIoKWAgbXVsdGlwbGUgdGltZXMgb24gdGhlIHNhbWVcblx0Ly8gRE9NIG5vZGUsIHdlIG5lZWQgdG8gb2J0YWluIGEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91cyB0cmVlLiBXZSBkb1xuXHQvLyB0aGlzIGJ5IGFzc2lnbmluZyBhIG5ldyBgX2NoaWxkcmVuYCBwcm9wZXJ0eSB0byBET00gbm9kZXMgd2hpY2ggcG9pbnRzXG5cdC8vIHRvIHRoZSBsYXN0IHJlbmRlcmVkIHRyZWUuIEJ5IGRlZmF1bHQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgcHJlc2VudCwgd2hpY2hcblx0Ly8gbWVhbnMgdGhhdCB3ZSBhcmUgbW91bnRpbmcgYSBuZXcgdHJlZSBmb3IgdGhlIGZpcnN0IHRpbWUuXG5cdGxldCBvbGRWTm9kZSA9IGlzSHlkcmF0aW5nXG5cdFx0PyBudWxsXG5cdFx0OiAocmVwbGFjZU5vZGUgJiYgcmVwbGFjZU5vZGUuX2NoaWxkcmVuKSB8fCBwYXJlbnREb20uX2NoaWxkcmVuO1xuXG5cdHZub2RlID0gKFxuXHRcdCghaXNIeWRyYXRpbmcgJiYgcmVwbGFjZU5vZGUpIHx8XG5cdFx0cGFyZW50RG9tXG5cdCkuX2NoaWxkcmVuID0gY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgW3Zub2RlXSk7XG5cblx0Ly8gTGlzdCBvZiBlZmZlY3RzIHRoYXQgbmVlZCB0byBiZSBjYWxsZWQgYWZ0ZXIgZGlmZmluZy5cblx0bGV0IGNvbW1pdFF1ZXVlID0gW107XG5cdGRpZmYoXG5cdFx0cGFyZW50RG9tLFxuXHRcdC8vIERldGVybWluZSB0aGUgbmV3IHZub2RlIHRyZWUgYW5kIHN0b3JlIGl0IG9uIHRoZSBET00gZWxlbWVudCBvblxuXHRcdC8vIG91ciBjdXN0b20gYF9jaGlsZHJlbmAgcHJvcGVydHkuXG5cdFx0dm5vZGUsXG5cdFx0b2xkVk5vZGUgfHwgRU1QVFlfT0JKLFxuXHRcdEVNUFRZX09CSixcblx0XHRwYXJlbnREb20ub3duZXJTVkdFbGVtZW50ICE9PSB1bmRlZmluZWQsXG5cdFx0IWlzSHlkcmF0aW5nICYmIHJlcGxhY2VOb2RlXG5cdFx0XHQ/IFtyZXBsYWNlTm9kZV1cblx0XHRcdDogb2xkVk5vZGVcblx0XHRcdD8gbnVsbFxuXHRcdFx0OiBwYXJlbnREb20uZmlyc3RDaGlsZFxuXHRcdFx0PyBzbGljZS5jYWxsKHBhcmVudERvbS5jaGlsZE5vZGVzKVxuXHRcdFx0OiBudWxsLFxuXHRcdGNvbW1pdFF1ZXVlLFxuXHRcdCFpc0h5ZHJhdGluZyAmJiByZXBsYWNlTm9kZVxuXHRcdFx0PyByZXBsYWNlTm9kZVxuXHRcdFx0OiBvbGRWTm9kZVxuXHRcdFx0PyBvbGRWTm9kZS5fZG9tXG5cdFx0XHQ6IHBhcmVudERvbS5maXJzdENoaWxkLFxuXHRcdGlzSHlkcmF0aW5nXG5cdCk7XG5cblx0Ly8gRmx1c2ggYWxsIHF1ZXVlZCBlZmZlY3RzXG5cdGNvbW1pdFJvb3QoY29tbWl0UXVldWUsIHZub2RlKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgYW4gZXhpc3RpbmcgRE9NIGVsZW1lbnQgd2l0aCBkYXRhIGZyb20gYSBQcmVhY3QgdmlydHVhbCBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudENoaWxkfSB2bm9kZSBUaGUgdmlydHVhbCBub2RlIHRvIHJlbmRlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5QcmVhY3RFbGVtZW50fSBwYXJlbnREb20gVGhlIERPTSBlbGVtZW50IHRvXG4gKiB1cGRhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGh5ZHJhdGUodm5vZGUsIHBhcmVudERvbSkge1xuXHRyZW5kZXIodm5vZGUsIHBhcmVudERvbSwgaHlkcmF0ZSk7XG59XG4iLCIvKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3QgZXJyb3IgYm91bmRhcnkgdG8gYSB0aHJvd24gZXJyb3IgYW5kIGNhbGwgaXRcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvciBUaGUgdGhyb3duIHZhbHVlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVGhlIHZub2RlIHRoYXQgdGhyZXdcbiAqIHRoZSBlcnJvciB0aGF0IHdhcyBjYXVnaHQgKGV4Y2VwdCBmb3IgdW5tb3VudGluZyB3aGVuIHRoaXMgcGFyYW1ldGVyXG4gKiBpcyB0aGUgaGlnaGVzdCBwYXJlbnQgdGhhdCB3YXMgYmVpbmcgdW5tb3VudGVkKVxuICogQHBhcmFtIHtpbXBvcnQoJy4uL2ludGVybmFsJykuVk5vZGV9IFtvbGRWTm9kZV1cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9pbnRlcm5hbCcpLkVycm9ySW5mb30gW2Vycm9ySW5mb11cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaEVycm9yKGVycm9yLCB2bm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGxldCBjb21wb25lbnQsIGN0b3IsIGhhbmRsZWQ7XG5cblx0Zm9yICg7ICh2bm9kZSA9IHZub2RlLl9wYXJlbnQpOyApIHtcblx0XHRpZiAoKGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQpICYmICFjb21wb25lbnQuX3Byb2Nlc3NpbmdFeGNlcHRpb24pIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XG5cblx0XHRcdFx0aWYgKGN0b3IgJiYgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT0gbnVsbCkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zZXRTdGF0ZShjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvcikpO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCAhPSBudWxsKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKGVycm9yLCBlcnJvckluZm8gfHwge30pO1xuXHRcdFx0XHRcdGhhbmRsZWQgPSBjb21wb25lbnQuX2RpcnR5O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVGhpcyBpcyBhbiBlcnJvciBib3VuZGFyeS4gTWFyayBpdCBhcyBoYXZpbmcgYmFpbGVkIG91dCwgYW5kIHdoZXRoZXIgaXQgd2FzIG1pZC1oeWRyYXRpb24uXG5cdFx0XHRcdGlmIChoYW5kbGVkKSB7XG5cdFx0XHRcdFx0cmV0dXJuIChjb21wb25lbnQuX3BlbmRpbmdFcnJvciA9IGNvbXBvbmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHRocm93IGVycm9yO1xufVxuIiwiaW1wb3J0IHsgb3B0aW9ucywgRnJhZ21lbnQgfSBmcm9tICdwcmVhY3QnO1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgncHJlYWN0JykuVk5vZGV9IFZOb2RlICovXG5cbmxldCB2bm9kZUlkID0gMDtcblxuLyoqXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBUaGlzIGZpbGUgZXhwb3J0cyB2YXJpb3VzIG1ldGhvZHMgdGhhdCBpbXBsZW1lbnQgQmFiZWwncyBcImF1dG9tYXRpY1wiIEpTWCBydW50aW1lIEFQSTpcbiAqIC0ganN4KHR5cGUsIHByb3BzLCBrZXkpXG4gKiAtIGpzeHModHlwZSwgcHJvcHMsIGtleSlcbiAqIC0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIF9fc291cmNlLCBfX3NlbGYpXG4gKlxuICogVGhlIGltcGxlbWVudGF0aW9uIG9mIGNyZWF0ZVZOb2RlIGhlcmUgaXMgb3B0aW1pemVkIGZvciBwZXJmb3JtYW5jZS5cbiAqIEJlbmNobWFya3M6IGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWY2YjU0YTBiNDYzMjEwMGE3ZGNkMmIzXG4gKi9cblxuLyoqXG4gKiBKU1guRWxlbWVudCBmYWN0b3J5IHVzZWQgYnkgQmFiZWwncyB7cnVudGltZTpcImF1dG9tYXRpY1wifSBKU1ggdHJhbnNmb3JtXG4gKiBAcGFyYW0ge1ZOb2RlWyd0eXBlJ119IHR5cGVcbiAqIEBwYXJhbSB7Vk5vZGVbJ3Byb3BzJ119IHByb3BzXG4gKiBAcGFyYW0ge1ZOb2RlWydrZXknXX0gW2tleV1cbiAqIEBwYXJhbSB7c3RyaW5nfSBbX19zZWxmXVxuICogQHBhcmFtIHtzdHJpbmd9IFtfX3NvdXJjZV1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVk5vZGUodHlwZSwgcHJvcHMsIGtleSwgX19zZWxmLCBfX3NvdXJjZSkge1xuXHQvLyBXZSdsbCB3YW50IHRvIHByZXNlcnZlIGByZWZgIGluIHByb3BzIHRvIGdldCByaWQgb2YgdGhlIG5lZWQgZm9yXG5cdC8vIGZvcndhcmRSZWYgY29tcG9uZW50cyBpbiB0aGUgZnV0dXJlLCBidXQgdGhhdCBzaG91bGQgaGFwcGVuIHZpYVxuXHQvLyBhIHNlcGFyYXRlIFBSLlxuXHRsZXQgbm9ybWFsaXplZFByb3BzID0ge30sXG5cdFx0cmVmLFxuXHRcdGk7XG5cdGZvciAoaSBpbiBwcm9wcykge1xuXHRcdGlmIChpID09ICdyZWYnKSB7XG5cdFx0XHRyZWYgPSBwcm9wc1tpXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bm9ybWFsaXplZFByb3BzW2ldID0gcHJvcHNbaV07XG5cdFx0fVxuXHR9XG5cblx0Y29uc3Qgdm5vZGUgPSB7XG5cdFx0dHlwZSxcblx0XHRwcm9wczogbm9ybWFsaXplZFByb3BzLFxuXHRcdGtleSxcblx0XHRyZWYsXG5cdFx0X2NoaWxkcmVuOiBudWxsLFxuXHRcdF9wYXJlbnQ6IG51bGwsXG5cdFx0X2RlcHRoOiAwLFxuXHRcdF9kb206IG51bGwsXG5cdFx0X25leHREb206IHVuZGVmaW5lZCxcblx0XHRfY29tcG9uZW50OiBudWxsLFxuXHRcdF9oeWRyYXRpbmc6IG51bGwsXG5cdFx0Y29uc3RydWN0b3I6IHVuZGVmaW5lZCxcblx0XHRfb3JpZ2luYWw6IC0tdm5vZGVJZCxcblx0XHRfX3NvdXJjZSxcblx0XHRfX3NlbGZcblx0fTtcblxuXHQvLyBJZiBhIENvbXBvbmVudCBWTm9kZSwgY2hlY2sgZm9yIGFuZCBhcHBseSBkZWZhdWx0UHJvcHMuXG5cdC8vIE5vdGU6IGB0eXBlYCBpcyBvZnRlbiBhIFN0cmluZywgYW5kIGNhbiBiZSBgdW5kZWZpbmVkYCBpbiBkZXZlbG9wbWVudC5cblx0aWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIChyZWYgPSB0eXBlLmRlZmF1bHRQcm9wcykpIHtcblx0XHRmb3IgKGkgaW4gcmVmKVxuXHRcdFx0aWYgKHR5cGVvZiBub3JtYWxpemVkUHJvcHNbaV0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdG5vcm1hbGl6ZWRQcm9wc1tpXSA9IHJlZltpXTtcblx0XHRcdH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnZub2RlKSBvcHRpb25zLnZub2RlKHZub2RlKTtcblx0cmV0dXJuIHZub2RlO1xufVxuXG5leHBvcnQge1xuXHRjcmVhdGVWTm9kZSBhcyBqc3gsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeHMsXG5cdGNyZWF0ZVZOb2RlIGFzIGpzeERFVixcblx0RnJhZ21lbnRcbn07XG4iLCJpbXBvcnQgeyBGcmFnbWVudCwgb3B0aW9ucyB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xubGV0IGN1cnJlbnRJbmRleDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5sZXQgY3VycmVudENvbXBvbmVudDtcblxuLyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5sZXQgcHJldmlvdXNDb21wb25lbnQ7XG5cbi8qKiBAdHlwZSB7bnVtYmVyfSAqL1xubGV0IGN1cnJlbnRIb29rID0gMDtcblxuLyoqIEB0eXBlIHtBcnJheTxpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnQ+fSAqL1xubGV0IGFmdGVyUGFpbnRFZmZlY3RzID0gW107XG5cbmxldCBFTVBUWSA9IFtdO1xuXG5sZXQgb2xkQmVmb3JlRGlmZiA9IG9wdGlvbnMuX2RpZmY7XG5sZXQgb2xkQmVmb3JlUmVuZGVyID0gb3B0aW9ucy5fcmVuZGVyO1xubGV0IG9sZEFmdGVyRGlmZiA9IG9wdGlvbnMuZGlmZmVkO1xubGV0IG9sZENvbW1pdCA9IG9wdGlvbnMuX2NvbW1pdDtcbmxldCBvbGRCZWZvcmVVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xuXG5jb25zdCBSQUZfVElNRU9VVCA9IDEwMDtcbmxldCBwcmV2UmFmO1xuXG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAoXG5cdFx0dHlwZW9mIHZub2RlLnR5cGUgPT09ICdmdW5jdGlvbicgJiZcblx0XHQhdm5vZGUuX21hc2sgJiZcblx0XHR2bm9kZS50eXBlICE9PSBGcmFnbWVudFxuXHQpIHtcblx0XHR2bm9kZS5fbWFzayA9XG5cdFx0XHQodm5vZGUuX3BhcmVudCAmJiB2bm9kZS5fcGFyZW50Ll9tYXNrID8gdm5vZGUuX3BhcmVudC5fbWFzayA6ICcnKSArXG5cdFx0XHQodm5vZGUuX3BhcmVudCAmJiB2bm9kZS5fcGFyZW50Ll9jaGlsZHJlblxuXHRcdFx0XHQ/IHZub2RlLl9wYXJlbnQuX2NoaWxkcmVuLmluZGV4T2Yodm5vZGUpXG5cdFx0XHRcdDogMCk7XG5cdH0gZWxzZSBpZiAoIXZub2RlLl9tYXNrKSB7XG5cdFx0dm5vZGUuX21hc2sgPVxuXHRcdFx0dm5vZGUuX3BhcmVudCAmJiB2bm9kZS5fcGFyZW50Ll9tYXNrID8gdm5vZGUuX3BhcmVudC5fbWFzayA6ICcnO1xuXHR9XG5cblx0Y3VycmVudENvbXBvbmVudCA9IG51bGw7XG5cdGlmIChvbGRCZWZvcmVEaWZmKSBvbGRCZWZvcmVEaWZmKHZub2RlKTtcbn07XG5cbm9wdGlvbnMuX3JlbmRlciA9IHZub2RlID0+IHtcblx0aWYgKG9sZEJlZm9yZVJlbmRlcikgb2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcblx0Y3VycmVudEluZGV4ID0gMDtcblxuXHRjb25zdCBob29rcyA9IGN1cnJlbnRDb21wb25lbnQuX19ob29rcztcblx0aWYgKGhvb2tzKSB7XG5cdFx0aWYgKHByZXZpb3VzQ29tcG9uZW50ID09PSBjdXJyZW50Q29tcG9uZW50KSB7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdGN1cnJlbnRDb21wb25lbnQuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0aG9va3MuX2xpc3QuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdGlmIChob29rSXRlbS5fbmV4dFZhbHVlKSB7XG5cdFx0XHRcdFx0aG9va0l0ZW0uX3ZhbHVlID0gaG9va0l0ZW0uX25leHRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRob29rSXRlbS5fcGVuZGluZ1ZhbHVlID0gRU1QVFk7XG5cdFx0XHRcdGhvb2tJdGVtLl9uZXh0VmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ0FyZ3MgPSB1bmRlZmluZWQ7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzLmZvckVhY2goaW52b2tlQ2xlYW51cCk7XG5cdFx0XHRob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VFZmZlY3QpO1xuXHRcdFx0aG9va3MuX3BlbmRpbmdFZmZlY3RzID0gW107XG5cdFx0fVxuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudDtcbn07XG5cbm9wdGlvbnMuZGlmZmVkID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQWZ0ZXJEaWZmKSBvbGRBZnRlckRpZmYodm5vZGUpO1xuXG5cdGNvbnN0IGMgPSB2bm9kZS5fY29tcG9uZW50O1xuXHRpZiAoYyAmJiBjLl9faG9va3MpIHtcblx0XHRpZiAoYy5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5sZW5ndGgpIGFmdGVyUGFpbnQoYWZ0ZXJQYWludEVmZmVjdHMucHVzaChjKSk7XG5cdFx0Yy5fX2hvb2tzLl9saXN0LmZvckVhY2goaG9va0l0ZW0gPT4ge1xuXHRcdFx0aWYgKGhvb2tJdGVtLl9wZW5kaW5nQXJncykge1xuXHRcdFx0XHRob29rSXRlbS5fYXJncyA9IGhvb2tJdGVtLl9wZW5kaW5nQXJncztcblx0XHRcdH1cblx0XHRcdGlmIChob29rSXRlbS5fcGVuZGluZ1ZhbHVlICE9PSBFTVBUWSkge1xuXHRcdFx0XHRob29rSXRlbS5fdmFsdWUgPSBob29rSXRlbS5fcGVuZGluZ1ZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdBcmdzID0gdW5kZWZpbmVkO1xuXHRcdFx0aG9va0l0ZW0uX3BlbmRpbmdWYWx1ZSA9IEVNUFRZO1xuXHRcdH0pO1xuXHR9XG5cdHByZXZpb3VzQ29tcG9uZW50ID0gY3VycmVudENvbXBvbmVudCA9IG51bGw7XG59O1xuXG5vcHRpb25zLl9jb21taXQgPSAodm5vZGUsIGNvbW1pdFF1ZXVlKSA9PiB7XG5cdGNvbW1pdFF1ZXVlLnNvbWUoY29tcG9uZW50ID0+IHtcblx0XHR0cnkge1xuXHRcdFx0Y29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fcmVuZGVyQ2FsbGJhY2tzID0gY29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MuZmlsdGVyKGNiID0+XG5cdFx0XHRcdGNiLl92YWx1ZSA/IGludm9rZUVmZmVjdChjYikgOiB0cnVlXG5cdFx0XHQpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdGNvbW1pdFF1ZXVlLnNvbWUoYyA9PiB7XG5cdFx0XHRcdGlmIChjLl9yZW5kZXJDYWxsYmFja3MpIGMuX3JlbmRlckNhbGxiYWNrcyA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRjb21taXRRdWV1ZSA9IFtdO1xuXHRcdFx0b3B0aW9ucy5fY2F0Y2hFcnJvcihlLCBjb21wb25lbnQuX3Zub2RlKTtcblx0XHR9XG5cdH0pO1xuXG5cdGlmIChvbGRDb21taXQpIG9sZENvbW1pdCh2bm9kZSwgY29tbWl0UXVldWUpO1xufTtcblxub3B0aW9ucy51bm1vdW50ID0gdm5vZGUgPT4ge1xuXHRpZiAob2xkQmVmb3JlVW5tb3VudCkgb2xkQmVmb3JlVW5tb3VudCh2bm9kZSk7XG5cblx0Y29uc3QgYyA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjICYmIGMuX19ob29rcykge1xuXHRcdGxldCBoYXNFcnJvcmVkO1xuXHRcdGMuX19ob29rcy5fbGlzdC5mb3JFYWNoKHMgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aW52b2tlQ2xlYW51cChzKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0aGFzRXJyb3JlZCA9IGU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0Yy5fX2hvb2tzID0gdW5kZWZpbmVkO1xuXHRcdGlmIChoYXNFcnJvcmVkKSBvcHRpb25zLl9jYXRjaEVycm9yKGhhc0Vycm9yZWQsIGMuX3Zub2RlKTtcblx0fVxufTtcblxuLyoqXG4gKiBHZXQgYSBob29rJ3Mgc3RhdGUgZnJvbSB0aGUgY3VycmVudENvbXBvbmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlIFRoZSBpbmRleCBvZiB0aGUgaG9vayB0byBnZXRcbiAqIEByZXR1cm5zIHthbnl9XG4gKi9cbmZ1bmN0aW9uIGdldEhvb2tTdGF0ZShpbmRleCwgdHlwZSkge1xuXHRpZiAob3B0aW9ucy5faG9vaykge1xuXHRcdG9wdGlvbnMuX2hvb2soY3VycmVudENvbXBvbmVudCwgaW5kZXgsIGN1cnJlbnRIb29rIHx8IHR5cGUpO1xuXHR9XG5cdGN1cnJlbnRIb29rID0gMDtcblxuXHQvLyBMYXJnZWx5IGluc3BpcmVkIGJ5OlxuXHQvLyAqIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNoYWVsLWtsZWluL2Z1bmN5LmpzL2Jsb2IvZjZiZTczNDY4ZTZlYzQ2YjBmZjVhYTNjYzRjOWJhZjcyYTI5MDI1YS9zcmMvaG9va3MvY29yZV9ob29rcy5tanNcblx0Ly8gKiBodHRwczovL2dpdGh1Yi5jb20vbWljaGFlbC1rbGVpbi9mdW5jeS5qcy9ibG9iLzY1MGJlYWE1OGM0M2MzM2E3NDgyMGEzYzk4YjNjNzA3OWNmMmUzMzMvc3JjL3JlbmRlcmVyLm1qc1xuXHQvLyBPdGhlciBpbXBsZW1lbnRhdGlvbnMgdG8gbG9vayBhdDpcblx0Ly8gKiBodHRwczovL2NvZGVzYW5kYm94LmlvL3MvbW5veDA1cXA4XG5cdGNvbnN0IGhvb2tzID1cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9faG9va3MgfHxcblx0XHQoY3VycmVudENvbXBvbmVudC5fX2hvb2tzID0ge1xuXHRcdFx0X2xpc3Q6IFtdLFxuXHRcdFx0X3BlbmRpbmdFZmZlY3RzOiBbXVxuXHRcdH0pO1xuXG5cdGlmIChpbmRleCA+PSBob29rcy5fbGlzdC5sZW5ndGgpIHtcblx0XHRob29rcy5fbGlzdC5wdXNoKHsgX3BlbmRpbmdWYWx1ZTogRU1QVFkgfSk7XG5cdH1cblx0cmV0dXJuIGhvb2tzLl9saXN0W2luZGV4XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLlN0YXRlVXBkYXRlcjxhbnk+fSBbaW5pdGlhbFN0YXRlXVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG5cdGN1cnJlbnRIb29rID0gMTtcblx0cmV0dXJuIHVzZVJlZHVjZXIoaW52b2tlT3JSZXR1cm4sIGluaXRpYWxTdGF0ZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5SZWR1Y2VyPGFueSwgYW55Pn0gcmVkdWNlclxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW5kZXgnKS5TdGF0ZVVwZGF0ZXI8YW55Pn0gaW5pdGlhbFN0YXRlXG4gKiBAcGFyYW0geyhpbml0aWFsU3RhdGU6IGFueSkgPT4gdm9pZH0gW2luaXRdXG4gKiBAcmV0dXJucyB7WyBhbnksIChzdGF0ZTogYW55KSA9PiB2b2lkIF19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxTdGF0ZSwgaW5pdCkge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlJlZHVjZXJIb29rU3RhdGV9ICovXG5cdGNvbnN0IGhvb2tTdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMik7XG5cdGhvb2tTdGF0ZS5fcmVkdWNlciA9IHJlZHVjZXI7XG5cdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQpIHtcblx0XHRob29rU3RhdGUuX3ZhbHVlID0gW1xuXHRcdFx0IWluaXQgPyBpbnZva2VPclJldHVybih1bmRlZmluZWQsIGluaXRpYWxTdGF0ZSkgOiBpbml0KGluaXRpYWxTdGF0ZSksXG5cblx0XHRcdGFjdGlvbiA9PiB7XG5cdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tTdGF0ZS5fbmV4dFZhbHVlXG5cdFx0XHRcdFx0PyBob29rU3RhdGUuX25leHRWYWx1ZVswXVxuXHRcdFx0XHRcdDogaG9va1N0YXRlLl92YWx1ZVswXTtcblx0XHRcdFx0Y29uc3QgbmV4dFZhbHVlID0gaG9va1N0YXRlLl9yZWR1Y2VyKGN1cnJlbnRWYWx1ZSwgYWN0aW9uKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlICE9PSBuZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRob29rU3RhdGUuX25leHRWYWx1ZSA9IFtuZXh0VmFsdWUsIGhvb2tTdGF0ZS5fdmFsdWVbMV1dO1xuXHRcdFx0XHRcdGhvb2tTdGF0ZS5fY29tcG9uZW50LnNldFN0YXRlKHt9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdF07XG5cblx0XHRob29rU3RhdGUuX2NvbXBvbmVudCA9IGN1cnJlbnRDb21wb25lbnQ7XG5cblx0XHRpZiAoIWN1cnJlbnRDb21wb25lbnQuX2hhc1NjdUZyb21Ib29rcykge1xuXHRcdFx0Y3VycmVudENvbXBvbmVudC5faGFzU2N1RnJvbUhvb2tzID0gdHJ1ZTtcblx0XHRcdGNvbnN0IHByZXZTY3UgPSBjdXJyZW50Q29tcG9uZW50LnNob3VsZENvbXBvbmVudFVwZGF0ZTtcblxuXHRcdFx0Ly8gVGhpcyBTQ1UgaGFzIHRoZSBwdXJwb3NlIG9mIGJhaWxpbmcgb3V0IGFmdGVyIHJlcGVhdGVkIHVwZGF0ZXNcblx0XHRcdC8vIHRvIHN0YXRlZnVsIGhvb2tzLlxuXHRcdFx0Ly8gd2Ugc3RvcmUgdGhlIG5leHQgdmFsdWUgaW4gX25leHRWYWx1ZVswXSBhbmQga2VlcCBkb2luZyB0aGF0IGZvciBhbGxcblx0XHRcdC8vIHN0YXRlIHNldHRlcnMsIGlmIHdlIGhhdmUgbmV4dCBzdGF0ZXMgYW5kXG5cdFx0XHQvLyBhbGwgbmV4dCBzdGF0ZXMgd2l0aGluIGEgY29tcG9uZW50IGVuZCB1cCBiZWluZyBlcXVhbCB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZVxuXHRcdFx0Ly8gd2UgYXJlIHNhZmUgdG8gYmFpbCBvdXQgZm9yIHRoaXMgc3BlY2lmaWMgY29tcG9uZW50LlxuXHRcdFx0Y3VycmVudENvbXBvbmVudC5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwLCBzLCBjKSB7XG5cdFx0XHRcdGlmICghaG9va1N0YXRlLl9jb21wb25lbnQuX19ob29rcykgcmV0dXJuIHRydWU7XG5cblx0XHRcdFx0Y29uc3Qgc3RhdGVIb29rcyA9IGhvb2tTdGF0ZS5fY29tcG9uZW50Ll9faG9va3MuX2xpc3QuZmlsdGVyKFxuXHRcdFx0XHRcdHggPT4geC5fY29tcG9uZW50XG5cdFx0XHRcdCk7XG5cdFx0XHRcdGNvbnN0IGFsbEhvb2tzRW1wdHkgPSBzdGF0ZUhvb2tzLmV2ZXJ5KHggPT4gIXguX25leHRWYWx1ZSk7XG5cdFx0XHRcdC8vIFdoZW4gd2UgaGF2ZSBubyB1cGRhdGVkIGhvb2tzIGluIHRoZSBjb21wb25lbnQgd2UgaW52b2tlIHRoZSBwcmV2aW91cyBTQ1Ugb3Jcblx0XHRcdFx0Ly8gdHJhdmVyc2UgdGhlIFZET00gdHJlZSBmdXJ0aGVyLlxuXHRcdFx0XHRpZiAoYWxsSG9va3NFbXB0eSkge1xuXHRcdFx0XHRcdHJldHVybiBwcmV2U2N1ID8gcHJldlNjdS5jYWxsKHRoaXMsIHAsIHMsIGMpIDogdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIGNoZWNrIHdoZXRoZXIgd2UgaGF2ZSBjb21wb25lbnRzIHdpdGggYSBuZXh0VmFsdWUgc2V0IHRoYXRcblx0XHRcdFx0Ly8gaGF2ZSB2YWx1ZXMgdGhhdCBhcmVuJ3QgZXF1YWwgdG8gb25lIGFub3RoZXIgdGhpcyBwdXNoZXNcblx0XHRcdFx0Ly8gdXMgdG8gdXBkYXRlIGZ1cnRoZXIgZG93biB0aGUgdHJlZVxuXHRcdFx0XHRsZXQgc2hvdWxkVXBkYXRlID0gZmFsc2U7XG5cdFx0XHRcdHN0YXRlSG9va3MuZm9yRWFjaChob29rSXRlbSA9PiB7XG5cdFx0XHRcdFx0aWYgKGhvb2tJdGVtLl9uZXh0VmFsdWUpIHtcblx0XHRcdFx0XHRcdGNvbnN0IGN1cnJlbnRWYWx1ZSA9IGhvb2tJdGVtLl92YWx1ZVswXTtcblx0XHRcdFx0XHRcdGhvb2tJdGVtLl92YWx1ZSA9IGhvb2tJdGVtLl9uZXh0VmFsdWU7XG5cdFx0XHRcdFx0XHRob29rSXRlbS5fbmV4dFZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSAhPT0gaG9va0l0ZW0uX3ZhbHVlWzBdKSBzaG91bGRVcGRhdGUgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0cmV0dXJuIHNob3VsZFVwZGF0ZSB8fCBob29rU3RhdGUuX2NvbXBvbmVudC5wcm9wcyAhPT0gcFxuXHRcdFx0XHRcdD8gcHJldlNjdVxuXHRcdFx0XHRcdFx0PyBwcmV2U2N1LmNhbGwodGhpcywgcCwgcywgYylcblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDogZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBob29rU3RhdGUuX25leHRWYWx1ZSB8fCBob29rU3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0fSBjYWxsYmFja1xuICogQHBhcmFtIHthbnlbXX0gYXJnc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRWZmZWN0KGNhbGxiYWNrLCBhcmdzKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSAqL1xuXHRjb25zdCBzdGF0ZSA9IGdldEhvb2tTdGF0ZShjdXJyZW50SW5kZXgrKywgMyk7XG5cdGlmICghb3B0aW9ucy5fc2tpcEVmZmVjdHMgJiYgYXJnc0NoYW5nZWQoc3RhdGUuX2FyZ3MsIGFyZ3MpKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gY2FsbGJhY2s7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblxuXHRcdGN1cnJlbnRDb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxheW91dEVmZmVjdChjYWxsYmFjaywgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDQpO1xuXHRpZiAoIW9wdGlvbnMuX3NraXBFZmZlY3RzICYmIGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl92YWx1ZSA9IGNhbGxiYWNrO1xuXHRcdHN0YXRlLl9wZW5kaW5nQXJncyA9IGFyZ3M7XG5cblx0XHRjdXJyZW50Q29tcG9uZW50Ll9yZW5kZXJDYWxsYmFja3MucHVzaChzdGF0ZSk7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVJlZihpbml0aWFsVmFsdWUpIHtcblx0Y3VycmVudEhvb2sgPSA1O1xuXHRyZXR1cm4gdXNlTWVtbygoKSA9PiAoeyBjdXJyZW50OiBpbml0aWFsVmFsdWUgfSksIFtdKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcmVmXG4gKiBAcGFyYW0geygpID0+IG9iamVjdH0gY3JlYXRlSGFuZGxlXG4gKiBAcGFyYW0ge2FueVtdfSBhcmdzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlSGFuZGxlLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gNjtcblx0dXNlTGF5b3V0RWZmZWN0KFxuXHRcdCgpID0+IHtcblx0XHRcdGlmICh0eXBlb2YgcmVmID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0cmVmKGNyZWF0ZUhhbmRsZSgpKTtcblx0XHRcdFx0cmV0dXJuICgpID0+IHJlZihudWxsKTtcblx0XHRcdH0gZWxzZSBpZiAocmVmKSB7XG5cdFx0XHRcdHJlZi5jdXJyZW50ID0gY3JlYXRlSGFuZGxlKCk7XG5cdFx0XHRcdHJldHVybiAoKSA9PiAocmVmLmN1cnJlbnQgPSBudWxsKTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdGFyZ3MgPT0gbnVsbCA/IGFyZ3MgOiBhcmdzLmNvbmNhdChyZWYpXG5cdCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsoKSA9PiBhbnl9IGZhY3RvcnlcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lbW8oZmFjdG9yeSwgYXJncykge1xuXHQvKiogQHR5cGUge2ltcG9ydCgnLi9pbnRlcm5hbCcpLk1lbW9Ib29rU3RhdGV9ICovXG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCA3KTtcblx0aWYgKGFyZ3NDaGFuZ2VkKHN0YXRlLl9hcmdzLCBhcmdzKSkge1xuXHRcdHN0YXRlLl9wZW5kaW5nVmFsdWUgPSBmYWN0b3J5KCk7XG5cdFx0c3RhdGUuX3BlbmRpbmdBcmdzID0gYXJncztcblx0XHRzdGF0ZS5fZmFjdG9yeSA9IGZhY3Rvcnk7XG5cdFx0cmV0dXJuIHN0YXRlLl9wZW5kaW5nVmFsdWU7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7YW55W119IGFyZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNhbGxiYWNrKGNhbGxiYWNrLCBhcmdzKSB7XG5cdGN1cnJlbnRIb29rID0gODtcblx0cmV0dXJuIHVzZU1lbW8oKCkgPT4gY2FsbGJhY2ssIGFyZ3MpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0Q29udGV4dH0gY29udGV4dFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29udGV4dChjb250ZXh0KSB7XG5cdGNvbnN0IHByb3ZpZGVyID0gY3VycmVudENvbXBvbmVudC5jb250ZXh0W2NvbnRleHQuX2lkXTtcblx0Ly8gV2UgY291bGQgc2tpcCB0aGlzIGNhbGwgaGVyZSwgYnV0IHRoYW4gd2UnZCBub3QgY2FsbFxuXHQvLyBgb3B0aW9ucy5faG9va2AuIFdlIG5lZWQgdG8gZG8gdGhhdCBpbiBvcmRlciB0byBtYWtlXG5cdC8vIHRoZSBkZXZ0b29scyBhd2FyZSBvZiB0aGlzIGhvb2suXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29udGV4dEhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDkpO1xuXHQvLyBUaGUgZGV2dG9vbHMgbmVlZHMgYWNjZXNzIHRvIHRoZSBjb250ZXh0IG9iamVjdCB0b1xuXHQvLyBiZSBhYmxlIHRvIHB1bGwgb2YgdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBubyBwcm92aWRlclxuXHQvLyBpcyBwcmVzZW50IGluIHRoZSB0cmVlLlxuXHRzdGF0ZS5fY29udGV4dCA9IGNvbnRleHQ7XG5cdGlmICghcHJvdmlkZXIpIHJldHVybiBjb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG5cdC8vIFRoaXMgaXMgcHJvYmFibHkgbm90IHNhZmUgdG8gY29udmVydCB0byBcIiFcIlxuXHRpZiAoc3RhdGUuX3ZhbHVlID09IG51bGwpIHtcblx0XHRzdGF0ZS5fdmFsdWUgPSB0cnVlO1xuXHRcdHByb3ZpZGVyLnN1YihjdXJyZW50Q29tcG9uZW50KTtcblx0fVxuXHRyZXR1cm4gcHJvdmlkZXIucHJvcHMudmFsdWU7XG59XG5cbi8qKlxuICogRGlzcGxheSBhIGN1c3RvbSBsYWJlbCBmb3IgYSBjdXN0b20gaG9vayBmb3IgdGhlIGRldnRvb2xzIHBhbmVsXG4gKiBAdHlwZSB7PFQ+KHZhbHVlOiBULCBjYj86ICh2YWx1ZTogVCkgPT4gc3RyaW5nIHwgbnVtYmVyKSA9PiB2b2lkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyKSB7XG5cdGlmIChvcHRpb25zLnVzZURlYnVnVmFsdWUpIHtcblx0XHRvcHRpb25zLnVzZURlYnVnVmFsdWUoZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlKSA6IHZhbHVlKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7KGVycm9yOiBhbnksIGVycm9ySW5mbzogaW1wb3J0KCdwcmVhY3QnKS5FcnJvckluZm8pID0+IHZvaWR9IGNiXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VFcnJvckJvdW5kYXJ5KGNiKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuRXJyb3JCb3VuZGFyeUhvb2tTdGF0ZX0gKi9cblx0Y29uc3Qgc3RhdGUgPSBnZXRIb29rU3RhdGUoY3VycmVudEluZGV4KyssIDEwKTtcblx0Y29uc3QgZXJyU3RhdGUgPSB1c2VTdGF0ZSgpO1xuXHRzdGF0ZS5fdmFsdWUgPSBjYjtcblx0aWYgKCFjdXJyZW50Q29tcG9uZW50LmNvbXBvbmVudERpZENhdGNoKSB7XG5cdFx0Y3VycmVudENvbXBvbmVudC5jb21wb25lbnREaWRDYXRjaCA9IChlcnIsIGVycm9ySW5mbykgPT4ge1xuXHRcdFx0aWYgKHN0YXRlLl92YWx1ZSkgc3RhdGUuX3ZhbHVlKGVyciwgZXJyb3JJbmZvKTtcblx0XHRcdGVyclN0YXRlWzFdKGVycik7XG5cdFx0fTtcblx0fVxuXHRyZXR1cm4gW1xuXHRcdGVyclN0YXRlWzBdLFxuXHRcdCgpID0+IHtcblx0XHRcdGVyclN0YXRlWzFdKHVuZGVmaW5lZCk7XG5cdFx0fVxuXHRdO1xufVxuXG5mdW5jdGlvbiBoYXNoKHMpIHtcblx0bGV0IGggPSAwLFxuXHRcdGkgPSBzLmxlbmd0aDtcblx0d2hpbGUgKGkgPiAwKSB7XG5cdFx0aCA9ICgoaCA8PCA1KSAtIGggKyBzLmNoYXJDb2RlQXQoLS1pKSkgfCAwO1xuXHR9XG5cdHJldHVybiBoO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlSWQoKSB7XG5cdGNvbnN0IHN0YXRlID0gZ2V0SG9va1N0YXRlKGN1cnJlbnRJbmRleCsrLCAxMSk7XG5cdGlmICghc3RhdGUuX3ZhbHVlKSB7XG5cdFx0c3RhdGUuX3ZhbHVlID0gJ1AnICsgaGFzaChjdXJyZW50Q29tcG9uZW50Ll92bm9kZS5fbWFzaykgKyBjdXJyZW50SW5kZXg7XG5cdH1cblxuXHRyZXR1cm4gc3RhdGUuX3ZhbHVlO1xufVxuLyoqXG4gKiBBZnRlciBwYWludCBlZmZlY3RzIGNvbnN1bWVyLlxuICovXG5mdW5jdGlvbiBmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKCkge1xuXHRsZXQgY29tcG9uZW50O1xuXHR3aGlsZSAoKGNvbXBvbmVudCA9IGFmdGVyUGFpbnRFZmZlY3RzLnNoaWZ0KCkpKSB7XG5cdFx0aWYgKCFjb21wb25lbnQuX3BhcmVudERvbSB8fCAhY29tcG9uZW50Ll9faG9va3MpIGNvbnRpbnVlO1xuXHRcdHRyeSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMuZm9yRWFjaChpbnZva2VDbGVhbnVwKTtcblx0XHRcdGNvbXBvbmVudC5fX2hvb2tzLl9wZW5kaW5nRWZmZWN0cy5mb3JFYWNoKGludm9rZUVmZmVjdCk7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRjb21wb25lbnQuX19ob29rcy5fcGVuZGluZ0VmZmVjdHMgPSBbXTtcblx0XHRcdG9wdGlvbnMuX2NhdGNoRXJyb3IoZSwgY29tcG9uZW50Ll92bm9kZSk7XG5cdFx0fVxuXHR9XG59XG5cbmxldCBIQVNfUkFGID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PSAnZnVuY3Rpb24nO1xuXG4vKipcbiAqIFNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgYnJvd3NlciBoYXMgYSBjaGFuY2UgdG8gcGFpbnQgYSBuZXcgZnJhbWUuXG4gKiBEbyB0aGlzIGJ5IGNvbWJpbmluZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKHJBRikgKyBzZXRUaW1lb3V0IHRvIGludm9rZSBhIGNhbGxiYWNrIGFmdGVyXG4gKiB0aGUgbmV4dCBicm93c2VyIGZyYW1lLlxuICpcbiAqIEFsc28sIHNjaGVkdWxlIGEgdGltZW91dCBpbiBwYXJhbGxlbCB0byB0aGUgdGhlIHJBRiB0byBlbnN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWRcbiAqIGV2ZW4gaWYgUkFGIGRvZXNuJ3QgZmlyZSAoZm9yIGV4YW1wbGUgaWYgdGhlIGJyb3dzZXIgdGFiIGlzIG5vdCB2aXNpYmxlKVxuICpcbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gY2FsbGJhY2tcbiAqL1xuZnVuY3Rpb24gYWZ0ZXJOZXh0RnJhbWUoY2FsbGJhY2spIHtcblx0Y29uc3QgZG9uZSA9ICgpID0+IHtcblx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0aWYgKEhBU19SQUYpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHJhZik7XG5cdFx0c2V0VGltZW91dChjYWxsYmFjayk7XG5cdH07XG5cdGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KGRvbmUsIFJBRl9USU1FT1VUKTtcblxuXHRsZXQgcmFmO1xuXHRpZiAoSEFTX1JBRikge1xuXHRcdHJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShkb25lKTtcblx0fVxufVxuXG4vLyBOb3RlOiBpZiBzb21lb25lIHVzZWQgb3B0aW9ucy5kZWJvdW5jZVJlbmRlcmluZyA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSxcbi8vIHRoZW4gZWZmZWN0cyB3aWxsIEFMV0FZUyBydW4gb24gdGhlIE5FWFQgZnJhbWUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBvbmUsIGluY3VycmluZyBhIH4xNm1zIGRlbGF5LlxuLy8gUGVyaGFwcyB0aGlzIGlzIG5vdCBzdWNoIGEgYmlnIGRlYWwuXG4vKipcbiAqIFNjaGVkdWxlIGFmdGVyUGFpbnRFZmZlY3RzIGZsdXNoIGFmdGVyIHRoZSBicm93c2VyIHBhaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG5ld1F1ZXVlTGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGFmdGVyUGFpbnQobmV3UXVldWVMZW5ndGgpIHtcblx0aWYgKG5ld1F1ZXVlTGVuZ3RoID09PSAxIHx8IHByZXZSYWYgIT09IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG5cdFx0cHJldlJhZiA9IG9wdGlvbnMucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXHRcdChwcmV2UmFmIHx8IGFmdGVyTmV4dEZyYW1lKShmbHVzaEFmdGVyUGFpbnRFZmZlY3RzKTtcblx0fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuRWZmZWN0SG9va1N0YXRlfSBob29rXG4gKi9cbmZ1bmN0aW9uIGludm9rZUNsZWFudXAoaG9vaykge1xuXHQvLyBBIGhvb2sgY2xlYW51cCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRsZXQgY2xlYW51cCA9IGhvb2suX2NsZWFudXA7XG5cdGlmICh0eXBlb2YgY2xlYW51cCA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0aG9vay5fY2xlYW51cCA9IHVuZGVmaW5lZDtcblx0XHRjbGVhbnVwKCk7XG5cdH1cblxuXHRjdXJyZW50Q29tcG9uZW50ID0gY29tcDtcbn1cblxuLyoqXG4gKiBJbnZva2UgYSBIb29rJ3MgZWZmZWN0XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkVmZmVjdEhvb2tTdGF0ZX0gaG9va1xuICovXG5mdW5jdGlvbiBpbnZva2VFZmZlY3QoaG9vaykge1xuXHQvLyBBIGhvb2sgY2FsbCBjYW4gaW50cm9kdWNlIGEgY2FsbCB0byByZW5kZXIgd2hpY2ggY3JlYXRlcyBhIG5ldyByb290LCB0aGlzIHdpbGwgY2FsbCBvcHRpb25zLnZub2RlXG5cdC8vIGFuZCBtb3ZlIHRoZSBjdXJyZW50Q29tcG9uZW50IGF3YXkuXG5cdGNvbnN0IGNvbXAgPSBjdXJyZW50Q29tcG9uZW50O1xuXHRob29rLl9jbGVhbnVwID0gaG9vay5fdmFsdWUoKTtcblx0Y3VycmVudENvbXBvbmVudCA9IGNvbXA7XG59XG5cbi8qKlxuICogQHBhcmFtIHthbnlbXX0gb2xkQXJnc1xuICogQHBhcmFtIHthbnlbXX0gbmV3QXJnc1xuICovXG5mdW5jdGlvbiBhcmdzQ2hhbmdlZChvbGRBcmdzLCBuZXdBcmdzKSB7XG5cdHJldHVybiAoXG5cdFx0IW9sZEFyZ3MgfHxcblx0XHRvbGRBcmdzLmxlbmd0aCAhPT0gbmV3QXJncy5sZW5ndGggfHxcblx0XHRuZXdBcmdzLnNvbWUoKGFyZywgaW5kZXgpID0+IGFyZyAhPT0gb2xkQXJnc1tpbmRleF0pXG5cdCk7XG59XG5cbmZ1bmN0aW9uIGludm9rZU9yUmV0dXJuKGFyZywgZikge1xuXHRyZXR1cm4gdHlwZW9mIGYgPT0gJ2Z1bmN0aW9uJyA/IGYoYXJnKSA6IGY7XG59XG4iLCIvKipcbiAqIEFzc2lnbiBwcm9wZXJ0aWVzIGZyb20gYHByb3BzYCB0byBgb2JqYFxuICogQHRlbXBsYXRlIE8sIFAgVGhlIG9iaiBhbmQgcHJvcHMgdHlwZXNcbiAqIEBwYXJhbSB7T30gb2JqIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvXG4gKiBAcGFyYW0ge1B9IHByb3BzIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEByZXR1cm5zIHtPICYgUH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbihvYmosIHByb3BzKSB7XG5cdGZvciAobGV0IGkgaW4gcHJvcHMpIG9ialtpXSA9IHByb3BzW2ldO1xuXHRyZXR1cm4gLyoqIEB0eXBlIHtPICYgUH0gKi8gKG9iaik7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdHdvIG9iamVjdHMgaGF2ZSBhIGRpZmZlcmVudCBzaGFwZVxuICogQHBhcmFtIHtvYmplY3R9IGFcbiAqIEBwYXJhbSB7b2JqZWN0fSBiXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dEaWZmZXJzKGEsIGIpIHtcblx0Zm9yIChsZXQgaSBpbiBhKSBpZiAoaSAhPT0gJ19fc291cmNlJyAmJiAhKGkgaW4gYikpIHJldHVybiB0cnVlO1xuXHRmb3IgKGxldCBpIGluIGIpIGlmIChpICE9PSAnX19zb3VyY2UnICYmIGFbaV0gIT09IGJbaV0pIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVOb2RlKG5vZGUpIHtcblx0bGV0IHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdGlmIChwYXJlbnROb2RlKSBwYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xufVxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHNoYWxsb3dEaWZmZXJzIH0gZnJvbSAnLi91dGlsJztcblxuLyoqXG4gKiBDb21wb25lbnQgY2xhc3Mgd2l0aCBhIHByZWRlZmluZWQgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAgaW1wbGVtZW50YXRpb25cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFB1cmVDb21wb25lbnQocCkge1xuXHR0aGlzLnByb3BzID0gcDtcbn1cblB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudCgpO1xuLy8gU29tZSB0aGlyZC1wYXJ0eSBsaWJyYXJpZXMgY2hlY2sgaWYgdGhpcyBwcm9wZXJ0eSBpcyBwcmVzZW50XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0cmV0dXJuIHNoYWxsb3dEaWZmZXJzKHRoaXMucHJvcHMsIHByb3BzKSB8fCBzaGFsbG93RGlmZmVycyh0aGlzLnN0YXRlLCBzdGF0ZSk7XG59O1xuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3ByZWFjdCc7XG5pbXBvcnQgeyBzaGFsbG93RGlmZmVycyB9IGZyb20gJy4vdXRpbCc7XG5cbi8qKlxuICogTWVtb2l6ZSBhIGNvbXBvbmVudCwgc28gdGhhdCBpdCBvbmx5IHVwZGF0ZXMgd2hlbiB0aGUgcHJvcHMgYWN0dWFsbHkgaGF2ZVxuICogY2hhbmdlZC4gVGhpcyB3YXMgcHJldmlvdXNseSBrbm93biBhcyBgUmVhY3QucHVyZWAuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkZ1bmN0aW9uQ29tcG9uZW50fSBjIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gKiBAcGFyYW0geyhwcmV2OiBvYmplY3QsIG5leHQ6IG9iamVjdCkgPT4gYm9vbGVhbn0gW2NvbXBhcmVyXSBDdXN0b20gZXF1YWxpdHkgZnVuY3Rpb25cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1lbW8oYywgY29tcGFyZXIpIHtcblx0ZnVuY3Rpb24gc2hvdWxkVXBkYXRlKG5leHRQcm9wcykge1xuXHRcdGxldCByZWYgPSB0aGlzLnByb3BzLnJlZjtcblx0XHRsZXQgdXBkYXRlUmVmID0gcmVmID09IG5leHRQcm9wcy5yZWY7XG5cdFx0aWYgKCF1cGRhdGVSZWYgJiYgcmVmKSB7XG5cdFx0XHRyZWYuY2FsbCA/IHJlZihudWxsKSA6IChyZWYuY3VycmVudCA9IG51bGwpO1xuXHRcdH1cblxuXHRcdGlmICghY29tcGFyZXIpIHtcblx0XHRcdHJldHVybiBzaGFsbG93RGlmZmVycyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuXHRcdH1cblxuXHRcdHJldHVybiAhY29tcGFyZXIodGhpcy5wcm9wcywgbmV4dFByb3BzKSB8fCAhdXBkYXRlUmVmO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVtb2VkKHByb3BzKSB7XG5cdFx0dGhpcy5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBzaG91bGRVcGRhdGU7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoYywgcHJvcHMpO1xuXHR9XG5cdE1lbW9lZC5kaXNwbGF5TmFtZSA9ICdNZW1vKCcgKyAoYy5kaXNwbGF5TmFtZSB8fCBjLm5hbWUpICsgJyknO1xuXHRNZW1vZWQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXHRNZW1vZWQuX2ZvcndhcmRlZCA9IHRydWU7XG5cdHJldHVybiBNZW1vZWQ7XG59XG4iLCJpbXBvcnQgeyBvcHRpb25zIH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmxldCBvbGREaWZmSG9vayA9IG9wdGlvbnMuX2RpZmY7XG5vcHRpb25zLl9kaWZmID0gdm5vZGUgPT4ge1xuXHRpZiAodm5vZGUudHlwZSAmJiB2bm9kZS50eXBlLl9mb3J3YXJkZWQgJiYgdm5vZGUucmVmKSB7XG5cdFx0dm5vZGUucHJvcHMucmVmID0gdm5vZGUucmVmO1xuXHRcdHZub2RlLnJlZiA9IG51bGw7XG5cdH1cblx0aWYgKG9sZERpZmZIb29rKSBvbGREaWZmSG9vayh2bm9kZSk7XG59O1xuXG5leHBvcnQgY29uc3QgUkVBQ1RfRk9SV0FSRF9TWU1CT0wgPVxuXHQodHlwZW9mIFN5bWJvbCAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFN5bWJvbC5mb3IgJiZcblx0XHRTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpKSB8fFxuXHQweGY0NztcblxuLyoqXG4gKiBQYXNzIHJlZiBkb3duIHRvIGEgY2hpbGQuIFRoaXMgaXMgbWFpbmx5IHVzZWQgaW4gbGlicmFyaWVzIHdpdGggSE9DcyB0aGF0XG4gKiB3cmFwIGNvbXBvbmVudHMuIFVzaW5nIGBmb3J3YXJkUmVmYCB0aGVyZSBpcyBhbiBlYXN5IHdheSB0byBnZXQgYSByZWZlcmVuY2VcbiAqIG9mIHRoZSB3cmFwcGVkIGNvbXBvbmVudCBpbnN0ZWFkIG9mIG9uZSBvZiB0aGUgd3JhcHBlciBpdHNlbGYuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbmRleCcpLkZvcndhcmRGbn0gZm5cbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5GdW5jdGlvbkNvbXBvbmVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcndhcmRSZWYoZm4pIHtcblx0ZnVuY3Rpb24gRm9yd2FyZGVkKHByb3BzKSB7XG5cdFx0bGV0IGNsb25lID0gYXNzaWduKHt9LCBwcm9wcyk7XG5cdFx0ZGVsZXRlIGNsb25lLnJlZjtcblx0XHRyZXR1cm4gZm4oY2xvbmUsIHByb3BzLnJlZiB8fCBudWxsKTtcblx0fVxuXG5cdC8vIG1vYngtcmVhY3QgY2hlY2tzIGZvciB0aGlzIGJlaW5nIHByZXNlbnRcblx0Rm9yd2FyZGVkLiQkdHlwZW9mID0gUkVBQ1RfRk9SV0FSRF9TWU1CT0w7XG5cdC8vIG1vYngtcmVhY3QgaGVhdmlseSByZWxpZXMgb24gaW1wbGVtZW50YXRpb24gZGV0YWlscy5cblx0Ly8gSXQgZXhwZWN0cyBhbiBvYmplY3QgaGVyZSB3aXRoIGEgYHJlbmRlcmAgcHJvcGVydHksXG5cdC8vIGFuZCBwcm90b3R5cGUucmVuZGVyIHdpbGwgZmFpbC4gV2l0aG91dCB0aGlzXG5cdC8vIG1vYngtcmVhY3QgdGhyb3dzLlxuXHRGb3J3YXJkZWQucmVuZGVyID0gRm9yd2FyZGVkO1xuXG5cdEZvcndhcmRlZC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IEZvcndhcmRlZC5fZm9yd2FyZGVkID0gdHJ1ZTtcblx0Rm9yd2FyZGVkLmRpc3BsYXlOYW1lID0gJ0ZvcndhcmRSZWYoJyArIChmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lKSArICcpJztcblx0cmV0dXJuIEZvcndhcmRlZDtcbn1cbiIsImltcG9ydCB7IHRvQ2hpbGRBcnJheSB9IGZyb20gJ3ByZWFjdCc7XG5cbmNvbnN0IG1hcEZuID0gKGNoaWxkcmVuLCBmbikgPT4ge1xuXHRpZiAoY2hpbGRyZW4gPT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cdHJldHVybiB0b0NoaWxkQXJyYXkodG9DaGlsZEFycmF5KGNoaWxkcmVuKS5tYXAoZm4pKTtcbn07XG5cbi8vIFRoaXMgQVBJIGlzIGNvbXBsZXRlbHkgdW5uZWNlc3NhcnkgZm9yIFByZWFjdCwgc28gaXQncyBiYXNpY2FsbHkgcGFzc3Rocm91Z2guXG5leHBvcnQgY29uc3QgQ2hpbGRyZW4gPSB7XG5cdG1hcDogbWFwRm4sXG5cdGZvckVhY2g6IG1hcEZuLFxuXHRjb3VudChjaGlsZHJlbikge1xuXHRcdHJldHVybiBjaGlsZHJlbiA/IHRvQ2hpbGRBcnJheShjaGlsZHJlbikubGVuZ3RoIDogMDtcblx0fSxcblx0b25seShjaGlsZHJlbikge1xuXHRcdGNvbnN0IG5vcm1hbGl6ZWQgPSB0b0NoaWxkQXJyYXkoY2hpbGRyZW4pO1xuXHRcdGlmIChub3JtYWxpemVkLmxlbmd0aCAhPT0gMSkgdGhyb3cgJ0NoaWxkcmVuLm9ubHknO1xuXHRcdHJldHVybiBub3JtYWxpemVkWzBdO1xuXHR9LFxuXHR0b0FycmF5OiB0b0NoaWxkQXJyYXlcbn07XG4iLCJpbXBvcnQgeyBDb21wb25lbnQsIGNyZWF0ZUVsZW1lbnQsIG9wdGlvbnMsIEZyYWdtZW50IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IGFzc2lnbiB9IGZyb20gJy4vdXRpbCc7XG5cbmNvbnN0IG9sZENhdGNoRXJyb3IgPSBvcHRpb25zLl9jYXRjaEVycm9yO1xub3B0aW9ucy5fY2F0Y2hFcnJvciA9IGZ1bmN0aW9uKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbykge1xuXHRpZiAoZXJyb3IudGhlbikge1xuXHRcdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRcdGxldCBjb21wb25lbnQ7XG5cdFx0bGV0IHZub2RlID0gbmV3Vk5vZGU7XG5cblx0XHRmb3IgKDsgKHZub2RlID0gdm5vZGUuX3BhcmVudCk7ICkge1xuXHRcdFx0aWYgKChjb21wb25lbnQgPSB2bm9kZS5fY29tcG9uZW50KSAmJiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZCkge1xuXHRcdFx0XHRpZiAobmV3Vk5vZGUuX2RvbSA9PSBudWxsKSB7XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2RvbSA9IG9sZFZOb2RlLl9kb207XG5cdFx0XHRcdFx0bmV3Vk5vZGUuX2NoaWxkcmVuID0gb2xkVk5vZGUuX2NoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIERvbid0IGNhbGwgb2xkQ2F0Y2hFcnJvciBpZiB3ZSBmb3VuZCBhIFN1c3BlbnNlXG5cdFx0XHRcdHJldHVybiBjb21wb25lbnQuX2NoaWxkRGlkU3VzcGVuZChlcnJvciwgbmV3Vk5vZGUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRvbGRDYXRjaEVycm9yKGVycm9yLCBuZXdWTm9kZSwgb2xkVk5vZGUsIGVycm9ySW5mbyk7XG59O1xuXG5jb25zdCBvbGRVbm1vdW50ID0gb3B0aW9ucy51bm1vdW50O1xub3B0aW9ucy51bm1vdW50ID0gZnVuY3Rpb24odm5vZGUpIHtcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9ICovXG5cdGNvbnN0IGNvbXBvbmVudCA9IHZub2RlLl9jb21wb25lbnQ7XG5cdGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Ll9vblJlc29sdmUpIHtcblx0XHRjb21wb25lbnQuX29uUmVzb2x2ZSgpO1xuXHR9XG5cblx0Ly8gaWYgdGhlIGNvbXBvbmVudCBpcyBzdGlsbCBoeWRyYXRpbmdcblx0Ly8gbW9zdCBsaWtlbHkgaXQgaXMgYmVjYXVzZSB0aGUgY29tcG9uZW50IGlzIHN1c3BlbmRlZFxuXHQvLyB3ZSBzZXQgdGhlIHZub2RlLnR5cGUgYXMgYG51bGxgIHNvIHRoYXQgaXQgaXMgbm90IGEgdHlwZW9mIGZ1bmN0aW9uXG5cdC8vIHNvIHRoZSB1bm1vdW50IHdpbGwgcmVtb3ZlIHRoZSB2bm9kZS5fZG9tXG5cdGlmIChjb21wb25lbnQgJiYgdm5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZSkge1xuXHRcdHZub2RlLnR5cGUgPSBudWxsO1xuXHR9XG5cblx0aWYgKG9sZFVubW91bnQpIG9sZFVubW91bnQodm5vZGUpO1xufTtcblxuZnVuY3Rpb24gZGV0YWNoZWRDbG9uZSh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIHBhcmVudERvbSkge1xuXHRpZiAodm5vZGUpIHtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAmJiB2bm9kZS5fY29tcG9uZW50Ll9faG9va3MpIHtcblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcy5fbGlzdC5mb3JFYWNoKGVmZmVjdCA9PiB7XG5cdFx0XHRcdGlmICh0eXBlb2YgZWZmZWN0Ll9jbGVhbnVwID09ICdmdW5jdGlvbicpIGVmZmVjdC5fY2xlYW51cCgpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHZub2RlLl9jb21wb25lbnQuX19ob29rcyA9IG51bGw7XG5cdFx0fVxuXG5cdFx0dm5vZGUgPSBhc3NpZ24oe30sIHZub2RlKTtcblx0XHRpZiAodm5vZGUuX2NvbXBvbmVudCAhPSBudWxsKSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBwYXJlbnREb20pIHtcblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID0gZGV0YWNoZWRQYXJlbnQ7XG5cdFx0XHR9XG5cdFx0XHR2bm9kZS5fY29tcG9uZW50ID0gbnVsbDtcblx0XHR9XG5cblx0XHR2bm9kZS5fY2hpbGRyZW4gPVxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuICYmXG5cdFx0XHR2bm9kZS5fY2hpbGRyZW4ubWFwKGNoaWxkID0+XG5cdFx0XHRcdGRldGFjaGVkQ2xvbmUoY2hpbGQsIGRldGFjaGVkUGFyZW50LCBwYXJlbnREb20pXG5cdFx0XHQpO1xuXHR9XG5cblx0cmV0dXJuIHZub2RlO1xufVxuXG5mdW5jdGlvbiByZW1vdmVPcmlnaW5hbCh2bm9kZSwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KSB7XG5cdGlmICh2bm9kZSkge1xuXHRcdHZub2RlLl9vcmlnaW5hbCA9IG51bGw7XG5cdFx0dm5vZGUuX2NoaWxkcmVuID1cblx0XHRcdHZub2RlLl9jaGlsZHJlbiAmJlxuXHRcdFx0dm5vZGUuX2NoaWxkcmVuLm1hcChjaGlsZCA9PlxuXHRcdFx0XHRyZW1vdmVPcmlnaW5hbChjaGlsZCwgZGV0YWNoZWRQYXJlbnQsIG9yaWdpbmFsUGFyZW50KVxuXHRcdFx0KTtcblxuXHRcdGlmICh2bm9kZS5fY29tcG9uZW50KSB7XG5cdFx0XHRpZiAodm5vZGUuX2NvbXBvbmVudC5fcGFyZW50RG9tID09PSBkZXRhY2hlZFBhcmVudCkge1xuXHRcdFx0XHRpZiAodm5vZGUuX2RvbSkge1xuXHRcdFx0XHRcdG9yaWdpbmFsUGFyZW50Lmluc2VydEJlZm9yZSh2bm9kZS5fZG9tLCB2bm9kZS5fbmV4dERvbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dm5vZGUuX2NvbXBvbmVudC5fZm9yY2UgPSB0cnVlO1xuXHRcdFx0XHR2bm9kZS5fY29tcG9uZW50Ll9wYXJlbnREb20gPSBvcmlnaW5hbFBhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdm5vZGU7XG59XG5cbi8vIGhhdmluZyBjdXN0b20gaW5oZXJpdGFuY2UgaW5zdGVhZCBvZiBhIGNsYXNzIGhlcmUgc2F2ZXMgYSBsb3Qgb2YgYnl0ZXNcbmV4cG9ydCBmdW5jdGlvbiBTdXNwZW5zZSgpIHtcblx0Ly8gd2UgZG8gbm90IGNhbGwgc3VwZXIgaGVyZSB0byBnb2xmIHNvbWUgYnl0ZXMuLi5cblx0dGhpcy5fcGVuZGluZ1N1c3BlbnNpb25Db3VudCA9IDA7XG5cdHRoaXMuX3N1c3BlbmRlcnMgPSBudWxsO1xuXHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xufVxuXG4vLyBUaGluZ3Mgd2UgZG8gaGVyZSB0byBzYXZlIHNvbWUgYnl0ZXMgYnV0IGFyZSBub3QgcHJvcGVyIEpTIGluaGVyaXRhbmNlOlxuLy8gLSBjYWxsIGBuZXcgQ29tcG9uZW50KClgIGFzIHRoZSBwcm90b3R5cGVcbi8vIC0gZG8gbm90IHNldCBgU3VzcGVuc2UucHJvdG90eXBlLmNvbnN0cnVjdG9yYCB0byBgU3VzcGVuc2VgXG5TdXNwZW5zZS5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50KCk7XG5cbi8qKlxuICogQHRoaXMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50fVxuICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlIFRoZSB0aHJvd24gcHJvbWlzZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZTxhbnksIGFueT59IHN1c3BlbmRpbmdWTm9kZSBUaGUgc3VzcGVuZGluZyBjb21wb25lbnRcbiAqL1xuU3VzcGVuc2UucHJvdG90eXBlLl9jaGlsZERpZFN1c3BlbmQgPSBmdW5jdGlvbihwcm9taXNlLCBzdXNwZW5kaW5nVk5vZGUpIHtcblx0Y29uc3Qgc3VzcGVuZGluZ0NvbXBvbmVudCA9IHN1c3BlbmRpbmdWTm9kZS5fY29tcG9uZW50O1xuXG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9ICovXG5cdGNvbnN0IGMgPSB0aGlzO1xuXG5cdGlmIChjLl9zdXNwZW5kZXJzID09IG51bGwpIHtcblx0XHRjLl9zdXNwZW5kZXJzID0gW107XG5cdH1cblx0Yy5fc3VzcGVuZGVycy5wdXNoKHN1c3BlbmRpbmdDb21wb25lbnQpO1xuXG5cdGNvbnN0IHJlc29sdmUgPSBzdXNwZW5kZWQoYy5fdm5vZGUpO1xuXG5cdGxldCByZXNvbHZlZCA9IGZhbHNlO1xuXHRjb25zdCBvblJlc29sdmVkID0gKCkgPT4ge1xuXHRcdGlmIChyZXNvbHZlZCkgcmV0dXJuO1xuXG5cdFx0cmVzb2x2ZWQgPSB0cnVlO1xuXHRcdHN1c3BlbmRpbmdDb21wb25lbnQuX29uUmVzb2x2ZSA9IG51bGw7XG5cblx0XHRpZiAocmVzb2x2ZSkge1xuXHRcdFx0cmVzb2x2ZShvblN1c3BlbnNpb25Db21wbGV0ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9uU3VzcGVuc2lvbkNvbXBsZXRlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdHN1c3BlbmRpbmdDb21wb25lbnQuX29uUmVzb2x2ZSA9IG9uUmVzb2x2ZWQ7XG5cblx0Y29uc3Qgb25TdXNwZW5zaW9uQ29tcGxldGUgPSAoKSA9PiB7XG5cdFx0aWYgKCEtLWMuX3BlbmRpbmdTdXNwZW5zaW9uQ291bnQpIHtcblx0XHRcdC8vIElmIHRoZSBzdXNwZW5zaW9uIHdhcyBkdXJpbmcgaHlkcmF0aW9uIHdlIGRvbid0IG5lZWQgdG8gcmVzdG9yZSB0aGVcblx0XHRcdC8vIHN1c3BlbmRlZCBjaGlsZHJlbiBpbnRvIHRoZSBfY2hpbGRyZW4gYXJyYXlcblx0XHRcdGlmIChjLnN0YXRlLl9zdXNwZW5kZWQpIHtcblx0XHRcdFx0Y29uc3Qgc3VzcGVuZGVkVk5vZGUgPSBjLnN0YXRlLl9zdXNwZW5kZWQ7XG5cdFx0XHRcdGMuX3Zub2RlLl9jaGlsZHJlblswXSA9IHJlbW92ZU9yaWdpbmFsKFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLFxuXHRcdFx0XHRcdHN1c3BlbmRlZFZOb2RlLl9jb21wb25lbnQuX3BhcmVudERvbSxcblx0XHRcdFx0XHRzdXNwZW5kZWRWTm9kZS5fY29tcG9uZW50Ll9vcmlnaW5hbFBhcmVudERvbVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXG5cdFx0XHRjLnNldFN0YXRlKHsgX3N1c3BlbmRlZDogKGMuX2RldGFjaE9uTmV4dFJlbmRlciA9IG51bGwpIH0pO1xuXG5cdFx0XHRsZXQgc3VzcGVuZGVkO1xuXHRcdFx0d2hpbGUgKChzdXNwZW5kZWQgPSBjLl9zdXNwZW5kZXJzLnBvcCgpKSkge1xuXHRcdFx0XHRzdXNwZW5kZWQuZm9yY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFdlIGRvIG5vdCBzZXQgYHN1c3BlbmRlZDogdHJ1ZWAgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHdlIHdhbnQgdGhlIGFjdHVhbCBtYXJrdXBcblx0ICogdG8gcmVtYWluIG9uIHNjcmVlbiBhbmQgaHlkcmF0ZSBpdCB3aGVuIHRoZSBzdXNwZW5zZSBhY3R1YWxseSBnZXRzIHJlc29sdmVkLlxuXHQgKiBXaGlsZSBpbiBub24taHlkcmF0aW9uIGNhc2VzIHRoZSB1c3VhbCBmYWxsYmFjayAtPiBjb21wb25lbnQgZmxvdyB3b3VsZCBvY2NvdXIuXG5cdCAqL1xuXHRjb25zdCB3YXNIeWRyYXRpbmcgPSBzdXNwZW5kaW5nVk5vZGUuX2h5ZHJhdGluZyA9PT0gdHJ1ZTtcblx0aWYgKCFjLl9wZW5kaW5nU3VzcGVuc2lvbkNvdW50KysgJiYgIXdhc0h5ZHJhdGluZykge1xuXHRcdGMuc2V0U3RhdGUoeyBfc3VzcGVuZGVkOiAoYy5fZGV0YWNoT25OZXh0UmVuZGVyID0gYy5fdm5vZGUuX2NoaWxkcmVuWzBdKSB9KTtcblx0fVxuXHRwcm9taXNlLnRoZW4ob25SZXNvbHZlZCwgb25SZXNvbHZlZCk7XG59O1xuXG5TdXNwZW5zZS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbigpIHtcblx0dGhpcy5fc3VzcGVuZGVycyA9IFtdO1xufTtcblxuLyoqXG4gKiBAdGhpcyB7aW1wb3J0KCcuL2ludGVybmFsJykuU3VzcGVuc2VDb21wb25lbnR9XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlQ29tcG9uZW50W1wicHJvcHNcIl19IHByb3BzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlN1c3BlbnNlU3RhdGV9IHN0YXRlXG4gKi9cblN1c3BlbnNlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbihwcm9wcywgc3RhdGUpIHtcblx0aWYgKHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcikge1xuXHRcdC8vIFdoZW4gdGhlIFN1c3BlbnNlJ3MgX3Zub2RlIHdhcyBjcmVhdGVkIGJ5IGEgY2FsbCB0byBjcmVhdGVWTm9kZVxuXHRcdC8vIChpLmUuIGR1ZSB0byBhIHNldFN0YXRlIGZ1cnRoZXIgdXAgaW4gdGhlIHRyZWUpXG5cdFx0Ly8gaXQncyBfY2hpbGRyZW4gcHJvcCBpcyBudWxsLCBpbiB0aGlzIGNhc2Ugd2UgXCJmb3JnZXRcIiBhYm91dCB0aGUgcGFya2VkIHZub2RlcyB0byBkZXRhY2hcblx0XHRpZiAodGhpcy5fdm5vZGUuX2NoaWxkcmVuKSB7XG5cdFx0XHRjb25zdCBkZXRhY2hlZFBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0Y29uc3QgZGV0YWNoZWRDb21wb25lbnQgPSB0aGlzLl92bm9kZS5fY2hpbGRyZW5bMF0uX2NvbXBvbmVudDtcblx0XHRcdHRoaXMuX3Zub2RlLl9jaGlsZHJlblswXSA9IGRldGFjaGVkQ2xvbmUoXG5cdFx0XHRcdHRoaXMuX2RldGFjaE9uTmV4dFJlbmRlcixcblx0XHRcdFx0ZGV0YWNoZWRQYXJlbnQsXG5cdFx0XHRcdChkZXRhY2hlZENvbXBvbmVudC5fb3JpZ2luYWxQYXJlbnREb20gPSBkZXRhY2hlZENvbXBvbmVudC5fcGFyZW50RG9tKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLl9kZXRhY2hPbk5leHRSZW5kZXIgPSBudWxsO1xuXHR9XG5cblx0Ly8gV3JhcCBmYWxsYmFjayB0cmVlIGluIGEgVk5vZGUgdGhhdCBwcmV2ZW50cyBpdHNlbGYgZnJvbSBiZWluZyBtYXJrZWQgYXMgYWJvcnRpbmcgbWlkLWh5ZHJhdGlvbjpcblx0LyoqIEB0eXBlIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gKi9cblx0Y29uc3QgZmFsbGJhY2sgPVxuXHRcdHN0YXRlLl9zdXNwZW5kZWQgJiYgY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgcHJvcHMuZmFsbGJhY2spO1xuXHRpZiAoZmFsbGJhY2spIGZhbGxiYWNrLl9oeWRyYXRpbmcgPSBudWxsO1xuXG5cdHJldHVybiBbXG5cdFx0Y3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgc3RhdGUuX3N1c3BlbmRlZCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbiksXG5cdFx0ZmFsbGJhY2tcblx0XTtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGFuZCBjYWxscyB0aGUgcGFyZW50IGNvbXBvbmVudCdzIF9zdXNwZW5kZWQgbWV0aG9kLCBwYXNzaW5nIGluIHRoZVxuICogc3VzcGVuZGVkIHZub2RlLiBUaGlzIGlzIGEgd2F5IGZvciBhIHBhcmVudCAoZS5nLiBTdXNwZW5zZUxpc3QpIHRvIGdldCBub3RpZmllZFxuICogdGhhdCBvbmUgb2YgaXRzIGNoaWxkcmVuL2Rlc2NlbmRhbnRzIHN1c3BlbmRlZC5cbiAqXG4gKiBUaGUgcGFyZW50IE1BWSByZXR1cm4gYSBjYWxsYmFjay4gVGhlIGNhbGxiYWNrIHdpbGwgZ2V0IGNhbGxlZCB3aGVuIHRoZVxuICogc3VzcGVuc2lvbiByZXNvbHZlcywgbm90aWZ5aW5nIHRoZSBwYXJlbnQgb2YgdGhlIGZhY3QuXG4gKiBNb3Jlb3ZlciwgdGhlIGNhbGxiYWNrIGdldHMgZnVuY3Rpb24gYHVuc3VzcGVuZGAgYXMgYSBwYXJhbWV0ZXIuIFRoZSByZXNvbHZlZFxuICogY2hpbGQgZGVzY2VuZGFudCB3aWxsIG5vdCBhY3R1YWxseSBnZXQgdW5zdXNwZW5kZWQgdW50aWwgYHVuc3VzcGVuZGAgZ2V0cyBjYWxsZWQuXG4gKiBUaGlzIGlzIGEgd2F5IGZvciB0aGUgcGFyZW50IHRvIGRlbGF5IHVuc3VzcGVuZGluZy5cbiAqXG4gKiBJZiB0aGUgcGFyZW50IGRvZXMgbm90IHJldHVybiBhIGNhbGxiYWNrIHRoZW4gdGhlIHJlc29sdmVkIHZub2RlXG4gKiBnZXRzIHVuc3VzcGVuZGVkIGltbWVkaWF0ZWx5IHdoZW4gaXQgcmVzb2x2ZXMuXG4gKlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGVcbiAqIEByZXR1cm5zIHsoKHVuc3VzcGVuZDogKCkgPT4gdm9pZCkgPT4gdm9pZCk/fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VzcGVuZGVkKHZub2RlKSB7XG5cdC8qKiBAdHlwZSB7aW1wb3J0KCcuL2ludGVybmFsJykuQ29tcG9uZW50fSAqL1xuXHRsZXQgY29tcG9uZW50ID0gdm5vZGUuX3BhcmVudC5fY29tcG9uZW50O1xuXHRyZXR1cm4gY29tcG9uZW50ICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkICYmIGNvbXBvbmVudC5fc3VzcGVuZGVkKHZub2RlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxhenkobG9hZGVyKSB7XG5cdGxldCBwcm9tO1xuXHRsZXQgY29tcG9uZW50O1xuXHRsZXQgZXJyb3I7XG5cblx0ZnVuY3Rpb24gTGF6eShwcm9wcykge1xuXHRcdGlmICghcHJvbSkge1xuXHRcdFx0cHJvbSA9IGxvYWRlcigpO1xuXHRcdFx0cHJvbS50aGVuKFxuXHRcdFx0XHRleHBvcnRzID0+IHtcblx0XHRcdFx0XHRjb21wb25lbnQgPSBleHBvcnRzLmRlZmF1bHQgfHwgZXhwb3J0cztcblx0XHRcdFx0fSxcblx0XHRcdFx0ZSA9PiB7XG5cdFx0XHRcdFx0ZXJyb3IgPSBlO1xuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdH1cblxuXHRcdGlmIChlcnJvcikge1xuXHRcdFx0dGhyb3cgZXJyb3I7XG5cdFx0fVxuXG5cdFx0aWYgKCFjb21wb25lbnQpIHtcblx0XHRcdHRocm93IHByb207XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoY29tcG9uZW50LCBwcm9wcyk7XG5cdH1cblxuXHRMYXp5LmRpc3BsYXlOYW1lID0gJ0xhenknO1xuXHRMYXp5Ll9mb3J3YXJkZWQgPSB0cnVlO1xuXHRyZXR1cm4gTGF6eTtcbn1cbiIsImltcG9ydCB7IENvbXBvbmVudCwgdG9DaGlsZEFycmF5IH0gZnJvbSAncHJlYWN0JztcbmltcG9ydCB7IHN1c3BlbmRlZCB9IGZyb20gJy4vc3VzcGVuc2UuanMnO1xuXG4vLyBJbmRleGVzIHRvIGxpbmtlZCBsaXN0IG5vZGVzIChub2RlcyBhcmUgc3RvcmVkIGFzIGFycmF5cyB0byBzYXZlIGJ5dGVzKS5cbmNvbnN0IFNVU1BFTkRFRF9DT1VOVCA9IDA7XG5jb25zdCBSRVNPTFZFRF9DT1VOVCA9IDE7XG5jb25zdCBORVhUX05PREUgPSAyO1xuXG4vLyBIYXZpbmcgY3VzdG9tIGluaGVyaXRhbmNlIGluc3RlYWQgb2YgYSBjbGFzcyBoZXJlIHNhdmVzIGEgbG90IG9mIGJ5dGVzLlxuZXhwb3J0IGZ1bmN0aW9uIFN1c3BlbnNlTGlzdCgpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG51bGw7XG59XG5cbi8vIE1hcmsgb25lIG9mIGNoaWxkJ3MgZWFybGllciBzdXNwZW5zaW9ucyBhcyByZXNvbHZlZC5cbi8vIFNvbWUgcGVuZGluZyBjYWxsYmFja3MgbWF5IGJlY29tZSBjYWxsYWJsZSBkdWUgdG8gdGhpc1xuLy8gKGUuZy4gdGhlIGxhc3Qgc3VzcGVuZGVkIGRlc2NlbmRhbnQgZ2V0cyByZXNvbHZlZCB3aGVuXG4vLyByZXZlYWxPcmRlciA9PT0gJ3RvZ2V0aGVyJykuIFByb2Nlc3MgdGhvc2UgY2FsbGJhY2tzIGFzIHdlbGwuXG5jb25zdCByZXNvbHZlID0gKGxpc3QsIGNoaWxkLCBub2RlKSA9PiB7XG5cdGlmICgrK25vZGVbUkVTT0xWRURfQ09VTlRdID09PSBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHQvLyBUaGUgbnVtYmVyIGEgY2hpbGQgKG9yIGFueSBvZiBpdHMgZGVzY2VuZGFudHMpIGhhcyBiZWVuIHN1c3BlbmRlZFxuXHRcdC8vIG1hdGNoZXMgdGhlIG51bWJlciBvZiB0aW1lcyBpdCdzIGJlZW4gcmVzb2x2ZWQuIFRoZXJlZm9yZSB3ZVxuXHRcdC8vIG1hcmsgdGhlIGNoaWxkIGFzIGNvbXBsZXRlbHkgcmVzb2x2ZWQgYnkgZGVsZXRpbmcgaXQgZnJvbSAuX21hcC5cblx0XHQvLyBUaGlzIGlzIHVzZWQgdG8gZmlndXJlIG91dCB3aGVuICphbGwqIGNoaWxkcmVuIGhhdmUgYmVlbiBjb21wbGV0ZWx5XG5cdFx0Ly8gcmVzb2x2ZWQgd2hlbiByZXZlYWxPcmRlciBpcyAndG9nZXRoZXInLlxuXHRcdGxpc3QuX21hcC5kZWxldGUoY2hpbGQpO1xuXHR9XG5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgZmFsc3kgdGhlbiB3ZSBjYW4gZG8gYW4gZWFybHkgZXhpdCwgYXMgdGhlXG5cdC8vIGNhbGxiYWNrcyB3b24ndCBnZXQgcXVldWVkIGluIHRoZSBub2RlIGFueXdheS5cblx0Ly8gSWYgcmV2ZWFsT3JkZXIgaXMgJ3RvZ2V0aGVyJyB0aGVuIGFsc28gZG8gYW4gZWFybHkgZXhpdFxuXHQvLyBpZiBhbGwgc3VzcGVuZGVkIGRlc2NlbmRhbnRzIGhhdmUgbm90IHlldCBiZWVuIHJlc29sdmVkLlxuXHRpZiAoXG5cdFx0IWxpc3QucHJvcHMucmV2ZWFsT3JkZXIgfHxcblx0XHQobGlzdC5wcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ3QnICYmIGxpc3QuX21hcC5zaXplKVxuXHQpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBXYWxrIHRoZSBjdXJyZW50bHkgc3VzcGVuZGVkIGNoaWxkcmVuIGluIG9yZGVyLCBjYWxsaW5nIHRoZWlyXG5cdC8vIHN0b3JlZCBjYWxsYmFja3Mgb24gdGhlIHdheS4gU3RvcCBpZiB3ZSBlbmNvdW50ZXIgYSBjaGlsZCB0aGF0XG5cdC8vIGhhcyBub3QgYmVlbiBjb21wbGV0ZWx5IHJlc29sdmVkIHlldC5cblx0bm9kZSA9IGxpc3QuX25leHQ7XG5cdHdoaWxlIChub2RlKSB7XG5cdFx0d2hpbGUgKG5vZGUubGVuZ3RoID4gMykge1xuXHRcdFx0bm9kZS5wb3AoKSgpO1xuXHRcdH1cblx0XHRpZiAobm9kZVtSRVNPTFZFRF9DT1VOVF0gPCBub2RlW1NVU1BFTkRFRF9DT1VOVF0pIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRsaXN0Ll9uZXh0ID0gbm9kZSA9IG5vZGVbTkVYVF9OT0RFXTtcblx0fVxufTtcblxuLy8gVGhpbmdzIHdlIGRvIGhlcmUgdG8gc2F2ZSBzb21lIGJ5dGVzIGJ1dCBhcmUgbm90IHByb3BlciBKUyBpbmhlcml0YW5jZTpcbi8vIC0gY2FsbCBgbmV3IENvbXBvbmVudCgpYCBhcyB0aGUgcHJvdG90eXBlXG4vLyAtIGRvIG5vdCBzZXQgYFN1c3BlbnNlLnByb3RvdHlwZS5jb25zdHJ1Y3RvcmAgdG8gYFN1c3BlbnNlYFxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnQoKTtcblxuU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5fc3VzcGVuZGVkID0gZnVuY3Rpb24oY2hpbGQpIHtcblx0Y29uc3QgbGlzdCA9IHRoaXM7XG5cdGNvbnN0IGRlbGVnYXRlZCA9IHN1c3BlbmRlZChsaXN0Ll92bm9kZSk7XG5cblx0bGV0IG5vZGUgPSBsaXN0Ll9tYXAuZ2V0KGNoaWxkKTtcblx0bm9kZVtTVVNQRU5ERURfQ09VTlRdKys7XG5cblx0cmV0dXJuIHVuc3VzcGVuZCA9PiB7XG5cdFx0Y29uc3Qgd3JhcHBlZFVuc3VzcGVuZCA9ICgpID0+IHtcblx0XHRcdGlmICghbGlzdC5wcm9wcy5yZXZlYWxPcmRlcikge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgdGhlIHVuZGVmaW5lZCAoZmFsc3kpIHJldmVhbE9yZGVyLCBhcyB0aGVyZVxuXHRcdFx0XHQvLyBpcyBubyBuZWVkIHRvIGNvb3JkaW5hdGUgYSBzcGVjaWZpYyBvcmRlciBvciB1bnN1c3BlbmRzLlxuXHRcdFx0XHR1bnN1c3BlbmQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucHVzaCh1bnN1c3BlbmQpO1xuXHRcdFx0XHRyZXNvbHZlKGxpc3QsIGNoaWxkLCBub2RlKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGlmIChkZWxlZ2F0ZWQpIHtcblx0XHRcdGRlbGVnYXRlZCh3cmFwcGVkVW5zdXNwZW5kKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0d3JhcHBlZFVuc3VzcGVuZCgpO1xuXHRcdH1cblx0fTtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24ocHJvcHMpIHtcblx0dGhpcy5fbmV4dCA9IG51bGw7XG5cdHRoaXMuX21hcCA9IG5ldyBNYXAoKTtcblxuXHRjb25zdCBjaGlsZHJlbiA9IHRvQ2hpbGRBcnJheShwcm9wcy5jaGlsZHJlbik7XG5cdGlmIChwcm9wcy5yZXZlYWxPcmRlciAmJiBwcm9wcy5yZXZlYWxPcmRlclswXSA9PT0gJ2InKSB7XG5cdFx0Ly8gSWYgb3JkZXIgPT09ICdiYWNrd2FyZHMnIChvciwgd2VsbCwgYW55dGhpbmcgc3RhcnRpbmcgd2l0aCBhICdiJylcblx0XHQvLyB0aGVuIGZsaXAgdGhlIGNoaWxkIGxpc3QgYXJvdW5kIHNvIHRoYXQgdGhlIGxhc3QgY2hpbGQgd2lsbCBiZVxuXHRcdC8vIHRoZSBmaXJzdCBpbiB0aGUgbGlua2VkIGxpc3QuXG5cdFx0Y2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHR9XG5cdC8vIEJ1aWxkIHRoZSBsaW5rZWQgbGlzdC4gSXRlcmF0ZSB0aHJvdWdoIHRoZSBjaGlsZHJlbiBpbiByZXZlcnNlIG9yZGVyXG5cdC8vIHNvIHRoYXQgYF9uZXh0YCBwb2ludHMgdG8gdGhlIGZpcnN0IGxpbmtlZCBsaXN0IG5vZGUgdG8gYmUgcmVzb2x2ZWQuXG5cdGZvciAobGV0IGkgPSBjaGlsZHJlbi5sZW5ndGg7IGktLTsgKSB7XG5cdFx0Ly8gQ3JlYXRlIGEgbmV3IGxpbmtlZCBsaXN0IG5vZGUgYXMgYW4gYXJyYXkgb2YgZm9ybTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGVdXG5cdFx0Ly8gd2hlcmUgc3VzcGVuZGVkX2NvdW50IGFuZCByZXNvbHZlZF9jb3VudCBhcmUgbnVtZXJpYyBjb3VudGVycyBmb3Jcblx0XHQvLyBrZWVwaW5nIHRyYWNrIGhvdyBtYW55IHRpbWVzIGEgbm9kZSBoYXMgYmVlbiBzdXNwZW5kZWQgYW5kIHJlc29sdmVkLlxuXHRcdC8vXG5cdFx0Ly8gTm90ZSB0aGF0IHN1c3BlbmRlZF9jb3VudCBzdGFydHMgZnJvbSAxIGluc3RlYWQgb2YgMCwgc28gd2UgY2FuIGJsb2NrXG5cdFx0Ly8gcHJvY2Vzc2luZyBjYWxsYmFja3MgdW50aWwgY29tcG9uZW50RGlkTW91bnQgaGFzIGJlZW4gY2FsbGVkLiBJbiBhIHNlbnNlXG5cdFx0Ly8gbm9kZSBpcyBzdXNwZW5kZWQgYXQgbGVhc3QgdW50aWwgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQhXG5cdFx0Ly9cblx0XHQvLyBQZW5kaW5nIGNhbGxiYWNrcyBhcmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgbm9kZTpcblx0XHQvLyBcdFtzdXNwZW5kZWRfY291bnQsIHJlc29sdmVkX2NvdW50LCBuZXh0X25vZGUsIGNhbGxiYWNrXzAsIGNhbGxiYWNrXzEsIC4uLl1cblx0XHR0aGlzLl9tYXAuc2V0KGNoaWxkcmVuW2ldLCAodGhpcy5fbmV4dCA9IFsxLCAwLCB0aGlzLl9uZXh0XSkpO1xuXHR9XG5cdHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbn07XG5cblN1c3BlbnNlTGlzdC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gU3VzcGVuc2VMaXN0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uKCkge1xuXHQvLyBJdGVyYXRlIHRocm91Z2ggYWxsIGNoaWxkcmVuIGFmdGVyIG1vdW50aW5nIGZvciB0d28gcmVhc29uczpcblx0Ly8gMS4gQXMgZWFjaCBub2RlW1NVU1BFTkRFRF9DT1VOVF0gc3RhcnRzIGZyb20gMSwgdGhpcyBpdGVyYXRpb24gaW5jcmVhc2VzXG5cdC8vICAgIGVhY2ggbm9kZVtSRUxFQVNFRF9DT1VOVF0gYnkgMSwgdGhlcmVmb3JlIGJhbGFuY2luZyB0aGUgY291bnRlcnMuXG5cdC8vICAgIFRoZSBub2RlcyBjYW4gbm93IGJlIGNvbXBsZXRlbHkgY29uc3VtZWQgZnJvbSB0aGUgbGlua2VkIGxpc3QuXG5cdC8vIDIuIEhhbmRsZSBub2RlcyB0aGF0IG1pZ2h0IGhhdmUgZ290dGVuIHJlc29sdmVkIGJldHdlZW4gcmVuZGVyIGFuZFxuXHQvLyAgICBjb21wb25lbnREaWRNb3VudC5cblx0dGhpcy5fbWFwLmZvckVhY2goKG5vZGUsIGNoaWxkKSA9PiB7XG5cdFx0cmVzb2x2ZSh0aGlzLCBjaGlsZCwgbm9kZSk7XG5cdH0pO1xufTtcbiIsImltcG9ydCB7IGNyZWF0ZUVsZW1lbnQsIHJlbmRlciB9IGZyb20gJ3ByZWFjdCc7XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uLy4uL3NyYy9pbmRleCcpLlJlbmRlcmFibGVQcm9wczx7IGNvbnRleHQ6IGFueSB9Pn0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gQ29udGV4dFByb3ZpZGVyKHByb3BzKSB7XG5cdHRoaXMuZ2V0Q2hpbGRDb250ZXh0ID0gKCkgPT4gcHJvcHMuY29udGV4dDtcblx0cmV0dXJuIHByb3BzLmNoaWxkcmVuO1xufVxuXG4vKipcbiAqIFBvcnRhbCBjb21wb25lbnRcbiAqIEB0aGlzIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5Db21wb25lbnR9XG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGwgfCB1bmRlZmluZWR9IHByb3BzXG4gKlxuICogVE9ETzogdXNlIGNyZWF0ZVJvb3QoKSBpbnN0ZWFkIG9mIGZha2Ugcm9vdFxuICovXG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcblx0Y29uc3QgX3RoaXMgPSB0aGlzO1xuXHRsZXQgY29udGFpbmVyID0gcHJvcHMuX2NvbnRhaW5lcjtcblxuXHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJlbmRlcihudWxsLCBfdGhpcy5fdGVtcCk7XG5cdFx0X3RoaXMuX3RlbXAgPSBudWxsO1xuXHRcdF90aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHR9O1xuXG5cdC8vIFdoZW4gd2UgY2hhbmdlIGNvbnRhaW5lciB3ZSBzaG91bGQgY2xlYXIgb3VyIG9sZCBjb250YWluZXIgYW5kXG5cdC8vIGluZGljYXRlIGEgbmV3IG1vdW50LlxuXHRpZiAoX3RoaXMuX2NvbnRhaW5lciAmJiBfdGhpcy5fY29udGFpbmVyICE9PSBjb250YWluZXIpIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG5cblx0Ly8gV2hlbiBwcm9wcy52bm9kZSBpcyB1bmRlZmluZWQvZmFsc2UvbnVsbCB3ZSBhcmUgZGVhbGluZyB3aXRoIHNvbWUga2luZCBvZlxuXHQvLyBjb25kaXRpb25hbCB2bm9kZS4gVGhpcyBzaG91bGQgbm90IHRyaWdnZXIgYSByZW5kZXIuXG5cdGlmIChwcm9wcy5fdm5vZGUpIHtcblx0XHRpZiAoIV90aGlzLl90ZW1wKSB7XG5cdFx0XHRfdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuXG5cdFx0XHQvLyBDcmVhdGUgYSBmYWtlIERPTSBwYXJlbnQgbm9kZSB0aGF0IG1hbmFnZXMgYSBzdWJzZXQgb2YgYGNvbnRhaW5lcmAncyBjaGlsZHJlbjpcblx0XHRcdF90aGlzLl90ZW1wID0ge1xuXHRcdFx0XHRub2RlVHlwZTogMSxcblx0XHRcdFx0cGFyZW50Tm9kZTogY29udGFpbmVyLFxuXHRcdFx0XHRjaGlsZE5vZGVzOiBbXSxcblx0XHRcdFx0YXBwZW5kQ2hpbGQoY2hpbGQpIHtcblx0XHRcdFx0XHR0aGlzLmNoaWxkTm9kZXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0X3RoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlKSB7XG5cdFx0XHRcdFx0dGhpcy5jaGlsZE5vZGVzLnB1c2goY2hpbGQpO1xuXHRcdFx0XHRcdF90aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZW1vdmVDaGlsZChjaGlsZCkge1xuXHRcdFx0XHRcdHRoaXMuY2hpbGROb2Rlcy5zcGxpY2UodGhpcy5jaGlsZE5vZGVzLmluZGV4T2YoY2hpbGQpID4+PiAxLCAxKTtcblx0XHRcdFx0XHRfdGhpcy5fY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBSZW5kZXIgb3VyIHdyYXBwaW5nIGVsZW1lbnQgaW50byB0ZW1wLlxuXHRcdHJlbmRlcihcblx0XHRcdGNyZWF0ZUVsZW1lbnQoQ29udGV4dFByb3ZpZGVyLCB7IGNvbnRleHQ6IF90aGlzLmNvbnRleHQgfSwgcHJvcHMuX3Zub2RlKSxcblx0XHRcdF90aGlzLl90ZW1wXG5cdFx0KTtcblx0fVxuXHQvLyBXaGVuIHdlIGNvbWUgZnJvbSBhIGNvbmRpdGlvbmFsIHJlbmRlciwgb24gYSBtb3VudGVkXG5cdC8vIHBvcnRhbCB3ZSBzaG91bGQgY2xlYXIgdGhlIERPTS5cblx0ZWxzZSBpZiAoX3RoaXMuX3RlbXApIHtcblx0XHRfdGhpcy5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuXHR9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYFBvcnRhbGAgdG8gY29udGludWUgcmVuZGVyaW5nIHRoZSB2bm9kZSB0cmVlIGF0IGEgZGlmZmVyZW50IERPTSBub2RlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlZOb2RlfSB2bm9kZSBUaGUgdm5vZGUgdG8gcmVuZGVyXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi9pbnRlcm5hbCcpLlByZWFjdEVsZW1lbnR9IGNvbnRhaW5lciBUaGUgRE9NIG5vZGUgdG8gY29udGludWUgcmVuZGVyaW5nIGluIHRvLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9ydGFsKHZub2RlLCBjb250YWluZXIpIHtcblx0Y29uc3QgZWwgPSBjcmVhdGVFbGVtZW50KFBvcnRhbCwgeyBfdm5vZGU6IHZub2RlLCBfY29udGFpbmVyOiBjb250YWluZXIgfSk7XG5cdGVsLmNvbnRhaW5lckluZm8gPSBjb250YWluZXI7XG5cdHJldHVybiBlbDtcbn1cbiIsImltcG9ydCB7XG5cdHJlbmRlciBhcyBwcmVhY3RSZW5kZXIsXG5cdGh5ZHJhdGUgYXMgcHJlYWN0SHlkcmF0ZSxcblx0b3B0aW9ucyxcblx0dG9DaGlsZEFycmF5LFxuXHRDb21wb25lbnRcbn0gZnJvbSAncHJlYWN0JztcblxuZXhwb3J0IGNvbnN0IFJFQUNUX0VMRU1FTlRfVFlQRSA9XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIFN5bWJvbC5mb3IgJiYgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuXHQweGVhYzc7XG5cbmNvbnN0IENBTUVMX1BST1BTID0gL14oPzphY2NlbnR8YWxpZ25tZW50fGFyYWJpY3xiYXNlbGluZXxjYXB8Y2xpcCg/IVBhdGhVKXxjb2xvcnxkb21pbmFudHxmaWxsfGZsb29kfGZvbnR8Z2x5cGgoPyFSKXxob3JpenxpbWFnZXxsZXR0ZXJ8bGlnaHRpbmd8bWFya2VyKD8hSHxXfFUpfG92ZXJsaW5lfHBhaW50fHBvaW50ZXJ8c2hhcGV8c3RvcHxzdHJpa2V0aHJvdWdofHN0cm9rZXx0ZXh0KD8hTCl8dHJhbnNmb3JtfHVuZGVybGluZXx1bmljb2RlfHVuaXRzfHZ8dmVjdG9yfHZlcnR8d29yZHx3cml0aW5nfHgoPyFDKSlbQS1aXS87XG5cbmNvbnN0IElTX0RPTSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIElucHV0IHR5cGVzIGZvciB3aGljaCBvbmNoYW5nZSBzaG91bGQgbm90IGJlIGNvbnZlcnRlZCB0byBvbmlucHV0LlxuLy8gdHlwZT1cImZpbGV8Y2hlY2tib3h8cmFkaW9cIiwgcGx1cyBcInJhbmdlXCIgaW4gSUUxMS5cbi8vIChJRTExIGRvZXNuJ3Qgc3VwcG9ydCBTeW1ib2wsIHdoaWNoIHdlIHVzZSBoZXJlIHRvIHR1cm4gYHJhZGAgaW50byBgcmFgIHdoaWNoIG1hdGNoZXMgXCJyYW5nZVwiKVxuY29uc3Qgb25DaGFuZ2VJbnB1dFR5cGUgPSB0eXBlID0+XG5cdCh0eXBlb2YgU3ltYm9sICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBTeW1ib2woKSA9PSAnc3ltYm9sJ1xuXHRcdD8gL2ZpbHxjaGV8cmFkL2lcblx0XHQ6IC9maWx8Y2hlfHJhL2lcblx0KS50ZXN0KHR5cGUpO1xuXG4vLyBTb21lIGxpYnJhcmllcyBsaWtlIGByZWFjdC12aXJ0dWFsaXplZGAgZXhwbGljaXRseSBjaGVjayBmb3IgdGhpcy5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vLyBgVU5TQUZFXypgIGxpZmVjeWNsZSBob29rc1xuLy8gUHJlYWN0IG9ubHkgZXZlciBpbnZva2VzIHRoZSB1bnByZWZpeGVkIG1ldGhvZHMuXG4vLyBIZXJlIHdlIHByb3ZpZGUgYSBiYXNlIFwiZmFsbGJhY2tcIiBpbXBsZW1lbnRhdGlvbiB0aGF0IGNhbGxzIGFueSBkZWZpbmVkIFVOU0FGRV8gcHJlZml4ZWQgbWV0aG9kLlxuLy8gLSBJZiBhIGNvbXBvbmVudCBkZWZpbmVzIGl0cyBvd24gYGNvbXBvbmVudERpZE1vdW50KClgIChpbmNsdWRpbmcgdmlhIGRlZmluZVByb3BlcnR5KSwgdXNlIHRoYXQuXG4vLyAtIElmIGEgY29tcG9uZW50IGRlZmluZXMgYFVOU0FGRV9jb21wb25lbnREaWRNb3VudCgpYCwgYGNvbXBvbmVudERpZE1vdW50YCBpcyB0aGUgYWxpYXMgZ2V0dGVyL3NldHRlci5cbi8vIC0gSWYgYW55dGhpbmcgYXNzaWducyB0byBhbiBgVU5TQUZFXypgIHByb3BlcnR5LCB0aGUgYXNzaWdubWVudCBpcyBmb3J3YXJkZWQgdG8gdGhlIHVucHJlZml4ZWQgcHJvcGVydHkuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMTk0MVxuW1xuXHQnY29tcG9uZW50V2lsbE1vdW50Jyxcblx0J2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxuXHQnY29tcG9uZW50V2lsbFVwZGF0ZSdcbl0uZm9yRWFjaChrZXkgPT4ge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwga2V5LCB7XG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiB0aGlzWydVTlNBRkVfJyArIGtleV07XG5cdFx0fSxcblx0XHRzZXQodikge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogdlxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG4vKipcbiAqIFByb3h5IHJlbmRlcigpIHNpbmNlIFJlYWN0IHJldHVybnMgYSBDb21wb25lbnQgcmVmZXJlbmNlLlxuICogQHBhcmFtIHtpbXBvcnQoJy4vaW50ZXJuYWwnKS5WTm9kZX0gdm5vZGUgVk5vZGUgdHJlZSB0byByZW5kZXJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL2ludGVybmFsJykuUHJlYWN0RWxlbWVudH0gcGFyZW50IERPTSBub2RlIHRvIHJlbmRlciB2bm9kZSB0cmVlIGludG9cbiAqIEBwYXJhbSB7KCkgPT4gdm9pZH0gW2NhbGxiYWNrXSBPcHRpb25hbCBjYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIGFmdGVyIHJlbmRlcmluZ1xuICogQHJldHVybnMge2ltcG9ydCgnLi9pbnRlcm5hbCcpLkNvbXBvbmVudCB8IG51bGx9IFRoZSByb290IGNvbXBvbmVudCByZWZlcmVuY2Ugb3IgbnVsbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdC8vIFJlYWN0IGRlc3Ryb3lzIGFueSBleGlzdGluZyBET00gbm9kZXMsIHNlZSAjMTcyN1xuXHQvLyAuLi5idXQgb25seSBvbiB0aGUgZmlyc3QgcmVuZGVyLCBzZWUgIzE4Mjhcblx0aWYgKHBhcmVudC5fY2hpbGRyZW4gPT0gbnVsbCkge1xuXHRcdHBhcmVudC50ZXh0Q29udGVudCA9ICcnO1xuXHR9XG5cblx0cHJlYWN0UmVuZGVyKHZub2RlLCBwYXJlbnQpO1xuXHRpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG5cblx0cmV0dXJuIHZub2RlID8gdm5vZGUuX2NvbXBvbmVudCA6IG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoeWRyYXRlKHZub2RlLCBwYXJlbnQsIGNhbGxiYWNrKSB7XG5cdHByZWFjdEh5ZHJhdGUodm5vZGUsIHBhcmVudCk7XG5cdGlmICh0eXBlb2YgY2FsbGJhY2sgPT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soKTtcblxuXHRyZXR1cm4gdm5vZGUgPyB2bm9kZS5fY29tcG9uZW50IDogbnVsbDtcbn1cblxubGV0IG9sZEV2ZW50SG9vayA9IG9wdGlvbnMuZXZlbnQ7XG5vcHRpb25zLmV2ZW50ID0gZSA9PiB7XG5cdGlmIChvbGRFdmVudEhvb2spIGUgPSBvbGRFdmVudEhvb2soZSk7XG5cdGUucGVyc2lzdCA9IGVtcHR5O1xuXHRlLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gaXNQcm9wYWdhdGlvblN0b3BwZWQ7XG5cdGUuaXNEZWZhdWx0UHJldmVudGVkID0gaXNEZWZhdWx0UHJldmVudGVkO1xuXHRyZXR1cm4gKGUubmF0aXZlRXZlbnQgPSBlKTtcbn07XG5cbmZ1bmN0aW9uIGVtcHR5KCkge31cblxuZnVuY3Rpb24gaXNQcm9wYWdhdGlvblN0b3BwZWQoKSB7XG5cdHJldHVybiB0aGlzLmNhbmNlbEJ1YmJsZTtcbn1cblxuZnVuY3Rpb24gaXNEZWZhdWx0UHJldmVudGVkKCkge1xuXHRyZXR1cm4gdGhpcy5kZWZhdWx0UHJldmVudGVkO1xufVxuXG5sZXQgY2xhc3NOYW1lRGVzY3JpcHRvciA9IHtcblx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRnZXQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY2xhc3M7XG5cdH1cbn07XG5cbmxldCBvbGRWTm9kZUhvb2sgPSBvcHRpb25zLnZub2RlO1xub3B0aW9ucy52bm9kZSA9IHZub2RlID0+IHtcblx0bGV0IHR5cGUgPSB2bm9kZS50eXBlO1xuXHRsZXQgcHJvcHMgPSB2bm9kZS5wcm9wcztcblx0bGV0IG5vcm1hbGl6ZWRQcm9wcyA9IHByb3BzO1xuXG5cdC8vIG9ubHkgbm9ybWFsaXplIHByb3BzIG9uIEVsZW1lbnQgbm9kZXNcblx0aWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuXHRcdGNvbnN0IG5vbkN1c3RvbUVsZW1lbnQgPSB0eXBlLmluZGV4T2YoJy0nKSA9PT0gLTE7XG5cdFx0bm9ybWFsaXplZFByb3BzID0ge307XG5cblx0XHRmb3IgKGxldCBpIGluIHByb3BzKSB7XG5cdFx0XHRsZXQgdmFsdWUgPSBwcm9wc1tpXTtcblxuXHRcdFx0aWYgKElTX0RPTSAmJiBpID09PSAnY2hpbGRyZW4nICYmIHR5cGUgPT09ICdub3NjcmlwdCcpIHtcblx0XHRcdFx0Ly8gRW11bGF0ZSBSZWFjdCdzIGJlaGF2aW9yIG9mIG5vdCByZW5kZXJpbmcgdGhlIGNvbnRlbnRzIG9mIG5vc2NyaXB0IHRhZ3Mgb24gdGhlIGNsaWVudC5cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICd2YWx1ZScgJiYgJ2RlZmF1bHRWYWx1ZScgaW4gcHJvcHMgJiYgdmFsdWUgPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBTa2lwIGFwcGx5aW5nIHZhbHVlIGlmIGl0IGlzIG51bGwvdW5kZWZpbmVkIGFuZCB3ZSBhbHJlYWR5IHNldFxuXHRcdFx0XHQvLyBhIGRlZmF1bHQgdmFsdWVcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRpID09PSAnZGVmYXVsdFZhbHVlJyAmJlxuXHRcdFx0XHQndmFsdWUnIGluIHByb3BzICYmXG5cdFx0XHRcdHByb3BzLnZhbHVlID09IG51bGxcblx0XHRcdCkge1xuXHRcdFx0XHQvLyBgZGVmYXVsdFZhbHVlYCBpcyB0cmVhdGVkIGFzIGEgZmFsbGJhY2sgYHZhbHVlYCB3aGVuIGEgdmFsdWUgcHJvcCBpcyBwcmVzZW50IGJ1dCBudWxsL3VuZGVmaW5lZC5cblx0XHRcdFx0Ly8gYGRlZmF1bHRWYWx1ZWAgZm9yIEVsZW1lbnRzIHdpdGggbm8gdmFsdWUgcHJvcCBpcyB0aGUgc2FtZSBhcyB0aGUgRE9NIGRlZmF1bHRWYWx1ZSBwcm9wZXJ0eS5cblx0XHRcdFx0aSA9ICd2YWx1ZSc7XG5cdFx0XHR9IGVsc2UgaWYgKGkgPT09ICdkb3dubG9hZCcgJiYgdmFsdWUgPT09IHRydWUpIHtcblx0XHRcdFx0Ly8gQ2FsbGluZyBgc2V0QXR0cmlidXRlYCB3aXRoIGEgdHJ1dGh5IHZhbHVlIHdpbGwgbGVhZCB0byBpdCBiZWluZ1xuXHRcdFx0XHQvLyBwYXNzZWQgYXMgYSBzdHJpbmdpZmllZCB2YWx1ZSwgZS5nLiBgZG93bmxvYWQ9XCJ0cnVlXCJgLiBSZWFjdFxuXHRcdFx0XHQvLyBjb252ZXJ0cyBpdCB0byBhbiBlbXB0eSBzdHJpbmcgaW5zdGVhZCwgb3RoZXJ3aXNlIHRoZSBhdHRyaWJ1dGVcblx0XHRcdFx0Ly8gdmFsdWUgd2lsbCBiZSB1c2VkIGFzIHRoZSBmaWxlIG5hbWUgYW5kIHRoZSBmaWxlIHdpbGwgYmUgY2FsbGVkXG5cdFx0XHRcdC8vIFwidHJ1ZVwiIHVwb24gZG93bmxvYWRpbmcgaXQuXG5cdFx0XHRcdHZhbHVlID0gJyc7XG5cdFx0XHR9IGVsc2UgaWYgKC9vbmRvdWJsZWNsaWNrL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZGJsY2xpY2snO1xuXHRcdFx0fSBlbHNlIGlmIChcblx0XHRcdFx0L15vbmNoYW5nZSh0ZXh0YXJlYXxpbnB1dCkvaS50ZXN0KGkgKyB0eXBlKSAmJlxuXHRcdFx0XHQhb25DaGFuZ2VJbnB1dFR5cGUocHJvcHMudHlwZSlcblx0XHRcdCkge1xuXHRcdFx0XHRpID0gJ29uaW5wdXQnO1xuXHRcdFx0fSBlbHNlIGlmICgvXm9uZm9jdXMkL2kudGVzdChpKSkge1xuXHRcdFx0XHRpID0gJ29uZm9jdXNpbic7XG5cdFx0XHR9IGVsc2UgaWYgKC9eb25ibHVyJC9pLnRlc3QoaSkpIHtcblx0XHRcdFx0aSA9ICdvbmZvY3Vzb3V0Jztcblx0XHRcdH0gZWxzZSBpZiAoL15vbihBbml8VHJhfFRvdXxCZWZvcmVJbnB8Q29tcG8pLy50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9IGVsc2UgaWYgKG5vbkN1c3RvbUVsZW1lbnQgJiYgQ0FNRUxfUFJPUFMudGVzdChpKSkge1xuXHRcdFx0XHRpID0gaS5yZXBsYWNlKC9bQS1aMC05XS9nLCAnLSQmJykudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gZWxzZSBpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dmFsdWUgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBzdXBwb3J0IGZvciBvbklucHV0IGFuZCBvbkNoYW5nZSwgc2VlICMzNTYxXG5cdFx0XHQvLyBpZiB3ZSBoYXZlIGFuIG9uaW5wdXQgcHJvcCBhbHJlYWR5IGNoYW5nZSBpdCB0byBvbmlucHV0Q2FwdHVyZVxuXHRcdFx0aWYgKC9eb25pbnB1dCQvaS50ZXN0KGkpKSB7XG5cdFx0XHRcdGkgPSBpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdGlmIChub3JtYWxpemVkUHJvcHNbaV0pIHtcblx0XHRcdFx0XHRpID0gJ29uaW5wdXRDYXB0dXJlJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRub3JtYWxpemVkUHJvcHNbaV0gPSB2YWx1ZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgc3VwcG9ydCBmb3IgYXJyYXkgc2VsZWN0IHZhbHVlczogPHNlbGVjdCBtdWx0aXBsZSB2YWx1ZT17W119IC8+XG5cdFx0aWYgKFxuXHRcdFx0dHlwZSA9PSAnc2VsZWN0JyAmJlxuXHRcdFx0bm9ybWFsaXplZFByb3BzLm11bHRpcGxlICYmXG5cdFx0XHRBcnJheS5pc0FycmF5KG5vcm1hbGl6ZWRQcm9wcy52YWx1ZSlcblx0XHQpIHtcblx0XHRcdC8vIGZvckVhY2goKSBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHdoaWNoIHdlIGFidXNlIGhlcmUgdG8gdW5zZXQgdGhlIHZhbHVlIHByb3AuXG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLnZhbHVlLmluZGV4T2YoY2hpbGQucHJvcHMudmFsdWUpICE9IC0xO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkaW5nIHN1cHBvcnQgZm9yIGRlZmF1bHRWYWx1ZSBpbiBzZWxlY3QgdGFnXG5cdFx0aWYgKHR5cGUgPT0gJ3NlbGVjdCcgJiYgbm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRub3JtYWxpemVkUHJvcHMudmFsdWUgPSB0b0NoaWxkQXJyYXkocHJvcHMuY2hpbGRyZW4pLmZvckVhY2goY2hpbGQgPT4ge1xuXHRcdFx0XHRpZiAobm9ybWFsaXplZFByb3BzLm11bHRpcGxlKSB7XG5cdFx0XHRcdFx0Y2hpbGQucHJvcHMuc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdFx0bm9ybWFsaXplZFByb3BzLmRlZmF1bHRWYWx1ZS5pbmRleE9mKGNoaWxkLnByb3BzLnZhbHVlKSAhPSAtMTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjaGlsZC5wcm9wcy5zZWxlY3RlZCA9XG5cdFx0XHRcdFx0XHRub3JtYWxpemVkUHJvcHMuZGVmYXVsdFZhbHVlID09IGNoaWxkLnByb3BzLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR2bm9kZS5wcm9wcyA9IG5vcm1hbGl6ZWRQcm9wcztcblxuXHRcdGlmIChwcm9wcy5jbGFzcyAhPSBwcm9wcy5jbGFzc05hbWUpIHtcblx0XHRcdGNsYXNzTmFtZURlc2NyaXB0b3IuZW51bWVyYWJsZSA9ICdjbGFzc05hbWUnIGluIHByb3BzO1xuXHRcdFx0aWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSBub3JtYWxpemVkUHJvcHMuY2xhc3MgPSBwcm9wcy5jbGFzc05hbWU7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobm9ybWFsaXplZFByb3BzLCAnY2xhc3NOYW1lJywgY2xhc3NOYW1lRGVzY3JpcHRvcik7XG5cdFx0fVxuXHR9XG5cblx0dm5vZGUuJCR0eXBlb2YgPSBSRUFDVF9FTEVNRU5UX1RZUEU7XG5cblx0aWYgKG9sZFZOb2RlSG9vaykgb2xkVk5vZGVIb29rKHZub2RlKTtcbn07XG5cbi8vIE9ubHkgbmVlZGVkIGZvciByZWFjdC1yZWxheVxubGV0IGN1cnJlbnRDb21wb25lbnQ7XG5jb25zdCBvbGRCZWZvcmVSZW5kZXIgPSBvcHRpb25zLl9yZW5kZXI7XG5vcHRpb25zLl9yZW5kZXIgPSBmdW5jdGlvbih2bm9kZSkge1xuXHRpZiAob2xkQmVmb3JlUmVuZGVyKSB7XG5cdFx0b2xkQmVmb3JlUmVuZGVyKHZub2RlKTtcblx0fVxuXHRjdXJyZW50Q29tcG9uZW50ID0gdm5vZGUuX2NvbXBvbmVudDtcbn07XG5cbi8vIFRoaXMgaXMgYSB2ZXJ5IHZlcnkgcHJpdmF0ZSBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgUmVhY3QgaXRcbi8vIGlzIHVzZWQgdG8gc29ydC1vZiBkbyBydW50aW1lIGRlcGVuZGVuY3kgaW5qZWN0aW9uLiBTbyBmYXJcbi8vIG9ubHkgYHJlYWN0LXJlbGF5YCBtYWtlcyB1c2Ugb2YgaXQuIEl0IHVzZXMgaXQgdG8gcmVhZCB0aGVcbi8vIGNvbnRleHQgdmFsdWUuXG5leHBvcnQgY29uc3QgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSB7XG5cdFJlYWN0Q3VycmVudERpc3BhdGNoZXI6IHtcblx0XHRjdXJyZW50OiB7XG5cdFx0XHRyZWFkQ29udGV4dChjb250ZXh0KSB7XG5cdFx0XHRcdHJldHVybiBjdXJyZW50Q29tcG9uZW50Ll9nbG9iYWxDb250ZXh0W2NvbnRleHQuX2lkXS5wcm9wcy52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBvcHRpb25zIH0gZnJvbSBcInByZWFjdFwiXG5cbmV4cG9ydCB0eXBlIFBhc3NpdmVTdGF0ZVVwZGF0ZXI8Uz4gPSAodmFsdWU6IFMgfCAoKHByZXZTdGF0ZTogUyB8IHVuZGVmaW5lZCkgPT4gUykpID0+IHZvaWQ7XG5leHBvcnQgdHlwZSBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiA9ICgodmFsdWU6IFQsIHByZXZWYWx1ZTogVCB8IHVuZGVmaW5lZCkgPT4gKHZvaWQgfCAoKCkgPT4gdm9pZCkpKTtcblxuLyoqXG4gKiBEZWJ1ZyBob29rLlxuICogXG4gKiBHaXZlbiBhIHZhbHVlIG9yIHNldCBvZiB2YWx1ZXMsIGVtaXRzIGEgY29uc29sZSBlcnJvciBpZiBhbnkgb2YgdGhlbSBjaGFuZ2UgZnJvbSBvbmUgcmVuZGVyIHRvIHRoZSBuZXh0LlxuICogXG4gKiBFdmVudHVhbGx5LCB3aGVuIHVzZUV2ZW50IGxhbmRzLCB3ZSBob3BlZnVsbHkgd29uJ3QgbmVlZCB0aGlzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRW5zdXJlU3RhYmlsaXR5PFQgZXh0ZW5kcyBhbnlbXT4ocGFyZW50SG9va05hbWU6IHN0cmluZywgLi4udmFsdWVzOiBUKSB7XG4gICAgdXNlSGVscGVyKHZhbHVlcy5sZW5ndGgsIDApO1xuICAgIHZhbHVlcy5mb3JFYWNoKHVzZUhlbHBlcik7XG4gICAgcmV0dXJuO1xuXG5cbiAgICBmdW5jdGlvbiB1c2VIZWxwZXI8VT4odmFsdWU6IFUsIGluZGV4OiBudW1iZXIpIHtcblxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZWQgZnVuY3Rpb25zIGFyZSBwZXJmZWN0bHkgc3RhYmxlIGFjcm9zcyByZW5kZXJzXG4gICAgICAgIGNvbnN0IGhlbHBlclRvRW5zdXJlU3RhYmlsaXR5ID0gdXNlUmVmKHZhbHVlKTtcbiAgICAgICAgY29uc3Qgc2hvd25FcnJvciA9IHVzZVJlZihmYWxzZSk7XG4gICAgICAgIGlmIChoZWxwZXJUb0Vuc3VyZVN0YWJpbGl0eS5jdXJyZW50ICE9IHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXNob3duRXJyb3IuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWRlYnVnZ2VyICovXG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlIGhvb2sgJHtwYXJlbnRIb29rTmFtZX0gcmVxdWlyZXMgc29tZSBvciBhbGwgb2YgaXRzIGFyZ3VtZW50cyByZW1haW4gc3RhYmxlIGFjcm9zcyBlYWNoIHJlbmRlcjsgcGxlYXNlIGNoZWNrIHRoZSAke2luZGV4fS1pbmRleGVkIGFyZ3VtZW50LmApO1xuICAgICAgICAgICAgICAgIHNob3duRXJyb3IuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWJvdW5jZVJlbmRlcmluZyhmOiAoKSA9PiB2b2lkKSB7XG4gICAgKG9wdGlvbnMuZGVib3VuY2VSZW5kZXJpbmcgPz8gc2V0VGltZW91dCkoZik7XG59XG5cbi8qKlxuICogU2ltaWxhciB0byBgdXNlU3RhdGVgLCBidXQgZm9yIHZhbHVlcyB0aGF0IGFyZW4ndCBcInJlbmRlci1pbXBvcnRhbnRcIiAmbmRhc2g7IHVwZGF0ZXMgZG9uJ3QgY2F1c2UgYSByZS1yZW5kZXIgYW5kIHNvIHRoZSB2YWx1ZSBzaG91bGRuJ3QgYmUgdXNlZCBkdXJpbmcgcmVuZGVyICh0aG91Z2ggaXQgY2VydGFpbmx5IGNhbiwgYXQgbGVhc3QgYnkgcmUtcmVuZGVyaW5nIGFnYWluKS5cbiAqIFxuICogVG8gY29tcGVuc2F0ZSBmb3IgdGhpcywgeW91IHNob3VsZCBwYXNzIGEgYHVzZUVmZmVjdGAtZXNxdWUgY2FsbGJhY2sgdGhhdCBpcyBydW4gd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMuICBKdXN0IGxpa2UgYHVzZUVmZmVjdGAsIHRoaXMgY2FsbGJhY2sgY2FuIHJldHVybiBhIGNsZWFudXAgZnVuY3Rpb24gdGhhdCdzIHJ1biBiZWZvcmUgdGhlIHZhbHVlIGNoYW5nZXMuICBJZiB5b3Ugd291bGQgbGlrZSB0byByZS1yZW5kZXIgd2hlbiB0aGUgdmFsdWUgY2hhbmdlcyAob3IsIHNheSwgd2hlbiB0aGUgdmFsdWUgbWVldHMgc29tZSBjcml0ZXJpYSksIHRoaXMgaXMgd2hlcmUgeW91J2xsIHdhbnQgdG8gcHV0IGluIGEgY2FsbCB0byBhIGBzZXRTdGF0ZWAgZnVuY3Rpb24uXG4gKiBcbiAqIFRvIHN1bW1hcml6ZSwgaXQncyBsaWtlIGEgYHVzZVN0YXRlYC1gdXNlRWZmZWN0YCBtYXNodXA6XG4gKiBcbiAqIDEuIEl0J3MgbGlrZSBgdXNlU3RhdGVgLCBleGNlcHQgdGhpcyB2ZXJzaW9uIG9mIGBzZXRTdGF0ZWAgZG9lc24ndCByZS1yZW5kZXIgdGhlIHdob2xlIGNvbXBvbmVudFxuICogMi4gSXQncyBsaWtlIGB1c2VTdGF0ZWAsIGV4Y2VwdCB5b3UgY2FuIHJ1biBhIGZ1bmN0aW9uIHdoZW4gdGhlIHZhbHVlIGNoYW5nZXMgdGhhdCBvcHRpb25hbGx5IHJldHVybnMgYSBjbGVhbnVwIGZ1bmN0aW9uXG4gKiAzLiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB5b3UgdHJpZ2dlciB0aGUgZWZmZWN0IGZ1bmN0aW9uIFwicmVtb3RlbHlcIiBpbnN0ZWFkIG9mIGl0IHJ1bm5pbmcgYWZ0ZXIgcmVuZGVyaW5nXG4gKiA0LiBJdCdzIGxpa2UgYHVzZUVmZmVjdGAsIGV4Y2VwdCB0aGUgc2luZ2xlIFwiZGVwZW5kZW5jeVwiIGlzIGJhc2VkIG9uIHlvdXIgY2FsbHMgdG8gYHNldFN0YXRlYFxuICogXG4gKiBOb3RlIHRoYXQgd2hpbGUgY2FsbGluZyBgc2V0U3RhdGVgIGRvZXNuJ3QgY2F1c2UgYW55IHJlLXJlbmRlcnMsIHlvdSBjYW4gZG8gdGhhdCB3aXRoaW4geW91ciBgb25DaGFuZ2VgIGZ1bmN0aW9uLCBjYWxsZWQgd2hlbmV2ZXIgdGhlIHZhbHVlIGNoYW5nZXMgdmlhIHRoYXQgYHNldFN0YXRlYC5cbiAqIFxuICogQHBhcmFtIG9uQ2hhbmdlIFRoZSBcImVmZmVjdFwiIGZ1bmN0aW9uIHRvIHJ1biB3aGVuIHRoZSB2YWx1ZSBjaGFuZ2VzLiBFZmZlY3RpdmVseSB0aGUgc2FtZSBhcyBgdXNlRWZmZWN0YCdzIFwiZWZmZWN0XCIgZnVuY3Rpb24uICBNVVNUIEJFIFNUQUJMRSwgZWl0aGVyIGJlY2F1c2UgaXQgaGFzIG5vIGRlcGVuZGVuY2llcywgb3IgYmVjYXVzZSBpdCdzIGZyb20gdXNlU3RhYmxlQ2FsbGJhY2ssIGJ1dCB0aGlzIHdpbGwgbWVhbiB5b3UgY2Fubm90IHVzZSBnZXRTdGF0ZSBvciBzZXRTdGF0ZSBkdXJpbmcgcmVuZGVyLlxuICogQHBhcmFtIGdldEluaXRpYWxWYWx1ZSBJZiBwcm92aWRlZCwgdGhlIGVmZmVjdCB3aWxsIGJlIGludm9rZWQgb25jZSB3aXRoIHRoaXMgdmFsdWUgb24gbW91bnQuIE1VU1QgQkUgU1RBQkxFLCBlaXRoZXIgYmVjYXVzZSBpdCBoYXMgbm8gZGVwZW5kZW5jaWVzLCBvciBiZWNhdXNlIGl0J3MgZnJvbSB1c2VTdGFibGVDYWxsYmFjaywgYnV0IHRoaXMgd2lsbCBtZWFuIHlvdSBjYW5ub3QgdXNlIGdldFN0YXRlIG9yIHNldFN0YXRlIGR1cmluZyByZW5kZXIuXG4gKiBAcGFyYW0gY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgQnkgZGVmYXVsdCwgY2hhbmdlcyB0byBwYXNzaXZlIHN0YXRlIGFyZSBkZWxheWVkIGJ5IG9uZSB0aWNrIHNvIHRoYXQgd2Ugb25seSBjaGVjayBmb3IgY2hhbmdlcyBpbiBhIHNpbWlsYXIgd2F5IHRvIFByZWFjdC4gWW91IGNhbiBvdmVycmlkZSB0aGlzIHRvLCBmb3IgZXhhbXBsZSwgYWx3YXlzIHJ1biBpbW1lZGlhdGVseSBpbnN0ZWFkLlxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXNzaXZlU3RhdGU8VD4ob25DaGFuZ2U6IHVuZGVmaW5lZCB8IG51bGwgfCBPblBhc3NpdmVTdGF0ZUNoYW5nZTxUPiwgZ2V0SW5pdGlhbFZhbHVlPzogKCkgPT4gVCwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmc/OiB0eXBlb2YgZGVib3VuY2VSZW5kZXJpbmcpOiByZWFkb25seSBbZ2V0U3RhdGVTdGFibGU6ICgpID0+IFQsIHNldFN0YXRlU3RhYmxlOiBQYXNzaXZlU3RhdGVVcGRhdGVyPFQ+XSB7XG5cbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZjxUIHwgdHlwZW9mIFVuc2V0PihVbnNldCk7XG4gICAgY29uc3Qgd2FybmluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgY2xlYW51cENhbGxiYWNrUmVmID0gdXNlUmVmPHVuZGVmaW5lZCB8ICgoKSA9PiB2b2lkKT4odW5kZWZpbmVkKTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwcm92aWRlZCBmdW5jdGlvbnMgYXJlIHBlcmZlY3RseSBzdGFibGUgYWNyb3NzIHJlbmRlcnNcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VQYXNzaXZlU3RhdGVcIiwgb25DaGFuZ2UsIGdldEluaXRpYWxWYWx1ZSwgY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcpO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gXCJkZXBlbmRlbmN5IGNoYW5nZWRcIiBhbmQgXCJjb21wb25lbnQgdW5tb3VudGVkXCIuXG4gICAgY29uc3Qgb25TaG91bGRDbGVhblVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwQ2FsbGJhY2sgPSBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGNsZWFudXBDYWxsYmFjaylcbiAgICAgICAgICAgIGNsZWFudXBDYWxsYmFjaygpO1xuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZXJlIGFyZSBhIGNvdXBsZSBwbGFjZXMgd2hlcmUgd2UnZCBsaWtlIHRvIHVzZSBvdXIgaW5pdGlhbFxuICAgIC8vIHZhbHVlIGluIHBsYWNlIG9mIGhhdmluZyBubyB2YWx1ZSBhdCBhbGwgeWV0LlxuICAgIC8vIFRoaXMgaXMgdGhlIHNoYXJlZCBjb2RlIGZvciB0aGF0LCB1c2VkIG9uIG1vdW50IGFuZCB3aGVuZXZlclxuICAgIC8vIGdldFZhbHVlIGlzIGNhbGxlZC5cbiAgICBjb25zdCB0cnlFbnN1cmVWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ICYmIGdldEluaXRpYWxWYWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5pdGlhbFZhbHVlID0gZ2V0SW5pdGlhbFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGluaXRpYWxWYWx1ZTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKGluaXRpYWxWYWx1ZSwgdW5kZWZpbmVkKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gRXhjZXB0aW9ucyBhcmUgaW50ZW50aW9uYWwgdG8gYWxsb3cgYmFpbG91dCAod2l0aG91dCBleHBvc2luZyB0aGUgVW5zZXQgc3ltYm9sKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgWy8qIGdldEluaXRpYWxWYWx1ZSBhbmQgb25DaGFuZ2UgaW50ZW50aW9uYWxseSBvbWl0dGVkICovXSk7XG5cblxuICAgIGNvbnN0IGdldFZhbHVlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAod2FybmluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiRHVyaW5nIG9uQ2hhbmdlLCBwcmVmZXIgdXNpbmcgdGhlICh2YWx1ZSwgcHJldlZhbHVlKSBhcmd1bWVudHMgaW5zdGVhZCBvZiBnZXRWYWx1ZSAtLSBpdCdzIGFtYmlndW91cyBhcyB0byBpZiB5b3UncmUgYXNraW5nIGZvciB0aGUgb2xkIG9yIG5ldyB2YWx1ZSBhdCB0aGlzIHBvaW50IGluIHRpbWUgZm9yIHRoaXMgY29tcG9uZW50LlwiKTtcblxuICAgICAgICAvLyBUaGUgZmlyc3QgdGltZSB3ZSBjYWxsIGdldFZhbHVlLCBpZiB3ZSBoYXZlbid0IGJlZW4gZ2l2ZW4gYSB2YWx1ZSB5ZXQsXG4gICAgICAgIC8vIChhbmQgd2Ugd2VyZSBnaXZlbiBhbiBpbml0aWFsIHZhbHVlIHRvIHVzZSlcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBpbml0aWFsIHZhbHVlIGluc3RlYWQgb2Ygbm90aGluZy5cbiAgICAgICAgaWYgKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0KVxuICAgICAgICAgICAgdHJ5RW5zdXJlVmFsdWUoKTtcblxuICAgICAgICByZXR1cm4gKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkISA6IHZhbHVlUmVmLmN1cnJlbnQhKSBhcyBUO1xuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSd2ZSBydW4gb3VyIGVmZmVjdCBhdCBsZWFzdCBvbmNlIG9uIG1vdW50LlxuICAgICAgICAvLyAoSWYgd2UgaGF2ZSBhbiBpbml0aWFsIHZhbHVlLCBvZiBjb3Vyc2UpXG4gICAgICAgIHRyeUVuc3VyZVZhbHVlKCk7XG5cblxuICAgIH0sIFtdKTtcblxuICAgIC8vIFRoZSBhY3R1YWwgY29kZSB0aGUgdXNlciBjYWxscyB0byAocG9zc2libHkpIHJ1biBhIG5ldyBlZmZlY3QuXG4gICAgY29uc3QgciA9IHVzZVJlZih7IHByZXZEZXA6IFVuc2V0IGFzIFQgfCAodHlwZW9mIFVuc2V0KSB9KTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IHVzZUNhbGxiYWNrPFBhc3NpdmVTdGF0ZVVwZGF0ZXI8VD4+KChhcmcpID0+IHtcblxuICAgICAgICAvLyBSZWdhcmRsZXNzIG9mIGFueXRoaW5nIGVsc2UsIGZpZ3VyZSBvdXQgd2hhdCBvdXIgbmV4dCB2YWx1ZSBpcyBhYm91dCB0byBiZS5cbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gKGFyZyBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gYXJnKHZhbHVlUmVmLmN1cnJlbnQgPT09IFVuc2V0ID8gdW5kZWZpbmVkIDogdmFsdWVSZWYuY3VycmVudCkgOiBhcmcpO1xuXG5cbiAgICAgICAgaWYgKHIuY3VycmVudC5wcmV2RGVwID09PSBVbnNldCAmJiBuZXh0VmFsdWUgIT09IHZhbHVlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlcXVlc3QgdG8gY2hhbmdlIHRoaXMgdmFsdWUuXG4gICAgICAgICAgICAvLyBFdmFsdWF0ZSB0aGUgcmVxdWVzdCBpbW1lZGlhdGVseSwgdGhlbiBxdWV1ZSB1cCB0aGUgb25DaGFuZ2UgZnVuY3Rpb25cblxuICAgICAgICAgICAgLy8gU2F2ZSBvdXIgY3VycmVudCB2YWx1ZSBzbyB0aGF0IHdlIGNhbiBjb21wYXJlIGFnYWluc3QgaXQgbGF0ZXJcbiAgICAgICAgICAgIC8vIChpZiB3ZSBmbGlwIGJhY2sgdG8gdGhpcyBzdGF0ZSwgdGhlbiB3ZSB3b24ndCBzZW5kIHRoZSBvbkNoYW5nZSBmdW5jdGlvbilcbiAgICAgICAgICAgIHIuY3VycmVudC5wcmV2RGVwID0gdmFsdWVSZWYuY3VycmVudDtcblxuICAgICAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gdXBkYXRlIHRoaXMgaGVyZSAoYXMgd2VsbCBhcyBiZWxvdykgaW4gY2FzZSBjdXN0b21EZWJvdW5jZVJlbmRlcmluZyBpbnZva2VzIHRoaXMgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBhY3R1YWwgY2hlY2sgYW5kIGludm9jYXRpb24gb2Ygb25DaGFuZ2UgbGF0ZXIgdG8gbGV0IGVmZmVjdHMgc2V0dGxlXG4gICAgICAgICAgICAoY3VzdG9tRGVib3VuY2VSZW5kZXJpbmcgPz8gZGVib3VuY2VSZW5kZXJpbmcpKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0RGVwID0gdmFsdWVSZWYuY3VycmVudCEgYXMgVDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2RGVwID0gci5jdXJyZW50LnByZXZEZXAgO1xuICAgICAgICAgICAgICAgIGlmIChyLmN1cnJlbnQucHJldkRlcCAhPSB2YWx1ZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHdhcm5pbmdSZWYuY3VycmVudCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhbGwgYW55IHJlZ2lzdGVyZWQgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgb25TaG91bGRDbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhbnVwQ2FsbGJhY2tSZWYuY3VycmVudCA9IChvbkNoYW5nZT8uKG5leHREZXAsIHByZXZEZXAgPT09IFVuc2V0PyB1bmRlZmluZWQgOiBwcmV2RGVwKSA/PyB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IG5leHREZXA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgdXNlciB0byBub3JtYWxseSBjYWxsIGdldFZhbHVlIGFnYWluXG4gICAgICAgICAgICAgICAgICAgICAgICB3YXJuaW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gV2UndmUgZmluaXNoZWQgd2l0aCBldmVyeXRoaW5nLCBzbyBtYXJrIHVzIGFzIGJlaW5nIG9uIGEgY2xlYW4gc2xhdGUgYWdhaW4uXG4gICAgICAgICAgICAgICAgci5jdXJyZW50LnByZXZEZXAgPSBVbnNldDtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlIGltbWVkaWF0ZWx5LlxuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgY2hlY2tlZCBhZ2FpbnN0IHByZXZEZXAgdG8gc2VlIGlmIHdlIHNob3VsZCBhY3R1YWxseSBjYWxsIG9uQ2hhbmdlXG4gICAgICAgIHZhbHVlUmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG5cbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4gW2dldFZhbHVlLCBzZXRWYWx1ZV0gYXMgY29uc3Q7XG59XG5cbmNvbnN0IFVuc2V0ID0gU3ltYm9sKCk7XG5cbi8vIEVhc3kgY29uc3RhbnRzIGZvciBnZXRJbml0aWFsVmFsdWVcbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5UcnVlKCkgeyByZXR1cm4gdHJ1ZTsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVybkZhbHNlKCkgeyByZXR1cm4gZmFsc2U7IH1cbmV4cG9ydCBmdW5jdGlvbiByZXR1cm5OdWxsKCkgeyByZXR1cm4gbnVsbDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblVuZGVmaW5lZCgpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHJldHVyblplcm8oKSB7IHJldHVybiAwOyB9IiwiXG5pbXBvcnQgeyBTdGF0ZVVwZGF0ZXIsIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlLCByZXR1cm5OdWxsLCByZXR1cm5UcnVlLCB1c2VFbnN1cmVTdGFiaWxpdHksIHVzZVBhc3NpdmVTdGF0ZSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5cblxuLyoqXG4gKiBcbiAqIFRoZXJlIGFyZSBzZXZlcmFsIGRpZmZlcmVudCB3YXlzIHRoYXQgYSBmb2N1cyBldmVudCBjYW4gaGFwcGVuLiAgQXNzdW1lXG4gKiB0aGUgZm9sbG93aW5nIHN0ZXBzIGhhcHBlbiBpbiBvcmRlcjpcbiAqIFxuICogMS4gVGhlIHBhZ2UgbG9hZHMuXG4gKiAgICAqIE5vdGhpbmcgaXMgZm9jdXNlZCwgYnV0IGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBgYm9keWAuIFxuICogICAgKiBObyBmb2N1cyBldmVudHMgYXJlIGZpcmVkLlxuICogMi4gVGhlIHdpbmRvdyBpcyBmb2N1c2VkLCBhbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCByZW1haW5zIGFzIGBib2R5YC5cbiAqICAgICogQSBgZm9jdXNgL2Bmb2N1c2luYCBldmVudCAqTUlHSFQqIGJlIGZpcmVkIGZvciBgYm9keWAuIERlcGVuZGluZyBvblxuICogICAgICB0aGUgYnJvd3NlciwgdGhpcyBkZXBlbmRzIG9uIHdoZXRoZXIgdGhlIGhhbmRsZXIgd2FzIGF0dGFjaGVkIHRvIGB3aW5kb3dgIG9yIGBkb2N1bWVudGAuXG4gKiAgICAgIFByb2JhYmx5IGp1c3QgYmVzdCB0byBub3QgcmVseSBvbiBpdCwgb3IgbGlzdGVuIHRvIGB3aW5kb3dgIGZvY3VzIGV2ZW50cyBkaXJlY3RseS5cbiAqIDMuIEEgZm9jdXNhYmxlIGVsZW1lbnQgaXMgY2xpY2tlZCwgZXRjLlxuICogICAgKiBUaGUgYGFjdGl2ZUVsZW1lbnRgIGlzIHNldCB0byB0aGUgbmV3IGVsZW1lbnQgYmVmb3JlIGFueSBldmVudCBldmVuIGZpcmVzLlxuICogICAgKiBgZm9jdXNvdXRgIGFuZCBgYmx1cmAgYXJlICpub3QqIGZpcmVkIG9uIGBib2R5YC5cbiAqICAgICogYGZvY3VzYCBhbmQgYGZvY3VzaW5gIGFyZSBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyBudWxsLlxuICogNC4gQSBmb2N1c2FibGUgZWxlbWVudCBpcyBjbGlja2VkLCBldGMuXG4gKiAgICAqICoqVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gdGhlIGBib2R5YCoqIGJlZm9yZSBhbnkgZXZlbnQgZXZlbiBmaXJlcy5cbiAqICAgICogYGJsdXJgIGFuZCBgZm9jdXNvdXRgIGFyZSBmaXJlZCBvbiB0aGUgb2xkIGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIFRoZSBgYWN0aXZlRWxlbWVudGAgaXMgbm93IHNldCB0byB0aGUgbmV3IGVsZW1lbnQuXG4gKiAgICAqIGBmb2N1c2luYCBpcyBmaXJlZCBvbiB0aGUgbmV3IGVsZW1lbnQuIGByZWxhdGVkVGFyZ2V0YCBpcyB0aGUgb2xkIGVsZW1lbnQuXG4gKiA1LiBBbiB1bmZvY3VzYWJsZSBlbGVtZW50IGlzIGNsaWNrZWQsIHRleHQgaXMgc2VsZWN0ZWQsIGV0Yy5cbiAqICAgICogVGhlIGBhY3RpdmVFbGVtZW50YCBpcyBzZXQgdG8gYGJvZHlgLlxuICogICAgKiBgYmx1cmAgYW5kIGBmb2N1c291dGAgYXJlIGZpcmVkIG9uIHRoZSBvbGQgZWxlbWVudC4gYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwuXG4gKiAgICAqIGBmb2N1c2luYCBpcyAqbm90KiBmaXJlZCBvbiBgYm9keWAuXG4gKiBcbiAqIFxuICogSW4gc3VtbWFyeTpcbiAqIDEuIEZvY3VzIGV2ZW50cyAqZG8qIG5vdGlmeSB1cyBvZiBhbGwgY2hhbmdlcyBpbiBmb2N1cywgYnV0IHRoZXJlIGlzIG5vIG9uZSBzaW5nbGUgY29tcHJlaGVuc2l2ZSBldmVudCB0aGF0IHByb3ZpZGVzIHVzIHdpdGggYWxsIGF2YWlsYWJsZSBpbmZvcm1hdGlvbi5cbiAqIDIuIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCAqaXMgbm90KiBhbHdheXMgdGhlIHNhbWUgYXMgd2hhdCdzIGJlaW5nIHJlZmVyZW5jZWQgYnkgYSBmb2N1cyBldmVudC4gSW4gcGFydGljdWxhciwgaXQgbWF5IGJlY29tZSBgYm9keWAgYXQgYW55IGFyYml0cmFyeSB0aW1lLlxuICogMy4gQSBgYmx1cmAgd2l0aG91dCBhIGBmb2N1c2AgY2FuIGFuZCB3aWxsIG9jY3VyLiBUaGlzIG1lYW5zIGl0IGlzIG5vdCBwb3NzaWJsZSB0byBzb2xlbHkgdXNlIGBmb2N1c2AgdG8gZGV0ZWN0IGFsbCBjaGFuZ2VzLlxuICogNC4gQSBgYmx1cmAgZXZlbnQgd2hvc2UgYHJlbGF0ZWRUYXJnZXRgIGlzIG51bGwgaW5kaWNhdGVzIHRoYXQgdGhlcmUgd2lsbCBiZSBubyBmb2xsb3dpbmcgYGZvY3VzYCBldmVudC5cbiAqIFxuICovXG5jb25zdCBfZHVtbXkgPSAwO1xuXG5pbnRlcmZhY2UgRm9vPFQ+IHtcbiAgICBsYXN0U2VudDogVCB8IHVuZGVmaW5lZDtcbiAgICBzZW5kOiAoZTogVCkgPT4gdm9pZDtcbn1cbi8qXG5jb25zdCBhY3RpdmVFbGVtZW50VXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGU6IE5vZGUgfCBudWxsKSA9PiB2b2lkKT4+KCk7XG5jb25zdCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbmV3IE1hcDxXaW5kb3cgfCBudWxsIHwgdW5kZWZpbmVkLCBTZXQ8dW5kZWZpbmVkIHwgKChlOiBOb2RlKSA9PiB2b2lkKT4+KCk7XG5jb25zdCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDx1bmRlZmluZWQgfCAoKGZvY3VzZWQ6IGJvb2xlYW4pID0+IHZvaWQpPj4oKTtcbmNvbnN0IHdpbmRvd3NGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIGJvb2xlYW4+KCk7Ki9cbmNvbnN0IGFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxOb2RlIHwgbnVsbD4+PigpO1xuY29uc3QgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxOb2RlPj4+KCk7XG5jb25zdCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMgPSBuZXcgTWFwPFdpbmRvdyB8IG51bGwgfCB1bmRlZmluZWQsIFNldDxGb288Ym9vbGVhbj4+PigpO1xuY29uc3Qgd2luZG93c0ZvY3VzZWRVcGRhdGVycyA9IG5ldyBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgYm9vbGVhbj4oKTtcblxuLy9jb25zdCBtaWNyb3Rhc2tzID0gbmV3IE1hcDxTZXQ8YW55PiwgYW55PigpO1xuXG4vLyBUaGUgZm9jdXNpbiBhbmQgZm9jdXNvdXQgZXZlbnRzIG9mdGVuIGZpcmUgc3luY3Jvbm91c2x5IGluIHRoZSBtaWRkbGUgb2YgcnVubmluZyBjb2RlLlxuLy8gRS5HLiBjYWxsaW5nIGVsZW1lbnQuZm9jdXMoKSBjYW4gY2F1c2UgYSBmb2N1c2luIGV2ZW50IGhhbmRsZXIgdG8gaW1tZWRpYXRlbHkgaW50ZXJydXB0IHRoYXQgY29kZS5cbi8vIEZvciB0aGUgcHVycG9zZSBvZiBpbXByb3Zpbmcgc3RhYmlsaXR5LCB3ZSBkZWJvdW5jZSBhbGwgZm9jdXMgZXZlbnRzIHRvIHRoZSBuZXh0IG1pY3JvdGFzay5cbmZ1bmN0aW9uIGZvckVhY2hVcGRhdGVyPFQ+KHdpbmRvdzogV2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgbWFwOiBNYXA8V2luZG93IHwgbnVsbCB8IHVuZGVmaW5lZCwgU2V0PEZvbzxUPj4+LCB2YWx1ZTogVCkge1xuICAgIGNvbnN0IHVwZGF0ZXJzID0gbWFwLmdldCh3aW5kb3cpO1xuICAgIGlmICh1cGRhdGVycykge1xuICAgICAgICAvL2lmICghbWljcm90YXNrcy5oYXModXBkYXRlcnNLZXkpKSB7XG4gICAgICAgIC8vZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAvL2NvbnN0IHVwZGF0ZXJzS2V5ID0gbWFwLmdldCh3aW5kb3cpITtcbiAgICAgICAgLy9jb25zdCB2YWx1ZSA9IG1pY3JvdGFza3MuZ2V0KHVwZGF0ZXJzS2V5KTtcbiAgICAgICAgLy9taWNyb3Rhc2tzLmRlbGV0ZSh1cGRhdGVyc0tleSk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHVwZGF0ZXIgb2YgdXBkYXRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxhc3RTZW50LCBzZW5kIH0gPSB1cGRhdGVyO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbGFzdFNlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZXIubGFzdFNlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvL30pO1xuICAgICAgICAvL31cblxuICAgICAgICAvL21pY3JvdGFza3Muc2V0KHVwZGF0ZXJzS2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb2N1c291dChlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICBpZiAoZS5yZWxhdGVkVGFyZ2V0ID09IG51bGwpIHtcbiAgICAgICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBhY3RpdmVFbGVtZW50VXBkYXRlcnMsIG51bGwpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSnVzdCB3YWl0IGZvciB0aGUgZm9jdXNpbiBldmVudC5cbiAgICB9XG5cbn1cblxuZnVuY3Rpb24gZm9jdXNpbihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGFzIEVsZW1lbnQpLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgY29uc3QgY3VycmVudGx5Rm9jdXNlZEVsZW1lbnQgPSBlLnRhcmdldCBhcyAoRWxlbWVudCAmIEhUTUxPclNWR0VsZW1lbnQpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCBsYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzLCBjdXJyZW50bHlGb2N1c2VkRWxlbWVudCk7XG59XG5cbmZ1bmN0aW9uIHdpbmRvd0ZvY3VzKGU6IEZvY3VzRXZlbnQpIHtcbiAgICBjb25zdCB3aW5kb3cgPSAoZS50YXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLnRhcmdldCA6IGUuY3VycmVudFRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdyA/IGUuY3VycmVudFRhcmdldCA6IChlLnRhcmdldCBhcyBFbGVtZW50KS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3KTtcbiAgICB3aW5kb3dzRm9jdXNlZFVwZGF0ZXJzLnNldCh3aW5kb3csIHRydWUpO1xuICAgIGZvckVhY2hVcGRhdGVyKHdpbmRvdywgd2luZG93Rm9jdXNlZFVwZGF0ZXJzLCB0cnVlKTtcbn1cblxuZnVuY3Rpb24gd2luZG93Qmx1cihlOiBGb2N1c0V2ZW50KSB7XG4gICAgY29uc3Qgd2luZG93ID0gKGUudGFyZ2V0IGluc3RhbmNlb2YgV2luZG93ID8gZS50YXJnZXQgOiBlLmN1cnJlbnRUYXJnZXQgaW5zdGFuY2VvZiBXaW5kb3cgPyBlLmN1cnJlbnRUYXJnZXQgOiAoZS50YXJnZXQgYXMgRWxlbWVudCkub3duZXJEb2N1bWVudC5kZWZhdWx0Vmlldyk7XG4gICAgd2luZG93c0ZvY3VzZWRVcGRhdGVycy5zZXQod2luZG93LCBmYWxzZSk7XG4gICAgZm9yRWFjaFVwZGF0ZXIod2luZG93LCB3aW5kb3dGb2N1c2VkVXBkYXRlcnMsIGZhbHNlKTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycyB7XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYW55IHRpbWUgdGhlIGFjdGl2ZSBlbGVtZW50IGNoYW5nZXMuIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZT86IE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnQgfCBudWxsPjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcyBhbmQgaXMgbm90IG51bGwuIFxuICAgICAqIE11c3QgYmUgc3RhYmxlLlxuICAgICAqL1xuICAgIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxFbGVtZW50PjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhbnkgdGltZSB0aGUgd2luZG93IGdhaW5zL2xvc2VzIGZvY3VzLiBNdXN0IGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2U/OiBPblBhc3NpdmVTdGF0ZUNoYW5nZTxib29sZWFuPjtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZG9jdW1lbnQgYXNzb2NpYXRlZCB3aXRoIHdoYXRldmVyIGVsZW1lbnRzIHdlJ3JlIGxpc3RlbmluZyB0by5cbiAgICAgKiBcbiAgICAgKiBFLkcuIHNvbWVEaXZFbGVtZW50Lm93bmVyRG9jdW1lbnRcbiAgICAgKiBcbiAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGVcbiAgICAgKi9cbiAgICBnZXREb2N1bWVudCgpOiBEb2N1bWVudDtcblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIGV2ZW50IGhhbmRsZXJzIGFyZSBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQncyBkZWZhdWx0VmlldyBXaW5kb3cuXG4gICAgICogSWYgeW91IG5lZWQgc29tZXRoaW5nIGRpZmZlcmVudCwgb3ZlcnJpZGUgaXQgaGVyZS5cbiAgICAgKiBcbiAgICAgKiAqKk1VU1QqKiBiZSBzdGFibGVcbiAgICAgKi9cbiAgICBnZXRXaW5kb3c/KGRvY3VtZW50OiBEb2N1bWVudCk6IFdpbmRvdztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XG4gICAgLyoqIFxuICAgICAqIFJldHVybnMgd2hhdGV2ZXIgZWxlbWVudCBpcyBjdXJyZW50bHkgZm9jdXNlZCwgb3IgYG51bGxgIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50XG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGdldEFjdGl2ZUVsZW1lbnQ6ICgpID0+IEVsZW1lbnQgfCBudWxsO1xuICAgIC8qKiBcbiAgICAgKiBSZXR1cm5zIHdoYXRldmVyIGVsZW1lbnQgaXMgY3VycmVudGx5IGZvY3VzZWQsIG9yIHdoYXRldmVyIGVsZW1lbnQgd2FzIG1vc3QgcmVjZW50bHkgZm9jdXNlZCBpZiB0aGVyZSdzIG5vIGZvY3VzZWQgZWxlbWVudFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICBnZXRMYXN0QWN0aXZlRWxlbWVudDogKCkgPT4gRWxlbWVudDtcbiAgICAvKiogXG4gICAgICogUmV0dXJucyBpZiB0aGUgd2luZG93IGl0c2VsZiBoYXMgZm9jdXMgb3Igbm90XG4gICAgICogKipTVEFCTEUqKlxuICAgICAqL1xuICAgIGdldFdpbmRvd0ZvY3VzZWQ6ICgpID0+IGJvb2xlYW47XG59XG5cbi8qKlxuICogQWxsb3dzIHlvdSB0byBpbnNwZWN0IHdoaWNoIGVsZW1lbnQgaW4gdGhlIGBkb2N1bWVudGAgY3VycmVudGx5IGhhcyBmb2N1cywgd2hpY2ggd2FzIG1vc3QgcmVjZW50bHkgZm9jdXNlZCBpZiBub25lIGFyZSBjdXJyZW50bHksIGFuZCB3aGV0aGVyIG9yIG5vdCB0aGUgd2luZG93IGhhcyBmb2N1cyBieSByZXR1cm5pbmcgdGhlIGZvbGxvd2luZyBmdW5jdGlvbnM6XG4gKiAqIGBnZXRBY3RpdmVFbGVtZW50KClgXG4gKiAqIGBnZXRMYXN0QWN0aXZlRWxlbWVudCgpYFxuICogKiBgZ2V0V2luZG93Rm9jdXNlZCgpYFxuICogXG4gKiAoVGhlIGRvY3VtZW50J3MgYm9keSByZWNlaXZpbmcgZm9jdXMsIGxpa2UgaXQgZG9lcyB3aGVuIHlvdSBjbGljayBvbiBhbiBlbXB0eSBhcmVhLCBpcyBjb3VudGVkIGFzIG5vIGVsZW1lbnQgaGF2aW5nIGZvY3VzIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMpXG4gKiBcbiAqIFRoaXMgaXMgYSBwYXNzaXZlIGhvb2ssIHNvIGJ5IGRlZmF1bHQgaXQgcmV0dXJucyBnZXR0ZXIgZnVuY3Rpb25zIHRoYXQgcmVwb3J0IHRoaXMgaW5mb3JtYXRpb24gYnV0IHRoZSBjb21wb25lbnQgd2lsbCBub3QgcmUtcmVuZGVyIGJ5IGRlZmF1bHQgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcy5cbiAqIFxuICogSWYgeW91IG5lZWQgdGhlIGNvbXBvbmVudCB0byByZS1yZW5kZXIgd2hlbiB0aGUgYWN0aXZlIGVsZW1lbnQgY2hhbmdlcywgdXNlIHRoZSBgb24qQ2hhbmdlYCBhcmd1bWVudHMgdG8gc2V0IHNvbWUgc3RhdGUgb24geW91ciBlbmQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VBY3RpdmVFbGVtZW50KHsgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIGdldERvY3VtZW50LCBnZXRXaW5kb3cgfTogVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMpOiBVc2VBY3RpdmVFbGVtZW50UmV0dXJuVHlwZSB7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VBY3RpdmVFbGVtZW50XCIsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gKGdldFdpbmRvdz8uKGRvY3VtZW50KSA/PyBkb2N1bWVudD8uZGVmYXVsdFZpZXcpO1xuXG4gICAgICAgIGlmICgoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpPy5zaXplID8/IDApID09PSAwKSB7XG4gICAgICAgICAgICBkb2N1bWVudD8uYWRkRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbiwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgZG9jdW1lbnQ/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICAgICAgd2luZG93Py5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMsIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHdpbmRvdz8uYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1ciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoZW0gZXZlbiBpZiB0aGV5J3JlIHVuZGVmaW5lZCB0byBtb3JlIGVhc2lseVxuICAgICAgICAvLyBtYW5hZ2UgdGhlIFwiPjAgbWVhbnMgZG9uJ3QgYWRkIGhhbmRsZXJzXCIgbG9naWMuXG4gICAgICAgIGNvbnN0IGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gYWN0aXZlRWxlbWVudFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgbG9jYWxMYXN0QWN0aXZlRWxlbWVudFVwZGF0ZXJzID0gbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5nZXQod2luZG93KSA/PyBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGxvY2FsV2luZG93Rm9jdXNlZFVwZGF0ZXJzID0gd2luZG93Rm9jdXNlZFVwZGF0ZXJzLmdldCh3aW5kb3cpID8/IG5ldyBTZXQoKTtcblxuICAgICAgICBjb25zdCBsYWV1ID0geyBzZW5kOiBzZXRBY3RpdmVFbGVtZW50IGFzIFN0YXRlVXBkYXRlcjxOb2RlIHwgbnVsbD4sIGxhc3RTZW50OiB1bmRlZmluZWQgfVxuICAgICAgICBjb25zdCBsbGFldSA9IHsgc2VuZDogc2V0TGFzdEFjdGl2ZUVsZW1lbnQgYXMgU3RhdGVVcGRhdGVyPE5vZGU+LCBsYXN0U2VudDogdW5kZWZpbmVkIH07XG4gICAgICAgIGNvbnN0IGx3ZnUgPSB7IHNlbmQ6IHNldFdpbmRvd0ZvY3VzZWQsIGxhc3RTZW50OiB1bmRlZmluZWQgfTtcblxuICAgICAgICBsb2NhbEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQobGFldSk7XG4gICAgICAgIGxvY2FsTGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5hZGQobGxhZXUpO1xuICAgICAgICBsb2NhbFdpbmRvd0ZvY3VzZWRVcGRhdGVycy5hZGQobHdmdSk7XG5cbiAgICAgICAgYWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNldCh3aW5kb3csIGxvY2FsQWN0aXZlRWxlbWVudFVwZGF0ZXJzKTtcbiAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnRVcGRhdGVycy5zZXQod2luZG93LCBsb2NhbExhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMpO1xuICAgICAgICB3aW5kb3dGb2N1c2VkVXBkYXRlcnMuc2V0KHdpbmRvdywgbG9jYWxXaW5kb3dGb2N1c2VkVXBkYXRlcnMpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBhY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShsYWV1KTtcbiAgICAgICAgICAgIGxhc3RBY3RpdmVFbGVtZW50VXBkYXRlcnMuZ2V0KHdpbmRvdykhLmRlbGV0ZShsYWV1KTtcbiAgICAgICAgICAgIHdpbmRvd0ZvY3VzZWRVcGRhdGVycy5nZXQod2luZG93KSEuZGVsZXRlKGx3ZnUpO1xuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudFVwZGF0ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkb2N1bWVudD8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzaW5cIiwgZm9jdXNpbik7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCBmb2N1c291dCk7XG4gICAgICAgICAgICAgICAgd2luZG93Py5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgd2luZG93Rm9jdXMpO1xuICAgICAgICAgICAgICAgIHdpbmRvdz8ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgd2luZG93Qmx1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSlcblxuICAgIGNvbnN0IFtnZXRBY3RpdmVFbGVtZW50LCBzZXRBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50IHwgbnVsbD4ob25BY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsKTtcbiAgICBjb25zdCBbZ2V0TGFzdEFjdGl2ZUVsZW1lbnQsIHNldExhc3RBY3RpdmVFbGVtZW50XSA9IHVzZVBhc3NpdmVTdGF0ZTxFbGVtZW50Pihvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlLCByZXR1cm5OdWxsIGFzICgpID0+IG5ldmVyKTtcbiAgICBjb25zdCBbZ2V0V2luZG93Rm9jdXNlZCwgc2V0V2luZG93Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25XaW5kb3dGb2N1c2VkQ2hhbmdlLCByZXR1cm5UcnVlKTtcblxuICAgIHJldHVybiB7IGdldEFjdGl2ZUVsZW1lbnQsIGdldExhc3RBY3RpdmVFbGVtZW50LCBnZXRXaW5kb3dGb2N1c2VkIH07XG59XG4iLCJcbmltcG9ydCB7IENvbXBvbmVudCwgb3B0aW9ucywgVk5vZGUgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBFZmZlY3RDYWxsYmFjaywgSW5wdXRzLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuXG5cblxuY29uc3QgVGFibGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xy1cIjtcblxuZnVuY3Rpb24gYmFzZTY0KHZhbHVlOiBudW1iZXIpIHtcbiAgICByZXR1cm4gVGFibGVbdmFsdWVdO1xufVxuXG5mdW5jdGlvbiByYW5kb202Qml0cygpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMGIxMDAwMDAwKTtcbn1cblxuZnVuY3Rpb24gcmFuZG9tNjRCaXRzKCkge1xuICAgIHJldHVybiBbcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKSwgcmFuZG9tNkJpdHMoKV0gYXMgY29uc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHJhbmRvbWx5LWdlbmVyYXRlZCBJRCB3aXRoIGFuIG9wdGlvbmFsIHByZWZpeC5cbiAqIE5vdGUgdGhhdCBpZiB0aGUgcHJlZml4IGlzICpleHBsaWNpdGx5KiBzZXQgdG8gXCJcIiwgdGhlblxuICogSURzIHRoYXQgYXJlIG5vdCB2YWxpZCB1bmRlciBIVE1MNCBtYXkgYmUgZ2VuZXJhdGVkLiBPaCBuby5cbiAqIFxuICogXG4gKiAoVGhpcyBpcyBoZXJlLCBpbiB0aGlzIHBhcnRpY3VsYXIgZmlsZSwgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzXG4gKiB3aXRob3V0IGFsc28gbWFraW5nIGEgdXRpbGl0aWVzIGZpbGUuXG4gKiBPbmNlIHdlIGNhbiByZW1vdmUgdGhpcyBob29rLCB3ZSBjYW4gcHV0IHRoaXMgZnVuY3Rpb24gYmFjayB3aXRoIHVzZVJhbmRvbUlkKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVSYW5kb21JZChwcmVmaXg/OiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYCR7cHJlZml4ID8/IFwiaWQtXCJ9JHtyYW5kb202NEJpdHMoKS5tYXAobiA9PiBiYXNlNjQobikpLmpvaW4oXCJcIil9YDtcbn1cblxuY29uc3QgcHJldmlvdXNJbnB1dHMgPSBuZXcgTWFwPHN0cmluZywgSW5wdXRzIHwgdW5kZWZpbmVkPigpO1xuY29uc3QgdG9SdW4gPSBuZXcgTWFwPHN0cmluZywgeyBlZmZlY3Q6IEVmZmVjdENhbGxiYWNrLCBpbnB1dHM/OiBJbnB1dHMsIGNsZWFudXA6IG51bGwgfCB1bmRlZmluZWQgfCB2b2lkIHwgKCgpID0+IHZvaWQpIH0+KCk7XG5cblxuLy8gVE9ETzogV2hldGhlciB0aGlzIGdvZXMgaW4gb3B0aW9ucy5kaWZmZWQgb3Igb3B0aW9ucy5fY29tbWl0XG4vLyBpcyBhIHBvc3Qtc3VzcGVuc2UgcXVlc3Rpb24uXG4vLyBSaWdodCBub3csIHVzaW5nIG9wdGlvbnMuX2NvbW1pdCBoYXMgdGhlIHByb2JsZW0gb2YgcnVubmluZ1xuLy8gKmFmdGVyKiByZWZzIGFyZSBhcHBsaWVkLCBidXQgd2UgbmVlZCB0byBjb21lIGJlZm9yZSBldmVuIHRoYXRcbi8vIHNvIGByZWY9e3NvbWVTdGFibGVGdW5jdGlvbn1gIHdvcmtzLlxuLy8gXG4vLyBBbHNvIGl0J3MgcHJpdmF0ZS5cbi8vXG4vLyAuLi5cbi8vIFdlbGwsIHVzZUV2ZW50IG9yIHdoYXRldmVyIGlzIGZpbmFsbHksIGZpbmFsbHkgNCB5ZWFycyBsYXRlciBmaW5hbGx5IGhlcmVcbi8vIHdoaWNoIGlzIGNvb2wgYW5kIG1lYW5zIHdlIHdvbid0IG5lZWQgdGhpcyBhdCBhbGwgc29vbi5cbi8vIFNvIGZvciBub3cgd2UnbGwgc3RpY2sgd2l0aCBkaWZmIHRvIHByZXZlbnQgYW55IHdlaXJkbmVzcyB3aXRoXG4vLyBjb21taXQgYmVpbmcgcHJpdmF0ZSBhbmQgYWxsLlxuY29uc3QgY29tbWl0TmFtZSA9IFwiZGlmZmVkXCI7XG5cbmNvbnN0IG9yaWdpbmFsQ29tbWl0ID0gb3B0aW9uc1tjb21taXROYW1lXSBhcyAodm5vZGU6IFZOb2RlLCBjb21taXRRdWV1ZTogQ29tcG9uZW50W10pID0+IHZvaWQ7XG5jb25zdCBuZXdDb21taXQ6IHR5cGVvZiBvcmlnaW5hbENvbW1pdCA9ICguLi5hcmdzKSA9PiB7XG4gICAgZm9yIChjb25zdCBbaWQsIGVmZmVjdEluZm9dIG9mIHRvUnVuKSB7XG4gICAgICAgIGNvbnN0IG9sZElucHV0cyA9IHByZXZpb3VzSW5wdXRzLmdldChpZCk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChvbGRJbnB1dHMsIGVmZmVjdEluZm8uaW5wdXRzKSkge1xuICAgICAgICAgICAgZWZmZWN0SW5mby5jbGVhbnVwPy4oKTtcbiAgICAgICAgICAgIGVmZmVjdEluZm8uY2xlYW51cCA9IGVmZmVjdEluZm8uZWZmZWN0KCk7XG4gICAgICAgICAgICBwcmV2aW91c0lucHV0cy5zZXQoaWQsIGVmZmVjdEluZm8uaW5wdXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1J1bi5jbGVhcigpO1xuICAgIG9yaWdpbmFsQ29tbWl0Py4oLi4uYXJncyk7XG59XG5vcHRpb25zW2NvbW1pdE5hbWVdID0gbmV3Q29tbWl0IGFzIG5ldmVyXG5cbi8qKlxuICogU2VtaS1wcml2YXRlIGZ1bmN0aW9uIHRvIGFsbG93IHN0YWJsZSBjYWxsYmFja3MgZXZlbiB3aXRoaW4gYHVzZUxheW91dEVmZmVjdGAgYW5kIHJlZiBhc3NpZ25tZW50LlxuICogXG4gKiBFdmVyeSByZW5kZXIsIHdlIHNlbmQgdGhlIGFyZ3VtZW50cyB0byBiZSBldmFsdWF0ZWQgYWZ0ZXIgZGlmZmluZyBoYXMgY29tcGxldGVkLFxuICogd2hpY2ggaGFwcGVucyBiZWZvcmUuXG4gKiBcbiAqIEBwYXJhbSBlZmZlY3QgXG4gKiBAcGFyYW0gaW5wdXRzIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQmVmb3JlTGF5b3V0RWZmZWN0KGVmZmVjdDogRWZmZWN0Q2FsbGJhY2ssIGlucHV0cz86IElucHV0cykge1xuXG4gICAgLyooKCkgPT4ge1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gdXNlUmVmPHZvaWQgfCAoKCkgPT4gdm9pZCkgfCBudWxsPihudWxsKTtcbiAgICAgICAgY29uc3QgcHJldkFyZ3NSZWYgPSB1c2VSZWY8SW5wdXRzPihudWxsISk7XG4gICAgICAgIGlmIChhcmdzQ2hhbmdlZChpbnB1dHMsIHByZXZBcmdzUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBwcmV2QXJnc1JlZi5jdXJyZW50ID0gaW5wdXRzITtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgY2xlYW51cC5jdXJyZW50KCk7XG4gICAgICAgICAgICBjbGVhbnVwLmN1cnJlbnQgPSBlZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH0pKCk7Ki9cblxuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBnZW5lcmF0ZVJhbmRvbUlkKCkpO1xuICAgIHRvUnVuLnNldChpZCwgeyBlZmZlY3QsIGlucHV0cywgY2xlYW51cDogbnVsbCB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0b1J1bi5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnB1dHMuZGVsZXRlKGlkKTtcbiAgICAgICAgfVxuICAgIH0sIFtpZF0pXG59XG5cbmZ1bmN0aW9uIGFyZ3NDaGFuZ2VkKG9sZEFyZ3M/OiBJbnB1dHMsIG5ld0FyZ3M/OiBJbnB1dHMpOiBib29sZWFuIHtcbiAgICByZXR1cm4gISEoXG4gICAgICAgICFvbGRBcmdzIHx8XG4gICAgICAgIG9sZEFyZ3MubGVuZ3RoICE9PSBuZXdBcmdzPy5sZW5ndGggfHxcbiAgICAgICAgbmV3QXJncz8uc29tZSgoYXJnLCBpbmRleCkgPT4gYXJnICE9PSBvbGRBcmdzW2luZGV4XSlcbiAgICApO1xufSIsImltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VCZWZvcmVMYXlvdXRFZmZlY3QgfSBmcm9tIFwiLi91c2UtYmVmb3JlLWxheW91dC1lZmZlY3RcIjtcblxuY29uc3QgVW5zZXQgPSBTeW1ib2woXCJ1bnNldFwiKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbnB1dCB2YWx1ZSwgcmV0dXJucyBhIGNvbnN0YW50IGdldHRlciBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIFxuICogaW5zaWRlIG9mIGB1c2VFZmZlY3RgIGFuZCBmcmllbmRzIHdpdGhvdXQgaW5jbHVkaW5nIGl0IGluIHRoZSBkZXBlbmRlbmN5IGFycmF5LlxuICogXG4gKiBUaGlzIHVzZXMgYG9wdGlvbnMuZGlmZmVkYCBpbiBvcmRlciB0byBydW4gYmVmb3JlIGV2ZXJ5dGhpbmcsIGV2ZW5cbiAqIHJlZiBhc3NpZ25tZW50LiBUaGlzIG1lYW5zIHRoaXMgZ2V0dGVyIGlzIHNhZmUgdG8gdXNlIGFueXdoZXJlICoqKmV4Y2VwdCB0aGUgcmVuZGVyIHBoYXNlKioqLlxuICogXG4gKiBAcGFyYW0gdmFsdWUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUdldHRlcjxUPih2YWx1ZTogVCk6ICgpID0+IFQge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZjxUPihVbnNldCBhcyB1bmtub3duIGFzIFQpO1xuICAgIHVzZUJlZm9yZUxheW91dEVmZmVjdCgoKSA9PiB7IHJlZi5jdXJyZW50ID0gdmFsdWU7IH0sIFt2YWx1ZV0pO1xuICAgIHJldHVybiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChyZWYuY3VycmVudCBhcyB1bmtub3duID09PSBVbnNldCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdWYWx1ZSByZXRyaWV2ZWQgZnJvbSB1c2VTdGFibGVHZXR0ZXIoKSBjYW5ub3QgYmUgY2FsbGVkIGR1cmluZyByZW5kZXIuJylcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pXG59IiwiaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8qKlxuICogQWx0ZXJuYXRlIHVzZUNhbGxiYWNrKCkgd2hpY2ggYWx3YXlzIHJldHVybnMgdGhlIHNhbWUgKHdyYXBwZWQpIGZ1bmN0aW9uIHJlZmVyZW5jZVxuICogc28gdGhhdCBpdCBjYW4gYmUgZXhjbHVkZWQgZnJvbSB0aGUgZGVwZW5kZW5jeSBhcnJheXMgb2YgYHVzZUVmZmVjdGAgYW5kIGZyaWVuZHMuXG4gKiBcbiAqIERvIG5vdCB1c2UgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UhICBgdXNlTGF5b3V0RWZmZWN0YCBpcyBmaW5lIHRob3VnaC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YWJsZUNhbGxiYWNrPFQgZXh0ZW5kcyAoLi4uX2FyZ3M6IGFueVtdKSA9PiBhbnk+KGZuOiBUKTogVCB7XG4gICAgY29uc3QgY3VycmVudENhbGxiYWNrR2V0dGVyID0gdXNlU3RhYmxlR2V0dGVyPFQ+KGZuKTtcblxuICAgIHJldHVybiB1c2VDYWxsYmFjaygoLi4uYXJnczogUGFyYW1ldGVyczxUPik6IFJldHVyblR5cGU8VD4gPT4ge1xuICAgICAgICByZXR1cm4gY3VycmVudENhbGxiYWNrR2V0dGVyKCkoLi4uYXJncyk7XG4gICAgfSwgW10pIGFzIFQ7XG59IiwiaW1wb3J0IHsgQ29tcG9uZW50Q2hpbGRyZW4sIGNyZWF0ZUNvbnRleHQgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxudHlwZSBSYWZDYWxsYmFja1R5cGUgPSAobXNTaW5jZUxhc3Q6IG51bWJlciwgdGFnPzogYW55KSA9PiB2b2lkO1xuXG5pbnRlcmZhY2UgQ29udGV4dFR5cGUge1xuICAgIGFkZENhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSwgdGFnPzogYW55KSA9PiB2b2lkO1xuICAgIHJlbW92ZUNhbGxiYWNrOiAoY2FsbGJhY2s6IFJhZkNhbGxiYWNrVHlwZSkgPT4gdm9pZDtcbn1cblxuY29uc3QgU2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxudWxsIHwgQ29udGV4dFR5cGU+KG51bGwpO1xuXG5leHBvcnQgZnVuY3Rpb24gUHJvdmlkZUJhdGNoZWRBbmltYXRpb25GcmFtZXMoeyBjaGlsZHJlbiB9OiB7IGNoaWxkcmVuOiBDb21wb25lbnRDaGlsZHJlbiB9KSB7XG5cbiAgICBjb25zdCBhZGRDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wiYWRkQ2FsbGJhY2tcIl0+KChjYWxsYmFja1RvQmVCYXRjaGVkLCB0YWcpID0+IHsgYWxsQ2FsbGJhY2tzLmN1cnJlbnQuc2V0KGNhbGxiYWNrVG9CZUJhdGNoZWQsIHRhZyk7IH0sIFtdKTtcbiAgICBjb25zdCByZW1vdmVDYWxsYmFjayA9IHVzZUNhbGxiYWNrPENvbnRleHRUeXBlW1wicmVtb3ZlQ2FsbGJhY2tcIl0+KChjYWxsYmFjaykgPT4geyBhbGxDYWxsYmFja3MuY3VycmVudC5kZWxldGUoY2FsbGJhY2spOyB9LCBbXSk7XG5cbiAgICBjb25zdCBjb250ZXh0SW5mbyA9IHVzZVJlZjxDb250ZXh0VHlwZT4obnVsbCEpO1xuICAgIGlmIChjb250ZXh0SW5mby5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGNvbnRleHRJbmZvLmN1cnJlbnQgPSB7IGFkZENhbGxiYWNrLCByZW1vdmVDYWxsYmFjayB9O1xuICAgIGNvbnN0IGFsbENhbGxiYWNrcyA9IHVzZVJlZjxNYXA8UmFmQ2FsbGJhY2tUeXBlLCBhbnk+PihudWxsISk7XG4gICAgaWYgKGFsbENhbGxiYWNrcy5jdXJyZW50ID09IG51bGwpXG4gICAgICAgIGFsbENhbGxiYWNrcy5jdXJyZW50ID0gbmV3IE1hcCgpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbGV0IGhhbmRsZSA9IC0xO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJhZldpdGhCYXRjaGVkQ2FsbGJhY2tzKG1zU2luY2VMYXN0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2JhdGNoZWRSYWZDYWxsYmFjaywgdGFnXSBvZiBhbGxDYWxsYmFja3MuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGJhdGNoZWRSYWZDYWxsYmFjayhtc1NpbmNlTGFzdCwgdGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShyYWZXaXRoQmF0Y2hlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cblxuICAgICAgICBoYW5kbGUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmFmV2l0aEJhdGNoZWRDYWxsYmFja3MpO1xuXG4gICAgICAgIHJldHVybiAoKSA9PiBjYW5jZWxBbmltYXRpb25GcmFtZShoYW5kbGUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRJbmZvLmN1cnJlbnR9PlxuICAgICAgICAgICAge2NoaWxkcmVufVxuICAgICAgICA8L1NoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5Qcm92aWRlcj4pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBDYWxsYmFjayB3aXRoIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHJ1bGVzIGFzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgXG4gICAgICogXG4gICAgICogRG9lc24ndCBuZWVkIHRvIGJlIHN0YWJsZS5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogbnVsbCB8ICgobXNTaW5jZUxhc3Q6IG51bWJlcikgPT4gdm9pZCk7XG59XG5cbi8qKlxuICogVGhlIChvcHRpb25hbGx5IG5vbi1zdGFibGUpIGBjYWxsYmFja2AgeW91IHByb3ZpZGUgd2lsbCBzdGFydCBydW5uaW5nIGV2ZXJ5IGZyYW1lIGFmdGVyIHRoZSBjb21wb25lbnQgbW91bnRzLlxuICogXG4gKiBQYXNzaW5nIGBudWxsYCBpcyBmaW5lIGFuZCBzaW1wbHkgc3RvcHMgdGhlIGVmZmVjdCB1bnRpbCB5b3UgcmVzdGFydCBpdCBieSBwcm92aWRpbmcgYSBub24tbnVsbCBjYWxsYmFjay5cbiAqIFxuICogKipUaGlzIGhvb2sgZG9lcyBub3QgcmV0dXJuIGFueXRoaW5nIGF0IGFsbCwgaW5jbHVkaW5nIG5vIHByb3AtbW9kaWZ5aW5nIGhvb2tzKipcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKHsgY2FsbGJhY2sgfTogVXNlQW5pbWF0aW9uRnJhbWVQYXJhbWV0ZXJzKTogdm9pZCB7XG4gICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIGdpdmVuIGNhbGxiYWNrIHRoYXQncyBzdGFibGVcbiAgICBjb25zdCBzdGFibGVDYWxsYmFjayA9IHVzZVN0YWJsZUNhbGxiYWNrKGNhbGxiYWNrID8/IG5vb3ApO1xuICAgIGNvbnN0IGhhc0NhbGxiYWNrID0gKGNhbGxiYWNrICE9IG51bGwpO1xuXG4gICAgY29uc3Qgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0ID0gdXNlQ29udGV4dChTaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dCkge1xuICAgICAgICAgICAgaWYgKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgc2hhcmVkQW5pbWF0aW9uRnJhbWVDb250ZXh0LmFkZENhbGxiYWNrKHN0YWJsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvbkZyYW1lQ29udGV4dC5yZW1vdmVDYWxsYmFjayhzdGFibGVDYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYSB3cmFwcGVyIGFyb3VuZCB0aGUgd3JhcHBlciBhcm91bmQgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBhbHNvIGNhbGxzIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFnYWluLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhZkNhbGxiYWNrID0gKG1zOiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlQ2FsbGJhY2sobXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJhZkNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsQW5pbWF0aW9uRnJhbWUoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtzaGFyZWRBbmltYXRpb25GcmFtZUNvbnRleHQsIGhhc0NhbGxiYWNrXSlcbn1cblxuLy8gZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LWZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkgeyB9XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHRoZVxuICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICogb2YgYE9iamVjdGAuIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0KHt9KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChfLm5vb3ApO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QobnVsbCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgKHR5cGUgPT0gJ29iamVjdCcgfHwgdHlwZSA9PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNPYmplY3Q7XG4iLCIvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbCAmJiBnbG9iYWwuT2JqZWN0ID09PSBPYmplY3QgJiYgZ2xvYmFsO1xuXG5leHBvcnQgZGVmYXVsdCBmcmVlR2xvYmFsO1xuIiwiaW1wb3J0IGZyZWVHbG9iYWwgZnJvbSAnLi9fZnJlZUdsb2JhbC5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgc2VsZmAuICovXG52YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuLyoqIFVzZWQgYXMgYSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBvYmplY3QuICovXG52YXIgcm9vdCA9IGZyZWVHbG9iYWwgfHwgZnJlZVNlbGYgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuZXhwb3J0IGRlZmF1bHQgcm9vdDtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICogdGhlIFVuaXggZXBvY2ggKDEgSmFudWFyeSAxOTcwIDAwOjAwOjAwIFVUQykuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IERhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRpbWVzdGFtcC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZlcihmdW5jdGlvbihzdGFtcCkge1xuICogICBjb25zb2xlLmxvZyhfLm5vdygpIC0gc3RhbXApO1xuICogfSwgXy5ub3coKSk7XG4gKiAvLyA9PiBMb2dzIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGl0IHRvb2sgZm9yIHRoZSBkZWZlcnJlZCBpbnZvY2F0aW9uLlxuICovXG52YXIgbm93ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiByb290LkRhdGUubm93KCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBub3c7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbnZhciByZVdoaXRlc3BhY2UgPSAvXFxzLztcblxuLyoqXG4gKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlXG4gKiBjaGFyYWN0ZXIgb2YgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICovXG5mdW5jdGlvbiB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSB7XG4gIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgd2hpbGUgKGluZGV4LS0gJiYgcmVXaGl0ZXNwYWNlLnRlc3Qoc3RyaW5nLmNoYXJBdChpbmRleCkpKSB7fVxuICByZXR1cm4gaW5kZXg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHRyaW1tZWRFbmRJbmRleDtcbiIsImltcG9ydCB0cmltbWVkRW5kSW5kZXggZnJvbSAnLi9fdHJpbW1lZEVuZEluZGV4LmpzJztcblxuLyoqIFVzZWQgdG8gbWF0Y2ggbGVhZGluZyB3aGl0ZXNwYWNlLiAqL1xudmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50cmltYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB0cmltbWVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmdcbiAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgIDogc3RyaW5nO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVHJpbTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBTeW1ib2wgPSByb290LlN5bWJvbDtcblxuZXhwb3J0IGRlZmF1bHQgU3ltYm9sO1xuIiwiaW1wb3J0IFN5bWJvbCBmcm9tICcuL19TeW1ib2wuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGdldFJhd1RhZztcbiIsIi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKlxuICogVXNlZCB0byByZXNvbHZlIHRoZVxuICogW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXG4gKiBvZiB2YWx1ZXMuXG4gKi9cbnZhciBuYXRpdmVPYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBzdHJpbmcgdXNpbmcgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBvYmplY3RUb1N0cmluZztcbiIsImltcG9ydCBTeW1ib2wgZnJvbSAnLi9fU3ltYm9sLmpzJztcbmltcG9ydCBnZXRSYXdUYWcgZnJvbSAnLi9fZ2V0UmF3VGFnLmpzJztcbmltcG9ydCBvYmplY3RUb1N0cmluZyBmcm9tICcuL19vYmplY3RUb1N0cmluZy5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBudWxsVGFnID0gJ1tvYmplY3QgTnVsbF0nLFxuICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1Ub1N0cmluZ1RhZyA9IFN5bWJvbCA/IFN5bWJvbC50b1N0cmluZ1RhZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGB0b1N0cmluZ1RhZ2AuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZFRhZyA6IG51bGxUYWc7XG4gIH1cbiAgcmV0dXJuIChzeW1Ub1N0cmluZ1RhZyAmJiBzeW1Ub1N0cmluZ1RhZyBpbiBPYmplY3QodmFsdWUpKVxuICAgID8gZ2V0UmF3VGFnKHZhbHVlKVxuICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzT2JqZWN0TGlrZTtcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0TGlrZSBmcm9tICcuL2lzT2JqZWN0TGlrZS5qcyc7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN5bWJvbCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3ltYm9sKFN5bWJvbC5pdGVyYXRvcik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1N5bWJvbCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N5bWJvbCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzeW1ib2wnIHx8XG4gICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaXNTeW1ib2w7XG4iLCJpbXBvcnQgYmFzZVRyaW0gZnJvbSAnLi9fYmFzZVRyaW0uanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuaW1wb3J0IGlzU3ltYm9sIGZyb20gJy4vaXNTeW1ib2wuanMnO1xuXG4vKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBOQU4gPSAwIC8gMDtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGJhZCBzaWduZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiaW5hcnkgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzQmluYXJ5ID0gL14wYlswMV0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb2N0YWwgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUlzT2N0YWwgPSAvXjBvWzAtN10rJC9pO1xuXG4vKiogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgd2l0aG91dCBhIGRlcGVuZGVuY3kgb24gYHJvb3RgLiAqL1xudmFyIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBudW1iZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb2Nlc3MuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9OdW1iZXIoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9OdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvTnVtYmVyKEluZmluaXR5KTtcbiAqIC8vID0+IEluZmluaXR5XG4gKlxuICogXy50b051bWJlcignMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgcmV0dXJuIE5BTjtcbiAgfVxuICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgdmFyIG90aGVyID0gdHlwZW9mIHZhbHVlLnZhbHVlT2YgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLnZhbHVlT2YoKSA6IHZhbHVlO1xuICAgIHZhbHVlID0gaXNPYmplY3Qob3RoZXIpID8gKG90aGVyICsgJycpIDogb3RoZXI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogK3ZhbHVlO1xuICB9XG4gIHZhbHVlID0gYmFzZVRyaW0odmFsdWUpO1xuICB2YXIgaXNCaW5hcnkgPSByZUlzQmluYXJ5LnRlc3QodmFsdWUpO1xuICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICA/IGZyZWVQYXJzZUludCh2YWx1ZS5zbGljZSgyKSwgaXNCaW5hcnkgPyAyIDogOClcbiAgICA6IChyZUlzQmFkSGV4LnRlc3QodmFsdWUpID8gTkFOIDogK3ZhbHVlKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdG9OdW1iZXI7XG4iLCJpbXBvcnQgaXNPYmplY3QgZnJvbSAnLi9pc09iamVjdC5qcyc7XG5pbXBvcnQgbm93IGZyb20gJy4vbm93LmpzJztcbmltcG9ydCB0b051bWJlciBmcm9tICcuL3RvTnVtYmVyLmpzJztcblxuLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4LFxuICAgIG5hdGl2ZU1pbiA9IE1hdGgubWluO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBkZWJvdW5jZWQgZnVuY3Rpb24gdGhhdCBkZWxheXMgaW52b2tpbmcgYGZ1bmNgIHVudGlsIGFmdGVyIGB3YWl0YFxuICogbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gd2FzXG4gKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gKiBkZWxheWVkIGBmdW5jYCBpbnZvY2F0aW9ucyBhbmQgYSBgZmx1c2hgIG1ldGhvZCB0byBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS5cbiAqIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZVxuICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICogd2l0aCB0aGUgbGFzdCBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbi4gU3Vic2VxdWVudFxuICogY2FsbHMgdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2BcbiAqIGludm9jYXRpb24uXG4gKlxuICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAqIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dC5cbiAqXG4gKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAqIHVudGlsIHRvIHRoZSBuZXh0IHRpY2ssIHNpbWlsYXIgdG8gYHNldFRpbWVvdXRgIHdpdGggYSB0aW1lb3V0IG9mIGAwYC5cbiAqXG4gKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAqIGZvciBkZXRhaWxzIG92ZXIgdGhlIGRpZmZlcmVuY2VzIGJldHdlZW4gYF8uZGVib3VuY2VgIGFuZCBgXy50aHJvdHRsZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byBkZWxheS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5sZWFkaW5nPWZhbHNlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIGxlYWRpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICogIFRoZSBtYXhpbXVtIHRpbWUgYGZ1bmNgIGlzIGFsbG93ZWQgdG8gYmUgZGVsYXllZCBiZWZvcmUgaXQncyBpbnZva2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy50cmFpbGluZz10cnVlXVxuICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBkZWJvdW5jZWQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIC8vIEF2b2lkIGNvc3RseSBjYWxjdWxhdGlvbnMgd2hpbGUgdGhlIHdpbmRvdyBzaXplIGlzIGluIGZsdXguXG4gKiBqUXVlcnkod2luZG93KS5vbigncmVzaXplJywgXy5kZWJvdW5jZShjYWxjdWxhdGVMYXlvdXQsIDE1MCkpO1xuICpcbiAqIC8vIEludm9rZSBgc2VuZE1haWxgIHdoZW4gY2xpY2tlZCwgZGVib3VuY2luZyBzdWJzZXF1ZW50IGNhbGxzLlxuICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uZGVib3VuY2Uoc2VuZE1haWwsIDMwMCwge1xuICogICAnbGVhZGluZyc6IHRydWUsXG4gKiAgICd0cmFpbGluZyc6IGZhbHNlXG4gKiB9KSk7XG4gKlxuICogLy8gRW5zdXJlIGBiYXRjaExvZ2AgaXMgaW52b2tlZCBvbmNlIGFmdGVyIDEgc2Vjb25kIG9mIGRlYm91bmNlZCBjYWxscy5cbiAqIHZhciBkZWJvdW5jZWQgPSBfLmRlYm91bmNlKGJhdGNoTG9nLCAyNTAsIHsgJ21heFdhaXQnOiAxMDAwIH0pO1xuICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICogalF1ZXJ5KHNvdXJjZSkub24oJ21lc3NhZ2UnLCBkZWJvdW5jZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCBkZWJvdW5jZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGFzdEFyZ3MsXG4gICAgICBsYXN0VGhpcyxcbiAgICAgIG1heFdhaXQsXG4gICAgICByZXN1bHQsXG4gICAgICB0aW1lcklkLFxuICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgbGFzdEludm9rZVRpbWUgPSAwLFxuICAgICAgbGVhZGluZyA9IGZhbHNlLFxuICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgd2FpdCA9IHRvTnVtYmVyKHdhaXQpIHx8IDA7XG4gIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgIGxlYWRpbmcgPSAhIW9wdGlvbnMubGVhZGluZztcbiAgICBtYXhpbmcgPSAnbWF4V2FpdCcgaW4gb3B0aW9ucztcbiAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICB2YXIgYXJncyA9IGxhc3RBcmdzLFxuICAgICAgICB0aGlzQXJnID0gbGFzdFRoaXM7XG5cbiAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgIGxhc3RJbnZva2VUaW1lID0gdGltZTtcbiAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBmdW5jdGlvbiBsZWFkaW5nRWRnZSh0aW1lKSB7XG4gICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgLy8gU3RhcnQgdGhlIHRpbWVyIGZvciB0aGUgdHJhaWxpbmcgZWRnZS5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgIC8vIEludm9rZSB0aGUgbGVhZGluZyBlZGdlLlxuICAgIHJldHVybiBsZWFkaW5nID8gaW52b2tlRnVuYyh0aW1lKSA6IHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbWFpbmluZ1dhaXQodGltZSkge1xuICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgIHRpbWVXYWl0aW5nID0gd2FpdCAtIHRpbWVTaW5jZUxhc3RDYWxsO1xuXG4gICAgcmV0dXJuIG1heGluZ1xuICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgOiB0aW1lV2FpdGluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgdGltZVNpbmNlTGFzdEludm9rZSA9IHRpbWUgLSBsYXN0SW52b2tlVGltZTtcblxuICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgLy8gdHJhaWxpbmcgZWRnZSwgdGhlIHN5c3RlbSB0aW1lIGhhcyBnb25lIGJhY2t3YXJkcyBhbmQgd2UncmUgdHJlYXRpbmdcbiAgICAvLyBpdCBhcyB0aGUgdHJhaWxpbmcgZWRnZSwgb3Igd2UndmUgaGl0IHRoZSBgbWF4V2FpdGAgbGltaXQuXG4gICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICh0aW1lU2luY2VMYXN0Q2FsbCA8IDApIHx8IChtYXhpbmcgJiYgdGltZVNpbmNlTGFzdEludm9rZSA+PSBtYXhXYWl0KSk7XG4gIH1cblxuICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgdmFyIHRpbWUgPSBub3coKTtcbiAgICBpZiAoc2hvdWxkSW52b2tlKHRpbWUpKSB7XG4gICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgIH1cbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lci5cbiAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdHJhaWxpbmdFZGdlKHRpbWUpIHtcbiAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gT25seSBpbnZva2UgaWYgd2UgaGF2ZSBgbGFzdEFyZ3NgIHdoaWNoIG1lYW5zIGBmdW5jYCBoYXMgYmVlblxuICAgIC8vIGRlYm91bmNlZCBhdCBsZWFzdCBvbmNlLlxuICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgcmV0dXJuIGludm9rZUZ1bmModGltZSk7XG4gICAgfVxuICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICBpZiAodGltZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgfVxuICAgIGxhc3RJbnZva2VUaW1lID0gMDtcbiAgICBsYXN0QXJncyA9IGxhc3RDYWxsVGltZSA9IGxhc3RUaGlzID0gdGltZXJJZCA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZsdXNoKCkge1xuICAgIHJldHVybiB0aW1lcklkID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiB0cmFpbGluZ0VkZ2Uobm93KCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2VkKCkge1xuICAgIHZhciB0aW1lID0gbm93KCksXG4gICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICBsYXN0QXJncyA9IGFyZ3VtZW50cztcbiAgICBsYXN0VGhpcyA9IHRoaXM7XG4gICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgIGlmIChpc0ludm9raW5nKSB7XG4gICAgICBpZiAodGltZXJJZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgfVxuICAgICAgaWYgKG1heGluZykge1xuICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICBjbGVhclRpbWVvdXQodGltZXJJZCk7XG4gICAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRpbWVySWQgPSBzZXRUaW1lb3V0KHRpbWVyRXhwaXJlZCwgd2FpdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVib3VuY2VkLmNhbmNlbCA9IGNhbmNlbDtcbiAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlYm91bmNlO1xuIiwiaW1wb3J0IGRlYm91bmNlIGZyb20gJy4vZGVib3VuY2UuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSB0aHJvdHRsZWQgZnVuY3Rpb24gdGhhdCBvbmx5IGludm9rZXMgYGZ1bmNgIGF0IG1vc3Qgb25jZSBwZXJcbiAqIGV2ZXJ5IGB3YWl0YCBtaWxsaXNlY29uZHMuIFRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gY29tZXMgd2l0aCBhIGBjYW5jZWxgXG4gKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gKiBpbW1lZGlhdGVseSBpbnZva2UgdGhlbS4gUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2BcbiAqIHNob3VsZCBiZSBpbnZva2VkIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSBgd2FpdGBcbiAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAqIHRocm90dGxlZCBmdW5jdGlvbi4gU3Vic2VxdWVudCBjYWxscyB0byB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHJldHVybiB0aGVcbiAqIHJlc3VsdCBvZiB0aGUgbGFzdCBgZnVuY2AgaW52b2NhdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gKiBpbnZva2VkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRocm90dGxlZCBmdW5jdGlvblxuICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICpcbiAqIElmIGB3YWl0YCBpcyBgMGAgYW5kIGBsZWFkaW5nYCBpcyBgZmFsc2VgLCBgZnVuY2AgaW52b2NhdGlvbiBpcyBkZWZlcnJlZFxuICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICpcbiAqIFNlZSBbRGF2aWQgQ29yYmFjaG8ncyBhcnRpY2xlXShodHRwczovL2Nzcy10cmlja3MuY29tL2RlYm91bmNpbmctdGhyb3R0bGluZy1leHBsYWluZWQtZXhhbXBsZXMvKVxuICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGludm9jYXRpb25zIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBUaGUgb3B0aW9ucyBvYmplY3QuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAqICBTcGVjaWZ5IGludm9raW5nIG9uIHRoZSBsZWFkaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogLy8gQXZvaWQgZXhjZXNzaXZlbHkgdXBkYXRpbmcgdGhlIHBvc2l0aW9uIHdoaWxlIHNjcm9sbGluZy5cbiAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCBfLnRocm90dGxlKHVwZGF0ZVBvc2l0aW9uLCAxMDApKTtcbiAqXG4gKiAvLyBJbnZva2UgYHJlbmV3VG9rZW5gIHdoZW4gdGhlIGNsaWNrIGV2ZW50IGlzIGZpcmVkLCBidXQgbm90IG1vcmUgdGhhbiBvbmNlIGV2ZXJ5IDUgbWludXRlcy5cbiAqIHZhciB0aHJvdHRsZWQgPSBfLnRocm90dGxlKHJlbmV3VG9rZW4sIDMwMDAwMCwgeyAndHJhaWxpbmcnOiBmYWxzZSB9KTtcbiAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICpcbiAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgdGhyb3R0bGVkIGludm9jYXRpb24uXG4gKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAqL1xuZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICB0cmFpbGluZyA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgaWYgKGlzT2JqZWN0KG9wdGlvbnMpKSB7XG4gICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgIHRyYWlsaW5nID0gJ3RyYWlsaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLnRyYWlsaW5nIDogdHJhaWxpbmc7XG4gIH1cbiAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAnbGVhZGluZyc6IGxlYWRpbmcsXG4gICAgJ21heFdhaXQnOiB3YWl0LFxuICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gIH0pO1xufVxuXG5leHBvcnQgZGVmYXVsdCB0aHJvdHRsZTtcbiIsIlxuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSBhcyB1c2VTdGF0ZVAgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5cbi8qKlxuICogU2xpZ2h0bHkgZW5oYW5jZWQgdmVyc2lvbiBvZiBgdXNlU3RhdGVgIHRoYXQgaW5jbHVkZXMgYSBnZXR0ZXIgdGhhdCByZW1haW5zIGNvbnN0YW50XG4gKiAoaS5lLiB5b3UgY2FuIHVzZSBpdCBpbiBgdXNlRWZmZWN0YCBhbmQgZnJpZW5kcyB3aXRob3V0IGl0IGJlaW5nIGEgZGVwZW5kZW5jeSkuXG4gKiBcbiAqIEBwYXJhbSBpbml0aWFsU3RhdGUgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVN0YXRlPFQ+KGluaXRpYWxTdGF0ZTogVCB8ICgoKSA9PiBUKSk6IHJlYWRvbmx5IFt2YWx1ZTogVCwgc2V0VmFsdWU6IFN0YXRlVXBkYXRlcjxUPiwgZ2V0VmFsdWU6ICgpID0+IFRdIHtcblxuICAgIC8vIFdlIGtlZXAgYm90aCwgYnV0IG92ZXJycmlkZSB0aGUgYHNldFN0YXRlYCBmdW5jdGlvbmFsaXR5XG4gICAgY29uc3QgW3N0YXRlLCBzZXRTdGF0ZVBdID0gdXNlU3RhdGVQKGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKHN0YXRlKTtcblxuICAgIC8vIEhpamFjayB0aGUgbm9ybWFsIHNldHRlciBmdW5jdGlvbiBcbiAgICAvLyB0byBhbHNvIHNldCBvdXIgcmVmIHRvIHRoZSBuZXcgdmFsdWVcbiAgICBjb25zdCBzZXRTdGF0ZSA9IHVzZUNhbGxiYWNrPFN0YXRlVXBkYXRlcjxUPj4odmFsdWUgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdmFsdWUgYXMgKChfcHJldlZhbHVlOiBUKSA9PiBUKTtcbiAgICAgICAgICAgIHNldFN0YXRlUChwcmV2VmFsdWUgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRWYWx1ZSA9IGNhbGxiYWNrKHByZXZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSBuZXh0VmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHRWYWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVmLmN1cnJlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIHNldFN0YXRlUCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG5cbiAgICBjb25zdCBnZXRTdGF0ZSA9ICgpID0+IHsgcmV0dXJuIHJlZi5jdXJyZW50OyB9O1xuXG5cbiAgICBjb25zb2xlLmFzc2VydChyZWYuY3VycmVudCA9PT0gc3RhdGUgfHwgKHR5cGVvZiBzdGF0ZSA9PT0gXCJudW1iZXJcIiAmJiBpc05hTihzdGF0ZSkpKTtcbiAgICByZXR1cm4gW3N0YXRlLCBzZXRTdGF0ZSwgZ2V0U3RhdGVdIGFzIGNvbnN0O1xufSIsIlxuaW1wb3J0IGRlYm91bmNlLCB7IERlYm91bmNlZEZ1bmMsIHR5cGUgRGVib3VuY2VTZXR0aW5ncyB9IGZyb20gXCJsb2Rhc2gtZXMvZGVib3VuY2VcIjtcbmltcG9ydCB0aHJvdHRsZSwgeyB0eXBlIFRocm90dGxlU2V0dGluZ3MgfSBmcm9tIFwibG9kYXNoLWVzL3Rocm90dGxlXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZU1lbW8gfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyByZXR1cm5OdWxsLCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG50eXBlIEZ1bmMgPSAoLi4uYXJnczogYW55KSA9PiBQcm9taXNlPHVua25vd24+IHwgdW5rbm93bjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY1BhcmFtZXRlcnM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+IHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWRkcyBhIGRlYm91bmNlIGJlaGF2aW9yICppbiBhZGRpdGlvbiogdG9cbiAgICAgKiB0aGUgZGVmYXVsdCBcIndhaXQgdW50aWwgcmVzb2x2ZWRcIiB0aHJvdHRsaW5nIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIGRlYm91bmNlPzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQnkgZGVmYXVsdCwgYHVzZUFzeW5jYCB3aXRoIGF1dG8tdGhyb3R0bGUgYmFzZWQgb24gaG93IGxvbmcgaXQgdGFrZXNcbiAgICAgKiBmb3IgdGhlIG9wZXJhdGlvbiB0byBjb21wbGV0ZS4gIElmIHlvdSB3b3VsZCBsaWtlIHRoZXJlIHRvIGJlIGFcbiAgICAgKiBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRvIHdhaXQgYmVmb3JlIGFsbG93aW5nIGEgc2Vjb25kIG9wZXJhdGlvbixcbiAgICAgKiB0aGUgYHRocm90dGxlYCBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gYWRkaXRpb24gdG8gdGhhdCBiZWhhdmlvci5cbiAgICAgKi9cbiAgICB0aHJvdHRsZT86IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gYW4gYXN5bmMgZnVuY3Rpb24gaXMgZGVib3VuY2VkIGR1ZSB0byBvbmUgYWxyZWFkeSBydW5uaW5nLFxuICAgICAqIGl0IHdpbGwgcnVuIG9uIGEgZGVsYXkgYW5kLCBhcyBhIHJlc3VsdCwgdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuICAgICAqIHRoYXQgd2VyZSBwYXNzZWQgdG8gaXQgbWF5IG5lZWQgdG8gYmUgYWRqdXN0ZWQgdG8gYWNjb3VudCBmb3IgdGhhdC5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgZHVyaW5nIGBvbklucHV0YCwgdGhlIGB2YWx1ZWAgb2YgdGhhdCBldmVudCBpc24ndCBzdG9yZWRcbiAgICAgKiBpbiB0aGUgZXZlbnQgaXRzZWxmLCBpdCdzIHN0b3JlZCBpbiB0aGUgYEhUTUxJbnB1dEVsZW1lbnRgIHRoYXQgcmFpc2VkIGl0LlxuICAgICAqIFNvIHdoZW4gb3VyIGhhbmRsZXIgYWN0dWFsbHkgcnVucyBhIGZldyBzZWNvbmRzIGxhdGVyLCBpdCdsbCByZWFkIHRoZSAqKm5leHQqKlxuICAgICAqIGBldmVudC5jdXJyZW50VGFyZ2V0LnZhbHVlYCwgaW5zdGVhZCBvZiB0aGUgb25lIGZyb20gYSBmZXcgc2Vjb25kcyBhZ28gXG4gICAgICogdGhhdCBhY3R1YWxseSByYWlzZWQgdGhlIGV2ZW50IVxuICAgICAqIFxuICAgICAqIElmIHRoZSBhcmd1bWVudHMgdG8geW91ciBoYW5kbGVyIHJlcXVpcmUgcmVmZXJlbmNpbmcgZGF0YSBpbiB0aGUgYXJndW1lbnRzXG4gICAgICogdGhhdCBtYXkgYmVjb21lIFwic3RhbGVcIiBieSB0aGUgdGltZSB0aGUgZnVuY3Rpb24gYWN0dWFsbHkgcnVucyAoZ2VuZXJhbGx5IGV2ZW50XG4gICAgICogaGFuZGxlcnMgYW5kIG90aGVyIHRoaW5ncyB0aGF0IHJlZmVyZW5jZSB0aGUgcHJvcGVydGllcyBvZiBleGlzdGluZyBvYmplY3RzKSxcbiAgICAgKiB0aGUgYGNhcHR1cmVgIHBhcmFtZXRlciBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSB0aGUgcGFyYW1ldGVycyB5b3Ugd2VyZSBnaXZlblxuICAgICAqIHdoZW4gdGhlIHJlcXVlc3QgdG8gcnVuIHdhcyBpbml0aWFsbHkgbWFkZSBpbnRvIHBhcmFtZXRlcnMgdGhhdCB5b3UgaGF2ZVxuICAgICAqIGd1YXJhbnRlZWQgd2lsbCBzdGlsbCBiZSBnb29kIGJ5IHRoZSB0aW1lIHRoZSBoYW5kbGVyIGFjdHVhbGx5IHJ1bnMuXG4gICAgICovXG4gICAgY2FwdHVyZT86IENhcHR1cmVGdW5jdGlvblR5cGU8QVAsIFNQPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY1JldHVyblR5cGU8U1AgZXh0ZW5kcyB1bmtub3duW10sIFI+IHtcblxuICAgIC8vcHJvbWlzZTogUHJvbWlzZTxBd2FpdGVkPFJldHVyblR5cGU8Rj4+PiB8IG51bGw7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGEgaGFuZGxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nLCB0aGlzIGlzIHRydWUuXG4gICAgICogXG4gICAgICogSXQgaXMgZmFsc2UgYmVmb3JlIHRoZSBmaXJzdCBleGVjdXRpb24sIHRydWUgZHVyaW5nIHRoZVxuICAgICAqIGZpcnN0IGV4ZWN1dGlvbiwgcmVtYWlucyB0cnVlIGlmIGNvbnRpbnVpbmcgaW1tZWRpYXRlbHlcbiAgICAgKiBpbnRvIGEgc2Vjb25kLCBhbmQgb25seSByZXR1cm5zIHRvIGZhbHNlIHdoZW4gYSBoYW5kbGVyXG4gICAgICogY29tcGxldGVzIHdpdGggbm8gaGFuZGxlciBpbiB3YWl0aW5nLlxuICAgICAqL1xuICAgIHBlbmRpbmc6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBoYW5kbGVyIGhhcyBydW4uXG4gICAgICogRG9lcyBub3QgaW5jbHVkZSB0aW1lcyB3aGVyZSBpdCB3YXMgdGhyb3R0bGVkIG9yIGRlYm91bmNlZCBhd2F5LlxuICAgICAqIFxuICAgICAqIFVzZWZ1bCBmb3Iga25vd2luZyBpZiB0aGUgaGFuZGxlciBoYXMgYmVlbiBjYWxsZWQgeWV0LCBvciBmb3JcbiAgICAgKiBzZXR0aW5nIGEgbmV3IHRpbWVvdXQgdG8gc2hvdyBhIHNwaW5uZXIuXG4gICAgICovXG4gICAgY2FsbENvdW50OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBoYW5kbGVyIGhhcyBzZXR0bGVkXG4gICAgICogKHJlc29sdmVkIG9yIHJlamVjdGVkKSwgc2ltaWxhcmx5IHRvIGBjYWxsQ291bnRgLlxuICAgICAqIFxuICAgICAqIFVzZWZ1bCBmb3Iga25vd2luZyBpZiB0aGUgaGFuZGxlciBoYXMgY29tcGxldGVkIGV2ZW4gb25jZSB5ZXQsXG4gICAgICogb3IganVzdCBmb3Igd2hlbiB0aGUgaGFuZGxlciBoYXMgZmluaXNoZWRcbiAgICAgKi9cbiAgICBzZXR0bGVDb3VudDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG51bWJlciBvZiB0aW1lcyB0aGUgaGFuZGxlciBoYXMgY29tcGxldGVkIHN1Y2Nlc3NmdWxseSwgXG4gICAgICogc2ltaWxhcmx5IHRvIGBzZXR0bGVDb3VudGAuXG4gICAgICovXG4gICAgcmVzb2x2ZUNvdW50OiBudW1iZXI7XG5cblxuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGhhbmRsZXIgaGFzIGZhaWxlZCB0byBjb21wbGV0ZSwgXG4gICAgICogc2ltaWxhcmx5IHRvIGByZXNvbHZlQ291bnRgLlxuICAgICAqL1xuICAgIHJlamVjdENvdW50OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHRoZSB2YWx1ZSBtb3N0IHJlY2VudGx5IHJldHVybmVkIGZyb20gYSBzdWNjZXNzZnVsIGhhbmRsZXIgaW52b2NhdGlvbixcbiAgICAgKiBvciB1bmRlZmluZWQgaWYgbm8gaGFuZGxlciBoYXMgc3VjY2Vzc2Z1bGx5IHJldHVybmVkIHlldC5cbiAgICAgKiBcbiAgICAgKiBJZiB0aGUgaGFuZGxlciByZWplY3RzIGFmdGVyIGhhdmluZyBzdWNjZWVkZWQgcHJldmlvdXNseSwgdGhlblxuICAgICAqIGByZXN1bHRgIHdpbGwgc3RpbGwga2VlcCBpdHMgdmFsdWU7IGl0IHdvbid0IGJlIFwiZXJhc2VkXCIgZHVlIHRvIHRoZSBlcnJvci5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgYHJlc3VsdGAgYW5kIGBlcnJvcmAgY2FuIGJvdGggYmUgcG9wdWxhdGVkIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgICogXG4gICAgICogQHNlZSBoYXNSZXN1bHQgZm9yIGlmIGByZXN1bHRgIGJlaW5nIGB1bmRlZmluZWRgIG1lYW5zIGl0J3MgdW5maW5pc2hlZCBvciB0aGUgZnVuY3Rpb24gaXRzZWxmIHJldHVybmVkIGB1bmRlZmluZWRgLlxuICAgICAqL1xuICAgIHJlc3VsdDogUiB8IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIFRydWUgd2hlbiB0aGUgbW9zdCByZWNlbnRseS1ydW4gaGFuZGxlciBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5LFxuICAgICAqIGFsc28gbWVhbmluZyB0aGF0IHRoYXQgaXQncyByZXR1cm5lZCBhIHZhbHVlIHRoYXQgd2UgY3VycmVudGx5IGhhdmUuXG4gICAgICogXG4gICAgICogV2hpbGUgYHBlbmRpbmdgIGlzIHRydWUsICoqYGhhc1Jlc3VsdGAgYW5kIGBoYXNFcnJvcmAgbWF5IGJlIHNpbXVsdGFuZW91c2x5IHRydWUqKixcbiAgICAgKiBidXQgaW4gYWxsIG90aGVyIGNhc2VzIHRoZXkncmUgbXV0dWFsbHkgZXhjbHVzaXZlLlxuICAgICAqL1xuICAgIGhhc1Jlc3VsdDogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciB0aGUgaGFuZGxlciB0aHJldy4gYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLCB0aG91Z2ggbm90ZVxuICAgICAqIHRoYXQgYHVuZGVmaW5lZGAgaXMgYSB2YWxpZCB0aGluZyB0byB0aHJvdywgc28gY2hlY2sgYGhhc0Vycm9yYCB0b28uXG4gICAgICogXG4gICAgICogQHNlZSBoYXNFcnJvclxuICAgICAqL1xuICAgIGVycm9yOiB1bmtub3duO1xuXG4gICAgLyoqXG4gICAgICogV2hldGhlciBvciBub3QgdGhlIG1vc3QgcmVjZW50IGhhbmRsZXIgZmluaXNoZWQgd2l0aCBhbiBlcnJvci5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlLCB0ZWNobmljYWxseSwgYGVycm9yYCBjYW4gYmUgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgaGFzRXJyb3I6IGJvb2xlYW47XG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3Ugd291bGQgbGlrZSBhbnkgY3VycmVudGx5IGRlYm91bmNlZC1idXQtZXZlbnR1YWxseS1wZW5kaW5nIHByb21pc2VzIHRvIGltbWVkaWF0ZWx5IGJlIGNvbnNpZGVyZWQgYnkgY2FuY2VsbGluZyB0aGVpciBkZWJvdW5jZSB0aW1lb3V0LFxuICAgICAqIHlvdSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uLiAgTm9ybWFsIHByb2NlZHVyZSBhcHBsaWVzIGFzIGlmIHRoZSBkZWJvdW5jZWQgZW5kZWQgbm9ybWFsbHkgLS0gaWYgdGhlcmUncyBubyBwcm9taXNlIHdhaXRpbmcgaW4gdGhlIHF1ZXVlLFxuICAgICAqIHRoZSBkZWJvdW5jZWQgcHJvbWlzZSBydW5zIG5vcm1hbGx5LCBvdGhlcndpc2UsIGl0IHdhaXRzIGl0cyB0dXJuIHVudGlsIHRoZSBjdXJyZW50IG9uZSBlbmRzLCBwb3RlbnRpYWxseSBiZWluZyBvdmVyd3JpdHRlbiBsYXRlciBvblxuICAgICAqIGlmIGEgbmV3IHByb21pc2UgcnVucyBvdXQgKml0cyogZGVib3VuY2UgdGltZXIgYmVmb3JlIHRoaXMgb25lIGdvdCBhIGNoYW5jZSB0byBydW4uXG4gICAgICogXG4gICAgICogKipRdWFzaS1zdGFibGUqKiAoZG9uJ3QgdXNlIGR1cmluZyByZW5kZXIpXG4gICAgICovXG4gICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlOiAoKSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogQmFzZWQgb24gdGhlIHR5cGUgb2YgaGFuZGxlciBwYXNzZWQgaW4sIHRoaXMgcmV0dXJuZWQgdmFsdWUgd2lsbFxuICAgICAqIHJlcHJlc2VudCB3aGF0IHR5cGUgb2YgaGFuZGxlciBpdCB3YXMsIGp1c3QgaW4gY2FzZSB5b3VcbiAgICAgKiB5b3Vyc2VsZiBuZWVkIHRvIGtub3cgdGhhdCBhbmQgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gdGhlIG9yaWdpbmFsXG4gICAgICogdG8gZmluZCBvdXQgd2l0aG91dCBpdCBhY3R1YWxseSBiZWluZyBydW4uXG4gICAgICogXG4gICAgICogVW50aWwgYSBoYW5kbGVyIGlzIGNhbGxlZCwgdGhpcyB3aWxsIGJlIG51bGwuICBOYXR1cmFsbHksIGlmIFxuICAgICAqIGRpZmZlcmVudCBoYW5kbGVycyBhcmUgcGFzc2VkIGluLCBpdCBjYW4gZmxpcCBiYWNrIGFuZFxuICAgICAqIGZvcnRoIGJldHdlZW4gXCJhc3luY1wiIGFuZCBcInN5bmNcIiBhcyB3ZWxsLlxuICAgICAqL1xuICAgIGN1cnJlbnRUeXBlOiBudWxsIHwgXCJzeW5jXCIgfCBcImFzeW5jXCI7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiB0aGUgYXN5bmMgaGFuZGxlciBwcm92aWRlZCxcbiAgICAgKiBub3cgc3luY2hyb25vdXMgYW5kL29yIHRocm90dGxlZCBhbmQvb3IgZGVib3VuY2VkXG4gICAgICogXG4gICAgICogKipRdWFzaS1zdGFibGUqKiAoZG9uJ3QgdXNlIGR1cmluZyByZW5kZXIpXG4gICAgICovXG4gICAgc3luY0hhbmRsZXI6IFN5bmNGdW5jdGlvblR5cGU8U1AsIFI+O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eTxBUCBleHRlbmRzIHVua25vd25bXSwgU1AgZXh0ZW5kcyB1bmtub3duW10+KC4uLnQ6IFNQKSB7IHJldHVybiB0IGFzIHVua25vd25bXSBhcyBBUDsgfVxuXG4vKipcbiAqIFJldHVybnMgYSB0aHJvdHRsZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gKHN0YWJsZSkgY2FsbGJhY2sgdXNpbmcgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbi5cbiAqIFxuICogSWYgdGhlIGNhbGxiYWNrIGlzIGBudWxsYCwgdGhlbiBgbnVsbGAgd2lsbCBiZSByZXR1cm5lZCwgb3RoZXJ3aXNlIGBjYWxsYmFja2AgbXVzdCBiZSBzdGFibGUgZm9yIHRoaXMgdG8gd29yayBhcyBpbnRlbnRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPjtcbmV4cG9ydCBmdW5jdGlvbiB1c2VUaHJvdHRsZWQ8RiBleHRlbmRzIEZ1bmM+KGNhbGxiYWNrOiBGIHwgbnVsbCwgd2FpdDogbnVtYmVyLCBvcHRpb25zPzogVGhyb3R0bGVTZXR0aW5ncyk6IERlYm91bmNlZEZ1bmM8Rj4gfCBudWxsO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVRocm90dGxlZDxGIGV4dGVuZHMgRnVuYz4oY2FsbGJhY2s6IEYgfCBudWxsLCB3YWl0OiBudW1iZXIsIG9wdGlvbnM/OiBUaHJvdHRsZVNldHRpbmdzKTogRGVib3VuY2VkRnVuYzxGPiB8IG51bGwge1xuICAgIGNvbnN0IHRocm90dGxlZCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgPyB0aHJvdHRsZShjYWxsYmFjaywgd2FpdCwgb3B0aW9ucykgOiBudWxsO1xuICAgIH0sIFtjYWxsYmFjaywgd2FpdCwgb3B0aW9ucz8ubGVhZGluZywgb3B0aW9ucz8udHJhaWxpbmddKTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB0aHJvdHRsZWQ/LmNhbmNlbCgpO1xuICAgIH0sIFt0aHJvdHRsZWRdKVxuXG4gICAgcmV0dXJuIHRocm90dGxlZDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgdGhlIGdpdmVuIChzdGFibGUpIGNhbGxiYWNrIHVzaW5nIExvZGFzaCdzIGBkZWJvdW5jZWRgIGZ1bmN0aW9uLlxuICogXG4gKiBJZiB0aGUgY2FsbGJhY2sgaXMgYG51bGxgLCB0aGVuIGBudWxsYCB3aWxsIGJlIHJldHVybmVkLCBvdGhlcndpc2UgYGNhbGxiYWNrYCBtdXN0IGJlIHN0YWJsZSBmb3IgdGhpcyB0byB3b3JrIGFzIGludGVudGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiwgd2FpdDogbnVtYmVyLCBvcHRpb25zPzogRGVib3VuY2VTZXR0aW5ncyk6IERlYm91bmNlZEZ1bmM8Rj47XG5leHBvcnQgZnVuY3Rpb24gdXNlRGVib3VuY2VkPEYgZXh0ZW5kcyBGdW5jPihjYWxsYmFjazogRiB8IG51bGwsIHdhaXQ6IG51bWJlciwgb3B0aW9ucz86IERlYm91bmNlU2V0dGluZ3MpOiBEZWJvdW5jZWRGdW5jPEY+IHwgbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiB1c2VEZWJvdW5jZWQ8RiBleHRlbmRzIEZ1bmM+KGNhbGxiYWNrOiBGIHwgbnVsbCwgd2FpdDogbnVtYmVyLCBvcHRpb25zPzogRGVib3VuY2VTZXR0aW5ncyk6IERlYm91bmNlZEZ1bmM8Rj4gfCBudWxsIHtcbiAgICBjb25zdCBkZWJvdW5jZWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrID8gZGVib3VuY2UoY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnMpIDogbnVsbDtcbiAgICB9LCBbY2FsbGJhY2ssIHdhaXQsIG9wdGlvbnM/LmxlYWRpbmcsIG9wdGlvbnM/Lm1heFdhaXQsIG9wdGlvbnM/LnRyYWlsaW5nXSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4gZGVib3VuY2VkPy5jYW5jZWwoKTtcbiAgICB9LCBbZGVib3VuY2VkXSlcblxuICAgIHJldHVybiBkZWJvdW5jZWQ7XG59XG5cbnR5cGUgU3luY0Z1bmN0aW9uVHlwZTxTUCBleHRlbmRzIHVua25vd25bXSwgUj4gPSAoLi4uYXJnczogU1ApID0+IChSIHwgdW5kZWZpbmVkKTtcbnR5cGUgQXN5bmNGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKCguLi5hcmdzOiBBUCkgPT4gKFIgfCBQcm9taXNlPFI+KSk7XG50eXBlIEdsdWVGdW5jdGlvblR5cGU8QVAgZXh0ZW5kcyB1bmtub3duW10sIFI+ID0gKGVucXVldWU6IGJvb2xlYW4sIC4uLmFyZ3M6IEFQKSA9PiBSIHwgdW5kZWZpbmVkO1xudHlwZSBDYXB0dXJlRnVuY3Rpb25UeXBlPEFQIGV4dGVuZHMgdW5rbm93bltdLCBTUCBleHRlbmRzIHVua25vd25bXSA9IEFQPiA9ICguLi5hcmdzOiBTUCkgPT4gQVA7XG5cbi8qKlxuICogR2l2ZW4gYW4gYXN5bmMgZnVuY3Rpb24sIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0J3Mgc3VpdGFibGUgZm9yIG5vbi1hc3luYyBBUElzLCBcbiAqIGFsb25nIHdpdGggb3RoZXIgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgcnVuJ3Mgc3RhdHVzLlxuICogXG4gKiBTZWUgYWxzbyBgdXNlQXN5bmNIYW5kbGVyYCBmb3IgYSB2ZXJzaW9uIHRoYXQncyBzcGVjaWFsaXplZCBmb3IgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICogXG4gKiBXaGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBpbiBxdWljayBzdWNjZXNzaW9uLCAoaS5lLiBiZWZvcmUgdGhlIGhhbmRsZXIgaGFzIGZpbmlzaGVkKSwgXG4gKiB0aGlzIHdvcmtzIGxpa2UgTG9kYXNoJ3MgYHRocm90dGxlYCBmdW5jdGlvbiB3aXRoIHRoZSBgd2FpdGAgb3B0aW9uIGFsd2F5c1xuICogc2V0IHRvIGhvd2V2ZXIgbG9uZyB0aGUgaGFuZGxlciB0YWtlcyB0byBjb21wbGV0ZS4gQSBzZWNvbmQgY2FsbCB0byB0aGUgc3luYyBmdW5jdGlvbiB3aWxsIGJlIFxuICogdGhyb3R0bGVkIHVudGlsIHRoZSBmaXJzdCBjYWxsIGhhcyBmaW5pc2hlZC4gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gaXMgdGhlIHJlc3VsdCBcbiAqIG9mIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uLCBvciBgdW5kZWZpbmVkYCBvbiB0aGUgZmlyc3QgY2FsbC5cbiAqIFxuICogVGhlIGhhbmRsZXIgaXMgb25seSBldmVyIGRlbGF5ZWQgaWYgb25lIGlzIGN1cnJlbnRseSBydW5uaW5nLCBzbywgZS5nLiBmb3IgaU9TIHRvdWNoIGV2ZW50cyB0aGVcbiAqIGZpcnN0IGNhbGwgaGFwcGVucyBpbiB0aGUgc2FtZSBldmVudCBoYW5kbGVyICh3aGljaCBtZWFucyB0aGluZ3MgbGlrZSBjYWxscyB0byBgZWxlbWVudC5mb2N1cygpYFxuICogd2lsbCB3b3JrIGFzIGludGVuZGVkLCBzaW5jZSB0aGF0IGZhaWxzIHdoZW4gdGhlIGV2ZW50IGlzIFwic3BsaXQgdXBcIilcbiAqIFxuICogRmluYWxseSwgYmVjYXVzZSB0aGUgc3luYyBoYW5kbGVyIG1heSBiZSBpbnZva2VkIG9uIGEgZGVsYXksIGFueSBwcm9wZXJ0eSByZWZlcmVuY2VzIG9uIHRoZSBhcmd1bWVudHNcbiAqIHByb3ZpZGVkIG1pZ2h0IGJlIHN0YWxlIGJ5IHRoZSB0aW1lIGl0J3MgYWN0dWFsbHkgaW52b2tlZCAoZS5nLiBhY2Nlc3NpbmcgYGV2ZW50LmN1cnJlbnRUYXJnZXQuY2hlY2tlZGBcbiAqIGlzIG5vdCBzdGFibGUgYWNyb3NzIHRpbWUgYmVjYXVzZSBpdCdzIGEgXCJsaXZlXCIgdmFsdWUgLS0geW91IGFsbW9zdCBhbHdheXMgd2FudCB0aGUgdmFsdWUgdGhhdCBpdFxuICogaGFkIGF0IHRoZSBvcmlnaW5hbCB0aW1lIHRoZSBoYW5kbGVyIHdhcyBjYWxsZWQpLiBUaGUgYGNhcHR1cmVgIG9wdGlvbiBhbGxvd3MgeW91IHRvIHNhdmUgdGhhdCBraW5kIG9mXG4gKiBkeW5hbWljIGRhdGEgYXQgdGhlIHRpbWUgaXQgcnVuczsgdGhlIGBBUGAgYW5kIGBTUGAgdHlwZSBwYXJhbWV0ZXJzIGxpa2V3aXNlIGNvbnRyb2xcbiAqIHRoZSBwYXJhbWV0ZXJzIHRoZSBhc3luYyBoYW5kbGVyIGFuZCBzeW5jIGhhbmRsZXIgZXhwZWN0IHJlc3BlY3RpdmVseS5cbiAqIFxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmM8QVAgZXh0ZW5kcyB1bmtub3duW10sIFIsIFNQIGV4dGVuZHMgdW5rbm93bltdID0gQVA+KGFzeW5jSGFuZGxlcjogQXN5bmNGdW5jdGlvblR5cGU8QVAsIFI+IHwgbnVsbCwgb3B0aW9ucz86IFVzZUFzeW5jUGFyYW1ldGVyczxBUCwgU1A+KTogVXNlQXN5bmNSZXR1cm5UeXBlPFNQLCBSPiB7XG5cblxuICAgIC8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCAqL1xuICAgIGxldCB7IHRocm90dGxlLCBkZWJvdW5jZSwgY2FwdHVyZSB9ID0gKG9wdGlvbnMgPz8ge30pO1xuICAgIGNhcHR1cmUgPz89IGlkZW50aXR5O1xuXG4gICAgLy8gV2Uga2VlcCwgbGlrZSwgYSBsb3Qgb2YgcmVuZGVyLXN0YXRlLCBidXQgaXQgb25seSBldmVyIHRyaWdnZXJzIGEgcmUtcmVuZGVyXG4gICAgLy8gd2hlbiB3ZSBzdGFydC9zdG9wIGFuIGFzeW5jIGFjdGlvbi5cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhpcyBmb3IgdGhlIGNhbGxlcidzIHNha2UgLS0gd2UgZG9uJ3QgcmVhbGx5IGNhcmUuXG4gICAgY29uc3QgW2N1cnJlbnRUeXBlLCBzZXRDdXJyZW50VHlwZV0gPSB1c2VTdGF0ZTxudWxsIHwgXCJzeW5jXCIgfCBcImFzeW5jXCI+KG51bGwpO1xuICAgIGNvbnN0IFtydW5Db3VudCwgc2V0UnVuQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3NldHRsZUNvdW50LCBzZXRTZXR0bGVDb3VudF0gPSB1c2VTdGF0ZSgwKTtcbiAgICBjb25zdCBbcmVzb2x2ZUNvdW50LCBzZXRSZXNvbHZlQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3JlamVjdENvdW50LCBzZXRSZWplY3RDb3VudF0gPSB1c2VTdGF0ZSgwKTtcblxuICAgIC8vIFRoaW5ncyByZWxhdGVkIHRvIGN1cnJlbnQgZXhlY3V0aW9uXG4gICAgLy8gQmVjYXVzZSB3ZSBjYW4gYm90aCByZXR1cm4gYW5kIHRocm93IHVuZGVmaW5lZCwgXG4gICAgLy8gd2UgbmVlZCBzZXBhcmF0ZSBzdGF0ZSB0byB0cmFjayB0aGVpciBleGlzdGFuY2UgdG9vLlxuICAgIGNvbnN0IFtwZW5kaW5nLCBzZXRQZW5kaW5nLCBnZXRQZW5kaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcmVzdWx0LCBzZXRSZXN1bHQsIGdldFJlc3VsdF0gPSB1c2VTdGF0ZTxSPih1bmRlZmluZWQhKTtcbiAgICBjb25zdCBbZXJyb3IsIHNldEVycm9yLCBfZ2V0RXJyb3JdID0gdXNlU3RhdGU8dW5rbm93bj4odW5kZWZpbmVkISk7XG4gICAgY29uc3QgW2hhc0Vycm9yLCBzZXRIYXNFcnJvciwgX2dldEhhc0Vycm9yXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbaGFzUmVzdWx0LCBzZXRIYXNSZXN1bHQsIF9nZXRIYXNSZXN1bHRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gV2UgaW1wbGVtZW50IG91ciBvd24gdGhyb3R0bGluZyBiZWhhdmlvciBpbiByZWdhcmRzIHRvIHdhaXRpbmcgdW50aWwgdGhlIGFzeW5jIGhhbmRsZXIgZmluaXNoZXMuXG4gICAgLy8gVGhlc2UgdHdvIHBhc3NpdmUgc3RhdGUgdmFyaWFibGVzIGtlZXAgdHJhY2sgb2YgdGhhdCwgYXV0b21hdGljYWxseSBxdWV1ZWluZy9kZXF1ZXVpbmcgdGhlIG5leHQgaGFuZGxlci5cbiAgICBjb25zdCBbZ2V0UXVldWVkLCBzZXRRdWV1ZWRdID0gdXNlUGFzc2l2ZVN0YXRlPEFQIHwgbnVsbD4obnVsbCwgcmV0dXJuTnVsbCk7XG5cblxuICAgIC8vIFRoZSBhY3R1YWwgc3luYyBoYW5kbGVyLlxuICAgIC8vIENhcHR1cmUvdHJhbnNmb3JtIHRoZSBnaXZlbiBwYXJhbWV0ZXJzIGlmIGFwcGxpY2FibGUsXG4gICAgLy8gdGhlbiBydW4gZnVydGhlciBsb2dpYyB0aGF0J3MgZGVib3VuY2VkL3Rocm90dGxlZFxuICAgIGNvbnN0IGNhcHR1cmVBcmdzQW5kRXhlY3V0ZURlYm91bmNlZEhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjazxTeW5jRnVuY3Rpb25UeXBlPFNQLCBSPj4oZnVuY3Rpb24gb25OZXdFeGVjdXRlUmVxdWVzdCguLi5uZXdBcmdzMjogU1ApIHtcblxuICAgICAgICAvLyBDYXB0dXJlIHRoZSBhcmd1bWVudHMgd2Ugd2VyZSBnaXZlbi5cbiAgICAgICAgLy8gV2UgbWlnaHQgdXNlIHRoZW0gaW1tZWRpYXRlbHksIG9yIHdlIG1pZ2h0IHN0b3JlIHRoZW0gdG8gYHF1ZXVlZGAsXG4gICAgICAgIC8vIGJ1dCBpbiBlaXRoZXIgY2FzZSB3ZSBkbyBuZWVkIHRoZSBjYXB0dXJlZCB2YWx1ZS5cbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBjYXB0dXJlISguLi5uZXdBcmdzMik7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhbGwgbG9naWMgdGhhdCBkZWFscyB3aXRoIHRoZSBjYXB0dXJlZCB2YWx1ZSBpbnN0ZWFkIG9mIHRoZSByYXcgYXJndW1lbnRzLlxuICAgICAgICAvLyBJdCdzIGNhbGxlZCBpbiB0d28gc2VwYXJhdGUgY2lyY3Vtc3RhbmNlcyxcbiAgICAgICAgLy8gYW5kIGhhcyB0aGUgZGVib3VuY2UvdGhyb3R0bGUgbG9naWMgYWxyZWFkeSBhcHBsaWVkXG4gICAgICAgIHJldHVybiBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZShnZXRQZW5kaW5nKCksIC4uLmNhcHR1cmVkKTtcblxuICAgIH0pO1xuXG4gICAgLy8gVGhpcyBpcyB0aGUgbG9naWMgdGhhdCBydW5zIHdoZW4gdGhlIGhhbmRsZXIgaXMgKmp1c3QqIGFib3V0IHRvIHN0YXJ0LlxuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXRzZWxmIGlzIGZ1cnRoZXIgdHJhbnNmb3JtZWQgdG8gYmUgdGhyb3R0bGVkL2RlYm91bmNlZCBpZiByZXF1ZXN0ZWQsXG4gICAgLy8gc28gdGhpcyBtaWdodCBub3QgYmUgY2FsbGVkIGltbWVkaWF0ZWx5IGFmdGVyIFxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlID0gdXNlU3RhYmxlQ2FsbGJhY2s8R2x1ZUZ1bmN0aW9uVHlwZTxBUCwgUj4+KGZ1bmN0aW9uIG9uTmV3RXhlY3V0ZVJlcXVlc3QyKGVucXVldWU6IGJvb2xlYW4sIC4uLm5ld0FyZ3M6IEFQKSB7XG5cbiAgICAgICAgY29uc3Qgb25UaGVuID0gKHZhbHVlOiBSKSA9PiB7IHNldFJlc3VsdCh2YWx1ZSk7IHNldEhhc1Jlc3VsdCh0cnVlKTsgc2V0SGFzRXJyb3IoZmFsc2UpOyBzZXRSZXNvbHZlQ291bnQociA9PiArK3IpOyB9O1xuICAgICAgICBjb25zdCBvbkNhdGNoID0gKGV4OiBhbnkpID0+IHsgc2V0RXJyb3IoZXgpOyBzZXRIYXNFcnJvcih0cnVlKTsgc2V0SGFzUmVzdWx0KGZhbHNlKTsgc2V0UmVqZWN0Q291bnQociA9PiArK3IpOyB9O1xuICAgICAgICBjb25zdCBvbkZpbmFsbHkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZWQgPSBnZXRRdWV1ZWQoKTtcbiAgICAgICAgICAgIHNldFNldHRsZUNvdW50KHMgPT4gKytzKTtcbiAgICAgICAgICAgIGlmIChxdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRRdWV1ZWQobnVsbCk7XG4gICAgICAgICAgICAgICAgZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UoZmFsc2UsIC4uLnF1ZXVlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRQZW5kaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICghZW5xdWV1ZSkge1xuICAgICAgICAgICAgLy8gTm90aGluZyBpcyBwZW5kaW5nIGF0IHRoZSBtb21lbnQsIHNvIHdlIGNhbiBydW4gb3VyIGZ1bmN0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgc2V0UnVuQ291bnQociA9PiArK3IpO1xuICAgICAgICAgICAgc2V0UGVuZGluZyh0cnVlKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGFzeW5jSGFuZGxlcj8uKC4uLm5ld0FyZ3MpIGFzIFI7XG4gICAgICAgICAgICBjb25zdCBpc1Byb21pc2UgPSAocmVzdWx0ICE9IG51bGwgJiYgdHlwZW9mIHJlc3VsdCA9PSBcIm9iamVjdFwiICYmIFwidGhlblwiIGluIChyZXN1bHQgYXMgdW5rbm93biBhcyBQcm9taXNlPGFueT4pKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCB8fCAhaXNQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQncyBzeW5jaHJvbm91cyBhbmQgcmV0dXJuZWQgc3VjY2Vzc2Z1bGx5LlxuICAgICAgICAgICAgICAgIC8vIEJhaWwgb3V0IGVhcmx5LlxuICAgICAgICAgICAgICAgIG9uVGhlbihyZXN1bHQgYXMgUik7XG4gICAgICAgICAgICAgICAgb25GaW5hbGx5KCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJzeW5jXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgKHJlc3VsdCBhcyB1bmtub3duIGFzIFByb21pc2U8Uj4pLnRoZW4ob25UaGVuKS5jYXRjaChvbkNhdGNoKS5maW5hbGx5KG9uRmluYWxseSk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFR5cGUoXCJhc3luY1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UncmUgc3RpbGwgcnVubmluZyBhIHByZXZpb3VzIGhhbmRsZXIsXG4gICAgICAgICAgICAvLyBqdXN0IHNldCBvdXJzZWx2ZXMgYXMgdGhlIG5leHQgb25lIHRvIHJ1biBhbmQgcXVpdCBlYXJseS5cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgbW9yZSB0byBkby5cbiAgICAgICAgICAgIHNldFF1ZXVlZChuZXdBcmdzKTtcbiAgICAgICAgfVxuXG5cblxuXG4gICAgICAgIHJldHVybiBnZXRSZXN1bHQoKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aFQgPSB1c2VUaHJvdHRsZWQ8Tm9uTnVsbGFibGU8dHlwZW9mIGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlPj4oIXRocm90dGxlID8gbnVsbCA6IGV4ZWN1dGVIYW5kbGVyV2l0aG91dERlYm91bmNlLCB0aHJvdHRsZSA/PyAwKTtcbiAgICBjb25zdCBleGVjdXRlSGFuZGxlcldpdGhEID0gdXNlRGVib3VuY2VkKCFkZWJvdW5jZSA/IG51bGwgOiAoZXhlY3V0ZUhhbmRsZXJXaXRoVCA/PyBleGVjdXRlSGFuZGxlcldpdGhvdXREZWJvdW5jZSksIGRlYm91bmNlID8/IDApO1xuICAgIGNvbnN0IGV4ZWN1dGVIYW5kbGVyV2l0aERlYm91bmNlID0gKGV4ZWN1dGVIYW5kbGVyV2l0aEQgPz8gZXhlY3V0ZUhhbmRsZXJXaXRoVCA/PyBleGVjdXRlSGFuZGxlcldpdGhvdXREZWJvdW5jZSk7XG5cbiAgICBjb25zdCBmbHVzaERlYm91bmNlZFByb21pc2UgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZSAmJiBcImZsdXNoXCIgaW4gZXhlY3V0ZUhhbmRsZXJXaXRoRGVib3VuY2UpXG4gICAgICAgICAgICBleGVjdXRlSGFuZGxlcldpdGhEZWJvdW5jZS5mbHVzaCgpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3luY0hhbmRsZXI6IGNhcHR1cmVBcmdzQW5kRXhlY3V0ZURlYm91bmNlZEhhbmRsZXIsXG4gICAgICAgIGN1cnJlbnRUeXBlLFxuICAgICAgICBwZW5kaW5nLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIGVycm9yLFxuICAgICAgICBoYXNFcnJvcixcbiAgICAgICAgaGFzUmVzdWx0LFxuICAgICAgICByZXNvbHZlQ291bnQsXG4gICAgICAgIHJlamVjdENvdW50LFxuICAgICAgICBzZXR0bGVDb3VudCxcbiAgICAgICAgY2FsbENvdW50OiBydW5Db3VudCxcbiAgICAgICAgZmx1c2hEZWJvdW5jZWRQcm9taXNlXG4gICAgfVxuXG5cbn1cbiIsImltcG9ydCB7IHVzZUFzeW5jLCBVc2VBc3luY1BhcmFtZXRlcnMsIFVzZUFzeW5jUmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1hc3luY1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5leHBvcnQgdHlwZSBBc3luY0hhbmRsZXI8RXZlbnRUeXBlIGV4dGVuZHMgRXZlbnQsIENhcHR1cmVUeXBlPiA9ICgoYzogQ2FwdHVyZVR5cGUsIGU6IEV2ZW50VHlwZSkgPT4gKFByb21pc2U8dm9pZD4gfCB2b2lkKSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlQXN5bmNIYW5kbGVyUGFyYW1ldGVyczxFdmVudFR5cGUgZXh0ZW5kcyBFdmVudCwgQ2FwdHVyZVR5cGU+IGV4dGVuZHMgT21pdDxVc2VBc3luY1BhcmFtZXRlcnM8W0NhcHR1cmVUeXBlLCBFdmVudFR5cGVdLCBbRXZlbnRUeXBlXT4sIFwiY2FwdHVyZVwiPiB7XG4gICAgLyoqXG4gICAgICogV2hhdCB0cmFuc2llbnQgaW5mb3JtYXRpb24gaXMgY2FwdHVyZWQgYnkgdGhpcyBldmVudCBcbiAgICAgKiBhbmQgcHJlc2VudGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCBvZiB0aGUgZXZlbnQgaGFuZGxlcj9cbiAgICAgKiBcbiAgICAgKiBUaGUgXCJjYXB0dXJlXCIgcGFyYW1ldGVyIGFuc3dlcnMgdGhpcyBxdWVzdGlvbi4gVG8gaW1wbGVtZW50IGEgY2hlY2tib3gsIGZvciBleGFtcGxlLCByZXR1cm4gYHRhcmdldC5jaGVja2VkYC5cbiAgICAgKi9cbiAgICBjYXB0dXJlOiAoZXZlbnQ6IEV2ZW50VHlwZSkgPT4gQ2FwdHVyZVR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZnVuY3Rpb24gKGVpdGhlciBhc3luYyBvciBzeW5jKSB0aGF0IHlvdSB3YW50IHRvIGNvbnZlcnQgdG8gYSByZWd1bGFyLCBzeW5jIGV2ZW50IGhhbmRsZXIuIFxuICAgICAqL1xuICAgIGFzeW5jSGFuZGxlcjogQXN5bmNIYW5kbGVyPEV2ZW50VHlwZSwgQ2FwdHVyZVR5cGU+IHwgbnVsbDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VBc3luY0hhbmRsZXJSZXR1cm5UeXBlPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4gZXh0ZW5kcyBVc2VBc3luY1JldHVyblR5cGU8W0V2ZW50VHlwZV0sIHZvaWQ+IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBtb3N0IHJlY2VudGx5IGNhcHR1cmVkIHZhbHVlLiBJbiBvdGhlciB3b3JkcywgcmVwcmVzZW50cyB3aGF0XG4gICAgICogdGhlIGN1cnJlbnQgdmFsdWUgd291bGQgYmUgaWYgdGhpcyBvcGVyYXRpb24gd2VyZSBzeW5jaHJvbm91cyBhbmQgXG4gICAgICogYW5kIGNvdWxkbid0IGZhaWwuIEl0J3MgdXNlZnVsIHRvIHByZXRlbmQgdGhpcyBpcyB0aGUgYWN0dWFsIHZhbHVlXG4gICAgICogZm9yIGFuIGlucHV0IGZpZWxkLCBmb3IgZXhhbXBsZSwgc28gdGhhdCB0aGUgdmFsdWUgZG9lc24ndCBcInNuYXBcbiAgICAgKiBiYWNrXCIgd2hpbGUgeW91J3JlIHdhaXRpbmcgZm9yIHRoZSBoYW5kbGVyIHRvIGZpbmlzaC5cbiAgICAgKiBcbiAgICAgKiBTb21ldGhpbmcgbGlrZSBgdmFsdWU9e3BlbmRpbmc/IGN1cnJlbnRDYXB0dXJlIDogdmFsdWV9YCBpcyBnb29kIGZvciBjaGVja2JveGVzLFxuICAgICAqIHNvbWV0aGluZyBsaWtlIGB2YWx1ZT17KHBlbmRpbmcgfHwgaGFzRm9jdXMpPyBjdXJyZW50Q2FwdHVyZSA6IHZhbHVlfSBmb3IgdGV4dCBmaWVsZHMuXG4gICAgICogXG4gICAgICogQHNlZSBoYXNDYXB0dXJlXG4gICAgICovXG4gICAgY3VycmVudENhcHR1cmU6IENhcHR1cmVUeXBlIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqIFxuICAgICAqIFRoZSBhYm92ZSwgYnV0IHN0YWJsZSwgaWYgeW91IG5lZWQgdGhlIGN1cnJlbnQgY2FwdHVyZSB3aXRob3V0IGl0IGJlaW5nIGFuIGV4cGxpY2l0IGRlcGVuZGVuY3kuXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqICAqL1xuICAgIGdldEN1cnJlbnRDYXB0dXJlKCk6IChDYXB0dXJlVHlwZSB8IHVuZGVmaW5lZCk7XG5cbiAgICAvKipcbiAgICAgKiBCZWNhdXNlIHlvdSdyZSBhbGxvd2VkIHRvIGhhdmUgYENhcHR1cmVUeXBlYCBleHRlbmQgYHVuZGVmaW5lZGAsXG4gICAgICogeW91IG1pZ2h0IG5lZWQgdGhpcy5cbiAgICAgKi9cbiAgICBoYXNDYXB0dXJlOiBib29sZWFuO1xuXG4gICAgLy8gU2FtZSBhcyBpbiB1c2VBc3luYywgYnV0IHdpdGggYSBkaWZmZXJlbnQgdHlwZVxuICAgIC8vcHJvbWlzZTogUHJvbWlzZTx2b2lkPiB8IG51bGw7XG5cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhc3luY3Jvbm91cyBldmVudCBoYW5kbGVyLCByZXR1cm5zIGEgc3luY3Jvbm91cyBvbmUgdGhhdCB3b3JrcyBvbiB0aGUgRE9NLFxuICogYWxvbmcgd2l0aCBzb21lIG90aGVyIGluZm9ybWF0aW9uIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnQgc3RhdGUuXG4gKiBEb2VzIG5vdCBtb2RpZnkgYW55IHByb3BzLlxuICogXG4gKiBOb3RlIHRoYXQgYmVjYXVzZSB0aGUgaGFuZGxlciB5b3UgcHJvdmlkZSBtYXkgYmUgY2FsbGVkIHdpdGggYSBkZWxheSwgYW5kIFxuICogYmVjYXVzZSB0aGUgdmFsdWUgb2YsIGUuZy4sIGFuIGA8aW5wdXQ+YCBlbGVtZW50IHdpbGwgbGlrZWx5IGJlIHN0YWxlIGJ5IHRoZSBcbiAqIHRpbWUgdGhlIGRlbGF5IGlzIG92ZXIsIGEgYGNhcHR1cmVgIGZ1bmN0aW9uIGlzIG5lY2Vzc2FyeSBpbiBvcmRlciB0byBcbiAqIGNhcHR1cmUgdGhlIHJlbGV2YW50IGluZm9ybWF0aW9uIGZyb20gdGhlIERPTS4gQW55IG90aGVyIHNpbXBsZSBldmVudCBkYXRhLCBcbiAqIGxpa2UgYG1vdXNlWGAgb3IgYHNoaWZ0S2V5YCBjYW4gc3RheSBvbiB0aGUgZXZlbnQgaXRzZWxmIGFuZCBkb24ndCBcbiAqIG5lZWQgdG8gYmUgY2FwdHVyZWQgJm5kYXNoOyBpdCdzIG5ldmVyIHN0YWxlLlxuICogXG4gKiBgYGB0c3hcbiAqIGNvbnN0IGFzeW5jT25JbnB1dCA9IGFzeW5jICh2YWx1ZTogbnVtYmVyLCBlOiBFdmVudCkgPT4geyBcbiAqICAgICBbLi4uXSAvLyBFeC4gc2VuZCB0byBhIHNlcnZlciBhbmQgc2V0U3RhdGUgd2hlbiBkb25lXG4gKiB9O1xuICogY29uc3Qge1xuICogICAgIC8vIEEgc3luYyB2ZXJzaW9uIG9mIGFzeW5jT25JbnB1dFxuICogICAgIHN5bmNIYW5kbGVyLFxuICogICAgIC8vIFRydWUgd2hpbGUgdGhlIGhhbmRsZXIgaXMgcnVubmluZ1xuICogICAgIHBlbmRpbmcsXG4gKiAgICAgLy8gVGhlIGVycm9yIHRocm93biwgaWYgYW55XG4gKiAgICAgZXJyb3IsXG4gKiAgICAgLy8gU2hvdyB0aGlzIHZhbHVlIHdoaWxlIHRoZSBvcGVyYXRpb24ncyBwZW5kaW5nXG4gKiAgICAgY3VycmVudENhcHR1cmUsXG4gKiAgICAgLy8gQW5kIG90aGVycywgc2VlIGBVc2VBc3luY0hhbmRsZXJSZXR1cm5UeXBlYFxuICogICAgIC4uLnJlc3RcbiAqIH0gPSB1c2VBc3luY0hhbmRsZXI8SFRNTElucHV0RWxlbWVudD4oKShhc3luY09uSW5wdXQsIHsgXG4gKiAgICAgLy8gUGFzcyBpbiB0aGUgY2FwdHVyZSBmdW5jdGlvbiB0aGF0IHNhdmVzIGV2ZW50IGRhdGFcbiAqICAgICAvLyBmcm9tIGJlaW5nIHN0YWxlLlxuICogICAgIGNhcHR1cmU6IGUgPT4geyBcbiAqICAgICAgICAgLy8gYGNhcHR1cmVgIGNhbiBoYXZlIHNpZGUtZWZmZWN0cyBiZWNhdXNlXG4gKiAgICAgICAgIC8vIGl0J3MgY2FsbGVkIGV4YWN0bHkgb25jZSBwZXIgaW52b2NhdGlvblxuICogICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7IFxuICogXG4gKiAgICAgICAgIC8vIFNhdmUgdGhpcyB2YWx1ZSBzbyB0aGF0IGl0J3MgbmV2ZXIgc3RhbGVcbiAqICAgICAgICAgcmV0dXJuIGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyO1xuICogICAgIH1cbiAqIH0pO1xuICogXG4gKiBjb25zdCBvbklucHV0ID0gcGVuZGluZz8gbnVsbCA6IHN5bmNIYW5kbGVyO1xuICogYGBgXG4gKiBcbiAqIFRoZSBoYW5kbGVyIGlzIGF1dG9tYXRpY2FsbHkgdGhyb3R0bGVkIHRvIG9ubHkgcnVuIG9uZSBhdCBhIHRpbWUuIFxuICogSWYgdGhlIGhhbmRsZXIgaXMgY2FsbGVkLCBhbmQgdGhlbiBiZWZvcmUgaXQgZmluaXNoZXMsIGlzIGNhbGxlZCBhZ2FpbixcbiAqIGl0IHdpbGwgYmUgcHV0IG9uIGhvbGQgdW50aWwgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLCBhdCB3aGljaCBwb2ludFxuICogdGhlIHNlY29uZCBvbmUgd2lsbCBydW4uICBJZiB0aGUgaGFuZGxlciBpcyBjYWxsZWQgYSB0aGlyZCB0aW1lIGJlZm9yZVxuICogdGhlIGZpcnN0IGhhcyBmaW5pc2hlZCwgaXQgd2lsbCAqcmVwbGFjZSogdGhlIHNlY29uZCwgc28gb25seSB0aGUgbW9zdFxuICogcmVjZW50bHkgY2FsbGVkIGl0ZXJhdGlvbiBvZiB0aGUgaGFuZGxlciB3aWxsIHJ1bi5cbiAqIFxuICogXG4gKiBZb3UgbWF5IG9wdGlvbmFsbHkgKmFsc28qIHNwZWNpZnkgZGVib3VuY2UgYW5kIHRocm90dGxlIHBhcmFtZXRlcnMgdGhhdCB3YWl0IHVudGlsIHRoZVxuICogc3luY3Jvbm91cyBoYW5kbGVyIGhhcyBub3QgYmVlbiBjYWxsZWQgZm9yIHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mXG4gKiBtaWxsaXNlY29uZHMsIGF0IHdoaWNoIHBvaW50IHdlICphY3R1YWxseSogcnVuIHRoZSBhc3luY3Jvbm91cyBoYW5kbGVyXG4gKiBhY2NvcmRpbmcgdG8gdGhlIGxvZ2ljIGluIHRoZSBwcmV2aW91cyBwYXJhZ3JhcGguIFRoaXMgaXMgaW5cbiAqICphZGRpdGlvbiogdG8gdGhyb3R0bGluZyB0aGUgaGFuZGxlciwgYW5kIGRvZXMgbm90IHJlcGxhY2UgdGhhdCBiZWhhdmlvci5cbiAqIFxuICogQHNlZSB1c2VBc3luYyBBIG1vcmUgZ2VuZXJhbCB2ZXJzaW9uIG9mIHRoaXMgaG9vayB0aGF0IGNhbiB3b3JrIHdpdGggYW55IHR5cGUgb2YgaGFuZGxlciwgbm90IGp1c3QgRE9NIGV2ZW50IGhhbmRsZXJzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlQXN5bmNIYW5kbGVyPEV2ZW50VHlwZSBleHRlbmRzIEV2ZW50LCBDYXB0dXJlVHlwZT4oeyBhc3luY0hhbmRsZXIsIGNhcHR1cmU6IG9yaWdpbmFsQ2FwdHVyZSwgLi4ucmVzdEFzeW5jT3B0aW9ucyB9OiBVc2VBc3luY0hhbmRsZXJQYXJhbWV0ZXJzPEV2ZW50VHlwZSwgQ2FwdHVyZVR5cGU+KTogVXNlQXN5bmNIYW5kbGVyUmV0dXJuVHlwZTxFdmVudFR5cGUsIENhcHR1cmVUeXBlPiB7XG4gICAgXG4gICAgLy8gV2UgbmVlZCB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gXCJub3RoaW5nIGNhcHR1cmVkIHlldFwiIGFuZCBcImB1bmRlZmluZWRgIHdhcyBjYXB0dXJlZFwiXG4gICAgY29uc3QgW2N1cnJlbnRDYXB0dXJlLCBzZXRDdXJyZW50Q2FwdHVyZSwgZ2V0Q3VycmVudENhcHR1cmVdID0gdXNlU3RhdGU8Q2FwdHVyZVR5cGUgfCB1bmRlZmluZWQ+KHVuZGVmaW5lZCk7XG4gICAgY29uc3QgW2hhc0NhcHR1cmUsIHNldEhhc0NhcHR1cmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIFxuICAgIC8vIFdyYXAgYXJvdW5kIHRoZSBub3JtYWwgYHVzZUFzeW5jYCBgY2FwdHVyZWAgZnVuY3Rpb24gdG8gYWxzb1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIGxhc3QgdmFsdWUgdGhlIHVzZXIgYWN0dWFsbHkgaW5wdXQuXG4gICAgLy8gXG4gICAgLy8gV2l0aG91dCB0aGlzIHRoZXJlJ3Mgbm8gd2F5IHRvIHJlLXJlbmRlciB0aGUgY29udHJvbCB3aXRoXG4gICAgLy8gaXQgYmVpbmcgYm90aCBjb250cm9sbGVkIGFuZCBhbHNvIGhhdmluZyB0aGUgXCJjb3JyZWN0XCIgdmFsdWUsXG4gICAgLy8gYW5kIGF0IGFueSByYXRlIGFsc28gcHJvdGVjdHMgYWdhaW5zdCBzdWRkZW4gZXhjZXB0aW9ucyByZXZlcnRpbmdcbiAgICAvLyB5b3VyIGNoYW5nZSBvdXQgZnJvbSB1bmRlciB5b3UuXG4gICAgY29uc3QgY2FwdHVyZSA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBFdmVudFR5cGUpOiBbQ2FwdHVyZVR5cGUsIEV2ZW50VHlwZV0gPT4geyBcbiAgICAgICAgY29uc3QgY2FwdHVyZWQgPSBvcmlnaW5hbENhcHR1cmUoZSk7IFxuICAgICAgICBzZXRDdXJyZW50Q2FwdHVyZShjYXB0dXJlZCk7XG4gICAgICAgIHNldEhhc0NhcHR1cmUodHJ1ZSk7XG4gICAgICAgIHJldHVybiBbY2FwdHVyZWQsIGVdO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0Q3VycmVudENhcHR1cmUsXG4gICAgICAgIGN1cnJlbnRDYXB0dXJlLFxuICAgICAgICBoYXNDYXB0dXJlLFxuICAgICAgICAuLi51c2VBc3luYyhhc3luY0hhbmRsZXIsIHsgY2FwdHVyZSwgLi4ucmVzdEFzeW5jT3B0aW9ucyB9KVxuICAgIH07XG59XG5cblxuXG5cblxuXG5cbiIsImltcG9ydCB7IFN0YXRlVXBkYXRlciwgdXNlQ2FsbGJhY2ssIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgT25QYXNzaXZlU3RhdGVDaGFuZ2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlLCBkZWJvdW5jZVJlbmRlcmluZyB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcblxuLyoqXG4gKiBSZW1pbmRlciBvZiBvcmRlciBvZiBleGVjdXRpb246XG4gKiBcbiAqICogKHRyZWUgbW91bnRzKVxuICogKiBQYXJlbnQgcmVuZGVyc1xuICogKiBDaGlsZHJlbiByZW5kZXJcbiAqICogQ2hpbGRyZW4gcmVjZWl2ZSByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIFBhcmVudCByZWNlaXZlcyByZWYgKGlmIGFwcGxpY2FibGUpXG4gKiAqIENoaWxkcmVuIHJ1biBlZmZlY3RzXG4gKiAqIFBhcmVudCBydW5zIGVmZmVjdHNcbiAqIFxuICogKiAodHJlZSB1bm1vdW50cylcbiAqICogUGFyZW50IHJ1bnMgZWZmZWN0LWNsZWFudXBcbiAqICogUGFyZW50IGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogKiBDaGlsZCBydW5zIGVmZmVjdC1jbGVhbnVwXG4gKiAqIENoaWxkIGRlbGV0ZXMgcmVmIChpZiBhcHBsaWNhYmxlKVxuICogXG4gKiBUd28gdGhpbmdzIHRvIG5vdGUgaGVyZTpcbiAqICogUmVuZGVyaW5nIHN0YXJ0cyBhdCB0aGUgcm9vdCwgIGJ1dCBlZmZlY3RzIGFuZCByZWZzIHN0YXJ0IGF0IHRoZSBsZWF2ZXMuXG4gKiAqIHJlZnMgYXJlICp1c3VhbGx5KiBjYWxsZWQgYmVmb3JlIGVmZmVjdHMsIGJ1dCBvbmx5IHdoZW4gdGhhdCBIVE1MRWxlbWVudCByZW5kZXJzLiBCYXNpY2FsbHkganVzdCBhIHJlbWluZGVyIHRoYXQgYSBjb21wb25lbnQgY2FuIGJlIG1vdW50ZWQgd2l0aG91dCBpdCBleGlzdGluZyBpbiB0aGUgRE9NLlxuICovXG5jb25zdCBfY29tbWVudHMgPSB2b2lkICgwKTtcblxuXG4vKipcbiAqIEluZm9ybWF0aW9uIHRoYXQgY2hpbGRyZW4gYW5kIHBhcmVudHMgdXNlIHRvIGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAqIFxuICogKiBgaW5kZXhgIHJlZmVycyB0byB3aGljaCBjaGlsZCB0aGlzIGlzLlxuICogKiBgZmxhZ3NgIGFyZSBxdWljay1hbmQtZWFzeSBnZXR0ZXJzIGFuZCBzZXR0ZXJzIHRoYXQgeW91IGNhbiBvcHRpb25hbGx5IHVzZVxuICogKiBgc3ViSW5mb2AgaXMgYW55dGhpbmcgdXNlZCBieSBhIGRlcml2ZWQgaG9vay4gYHVzZVJvdmluZ1RhYkluZGV4YCwgZm9yIGV4YW1wbGUsIG5lZWRzIHRvIGtub3cgaG93IHRvIGZvY3VzIGFuIGFyYml0cmFyeSBjaGlsZCwgc28gdGhlIGNoaWxkIHBvcHVsYXRlcyBgaW5mb2Agd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyBhIG1ldGhvZCBjYWxsZWQgYGZvY3VzU2VsZmAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTWFuYWdlZENoaWxkSW5mbzxUIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyLCBNQ1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBpbmRleDogVDtcbiAgICBmbGFncz86IFBhcnRpYWw8UmVjb3JkPEssIENoaWxkRmxhZ09wZXJhdGlvbnM+PjtcbiAgICBzdWJJbmZvOiBNQ1N1YkluZm87XG59XG5cblxuXG5leHBvcnQgdHlwZSBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VCBleHRlbmRzIHN0cmluZyB8IG51bWJlcj4gPSAoKG1vdW50ZWQ6IFNldDxUPiwgdW5tb3VudGVkOiBTZXQ8VD4pID0+IHZvaWQpO1xuZXhwb3J0IHR5cGUgT25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PFQgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXI+ID0gKChjYXVzZXJzOiBJdGVyYWJsZTxUPikgPT4gdm9pZCk7XG5cbmludGVyZmFjZSBNQ1A8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZz4ge1xuICAgIC8qKlxuICAgICAqIFJ1bnMgYWZ0ZXIgb25lIG9yIG1vcmUgY2hpbGRyZW4gaGF2ZSB1cGRhdGVkIHRoZWlyIGluZm9ybWF0aW9uIChpbmRleCwgZXRjLikuXG4gICAgICogXG4gICAgICogT25seSBvbmUgd2lsbCBydW4gcGVyIHRpY2ssIGp1c3QgbGlrZSBsYXlvdXRFZmZlY3QsIGJ1dCBpdCBpc24ndFxuICAgICAqICpndWFyYW50ZWVkKiB0byBoYXZlIGFjdHVhbGx5IGJlZW4gYSBjaGFuZ2UuXG4gICAgICovXG4gICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0PzogbnVsbCB8IHVuZGVmaW5lZCB8IE9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdDxUPjtcblxuICAgIC8qKlxuICAgICAqIFNhbWUgYXMgdGhlIGFib3ZlLCBidXQgb25seSBmb3IgbW91bnQvdW5tb3VudCAob3Igd2hlbiBhIGNoaWxkIGNoYW5nZXMgaXRzIGluZGV4KVxuICAgICAqL1xuICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT86IG51bGwgfCB1bmRlZmluZWQgfCBPbkNoaWxkcmVuTW91bnRDaGFuZ2U8VD47XG59XG5cbmV4cG9ydCB0eXBlIE1hbmFnZWRDaGlsZHJlbk9taXRzID0ga2V5b2YgTUNQPGFueT47XG5leHBvcnQgdHlwZSBNYW5hZ2VkQ2hpbGRPbWl0cyA9IGtleW9mIE1hbmFnZWRDaGlsZEluZm88YW55LCBhbnksIGFueT47XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBPbWl0cyBleHRlbmRzIGtleW9mIE1DUDxUPj4ge1xuICAgIG1hbmFnZWRDaGlsZHJlbjogT21pdDxNQ1A8VD4sIE9taXRzPjtcbn1cblxuLy8gTUNTdWJJbmZvIGNvbnRhaW5zIHRoZSBlbnRpcmV0eSBvZiB0aGUgc2F2ZWQgZGF0YSBmb3IgdGhpcyBjaGlsZC4gIEFsbCBvZiBpdC4gRXZlbiB0eXBlcyB0aGUgdXNlciB3aWxsIG5ldmVyIGJlIGFibGUgdG8gcGFzcyBpbiBiZWNhdXNlIHRoZXkncmUgaW50ZXJuYWxseSBkZXJpdmVkLlxuLy8gU3ViYmVzdEluZm8gcmVmZXJzIHRvIHRoZSBhY3R1YWwgcGFyYW1ldGVycyB0aGUgdXNlciBwYXNzZXMgaW4gdGhhdCBjb3VsZCBiZSB0b3RhbGx5IHVucmVsYXRlZC4gXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8SW5kZXhUeXBlIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBNQ1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmcsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IHtcbiAgICBtYW5hZ2VkQ2hpbGQ6IE9taXQ8TWFuYWdlZENoaWxkSW5mbzxJbmRleFR5cGUsIE1DU3ViSW5mbywgSz4sIE1jT21pdHMgfCBcInN1YkluZm9cIj47XG4gICAgc3ViSW5mbzogU3ViYmVzdEluZm87XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBNQ1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjaGlsZCB0aGF0IHJlbmRlcmVkIGl0c2VsZiB3aXRoIHRoZSByZXF1ZXN0ZWQga2V5LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogKGV2ZW4gdGhvdWdoIGl0J3Mgbm90IGEgZnVuY3Rpb24sIHRoZSBpZGVudGl0eSBvZiB0aGlzIG9iamVjdCBuZXZlciBjaGFuZ2VzKVxuICAgICAqL1xuICAgIG1hbmFnZWRDaGlsZHJlbjoge1xuICAgICAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPFQsIE1DU3ViSW5mbywgSz47XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8VCBleHRlbmRzIG51bWJlciB8IHN0cmluZywgTUNTdWJJbmZvLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPFQsIE1DU3ViSW5mbywgSz4ge1xuICAgIC8qKlxuICAgICAqIEEgaG9vayB0aGF0IG11c3QgYmUgY2FsbGVkIGJ5IGV2ZXJ5IGNoaWxkIGNvbXBvbmVudCB0aGF0XG4gICAgICogaXMgdG8gYmUgbWFuYWdlZCBieSB0aGlzIG9uZS4gVGhlIGFyZ3VtZW50IHRvIHRoZSBob29rXG4gICAgICogaXMganVzdCB0aGUgYmFnIG9mIHByb3BlcnRpZXMgdG8gcGFzcyB0byB0aGUgcGFyZW50LFxuICAgICAqIGluY2x1ZGluZyB0aGUgY2hpbGQncyBpbmRleC5cbiAgICAgKiBcbiAgICAgKiAqKlNUQUJMRSoqXG4gICAgICovXG4gICAgdXNlTWFuYWdlZENoaWxkOiBVc2VNYW5hZ2VkQ2hpbGQ8VCwgTUNTdWJJbmZvLCBLPjtcbn1cblxuZXhwb3J0IHR5cGUgVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XG5cbmV4cG9ydCB0eXBlIFVzZU1hbmFnZWRDaGlsZDxUIGV4dGVuZHMgbnVtYmVyIHwgc3RyaW5nLCBNQ1N1YkluZm8sIEsgZXh0ZW5kcyBzdHJpbmc+ID0gKGE6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8VCwgTUNTdWJJbmZvLCBLLCBuZXZlciwgTUNTdWJJbmZvPikgPT4gVXNlTWFuYWdlZENoaWxkUmV0dXJuVHlwZTtcblxuXG5cblxuXG5cbi8qKlxuICogQWJzdHJhY3Rpb24gb3ZlciB0aGUgbWFuYWdlZCBjaGlsZHJlblxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1hbmFnZWRDaGlsZHJlbjxJbmRleFR5cGUgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIE1DU3ViSW5mbywgRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZz4ge1xuICAgIC8qKiBTVEFCTEUgKi9cbiAgICBnZXRBdChpbmRleDogSW5kZXhUeXBlKTogTWFuYWdlZENoaWxkSW5mbzxJbmRleFR5cGUsIE1DU3ViSW5mbywgRXh0cmFGbGFncz4gfCB1bmRlZmluZWQ7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGdldEhpZ2hlc3RJbmRleCgpOiBudW1iZXI7XG4gICAgLyoqIFNUQUJMRSAqL1xuICAgIGZvckVhY2g6IChmOiAoY2hpbGQ6IE1hbmFnZWRDaGlsZEluZm88SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3M+KSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqICoqVU5TVEFCTEUqKiwgYWxzbyBpbnRlcm5hbC11c2Ugb25seSwgYWxzbyBUT0RPIG5lZWQgYSB3b3JrYXJvdW5kIGZvciB0aGlzIGZvciBzb3J0YWJsZSBjaGlsZHJlbiAqL1xuICAgIGFycmF5U2xpY2U6ICgpID0+IE1hbmFnZWRDaGlsZEluZm88SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3M+W107XG59XG5cbi8qKlxuICogQWxsb3dzIGEgcGFyZW50IGNvbXBvbmVudCB0byBhY2Nlc3MgaW5mb3JtYXRpb24gYWJvdXQgY2VydGFpblxuICogY2hpbGQgY29tcG9uZW50cyBvbmNlIHRoZXkgaGF2ZSByZW5kZXJlZC5cbiAqIFxuICogVGhpcyBob29rIGlzIGRlc2lnbmVkIHRvIGJlIGxpZ2h0d2VpZ2h0LCBpbiB0aGF0IHRoZSBwYXJlbnQga2VlcHMgbm8gc3RhdGVcbiAqIGFuZCBydW5zIG5vIGVmZmVjdHMuICBFYWNoIGNoaWxkICpkb2VzKiBydW4gYW4gZWZmZWN0LCBidXQgd2l0aCBubyBzdGF0ZVxuICogY2hhbmdlcyB1bmxlc3MgeW91IGV4cGxpY2l0bHkgcmVxdWVzdCB0aGVtLlxuICogXG4gKiBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZU1hbmFnZWRDaGlsZHJlbjxJbmRleFR5cGUgZXh0ZW5kcyBudW1iZXIgfCBzdHJpbmcsIE1DU3ViSW5mbywgRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlTWFuYWdlZENoaWxkcmVuUGFyYW1ldGVyczxJbmRleFR5cGUsIG5ldmVyPik6IFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8SW5kZXhUeXBlLCBNQ1N1YkluZm8sIEV4dHJhRmxhZ3M+IHtcbiAgICB0eXBlIEluZm8gPSBNYW5hZ2VkQ2hpbGRJbmZvPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPjtcblxuICAgIGNvbnN0IHsgbWFuYWdlZENoaWxkcmVuOiB7IG9uQWZ0ZXJDaGlsZExheW91dEVmZmVjdCwgb25DaGlsZHJlbk1vdW50Q2hhbmdlIH0gfSA9IHBhcmVudFBhcmFtZXRlcnM7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VNYW5hZ2VkQ2hpbGRyZW5cIiwgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UpO1xuXG4gICAgY29uc3QgZ2V0SGlnaGVzdEluZGV4ID0gdXNlQ2FsbGJhY2soKCk6IG51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleDtcbiAgICB9LCBbXSk7XG5cbiAgICAvLyBBbGwgdGhlIGluZm9ybWF0aW9uIHdlIGhhdmUgYWJvdXQgb3VyIGNoaWxkcmVuIGlzIHN0b3JlZCBpbiB0aGlzICoqc3RhYmxlKiogYXJyYXkuXG4gICAgLy8gQW55IG11dGF0aW9ucyB0byB0aGlzIGFycmF5ICoqRE8gTk9UKiogdHJpZ2dlciBhbnkgc29ydCBvZiBhIHJlLXJlbmRlci5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW5BcnJheSA9IHVzZVJlZjx7IGFycjogQXJyYXk8SW5mbz47IHJlYzogUGFydGlhbDxSZWNvcmQ8SW5kZXhUeXBlLCBJbmZvPj47IGhpZ2hlc3RJbmRleDogbnVtYmVyLCBsb3dlc3RJbmRleDogbnVtYmVyIH0+KHsgYXJyOiBbXSwgcmVjOiB7fSwgaGlnaGVzdEluZGV4OiAwLCBsb3dlc3RJbmRleDogMCB9KTtcblxuICAgIC8vIEZvciBpbmRpcmVjdCBhY2Nlc3MgdG8gZWFjaCBjaGlsZFxuICAgIC8vIENvbXBhcmUgZ2V0TWFuYWdlZENoaWxkSW5mb1xuICAgIC8vIFRPRE86IFRoZSBwcmltYXJ5IHVzZSBmb3IgdGhpcyBpcyBmbGFnZ2FibGUgY2xvc2VzdCBmaXRzXG4gICAgLy8gd2hpY2ggbmVlZHMgdG8gc2VhcmNoIGFsbCBjaGlsZHJlbiBmb3IgdGhhdCBjbG9zZXN0IGZpdC5cbiAgICAvLyBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZXJlIHdhcyBzb21ldGhpbmcgYmV0dGVyIGZvciB0aGF0LlxuICAgIGNvbnN0IGZvckVhY2hDaGlsZCA9IHVzZUNhbGxiYWNrKChmOiAoY2hpbGQ6IEluZm8pID0+IHZvaWQpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFycikge1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkOiBJbmZvIHwgdW5kZWZpbmVkID0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbZmllbGQgYXMga2V5b2YgUmVjb3JkPEluZGV4VHlwZSwgSW5mbz5dO1xuICAgICAgICAgICAgaWYgKGNoaWxkKVxuICAgICAgICAgICAgICAgIGYoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfSwgW10pXG5cbiAgICAvLyBSZXRyaWV2ZXMgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgY2hpbGQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgLy8gYHVuZGVmaW5lZGAgaWYgbm90IGNoaWxkIHRoZXJlLCBvciBpdCdzIHVubW91bnRlZC5cbiAgICBjb25zdCBnZXRNYW5hZ2VkQ2hpbGRJbmZvID0gdXNlQ2FsbGJhY2s8TWFuYWdlZENoaWxkcmVuPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPltcImdldEF0XCJdPigoaW5kZXg6IEluZGV4VHlwZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGluZGV4ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICByZXR1cm4gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LnJlY1tpbmRleCBhcyBJbmRleFR5cGVdITtcbiAgICB9LCBbXSlcblxuICAgIC8vIHRsO2RyIHRoaXMgaXMgYSB3YXkgdG8gaGF2ZSBydW4gdXNlTGF5b3V0RWZmZWN0IG9uY2UgYWZ0ZXIgYWxsIE4gY2hpbGRyZW5cbiAgICAvLyBoYXZlIG1vdW50ZWQgYW5kIHJ1biAqdGhlaXIqIHVzZUxheW91dEVmZmVjdCwgYnV0IGFsc28gKndpdGhvdXQqIHJlLXJlbmRlcmluZ1xuICAgIC8vIG91cnNlbHZlcyBiZWNhdXNlIG9mIGhhdmluZyBhIGBjaGlsZENvdW50YCBzdGF0ZSBvciBhbnl0aGluZyBzaW1pbGFyLlxuICAgIC8vXG4gICAgLy8gV2hlbiB0aGUgY2hpbGQgY291bnQgcmVmIHVwZGF0ZXMsIHdlIHdhbnQgdGhlIHBhcmVudCB0byBhbHNvIHJ1biBhbiBlZmZlY3RcbiAgICAvLyB0byBtYXliZSBkbyBzb21ldGhpbmcgd2l0aCBhbGwgdGhlc2UgY2hpbGRyZW4gdGhhdCBqdXN0IG1vdW50ZWQuXG4gICAgLy8gVGhlIGVhc2llc3Qgd2F5IHdvdWxkIGJlIHVzZUVmZmVjdCguLi4sIFtjaGlsZENvdW50XSkgYnV0XG4gICAgLy8gdGhhdCB3b3VsZCByZXF1aXJlIHVzIGhhdmluZyBhIGNoaWxkQ291bnQgc3RhdGUsIHRoZW4gY2FsbGluZ1xuICAgIC8vIHNldENoaWxkQ291bnQgYW5kIHJlLXJlbmRlcmluZyBldmVyeSB0aW1lIGNoaWxkcmVuIG1vdW50XG4gICAgLy8gKG9ubHkgb25lIHJlLXJlbmRlciBhdCBhIHRpbWUgdW5sZXNzIGNoaWxkcmVuIGFyZSBzdGFnZ2VyZWQsIGJ1dCBzdGlsbClcbiAgICAvLyBcbiAgICAvLyBBcyBhbiBhbHRlcm5hdGUgc29sdXRpb24sIGFueSB0aW1lIGEgY2hpbGQgdXNlcyBVTEUgb24gbW91bnQsIGl0IHF1ZXVlcyBhIG1pY3JvdGFza1xuICAgIC8vIHRvIGVtdWxhdGUgcnVubmluZyBVTEUgb24gdGhlIHBhcmVudC4gT25seSB0aGUgZmlyc3QgY2hpbGQgd2lsbCBhY3R1YWxseSBxdWV1ZVxuICAgIC8vIHRoZSBtaWNyb3Rhc2sgKGJ5IGNoZWNraW5nIGhhc1JlbW90ZVVMRSBmaXJzdCkgc28gdGhhdCB0aGUgXCJlZmZlY3RcIiBvbmx5XG4gICAgLy8gcnVucyBvbmNlLiBXaGVuIGl0J3MgZG9uZSwgaGFzUmVtb3RlVUxFIGlzIHJlc2V0IHNvIGl0IGNhbiBydW4gYWdhaW4gaWZcbiAgICAvLyBtb3JlIGNoaWxkcmVuIG1vdW50L3VubW91bnQuXG4gICAgY29uc3QgaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkID0gdXNlUmVmPHsgbW91bnRzOiBTZXQ8SW5kZXhUeXBlPiwgdW5tb3VudHM6IFNldDxJbmRleFR5cGU+IH0gfCBudWxsPihudWxsKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzID0gdXNlUmVmKG5ldyBTZXQ8SW5kZXhUeXBlPigpKTtcbiAgICBjb25zdCByZW1vdGVVTEVDaGlsZENoYW5nZWQgPSB1c2VDYWxsYmFjaygoaW5kZXg6IEluZGV4VHlwZSkgPT4ge1xuXG4gICAgICAgIGlmIChyZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuc2l6ZSA9PSAwKSB7XG4gICAgICAgICAgICBkZWJvdW5jZVJlbmRlcmluZygoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0Py4ocmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICByZW1vdGVVTEVDaGlsZENoYW5nZWRDYXVzZXJzLmN1cnJlbnQuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkQ2F1c2Vycy5jdXJyZW50LmFkZChpbmRleCk7XG5cbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcblxuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuICAgIGNvbnN0IHJlbW90ZVVMRUNoaWxkTW91bnRlZCA9IHVzZUNhbGxiYWNrKChpbmRleDogSW5kZXhUeXBlLCBtb3VudGVkOiBib29sZWFuKTogdm9pZCA9PiB7XG4gICAgICAgIGlmICghaGFzUmVtb3RlVUxFQ2hpbGRNb3VudGVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIG1vdW50czogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIHVubW91bnRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZGVib3VuY2VSZW5kZXJpbmcoKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS5tb3VudHMsIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50IS51bm1vdW50cylcbiAgICAgICAgICAgICAgICBoYXNSZW1vdGVVTEVDaGlsZE1vdW50ZWQuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb3VudGVkKSB7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmhpZ2hlc3RJbmRleCA9IE1hdGgubWF4KG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuaGlnaGVzdEluZGV4LCBpbmRleCBhcyBudW1iZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW2luZGV4IGFzIG51bWJlcl07XG4gICAgICAgICAgICAgICAgbGV0IHNoYXZlID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2hhdmUgPD0gbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoICYmIG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyW21hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQuYXJyLmxlbmd0aCAtIDEgLSBzaGF2ZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICArK3NoYXZlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zcGxpY2UobWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnIubGVuZ3RoIC0gc2hhdmUsIHNoYXZlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGhhc1JlbW90ZVVMRUNoaWxkTW91bnRlZC5jdXJyZW50W21vdW50ZWQgPyBcIm1vdW50c1wiIDogXCJ1bm1vdW50c1wiXS5hZGQoaW5kZXgpO1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUgKi9dKTtcblxuXG4gICAgY29uc3QgdXNlTWFuYWdlZENoaWxkID0gdXNlQ2FsbGJhY2s8VXNlTWFuYWdlZENoaWxkPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPj4oKGluZm8pID0+IHtcbiAgICAgICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHN1YkluZm8gfSA9IGluZm87XG4gICAgICAgIC8vIEFueSB0aW1lIG91ciBjaGlsZCBwcm9wcyBjaGFuZ2UsIG1ha2UgdGhhdCBpbmZvcm1hdGlvbiBhdmFpbGFibGVcbiAgICAgICAgLy8gdGhlIHBhcmVudCBpZiB0aGV5IG5lZWQgaXQuXG4gICAgICAgIC8vIFRoZSBwYXJlbnQgY2FuIGxpc3RlbiBmb3IgYWxsIHVwZGF0ZXMgYW5kIG9ubHkgYWN0IG9uIHRoZSBvbmVzIGl0IGNhcmVzIGFib3V0LFxuICAgICAgICAvLyBhbmQgbXVsdGlwbGUgY2hpbGRyZW4gdXBkYXRpbmcgaW4gdGhlIHNhbWUgdGljayB3aWxsIGFsbCBiZSBzZW50IGF0IG9uY2UuXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhpcyBpbmZvcm1hdGlvbiBpbi1wbGFjZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmRleCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5hcnJbaW5kZXggYXMgbnVtYmVyXSA9IHsgaW5kZXgsIGZsYWdzOiBmbGFncyA/PyB7fSwgc3ViSW5mbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkcmVuQXJyYXkuY3VycmVudC5yZWNbaW5kZXggYXMgSW5kZXhUeXBlXSA9IHsgaW5kZXgsIGZsYWdzOiBmbGFncyA/PyB7fSwgc3ViSW5mbyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlbW90ZVVMRUNoaWxkQ2hhbmdlZChpbmRleCBhcyBJbmRleFR5cGUpO1xuICAgICAgICB9LCBbLi4uT2JqZWN0LmVudHJpZXMoaW5mbykuZmxhdCg5KV0pOyAgLy8gOSBpcyBpbmZpbml0eSwgcmlnaHQ/IFN1cmUuIFVucmVsYXRlZDogVE9ETy5cblxuICAgICAgICAvLyBXaGVuIHdlIG1vdW50LCBub3RpZnkgdGhlIHBhcmVudCB2aWEgcXVldWVNaWNyb3Rhc2tcbiAgICAgICAgLy8gKGV2ZXJ5IGNoaWxkIGRvZXMgdGhpcywgc28gZXZlcnl0aGluZydzIGNvb3JkaW5hdGVkIHRvIG9ubHkgcXVldWUgYSBzaW5nbGUgbWljcm90YXNrIHBlciB0aWNrKVxuICAgICAgICAvLyBEbyB0aGUgc2FtZSBvbiB1bm1vdW50LlxuICAgICAgICAvLyBOb3RlOiBJdCdzIGltcG9ydGFudCB0aGF0IHRoaXMgY29tZXMgQUZURVIgcmVtb3RlVUxFQ2hpbGRDaGFuZ2VkXG4gICAgICAgIC8vIHNvIHRoYXQgcmVtb3RlVUxFQ2hpbGRNb3VudGVkIGhhcyBhY2Nlc3MgdG8gYWxsIHRoZSBpbmZvIG9uIG1vdW50LlxuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVtb3RlVUxFQ2hpbGRNb3VudGVkPy4oaW5kZXggYXMgSW5kZXhUeXBlLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiByZW1vdGVVTEVDaGlsZE1vdW50ZWQ/LihpbmRleCBhcyBJbmRleFR5cGUsIGZhbHNlKTtcbiAgICAgICAgfSwgW2luZGV4XSk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG5cbiAgICBjb25zdCBtYW5hZ2VkQ2hpbGRyZW4gPSB1c2VSZWY8TWFuYWdlZENoaWxkcmVuPEluZGV4VHlwZSwgTUNTdWJJbmZvLCBFeHRyYUZsYWdzPj4oe1xuICAgICAgICAuLi57IF86IG1hbmFnZWRDaGlsZHJlbkFycmF5LmN1cnJlbnQgfSBhcyB7fSxcbiAgICAgICAgZm9yRWFjaDogZm9yRWFjaENoaWxkLFxuICAgICAgICBnZXRBdDogZ2V0TWFuYWdlZENoaWxkSW5mbyxcbiAgICAgICAgZ2V0SGlnaGVzdEluZGV4OiBnZXRIaWdoZXN0SW5kZXgsXG4gICAgICAgIGFycmF5U2xpY2U6ICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VkQ2hpbGRyZW5BcnJheS5jdXJyZW50LmFyci5zbGljZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLmN1cnJlbnQgfVxuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TUNTdWJJbmZvLCBFeHRyYUZsYWdzIGV4dGVuZHMgc3RyaW5nPiB7XG5cbiAgICAvKipcbiAgICAgKiBXaGljaCBjaGlsZCBpcyBjb25zaWRlcmVkIGFjdGl2ZSBvbiBtb3VudC5cbiAgICAgKiBcbiAgICAgKiBBZnRlciBtb3VudCwgY2hhbmdlIHRoZSBjdXJyZW50IGFjdGl2ZSBjaGlsZCB3aXRoIGBjaGFuZ2VJbmRleGAuXG4gICAgICovXG4gICAgaW5pdGlhbEluZGV4OiBudW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwcm92aWRlZCwgaWYgdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4IGRvZXNuJ3QgbWFwIG9udG8gYW55XG4gICAgICogcHJvdmlkZWQgY2hpbGQgKGVpdGhlciBiZWNhdXNlIGl0J3MgdG9vIGxhcmdlIG9yIHRoYXQgY2hpbGRcbiAgICAgKiBkb2Vzbid0IGV4aXN0KSwgdGhlIGNsb3Nlc3QgY2hpbGQgdG8gdGhlIGdpdmVuIGFjdGl2YXRlZEluZGV4XG4gICAgICogd2lsbCBoYXZlIGl0cyBmbGFnIHNldCBpbnN0ZWFkLlxuICAgICAqIFxuICAgICAqIFVzZSB3aXRoIGNhdXRpb24sIGFuZCBjb25zaWRlciBob3cgYSBjaGlsZCBoYXZpbmcgaXRzIGZsYWcgc2V0XG4gICAgICogd2hpbGUgdGhlIHBhcmVudCB0aGlua3MgaXQgc2hvdWxkbid0IGJlIGNvdWxkIGNhdXNlIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBjbG9zZXN0Rml0OiBib29sZWFuO1xuXG4gICAgY2hpbGRyZW46IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIE1DU3ViSW5mbywgRXh0cmFGbGFncz47XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbmV2ZXIgYSBuZXcgaW5kZXggaXMgc2VsZWN0ZWQuXG4gICAgICogXG4gICAgICogTm90YWJseSwgdGhlIHZhbHVlIGNhbiBiZSBkaWZmZXJlbnQgdGhhbiB3aGF0IHdhcyBjYWxsZWQgd2l0aCBjaGFuZ2VJbmRleCgpXG4gICAgICogaWYgdGhlIHJlcXVlc3RlZCBpbmRleCBkaWRuJ3QgZXhpc3Qgb3Igd2FzIGhpZGRlbi5cbiAgICAgKi9cbiAgICBvbkluZGV4Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8bnVtYmVyIHwgbnVsbD47XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIGNoaWxkcmVuIGhhdmUgbXVsdGlwbGUgZmxhZ3MsIHRoZSBga2V5YCBwYXJhbWV0ZXIgY29udHJvbHMgd2hpY2ggZmxhZyB3ZSdyZSBjaGVja2luZy5cbiAgICAgKiBcbiAgICAgKiBUaGlzIGNhbiBiZSBhbnl0aGluZyB5b3Ugd2FudCwgYnV0IG11c3Qgbm90IGNoYW5nZS5cbiAgICAgKi9cbiAgICBrZXk6IEV4dHJhRmxhZ3M7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBDaGlsZEZsYWdPcGVyYXRpb25zIHtcblxuICAgIC8qKlxuICAgICAqIE11c3QgcmV0dXJuIHdoZXRoZXIgdGhlIGN1cnJlbnQgY2hpbGQgaXMgYWN0aXZlXG4gICAgICovXG4gICAgZ2V0OiAoKSA9PiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFRoZSBjaGlsZCBtdXN0IHNldCBpdHNlbGYgYXMgYWN0aXZlL2luYWN0aXZlLCB3aGF0ZXZlciB0aGF0IGVudGFpbHMuXG4gICAgICogVGhpcyBjb3VsZCBiZSBhcyBzaW1wbGUgYXMgYSBzZXRTdGF0ZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzZXQ6IChhY3RpdmU6IGJvb2xlYW4pID0+IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4gdHJ1ZSBpZiB0aGlzIGNoaWxkIGlzIGEgdmFsaWQgY2FuZGlkYXRlIHRvIGJlIGZsYWdnZWQsIGFuZCBmYWxzZSBpZiBub3QuXG4gICAgICogTW9zdCBjaGlsZHJlbiBzaG91bGQgcmV0dXJuIHRydWUuIFJldHVybmluZyBmYWxzZSBpcyBvbmx5IHVzZWZ1bCB0byBtYXJrIGEgY2hpbGQgYXMgXCJpbnZhbGlkXCIgaW4gc29tZSB3YXkuXG4gICAgICogUmVtb3ZpbmcgYSBjaGlsZCBmcm9tIHRoZSBsaXN0IGRvZXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcsIGJ1dCB0aGlzIGxldHMgeW91IGtlZXAgdGhlIGNoaWxkIGFyb3VuZC5cbiAgICAgKi9cbiAgICBpc1ZhbGlkKCk6IGJvb2xlYW47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgY2hhbmdlSW5kZXg6IChhcmc6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSkgPT4gbnVtYmVyIHwgbnVsbDtcbiAgICAvKiogXG4gICAgICogKipTVEFCTEUqKlxuICAgICAqIFxuICAgICAqIENhbGwgdGhpcyB3aGVuZXZlciBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgb3Igd2hlbmV2ZXIgY2FsbGluZyBhIGNoaWxkJ3MgaXNWYWxpZCgpIHdvdWxkIGNoYW5nZVxuICAgICAqICAqL1xuICAgIHJlZXZhbHVhdGVDbG9zZXN0Rml0OiAoKSA9PiB2b2lkO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0Q3VycmVudEluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xufVxuXG4vKipcbiAqIEFuIGV4dGVuc2lvbiB0byB1c2VNYW5hZ2VkQ2hpbGRyZW4gdGhhdCBoYW5kbGVzIHRoZSBmb2xsb3dpbmcgY29tbW9uIGNhc2U6XG4gKiAxLiBZb3UgaGF2ZSBhIGJ1bmNoIG9mIGNoaWxkcmVuXG4gKiAyLiBBdCBhbnkgZ2l2ZW4gdGltZSwgb25seSAxIG9mIHRoZW0gaXMgXCJzZWxlY3RlZFwiLCBcImFjdGl2YXRlZFwiLCBcImZvY3VzYWJsZVwiLCB3aGF0ZXZlciAob3IgMCBvZiB0aGVtLCB0aGF0J3MgY29vbCB0b28sIGp1c3QgMCBvciAxIHRob3VnaCkuXG4gKiAzLiBUaGUgcGFyZW50IGhhcyBjb250cm9sIG92ZXIgd2hvIGlzIFwic2VsZWN0ZWRcIiB2aWEgYSBudW1lcmljYWwgaW5kZXguXG4gKiBcbiAqIFRoaXMgaG9vayBhbGxvd3MgZm9yIG11Y2ggZWFzaWVyIGNvbnRyb2wgb3ZlciBzZWxlY3Rpb24gbWFuYWdlbWVudC5cbiAqIFxuICogTm90ZSB0aGF0IGJlY2F1c2UgeW91IG1heSB3YW50IHRvIHVzZSBtdWx0aXBsZSBmbGFncyB3aXRoIHRoZSBzYW1lIGNoaWxkcmVuLCB0aGlzIGhvb2sgKmRvZXMgbm90KiB1c2UgYHVzZU1hbmFnZWRDaGlsZHJlbmAhXG4gKiBZb3UgbmVlZCB0byBwYXNzIGl0IHRoZSBleGlzdGluZyBjaGlsZHJlbiwgYW5kIHlvdSBtdXN0IHBhc3MgeW91ciBpbnZvY2F0aW9uIG9mIGB1c2VNYW5hZ2VkQ2hpbGRyZW5gIHRoZSByZXR1cm5lZCBgb25DaGlsZHJlbk1vdW50Q2hhbmdlYCBoYW5kbGVyIVxuICogXG4gKiBBbHNvIGJlY2F1c2Ugb2YgdGhhdCwgdGhlIHR5cGVzIG9mIHRoaXMgZnVuY3Rpb24gYXJlIHJhdGhlciBvZGQuICBJdCdzIGJldHRlciB0byBzdGFydCBvZmYgdXNpbmcgYSBob29rIHRoYXQgYWxyZWFkeSB1c2VzIGEgZmxhZywgc3VjaCBhcyBgdXNlUm92aW5nVGFiSW5kZXhgLCBhcyBhbiBleGFtcGxlLlxuICogXG4gKiBcbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoaWxkcmVuRmxhZzxNQ1N1YkluZm8sIEZsYWcgZXh0ZW5kcyBzdHJpbmc+KHsgY2hpbGRyZW4sIGluaXRpYWxJbmRleCwgY2xvc2VzdEZpdCwgb25JbmRleENoYW5nZSwga2V5IH06IFVzZUNoaWxkcmVuRmxhZ1BhcmFtZXRlcnM8TUNTdWJJbmZvLCBGbGFnPik6IFVzZUNoaWxkcmVuRmxhZ1JldHVyblR5cGUge1xuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUNoaWxkcmVuRmxhZ1wiLCBvbkluZGV4Q2hhbmdlLCBrZXkpO1xuXG4gICAgY29uc3QgW2dldEN1cnJlbnRJbmRleCwgc2V0Q3VycmVudEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihvbkluZGV4Q2hhbmdlLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XG5cbiAgICBjb25zdCBbZ2V0UmVxdWVzdGVkSW5kZXgsIHNldFJlcXVlc3RlZEluZGV4XSA9IHVzZVBhc3NpdmVTdGF0ZTxudWxsIHwgbnVtYmVyPihudWxsLCB1c2VDYWxsYmFjaygoKSA9PiAoaW5pdGlhbEluZGV4ID8/IChudWxsKSksIFtdKSk7XG5cbiAgICAvLyAgICBjb25zdCBnZXRGaXROdWxsVG9aZXJvID0gdXNlU3RhYmxlR2V0dGVyKGZpdE51bGxUb1plcm8pO1xuXG4gICAgLy8gU2hhcmVkIGJldHdlZW4gb25DaGlsZHJlbk1vdW50Q2hhbmdlIGFuZCBjaGFuZ2VJbmRleCwgbm90IHB1YmxpYyAoYnV0IGNvdWxkIGJlIEkgZ3Vlc3MpXG4gICAgY29uc3QgZ2V0Q2xvc2VzdEZpdCA9IHVzZUNhbGxiYWNrKChyZXF1ZXN0ZWRJbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICAgICAgbGV0IGNsb3Nlc3RJbmRleDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQuZmxhZ3M/LltrZXldPy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdEaXN0YW5jZSA9IE1hdGguYWJzKGNoaWxkLmluZGV4IC0gcmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXdEaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSB8fCAobmV3RGlzdGFuY2UgPT0gY2xvc2VzdERpc3RhbmNlICYmIGNoaWxkLmluZGV4IDwgcmVxdWVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IG5ld0Rpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0SW5kZXggPSBjaGlsZC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEluZGV4O1xuICAgIH0sIFsvKiBNdXN0IHJlbWFpbiBzdGFibGUhICovXSk7XG5cbiAgICAvLyBBbnkgdGltZSBhIGNoaWxkIG1vdW50cy91bm1vdW50cywgd2UgbmVlZCB0byBkb3VibGUtY2hlY2sgdG8gc2VlIGlmIHRoYXQgYWZmZWN0cyBcbiAgICAvLyB0aGUgXCJjdXJyZW50bHkgc2VsZWN0ZWRcIiAob3Igd2hhdGV2ZXIpIGluZGV4LiAgVGhlIHR3byBjYXNlcyB3ZSdyZSBsb29raW5nIGZvcjpcbiAgICAvLyAxLiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIGNoaWxkIHVubW91bnRlZFxuICAgIC8vIDIuIEEgY2hpbGQgbW91bnRlZCwgYW5kIGl0IG1vdW50cyB3aXRoIHRoZSBpbmRleCB3ZSdyZSBsb29raW5nIGZvclxuICAgIGNvbnN0IHJlZXZhbHVhdGVDbG9zZXN0Rml0ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ZWRJbmRleCA9IGdldFJlcXVlc3RlZEluZGV4KCk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbmRleCA9IGdldEN1cnJlbnRJbmRleCgpO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2hpbGQgPSBjdXJyZW50SW5kZXggPT0gbnVsbCA/IG51bGwgOiBjaGlsZHJlbi5nZXRBdChjdXJyZW50SW5kZXgpO1xuXG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCAhPSBudWxsICYmIGNsb3Nlc3RGaXQgJiYgKHJlcXVlc3RlZEluZGV4ICE9IGN1cnJlbnRJbmRleCB8fCBjdXJyZW50Q2hpbGQgPT0gbnVsbCB8fCAhY3VycmVudENoaWxkLmZsYWdzPy5ba2V5XT8uaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgY3VycmVudENoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBjbG9zZXN0Rml0SW5kZXggPSBnZXRDbG9zZXN0Rml0KHJlcXVlc3RlZEluZGV4KTtcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChjbG9zZXN0Rml0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdENoaWxkID0gY2hpbGRyZW4uZ2V0QXQoY2xvc2VzdEZpdEluZGV4KSE7XG4gICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQoY2xvc2VzdEZpdENoaWxkICE9IG51bGwsIFwiSW50ZXJuYWwgbG9naWM/Pz9cIik7XG4gICAgICAgICAgICAgICAgY2xvc2VzdEZpdENoaWxkLmZsYWdzPy5ba2V5XSEuc2V0KHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cbiAgICB9KTtcblxuXG5cblxuICAgIGNvbnN0IGNoYW5nZUluZGV4ID0gdXNlQ2FsbGJhY2soKGFyZzogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RlZEluZGV4ID0gYXJnIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBhcmcoZ2V0UmVxdWVzdGVkSW5kZXgoKSkgOiBhcmc7XG4gICAgICAgIC8vaWYgKHJlcXVlc3RlZEluZGV4ID09IG51bGwgJiYgZ2V0Rml0TnVsbFRvWmVybygpKVxuICAgICAgICAvLyAgICByZXF1ZXN0ZWRJbmRleCA9IDA7XG5cbiAgICAgICAgc2V0UmVxdWVzdGVkSW5kZXgocmVxdWVzdGVkSW5kZXgpO1xuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBnZXRDdXJyZW50SW5kZXgoKTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PSByZXF1ZXN0ZWRJbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0ZWRJbmRleDtcblxuICAgICAgICBsZXQgbmV3TWF0Y2hpbmdDaGlsZCA9IChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsID8gbnVsbCA6IGNoaWxkcmVuLmdldEF0KHJlcXVlc3RlZEluZGV4KSk7XG4gICAgICAgIGNvbnN0IG9sZE1hdGNoaW5nQ2hpbGQgPSAoY3VycmVudEluZGV4ID09IG51bGwgPyBudWxsIDogY2hpbGRyZW4uZ2V0QXQoY3VycmVudEluZGV4KSk7XG4gICAgICAgIGlmIChyZXF1ZXN0ZWRJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBFYXN5IGNhc2VcbiAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChudWxsKTtcbiAgICAgICAgICAgIG9sZE1hdGNoaW5nQ2hpbGQ/LmZsYWdzPy5ba2V5XSEuc2V0KGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG5ld01hdGNoaW5nQ2hpbGQgJiYgbmV3TWF0Y2hpbmdDaGlsZC5mbGFncz8uW2tleV0hLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRJbmRleChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgb2xkTWF0Y2hpbmdDaGlsZD8uZmxhZ3M/LltrZXldIS5zZXQoZmFsc2UpO1xuICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcXVlc3RlZEluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VzdEZpdEluZGV4ID0gZ2V0Q2xvc2VzdEZpdChyZXF1ZXN0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudEluZGV4KGNsb3Nlc3RGaXRJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RGaXRJbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQgPSBjaGlsZHJlbi5nZXRBdChjbG9zZXN0Rml0SW5kZXgpITtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5hc3NlcnQobmV3TWF0Y2hpbmdDaGlsZCAhPSBudWxsLCBcIkludGVybmFsIGxvZ2ljPz8/XCIpO1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIG5ld01hdGNoaW5nQ2hpbGQuZmxhZ3M/LltrZXldIS5zZXQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9zZXN0Rml0SW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvbGRNYXRjaGluZ0NoaWxkPy5mbGFncz8uW2tleV0hLnNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKTtcblxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpbml0aWFsSW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIGNoaWxkcmVuLmdldEF0KGluaXRpYWxJbmRleCk/LmZsYWdzPy5ba2V5XT8uc2V0KHRydWUpO1xuICAgIH0sIFtdKVxuXG4gICAgcmV0dXJuIHsgY2hhbmdlSW5kZXgsIHJlZXZhbHVhdGVDbG9zZXN0Rml0LCBnZXRDdXJyZW50SW5kZXggfTtcbn1cblxuIiwiZnVuY3Rpb24gcihlKXt2YXIgdCxmLG49XCJcIjtpZihcInN0cmluZ1wiPT10eXBlb2YgZXx8XCJudW1iZXJcIj09dHlwZW9mIGUpbis9ZTtlbHNlIGlmKFwib2JqZWN0XCI9PXR5cGVvZiBlKWlmKEFycmF5LmlzQXJyYXkoZSkpZm9yKHQ9MDt0PGUubGVuZ3RoO3QrKyllW3RdJiYoZj1yKGVbdF0pKSYmKG4mJihuKz1cIiBcIiksbis9Zik7ZWxzZSBmb3IodCBpbiBlKWVbdF0mJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBmdW5jdGlvbiBjbHN4KCl7Zm9yKHZhciBlLHQsZj0wLG49XCJcIjtmPGFyZ3VtZW50cy5sZW5ndGg7KShlPWFyZ3VtZW50c1tmKytdKSYmKHQ9cihlKSkmJihuJiYobis9XCIgXCIpLG4rPXQpO3JldHVybiBufWV4cG9ydCBkZWZhdWx0IGNsc3g7IiwiaW1wb3J0IGNsc3ggZnJvbSBcImNsc3hcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KGVsZW1lbnQ/OiBOb2RlKSB7IHJldHVybiAoZWxlbWVudD8ub3duZXJEb2N1bWVudCA/PyBkb2N1bWVudCA/PyB3aW5kb3cuZG9jdW1lbnQgPz8gZ2xvYmFsVGhpcy5kb2N1bWVudCk7IH1cblxudHlwZSBQID0gUGFyYW1ldGVyczx0eXBlb2YgY2xzeD47XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEb2N1bWVudENsYXNzKGNsYXNzTmFtZTogUFswXSwgYWN0aXZlPzogYm9vbGVhbiwgZWxlbWVudD86IEhUTUxFbGVtZW50KSB7XG4gICAgZWxlbWVudCA/Pz0gZ2V0RG9jdW1lbnQoKS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgY2xhc3NOYW1lID0gY2xzeChjbGFzc05hbWUpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiBlbGVtZW50IS5jbGFzc0xpc3QucmVtb3ZlKGNsYXNzTmFtZSBhcyBzdHJpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbY2xhc3NOYW1lLCBhY3RpdmUsIGVsZW1lbnRdKTtcblxufVxuIiwiaW1wb3J0IHsgY3JlYXRlRWxlbWVudCwgRnJhZ21lbnQsIGggfSBmcm9tIFwicHJlYWN0XCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRDaGlsZHJlbih7IGNoaWxkcmVuOiBsaHMgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwiY2hpbGRyZW5cIj4sIHsgY2hpbGRyZW46IHJoc306IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+LCBcImNoaWxkcmVuXCI+KTogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RXZlbnRUYXJnZXQ+W1wiY2hpbGRyZW5cIl0ge1xuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIGlmIChsaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gcmhzO1xuICAgIH1cbiAgICBlbHNlIGlmIChyaHMgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIHt9LCBsaHMsIHJocyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgZGVmYXVsdCBhcyBjbHN4IH0gZnJvbSBcImNsc3hcIjtcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbi8qKlxyXG4gKiBHaXZlbiB0d28gc2V0cyBvZiBwcm9wcywgbWVyZ2VzIHRoZWlyIGBjbGFzc2AgYW5kIGBjbGFzc05hbWVgIHByb3BlcnRpZXMuXHJcbiAqIER1cGxpY2F0ZSBjbGFzc2VzIGFyZSByZW1vdmVkIChvcmRlciBkb2Vzbid0IG1hdHRlciBhbnl3YXkpLlxyXG4gKiBcclxuICogQHBhcmFtIGxocyBDbGFzc2VzIG9mIHRoZSBmaXJzdCBjb21wb25lbnRcclxuICogQHBhcmFtIHJocyBDbGFzc2VzIG9mIHRoZSBzZWNvbmQgY29tcG9uZW50XHJcbiAqIEByZXR1cm5zIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgY29tYmluZWQgY2xhc3NlcyBmcm9tIGJvdGggYXJndW1lbnRzLlxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZENsYXNzZXM8RSBleHRlbmRzIEV2ZW50VGFyZ2V0Pih7IGNsYXNzOiBsaHNDbGFzcywgY2xhc3NOYW1lOiBsaHNDbGFzc05hbWUgfTogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgXCJjbGFzc1wiIHwgXCJjbGFzc05hbWVcIj4sIHsgY2xhc3M6IHJoc0NsYXNzLCBjbGFzc05hbWU6IHJoc0NsYXNzTmFtZX06IFBpY2s8aC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4sIFwiY2xhc3NcIiB8IFwiY2xhc3NOYW1lXCI+KTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcclxuXHJcbiAgICAvLyBOb3RlOiBGb3IgdGhlIHNha2Ugb2YgZm9yd2FyZCBjb21wYXRpYmlsaXR5LCB0aGlzIGZ1bmN0aW9uIGlzIGxhYmVsbGVkIGFzXHJcbiAgICAvLyBhIGhvb2ssIGJ1dCBhcyBpdCB1c2VzIG5vIG90aGVyIGhvb2tzIGl0IHRlY2huaWNhbGx5IGlzbid0IG9uZS5cclxuXHJcbiAgICBpZiAobGhzQ2xhc3MgfHwgcmhzQ2xhc3MgfHwgbGhzQ2xhc3NOYW1lIHx8IHJoc0NsYXNzTmFtZSkge1xyXG4gICAgICAgIGNvbnN0IGxoc0NsYXNzZXMgPSBjbHN4KGxoc0NsYXNzLCBsaHNDbGFzc05hbWUpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgICBjb25zdCByaHNDbGFzc2VzID0gY2xzeChyaHNDbGFzcywgcmhzQ2xhc3NOYW1lKS5zcGxpdChcIiBcIik7XHJcbiAgICAgICAgY29uc3QgYWxsQ2xhc3NlcyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20obGhzQ2xhc3NlcyksIC4uLkFycmF5LmZyb20ocmhzQ2xhc3NlcyldKVxyXG5cclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShhbGxDbGFzc2VzKS5qb2luKFwiIFwiKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCwgUmVmLCBSZWZDYWxsYmFjaywgUmVmT2JqZWN0IH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuXHJcblxyXG5mdW5jdGlvbiBwcm9jZXNzUmVmPFQ+KGluc3RhbmNlOiBUIHwgbnVsbCwgcmVmOiBSZWY8VD4gfCBudWxsIHwgdW5kZWZpbmVkKSB7XHJcbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgcmVmKGluc3RhbmNlKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJlZiAhPSBudWxsKSB7XHJcbiAgICAgICAgKHJlZiBhcyBSZWZPYmplY3Q8VCB8IG51bGw+KS5jdXJyZW50ID0gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1kZWJ1Z2dlciAqL1xyXG4gICAgICAgIGRlYnVnZ2VyO1xyXG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KGZhbHNlLCBcIlVua25vd24gcmVmIHR5cGUgZm91bmQgdGhhdCB3YXMgbmVpdGhlciBhIFJlZkNhbGxiYWNrIG5vciBhIFJlZk9iamVjdFwiKTtcclxuICAgIH1cclxufVxyXG5cclxuaW50ZXJmYWNlIFI8RT4ge1xyXG4gICAgcmVmPzogUmVmPEU+O1xyXG59XHJcblxyXG5cclxuLyoqXHJcbiAqIENvbWJpbmVzIHR3byByZWZzIGludG8gb25lLiBUaGlzIGFsbG93cyBhIGNvbXBvbmVudCB0byBib3RoIHVzZSBpdHMgb3duIHJlZiAqYW5kKiBmb3J3YXJkIGEgcmVmIHRoYXQgd2FzIGdpdmVuIHRvIGl0LlxyXG4gKiBAcGFyYW0gbGhzIFxyXG4gKiBAcGFyYW0gcmhzIFxyXG4gKiBAcmV0dXJucyBcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VNZXJnZWRSZWZzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4oeyByZWY6IHJocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgeyByZWY6IGxocyB9OiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikge1xyXG4gICAgY29uc3QgY29tYmluZWQ6IFJlZkNhbGxiYWNrPEU+ID0gdXNlQ2FsbGJhY2soKGN1cnJlbnQ6IEUgfCBudWxsKSA9PiB7XHJcbiAgICAgICAgcHJvY2Vzc1JlZihjdXJyZW50LCBsaHMpO1xyXG4gICAgICAgIHByb2Nlc3NSZWYoY3VycmVudCwgcmhzKTtcclxuICAgIH0sIFtsaHMsIHJoc10pO1xyXG5cclxuICAgIGlmIChsaHMgPT0gbnVsbCAmJiByaHMgPT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQhO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAobGhzID09IG51bGwpIHtcclxuICAgICAgICByZXR1cm4gcmhzITtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHJocyA9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGxocyE7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gY29tYmluZWQ7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuXHJcbmZ1bmN0aW9uIHN0eWxlU3RyaW5nVG9PYmplY3Qoc3R5bGU6IHN0cmluZyk6IGguSlNYLkNTU1Byb3BlcnRpZXMge1xyXG4gICAgLy8gVE9ETzogVGhpcyBzdWNrcyBEOlxyXG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhzdHlsZS5zcGxpdChcIjtcIikubWFwKHN0YXRlbWVudCA9PiBzdGF0ZW1lbnQuc3BsaXQoXCI6XCIpKSkgYXMgdW5rbm93biBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzO1xyXG59XHJcblxyXG4vKipcclxuICogTWVyZ2VzIHR3byBzdHlsZSBvYmplY3RzLCByZXR1cm5pbmcgdGhlIHJlc3VsdC5cclxuICogXHJcbiAqIEBwYXJhbSBzdHlsZSBUaGUgdXNlci1naXZlbiBzdHlsZSBwcm9wIGZvciB0aGlzIGNvbXBvbmVudFxyXG4gKiBAcGFyYW0gb2JqIFRoZSBDU1MgcHJvcGVydGllcyB5b3Ugd2FudCBhZGRlZCB0byB0aGUgdXNlci1naXZlbiBzdHlsZVxyXG4gKiBAcmV0dXJucyBBIENTUyBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBib3RoIG9iamVjdHMuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTWVyZ2VkU3R5bGVzKGxoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4sIHJoczogUGljazxoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD4sIFwic3R5bGVcIj4pOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFdmVudFRhcmdldD5bXCJzdHlsZVwiXSB7XHJcblxyXG4gICAgLy8gRWFzeSBjYXNlLCB3aGVuIHRoZXJlIGFyZSBubyBzdHlsZXMgdG8gbWVyZ2UgcmV0dXJuIG5vdGhpbmcuXHJcbiAgICBpZiAoIWxocz8uc3R5bGUgJiYgIXJocz8uc3R5bGUpXHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcbiAgICBpZiAodHlwZW9mIGxocyAhPSB0eXBlb2YgcmhzKSB7XHJcbiAgICAgICAgLy8gRWFzeSBjYXNlcywgd2hlbiBvbmUgaXMgbnVsbCBhbmQgdGhlIG90aGVyIGlzbid0LlxyXG4gICAgICAgIGlmIChsaHM/LnN0eWxlICYmICFyaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gbGhzLnN0eWxlO1xyXG4gICAgICAgIGlmICghbGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKVxyXG4gICAgICAgICAgICByZXR1cm4gcmhzLnN0eWxlO1xyXG5cclxuICAgICAgICAvLyBUaGV5J3JlIGJvdGggbm9uLW51bGwgYnV0IGRpZmZlcmVudCB0eXBlcy5cclxuICAgICAgICAvLyBDb252ZXJ0IHRoZSBzdHJpbmcgdHlwZSB0byBhbiBvYmplY3QgYmFnIHR5cGUgYW5kIHJ1biBpdCBhZ2Fpbi5cclxuICAgICAgICBpZiAobGhzPy5zdHlsZSAmJiByaHM/LnN0eWxlKSB7XHJcbiAgICAgICAgICAgIC8vICh1c2VNZXJnZWRTdHlsZXMgaXNuJ3QgYSB0cnVlIGhvb2sgLS0gdGhpcyBpc24ndCBhIHZpb2xhdGlvbilcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKHsgc3R5bGU6IHN0eWxlU3RyaW5nVG9PYmplY3QobGhzPy5zdHlsZSBhcyBzdHJpbmcpIH0sIHJocykgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiByaHM/LnN0eWxlID09IFwic3RyaW5nXCIpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdXNlTWVyZ2VkU3R5bGVzKGxocywgeyBzdHlsZTogc3R5bGVTdHJpbmdUb09iamVjdChyaHM/LnN0eWxlIGFzIHN0cmluZykgfSkgYXMgaC5KU1guQ1NTUHJvcGVydGllcztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExvZ2ljPz8/XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUaGV5J3JlIGJvdGggc3RyaW5ncywganVzdCBjb25jYXRlbmF0ZSB0aGVtLlxyXG4gICAgaWYgKHR5cGVvZiBsaHM/LnN0eWxlID09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICByZXR1cm4gYCR7bGhzLnN0eWxlfTske3Jocz8uc3R5bGUgPz8gXCJcIn1gIGFzIHVua25vd24gYXMgc3RyaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZXkncmUgYm90aCBvYmplY3RzLCBqdXN0IG1lcmdlIHRoZW0uXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLihsaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzLFxyXG4gICAgICAgIC4uLihyaHM/LnN0eWxlID8/IHt9KSBhcyBoLkpTWC5DU1NQcm9wZXJ0aWVzXHJcbiAgICB9IGFzIHVua25vd24gYXMgaC5KU1guQ1NTUHJvcGVydGllc1xyXG59XHJcblxyXG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2hpbGRyZW5cIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkQ2xhc3NlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtY2xhc3Nlc1wiO1xyXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWZzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1yZWZzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFN0eWxlcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtc3R5bGVzXCI7XHJcblxyXG5sZXQgbG9nID0gY29uc29sZS53YXJuO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZUxvZ2dpbmdQcm9wQ29uZmxpY3RzKGxvZzI6IHR5cGVvZiBjb25zb2xlW1wibG9nXCJdKSB7XHJcbiAgICBsb2cgPSBsb2cyXHJcbn1cclxuXHJcblxyXG4vKipcclxuICogR2l2ZW4gdHdvIHNldHMgb2YgcHJvcHMsIG1lcmdlcyB0aGVtIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXHJcbiAqIFxyXG4gKiBUaGUgaG9vayBpcyBhd2FyZSBvZiBhbmQgY2FuIGludGVsbGlnZW50bHkgbWVyZ2UgYGNsYXNzTmFtZWAsIGBjbGFzc2AsIGBzdHlsZWAsIGByZWZgLCBhbmQgYWxsIGV2ZW50IGhhbmRsZXJzLlxyXG4gKiBAcGFyYW0gbGhzMiBcclxuICogQHBhcmFtIHJoczIgXHJcbiAqIEByZXR1cm5zIFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZU1lcmdlZFByb3BzPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4obGhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPiwgcmhzQWxsOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPik6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+IHtcclxuICAgIC8vIEZpcnN0LCBzZXBhcmF0ZSB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiBpbnRvIHR3byBncm91cHM6XHJcbiAgICAvLyBsaHNBbGwgYW5kIHJoc0FsbCBjb250YWluIGFsbCB0aGUgcHJvcHMgd2Ugd2VyZSBnaXZlbiwgYW5kXHJcbiAgICAvLyBsaHNNaXNjIGFuZCByaHNNaXNjIGNvbnRhaW4gYWxsIHByb3BzICpleGNlcHQqIGZvciB0aGUgZWFzeSBvbmVzXHJcbiAgICAvLyBsaWtlIGNsYXNzTmFtZSBhbmQgc3R5bGUgdGhhdCB3ZSBhbHJlYWR5IGtub3cgaG93IHRvIG1lcmdlLlxyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX2xoc0NoaWxkcmVuLCBjbGFzczogX2xoc0NsYXNzLCBjbGFzc05hbWU6IF9saHNDbGFzc05hbWUsIHN0eWxlOiBfbGhzU3R5bGUsIHJlZjogX2xoc1JlZiwgLi4ubGhzTWlzYyB9ID0gbGhzQWxsO1xyXG4gICAgY29uc3QgeyBjaGlsZHJlbjogX3Joc0NoaWxkcmVuLCBjbGFzczogX3Joc0NsYXNzLCBjbGFzc05hbWU6IF9yaHNDbGFzc05hbWUsIHN0eWxlOiBfcmhzU3R5bGUsIHJlZjogX3Joc1JlZiwgLi4ucmhzTWlzYyB9ID0gcmhzQWxsO1xyXG5cclxuICAgIGNvbnN0IHJldDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4gPSB7XHJcbiAgICAgICAgLi4ubGhzTWlzYyxcclxuICAgICAgICByZWY6IHVzZU1lcmdlZFJlZnM8RT4obGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIHN0eWxlOiB1c2VNZXJnZWRTdHlsZXMobGhzQWxsLCByaHNBbGwpLFxyXG4gICAgICAgIGNsYXNzTmFtZTogdXNlTWVyZ2VkQ2xhc3NlcyhsaHNBbGwsIHJoc0FsbCksXHJcbiAgICAgICAgY2hpbGRyZW46IHVzZU1lcmdlZENoaWxkcmVuKGxoc0FsbCwgcmhzQWxsKSxcclxuICAgIH0gYXMgYW55O1xyXG5cclxuICAgIGlmIChyZXQucmVmID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQucmVmO1xyXG4gICAgaWYgKHJldC5zdHlsZSA9PT0gdW5kZWZpbmVkKSBkZWxldGUgcmV0LnN0eWxlO1xyXG4gICAgaWYgKHJldC5jbGFzc05hbWUgPT09IHVuZGVmaW5lZCkgZGVsZXRlIHJldC5jbGFzc05hbWU7XHJcbiAgICBpZiAocmV0LmNoaWxkcmVuID09PSB1bmRlZmluZWQpIGRlbGV0ZSByZXQuY2hpbGRyZW47XHJcblxyXG4gICAgLy8gTm93LCBkbyAqZXZlcnl0aGluZyogZWxzZVxyXG4gICAgLy8gTWVyZ2UgZXZlcnkgcmVtYWluaW5nIGV4aXN0aW5nIGVudHJ5IGluIGxocyB3aXRoIHdoYXQgd2UndmUgYWxyZWFkeSBwdXQgaW4gcmV0LlxyXG4gICAgLy9jb25zdCBsaHNFbnRyaWVzID0gT2JqZWN0LmVudHJpZXMobGhzKSBhcyBba2V5b2YgVCwgVFtrZXlvZiBUXV1bXTtcclxuICAgIGNvbnN0IHJoc0VudHJpZXMgPSBPYmplY3QuZW50cmllcyhyaHNNaXNjKTtcclxuXHJcbiAgICBmb3IgKGNvbnN0IFtyaHNLZXlVLCByaHNWYWx1ZV0gb2YgcmhzRW50cmllcykge1xyXG4gICAgICAgIGNvbnN0IHJoc0tleSA9IHJoc0tleVUgYXMga2V5b2YgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcblxyXG4gICAgICAgIGNvbnN0IGxoc1ZhbHVlID0gbGhzTWlzY1tyaHNLZXkgYXMga2V5b2YgdHlwZW9mIGxoc01pc2NdO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIGxoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIHJoc1ZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFRoZXkncmUgYm90aCBmdW5jdGlvbnMgdGhhdCBjYW4gYmUgbWVyZ2VkIChvciBvbmUncyBhIGZ1bmN0aW9uIGFuZCB0aGUgb3RoZXIncyBudWxsKS5cclxuICAgICAgICAgICAgLy8gTm90IGFuICplYXN5KiBjYXNlLCBidXQgYSB3ZWxsLWRlZmluZWQgb25lLlxyXG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZUZ1bmN0aW9ucyhsaHNWYWx1ZSBhcyBuZXZlciwgcmhzVmFsdWUgYXMgbmV2ZXIpO1xyXG4gICAgICAgICAgICByZXRbcmhzS2V5IGFzIGtleW9mIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+XSA9IG1lcmdlZCBhcyBuZXZlcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFVoLi4ud2UncmUgaGVyZSBiZWNhdXNlIG9uZSBvZiB0aGVtJ3MgbnVsbCwgcmlnaHQ/XHJcbiAgICAgICAgICAgIGlmIChsaHNWYWx1ZSA9PSBudWxsICYmIHJoc1ZhbHVlID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChyaHNWYWx1ZSA9PT0gbnVsbCAmJiBsaHNWYWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgICAgICBlbHNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSBsaHNWYWx1ZSBhcyBuZXZlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAobGhzVmFsdWUgPT0gbnVsbClcclxuICAgICAgICAgICAgICAgIHJldFtyaHNLZXldID0gcmhzVmFsdWUgYXMgbmV2ZXI7XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHJoc1ZhbHVlID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICByZXRbcmhzS2V5XSA9IGxoc1ZhbHVlIGFzIG5ldmVyO1xyXG4gICAgICAgICAgICBlbHNlIGlmICgocmhzVmFsdWUgYXMgYW55KSA9PSBsaHNWYWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSSBtZWFuLCB0aGV5J3JlIHRoZSBzYW1lIHZhbHVlIGF0IGxlYXN0XHJcbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLlxyXG4gICAgICAgICAgICAgICAgLy8gTm90IHJlYWxseSBpZGVhbCB0aG91Z2guXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBVZ2guXHJcbiAgICAgICAgICAgICAgICAvLyBObyBnb29kIHN0cmF0ZWdpZXMgaGVyZSwganVzdCBsb2cgaXQgaWYgcmVxdWVzdGVkXHJcbiAgICAgICAgICAgICAgICBsb2c/LihgVGhlIHByb3AgXCIke3Joc0tleX1cIiBjYW5ub3Qgc2ltdWx0YW5lb3VzbHkgYmUgdGhlIHZhbHVlcyAke2xoc1ZhbHVlfSBhbmQgJHtyaHNWYWx1ZX0uIE9uZSBtdXN0IGJlIGNob3NlbiBvdXRzaWRlIG9mIHVzZU1lcmdlZFByb3BzLmApO1xyXG4gICAgICAgICAgICAgICAgcmV0W3Joc0tleV0gPSByaHNWYWx1ZSBhcyBuZXZlclxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZXQ7XHJcblxyXG59XHJcblxyXG5mdW5jdGlvbiBtZXJnZUZ1bmN0aW9uczxUIGV4dGVuZHMgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnksIFUgZXh0ZW5kcyAoLi4uYXJnczogYW55W10pID0+IGFueT4obGhzOiBUIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBVIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xyXG5cclxuICAgIGlmICghbGhzKVxyXG4gICAgICAgIHJldHVybiByaHM7XHJcbiAgICBpZiAoIXJocylcclxuICAgICAgICByZXR1cm4gbGhzO1xyXG5cclxuICAgIHJldHVybiAoLi4uYXJnczogUGFyYW1ldGVyczxUPikgPT4ge1xyXG4gICAgICAgIGNvbnN0IGx2ID0gbGhzKC4uLmFyZ3MpO1xyXG4gICAgICAgIGNvbnN0IHJ2ID0gcmhzKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICBpZiAobHYgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJ2IGluc3RhbmNlb2YgUHJvbWlzZSlcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsdiwgcnZdKTtcclxuICAgIH07XHJcbn1cclxuXHJcbi8qXHJcbmZ1bmN0aW9uIHRlc3Q8UCBleHRlbmRzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEhUTUxJbnB1dEVsZW1lbnQ+Pihwcm9wczogUCkge1xyXG5cclxuICAgIGNvbnN0IGlkMDogR2VuZXJpY0dldDx7fSwgXCJpZFwiLCBzdHJpbmc+ID0gXCJcIjtcclxuICAgIGNvbnN0IGlkMzogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgY29uc3QgaWQ0OiBHZW5lcmljR2V0PHsgaWQ6IHVuZGVmaW5lZCB9LCBcImlkXCIsIHN0cmluZz4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDU6IEdlbmVyaWNHZXQ8eyBpZDogdW5kZWZpbmVkIH0sIFwiaWRcIiwgc3RyaW5nPiA9IHVuZGVmaW5lZDtcclxuICAgIGNvbnN0IGlkNjogR2VuZXJpY0dldDx7IGlkOiB1bmRlZmluZWQgfSwgXCJpZFwiLCBzdHJpbmc+ID0gdW5kZWZpbmVkO1xyXG4gICAgLy9jb25zdCBpZDI6IFppcFNpbmdsZTxzdHJpbmcgfCB1bmRlZmluZWQsIHN0cmluZyB8IHVuZGVmaW5lZD4gPSB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBpZDE6IFppcE9iamVjdDx7IGlkOiB1bmRlZmluZWQgfSwgeyBpZDogc3RyaW5nIH0+ID0geyBpZDogdW5kZWZpbmVkIH07XHJcblxyXG4gICAgdHlwZSBNMSA9IEdlbmVyaWNHZXQ8UCwgXCJzdHlsZVwiLCBzdHJpbmc+O1xyXG4gICAgdHlwZSBNMiA9IEdlbmVyaWNHZXQ8e30sIFwic3R5bGVcIiwgc3RyaW5nPjtcclxuICAgIGNvbnN0IG0xOiBNMSA9IFwiXCI7XHJcbiAgICBjb25zdCBtMjogTTEgPSB1bmRlZmluZWQ7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBCZWNhdXNlIG51bWJlciBpc24ndCBhc3NpZ25hYmxlIHRvIHN0cmluZ1xyXG4gICAgY29uc3QgbTM6IE0xID0gMDtcclxuXHJcbiAgICBjb25zdCBtNDogTTIgPSBcIlwiO1xyXG4gICAgY29uc3QgbTU6IE0yID0gdW5kZWZpbmVkO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgQmVjYXVzZSBudW1iZXIgaXNuJ3QgYXNzaWduYWJsZSB0byBzdHJpbmdcclxuICAgIGNvbnN0IG02OiBNMiA9IDA7XHJcblxyXG4gICAgY29uc3QgcDE6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHt9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHt9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDI6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBzdHJpbmcgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiBcInN0cmluZ1wiIH0pO1xyXG4gICAgY29uc3QgcDM6IE1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQsIHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfT4gPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHsgaWQ6IHVuZGVmaW5lZCB9LCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNDogTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudCwge30sIHt9PiA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkoe30sIHt9KTtcclxuICAgIGNvbnN0IHA1ID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywge30pO1xyXG4gICAgY29uc3QgcDYgPSB1c2VNZXJnZWRQcm9wczxIVE1MSW5wdXRFbGVtZW50PigpKHByb3BzLCB7IGlkOiB1bmRlZmluZWQgfSk7XHJcbiAgICBjb25zdCBwNyA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KCkocHJvcHMsIHsgaWQ6IFwic3RyaW5nXCIgfSk7XHJcblxyXG5cclxuICAgIHAxLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwMi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcDMuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHA0LmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHA1LmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICBwNi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcDcuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNi5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICBwNy5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHVuZGVmaW5lZCkge31cclxuICAgIGVsc2UgaWYgKHA1LmFsbG93RnVsbFNjcmVlbiA9PT0gZmFsc2UpIHt9XHJcbiAgICBlbHNlIGlmIChwNS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocDUuYWxsb3dGdWxsU2NyZWVuKTtcclxuICAgIH1cclxuXHJcblxyXG4gICAgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdW5kZWZpbmVkKSB7fVxyXG4gICAgZWxzZSBpZiAocDYuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHA2LmFsbG93RnVsbFNjcmVlbiA9PT0gdHJ1ZSkge31cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGFjY2VwdHNOZXZlcihwNi5hbGxvd0Z1bGxTY3JlZW4pO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChwNy5hbGxvd0Z1bGxTY3JlZW4gPT09IGZhbHNlKSB7fVxyXG4gICAgZWxzZSBpZiAocDcuYWxsb3dGdWxsU2NyZWVuID09PSB0cnVlKSB7fVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgYWNjZXB0c05ldmVyKHA3LmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdCB3b3JrcyByZWN1cnNpdmVseVxyXG4gICAgY29uc3QgcjFhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDEpO1xyXG4gICAgY29uc3QgcjFiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDEpO1xyXG4gICAgY29uc3QgcjJhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDIpO1xyXG4gICAgY29uc3QgcjJiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDIpO1xyXG4gICAgY29uc3QgcjNhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDMpO1xyXG4gICAgY29uc3QgcjNiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDMpO1xyXG4gICAgY29uc3QgcjRhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDQpO1xyXG4gICAgY29uc3QgcjRiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDQpO1xyXG4gICAgY29uc3QgcjVhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDUpO1xyXG4gICAgY29uc3QgcjViID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDUpO1xyXG4gICAgY29uc3QgcjZhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDYpO1xyXG4gICAgY29uc3QgcjZiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDYpO1xyXG4gICAgY29uc3QgcjdhID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKSh7fSwgcDcpO1xyXG4gICAgY29uc3QgcjdiID0gdXNlTWVyZ2VkUHJvcHM8SFRNTElucHV0RWxlbWVudD4oKShwcm9wcywgcDcpO1xyXG5cclxuXHJcbiAgICByMWEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHIxYi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjJhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByMmIuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgY2FuJ3QgYmUgYW55dGhpbmcgYnV0IHVuZGVmaW5lZFxyXG4gICAgcjNhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByM2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIGNhbid0IGJlIGFueXRoaW5nIGJ1dCB1bmRlZmluZWRcclxuICAgIHI0YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjRiLmlkPy5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIHI1YS5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjViLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByNmEuaWQ/LmNvbmNhdChcIlwiKTtcclxuICAgIHI2Yi5pZD8uY29uY2F0KFwiXCIpO1xyXG4gICAgcjdhLmlkPy5jb25jYXQoXCJcIik7XHJcbiAgICByN2IuaWQ/LmNvbmNhdChcIlwiKTtcclxuXHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNWEuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjViLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI2YS5pZC5jb25jYXQoXCJcIik7XHJcbiAgICAvLy8gQHRzLWV4cGVjdC1lcnJvciAgICBpZCBtdXN0IGNvbnRhaW4gdW5kZWZpbmVkXHJcbiAgICByNmIuaWQuY29uY2F0KFwiXCIpO1xyXG4gICAgLy8vIEB0cy1leHBlY3QtZXJyb3IgICAgaWQgbXVzdCBjb250YWluIHVuZGVmaW5lZFxyXG4gICAgcjdhLmlkLmNvbmNhdChcIlwiKTtcclxuICAgIC8vLyBAdHMtZXhwZWN0LWVycm9yICAgIGlkIG11c3QgY29udGFpbiB1bmRlZmluZWRcclxuICAgIHI3Yi5pZC5jb25jYXQoXCJcIik7XHJcblxyXG5cclxuICAgIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjVhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNWIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI1Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjViLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmEuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyNmIuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI2Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjZiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2EuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3YS5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdhLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSB1bmRlZmluZWQpIHt9XHJcbiAgICBlbHNlIGlmIChyN2IuYWxsb3dGdWxsU2NyZWVuID09PSBmYWxzZSkge31cclxuICAgIGVsc2UgaWYgKHI3Yi5hbGxvd0Z1bGxTY3JlZW4gPT09IHRydWUpIHt9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBhY2NlcHRzTmV2ZXIocjdiLmFsbG93RnVsbFNjcmVlbik7XHJcbiAgICB9XHJcblxyXG59XHJcbmZ1bmN0aW9uIGFjY2VwdHNOZXZlcihuOiBuZXZlcikge31cclxuKi8iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VEcmFnZ2FibGVSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFdmVudFRhcmdldD4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgdXNlRHJhZ2dhYmxlUHJvcHM6IChwOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVsZW1lbnQgaW4gcXVlc3Rpb24gaXMgY3VycmVudGx5IGJlaW5nIGRyYWdnZWRcbiAgICAgKi9cbiAgICBkcmFnZ2luZzogYm9vbGVhbjtcbiAgICBcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIGdldERyYWdnaW5nOiAoKSA9PiBib29sZWFuO1xuXG4gICAgLyoqXG4gICAgICogT25jZSB0aGUgZHJhZyBlbmRzLCBpZiBpdCB3YXMgb3ZlciBhIHZhbGlkIGRyb3BwYWJsZSwgdGhpcyB3aWxsIGJlXG4gICAgICogc2V0IHRvIHRoZSBgZHJvcEVmZmVjdGAgdmFsdWUgaXQgaGFkLlxuICAgICAqIFxuICAgICAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZWN0IHdoZW4gdGhlIGVsZW1lbnQgaGFzIGRyb3BwZWQsIFxuICAgICAqIGFuZCB0aGVuIHdoYXQgc2hvdWxkIGJlIGRvbmUgd2l0aCBpdCAoZ2VuZXJhbGx5IGRlbGV0ZWQgaWYgdGhlIGVmZmVjdCB3YXMgXCJtb3ZlXCIpXG4gICAgICovXG4gICAgbGFzdERyb3BFZmZlY3Q6IERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsO1xuXG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRMYXN0RHJvcEVmZmVjdDogKCkgPT4gKERhdGFUcmFuc2ZlcltcImRyb3BFZmZlY3RcIl0gfCBudWxsKTtcbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyYWdnYWJsZVBhcmFtZXRlcnMge1xuXG4gICAgLyoqXG4gICAgICogTWFwcyB0byB0aGUgRHJhZyBhbmQgRHJvcCBBUEkgLS0gYWxsb3dzIGxpbWl0aW5nIHRoZSBhcmVhcyB0aGlzIGVsZW1lbnQgY2FuIGJlIGRyb3BwZWQuXG4gICAgICogRm9yIGV4YW1wbGUsIHNldHRpbmcgdGhpcyB0byBcImNvcHlMaW5rXCIgd2lsbCBhbGxvdyB0aGlzIHRoaXMgdG8gYmUgZHJvcHBlZCBvbnRvXG4gICAgICogYSBkcm9wcGFibGUgd2l0aCBhbiBlZmZlY3Qgb2YgXCJjb3B5XCIgb3IgXCJsaW5rXCIsIGJ1dCBub3QgXCJtb3ZlXCIuXG4gICAgICogXG4gICAgICovXG4gICAgZWZmZWN0QWxsb3dlZD86IERhdGFUcmFuc2ZlcltcImVmZmVjdEFsbG93ZWRcIl0gfCB1bmRlZmluZWQ7XG5cbiAgICAvKipcbiAgICAgKiBDYW4gYmUgdXNlZCB0byBzcGVjaWZ5IGEgY3VzdG9tIGRyYWcgaW1hZ2UgaW5zdGVhZCBvZiB0aGUgYnJvd3NlciBkZWZhdWx0IChhIHRyYW5zcGFyZW50IHJlbmRlciBvZiB0aGUgb3JpZ2luYWwgZWxlbWVudCwgZ2VuZXJhbGx5KVxuICAgICAqL1xuICAgIGRyYWdJbWFnZT86IEhUTUxDYW52YXNFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudCB8IEhUTUxWaWRlb0VsZW1lbnQ7XG4gICAgZHJhZ0ltYWdlWE9mZnNldD86IG51bWJlcjtcbiAgICBkcmFnSW1hZ2VZT2Zmc2V0PzogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGRpY3Rpb25hcnkgbWFwcGluZyBvZiBNSU1FIHR5cGVzIHRvIGRhdGFcbiAgICAgKi9cbiAgICBkYXRhOiB7IFttaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEcmFnZ2FibGU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZWZmZWN0QWxsb3dlZCwgZGF0YSwgZHJhZ0ltYWdlLCBkcmFnSW1hZ2VYT2Zmc2V0LCBkcmFnSW1hZ2VZT2Zmc2V0IH06IFVzZURyYWdnYWJsZVBhcmFtZXRlcnMpIHtcblxuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmcsIGdldERyYWdnaW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbbGFzdERyb3BFZmZlY3QsIHNldExhc3REcm9wRWZmZWN0LCBnZXRMYXN0RHJvcEVmZmVjdF0gPSB1c2VTdGF0ZTxEYXRhVHJhbnNmZXJbXCJkcm9wRWZmZWN0XCJdIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB1c2VEcmFnZ2FibGVQcm9wcyA9IHVzZUNhbGxiYWNrKDxQIGV4dGVuZHMgaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4+KHA6IFApID0+IHtcblxuICAgICAgICBjb25zdCByZWYgPSB1c2VSZWY8RT4obnVsbCk7XG5cbiAgICAgICAgY29uc3Qgb25EcmFnU3RhcnQgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgICAvL2UucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgaWYgKGUuZGF0YVRyYW5zZmVyKSB7XG4gICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IChlZmZlY3RBbGxvd2VkID8/IFwiYWxsXCIpO1xuICAgICAgICAgICAgICAgIGlmIChkcmFnSW1hZ2UpXG4gICAgICAgICAgICAgICAgICAgIGUuZGF0YVRyYW5zZmVyLnNldERyYWdJbWFnZShkcmFnSW1hZ2UsIGRyYWdJbWFnZVhPZmZzZXQgPz8gMCwgZHJhZ0ltYWdlWU9mZnNldCA/PyAwKVxuXG4gICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKGRhdGEpIGFzIFttaW1lVHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmddW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbWltZVR5cGUsIGRhdGFdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5kYXRhVHJhbnNmZXIuc2V0RGF0YShtaW1lVHlwZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IG9uRHJhZ0VuZCA9IChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldERyYWdnaW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlcikge1xuICAgICAgICAgICAgICAgIGlmIChlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ICE9IFwibm9uZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldExhc3REcm9wRWZmZWN0KGUuZGF0YVRyYW5zZmVyLmRyb3BFZmZlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0TGFzdERyb3BFZmZlY3QobnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG5cbiAgICAgICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzPEU+KHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0LFxuICAgICAgICAgICAgb25EcmFnRW5kLFxuICAgICAgICAgICAgcmVmXG4gICAgICAgIH0sIHApO1xuXG4gICAgfSwgW2VmZmVjdEFsbG93ZWQsIGRyYWdJbWFnZSwgZHJhZ0ltYWdlWE9mZnNldCwgZHJhZ0ltYWdlWU9mZnNldCwgLi4uT2JqZWN0LmVudHJpZXMoZGF0YSkuZmxhdCgpXSk7XG5cbiAgICAvLyBSZXR1cm4gYm90aCB0aGUgZWxlbWVudCBhbmQgdGhlIGhvb2sgdGhhdCBtb2RpZmllcyBcbiAgICAvLyB0aGUgcHJvcHMgYW5kIGFsbG93cyB1cyB0byBhY3R1YWxseSBmaW5kIHRoZSBlbGVtZW50XG4gICAgY29uc3QgcmV0OiBVc2VEcmFnZ2FibGVSZXR1cm5UeXBlPEU+ID0ge1xuICAgICAgICB1c2VEcmFnZ2FibGVQcm9wcyxcbiAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgIGdldERyYWdnaW5nLFxuICAgICAgICBsYXN0RHJvcEVmZmVjdCxcbiAgICAgICAgZ2V0TGFzdERyb3BFZmZlY3RcbiAgICB9O1xuXG4gICAgcmV0dXJuIHJldDtcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyb3BwYWJsZVJldHVyblR5cGU8RSBleHRlbmRzIEVsZW1lbnQ+IHtcblxuICAgIC8qKlxuICAgICAqIEhvb2sgZm9yIG1vZGlmeWluZyB0aGUgcHJvcHMgeW91IHdlcmUgZ29pbmcgdG8gcGFzcyB0byB5b3VyIGRyb3AgdGFyZ2V0IEVsZW1lbnQuXG4gICAgICogXG4gICAgICogKlVuc3RhYmxlKlxuICAgICAqL1xuICAgIHVzZURyb3BwYWJsZVByb3BzOiAocDogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT4pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xuXG4gICAgLyoqXG4gICAgICogV2hpbGUgc29tZXRoaW5nIGlzIGJlaW5nIGRyYWdnZWQgb3ZlciB0aGlzIGVsZW1lbnQsIHRoaXMgd2lsbCBjb250YWluIGFueSBpbmZvcm1hdGlvbiBhYm91dCBhbnkgZmlsZXMgaW5jbHVkZWQgaW4gdGhhdCBkcm9wLlxuICAgICAqIE90aGVyd2lzZSwgaXQnbGwgYmUgbnVsbCwgbWVhbmluZyBub3RoaW5nIGlzIGJlaW5nIGRyYWdnZWQgb3ZlciB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgZmlsZXNGb3JDb25zaWRlcmF0aW9uOiBEcm9wRmlsZU1ldGFkYXRhW10gfCBudWxsO1xuICAgIC8qKlxuICAgICAqIFdoaWxlIHNvbWV0aGluZyBpcyBiZWluZyBkcmFnZ2VkIG92ZXIgdGhpcyBlbGVtZW50LCBhIGxpc3Qgb2YgYXZhaWxhYmxlIE1JTUUgdHlwZXMgZm9yIHRoZSBub24tZmlsZSBkYXRhIHdpbGwgYmUgbGlzdGVkIGhlcmUuXG4gICAgICogT3RoZXJ3aXNlLCBpdCdsbCBiZSBudWxsLCBtZWFuaW5nIG5vdGhpbmcgaXMgYmVpbmcgZHJhZ2dlZCBvdmVyIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbjogU2V0PHN0cmluZz4gfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBmaWxlcyBhcmUgZHJvcHBlZCBvdmVyIHRoZSBlbGVtZW50LCB0aGVpciBkYXRhIHdpbGwgYmUgZ2l2ZW4gaGVyZS5cbiAgICAgKiBUaGlzIHdpbGwgdXBkYXRlIGFzIG5ldyBkcm9wcyBoYXBwZW4uXG4gICAgICovXG4gICAgZHJvcHBlZEZpbGVzOiBEcm9wRmlsZVtdIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIFdoZW4gbm9uLWZpbGUgZGF0YSBpcyBkcm9wcGVkIG92ZXIgdGhlIGVsZW1lbnQsIHRoZWlyIGRhdGEgd2lsbCBiZSBnaXZlbiBoZXJlLlxuICAgICAqIFRoaXMgd2lsbCB1cGRhdGUgYXMgbmV3IGRyb3BzIGhhcHBlbi5cbiAgICAgKi9cbiAgICBkcm9wcGVkU3RyaW5nczogeyBbTWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9IHwgbnVsbDtcblxuXG4gICAgZHJvcEVycm9yOiB1bmtub3duO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZURyb3BwYWJsZVBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIE1hcHMgdG8gdGhlIERyYWcgYW5kIERyb3AgQVBJIC0tIGVmZmVjdGl2ZWx5IG1lYW5zIFwiYXMgY2xvc2UgYXMgcG9zc2libGUsIHdoYXQncyBoYXBwZW5pbmcgdG8gdGhlIGRhdGEgd2hlbiBJIGRyb3AgaXQgaGVyZT8gXG4gICAgICogQW0gSSBjb3B5aW5nIGl0IGFuZCBsZWF2aW5nIHRoZSBvcmlnaW5hbCwgYW0gSSBtb3ZpbmcgaXQgYW5kIGRlbGV0aW5nIHRoZSBvcmlnaW5hbCwgb3IgYW0gSSBsaW5raW5nIGl0IHRvIHRoZSBvcmlnaW5hbD9cIlxuICAgICAqIFxuICAgICAqIFdoYXRldmVyIGlzIGJlaW5nIGRyYWdnZWQgb3ZlciB0aGlzIHdpbGwgaGF2ZSBpdHMgb3duIHBlcm1pc3Npb24gdGhhdCdzIGNoZWNrZWQgYWdhaW5zdCB0aGlzLlxuICAgICAqL1xuICAgIGVmZmVjdDogRGF0YVRyYW5zZmVyW1wiZHJvcEVmZmVjdFwiXSB8IHVuZGVmaW5lZDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBEcm9wRmlsZSBleHRlbmRzIERyb3BGaWxlTWV0YWRhdGEgeyBuYW1lOiBzdHJpbmcsIGRhdGE6IEFycmF5QnVmZmVyLCBzaXplOiBudW1iZXIgfCB1bmRlZmluZWQsIGxhc3RNb2RpZmllZDogbnVtYmVyIHwgdW5kZWZpbmVkIH1cbmV4cG9ydCBpbnRlcmZhY2UgRHJvcEZpbGVNZXRhZGF0YSB7IHR5cGU6IHN0cmluZyB8IHVuZGVmaW5lZCB9XG5cblxudHlwZSBEcm9wcGFibGVGaWxlRXJyb3JUeXBlID0gXCJJbmRleFNpemVFcnJvclwiIHwgXCJIaWVyYXJjaHlSZXF1ZXN0RXJyb3JcIiB8IFwiV3JvbmdEb2N1bWVudEVycm9yXCIgfCBcIkludmFsaWRDaGFyYWN0ZXJFcnJvclwiIHwgXCJOb01vZGlmaWNhdGlvbkFsbG93ZWRFcnJvclwiIHwgXCJOb3RGb3VuZEVycm9yXCIgfCBcIk5vdFN1cHBvcnRlZEVycm9yXCIgfCBcIkludmFsaWRTdGF0ZUVycm9yXCIgfCBcIkluVXNlQXR0cmlidXRlRXJyb3JcIiB8IFwiU3ludGF4RXJyb3JcIiB8IFwiSW52YWxpZE1vZGlmaWNhdGlvbkVycm9yXCIgfCBcIk5hbWVzcGFjZUVycm9yXCIgfCBcIkludmFsaWRBY2Nlc3NFcnJvclwiIHwgXCJUeXBlTWlzbWF0Y2hFcnJvclwiIHwgXCJTZWN1cml0eUVycm9yXCIgfCBcIk5ldHdvcmtFcnJvclwiIHwgXCJBYm9ydEVycm9yXCIgfCBcIlVSTE1pc21hdGNoRXJyb3JcIiB8IFwiUXVvdGFFeGNlZWRlZEVycm9yXCIgfCBcIlRpbWVvdXRFcnJvclwiIHwgXCJJbnZhbGlkTm9kZVR5cGVFcnJvclwiIHwgXCJEYXRhQ2xvbmVFcnJvclwiIHwgXCJFbmNvZGluZ0Vycm9yXCIgfCBcIk5vdFJlYWRhYmxlRXJyb3JcIiB8IFwiVW5rbm93bkVycm9yXCIgfCBcIkNvbnN0cmFpbnRFcnJvclwiIHwgXCJEYXRhRXJyb3JcIiB8IFwiVHJhbnNhY3Rpb25JbmFjdGl2ZUVycm9yXCIgfCBcIlJlYWRPbmx5RXJyb3JcIiB8IFwiVmVyc2lvbkVycm9yXCIgfCBcIk9wZXJhdGlvbkVycm9yXCIgfCBcIk5vdEFsbG93ZWRFcnJvclwiO1xuXG5leHBvcnQgY2xhc3MgRHJvcHBhYmxlRmlsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGZpbGVOYW1lOiBzdHJpbmc7XG4gICAgZXJyb3JUeXBlOiBEcm9wcGFibGVGaWxlRXJyb3JUeXBlO1xuXG4gICAgY29uc3RydWN0b3IoZmlsZU5hbWU6IHN0cmluZywgYmFzZTogRE9NRXhjZXB0aW9uIHwgbnVsbCkge1xuICAgICAgICBzdXBlcihiYXNlPy5tZXNzYWdlID8/IFwiQW4gdW5zcGVjaWZpZWQgZXJyb3Igb2NjdXJyZWQgcmVhZGluZyB0aGUgZmlsZS5cIik7XG4gICAgICAgIHRoaXMuZmlsZU5hbWUgPSBmaWxlTmFtZTtcbiAgICAgICAgdGhpcy5lcnJvclR5cGUgPSAoYmFzZT8ubmFtZSBhcyBEcm9wcGFibGVGaWxlRXJyb3JUeXBlKTtcbiAgICB9XG5cbn1cblxuXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEcm9wcGFibGU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZWZmZWN0IH06IFVzZURyb3BwYWJsZVBhcmFtZXRlcnMpOiBVc2VEcm9wcGFibGVSZXR1cm5UeXBlPEU+IHtcblxuICAgIGNvbnN0IFtmaWxlc0ZvckNvbnNpZGVyYXRpb24sIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbl0gPSB1c2VTdGF0ZTxudWxsIHwgRHJvcEZpbGVNZXRhZGF0YVtdPihudWxsKTtcbiAgICBjb25zdCBbc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uXSA9IHVzZVN0YXRlPG51bGwgfCBTZXQ8c3RyaW5nPj4obnVsbCk7XG5cbiAgICBjb25zdCBbZHJvcHBlZEZpbGVzLCBzZXREcm9wcGVkRmlsZXNdID0gdXNlU3RhdGU8bnVsbCB8IERyb3BGaWxlW10+KG51bGwpO1xuICAgIGNvbnN0IFtkcm9wcGVkU3RyaW5ncywgc2V0RHJvcHBlZFN0cmluZ3NdID0gdXNlU3RhdGU8bnVsbCB8IHsgW01pbWVUeXBlOiBzdHJpbmddOiBzdHJpbmcgfT4obnVsbCk7XG5cbiAgICBjb25zdCBbZHJvcEVycm9yLCBzZXREcm9wRXJyb3JdID0gdXNlU3RhdGU8dW5rbm93biB8IHVuZGVmaW5lZD4odW5kZWZpbmVkKTtcblxuICAgIC8vIEFsbCB0aGUgcHJvbWlzZXMgZ2VuZXJhdGVkIGZyb20gdGhlIGRyb3AgZXZlbnRzLlxuICAgIC8vIFVzZWQgdG8gcHJvY2VzcyBtdWx0aXBsZSBkcm9wIGV2ZW50cyBpbiBzdWNjZXNzaW9uXG4gICAgY29uc3QgZHJvcFByb21pc2VzUmVmID0gdXNlUmVmPFByb21pc2U8bnVsbCB8IHsgc3RyaW5nczogeyBbbWltZVR5cGU6IHN0cmluZ106IHN0cmluZyB9LCBmaWxlczogRHJvcEZpbGVbXSB9PltdPihbXSk7XG4gICAgY29uc3QgW2N1cnJlbnRQcm9taXNlSW5kZXgsIHNldEN1cnJlbnRQcm9taXNlSW5kZXgsIGdldEN1cnJlbnRQcm9taXNlSW5kZXhdID0gdXNlU3RhdGUoLTEpO1xuICAgIGNvbnN0IFtwcm9taXNlQ291bnQsIHNldFByb21pc2VDb3VudCwgZ2V0UHJvbWlzZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gICAgLy8gQW55IHRpbWUgd2UgYWRkIGEgbmV3IHByb21pc2UsIGlmIHRoZXJlJ3Mgbm8gY3VycmVudCBwcm9taXNlIHJ1bm5pbmcsIHdlIG5lZWQgdG8gc3RhcnQgb25lLlxuICAgIC8vIElmIHRoZXJlIGlzIG9uZSwgdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGRvIGFueXRoaW5nLCBzaW5jZSBpdCBydW5zIHRoZSBzYW1lIGNoZWNrLlxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlSW5kZXggPSBnZXRDdXJyZW50UHJvbWlzZUluZGV4KCk7XG4gICAgICAgIGNvbnN0IHByb21pc2VDb3VudCA9IGdldFByb21pc2VDb3VudCgpO1xuXG4gICAgICAgIGlmIChwcm9taXNlQ291bnQgPiAwKSB7XG4gICAgICAgICAgICBpZiAoKGN1cnJlbnRQcm9taXNlSW5kZXggKyAxKSA8IHByb21pc2VDb3VudCkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQcm9taXNlSW5kZXgoaSA9PiArK2kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9LCBbcHJvbWlzZUNvdW50XSk7XG5cbiAgICAvLyBBbnl0aW1lIG91ciBjdXJyZW50IHByb21pc2UgY2hhbmdlcyxcbiAgICAvLyB3YWl0IGZvciBpdCB0byBmaW5pc2gsIHRoZW4gc2V0IG91ciBzdGF0ZSB0byBpdHMgcmVzdWx0LlxuICAgIC8vIEZpbmFsbHksIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgYW55bW9yZSBwcm9taXNlcy5cbiAgICAvLyBJZiB0aGVyZSBhcmUsIHRoZW4gaW5jcmVhc2UgY3VycmVudFByb21pc2VDb3VudCxcbiAgICAvLyB3aGljaCB3aWxsIHRyaWdnZXIgdGhpcyBhZ2Fpbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGhhcHBlbiAqb2Z0ZW4qLCBidXQgbWF5YmUgaW4gdGhlIGNhc2Ugb2ZcbiAgICAvLyBpbmRpdmlkdWFsbHkgZHJvcHBpbmcgYSBidW5jaCBvZiBsYXJnZSBmaWxlcyBvciBzb21ldGhpbmcuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9taXNlSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFByb21pc2UgPSBkcm9wUHJvbWlzZXNSZWYuY3VycmVudFtjdXJyZW50UHJvbWlzZUluZGV4XTtcbiAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnRoZW4oKGluZm8pID0+IHtcblxuICAgICAgICAgICAgICAgIGlmIChpbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZmlsZXMsIHN0cmluZ3MgfSA9IGluZm87XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BwZWRGaWxlcyhmaWxlcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldERyb3BwZWRTdHJpbmdzKHN0cmluZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIE5vdyB0aGF0IHdlJ3JlIGRvbmUsIGFyZSB0aGVyZSBtb3JlIHByb21pc2VzIGluIHRoZSBxdWV1ZT9cblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlSW5kZXggPSBnZXRDdXJyZW50UHJvbWlzZUluZGV4KCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZUNvdW50ID0gZ2V0UHJvbWlzZUNvdW50KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoKGN1cnJlbnRQcm9taXNlSW5kZXggKyAxKSA8IHByb21pc2VDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGlzIHByb21pc2UgaGFzIHN0YXJ0ZWQsIG1vcmUgaGF2ZSBiZWVuIGFkZGVkLlxuICAgICAgICAgICAgICAgICAgICAvLyBSdW4gdGhpcyBlZmZlY3QgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnJlbnRQcm9taXNlSW5kZXgoaSA9PiArK2kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9LCBbY3VycmVudFByb21pc2VJbmRleF0pXG5cblxuICAgIGNvbnN0IHVzZURyb3BwYWJsZVByb3BzOiBVc2VEcm9wcGFibGVSZXR1cm5UeXBlPEU+W1widXNlRHJvcHBhYmxlUHJvcHNcIl0gPSAocCkgPT4ge1xuXG4gICAgICAgIC8vY29uc3QgcmVmID0gdXNlUmVmPEU+KG51bGwpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBjb2xsZWN0aW5nIHRoZSBjdXJyZW50IGZpbGUgbWV0YWRhdGEgb3IgTUlNRSB0eXBlcy5cbiAgICAgICAgY29uc3Qgb25EcmFnRW50ZXIgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBpZiAoZS5kYXRhVHJhbnNmZXIpIHtcblxuICAgICAgICAgICAgICAgIC8vIElzIHRoZXJlIGEgZGVmYXVsdD8gSSBjYW4ndCBmaW5kIG9uZSBhbnl3aGVyZS5cbiAgICAgICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gKGVmZmVjdCA/PyBcIm1vdmVcIik7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdNaW1lVHlwZXMgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdGaWxlcyA9IG5ldyBBcnJheTxEcm9wRmlsZU1ldGFkYXRhPigpO1xuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGUuZGF0YVRyYW5zZmVyPy5pdGVtcyA/PyBbXSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGtpbmQsIHR5cGUgfSA9IGl0ZW07XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtpbmQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld01pbWVUeXBlcy5hZGQodHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2luZCA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0ZpbGVzLnB1c2goeyB0eXBlOiBpdGVtLnR5cGUgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbihuZXdGaWxlcyk7XG4gICAgICAgICAgICAgICAgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb24obmV3TWltZVR5cGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBIYW5kbGUgcmVzZXR0aW5nIHRoZSBjdXJyZW50IGZpbGUgbWV0YWRhdGEgb3IgTUlNRSB0eXBlc1xuICAgICAgICBjb25zdCBvbkRyYWdMZWF2ZSA9IChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldEZpbGVzRm9yQ29uc2lkZXJhdGlvbihudWxsKTtcbiAgICAgICAgICAgIHNldFN0cmluZ3NGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEJvaWxlcnBsYXRlLCBJIGd1ZXNzXG4gICAgICAgIGNvbnN0IG9uRHJhZ092ZXIgPSAoZTogRHJhZ0V2ZW50KSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW5kbGUgZ2V0dGluZyB0aGUgZHJvcCBkYXRhIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIGNvbnN0IG9uRHJvcCA9IChlOiBEcmFnRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgICAgc2V0RmlsZXNGb3JDb25zaWRlcmF0aW9uKG51bGwpO1xuICAgICAgICAgICAgc2V0U3RyaW5nc0ZvckNvbnNpZGVyYXRpb24obnVsbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFsbFByb21pc2VzID0gbmV3IEFycmF5PFByb21pc2U8dW5rbm93bj4+KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGRyb3BEYXRhOiB7IFttaW1lVHlwZTogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGRyb3BGaWxlOiBEcm9wRmlsZVtdID0gW107XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBlLmRhdGFUcmFuc2Zlcj8uaXRlbXMgPz8gW10pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtpbmQsIHR5cGUgfSA9IGl0ZW07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2luZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBhbGxQcm9taXNlcy5wdXNoKChuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCBfcmVqZWN0KSA9PiBpdGVtLmdldEFzU3RyaW5nKHJlc29sdmUpKSkudGhlbihzdHIgPT4gZHJvcERhdGFbdHlwZV0gPSBzdHIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoa2luZCA9PT0gXCJmaWxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZSA9IGl0ZW0uZ2V0QXNGaWxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxQcm9taXNlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlci5vbmxvYWQgPSAoXykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IHJlYWRlci5yZXN1bHQgYXMgQXJyYXlCdWZmZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wRmlsZS5wdXNoKHsgZGF0YSwgbmFtZTogZmlsZS5uYW1lLCB0eXBlOiBmaWxlLnR5cGUsIHNpemU6IGRhdGEuYnl0ZUxlbmd0aCwgbGFzdE1vZGlmaWVkOiBmaWxlLmxhc3RNb2RpZmllZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSAoXykgPT4geyByZWplY3QobmV3IERyb3BwYWJsZUZpbGVFcnJvcihmaWxlLm5hbWUsIHJlYWRlci5lcnJvcikpOyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFkZXIub25hYm9ydCA9IChfKSA9PiB7IHJlamVjdChuZXcgRHJvcHBhYmxlRmlsZUVycm9yKGZpbGUubmFtZSwgcmVhZGVyLmVycm9yKSk7IH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0FycmF5QnVmZmVyKGZpbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEZpbGUucHVzaCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGRyb3BQcm9taXNlc1JlZi5jdXJyZW50LnB1c2goUHJvbWlzZS5hbGwoYWxsUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFByb21pc2VDb3VudChpID0+ICsraSk7XG4gICAgICAgICAgICAgICAgc2V0RHJvcEVycm9yKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ3M6IGRyb3BEYXRhLFxuICAgICAgICAgICAgICAgICAgICBmaWxlczogZHJvcEZpbGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChleCA9PiB7XG4gICAgICAgICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tZGVidWdnZXIgKi9cbiAgICAgICAgICAgICAgICBkZWJ1Z2dlcjtcbiAgICAgICAgICAgICAgICBzZXRQcm9taXNlQ291bnQoaSA9PiArK2kpO1xuICAgICAgICAgICAgICAgIHNldERyb3BFcnJvcihleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFPih7IG9uRHJhZ0VudGVyLCBvbkRyYWdMZWF2ZSwgb25EcmFnT3Zlciwgb25Ecm9wIH0sIHApO1xuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VEcm9wcGFibGVQcm9wcyxcbiAgICAgICAgZmlsZXNGb3JDb25zaWRlcmF0aW9uLFxuICAgICAgICBzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbixcbiAgICAgICAgZHJvcHBlZEZpbGVzLFxuICAgICAgICBkcm9wcGVkU3RyaW5ncyxcblxuICAgICAgICBkcm9wRXJyb3JcbiAgICB9XG59XG5cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+IHtcclxuICAgIC8qKiAqKlNUQUJMRSoqICovXHJcbiAgICBnZXRFbGVtZW50KCk6IFQgfCBudWxsO1xyXG4gICAgLyoqICoqU1RBQkxFKiogKi9cclxuICAgIHJlZkVsZW1lbnRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8VD47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnM8VD4ge1xyXG4gICAgb25FbGVtZW50Q2hhbmdlPzogT25QYXNzaXZlU3RhdGVDaGFuZ2U8VCB8IG51bGw+O1xyXG4gICAgb25Nb3VudD86IChlbGVtZW50OiBUKSA9PiB2b2lkO1xyXG4gICAgb25Vbm1vdW50PzogKGVsZW1lbnQ6IFQpID0+IHZvaWQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYWNjZXNzaW5nIHRoZSBlbGVtZW50IGEgcmVmIHJlZmVyZW5jZXMgYXMgc29vbiBhcyBpdCBkb2VzIHNvLlxyXG4gKiAqVGhpcyBob29rIGl0c2VsZiByZXR1cm5zIGEgaG9vayotLXVzZVJlZkVsZW1lbnRQcm9wcyBtb2RpZmllcyB0aGUgcHJvcHMgdGhhdCB5b3Ugd2VyZSBnb2luZyB0byBwYXNzIHRvIGFuIEhUTUxFbGVtZW50LCBcclxuICogYWRkaW5nIGEgUmVmQ2FsbGJhY2sgYW5kIG1lcmdpbmcgaXQgd2l0aCBhbnkgZXhpc3RpbmcgcmVmIHRoYXQgZXhpc3RlZCBvbiB0aGUgcHJvcHMuXHJcbiAqIFxyXG4gKiBEb24ndCBmb3JnZXQgdG8gcHJvdmlkZSB0aGUgRWxlbWVudCBhcyB0aGUgdHlwZSBhcmd1bWVudCFcclxuICogXHJcbiAqIEByZXR1cm5zIFRoZSBlbGVtZW50LCBhbmQgdGhlIHN1Yi1ob29rIHRoYXQgbWFrZXMgaXQgcmV0cmlldmFibGUuXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVmRWxlbWVudDxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+KGFyZ3M/OiBVc2VSZWZFbGVtZW50UGFyYW1ldGVyczxUPik6IFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlPFQ+IHtcclxuICAgIGNvbnN0IHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSA9IChhcmdzID8/IHt9KTtcclxuXHJcbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VSZWZFbGVtZW50XCIsIG9uRWxlbWVudENoYW5nZSwgb25Nb3VudCwgb25Vbm1vdW50KTtcclxuXHJcbiAgICAvLyBDYWxsZWQgKGluZGlyZWN0bHkpIGJ5IHRoZSByZWYgdGhhdCB0aGUgZWxlbWVudCByZWNlaXZlcy5cclxuICAgIGNvbnN0IGhhbmRsZXIgPSB1c2VDYWxsYmFjazxPblBhc3NpdmVTdGF0ZUNoYW5nZTxUIHwgbnVsbD4+KChlLCBwcmV2VmFsdWUpID0+IHtcclxuICAgICAgICBjb25zdCBjbGVhbnVwID0gb25FbGVtZW50Q2hhbmdlPy4oZSwgcHJldlZhbHVlKTtcclxuICAgICAgICBpZiAocHJldlZhbHVlKVxyXG4gICAgICAgICAgICBvblVubW91bnQ/LihwcmV2VmFsdWUhKTtcclxuXHJcbiAgICAgICAgaWYgKGUpXHJcbiAgICAgICAgICAgIG9uTW91bnQ/LihlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIGNsZWFudXA7XHJcbiAgICB9LCBbXSk7XHJcblxyXG4gICAgLy8gTGV0IHVzIHN0b3JlIHRoZSBhY3R1YWwgKHJlZmVyZW5jZSB0bykgdGhlIGVsZW1lbnQgd2UgY2FwdHVyZVxyXG4gICAgY29uc3QgW2dldEVsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlUGFzc2l2ZVN0YXRlPFQgfCBudWxsPihoYW5kbGVyLCByZXR1cm5OdWxsLCBydW5JbW1lZGlhdGVseSk7XHJcbiAgICBjb25zdCByZWZFbGVtZW50UHJvcHMgPSB7IHJlZjogc2V0RWxlbWVudCB9O1xyXG5cclxuICAgIC8vIFJldHVybiBib3RoIHRoZSBlbGVtZW50IGFuZCB0aGUgaG9vayB0aGF0IG1vZGlmaWVzIFxyXG4gICAgLy8gdGhlIHByb3BzIGFuZCBhbGxvd3MgdXMgdG8gYWN0dWFsbHkgZmluZCB0aGUgZWxlbWVudFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByZWZFbGVtZW50UHJvcHMsXHJcbiAgICAgICAgZ2V0RWxlbWVudFxyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBydW5JbW1lZGlhdGVseShmOiAoKSA9PiB2b2lkKSB7XHJcbiAgICBmKCk7XHJcbn1cclxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSBcIi4vdXNlLWRvY3VtZW50LWNsYXNzXCI7XG5pbXBvcnQgeyBPblBhc3NpdmVTdGF0ZUNoYW5nZSwgcmV0dXJuTnVsbCwgdXNlRW5zdXJlU3RhYmlsaXR5LCB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtcmVmLWVsZW1lbnRcIjtcblxuaW50ZXJmYWNlIFVzZUVsZW1lbnRTaXplUGFyYW1ldGVycyB7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGFueSB0aW1lIHRoZSBicm93c2VyIGRldGVjdHMgYSBzaXplIGNoYW5nZVxuICAgICAqIG9uIHRoZSBlbGVtZW50LiBEb2VzIG5vdCBuZWVkIHRvIGJlIHN0YWJsZSwgc28geW91XG4gICAgICogY2FuIHBhc3MgYW4gYW5vbnltb3VzIGZ1bmN0aW9uIHRoYXQgb25seSBzZXRzIHRoZVxuICAgICAqIHZhbHVlcyB5b3UgdXNlIGlmIHlvdSdkIGxpa2UuXG4gICAgICogQHBhcmFtIHNpemVJbmZvIFxuICAgICAqL1xuICAgIG9uU2l6ZUNoYW5nZShzaXplSW5mbzogRWxlbWVudFNpemUpOiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogUGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBjcmVhdGVkIFJlc2l6ZU9ic2VydmVyLlxuICAgICAqIFxuICAgICAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1Jlc2l6ZU9ic2VydmVyL29ic2VydmUjcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGdldE9ic2VydmVCb3g/KCk6IFJlc2l6ZU9ic2VydmVyT3B0aW9uc1tcImJveFwiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFbGVtZW50U2l6ZSB7XG4gICAgY2xpZW50V2lkdGg6IG51bWJlcjtcbiAgICBzY3JvbGxXaWR0aDogbnVtYmVyO1xuICAgIG9mZnNldFdpZHRoOiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50SGVpZ2h0OiBudW1iZXI7XG4gICAgc2Nyb2xsSGVpZ2h0OiBudW1iZXI7XG4gICAgb2Zmc2V0SGVpZ2h0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50TGVmdDogbnVtYmVyO1xuICAgIHNjcm9sbExlZnQ6IG51bWJlcjtcbiAgICBvZmZzZXRMZWZ0OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgY2xpZW50VG9wOiBudW1iZXI7XG4gICAgc2Nyb2xsVG9wOiBudW1iZXI7XG4gICAgb2Zmc2V0VG9wOiBudW1iZXIgfCB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRWxlbWVudFNpemVSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBnZXRFbGVtZW50KCk6IEUgfCBudWxsO1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgZ2V0U2l6ZSgpOiBFbGVtZW50U2l6ZSB8IG51bGw7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VFbGVtZW50U2l6ZVByb3BzOiBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxFPltcInVzZVJlZkVsZW1lbnRQcm9wc1wiXTtcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRWxlbWVudFNpemU8RSBleHRlbmRzIEVsZW1lbnQ+KHsgZ2V0T2JzZXJ2ZUJveCwgb25TaXplQ2hhbmdlIH06IFVzZUVsZW1lbnRTaXplUGFyYW1ldGVycyk6IFVzZUVsZW1lbnRTaXplUmV0dXJuVHlwZTxFPiB7XG5cbiAgICB1c2VFbnN1cmVTdGFiaWxpdHkoXCJ1c2VFbGVtZW50U2l6ZVwiLCBnZXRPYnNlcnZlQm94LCBvblNpemVDaGFuZ2UpO1xuXG4gICAgY29uc3QgW2dldFNpemUsIHNldFNpemVdID0gdXNlUGFzc2l2ZVN0YXRlPEVsZW1lbnRTaXplIHwgbnVsbD4ob25TaXplQ2hhbmdlIGFzIE9uUGFzc2l2ZVN0YXRlQ2hhbmdlPEVsZW1lbnRTaXplIHwgbnVsbD4sIHJldHVybk51bGwpO1xuXG4gICAgY29uc3QgY3VycmVudE9ic2VydmVCb3ggPSB1c2VSZWY8UmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHwgdW5kZWZpbmVkPih1bmRlZmluZWQpO1xuXG4gICAgY29uc3QgbmVlZEFOZXdPYnNlcnZlciA9IHVzZUNhbGxiYWNrKChlbGVtZW50OiBFIHwgbnVsbCwgb2JzZXJ2ZUJveDogUmVzaXplT2JzZXJ2ZXJCb3hPcHRpb25zIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IGdldERvY3VtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgd2luZG93ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGNsaWVudFdpZHRoLCBzY3JvbGxXaWR0aCwgb2Zmc2V0V2lkdGgsIGNsaWVudEhlaWdodCwgc2Nyb2xsSGVpZ2h0LCBvZmZzZXRIZWlnaHQsIGNsaWVudExlZnQsIHNjcm9sbExlZnQsIG9mZnNldExlZnQsIGNsaWVudFRvcCwgc2Nyb2xsVG9wLCBvZmZzZXRUb3AgfSA9IChlbGVtZW50IGFzIEVsZW1lbnQgJiBQYXJ0aWFsPEhUTUxFbGVtZW50Pik7XG4gICAgICAgICAgICAgICAgICAgIHNldFNpemUoeyBjbGllbnRXaWR0aCwgc2Nyb2xsV2lkdGgsIG9mZnNldFdpZHRoLCBjbGllbnRIZWlnaHQsIHNjcm9sbEhlaWdodCwgb2Zmc2V0SGVpZ2h0LCBjbGllbnRMZWZ0LCBzY3JvbGxMZWZ0LCBvZmZzZXRMZWZ0LCBjbGllbnRUb3AsIHNjcm9sbFRvcCwgb2Zmc2V0VG9wIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAod2luZG93ICYmIChcIlJlc2l6ZU9ic2VydmVyXCIgaW4gd2luZG93KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChfZW50cmllcykgPT4geyBoYW5kbGVVcGRhdGUoKTsgfSk7XG5cbiAgICAgICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQsIHsgYm94OiBvYnNlcnZlQm94IH0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgaGFuZGxlVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtdKVxuXG4gICAgY29uc3QgeyBnZXRFbGVtZW50LCByZWZFbGVtZW50UHJvcHMgfSA9IHVzZVJlZkVsZW1lbnQ8RT4oeyBvbkVsZW1lbnRDaGFuZ2U6IHVzZUNhbGxiYWNrKChlOiBFIHwgbnVsbCkgPT4gbmVlZEFOZXdPYnNlcnZlcihlLCBnZXRPYnNlcnZlQm94Py4oKSksIFtdKSB9KTtcblxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChnZXRPYnNlcnZlQm94KSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudE9ic2VydmVCb3guY3VycmVudCAhPT0gZ2V0T2JzZXJ2ZUJveCgpKVxuICAgICAgICAgICAgICAgIG5lZWRBTmV3T2JzZXJ2ZXIoZ2V0RWxlbWVudCgpLCBnZXRPYnNlcnZlQm94KCkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICBnZXRTaXplLFxuICAgICAgICB1c2VFbGVtZW50U2l6ZVByb3BzOiByZWZFbGVtZW50UHJvcHNcbiAgICB9XG5cblxufVxuIiwiaW1wb3J0IHsgaCwgUHJlYWN0RE9NQXR0cmlidXRlcyB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgdXNlZCB0byBzZWxlY3QgKmp1c3QqIHRoZSB0eXBlZCBhZGRFdmVudExpc3RlbmVyIFxyXG4gKiBhbmQgbm90IHRoZSBnZW5lcmljIFwiSSdsbCBhY2NlcHQgYW55IHN0cmluZyBhbmQgYW55IGhhbmRsZXJcIiBvbmUuXHJcbiAqIFxyXG4gKiBUT0RPOiBUaGlzIFwiXCJcIndvcmtzXCJcIlwiIGJ1dCBpdCdzIG5vdCBncmVhdCBhbmQgaW1wbGljaXRseSByZWxpZXMgb25cclxuICogbGliLmRvbS50cyBhbHdheXMgZ2l2ZWluZyB0aGUgdHdvIG92ZXJsb2FkcyBpbiB0aGUgc2FtZSBvcmRlciwgd2l0aCB0aGVcclxuICogdHlwZWQgb25lIGZpcnN0LiAqVGhhdCogcHJvYmFibHkgd29uJ3QgY2hhbmdlLCBidXQgaWYgbW9yZSBvdmVybG9hZHNcclxuICogYXJlIGV2ZXIgYWRkZWQgdGhpcyB3aWxsIG5lZWQgYWRqdXN0bWVudC5cclxuICogXHJcbiAqIFNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNTI3NjExNTYgZm9yIGhvdyBzZWxlY3RpbmcgdGhlIGNvcnJlY3Qgb3ZlcmxvYWQgd29ya3MuXHJcbiAqL1xyXG50eXBlIEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPFQ+ID1cclxuICAgIFQgZXh0ZW5kcyB7ICguLi5hcmdzOiBpbmZlciBSKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogaW5mZXIgUiB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgeyAoLi4uYXJnczogaW5mZXIgUik6IGFueTsgKC4uLmFyZ3M6IGFueVtdKTogYW55OyAoLi4uYXJnczogYW55W10pOiBhbnkgfSA/IFIgOlxyXG4gICAgVCBleHRlbmRzIHsgKC4uLmFyZ3M6IGluZmVyIFIpOiBhbnk7ICguLi5hcmdzOiBhbnlbXSk6IGFueSB9ID8gUiA6XHJcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFIpID0+IGFueSA/IFIgOiBbXTtcclxuXHJcbi8vIEdldCBqdXN0IHRoZSB0eXBlZCB2ZXJzaW9uIG9mIGFkZEV2ZW50TGlzdGVuZXIsIGlmIGl0IGV4aXN0c1xyXG50eXBlIFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxUIGV4dGVuZHMgRXZlbnRUYXJnZXQ+ID0gKC4uLmFyZ3M6IEZpcnN0T3ZlcmxvYWRQYXJhbWV0ZXJzPChUW1wiYWRkRXZlbnRMaXN0ZW5lclwiXSk+KSA9PiB2b2lkO1xyXG5cclxuLy8gUmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgb2YgXCJhZGRFdmVudExpc3RlbmVyXCIgKHRoZSBldmVudCB0eXBlIGFzIGEgc3RyaW5nKVxyXG50eXBlIFR5cGVkRXZlbnRMaXN0ZW5lclR5cGVzPFQgZXh0ZW5kcyBFdmVudFRhcmdldD4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8VD4gZXh0ZW5kcyAoKHR5cGU6IGluZmVyIEsyLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSA/IEsyIDogc3RyaW5nO1xyXG5cclxuXHJcbi8vIFRPRE86IFRoaXMgaXNuJ3QgcXVpdGUgYWJsZSB0byBuYXJyb3cgZG93biB0aGUgZXhhY3QgZXZlbnQgdHlwZSBmb3IgdW5rbm93biByZWFzb25zLlxyXG4vLyBJbnN0ZWFkIGl0IHJldHVybnMgYSB1bmlvbiBvZiBhbGwgYXZhaWxhYmxlIGV2ZW50IHR5cGVzLCB3aGljaCBpcy4uLmZpbmUsIEkgZ3Vlc3MuXHJcbi8vIEkgZG9uJ3Qga25vdyB3aHkgYGluZmVyIEhgIGlzIGRvaW5nIHRoYXQgd2hlbiB0aGUgdHlwZSBzaG91bGQgYmUgbmFycm93ZWQgYnkgYFRgIHRob3VnaC4uLlxyXG4vLyBOb3RlIHRoYXQgdGhlIHR5cGUgcGFyYW1ldGVyIGlzIHN0aWxsIHVzZWQsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3QgbmFycm93IGRvd24gdGhlIHR5cGUsXHJcbi8vIGJlY2F1c2Ugb3RoZXJ3aXNlLCBpbnN0ZWFkIG9mIGJlaW5nIGEgdW5pb24gb2YgYWxsIHR5cGVzLCBpdCdzIGp1c3QgYGFueWBcclxudHlwZSBUeXBlZEV2ZW50SGFuZGxlcjxFIGV4dGVuZHMgRXZlbnRUYXJnZXQsIFQgZXh0ZW5kcyBUeXBlZEV2ZW50TGlzdGVuZXJUeXBlczxFPj4gPSBUeXBlZEFkZEV2ZW50TGlzdGVuZXI8RT4gZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IGluZmVyIEgsIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gTm9uTnVsbGFibGU8SD4gOiBuZXZlcjtcclxuLy8oKFR5cGVkQWRkRXZlbnRMaXN0ZW5lcjxFPiAmICgodHlwZTogVCwgaGFuZGxlcjogKGU6IEV2ZW50KSA9PiB2b2lkLCAuLi5hcmdzOiBhbnlbXSkgPT4gYW55KSkgZXh0ZW5kcyAoKHR5cGU6IFQsIGhhbmRsZXI6IChlOiBpbmZlciBIKSA9PiBhbnksIC4uLmFyZ3M6IGFueVtdKSA9PiBhbnkpID8gSCA6IEZ1bmN0aW9uKSAvKiYgKFQgZXh0ZW5kcyBrZXlvZiBHbG9iYWxFdmVudEhhbmRsZXJzRXZlbnRNYXA/IEdsb2JhbEV2ZW50SGFuZGxlcnNFdmVudE1hcFtUXSA6IChlOiBFdmVudCkgPT4gdm9pZCkqLztcclxuXHJcbnR5cGUgUGFyYW1ldGVyczI8VCBleHRlbmRzIChFdmVudExpc3RlbmVyT2JqZWN0IHwgKCguLi5hcmdzOiBhbnkpID0+IGFueSkpPiA9XHJcbiAgICBUIGV4dGVuZHMgRXZlbnRMaXN0ZW5lck9iamVjdCA/IFBhcmFtZXRlcnM8VFtcImhhbmRsZUV2ZW50XCJdPiA6XHJcbiAgICBUIGV4dGVuZHMgKC4uLmFyZ3M6IGluZmVyIFApID0+IGFueSA/IFAgOiBuZXZlcjtcclxuXHJcblxyXG50eXBlIFR5cGVkRXZlbnRIYW5kbGVyRXZlbnQ8RSBleHRlbmRzIEV2ZW50VGFyZ2V0LCBUIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8RT4+ID0gUGFyYW1ldGVyczI8VHlwZWRFdmVudEhhbmRsZXI8RSwgVD4+WzBdO1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBbGxvd3MgYXR0YWNoaW5nIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW55ICpub24tUHJlYWN0KiBlbGVtZW50LCBhbmQgcmVtb3ZpbmcgaXQgd2hlbiB0aGUgY29tcG9uZW50IHVzaW5nIHRoZSBob29rIHVubW91bnRzLiBUaGUgY2FsbGJhY2sgZG9lcyBub3QgbmVlZCB0byBiZSBzdGFibGUgYWNyb3NzIHJlbmRlcnMuXHJcbiAqIFxyXG4gKiBEdWUgdG8gdHlwaW5nIGxpbWl0YXRpb25zLCB0aGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGxpa2UgdGhpczpcclxuICogXHJcbiAqIGB1c2VFdmVudEhhbmRsZXIoZWxlbWVudCwgXCJpbnB1dFwiKTxJbnB1dEV2ZW50PihlID0+IHt9KWBcclxuICogXHJcbiAqIFRoZSB0eXBlIGFyZ3VtZW50IGlzIG9wdGlvbmFsLCBidXQgbmFycm93cyBkb3duIHRoZSB0eXBlIGZyb20gXCJhIHVuaW9uIG9mIGFsbCBldmVudHNcIiB0byB3aGF0ZXZlciB5b3Ugc3BlY2lmeSwgYW5kIGVycm9ycyBpZiBpdCBkb2Vzbid0IGV4aXN0LlxyXG4gKiBcclxuICogVGhlcmUgaXMgYSBzZXBhcmF0ZSB2ZXJzaW9uIHRoYXQgYXR0YWNoZXMgZXZlbnQgaGFuZGxlcnMgdG8gYSBzZXQgb2YgcHJvcHMuIFxyXG4gKiBJdCB0YWtlcyBkaWZmZXJlbnQgZXZlbnQgc3RyaW5nIHR5cGVzIChvbkV2ZW50IHZzIG9uZXZlbnQpLlxyXG4gKiBcclxuICogQHBhcmFtIHRhcmdldCBBICpub24tUHJlYWN0KiBub2RlIHRvIGF0dGFjaCB0aGUgZXZlbnQgdG8uXHJcbiAqIEByZXR1cm5zXHJcbiAqICpcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1c2VHbG9iYWxIYW5kbGVyPFQgZXh0ZW5kcyBFdmVudFRhcmdldCwgRXZlbnRUeXBlIGV4dGVuZHMgVHlwZWRFdmVudExpc3RlbmVyVHlwZXM8VD4sIEggZXh0ZW5kcyBUeXBlZEV2ZW50SGFuZGxlckV2ZW50PFQsIEV2ZW50VHlwZT4+KHRhcmdldDogVCwgdHlwZTogRXZlbnRUeXBlLCBoYW5kbGVyOiBudWxsIHwgKChlOiBIKSA9PiB2b2lkKSwgb3B0aW9ucz86IFBhcmFtZXRlcnM8VHlwZWRBZGRFdmVudExpc3RlbmVyPFQ+PlsyXSk6IHZvaWQge1xyXG5cclxuICAgIC8vIE5vdGUgdG8gc2VsZjogVGhlIHR5cGluZyBkb2Vzbid0IGltcHJvdmUgZXZlbiBpZiB0aGlzIGlzIHNwbGl0IHVwIGludG8gYSBzdWItZnVuY3Rpb24uXHJcbiAgICAvLyBObyBtYXR0ZXIgd2hhdCwgaXQgc2VlbXMgaW1wb3NzaWJsZSB0byBnZXQgdGhlIGhhbmRsZXIncyBldmVudCBvYmplY3QgdHlwZWQgcGVyZmVjdGx5LlxyXG4gICAgLy8gSXQgc2VlbXMgbGlrZSBpdCdzIGd1YXJhbnRlZWQgdG8gYWx3YXlzIGJlIGEgdW5pb24gb2YgYWxsIGF2YWlsYWJsZSB0dXBlcy5cclxuICAgIC8vIEFnYWluLCBubyBtYXR0ZXIgd2hhdCBjb21iaW5hdGlvbiBvZiBzdWItIG9yIHN1Yi1zdWItZnVuY3Rpb25zIHVzZWQuXHJcblxyXG4gICAgbGV0IHN0YWJsZUhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgfCBudWxsID0gdXNlU3RhYmxlQ2FsbGJhY2soaGFuZGxlciA/PyAoKCkgPT4geyB9KSkgYXMgRXZlbnRMaXN0ZW5lcjtcclxuICAgIGlmIChoYW5kbGVyID09IG51bGwpXHJcbiAgICAgICAgc3RhYmxlSGFuZGxlciA9IG51bGw7XHJcblxyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoc3RhYmxlSGFuZGxlcikge1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBzdGFibGVIYW5kbGVyLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbdGFyZ2V0LCB0eXBlLCBzdGFibGVIYW5kbGVyXSk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBbiBhbHRlcm5hdGl2ZSB3YXkgdG8gYWRkIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZWxlbWVudC4gVXNlZnVsIHByaW1hcmlseSB3aGVuIGludGVncmF0aW5nIDNyZCBwYXJ0eSBsaWJyYXJpZXMgdGhhdCBleHBlY3QgYSBnZW5lcmljIFwiYWRkIGV2ZW50IGhhbmRsZXJcIiBmdW5jdGlvbi5cclxuICogXHJcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFsbG93cyB5b3UgdG8gbW9kaWZ5IGEgc2V0IG9mIHByb3BzIHRvIGFwcGx5IHRoaXMgaGFuZGxlci5cclxuICogXHJcbiAqIEZvciB0eXBpbmcgcmVhc29ucywgdGhpcyBmdW5jdGlvbiBpcyBzcGxpdCBpbnRvIHR3by4gIFVzYWdlIGlzIGxpa2UgdGhlIGZvbGxvd2luZzpcclxuICogXHJcbiAqIGBgYFxyXG4gKiBjb25zdCB7IHVzZUxvY2FsRXZlbnRIYW5kbGVyUHJvcHMgfSA9IHVzZUxvY2FsRXZlbnRIYW5kbGVyPEhUTUxEaXZFbGVtZW50PigpKFwib25Nb3VzZURvd25cIiwgZSA9PiB7ICB9KTtcclxuICogY29uc3QgZGl2UHJvcHMgPSB1c2VMb2NhbEV2ZW50SGFuZGxlclByb3BzKHByb3BzKTtcclxuICogYGBgXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gdXNlTG9jYWxIYW5kbGVyPEVsZW1lbnRUeXBlIGV4dGVuZHMgKEhUTUxFbGVtZW50VGFnTmFtZU1hcFtrZXlvZiBIVE1MRWxlbWVudFRhZ05hbWVNYXBdIHwgU1ZHRWxlbWVudFRhZ05hbWVNYXBba2V5b2YgU1ZHRWxlbWVudFRhZ05hbWVNYXBdKT4oKSB7XHJcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soPEV2ZW50VHlwZSBleHRlbmRzIEV4Y2x1ZGU8a2V5b2YgaC5KU1guRE9NQXR0cmlidXRlczxFbGVtZW50VHlwZT4sIGtleW9mIFByZWFjdERPTUF0dHJpYnV0ZXM+Pih0eXBlOiBFdmVudFR5cGUsIGhhbmRsZXI6IE5vbk51bGxhYmxlPGguSlNYLkRPTUF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+W0V2ZW50VHlwZV0+KSA9PiB7XHJcblxyXG4gICAgICAgIGNvbnN0IHN0YWJsZUhhbmRsZXIgPSB1c2VTdGFibGVDYWxsYmFjayhoYW5kbGVyKTtcclxuXHJcbiAgICAgICAgY29uc3QgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyA9IHVzZUNhbGxiYWNrKChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RWxlbWVudFR5cGU+KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB1c2VNZXJnZWRQcm9wczxFbGVtZW50VHlwZT4oeyBbdHlwZV06IHN0YWJsZUhhbmRsZXIgfSBhcyB7IFtLIGluIEV2ZW50VHlwZV06IHR5cGVvZiBoYW5kbGVyIH0sIHByb3BzKSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxFbGVtZW50VHlwZT47XHJcbiAgICAgICAgfSwgW3R5cGVdKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHsgdXNlTG9jYWxFdmVudEhhbmRsZXJQcm9wcyB9O1xyXG5cclxuICAgIH0sIFtdKTtcclxufVxyXG4iLCJjb25zdCBjYW5kaWRhdGVTZWxlY3RvcnMgPSBbXG4gICdpbnB1dCcsXG4gICdzZWxlY3QnLFxuICAndGV4dGFyZWEnLFxuICAnYVtocmVmXScsXG4gICdidXR0b24nLFxuICAnW3RhYmluZGV4XTpub3Qoc2xvdCknLFxuICAnYXVkaW9bY29udHJvbHNdJyxcbiAgJ3ZpZGVvW2NvbnRyb2xzXScsXG4gICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKScsXG4gICdkZXRhaWxzPnN1bW1hcnk6Zmlyc3Qtb2YtdHlwZScsXG4gICdkZXRhaWxzJyxcbl07XG5jb25zdCBjYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xuXG5jb25zdCBOb0VsZW1lbnQgPSB0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IG1hdGNoZXMgPSBOb0VsZW1lbnRcbiAgPyBmdW5jdGlvbiAoKSB7fVxuICA6IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgfHxcbiAgICBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgIEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuY29uc3QgZ2V0Um9vdE5vZGUgPVxuICAhTm9FbGVtZW50ICYmIEVsZW1lbnQucHJvdG90eXBlLmdldFJvb3ROb2RlXG4gICAgPyAoZWxlbWVudCkgPT4gZWxlbWVudC5nZXRSb290Tm9kZSgpXG4gICAgOiAoZWxlbWVudCkgPT4gZWxlbWVudC5vd25lckRvY3VtZW50O1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWwgY29udGFpbmVyIHRvIGNoZWNrIGluXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciB0byBjaGVja1xuICogQHBhcmFtIHsobm9kZTogRWxlbWVudCkgPT4gYm9vbGVhbn0gZmlsdGVyIGZpbHRlciBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyB7RWxlbWVudFtdfVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzID0gZnVuY3Rpb24gKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgbGV0IGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoXG4gICAgZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcilcbiAgKTtcbiAgaWYgKGluY2x1ZGVDb250YWluZXIgJiYgbWF0Y2hlcy5jYWxsKGVsLCBjYW5kaWRhdGVTZWxlY3RvcikpIHtcbiAgICBjYW5kaWRhdGVzLnVuc2hpZnQoZWwpO1xuICB9XG4gIGNhbmRpZGF0ZXMgPSBjYW5kaWRhdGVzLmZpbHRlcihmaWx0ZXIpO1xuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIEdldFNoYWRvd1Jvb3RcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCB0byBjaGVjayBmb3Igc2hhZG93IHJvb3RcbiAqIEByZXR1cm5zIHtTaGFkb3dSb290fGJvb2xlYW59IFNoYWRvd1Jvb3QgaWYgYXZhaWxhYmxlIG9yIGJvb2xlYW4gaW5kaWNhdGluZyBpZiBhIHNoYWRvd1Jvb3QgaXMgYXR0YWNoZWQgYnV0IG5vdCBhdmFpbGFibGUuXG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2hhZG93Um9vdEZpbHRlclxuICogQHBhcmFtIHtFbGVtZW50fSBzaGFkb3dIb3N0Tm9kZSB0aGUgZWxlbWVudCB3aGljaCBjb250YWlucyBzaGFkb3cgY29udGVudFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgYSBzaGFkb3cgcm9vdCBjb3VsZCBwb3RlbnRpYWxseSBjb250YWluIHZhbGlkIGNhbmRpZGF0ZXMuXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDYW5kaWRhdGVzU2NvcGVcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudH0gc2NvcGUgY29udGFpbnMgaW5uZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtFbGVtZW50W119IGNhbmRpZGF0ZXNcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEl0ZXJhdGl2ZU9wdGlvbnNcbiAqIEBwcm9wZXJ0eSB7R2V0U2hhZG93Um9vdHxib29sZWFufSBnZXRTaGFkb3dSb290IHRydWUgaWYgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZDsgZmFsc3kgaWYgbm90O1xuICogIGlmIGEgZnVuY3Rpb24sIGltcGxpZXMgc2hhZG93IHN1cHBvcnQgaXMgZW5hYmxlZCBhbmQgZWl0aGVyIHJldHVybnMgdGhlIHNoYWRvdyByb290IG9mIGFuIGVsZW1lbnRcbiAqICBvciBhIGJvb2xlYW4gc3RhdGluZyBpZiBpdCBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHJvb3RcbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHByb3BlcnR5IHtib29sZWFufSBmbGF0dGVuIGlmIHRydWUgdGhlbiByZXN1bHQgd2lsbCBmbGF0dGVuIGFueSBDYW5kaWRhdGVzU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgbGlzdCBvZiBlbGVtZW50IGNvbnRhaW5lcnMgdG8gbWF0Y2ggY2FuZGlkYXRlcyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVzU2NvcGU+fVxuICovXG5jb25zdCBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiAoXG4gIGVsZW1lbnRzLFxuICBpbmNsdWRlQ29udGFpbmVyLFxuICBvcHRpb25zXG4pIHtcbiAgY29uc3QgY2FuZGlkYXRlcyA9IFtdO1xuICBjb25zdCBlbGVtZW50c1RvQ2hlY2sgPSBBcnJheS5mcm9tKGVsZW1lbnRzKTtcbiAgd2hpbGUgKGVsZW1lbnRzVG9DaGVjay5sZW5ndGgpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1NMT1QnKSB7XG4gICAgICAvLyBhZGQgc2hhZG93IGRvbSBzbG90IHNjb3BlIChzbG90IGl0c2VsZiBjYW5ub3QgYmUgZm9jdXNhYmxlKVxuICAgICAgY29uc3QgYXNzaWduZWQgPSBlbGVtZW50LmFzc2lnbmVkRWxlbWVudHMoKTtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KGNvbnRlbnQsIHRydWUsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuZmxhdHRlbikge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goLi4ubmVzdGVkQ2FuZGlkYXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIHNjb3BlOiBlbGVtZW50LFxuICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgY29uc3QgdmFsaWRDYW5kaWRhdGUgPSBtYXRjaGVzLmNhbGwoZWxlbWVudCwgY2FuZGlkYXRlU2VsZWN0b3IpO1xuICAgICAgaWYgKFxuICAgICAgICB2YWxpZENhbmRpZGF0ZSAmJlxuICAgICAgICBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJlxuICAgICAgICAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpXG4gICAgICApIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICAvLyBpdGVyYXRlIG92ZXIgc2hhZG93IGNvbnRlbnQgaWYgcG9zc2libGVcbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPVxuICAgICAgICBlbGVtZW50LnNoYWRvd1Jvb3QgfHxcbiAgICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgICAodHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgIG9wdGlvbnMuZ2V0U2hhZG93Um9vdChlbGVtZW50KSk7XG5cbiAgICAgIGNvbnN0IHZhbGlkU2hhZG93Um9vdCA9XG4gICAgICAgICFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoc2hhZG93Um9vdCAmJiB2YWxpZFNoYWRvd1Jvb3QpIHtcbiAgICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2NvcGUgSUlGIGEgc2hhZG93IHJvb3Qgbm9kZSB3YXMgZ2l2ZW47IG90aGVyd2lzZSwgYW4gdW5kaXNjbG9zZWRcbiAgICAgICAgLy8gIHNoYWRvdyBleGlzdHMsIHNvIGxvb2sgYXQgbGlnaHQgZG9tIGNoaWxkcmVuIGFzIGZhbGxiYWNrIEJVVCBjcmVhdGUgYSBzY29wZSBmb3IgYW55XG4gICAgICAgIC8vICBjaGlsZCBjYW5kaWRhdGVzIGZvdW5kIGJlY2F1c2UgdGhleSdyZSBsaWtlbHkgc2xvdHRlZCBlbGVtZW50cyAoZWxlbWVudHMgdGhhdCBhcmVcbiAgICAgICAgLy8gIGNoaWxkcmVuIG9mIHRoZSB3ZWIgY29tcG9uZW50IGVsZW1lbnQgKHdoaWNoIGhhcyB0aGUgc2hhZG93KSwgaW4gdGhlIGxpZ2h0IGRvbSwgYnV0XG4gICAgICAgIC8vICBzbG90dGVkIHNvbWV3aGVyZSBfaW5zaWRlXyB0aGUgdW5kaXNjbG9zZWQgc2hhZG93KSAtLSB0aGUgc2NvcGUgaXMgY3JlYXRlZCBiZWxvdyxcbiAgICAgICAgLy8gIF9hZnRlcl8gd2UgcmV0dXJuIGZyb20gdGhpcyByZWN1cnNpdmUgY2FsbFxuICAgICAgICBjb25zdCBuZXN0ZWRDYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFxuICAgICAgICAgIHNoYWRvd1Jvb3QgPT09IHRydWUgPyBlbGVtZW50LmNoaWxkcmVuIDogc2hhZG93Um9vdC5jaGlsZHJlbixcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoKC4uLm5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbmRpZGF0ZXMucHVzaCh7XG4gICAgICAgICAgICBzY29wZTogZWxlbWVudCxcbiAgICAgICAgICAgIGNhbmRpZGF0ZXM6IG5lc3RlZENhbmRpZGF0ZXMsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHRoZXJlJ3Mgbm90IHNoYWRvdyBzbyBqdXN0IGRpZyBpbnRvIHRoZSBlbGVtZW50J3MgKGxpZ2h0IGRvbSkgY2hpbGRyZW5cbiAgICAgICAgLy8gIF9fd2l0aG91dF9fIGdpdmluZyB0aGUgZWxlbWVudCBzcGVjaWFsIHNjb3BlIHRyZWF0bWVudFxuICAgICAgICBlbGVtZW50c1RvQ2hlY2sudW5zaGlmdCguLi5lbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5jb25zdCBnZXRUYWJpbmRleCA9IGZ1bmN0aW9uIChub2RlLCBpc1Njb3BlKSB7XG4gIGlmIChub2RlLnRhYkluZGV4IDwgMCkge1xuICAgIC8vIGluIENocm9tZSwgPGRldGFpbHMvPiwgPGF1ZGlvIGNvbnRyb2xzLz4gYW5kIDx2aWRlbyBjb250cm9scy8+IGVsZW1lbnRzIGdldCBhIGRlZmF1bHRcbiAgICAvLyBgdGFiSW5kZXhgIG9mIC0xIHdoZW4gdGhlICd0YWJpbmRleCcgYXR0cmlidXRlIGlzbid0IHNwZWNpZmllZCBpbiB0aGUgRE9NLFxuICAgIC8vIHlldCB0aGV5IGFyZSBzdGlsbCBwYXJ0IG9mIHRoZSByZWd1bGFyIHRhYiBvcmRlcjsgaW4gRkYsIHRoZXkgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgMDsgc2luY2UgQ2hyb21lIHN0aWxsIHB1dHMgdGhvc2UgZWxlbWVudHMgaW4gdGhlIHJlZ3VsYXIgdGFiXG4gICAgLy8gb3JkZXIsIGNvbnNpZGVyIHRoZWlyIHRhYiBpbmRleCB0byBiZSAwLlxuICAgIC8vIEFsc28gYnJvd3NlcnMgZG8gbm90IHJldHVybiBgdGFiSW5kZXhgIGNvcnJlY3RseSBmb3IgY29udGVudEVkaXRhYmxlIG5vZGVzO1xuICAgIC8vIHNvIGlmIHRoZXkgZG9uJ3QgaGF2ZSBhIHRhYmluZGV4IGF0dHJpYnV0ZSBzcGVjaWZpY2FsbHkgc2V0LCBhc3N1bWUgaXQncyAwLlxuICAgIC8vXG4gICAgLy8gaXNTY29wZSBpcyBwb3NpdGl2ZSBmb3IgY3VzdG9tIGVsZW1lbnQgd2l0aCBzaGFkb3cgcm9vdCBvciBzbG90IHRoYXQgYnkgZGVmYXVsdFxuICAgIC8vIGhhdmUgdGFiSW5kZXggLTEsIGJ1dCBuZWVkIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgdGhlaXJcbiAgICAvLyBjb250ZW50IHRvIGJlIGluc2VydGVkIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uXG4gICAgaWYgKFxuICAgICAgKGlzU2NvcGUgfHxcbiAgICAgICAgL14oQVVESU98VklERU98REVUQUlMUykkLy50ZXN0KG5vZGUudGFnTmFtZSkgfHxcbiAgICAgICAgbm9kZS5pc0NvbnRlbnRFZGl0YWJsZSkgJiZcbiAgICAgIGlzTmFOKHBhcnNlSW50KG5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCkpXG4gICAgKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWJJbmRleDtcbn07XG5cbmNvbnN0IHNvcnRPcmRlcmVkVGFiYmFibGVzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXhcbiAgICA/IGEuZG9jdW1lbnRPcmRlciAtIGIuZG9jdW1lbnRPcmRlclxuICAgIDogYS50YWJJbmRleCAtIGIudGFiSW5kZXg7XG59O1xuXG5jb25zdCBpc0lucHV0ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUudGFnTmFtZSA9PT0gJ0lOUFVUJztcbn07XG5cbmNvbnN0IGlzSGlkZGVuSW5wdXQgPSBmdW5jdGlvbiAobm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdoaWRkZW4nO1xufTtcblxuY29uc3QgaXNEZXRhaWxzV2l0aFN1bW1hcnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICBjb25zdCByID1cbiAgICBub2RlLnRhZ05hbWUgPT09ICdERVRBSUxTJyAmJlxuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZVxuICAgICAgLmFwcGx5KG5vZGUuY2hpbGRyZW4pXG4gICAgICAuc29tZSgoY2hpbGQpID0+IGNoaWxkLnRhZ05hbWUgPT09ICdTVU1NQVJZJyk7XG4gIHJldHVybiByO1xufTtcblxuY29uc3QgZ2V0Q2hlY2tlZFJhZGlvID0gZnVuY3Rpb24gKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59O1xuXG5jb25zdCBpc1RhYmJhYmxlUmFkaW8gPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAoIW5vZGUubmFtZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIGNvbnN0IHF1ZXJ5UmFkaW9zID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgJ2lucHV0W3R5cGU9XCJyYWRpb1wiXVtuYW1lPVwiJyArIG5hbWUgKyAnXCJdJ1xuICAgICk7XG4gIH07XG5cbiAgbGV0IHJhZGlvU2V0O1xuICBpZiAoXG4gICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2Ygd2luZG93LkNTUy5lc2NhcGUgPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICdMb29rcyBsaWtlIHlvdSBoYXZlIGEgcmFkaW8gYnV0dG9uIHdpdGggYSBuYW1lIGF0dHJpYnV0ZSBjb250YWluaW5nIGludmFsaWQgQ1NTIHNlbGVjdG9yIGNoYXJhY3RlcnMgYW5kIG5lZWQgdGhlIENTUy5lc2NhcGUgcG9seWZpbGw6ICVzJyxcbiAgICAgICAgZXJyLm1lc3NhZ2VcbiAgICAgICk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgY2hlY2tlZCA9IGdldENoZWNrZWRSYWRpbyhyYWRpb1NldCwgbm9kZS5mb3JtKTtcbiAgcmV0dXJuICFjaGVja2VkIHx8IGNoZWNrZWQgPT09IG5vZGU7XG59O1xuXG5jb25zdCBpc1JhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzSW5wdXQobm9kZSkgJiYgbm9kZS50eXBlID09PSAncmFkaW8nO1xufTtcblxuY29uc3QgaXNOb25UYWJiYWJsZVJhZGlvID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgcmV0dXJuIGlzUmFkaW8obm9kZSkgJiYgIWlzVGFiYmFibGVSYWRpbyhub2RlKTtcbn07XG5cbi8vIGRldGVybWluZXMgaWYgYSBub2RlIGlzIHVsdGltYXRlbHkgYXR0YWNoZWQgdG8gdGhlIHdpbmRvdydzIGRvY3VtZW50XG5jb25zdCBpc05vZGVBdHRhY2hlZCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIC8vIFRoZSByb290IG5vZGUgaXMgdGhlIHNoYWRvdyByb290IGlmIHRoZSBub2RlIGlzIGluIGEgc2hhZG93IERPTTsgc29tZSBkb2N1bWVudCBvdGhlcndpc2VcbiAgLy8gIChidXQgTk9UIF90aGVfIGRvY3VtZW50OyBzZWUgc2Vjb25kICdJZicgY29tbWVudCBiZWxvdyBmb3IgbW9yZSkuXG4gIC8vIElmIHJvb3ROb2RlIGlzIHNoYWRvdyByb290LCBpdCdsbCBoYXZlIGEgaG9zdCwgd2hpY2ggaXMgdGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHNoYWRvd1xuICAvLyAgaXMgYXR0YWNoZWQsIGFuZCB0aGUgb25lIHdlIG5lZWQgdG8gY2hlY2sgaWYgaXQncyBpbiB0aGUgZG9jdW1lbnQgb3Igbm90IChiZWNhdXNlIHRoZVxuICAvLyAgc2hhZG93LCBhbmQgYWxsIG5vZGVzIGl0IGNvbnRhaW5zLCBpcyBuZXZlciBjb25zaWRlcmVkIGluIHRoZSBkb2N1bWVudCBzaW5jZSBzaGFkb3dzXG4gIC8vICBiZWhhdmUgbGlrZSBzZWxmLWNvbnRhaW5lZCBET01zOyBidXQgaWYgdGhlIHNoYWRvdydzIEhPU1QsIHdoaWNoIGlzIHBhcnQgb2YgdGhlIGRvY3VtZW50LFxuICAvLyAgaXMgaGlkZGVuLCBvciBpcyBub3QgaW4gdGhlIGRvY3VtZW50IGl0c2VsZiBidXQgaXMgZGV0YWNoZWQsIGl0IHdpbGwgYWZmZWN0IHRoZSBzaGFkb3cnc1xuICAvLyAgdmlzaWJpbGl0eSwgaW5jbHVkaW5nIGFsbCB0aGUgbm9kZXMgaXQgY29udGFpbnMpLiBUaGUgaG9zdCBjb3VsZCBiZSBhbnkgbm9ybWFsIG5vZGUsXG4gIC8vICBvciBhIGN1c3RvbSBlbGVtZW50IChpLmUuIHdlYiBjb21wb25lbnQpLiBFaXRoZXIgd2F5LCB0aGF0J3MgdGhlIG9uZSB0aGF0IGlzIGNvbnNpZGVyZWRcbiAgLy8gIHBhcnQgb2YgdGhlIGRvY3VtZW50LCBub3QgdGhlIHNoYWRvdyByb290LCBub3IgYW55IG9mIGl0cyBjaGlsZHJlbiAoaS5lLiB0aGUgbm9kZSBiZWluZ1xuICAvLyAgdGVzdGVkKS5cbiAgLy8gVG8gZnVydGhlciBjb21wbGljYXRlIHRoaW5ncywgd2UgaGF2ZSB0byBsb29rIGFsbCB0aGUgd2F5IHVwIHVudGlsIHdlIGZpbmQgYSBzaGFkb3cgSE9TVFxuICAvLyAgdGhhdCBpcyBhdHRhY2hlZCAob3IgZmluZCBub25lKSBiZWNhdXNlIHRoZSBub2RlIG1pZ2h0IGJlIGluIG5lc3RlZCBzaGFkb3dzLi4uXG4gIC8vIElmIHJvb3ROb2RlIGlzIG5vdCBhIHNoYWRvdyByb290LCBpdCB3b24ndCBoYXZlIGEgaG9zdCwgYW5kIHNvIHJvb3ROb2RlIHNob3VsZCBiZSB0aGVcbiAgLy8gIGRvY3VtZW50IChwZXIgdGhlIGRvY3MpIGFuZCB3aGlsZSBpdCdzIGEgRG9jdW1lbnQtdHlwZSBvYmplY3QsIHRoYXQgZG9jdW1lbnQgZG9lcyBub3RcbiAgLy8gIGFwcGVhciB0byBiZSB0aGUgc2FtZSBhcyB0aGUgbm9kZSdzIGBvd25lckRvY3VtZW50YCBmb3Igc29tZSByZWFzb24sIHNvIGl0J3Mgc2FmZXJcbiAgLy8gIHRvIGlnbm9yZSB0aGUgcm9vdE5vZGUgYXQgdGhpcyBwb2ludCwgYW5kIHVzZSBgbm9kZS5vd25lckRvY3VtZW50YC4gT3RoZXJ3aXNlLFxuICAvLyAgdXNpbmcgYHJvb3ROb2RlLmNvbnRhaW5zKG5vZGUpYCB3aWxsIF9hbHdheXNfIGJlIHRydWUgd2UnbGwgZ2V0IGZhbHNlLXBvc2l0aXZlcyB3aGVuXG4gIC8vICBub2RlIGlzIGFjdHVhbGx5IGRldGFjaGVkLlxuICBsZXQgbm9kZVJvb3RIb3N0ID0gZ2V0Um9vdE5vZGUobm9kZSkuaG9zdDtcbiAgbGV0IGF0dGFjaGVkID0gISEoXG4gICAgbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCkgfHxcbiAgICBub2RlLm93bmVyRG9jdW1lbnQuY29udGFpbnMobm9kZSlcbiAgKTtcblxuICB3aGlsZSAoIWF0dGFjaGVkICYmIG5vZGVSb290SG9zdCkge1xuICAgIC8vIHNpbmNlIGl0J3Mgbm90IGF0dGFjaGVkIGFuZCB3ZSBoYXZlIGEgcm9vdCBob3N0LCB0aGUgbm9kZSBNVVNUIGJlIGluIGEgbmVzdGVkIHNoYWRvdyBET00sXG4gICAgLy8gIHdoaWNoIG1lYW5zIHdlIG5lZWQgdG8gZ2V0IHRoZSBob3N0J3MgaG9zdCBhbmQgY2hlY2sgaWYgdGhhdCBwYXJlbnQgaG9zdCBpcyBjb250YWluZWRcbiAgICAvLyAgaW4gKGkuZS4gYXR0YWNoZWQgdG8pIHRoZSBkb2N1bWVudFxuICAgIG5vZGVSb290SG9zdCA9IGdldFJvb3ROb2RlKG5vZGVSb290SG9zdCkuaG9zdDtcbiAgICBhdHRhY2hlZCA9ICEhbm9kZVJvb3RIb3N0Py5vd25lckRvY3VtZW50LmNvbnRhaW5zKG5vZGVSb290SG9zdCk7XG4gIH1cblxuICByZXR1cm4gYXR0YWNoZWQ7XG59O1xuXG5jb25zdCBpc1plcm9BcmVhID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4gd2lkdGggPT09IDAgJiYgaGVpZ2h0ID09PSAwO1xufTtcbmNvbnN0IGlzSGlkZGVuID0gZnVuY3Rpb24gKG5vZGUsIHsgZGlzcGxheUNoZWNrLCBnZXRTaGFkb3dSb290IH0pIHtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBjb25zdCBpc0RpcmVjdFN1bW1hcnkgPSBtYXRjaGVzLmNhbGwobm9kZSwgJ2RldGFpbHM+c3VtbWFyeTpmaXJzdC1vZi10eXBlJyk7XG4gIGNvbnN0IG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKFxuICAgICFkaXNwbGF5Q2hlY2sgfHxcbiAgICBkaXNwbGF5Q2hlY2sgPT09ICdmdWxsJyB8fFxuICAgIGRpc3BsYXlDaGVjayA9PT0gJ2xlZ2FjeS1mdWxsJ1xuICApIHtcbiAgICBpZiAodHlwZW9mIGdldFNoYWRvd1Jvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIGZpZ3VyZSBvdXQgaWYgd2Ugc2hvdWxkIGNvbnNpZGVyIHRoZSBub2RlIHRvIGJlIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyBhbmQgdXNlIHRoZVxuICAgICAgLy8gICdub24temVyby1hcmVhJyBmYWxsYmFja1xuICAgICAgY29uc3Qgb3JpZ2luYWxOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEVsZW1lbnQgPSBub2RlLnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZ2V0Um9vdE5vZGUobm9kZSk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBwYXJlbnRFbGVtZW50ICYmXG4gICAgICAgICAgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJlxuICAgICAgICAgIGdldFNoYWRvd1Jvb3QocGFyZW50RWxlbWVudCkgPT09IHRydWUgLy8gY2hlY2sgaWYgdGhlcmUncyBhbiB1bmRpc2Nsb3NlZCBzaGFkb3dcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gbm9kZSBoYXMgYW4gdW5kaXNjbG9zZWQgc2hhZG93IHdoaWNoIG1lYW5zIHdlIGNhbiBvbmx5IHRyZWF0IGl0IGFzIGEgYmxhY2sgYm94LCBzbyB3ZVxuICAgICAgICAgIC8vICBmYWxsIGJhY2sgdG8gYSBub24temVyby1hcmVhIHRlc3RcbiAgICAgICAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgc2xvdFxuICAgICAgICAgIG5vZGUgPSBub2RlLmFzc2lnbmVkU2xvdDtcbiAgICAgICAgfSBlbHNlIGlmICghcGFyZW50RWxlbWVudCAmJiByb290Tm9kZSAhPT0gbm9kZS5vd25lckRvY3VtZW50KSB7XG4gICAgICAgICAgLy8gY3Jvc3Mgc2hhZG93IGJvdW5kYXJ5XG4gICAgICAgICAgbm9kZSA9IHJvb3ROb2RlLmhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaXRlcmF0ZSB1cCBub3JtYWwgZG9tXG4gICAgICAgICAgbm9kZSA9IHBhcmVudEVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG9yaWdpbmFsTm9kZTtcbiAgICB9XG4gICAgLy8gZWxzZSwgYGdldFNoYWRvd1Jvb3RgIG1pZ2h0IGJlIHRydWUsIGJ1dCBhbGwgdGhhdCBkb2VzIGlzIGVuYWJsZSBzaGFkb3cgRE9NIHN1cHBvcnRcbiAgICAvLyAgKGkuZS4gaXQgZG9lcyBub3QgYWxzbyBwcmVzdW1lIHRoYXQgYWxsIG5vZGVzIG1pZ2h0IGhhdmUgdW5kaXNjbG9zZWQgc2hhZG93cyk7IG9yXG4gICAgLy8gIGl0IG1pZ2h0IGJlIGEgZmFsc3kgdmFsdWUsIHdoaWNoIG1lYW5zIHNoYWRvdyBET00gc3VwcG9ydCBpcyBkaXNhYmxlZFxuXG4gICAgLy8gU2luY2Ugd2UgZGlkbid0IGZpbmQgaXQgc2l0dGluZyBpbiBhbiB1bmRpc2Nsb3NlZCBzaGFkb3cgKG9yIHNoYWRvd3MgYXJlIGRpc2FibGVkKVxuICAgIC8vICBub3cgd2UgY2FuIGp1c3QgdGVzdCB0byBzZWUgaWYgaXQgd291bGQgbm9ybWFsbHkgYmUgdmlzaWJsZSBvciBub3QsIHByb3ZpZGVkIGl0J3NcbiAgICAvLyAgYXR0YWNoZWQgdG8gdGhlIG1haW4gZG9jdW1lbnQuXG4gICAgLy8gTk9URTogV2UgbXVzdCBjb25zaWRlciBjYXNlIHdoZXJlIG5vZGUgaXMgaW5zaWRlIGEgc2hhZG93IERPTSBhbmQgZ2l2ZW4gZGlyZWN0bHkgdG9cbiAgICAvLyAgYGlzVGFiYmFibGUoKWAgb3IgYGlzRm9jdXNhYmxlKClgIC0tIHJlZ2FyZGxlc3Mgb2YgYGdldFNoYWRvd1Jvb3RgIG9wdGlvbiBzZXR0aW5nLlxuXG4gICAgaWYgKGlzTm9kZUF0dGFjaGVkKG5vZGUpKSB7XG4gICAgICAvLyB0aGlzIHdvcmtzIHdoZXJldmVyIHRoZSBub2RlIGlzOiBpZiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBjbGllbnQgcmVjdCwgaXQnc1xuICAgICAgLy8gIHNvbWVob3cgZGlzcGxheWVkOyBpdCBhbHNvIGNvdmVycyB0aGUgQ1NTICdkaXNwbGF5OiBjb250ZW50cycgY2FzZSB3aGVyZSB0aGVcbiAgICAgIC8vICBub2RlIGl0c2VsZiBpcyBoaWRkZW4gaW4gcGxhY2Ugb2YgaXRzIGNvbnRlbnRzOyBhbmQgdGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaFxuICAgICAgLy8gIHVwIHRoZSBoaWVyYXJjaHkgZWl0aGVyXG4gICAgICByZXR1cm4gIW5vZGUuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gRWxzZSwgdGhlIG5vZGUgaXNuJ3QgYXR0YWNoZWQgdG8gdGhlIGRvY3VtZW50LCB3aGljaCBtZWFucyB0aGUgYGdldENsaWVudFJlY3RzKClgXG4gICAgLy8gIEFQSSB3aWxsIF9fYWx3YXlzX18gcmV0dXJuIHplcm8gcmVjdHMgKHRoaXMgY2FuIGhhcHBlbiwgZm9yIGV4YW1wbGUsIGlmIFJlYWN0XG4gICAgLy8gIGlzIHVzZWQgdG8gcmVuZGVyIG5vZGVzIG9udG8gYSBkZXRhY2hlZCB0cmVlLCBhcyBjb25maXJtZWQgaW4gdGhpcyB0aHJlYWQ6XG4gICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvOTExNyNpc3N1ZWNvbW1lbnQtMjg0MjI4ODcwKVxuICAgIC8vXG4gICAgLy8gSXQgYWxzbyBtZWFucyB0aGF0IGV2ZW4gd2luZG93LmdldENvbXB1dGVkU3R5bGUobm9kZSkuZGlzcGxheSB3aWxsIHJldHVybiBgdW5kZWZpbmVkYFxuICAgIC8vICBiZWNhdXNlIHN0eWxlcyBhcmUgb25seSBjb21wdXRlZCBmb3Igbm9kZXMgdGhhdCBhcmUgaW4gdGhlIGRvY3VtZW50LlxuICAgIC8vXG4gICAgLy8gTk9URTogVEhJUyBIQVMgQkVFTiBUSEUgQ0FTRSBGT1IgWUVBUlMuIEl0IGlzIG5vdCBuZXcsIG5vciBpcyBpdCBjYXVzZWQgYnkgdGFiYmFibGVcbiAgICAvLyAgc29tZWhvdy4gVGhvdWdoIGl0IHdhcyBuZXZlciBzdGF0ZWQgb2ZmaWNpYWxseSwgYW55b25lIHdobyBoYXMgZXZlciB1c2VkIHRhYmJhYmxlXG4gICAgLy8gIEFQSXMgb24gbm9kZXMgaW4gZGV0YWNoZWQgY29udGFpbmVycyBoYXMgYWN0dWFsbHkgaW1wbGljaXRseSB1c2VkIHRhYmJhYmxlIGluIHdoYXRcbiAgICAvLyAgd2FzIGxhdGVyIChhcyBvZiB2NS4yLjAgb24gQXByIDksIDIwMjEpIGNhbGxlZCBgZGlzcGxheUNoZWNrPVwibm9uZVwiYCBtb2RlIC0tIGVzc2VudGlhbGx5XG4gICAgLy8gIGNvbnNpZGVyaW5nIF9fZXZlcnl0aGluZ19fIHRvIGJlIHZpc2libGUgYmVjYXVzZSBvZiB0aGUgaW5uYWJpbGl0eSB0byBkZXRlcm1pbmUgc3R5bGVzLlxuICAgIC8vXG4gICAgLy8gdjYuMC4wOiBBcyBvZiB0aGlzIG1ham9yIHJlbGVhc2UsIHRoZSBkZWZhdWx0ICdmdWxsJyBvcHRpb24gX19ubyBsb25nZXIgdHJlYXRzIGRldGFjaGVkXG4gICAgLy8gIG5vZGVzIGFzIHZpc2libGUgd2l0aCB0aGUgJ25vbmUnIGZhbGxiYWNrLl9fXG4gICAgaWYgKGRpc3BsYXlDaGVjayAhPT0gJ2xlZ2FjeS1mdWxsJykge1xuICAgICAgcmV0dXJuIHRydWU7IC8vIGhpZGRlblxuICAgIH1cbiAgICAvLyBlbHNlLCBmYWxsYmFjayB0byAnbm9uZScgbW9kZSBhbmQgY29uc2lkZXIgdGhlIG5vZGUgdmlzaWJsZVxuICB9IGVsc2UgaWYgKGRpc3BsYXlDaGVjayA9PT0gJ25vbi16ZXJvLWFyZWEnKSB7XG4gICAgLy8gTk9URTogRXZlbiB0aG91Z2ggdGhpcyB0ZXN0cyB0aGF0IHRoZSBub2RlJ3MgY2xpZW50IHJlY3QgaXMgbm9uLXplcm8gdG8gZGV0ZXJtaW5lXG4gICAgLy8gIHdoZXRoZXIgaXQncyBkaXNwbGF5ZWQsIGFuZCB0aGF0IGEgZGV0YWNoZWQgbm9kZSB3aWxsIF9fYWx3YXlzX18gaGF2ZSBhIHplcm8tYXJlYVxuICAgIC8vICBjbGllbnQgcmVjdCwgd2UgZG9uJ3Qgc3BlY2lhbC1jYXNlIGZvciB3aGV0aGVyIHRoZSBub2RlIGlzIGF0dGFjaGVkIG9yIG5vdC4gSW5cbiAgICAvLyAgdGhpcyBtb2RlLCB3ZSBkbyB3YW50IHRvIGNvbnNpZGVyIG5vZGVzIHRoYXQgaGF2ZSBhIHplcm8gYXJlYSB0byBiZSBoaWRkZW4gYXQgYWxsXG4gICAgLy8gIHRpbWVzLCBhbmQgdGhhdCBpbmNsdWRlcyBhdHRhY2hlZCBvciBub3QuXG4gICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gIH1cblxuICAvLyB2aXNpYmxlLCBhcyBmYXIgYXMgd2UgY2FuIHRlbGwsIG9yIHBlciBjdXJyZW50IGBkaXNwbGF5Q2hlY2s9bm9uZWAgbW9kZSwgd2UgYXNzdW1lXG4gIC8vICBpdCdzIHZpc2libGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLy8gZm9ybSBmaWVsZHMgKG5lc3RlZCkgaW5zaWRlIGEgZGlzYWJsZWQgZmllbGRzZXQgYXJlIG5vdCBmb2N1c2FibGUvdGFiYmFibGVcbi8vICB1bmxlc3MgdGhleSBhcmUgaW4gdGhlIF9maXJzdF8gPGxlZ2VuZD4gZWxlbWVudCBvZiB0aGUgdG9wLW1vc3QgZGlzYWJsZWRcbi8vICBmaWVsZHNldFxuY29uc3QgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIGlmICgvXihJTlBVVHxCVVRUT058U0VMRUNUfFRFWFRBUkVBKSQvLnRlc3Qobm9kZS50YWdOYW1lKSkge1xuICAgIGxldCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIC8vIGNoZWNrIGlmIGBub2RlYCBpcyBjb250YWluZWQgaW4gYSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgd2hpbGUgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmIChwYXJlbnROb2RlLnRhZ05hbWUgPT09ICdGSUVMRFNFVCcgJiYgcGFyZW50Tm9kZS5kaXNhYmxlZCkge1xuICAgICAgICAvLyBsb29rIGZvciB0aGUgZmlyc3QgPGxlZ2VuZD4gYW1vbmcgdGhlIGNoaWxkcmVuIG9mIHRoZSBkaXNhYmxlZCA8ZmllbGRzZXQ+XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50Tm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50Tm9kZS5jaGlsZHJlbi5pdGVtKGkpO1xuICAgICAgICAgIC8vIHdoZW4gdGhlIGZpcnN0IDxsZWdlbmQ+IChpbiBkb2N1bWVudCBvcmRlcikgaXMgZm91bmRcbiAgICAgICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0xFR0VORCcpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0cyBwYXJlbnQgPGZpZWxkc2V0PiBpcyBub3QgbmVzdGVkIGluIGFub3RoZXIgZGlzYWJsZWQgPGZpZWxkc2V0PixcbiAgICAgICAgICAgIC8vIHJldHVybiB3aGV0aGVyIGBub2RlYCBpcyBhIGRlc2NlbmRhbnQgb2YgaXRzIGZpcnN0IDxsZWdlbmQ+XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKHBhcmVudE5vZGUsICdmaWVsZHNldFtkaXNhYmxlZF0gKicpXG4gICAgICAgICAgICAgID8gdHJ1ZVxuICAgICAgICAgICAgICA6ICFjaGlsZC5jb250YWlucyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlIGRpc2FibGVkIDxmaWVsZHNldD4gY29udGFpbmluZyBgbm9kZWAgaGFzIG5vIDxsZWdlbmQ+XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH1cblxuICAvLyBlbHNlLCBub2RlJ3MgdGFiYmFibGUvZm9jdXNhYmxlIHN0YXRlIHNob3VsZCBub3QgYmUgYWZmZWN0ZWQgYnkgYSBmaWVsZHNldCdzXG4gIC8vICBlbmFibGVkL2Rpc2FibGVkIHN0YXRlXG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmNvbnN0IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgbm9kZS5kaXNhYmxlZCB8fFxuICAgIGlzSGlkZGVuSW5wdXQobm9kZSkgfHxcbiAgICBpc0hpZGRlbihub2RlLCBvcHRpb25zKSB8fFxuICAgIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICAgIGlzRGV0YWlsc1dpdGhTdW1tYXJ5KG5vZGUpIHx8XG4gICAgaXNEaXNhYmxlZEZyb21GaWVsZHNldChub2RlKVxuICApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiAob3B0aW9ucywgbm9kZSkge1xuICBpZiAoXG4gICAgaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8XG4gICAgZ2V0VGFiaW5kZXgobm9kZSkgPCAwIHx8XG4gICAgIWlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSlcbiAgKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIChzaGFkb3dIb3N0Tm9kZSkge1xuICBjb25zdCB0YWJJbmRleCA9IHBhcnNlSW50KHNoYWRvd0hvc3ROb2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApO1xuICBpZiAoaXNOYU4odGFiSW5kZXgpIHx8IHRhYkluZGV4ID49IDApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBJZiBhIGN1c3RvbSBlbGVtZW50IGhhcyBhbiBleHBsaWNpdCBuZWdhdGl2ZSB0YWJpbmRleCxcbiAgLy8gYnJvd3NlcnMgd2lsbCBub3QgYWxsb3cgdGFiIHRhcmdldGluZyBzYWlkIGVsZW1lbnQncyBjaGlsZHJlbi5cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5LjxFbGVtZW50fENhbmRpZGF0ZXNTY29wZT59IGNhbmRpZGF0ZXNcbiAqIEByZXR1cm5zIEVsZW1lbnRbXVxuICovXG5jb25zdCBzb3J0QnlPcmRlciA9IGZ1bmN0aW9uIChjYW5kaWRhdGVzKSB7XG4gIGNvbnN0IHJlZ3VsYXJUYWJiYWJsZXMgPSBbXTtcbiAgY29uc3Qgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICBjb25zdCBpc1Njb3BlID0gISFpdGVtLnNjb3BlO1xuICAgIGNvbnN0IGVsZW1lbnQgPSBpc1Njb3BlID8gaXRlbS5zY29wZSA6IGl0ZW07XG4gICAgY29uc3QgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRUYWJpbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IGlzU2NvcGUgPyBzb3J0QnlPcmRlcihpdGVtLmNhbmRpZGF0ZXMpIDogZWxlbWVudDtcbiAgICBpZiAoY2FuZGlkYXRlVGFiaW5kZXggPT09IDApIHtcbiAgICAgIGlzU2NvcGVcbiAgICAgICAgPyByZWd1bGFyVGFiYmFibGVzLnB1c2goLi4uZWxlbWVudHMpXG4gICAgICAgIDogcmVndWxhclRhYmJhYmxlcy5wdXNoKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcmRlcmVkVGFiYmFibGVzLnB1c2goe1xuICAgICAgICBkb2N1bWVudE9yZGVyOiBpLFxuICAgICAgICB0YWJJbmRleDogY2FuZGlkYXRlVGFiaW5kZXgsXG4gICAgICAgIGl0ZW06IGl0ZW0sXG4gICAgICAgIGlzU2NvcGU6IGlzU2NvcGUsXG4gICAgICAgIGNvbnRlbnQ6IGVsZW1lbnRzLFxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gb3JkZXJlZFRhYmJhYmxlc1xuICAgIC5zb3J0KHNvcnRPcmRlcmVkVGFiYmFibGVzKVxuICAgIC5yZWR1Y2UoKGFjYywgc29ydGFibGUpID0+IHtcbiAgICAgIHNvcnRhYmxlLmlzU2NvcGVcbiAgICAgICAgPyBhY2MucHVzaCguLi5zb3J0YWJsZS5jb250ZW50KVxuICAgICAgICA6IGFjYy5wdXNoKHNvcnRhYmxlLmNvbnRlbnQpO1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9LCBbXSlcbiAgICAuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcblxuY29uc3QgdGFiYmFibGUgPSBmdW5jdGlvbiAoZWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgbGV0IGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtlbF0sIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwge1xuICAgICAgZmlsdGVyOiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IGZhbHNlLFxuICAgICAgZ2V0U2hhZG93Um9vdDogb3B0aW9ucy5nZXRTaGFkb3dSb290LFxuICAgICAgc2hhZG93Um9vdEZpbHRlcjogaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhcbiAgICAgIGVsLFxuICAgICAgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLFxuICAgICAgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucylcbiAgICApO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG5cbmNvbnN0IGZvY3VzYWJsZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICBsZXQgY2FuZGlkYXRlcztcbiAgaWYgKG9wdGlvbnMuZ2V0U2hhZG93Um9vdCkge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoW2VsXSwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCB7XG4gICAgICBmaWx0ZXI6IGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKSxcbiAgICAgIGZsYXR0ZW46IHRydWUsXG4gICAgICBnZXRTaGFkb3dSb290OiBvcHRpb25zLmdldFNoYWRvd1Jvb3QsXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXMoXG4gICAgICBlbCxcbiAgICAgIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lcixcbiAgICAgIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUuYmluZChudWxsLCBvcHRpb25zKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gY2FuZGlkYXRlcztcbn07XG5cbmNvbnN0IGlzVGFiYmFibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBjYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5jb25zdCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvciA9IC8qICNfX1BVUkVfXyAqLyBjYW5kaWRhdGVTZWxlY3RvcnNcbiAgLmNvbmNhdCgnaWZyYW1lJylcbiAgLmpvaW4oJywnKTtcblxuY29uc3QgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiAobm9kZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG1hdGNoZXMuY2FsbChub2RlLCBmb2N1c2FibGVDYW5kaWRhdGVTZWxlY3RvcikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlKG9wdGlvbnMsIG5vZGUpO1xufTtcblxuZXhwb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgaXNGb2N1c2FibGUgfTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZSgnaW5lcnQnLCBmYWN0b3J5KSA6XG4gIChmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4gIC8qKlxuICAgKiBUaGlzIHdvcmsgaXMgbGljZW5zZWQgdW5kZXIgdGhlIFczQyBTb2Z0d2FyZSBhbmQgRG9jdW1lbnQgTGljZW5zZVxuICAgKiAoaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDE1L2NvcHlyaWdodC1zb2Z0d2FyZS1hbmQtZG9jdW1lbnQpLlxuICAgKi9cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFJldHVybiBlYXJseSBpZiB3ZSdyZSBub3QgcnVubmluZyBpbnNpZGUgb2YgdGhlIGJyb3dzZXIuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGNvbnZlcnRpbmcgTm9kZUxpc3RzLlxuICAgIC8qKiBAdHlwZSB7dHlwZW9mIEFycmF5LnByb3RvdHlwZS5zbGljZX0gKi9cbiAgICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgICAvKipcbiAgICAgKiBJRSBoYXMgYSBub24tc3RhbmRhcmQgbmFtZSBmb3IgXCJtYXRjaGVzXCIuXG4gICAgICogQHR5cGUge3R5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzfVxuICAgICAqL1xuICAgIHZhciBtYXRjaGVzID0gRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyB8fCBFbGVtZW50LnByb3RvdHlwZS5tc01hdGNoZXNTZWxlY3RvcjtcblxuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHZhciBfZm9jdXNhYmxlRWxlbWVudHNTdHJpbmcgPSBbJ2FbaHJlZl0nLCAnYXJlYVtocmVmXScsICdpbnB1dDpub3QoW2Rpc2FibGVkXSknLCAnc2VsZWN0Om5vdChbZGlzYWJsZWRdKScsICd0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSknLCAnYnV0dG9uOm5vdChbZGlzYWJsZWRdKScsICdkZXRhaWxzJywgJ3N1bW1hcnknLCAnaWZyYW1lJywgJ29iamVjdCcsICdlbWJlZCcsICdbY29udGVudGVkaXRhYmxlXSddLmpvaW4oJywnKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydFJvb3RgIG1hbmFnZXMgYSBzaW5nbGUgaW5lcnQgc3VidHJlZSwgaS5lLiBhIERPTSBzdWJ0cmVlIHdob3NlIHJvb3QgZWxlbWVudCBoYXMgYW4gYGluZXJ0YFxuICAgICAqIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEl0cyBtYWluIGZ1bmN0aW9ucyBhcmU6XG4gICAgICpcbiAgICAgKiAtIHRvIGNyZWF0ZSBhbmQgbWFpbnRhaW4gYSBzZXQgb2YgbWFuYWdlZCBgSW5lcnROb2RlYHMsIGluY2x1ZGluZyB3aGVuIG11dGF0aW9ucyBvY2N1ciBpbiB0aGVcbiAgICAgKiAgIHN1YnRyZWUuIFRoZSBgbWFrZVN1YnRyZWVVbmZvY3VzYWJsZSgpYCBtZXRob2QgaGFuZGxlcyBjb2xsZWN0aW5nIGBJbmVydE5vZGVgcyB2aWEgcmVnaXN0ZXJpbmdcbiAgICAgKiAgIGVhY2ggZm9jdXNhYmxlIG5vZGUgaW4gdGhlIHN1YnRyZWUgd2l0aCB0aGUgc2luZ2xldG9uIGBJbmVydE1hbmFnZXJgIHdoaWNoIG1hbmFnZXMgYWxsIGtub3duXG4gICAgICogICBmb2N1c2FibGUgbm9kZXMgd2l0aGluIGluZXJ0IHN1YnRyZWVzLiBgSW5lcnRNYW5hZ2VyYCBlbnN1cmVzIHRoYXQgYSBzaW5nbGUgYEluZXJ0Tm9kZWBcbiAgICAgKiAgIGluc3RhbmNlIGV4aXN0cyBmb3IgZWFjaCBmb2N1c2FibGUgbm9kZSB3aGljaCBoYXMgYXQgbGVhc3Qgb25lIGluZXJ0IHJvb3QgYXMgYW4gYW5jZXN0b3IuXG4gICAgICpcbiAgICAgKiAtIHRvIG5vdGlmeSBhbGwgbWFuYWdlZCBgSW5lcnROb2RlYHMgd2hlbiB0aGlzIHN1YnRyZWUgc3RvcHMgYmVpbmcgaW5lcnQgKGkuZS4gd2hlbiB0aGUgYGluZXJ0YFxuICAgICAqICAgYXR0cmlidXRlIGlzIHJlbW92ZWQgZnJvbSB0aGUgcm9vdCBub2RlKS4gVGhpcyBpcyBoYW5kbGVkIGluIHRoZSBkZXN0cnVjdG9yLCB3aGljaCBjYWxscyB0aGVcbiAgICAgKiAgIGBkZXJlZ2lzdGVyYCBtZXRob2Qgb24gYEluZXJ0TWFuYWdlcmAgZm9yIGVhY2ggbWFuYWdlZCBpbmVydCBub2RlLlxuICAgICAqL1xuXG4gICAgdmFyIEluZXJ0Um9vdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IHJvb3RFbGVtZW50IFRoZSBIVE1MRWxlbWVudCBhdCB0aGUgcm9vdCBvZiB0aGUgaW5lcnQgc3VidHJlZS5cbiAgICAgICAqIEBwYXJhbSB7IUluZXJ0TWFuYWdlcn0gaW5lcnRNYW5hZ2VyIFRoZSBnbG9iYWwgc2luZ2xldG9uIEluZXJ0TWFuYWdlciBvYmplY3QuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Um9vdChyb290RWxlbWVudCwgaW5lcnRNYW5hZ2VyKSB7XG4gICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbmVydFJvb3QpO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgICAgdGhpcy5faW5lcnRNYW5hZ2VyID0gaW5lcnRNYW5hZ2VyO1xuXG4gICAgICAgIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL1xuICAgICAgICB0aGlzLl9yb290RWxlbWVudCA9IHJvb3RFbGVtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7IVNldDwhSW5lcnROb2RlPn1cbiAgICAgICAgICogQWxsIG1hbmFnZWQgZm9jdXNhYmxlIG5vZGVzIGluIHRoaXMgSW5lcnRSb290J3Mgc3VidHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX21hbmFnZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAgICAgICAvLyBNYWtlIHRoZSBzdWJ0cmVlIGhpZGRlbiBmcm9tIGFzc2lzdGl2ZSB0ZWNobm9sb2d5XG4gICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJykpIHtcbiAgICAgICAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgICAgICAgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuID0gdGhpcy5fcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NhdmVkQXJpYUhpZGRlbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG5cbiAgICAgICAgLy8gTWFrZSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIGluIHRoZSBzdWJ0cmVlIHVuZm9jdXNhYmxlIGFuZCBhZGQgdGhlbSB0byBfbWFuYWdlZE5vZGVzXG4gICAgICAgIHRoaXMuX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUodGhpcy5fcm9vdEVsZW1lbnQpO1xuXG4gICAgICAgIC8vIFdhdGNoIGZvcjpcbiAgICAgICAgLy8gLSBhbnkgYWRkaXRpb25zIGluIHRoZSBzdWJ0cmVlOiBtYWtlIHRoZW0gdW5mb2N1c2FibGUgdG9vXG4gICAgICAgIC8vIC0gYW55IHJlbW92YWxzIGZyb20gdGhlIHN1YnRyZWU6IHJlbW92ZSB0aGVtIGZyb20gdGhpcyBpbmVydCByb290J3MgbWFuYWdlZCBub2Rlc1xuICAgICAgICAvLyAtIGF0dHJpYnV0ZSBjaGFuZ2VzOiBpZiBgdGFiaW5kZXhgIGlzIGFkZGVkLCBvciByZW1vdmVkIGZyb20gYW4gaW50cmluc2ljYWxseSBmb2N1c2FibGVcbiAgICAgICAgLy8gICBlbGVtZW50LCBtYWtlIHRoYXQgbm9kZSBhIG1hbmFnZWQgbm9kZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9vbk11dGF0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX3Jvb3RFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSwgc3VidHJlZTogdHJ1ZSB9KTtcbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiAgVGhpcyB1bndpbmRzIGFsbCBvZiB0aGUgc3RhdGVcbiAgICAgICAqIHN0b3JlZCBpbiB0aGlzIG9iamVjdCBhbmQgdXBkYXRlcyB0aGUgc3RhdGUgb2YgYWxsIG9mIHRoZSBtYW5hZ2VkIG5vZGVzLlxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0Um9vdCwgW3tcbiAgICAgICAga2V5OiAnZGVzdHJ1Y3RvcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cnVjdG9yKCkge1xuICAgICAgICAgIHRoaXMuX29ic2VydmVyLmRpc2Nvbm5lY3QoKTtcblxuICAgICAgICAgIGlmICh0aGlzLl9yb290RWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkQXJpYUhpZGRlbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aGlzLl9yb290RWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdGhpcy5fc2F2ZWRBcmlhSGlkZGVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuX3Jvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5lcnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl91bm1hbmFnZU5vZGUoaW5lcnROb2RlLm5vZGUpO1xuICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgLy8gTm90ZSB3ZSBjYXN0IHRoZSBudWxscyB0byB0aGUgQU5ZIHR5cGUgaGVyZSBiZWNhdXNlOlxuICAgICAgICAgIC8vIDEpIFdlIHdhbnQgdGhlIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZGVjbGFyZWQgYXMgbm9uLW51bGwsIG9yIGVsc2Ugd2VcbiAgICAgICAgICAvLyAgICBuZWVkIGV2ZW4gbW9yZSBjYXN0cyB0aHJvdWdob3V0IHRoaXMgY29kZS4gQWxsIGJldHMgYXJlIG9mZiBpZiBhblxuICAgICAgICAgIC8vICAgIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCBhbmQgYSBtZXRob2QgaXMgY2FsbGVkLlxuICAgICAgICAgIC8vIDIpIFdlIGRvbid0IHdhbnQgdG8gY2FzdCBcInRoaXNcIiwgYmVjYXVzZSB3ZSB3YW50IHR5cGUtYXdhcmUgb3B0aW1pemF0aW9uc1xuICAgICAgICAgIC8vICAgIHRvIGtub3cgd2hpY2ggcHJvcGVydGllcyB3ZSdyZSBzZXR0aW5nLlxuICAgICAgICAgIHRoaXMuX29ic2VydmVyID0gLyoqIEB0eXBlIHs/fSAqL251bGw7XG4gICAgICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJuIHshU2V0PCFJbmVydE5vZGU+fSBBIGNvcHkgb2YgdGhpcyBJbmVydFJvb3QncyBtYW5hZ2VkIG5vZGVzIHNldC5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX21ha2VTdWJ0cmVlVW5mb2N1c2FibGUnLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3VidHJlZVVuZm9jdXNhYmxlKHN0YXJ0Tm9kZSkge1xuICAgICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgICAgY29tcG9zZWRUcmVlV2FsayhzdGFydE5vZGUsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl92aXNpdE5vZGUobm9kZSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnMoc3RhcnROb2RlKSkge1xuICAgICAgICAgICAgLy8gc3RhcnROb2RlIG1heSBiZSBpbiBzaGFkb3cgRE9NLCBzbyBmaW5kIGl0cyBuZWFyZXN0IHNoYWRvd1Jvb3QgdG8gZ2V0IHRoZSBhY3RpdmVFbGVtZW50LlxuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgICAgICAvKiogQHR5cGUgeyFTaGFkb3dSb290fHVuZGVmaW5lZH0gKi9cbiAgICAgICAgICAgIHZhciByb290ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJvb3QgPSAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqL25vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyb290KSB7XG4gICAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgPSByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGFydE5vZGUuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuYmx1cigpO1xuICAgICAgICAgICAgLy8gSW4gSUUxMSwgaWYgYW4gZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQsIGFuZCB0aGVuIHNldCB0byB0YWJpbmRleD0tMVxuICAgICAgICAgICAgLy8gY2FsbGluZyBibHVyKCkgd2lsbCBub3QgYWN0dWFsbHkgbW92ZSB0aGUgZm9jdXMuXG4gICAgICAgICAgICAvLyBUbyB3b3JrIGFyb3VuZCB0aGlzIHdlIGNhbGwgZm9jdXMoKSBvbiB0aGUgYm9keSBpbnN0ZWFkLlxuICAgICAgICAgICAgaWYgKGFjdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ192aXNpdE5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3Zpc2l0Tm9kZShub2RlKSB7XG4gICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovbm9kZTtcblxuICAgICAgICAgIC8vIElmIGEgZGVzY2VuZGFudCBpbmVydCByb290IGJlY29tZXMgdW4taW5lcnQsIGl0cyBkZXNjZW5kYW50cyB3aWxsIHN0aWxsIGJlIGluZXJ0IGJlY2F1c2Ugb2ZcbiAgICAgICAgICAvLyB0aGlzIGluZXJ0IHJvb3QsIHNvIGFsbCBvZiBpdHMgbWFuYWdlZCBub2RlcyBuZWVkIHRvIGJlIGFkb3B0ZWQgYnkgdGhpcyBJbmVydFJvb3QuXG4gICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIGVsZW1lbnQuaGFzQXR0cmlidXRlKCdpbmVydCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdChlbGVtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykgfHwgZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoZWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19tYW5hZ2VOb2RlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYW5hZ2VOb2RlKG5vZGUpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5faW5lcnRNYW5hZ2VyLnJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlcy5hZGQoaW5lcnROb2RlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVbnJlZ2lzdGVyIHRoZSBnaXZlbiBub2RlIHdpdGggdGhpcyBJbmVydFJvb3QgYW5kIHdpdGggSW5lcnRNYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ191bm1hbmFnZU5vZGUnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gX3VubWFuYWdlTm9kZShub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0Tm9kZSA9IHRoaXMuX2luZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKG5vZGUsIHRoaXMpO1xuICAgICAgICAgIGlmIChpbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10oaW5lcnROb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5yZWdpc3RlciB0aGUgZW50aXJlIHN1YnRyZWUgc3RhcnRpbmcgYXQgYHN0YXJ0Tm9kZWAuXG4gICAgICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdfdW5tYW5hZ2VTdWJ0cmVlJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91bm1hbmFnZVN1YnRyZWUoc3RhcnROb2RlKSB7XG4gICAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHN0YXJ0Tm9kZSwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczMuX3VubWFuYWdlTm9kZShub2RlKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIGRlc2NlbmRhbnQgbm9kZSBpcyBmb3VuZCB3aXRoIGFuIGBpbmVydGAgYXR0cmlidXRlLCBhZG9wdCBpdHMgbWFuYWdlZCBub2Rlcy5cbiAgICAgICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnX2Fkb3B0SW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZG9wdEluZXJ0Um9vdChub2RlKSB7XG4gICAgICAgICAgdmFyIGluZXJ0U3Vicm9vdCA9IHRoaXMuX2luZXJ0TWFuYWdlci5nZXRJbmVydFJvb3Qobm9kZSk7XG5cbiAgICAgICAgICAvLyBEdXJpbmcgaW5pdGlhbGlzYXRpb24gdGhpcyBpbmVydCByb290IG1heSBub3QgaGF2ZSBiZWVuIHJlZ2lzdGVyZWQgeWV0LFxuICAgICAgICAgIC8vIHNvIHJlZ2lzdGVyIGl0IG5vdyBpZiBuZWVkIGJlLlxuICAgICAgICAgIGlmICghaW5lcnRTdWJyb290KSB7XG4gICAgICAgICAgICB0aGlzLl9pbmVydE1hbmFnZXIuc2V0SW5lcnQobm9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGluZXJ0U3Vicm9vdC5tYW5hZ2VkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAoc2F2ZWRJbmVydE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUoc2F2ZWRJbmVydE5vZGUubm9kZSk7XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgdXNlZCB3aGVuIG11dGF0aW9uIG9ic2VydmVyIGRldGVjdHMgc3VidHJlZSBhZGRpdGlvbnMsIHJlbW92YWxzLCBvciBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbk11dGF0aW9uJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbk11dGF0aW9uKHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICByZWNvcmRzLmZvckVhY2goZnVuY3Rpb24gKHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3JlY29yZC50YXJnZXQ7XG4gICAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgIC8vIE1hbmFnZSBhZGRlZCBub2Rlc1xuICAgICAgICAgICAgICBzbGljZS5jYWxsKHJlY29yZC5hZGRlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFrZVN1YnRyZWVVbmZvY3VzYWJsZShub2RlKTtcbiAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgLy8gVW4tbWFuYWdlIHJlbW92ZWQgbm9kZXNcbiAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQucmVtb3ZlZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdW5tYW5hZ2VTdWJ0cmVlKG5vZGUpO1xuICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09ICdhdHRyaWJ1dGVzJykge1xuICAgICAgICAgICAgICBpZiAocmVjb3JkLmF0dHJpYnV0ZU5hbWUgPT09ICd0YWJpbmRleCcpIHtcbiAgICAgICAgICAgICAgICAvLyBSZS1pbml0aWFsaXNlIGluZXJ0IG5vZGUgaWYgdGFiaW5kZXggY2hhbmdlc1xuICAgICAgICAgICAgICAgIHRoaXMuX21hbmFnZU5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0YXJnZXQgIT09IHRoaXMuX3Jvb3RFbGVtZW50ICYmIHJlY29yZC5hdHRyaWJ1dGVOYW1lID09PSAnaW5lcnQnICYmIHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhIG5ldyBpbmVydCByb290IGlzIGFkZGVkLCBhZG9wdCBpdHMgbWFuYWdlZCBub2RlcyBhbmQgbWFrZSBzdXJlIGl0IGtub3dzIGFib3V0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgbWFuYWdlZCBub2RlcyBmcm9tIHRoaXMgaW5lcnQgc3Vicm9vdC5cbiAgICAgICAgICAgICAgICB0aGlzLl9hZG9wdEluZXJ0Um9vdCh0YXJnZXQpO1xuICAgICAgICAgICAgICAgIHZhciBpbmVydFN1YnJvb3QgPSB0aGlzLl9pbmVydE1hbmFnZXIuZ2V0SW5lcnRSb290KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZWROb2RlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmNvbnRhaW5zKG1hbmFnZWROb2RlLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZXJ0U3Vicm9vdC5fbWFuYWdlTm9kZShtYW5hZ2VkTm9kZS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ21hbmFnZWROb2RlcycsXG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX21hbmFnZWROb2Rlcyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdoYXNTYXZlZEFyaWFIaWRkZW4nLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRBcmlhSGlkZGVuICE9PSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P3N0cmluZ30gYXJpYUhpZGRlbiAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ3NhdmVkQXJpYUhpZGRlbicsXG4gICAgICAgIHNldDogZnVuY3Rpb24gc2V0KGFyaWFIaWRkZW4pIHtcbiAgICAgICAgICB0aGlzLl9zYXZlZEFyaWFIaWRkZW4gPSBhcmlhSGlkZGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9zdHJpbmd9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NhdmVkQXJpYUhpZGRlbjtcbiAgICAgICAgfVxuICAgICAgfV0pO1xuXG4gICAgICByZXR1cm4gSW5lcnRSb290O1xuICAgIH0oKTtcblxuICAgIC8qKlxuICAgICAqIGBJbmVydE5vZGVgIGluaXRpYWxpc2VzIGFuZCBtYW5hZ2VzIGEgc2luZ2xlIGluZXJ0IG5vZGUuXG4gICAgICogQSBub2RlIGlzIGluZXJ0IGlmIGl0IGlzIGEgZGVzY2VuZGFudCBvZiBvbmUgb3IgbW9yZSBpbmVydCByb290IGVsZW1lbnRzLlxuICAgICAqXG4gICAgICogT24gY29uc3RydWN0aW9uLCBgSW5lcnROb2RlYCBzYXZlcyB0aGUgZXhpc3RpbmcgYHRhYmluZGV4YCB2YWx1ZSBmb3IgdGhlIG5vZGUsIGlmIGFueSwgYW5kXG4gICAgICogZWl0aGVyIHJlbW92ZXMgdGhlIGB0YWJpbmRleGAgYXR0cmlidXRlIG9yIHNldHMgaXQgdG8gYC0xYCwgZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZSBvciBub3QuXG4gICAgICpcbiAgICAgKiBgSW5lcnROb2RlYCBtYWludGFpbnMgYSBzZXQgb2YgYEluZXJ0Um9vdGBzIHdoaWNoIGFyZSBkZXNjZW5kYW50cyBvZiB0aGlzIGBJbmVydE5vZGVgLiBXaGVuIGFuXG4gICAgICogYEluZXJ0Um9vdGAgaXMgZGVzdHJveWVkLCBhbmQgY2FsbHMgYEluZXJ0TWFuYWdlci5kZXJlZ2lzdGVyKClgLCB0aGUgYEluZXJ0TWFuYWdlcmAgbm90aWZpZXMgdGhlXG4gICAgICogYEluZXJ0Tm9kZWAgdmlhIGByZW1vdmVJbmVydFJvb3QoKWAsIHdoaWNoIGluIHR1cm4gZGVzdHJveXMgdGhlIGBJbmVydE5vZGVgIGlmIG5vIGBJbmVydFJvb3Rgc1xuICAgICAqIHJlbWFpbiBpbiB0aGUgc2V0LiBPbiBkZXN0cnVjdGlvbiwgYEluZXJ0Tm9kZWAgcmVpbnN0YXRlcyB0aGUgc3RvcmVkIGB0YWJpbmRleGAgaWYgb25lIGV4aXN0cyxcbiAgICAgKiBvciByZW1vdmVzIHRoZSBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBpZiB0aGUgZWxlbWVudCBpcyBpbnRyaW5zaWNhbGx5IGZvY3VzYWJsZS5cbiAgICAgKi9cblxuXG4gICAgdmFyIEluZXJ0Tm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBBIGZvY3VzYWJsZSBlbGVtZW50IHRvIGJlIG1hZGUgaW5lcnQuXG4gICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdCBUaGUgaW5lcnQgcm9vdCBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluZXJ0IG5vZGUuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIEluZXJ0Tm9kZShub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0Tm9kZSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHshTm9kZX0gKi9cbiAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG5cbiAgICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHshU2V0PCFJbmVydFJvb3Q+fSBUaGUgc2V0IG9mIGRlc2NlbmRhbnQgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqICAgIElmIGFuZCBvbmx5IGlmIHRoaXMgc2V0IGJlY29tZXMgZW1wdHksIHRoaXMgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IFNldChbaW5lcnRSb290XSk7XG5cbiAgICAgICAgLyoqIEB0eXBlIHs/bnVtYmVyfSAqL1xuICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gbnVsbDtcblxuICAgICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICAgIHRoaXMuX2Rlc3Ryb3llZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIFNhdmUgYW55IHByaW9yIHRhYmluZGV4IGluZm8gYW5kIG1ha2UgdGhpcyBub2RlIHVudGFiYmFibGVcbiAgICAgICAgdGhpcy5lbnN1cmVVbnRhYmJhYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICogQ2FsbCB0aGlzIHdoZW5ldmVyIHRoaXMgb2JqZWN0IGlzIGFib3V0IHRvIGJlY29tZSBvYnNvbGV0ZS5cbiAgICAgICAqIFRoaXMgbWFrZXMgdGhlIG1hbmFnZWQgbm9kZSBmb2N1c2FibGUgYWdhaW4gYW5kIGRlbGV0ZXMgYWxsIG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCBzdGF0ZS5cbiAgICAgICAqL1xuXG5cbiAgICAgIF9jcmVhdGVDbGFzcyhJbmVydE5vZGUsIFt7XG4gICAgICAgIGtleTogJ2Rlc3RydWN0b3InLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJ1Y3RvcigpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG5cbiAgICAgICAgICBpZiAodGhpcy5fbm9kZSAmJiB0aGlzLl9ub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi90aGlzLl9ub2RlO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NhdmVkVGFiSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgdGhpcy5fc2F2ZWRUYWJJbmRleCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVXNlIGBkZWxldGVgIHRvIHJlc3RvcmUgbmF0aXZlIGZvY3VzIG1ldGhvZC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBlbGVtZW50LmZvY3VzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFNlZSBub3RlIGluIEluZXJ0Um9vdC5kZXN0cnVjdG9yIGZvciB3aHkgd2UgY2FzdCB0aGVzZSBudWxscyB0byBBTlkuXG4gICAgICAgICAgdGhpcy5fbm9kZSA9IC8qKiBAdHlwZSB7P30gKi9udWxsO1xuICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMgPSAvKiogQHR5cGUgez99ICovbnVsbDtcbiAgICAgICAgICB0aGlzLl9kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtib29sZWFufSBXaGV0aGVyIHRoaXMgb2JqZWN0IGlzIG9ic29sZXRlIGJlY2F1c2UgdGhlIG1hbmFnZWQgbm9kZSBpcyBubyBsb25nZXIgaW5lcnQuXG4gICAgICAgICAqIElmIHRoZSBvYmplY3QgaGFzIGJlZW4gZGVzdHJveWVkLCBhbnkgYXR0ZW1wdCB0byBhY2Nlc3MgaXQgd2lsbCBjYXVzZSBhbiBleGNlcHRpb24uXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ190aHJvd0lmRGVzdHJveWVkJyxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaHJvdyBpZiB1c2VyIHRyaWVzIHRvIGFjY2VzcyBkZXN0cm95ZWQgSW5lcnROb2RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90aHJvd0lmRGVzdHJveWVkKCkge1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGRlc3Ryb3llZCBJbmVydE5vZGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdlbnN1cmVVbnRhYmJhYmxlJyxcblxuXG4gICAgICAgIC8qKiBTYXZlIHRoZSBleGlzdGluZyB0YWJpbmRleCB2YWx1ZSBhbmQgbWFrZSB0aGUgbm9kZSB1bnRhYmJhYmxlIGFuZCB1bmZvY3VzYWJsZSAqL1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZW5zdXJlVW50YWJiYWJsZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL3RoaXMubm9kZTtcbiAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsIF9mb2N1c2FibGVFbGVtZW50c1N0cmluZykpIHtcbiAgICAgICAgICAgIGlmICggLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleCA9PT0gLTEgJiYgdGhpcy5oYXNTYXZlZFRhYkluZGV4KSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICAgIHRoaXMuX3NhdmVkVGFiSW5kZXggPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9lbGVtZW50LnRhYkluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgZWxlbWVudC5mb2N1cyA9IGZ1bmN0aW9uICgpIHt9O1xuICAgICAgICAgICAgICB0aGlzLl9vdmVycm9kZUZvY3VzTWV0aG9kID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICAgICAgICB0aGlzLl9zYXZlZFRhYkluZGV4ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovZWxlbWVudC50YWJJbmRleDtcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYW5vdGhlciBpbmVydCByb290IHRvIHRoaXMgaW5lcnQgbm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cy5cbiAgICAgICAgICogQHBhcmFtIHshSW5lcnRSb290fSBpbmVydFJvb3RcbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnYWRkSW5lcnRSb290JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEluZXJ0Um9vdChpbmVydFJvb3QpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5faW5lcnRSb290cy5hZGQoaW5lcnRSb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIGdpdmVuIGluZXJ0IHJvb3QgZnJvbSB0aGlzIGluZXJ0IG5vZGUncyBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMuXG4gICAgICAgICAqIElmIHRoZSBzZXQgb2YgbWFuYWdpbmcgaW5lcnQgcm9vdHMgYmVjb21lcyBlbXB0eSwgdGhpcyBub2RlIGlzIG5vIGxvbmdlciBpbmVydCxcbiAgICAgICAgICogc28gdGhlIG9iamVjdCBzaG91bGQgYmUgZGVzdHJveWVkLlxuICAgICAgICAgKiBAcGFyYW0geyFJbmVydFJvb3R9IGluZXJ0Um9vdFxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZW1vdmVJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCkge1xuICAgICAgICAgIHRoaXMuX3Rocm93SWZEZXN0cm95ZWQoKTtcbiAgICAgICAgICB0aGlzLl9pbmVydFJvb3RzWydkZWxldGUnXShpbmVydFJvb3QpO1xuICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdkZXN0cm95ZWQnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gKC8qKiBAdHlwZSB7IUluZXJ0Tm9kZX0gKi90aGlzLl9kZXN0cm95ZWRcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ2hhc1NhdmVkVGFiSW5kZXgnLFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2F2ZWRUYWJJbmRleCAhPT0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAcmV0dXJuIHshTm9kZX0gKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdub2RlJyxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEBwYXJhbSB7P251bWJlcn0gdGFiSW5kZXggKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdzYXZlZFRhYkluZGV4JyxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQodGFiSW5kZXgpIHtcbiAgICAgICAgICB0aGlzLl90aHJvd0lmRGVzdHJveWVkKCk7XG4gICAgICAgICAgdGhpcy5fc2F2ZWRUYWJJbmRleCA9IHRhYkluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqIEByZXR1cm4gez9udW1iZXJ9ICovXG4gICAgICAgICxcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgdGhpcy5fdGhyb3dJZkRlc3Ryb3llZCgpO1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zYXZlZFRhYkluZGV4O1xuICAgICAgICB9XG4gICAgICB9XSk7XG5cbiAgICAgIHJldHVybiBJbmVydE5vZGU7XG4gICAgfSgpO1xuXG4gICAgLyoqXG4gICAgICogSW5lcnRNYW5hZ2VyIGlzIGEgcGVyLWRvY3VtZW50IHNpbmdsZXRvbiBvYmplY3Qgd2hpY2ggbWFuYWdlcyBhbGwgaW5lcnQgcm9vdHMgYW5kIG5vZGVzLlxuICAgICAqXG4gICAgICogV2hlbiBhbiBlbGVtZW50IGJlY29tZXMgYW4gaW5lcnQgcm9vdCBieSBoYXZpbmcgYW4gYGluZXJ0YCBhdHRyaWJ1dGUgc2V0IGFuZC9vciBpdHMgYGluZXJ0YFxuICAgICAqIHByb3BlcnR5IHNldCB0byBgdHJ1ZWAsIHRoZSBgc2V0SW5lcnRgIG1ldGhvZCBjcmVhdGVzIGFuIGBJbmVydFJvb3RgIG9iamVjdCBmb3IgdGhlIGVsZW1lbnQuXG4gICAgICogVGhlIGBJbmVydFJvb3RgIGluIHR1cm4gcmVnaXN0ZXJzIGl0c2VsZiBhcyBtYW5hZ2luZyBhbGwgb2YgdGhlIGVsZW1lbnQncyBmb2N1c2FibGUgZGVzY2VuZGFudFxuICAgICAqIG5vZGVzIHZpYSB0aGUgYHJlZ2lzdGVyKClgIG1ldGhvZC4gVGhlIGBJbmVydE1hbmFnZXJgIGVuc3VyZXMgdGhhdCBhIHNpbmdsZSBgSW5lcnROb2RlYCBpbnN0YW5jZVxuICAgICAqIGlzIGNyZWF0ZWQgZm9yIGVhY2ggc3VjaCBub2RlLCB2aWEgdGhlIGBfbWFuYWdlZE5vZGVzYCBtYXAuXG4gICAgICovXG5cblxuICAgIHZhciBJbmVydE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7IURvY3VtZW50fSBkb2N1bWVudFxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiBJbmVydE1hbmFnZXIoZG9jdW1lbnQpIHtcbiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEluZXJ0TWFuYWdlcik7XG5cbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudDsgSW5lcnRNYW5hZ2VyIG5lZWRzIHRvIHdyYXAgYSBkb2N1bWVudC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKiBAdHlwZSB7IURvY3VtZW50fSAqL1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IGRvY3VtZW50O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbGwgbWFuYWdlZCBub2RlcyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Tm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9tYW5hZ2VkTm9kZXMgPSBuZXcgTWFwKCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFsbCBpbmVydCByb290cyBrbm93biB0byB0aGlzIEluZXJ0TWFuYWdlci4gSW4gYSBtYXAgdG8gYWxsb3cgbG9va2luZyB1cCBieSBOb2RlLlxuICAgICAgICAgKiBAdHlwZSB7IU1hcDwhTm9kZSwgIUluZXJ0Um9vdD59XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9pbmVydFJvb3RzID0gbmV3IE1hcCgpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlciBmb3IgbXV0YXRpb25zIG9uIGBkb2N1bWVudC5ib2R5YC5cbiAgICAgICAgICogQHR5cGUgeyFNdXRhdGlvbk9ic2VydmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl93YXRjaEZvckluZXJ0LmJpbmQodGhpcykpO1xuXG4gICAgICAgIC8vIEFkZCBpbmVydCBzdHlsZS5cbiAgICAgICAgYWRkSW5lcnRTdHlsZShkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcblxuICAgICAgICAvLyBXYWl0IGZvciBkb2N1bWVudCB0byBiZSBsb2FkZWQuXG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgdGhpcy5fb25Eb2N1bWVudExvYWRlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9vbkRvY3VtZW50TG9hZGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqXG4gICAgICAgKiBTZXQgd2hldGhlciB0aGUgZ2l2ZW4gZWxlbWVudCBzaG91bGQgYmUgYW4gaW5lcnQgcm9vdCBvciBub3QuXG4gICAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gcm9vdFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBpbmVydFxuICAgICAgICovXG5cblxuICAgICAgX2NyZWF0ZUNsYXNzKEluZXJ0TWFuYWdlciwgW3tcbiAgICAgICAga2V5OiAnc2V0SW5lcnQnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SW5lcnQocm9vdCwgaW5lcnQpIHtcbiAgICAgICAgICBpZiAoaW5lcnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgaW5lcnRcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgaW5lcnRSb290ID0gbmV3IEluZXJ0Um9vdChyb290LCB0aGlzKTtcbiAgICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKCdpbmVydCcsICcnKTtcbiAgICAgICAgICAgIHRoaXMuX2luZXJ0Um9vdHMuc2V0KHJvb3QsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgICAvLyBJZiBub3QgY29udGFpbmVkIGluIHRoZSBkb2N1bWVudCwgaXQgbXVzdCBiZSBpbiBhIHNoYWRvd1Jvb3QuXG4gICAgICAgICAgICAvLyBFbnN1cmUgaW5lcnQgc3R5bGVzIGFyZSBhZGRlZCB0aGVyZS5cbiAgICAgICAgICAgIGlmICghdGhpcy5fZG9jdW1lbnQuYm9keS5jb250YWlucyhyb290KSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gcm9vdC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICB3aGlsZSAocGFyZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSA9PT0gMTEpIHtcbiAgICAgICAgICAgICAgICAgIGFkZEluZXJ0U3R5bGUocGFyZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmVydFJvb3RzLmhhcyhyb290KSkge1xuICAgICAgICAgICAgICAvLyBlbGVtZW50IGlzIGFscmVhZHkgbm9uLWluZXJ0XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pbmVydFJvb3QgPSB0aGlzLl9pbmVydFJvb3RzLmdldChyb290KTtcbiAgICAgICAgICAgIF9pbmVydFJvb3QuZGVzdHJ1Y3RvcigpO1xuICAgICAgICAgICAgdGhpcy5faW5lcnRSb290c1snZGVsZXRlJ10ocm9vdCk7XG4gICAgICAgICAgICByb290LnJlbW92ZUF0dHJpYnV0ZSgnaW5lcnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBJbmVydFJvb3Qgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGluZXJ0IHJvb3QgZWxlbWVudCwgaWYgYW55LlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBlbGVtZW50XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydFJvb3R8dW5kZWZpbmVkfVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdnZXRJbmVydFJvb3QnLFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5lcnRSb290KGVsZW1lbnQpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5lcnRSb290cy5nZXQoZWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgdGhlIGdpdmVuIEluZXJ0Um9vdCBhcyBtYW5hZ2luZyB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgICAgICogSW4gdGhlIGNhc2Ugd2hlcmUgdGhlIG5vZGUgaGFzIGEgcHJldmlvdXNseSBleGlzdGluZyBpbmVydCByb290LCB0aGlzIGluZXJ0IHJvb3Qgd2lsbFxuICAgICAgICAgKiBiZSBhZGRlZCB0byBpdHMgc2V0IG9mIGluZXJ0IHJvb3RzLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4geyFJbmVydE5vZGV9IGluZXJ0Tm9kZVxuICAgICAgICAgKi9cblxuICAgICAgfSwge1xuICAgICAgICBrZXk6ICdyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlcihub2RlLCBpbmVydFJvb3QpIHtcbiAgICAgICAgICB2YXIgaW5lcnROb2RlID0gdGhpcy5fbWFuYWdlZE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgICBpZiAoaW5lcnROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vZGUgd2FzIGFscmVhZHkgaW4gYW4gaW5lcnQgc3VidHJlZVxuICAgICAgICAgICAgaW5lcnROb2RlLmFkZEluZXJ0Um9vdChpbmVydFJvb3QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbmVydE5vZGUgPSBuZXcgSW5lcnROb2RlKG5vZGUsIGluZXJ0Um9vdCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZE5vZGVzLnNldChub2RlLCBpbmVydE5vZGUpO1xuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZS1yZWdpc3RlciB0aGUgZ2l2ZW4gSW5lcnRSb290IGFzIG1hbmFnaW5nIHRoZSBnaXZlbiBpbmVydCBub2RlLlxuICAgICAgICAgKiBSZW1vdmVzIHRoZSBpbmVydCByb290IGZyb20gdGhlIEluZXJ0Tm9kZSdzIHNldCBvZiBtYW5hZ2luZyBpbmVydCByb290cywgYW5kIHJlbW92ZSB0aGUgaW5lcnRcbiAgICAgICAgICogbm9kZSBmcm9tIHRoZSBJbmVydE1hbmFnZXIncyBzZXQgb2YgbWFuYWdlZCBub2RlcyBpZiBpdCBpcyBkZXN0cm95ZWQuXG4gICAgICAgICAqIElmIHRoZSBub2RlIGlzIG5vdCBjdXJyZW50bHkgbWFuYWdlZCwgdGhpcyBpcyBlc3NlbnRpYWxseSBhIG5vLW9wLlxuICAgICAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB7IUluZXJ0Um9vdH0gaW5lcnRSb290XG4gICAgICAgICAqIEByZXR1cm4gez9JbmVydE5vZGV9IFRoZSBwb3RlbnRpYWxseSBkZXN0cm95ZWQgSW5lcnROb2RlIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG5cbiAgICAgIH0sIHtcbiAgICAgICAga2V5OiAnZGVyZWdpc3RlcicsXG4gICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXJlZ2lzdGVyKG5vZGUsIGluZXJ0Um9vdCkge1xuICAgICAgICAgIHZhciBpbmVydE5vZGUgPSB0aGlzLl9tYW5hZ2VkTm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICAgIGlmICghaW5lcnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbmVydE5vZGUucmVtb3ZlSW5lcnRSb290KGluZXJ0Um9vdCk7XG4gICAgICAgICAgaWYgKGluZXJ0Tm9kZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX21hbmFnZWROb2Rlc1snZGVsZXRlJ10obm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGluZXJ0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gZG9jdW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ19vbkRvY3VtZW50TG9hZGVkJyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvY3VtZW50TG9hZGVkKCkge1xuICAgICAgICAgIC8vIEZpbmQgYWxsIGluZXJ0IHJvb3RzIGluIGRvY3VtZW50IGFuZCBtYWtlIHRoZW0gYWN0dWFsbHkgaW5lcnQuXG4gICAgICAgICAgdmFyIGluZXJ0RWxlbWVudHMgPSBzbGljZS5jYWxsKHRoaXMuX2RvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5lcnQoaW5lcnRFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgIC8vIENvbW1lbnQgdGhpcyBvdXQgdG8gdXNlIHByb2dyYW1tYXRpYyBBUEkgb25seS5cbiAgICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHRoaXMuX2RvY3VtZW50LmJvZHkgfHwgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB7IGF0dHJpYnV0ZXM6IHRydWUsIHN1YnRyZWU6IHRydWUsIGNoaWxkTGlzdDogdHJ1ZSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayB1c2VkIHdoZW4gbXV0YXRpb24gb2JzZXJ2ZXIgZGV0ZWN0cyBhdHRyaWJ1dGUgY2hhbmdlcy5cbiAgICAgICAgICogQHBhcmFtIHshQXJyYXk8IU11dGF0aW9uUmVjb3JkPn0gcmVjb3Jkc1xuICAgICAgICAgKiBAcGFyYW0geyFNdXRhdGlvbk9ic2VydmVyfSBzZWxmXG4gICAgICAgICAqL1xuXG4gICAgICB9LCB7XG4gICAgICAgIGtleTogJ193YXRjaEZvckluZXJ0JyxcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIF93YXRjaEZvckluZXJ0KHJlY29yZHMsIHNlbGYpIHtcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgIHJlY29yZHMuZm9yRWFjaChmdW5jdGlvbiAocmVjb3JkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlY29yZC50eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgJ2NoaWxkTGlzdCc6XG4gICAgICAgICAgICAgICAgc2xpY2UuY2FsbChyZWNvcmQuYWRkZWROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHZhciBpbmVydEVsZW1lbnRzID0gc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpbmVydF0nKSk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsICdbaW5lcnRdJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy51bnNoaWZ0KG5vZGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaW5lcnRFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChpbmVydEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbmVydChpbmVydEVsZW1lbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgfSwgX3RoaXMpO1xuICAgICAgICAgICAgICAgIH0sIF90aGlzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAnYXR0cmlidXRlcyc6XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZC5hdHRyaWJ1dGVOYW1lICE9PSAnaW5lcnQnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9yZWNvcmQudGFyZ2V0O1xuICAgICAgICAgICAgICAgIHZhciBpbmVydCA9IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2luZXJ0Jyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0SW5lcnQodGFyZ2V0LCBpbmVydCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1dKTtcblxuICAgICAgcmV0dXJuIEluZXJ0TWFuYWdlcjtcbiAgICB9KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSB3YWxrIHRoZSBjb21wb3NlZCB0cmVlIGZyb20gfG5vZGV8LlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0geyhmdW5jdGlvbiAoIUhUTUxFbGVtZW50KSk9fSBjYWxsYmFjayBDYWxsYmFjayB0byBiZSBjYWxsZWQgZm9yIGVhY2ggZWxlbWVudCB0cmF2ZXJzZWQsXG4gICAgICogICAgIGJlZm9yZSBkZXNjZW5kaW5nIGludG8gY2hpbGQgbm9kZXMuXG4gICAgICogQHBhcmFtIHs/U2hhZG93Um9vdD19IHNoYWRvd1Jvb3RBbmNlc3RvciBUaGUgbmVhcmVzdCBTaGFkb3dSb290IGFuY2VzdG9yLCBpZiBhbnkuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbXBvc2VkVHJlZVdhbGsobm9kZSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcikge1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi9ub2RlO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjayhlbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlc2NlbmQgaW50byBub2RlOlxuICAgICAgICAvLyBJZiBpdCBoYXMgYSBTaGFkb3dSb290LCBpZ25vcmUgYWxsIGNoaWxkIGVsZW1lbnRzIC0gdGhlc2Ugd2lsbCBiZSBwaWNrZWRcbiAgICAgICAgLy8gdXAgYnkgdGhlIDxjb250ZW50PiBvciA8c2hhZG93PiBlbGVtZW50cy4gRGVzY2VuZCBzdHJhaWdodCBpbnRvIHRoZVxuICAgICAgICAvLyBTaGFkb3dSb290LlxuICAgICAgICB2YXIgc2hhZG93Um9vdCA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqL2VsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKHNoYWRvd1Jvb3QsIGNhbGxiYWNrLCBzaGFkb3dSb290KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBpdCBpcyBhIDxjb250ZW50PiBlbGVtZW50LCBkZXNjZW5kIGludG8gZGlzdHJpYnV0ZWQgZWxlbWVudHMgLSB0aGVzZVxuICAgICAgICAvLyBhcmUgZWxlbWVudHMgZnJvbSBvdXRzaWRlIHRoZSBzaGFkb3cgcm9vdCB3aGljaCBhcmUgcmVuZGVyZWQgaW5zaWRlIHRoZVxuICAgICAgICAvLyBzaGFkb3cgRE9NLlxuICAgICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ2NvbnRlbnQnKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSAvKiogQHR5cGUgeyFIVE1MQ29udGVudEVsZW1lbnR9ICovZWxlbWVudDtcbiAgICAgICAgICAvLyBWZXJpZmllcyBpZiBTaGFkb3dEb20gdjAgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBkaXN0cmlidXRlZE5vZGVzID0gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzID8gY29udGVudC5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvc2VkVHJlZVdhbGsoZGlzdHJpYnV0ZWROb2Rlc1tpXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIGl0IGlzIGEgPHNsb3Q+IGVsZW1lbnQsIGRlc2NlbmQgaW50byBhc3NpZ25lZCBub2RlcyAtIHRoZXNlXG4gICAgICAgIC8vIGFyZSBlbGVtZW50cyBmcm9tIG91dHNpZGUgdGhlIHNoYWRvdyByb290IHdoaWNoIGFyZSByZW5kZXJlZCBpbnNpZGUgdGhlXG4gICAgICAgIC8vIHNoYWRvdyBET00uXG4gICAgICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PSAnc2xvdCcpIHtcbiAgICAgICAgICB2YXIgc2xvdCA9IC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi9lbGVtZW50O1xuICAgICAgICAgIC8vIFZlcmlmeSBpZiBTaGFkb3dEb20gdjEgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgIHZhciBfZGlzdHJpYnV0ZWROb2RlcyA9IHNsb3QuYXNzaWduZWROb2RlcyA/IHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW46IHRydWUgfSkgOiBbXTtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgX2Rpc3RyaWJ1dGVkTm9kZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBjb21wb3NlZFRyZWVXYWxrKF9kaXN0cmlidXRlZE5vZGVzW19pXSwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBpdCBpcyBuZWl0aGVyIHRoZSBwYXJlbnQgb2YgYSBTaGFkb3dSb290LCBhIDxjb250ZW50PiBlbGVtZW50LCBhIDxzbG90PlxuICAgICAgLy8gZWxlbWVudCwgbm9yIGEgPHNoYWRvdz4gZWxlbWVudCByZWN1cnNlIG5vcm1hbGx5LlxuICAgICAgdmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkICE9IG51bGwpIHtcbiAgICAgICAgY29tcG9zZWRUcmVlV2FsayhjaGlsZCwgY2FsbGJhY2ssIHNoYWRvd1Jvb3RBbmNlc3Rvcik7XG4gICAgICAgIGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHN0eWxlIGVsZW1lbnQgdG8gdGhlIG5vZGUgY29udGFpbmluZyB0aGUgaW5lcnQgc3BlY2lmaWMgc3R5bGVzXG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZEluZXJ0U3R5bGUobm9kZSkge1xuICAgICAgaWYgKG5vZGUucXVlcnlTZWxlY3Rvcignc3R5bGUjaW5lcnQtc3R5bGUsIGxpbmsjaW5lcnQtc3R5bGUnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgc3R5bGUuc2V0QXR0cmlidXRlKCdpZCcsICdpbmVydC1zdHlsZScpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSAnXFxuJyArICdbaW5lcnRdIHtcXG4nICsgJyAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxuJyArICcgIGN1cnNvcjogZGVmYXVsdDtcXG4nICsgJ31cXG4nICsgJ1xcbicgKyAnW2luZXJ0XSwgW2luZXJ0XSAqIHtcXG4nICsgJyAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJyAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbicgKyAnICB1c2VyLXNlbGVjdDogbm9uZTtcXG4nICsgJ31cXG4nO1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxuXG4gICAgaWYgKCFIVE1MRWxlbWVudC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2luZXJ0JykpIHtcbiAgICAgIC8qKiBAdHlwZSB7IUluZXJ0TWFuYWdlcn0gKi9cbiAgICAgIHZhciBpbmVydE1hbmFnZXIgPSBuZXcgSW5lcnRNYW5hZ2VyKGRvY3VtZW50KTtcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2luZXJ0Jywge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKCdpbmVydCcpO1xuICAgICAgICB9LFxuICAgICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoaW5lcnQpIHtcbiAgICAgICAgICBpbmVydE1hbmFnZXIuc2V0SW5lcnQodGhpcywgaW5lcnQpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pKCk7XG5cbn0pKSk7XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIGBCbG9ja2luZ0VsZW1lbnRzYCBtYW5hZ2VzIGEgc3RhY2sgb2YgZWxlbWVudHMgdGhhdCBpbmVydCB0aGUgaW50ZXJhY3Rpb25cbiAqIG91dHNpZGUgdGhlbS4gVGhlIHRvcCBlbGVtZW50IGlzIHRoZSBpbnRlcmFjdGl2ZSBwYXJ0IG9mIHRoZSBkb2N1bWVudC5cbiAqIFRoZSBzdGFjayBjYW4gYmUgdXBkYXRlZCB3aXRoIHRoZSBtZXRob2RzIGBwdXNoLCByZW1vdmUsIHBvcGAuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvY2tpbmdFbGVtZW50cyB7XG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgd2hlbmV2ZXIgdGhpcyBvYmplY3QgaXMgYWJvdXQgdG8gYmVjb21lIG9ic29sZXRlLiBUaGlzIGVtcHRpZXNcbiAgICogdGhlIGJsb2NraW5nIGVsZW1lbnRzXG4gICAqL1xuICBkZXN0cnVjdG9yKCk6IHZvaWQ7XG5cbiAgLyoqXG4gICAqIFRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIHRvcDogSFRNTEVsZW1lbnR8bnVsbDtcblxuICAvKipcbiAgICogQWRkcyB0aGUgZWxlbWVudCB0byB0aGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAqL1xuICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZDtcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgZWxlbWVudCBmcm9tIHRoZSBibG9ja2luZyBlbGVtZW50cy4gUmV0dXJucyB0cnVlIGlmIHRoZVxuICAgKiBlbGVtZW50IHdhcyByZW1vdmVkLlxuICAgKi9cbiAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogUmVtb3ZlIHRoZSB0b3AgYmxvY2tpbmcgZWxlbWVudCBhbmQgcmV0dXJucyBpdC5cbiAgICovXG4gIHBvcCgpOiBIVE1MRWxlbWVudHxudWxsO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGEgYmxvY2tpbmcgZWxlbWVudC5cbiAgICovXG4gIGhhcyhlbGVtZW50OiBIVE1MRWxlbWVudCk6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyBleHRlbmRzIERvY3VtZW50IHtcbiAgJGJsb2NraW5nRWxlbWVudHM6IEJsb2NraW5nRWxlbWVudHM7XG59XG5cbigoKSA9PiB7XG4gIC8qIFN5bWJvbHMgZm9yIHByaXZhdGUgcHJvcGVydGllcyAqL1xuICBjb25zdCBfYmxvY2tpbmdFbGVtZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfYWxyZWFkeUluZXJ0RWxlbWVudHMgPSBTeW1ib2woKTtcbiAgY29uc3QgX3RvcEVsUGFyZW50cyA9IFN5bWJvbCgpO1xuICBjb25zdCBfc2libGluZ3NUb1Jlc3RvcmUgPSBTeW1ib2woKTtcbiAgY29uc3QgX3BhcmVudE1PID0gU3ltYm9sKCk7XG5cbiAgLyogU3ltYm9scyBmb3IgcHJpdmF0ZSBzdGF0aWMgbWV0aG9kcyAqL1xuICBjb25zdCBfdG9wQ2hhbmdlZCA9IFN5bWJvbCgpO1xuICBjb25zdCBfc3dhcEluZXJ0ZWRTaWJsaW5nID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pbmVydFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9yZXN0b3JlSW5lcnRlZFNpYmxpbmdzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXRQYXJlbnRzID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9nZXREaXN0cmlidXRlZENoaWxkcmVuID0gU3ltYm9sKCk7XG4gIGNvbnN0IF9pc0luZXJ0YWJsZSA9IFN5bWJvbCgpO1xuICBjb25zdCBfaGFuZGxlTXV0YXRpb25zID0gU3ltYm9sKCk7XG5cbiAgaW50ZXJmYWNlIEluZXJ0YWJsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgICBpbmVydD86IGJvb2xlYW47XG4gIH1cblxuICBpbnRlcmZhY2UgSW50ZXJuYWxTdGF0ZSB7XG4gICAgW19zaWJsaW5nc1RvUmVzdG9yZV06IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+O1xuICAgIFtfcGFyZW50TU9dOiBNdXRhdGlvbk9ic2VydmVyO1xuICB9XG4gIGludGVyZmFjZSBIYXNJbnRlcm5hbFN0YXRlIGV4dGVuZHMgSW5lcnRhYmxlLCBJbnRlcm5hbFN0YXRlIHt9XG4gIGludGVyZmFjZSBNYXliZUhhc0ludGVybmFsU3RhdGUgZXh0ZW5kcyBJbmVydGFibGUsIFBhcnRpYWw8SW50ZXJuYWxTdGF0ZT4ge31cblxuICAvKipcbiAgICogU2hhZHlET00gc2hhZHkgcm9vdHMgbG9vayBhIGxvdCBsaWtlIHJlYWwgU2hhZG93Um9vdHMuIFRoZSBfX3NoYWR5IHByb3BlcnR5XG4gICAqIGdpdmVzIHRoZW0gYXdheSwgdGhvdWdoLlxuICAgKi9cbiAgaW50ZXJmYWNlIE1heWJlU2hhZHlSb290IGV4dGVuZHMgRWxlbWVudCB7XG4gICAgX19zaGFkeTogdW5rbm93bjtcbiAgICBob3N0OiBFbGVtZW50O1xuICB9XG5cbiAgY2xhc3MgQmxvY2tpbmdFbGVtZW50c0ltcGwgaW1wbGVtZW50cyBCbG9ja2luZ0VsZW1lbnRzIHtcbiAgICAvKipcbiAgICAgKiBUaGUgYmxvY2tpbmcgZWxlbWVudHMuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYmxvY2tpbmdFbGVtZW50c106IE1heWJlSGFzSW50ZXJuYWxTdGF0ZVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIHBhcmVudHMgb2YgdGhlIHRvcCBlbGVtZW50LCBmcm9tIHRoZSBlbGVtZW50XG4gICAgICogaXRzZWxmIHVwIHRvIGJvZHkuIFdoZW4gdG9wIGNoYW5nZXMsIHRoZSBvbGQgdG9wIG1pZ2h0IGhhdmUgYmVlbiByZW1vdmVkXG4gICAgICogZnJvbSB0aGUgZG9jdW1lbnQsIHNvIHdlIG5lZWQgdG8gbWVtb2l6ZSB0aGUgaW5lcnRlZCBwYXJlbnRzJyBzaWJsaW5nc1xuICAgICAqIGluIG9yZGVyIHRvIHJlc3RvcmUgdGhlaXIgaW5lcnRlbmVzcyB3aGVuIHRvcCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcEVsUGFyZW50c106IEhhc0ludGVybmFsU3RhdGVbXSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogRWxlbWVudHMgdGhhdCBhcmUgYWxyZWFkeSBpbmVydCBiZWZvcmUgdGhlIGZpcnN0IGJsb2NraW5nIGVsZW1lbnQgaXNcbiAgICAgKiBwdXNoZWQuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfYWxyZWFkeUluZXJ0RWxlbWVudHNdID0gbmV3IFNldDxNYXliZUhhc0ludGVybmFsU3RhdGU+KCk7XG5cbiAgICBkZXN0cnVjdG9yKCk6IHZvaWQge1xuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCBpbmVydG5lc3MuXG4gICAgICB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXSh0aGlzW190b3BFbFBhcmVudHNdKTtcbiAgICAgIC8vIE5vdGUgd2UgZG9uJ3Qgd2FudCB0byBtYWtlIHRoZXNlIHByb3BlcnRpZXMgbnVsbGFibGUgb24gdGhlIGNsYXNzLFxuICAgICAgLy8gc2luY2UgdGhlbiB3ZSdkIG5lZWQgbm9uLW51bGwgY2FzdHMgaW4gbWFueSBwbGFjZXMuIENhbGxpbmcgYSBtZXRob2Qgb25cbiAgICAgIC8vIGEgQmxvY2tpbmdFbGVtZW50cyBpbnN0YW5jZSBhZnRlciBjYWxsaW5nIGRlc3RydWN0b3Igd2lsbCByZXN1bHQgaW4gYW5cbiAgICAgIC8vIGV4Y2VwdGlvbi5cbiAgICAgIGNvbnN0IG51bGxhYmxlID0gdGhpcyBhcyB1bmtub3duIGFzIHtcbiAgICAgICAgW19ibG9ja2luZ0VsZW1lbnRzXTogbnVsbDtcbiAgICAgICAgW190b3BFbFBhcmVudHNdOiBudWxsO1xuICAgICAgICBbX2FscmVhZHlJbmVydEVsZW1lbnRzXTogbnVsbDtcbiAgICAgIH07XG4gICAgICBudWxsYWJsZVtfYmxvY2tpbmdFbGVtZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX3RvcEVsUGFyZW50c10gPSBudWxsO1xuICAgICAgbnVsbGFibGVbX2FscmVhZHlJbmVydEVsZW1lbnRzXSA9IG51bGw7XG4gICAgfVxuXG4gICAgZ2V0IHRvcCgpOiBIVE1MRWxlbWVudHxudWxsIHtcbiAgICAgIGNvbnN0IGVsZW1zID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c107XG4gICAgICByZXR1cm4gZWxlbXNbZWxlbXMubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG5cbiAgICBwdXNoKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogdm9pZCB7XG4gICAgICBpZiAoIWVsZW1lbnQgfHwgZWxlbWVudCA9PT0gdGhpcy50b3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCB3ZSdsbCBicmluZyBpdCB0byB0aGUgdG9wLlxuICAgICAgdGhpcy5yZW1vdmUoZWxlbWVudCk7XG4gICAgICB0aGlzW190b3BDaGFuZ2VkXShlbGVtZW50KTtcbiAgICAgIHRoaXNbX2Jsb2NraW5nRWxlbWVudHNdLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICBjb25zdCBpID0gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KTtcbiAgICAgIGlmIChpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5zcGxpY2UoaSwgMSk7XG4gICAgICAvLyBUb3AgY2hhbmdlZCBvbmx5IGlmIHRoZSByZW1vdmVkIGVsZW1lbnQgd2FzIHRoZSB0b3AgZWxlbWVudC5cbiAgICAgIGlmIChpID09PSB0aGlzW19ibG9ja2luZ0VsZW1lbnRzXS5sZW5ndGgpIHtcbiAgICAgICAgdGhpc1tfdG9wQ2hhbmdlZF0odGhpcy50b3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcG9wKCk6IEhUTUxFbGVtZW50fG51bGwge1xuICAgICAgY29uc3QgdG9wID0gdGhpcy50b3A7XG4gICAgICB0b3AgJiYgdGhpcy5yZW1vdmUodG9wKTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgaGFzKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gdGhpc1tfYmxvY2tpbmdFbGVtZW50c10uaW5kZXhPZihlbGVtZW50KSAhPT0gLTE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBgaW5lcnRgIHRvIGFsbCBkb2N1bWVudCBlbGVtZW50cyBleGNlcHQgdGhlIG5ldyB0b3AgZWxlbWVudCwgaXRzXG4gICAgICogcGFyZW50cywgYW5kIGl0cyBkaXN0cmlidXRlZCBjb250ZW50LlxuICAgICAqL1xuICAgIHByaXZhdGVbX3RvcENoYW5nZWRdKG5ld1RvcDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlfG51bGwpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHRvS2VlcEluZXJ0ID0gdGhpc1tfYWxyZWFkeUluZXJ0RWxlbWVudHNdO1xuICAgICAgY29uc3Qgb2xkUGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICAvLyBObyBuZXcgdG9wLCByZXNldCBvbGQgdG9wIGlmIGFueS5cbiAgICAgIGlmICghbmV3VG9wKSB7XG4gICAgICAgIHRoaXNbX3Jlc3RvcmVJbmVydGVkU2libGluZ3NdKG9sZFBhcmVudHMpO1xuICAgICAgICB0b0tlZXBJbmVydC5jbGVhcigpO1xuICAgICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gW107XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmV3UGFyZW50cyA9IHRoaXNbX2dldFBhcmVudHNdKG5ld1RvcCk7XG4gICAgICAvLyBOZXcgdG9wIGlzIG5vdCBjb250YWluZWQgaW4gdGhlIG1haW4gZG9jdW1lbnQhXG4gICAgICBpZiAobmV3UGFyZW50c1tuZXdQYXJlbnRzLmxlbmd0aCAtIDFdLnBhcmVudE5vZGUgIT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ05vbi1jb25uZWN0ZWQgZWxlbWVudCBjYW5ub3QgYmUgYSBibG9ja2luZyBlbGVtZW50Jyk7XG4gICAgICB9XG4gICAgICAvLyBDYXN0IGhlcmUgYmVjYXVzZSB3ZSBrbm93IHdlJ2xsIGNhbGwgX2luZXJ0U2libGluZ3Mgb24gbmV3UGFyZW50c1xuICAgICAgLy8gYmVsb3cuXG4gICAgICB0aGlzW190b3BFbFBhcmVudHNdID0gbmV3UGFyZW50cyBhcyBBcnJheTxIYXNJbnRlcm5hbFN0YXRlPjtcblxuICAgICAgY29uc3QgdG9Ta2lwID0gdGhpc1tfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0obmV3VG9wKTtcblxuICAgICAgLy8gTm8gcHJldmlvdXMgdG9wIGVsZW1lbnQuXG4gICAgICBpZiAoIW9sZFBhcmVudHMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXNbX2luZXJ0U2libGluZ3NdKG5ld1BhcmVudHMsIHRvU2tpcCwgdG9LZWVwSW5lcnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBpID0gb2xkUGFyZW50cy5sZW5ndGggLSAxO1xuICAgICAgbGV0IGogPSBuZXdQYXJlbnRzLmxlbmd0aCAtIDE7XG4gICAgICAvLyBGaW5kIGNvbW1vbiBwYXJlbnQuIEluZGV4IDAgaXMgdGhlIGVsZW1lbnQgaXRzZWxmIChzbyBzdG9wIGJlZm9yZSBpdCkuXG4gICAgICB3aGlsZSAoaSA+IDAgJiYgaiA+IDAgJiYgb2xkUGFyZW50c1tpXSA9PT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICBpLS07XG4gICAgICAgIGotLTtcbiAgICAgIH1cbiAgICAgIC8vIElmIHVwIHRoZSBwYXJlbnRzIHRyZWUgdGhlcmUgYXJlIDIgZWxlbWVudHMgdGhhdCBhcmUgc2libGluZ3MsIHN3YXBcbiAgICAgIC8vIHRoZSBpbmVydGVkIHNpYmxpbmcuXG4gICAgICBpZiAob2xkUGFyZW50c1tpXSAhPT0gbmV3UGFyZW50c1tqXSkge1xuICAgICAgICB0aGlzW19zd2FwSW5lcnRlZFNpYmxpbmddKG9sZFBhcmVudHNbaV0sIG5ld1BhcmVudHNbal0pO1xuICAgICAgfVxuICAgICAgLy8gUmVzdG9yZSBvbGQgcGFyZW50cyBzaWJsaW5ncyBpbmVydG5lc3MuXG4gICAgICBpID4gMCAmJiB0aGlzW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShvbGRQYXJlbnRzLnNsaWNlKDAsIGkpKTtcbiAgICAgIC8vIE1ha2UgbmV3IHBhcmVudHMgc2libGluZ3MgaW5lcnQuXG4gICAgICBqID4gMCAmJiB0aGlzW19pbmVydFNpYmxpbmdzXShuZXdQYXJlbnRzLnNsaWNlKDAsIGopLCB0b1NraXAsIG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN3YXBzIGluZXJ0bmVzcyBiZXR3ZWVuIHR3byBzaWJsaW5nIGVsZW1lbnRzLlxuICAgICAqIFNldHMgdGhlIHByb3BlcnR5IGBpbmVydGAgb3ZlciB0aGUgYXR0cmlidXRlIHNpbmNlIHRoZSBpbmVydCBzcGVjXG4gICAgICogZG9lc24ndCBzcGVjaWZ5IGlmIGl0IHNob3VsZCBiZSByZWZsZWN0ZWQuXG4gICAgICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW50ZXJhY3Rpb24uaHRtbCNpbmVydFxuICAgICAqL1xuICAgIHByaXZhdGVbX3N3YXBJbmVydGVkU2libGluZ10oXG4gICAgICAgIG9sZEluZXJ0OiBIYXNJbnRlcm5hbFN0YXRlLCBuZXdJbmVydDogTWF5YmVIYXNJbnRlcm5hbFN0YXRlKTogdm9pZCB7XG4gICAgICBjb25zdCBzaWJsaW5nc1RvUmVzdG9yZSA9IG9sZEluZXJ0W19zaWJsaW5nc1RvUmVzdG9yZV07XG4gICAgICAvLyBvbGRJbmVydCBpcyBub3QgY29udGFpbmVkIGluIHNpYmxpbmdzIHRvIHJlc3RvcmUsIHNvIHdlIGhhdmUgdG8gY2hlY2tcbiAgICAgIC8vIGlmIGl0J3MgaW5lcnRhYmxlIGFuZCBpZiBhbHJlYWR5IGluZXJ0LlxuICAgICAgaWYgKHRoaXNbX2lzSW5lcnRhYmxlXShvbGRJbmVydCkgJiYgIW9sZEluZXJ0LmluZXJ0KSB7XG4gICAgICAgIG9sZEluZXJ0LmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgc2libGluZ3NUb1Jlc3RvcmUuYWRkKG9sZEluZXJ0KTtcbiAgICAgIH1cbiAgICAgIC8vIElmIG5ld0luZXJ0IHdhcyBhbHJlYWR5IGJldHdlZW4gdGhlIHNpYmxpbmdzIHRvIHJlc3RvcmUsIGl0IG1lYW5zIGl0IGlzXG4gICAgICAvLyBpbmVydGFibGUgYW5kIG11c3QgYmUgcmVzdG9yZWQuXG4gICAgICBpZiAoc2libGluZ3NUb1Jlc3RvcmUuaGFzKG5ld0luZXJ0KSkge1xuICAgICAgICBuZXdJbmVydC5pbmVydCA9IGZhbHNlO1xuICAgICAgICBzaWJsaW5nc1RvUmVzdG9yZS5kZWxldGUobmV3SW5lcnQpO1xuICAgICAgfVxuICAgICAgbmV3SW5lcnRbX3BhcmVudE1PXSA9IG9sZEluZXJ0W19wYXJlbnRNT107XG4gICAgICBuZXdJbmVydFtfc2libGluZ3NUb1Jlc3RvcmVdID0gc2libGluZ3NUb1Jlc3RvcmU7XG4gICAgICAob2xkSW5lcnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgKG9sZEluZXJ0IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXN0b3JlcyBvcmlnaW5hbCBpbmVydG5lc3MgdG8gdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cy5cbiAgICAgKiBTZXRzIHRoZSBwcm9wZXJ0eSBgaW5lcnRgIG92ZXIgdGhlIGF0dHJpYnV0ZSBzaW5jZSB0aGUgaW5lcnQgc3BlY1xuICAgICAqIGRvZXNuJ3Qgc3BlY2lmeSBpZiBpdCBzaG91bGQgYmUgcmVmbGVjdGVkLlxuICAgICAqIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2ludGVyYWN0aW9uLmh0bWwjaW5lcnRcbiAgICAgKi9cbiAgICBwcml2YXRlW19yZXN0b3JlSW5lcnRlZFNpYmxpbmdzXShlbGVtZW50czogSGFzSW50ZXJuYWxTdGF0ZVtdKSB7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgbW8gPSBlbGVtZW50W19wYXJlbnRNT107XG4gICAgICAgIG1vLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgKGVsZW1lbnQgYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlKVtfcGFyZW50TU9dID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzaWJsaW5ncyA9IGVsZW1lbnRbX3NpYmxpbmdzVG9SZXN0b3JlXTtcbiAgICAgICAgZm9yIChjb25zdCBzaWJsaW5nIG9mIHNpYmxpbmdzKSB7XG4gICAgICAgICAgc2libGluZy5pbmVydCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChlbGVtZW50IGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZSlbX3NpYmxpbmdzVG9SZXN0b3JlXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbmVydHMgdGhlIHNpYmxpbmdzIG9mIHRoZSBlbGVtZW50cyBleGNlcHQgdGhlIGVsZW1lbnRzIHRvIHNraXAuIFN0b3Jlc1xuICAgICAqIHRoZSBpbmVydGVkIHNpYmxpbmdzIGludG8gdGhlIGVsZW1lbnQncyBzeW1ib2wgYF9zaWJsaW5nc1RvUmVzdG9yZWAuXG4gICAgICogUGFzcyBgdG9LZWVwSW5lcnRgIHRvIGNvbGxlY3QgdGhlIGFscmVhZHkgaW5lcnQgZWxlbWVudHMuXG4gICAgICogU2V0cyB0aGUgcHJvcGVydHkgYGluZXJ0YCBvdmVyIHRoZSBhdHRyaWJ1dGUgc2luY2UgdGhlIGluZXJ0IHNwZWNcbiAgICAgKiBkb2Vzbid0IHNwZWNpZnkgaWYgaXQgc2hvdWxkIGJlIHJlZmxlY3RlZC5cbiAgICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnRlcmFjdGlvbi5odG1sI2luZXJ0XG4gICAgICovXG4gICAgcHJpdmF0ZVtfaW5lcnRTaWJsaW5nc10oXG4gICAgICAgIGVsZW1lbnRzOiBNYXliZUhhc0ludGVybmFsU3RhdGVbXSwgdG9Ta2lwOiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwsXG4gICAgICAgIHRvS2VlcEluZXJ0OiBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwpIHtcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAvLyBBc3N1bWUgZWxlbWVudCBpcyBub3QgYSBEb2N1bWVudCwgc28gaXQgbXVzdCBoYXZlIGEgcGFyZW50Tm9kZS5cbiAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlITtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBwYXJlbnQuY2hpbGRyZW47XG4gICAgICAgIGNvbnN0IGluZXJ0ZWRTaWJsaW5ncyA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gY2hpbGRyZW5bal0gYXMgTWF5YmVIYXNJbnRlcm5hbFN0YXRlO1xuICAgICAgICAgIC8vIFNraXAgdGhlIGlucHV0IGVsZW1lbnQsIGlmIG5vdCBpbmVydGFibGUgb3IgdG8gYmUgc2tpcHBlZC5cbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gZWxlbWVudCB8fCAhdGhpc1tfaXNJbmVydGFibGVdKHNpYmxpbmcpIHx8XG4gICAgICAgICAgICAgICh0b1NraXAgJiYgdG9Ta2lwLmhhcyhzaWJsaW5nKSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBTaG91bGQgYmUgY29sbGVjdGVkIHNpbmNlIGFscmVhZHkgaW5lcnRlZC5cbiAgICAgICAgICBpZiAodG9LZWVwSW5lcnQgJiYgc2libGluZy5pbmVydCkge1xuICAgICAgICAgICAgdG9LZWVwSW5lcnQuYWRkKHNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaWJsaW5nLmluZXJ0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5hZGQoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFN0b3JlIHRoZSBzaWJsaW5ncyB0aGF0IHdlcmUgaW5lcnRlZC5cbiAgICAgICAgZWxlbWVudFtfc2libGluZ3NUb1Jlc3RvcmVdID0gaW5lcnRlZFNpYmxpbmdzO1xuICAgICAgICAvLyBPYnNlcnZlIG9ubHkgaW1tZWRpYXRlIGNoaWxkcmVuIG11dGF0aW9ucyBvbiB0aGUgcGFyZW50LlxuICAgICAgICBjb25zdCBtbyA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXNbX2hhbmRsZU11dGF0aW9uc10uYmluZCh0aGlzKSk7XG4gICAgICAgIGVsZW1lbnRbX3BhcmVudE1PXSA9IG1vO1xuICAgICAgICBsZXQgcGFyZW50VG9PYnNlcnZlID0gcGFyZW50O1xuICAgICAgICAvLyBJZiB3ZSdyZSB1c2luZyB0aGUgU2hhZHlET00gcG9seWZpbGwsIHRoZW4gb3VyIHBhcmVudCBjb3VsZCBiZSBhXG4gICAgICAgIC8vIHNoYWR5IHJvb3QsIHdoaWNoIGlzIGFuIG9iamVjdCB0aGF0IGFjdHMgbGlrZSBhIFNoYWRvd1Jvb3QsIGJ1dCBpc24ndFxuICAgICAgICAvLyBhY3R1YWxseSBhIG5vZGUgaW4gdGhlIHJlYWwgRE9NLiBPYnNlcnZlIHRoZSByZWFsIERPTSBwYXJlbnQgaW5zdGVhZC5cbiAgICAgICAgY29uc3QgbWF5YmVTaGFkeVJvb3QgPSBwYXJlbnRUb09ic2VydmUgYXMgTWF5YmVTaGFkeVJvb3Q7XG4gICAgICAgIGlmIChtYXliZVNoYWR5Um9vdC5fX3NoYWR5ICYmIG1heWJlU2hhZHlSb290Lmhvc3QpIHtcbiAgICAgICAgICBwYXJlbnRUb09ic2VydmUgPSBtYXliZVNoYWR5Um9vdC5ob3N0O1xuICAgICAgICB9XG4gICAgICAgIG1vLm9ic2VydmUocGFyZW50VG9PYnNlcnZlLCB7XG4gICAgICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG5ld2x5IGFkZGVkL3JlbW92ZWQgbm9kZXMgYnkgdG9nZ2xpbmcgdGhlaXIgaW5lcnRuZXNzLlxuICAgICAqIEl0IGFsc28gY2hlY2tzIGlmIHRoZSBjdXJyZW50IHRvcCBCbG9ja2luZyBFbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQsXG4gICAgICogbm90aWZ5aW5nIGFuZCByZW1vdmluZyBpdC5cbiAgICAgKi9cbiAgICBwcml2YXRlW19oYW5kbGVNdXRhdGlvbnNdKG11dGF0aW9uczogTXV0YXRpb25SZWNvcmRbXSk6IHZvaWQge1xuICAgICAgY29uc3QgcGFyZW50cyA9IHRoaXNbX3RvcEVsUGFyZW50c107XG4gICAgICBjb25zdCB0b0tlZXBJbmVydCA9IHRoaXNbX2FscmVhZHlJbmVydEVsZW1lbnRzXTtcbiAgICAgIGZvciAoY29uc3QgbXV0YXRpb24gb2YgbXV0YXRpb25zKSB7XG4gICAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYSBzaGFkb3dSb290LCBnZXQgaXRzIGhvc3QgYXMgd2Ugc2tpcCBzaGFkb3dSb290cyB3aGVuXG4gICAgICAgIC8vIGNvbXB1dGluZyBfdG9wRWxQYXJlbnRzLlxuICAgICAgICBjb25zdCB0YXJnZXQgPSAobXV0YXRpb24udGFyZ2V0IGFzIFNoYWRvd1Jvb3QpLmhvc3QgfHwgbXV0YXRpb24udGFyZ2V0O1xuICAgICAgICBjb25zdCBpZHggPSB0YXJnZXQgPT09IGRvY3VtZW50LmJvZHkgP1xuICAgICAgICAgICAgcGFyZW50cy5sZW5ndGggOlxuICAgICAgICAgICAgcGFyZW50cy5pbmRleE9mKHRhcmdldCBhcyBIYXNJbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgY29uc3QgaW5lcnRlZENoaWxkID0gcGFyZW50c1tpZHggLSAxXTtcbiAgICAgICAgY29uc3QgaW5lcnRlZFNpYmxpbmdzID0gaW5lcnRlZENoaWxkW19zaWJsaW5nc1RvUmVzdG9yZV07XG5cbiAgICAgICAgLy8gVG8gcmVzdG9yZS5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtdXRhdGlvbi5yZW1vdmVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBzaWJsaW5nID0gbXV0YXRpb24ucmVtb3ZlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoc2libGluZyA9PT0gaW5lcnRlZENoaWxkKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oJ0RldGVjdGVkIHJlbW92YWwgb2YgdGhlIHRvcCBCbG9ja2luZyBFbGVtZW50LicpO1xuICAgICAgICAgICAgdGhpcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZXJ0ZWRTaWJsaW5ncy5oYXMoc2libGluZykpIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGluZXJ0ZWRTaWJsaW5ncy5kZWxldGUoc2libGluZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVG8gaW5lcnQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb24uYWRkZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBtdXRhdGlvbi5hZGRlZE5vZGVzW2ldIGFzIE1heWJlSGFzSW50ZXJuYWxTdGF0ZTtcbiAgICAgICAgICBpZiAoIXRoaXNbX2lzSW5lcnRhYmxlXShzaWJsaW5nKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0b0tlZXBJbmVydCAmJiBzaWJsaW5nLmluZXJ0KSB7XG4gICAgICAgICAgICB0b0tlZXBJbmVydC5hZGQoc2libGluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNpYmxpbmcuaW5lcnQgPSB0cnVlO1xuICAgICAgICAgICAgaW5lcnRlZFNpYmxpbmdzLmFkZChzaWJsaW5nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBlbGVtZW50IGlzIGluZXJ0YWJsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlW19pc0luZXJ0YWJsZV0oZWxlbWVudDogSFRNTEVsZW1lbnQpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBmYWxzZSA9PT0gL14oc3R5bGV8dGVtcGxhdGV8c2NyaXB0KSQvLnRlc3QoZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgbmV3UGFyZW50cyBvZiBhbiBlbGVtZW50LCBzdGFydGluZyBmcm9tIGVsZW1lbnRcbiAgICAgKiAoaW5jbHVkZWQpIHVwIHRvIGBkb2N1bWVudC5ib2R5YCAoZXhjbHVkZWQpLlxuICAgICAqL1xuICAgIHByaXZhdGVbX2dldFBhcmVudHNdKGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogQXJyYXk8SFRNTEVsZW1lbnQ+IHtcbiAgICAgIGNvbnN0IHBhcmVudHMgPSBbXTtcbiAgICAgIGxldCBjdXJyZW50OiBIVE1MRWxlbWVudHxudWxsfHVuZGVmaW5lZCA9IGVsZW1lbnQ7XG4gICAgICAvLyBTdG9wIHRvIGJvZHkuXG4gICAgICB3aGlsZSAoY3VycmVudCAmJiBjdXJyZW50ICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIC8vIFNraXAgc2hhZG93IHJvb3RzLlxuICAgICAgICBpZiAoY3VycmVudC5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBwYXJlbnRzLnB1c2goY3VycmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2hhZG93RG9tIHYxXG4gICAgICAgIGlmIChjdXJyZW50LmFzc2lnbmVkU2xvdCkge1xuICAgICAgICAgIC8vIENvbGxlY3Qgc2xvdHMgZnJvbSBkZWVwZXN0IHNsb3QgdG8gdG9wLlxuICAgICAgICAgIHdoaWxlIChjdXJyZW50ID0gY3VycmVudC5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQ29udGludWUgdGhlIHNlYXJjaCBvbiB0aGUgdG9wIHNsb3QuXG4gICAgICAgICAgY3VycmVudCA9IHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZSBhcyBIVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgKGN1cnJlbnQgYXMgTm9kZSBhcyBTaGFkb3dSb290KS5ob3N0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgY2hpbGRyZW4gb2YgdGhlIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGEgc2hhZG93IHJvb3QuXG4gICAgICovXG4gICAgcHJpdmF0ZVtfZ2V0RGlzdHJpYnV0ZWRDaGlsZHJlbl0oZWxlbWVudDogSFRNTEVsZW1lbnQpOlxuICAgICAgICBTZXQ8SFRNTEVsZW1lbnQ+fG51bGwge1xuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmICghc2hhZG93Um9vdCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBTZXQ8SFRNTEVsZW1lbnQ+KCk7XG4gICAgICBsZXQgaTtcbiAgICAgIGxldCBqO1xuICAgICAgbGV0IG5vZGVzO1xuICAgICAgY29uc3Qgc2xvdHMgPSBzaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAgIGlmIChzbG90cy5sZW5ndGggJiYgc2xvdHNbMF0uYXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2xvdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBub2RlcyA9IHNsb3RzW2ldLmFzc2lnbmVkTm9kZXMoe1xuICAgICAgICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChub2Rlc1tqXS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgcmVzdWx0LmFkZChub2Rlc1tqXSBhcyBIVE1MRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIG5lZWQgdG8gc2VhcmNoIGZvciA8Y29udGVudD4uXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIChkb2N1bWVudCBhcyBEb2N1bWVudFdpdGhCbG9ja2luZ0VsZW1lbnRzKS4kYmxvY2tpbmdFbGVtZW50cyA9XG4gICAgICBuZXcgQmxvY2tpbmdFbGVtZW50c0ltcGwoKTtcbn0pKCk7XG4iLCJpbXBvcnQgXCJ3aWNnLWluZXJ0XCI7XG5pbXBvcnQgXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cyB9IGZyb20gXCJibG9ja2luZy1lbGVtZW50c1wiO1xuaW1wb3J0IHsgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tIFwiLi91c2UtZG9jdW1lbnQtY2xhc3NcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuXG5mdW5jdGlvbiBibG9ja2luZ0VsZW1lbnRzKCkgeyByZXR1cm4gKGdldERvY3VtZW50KCkgYXMgRG9jdW1lbnRXaXRoQmxvY2tpbmdFbGVtZW50cykuJGJsb2NraW5nRWxlbWVudHMgfVxuLyoqXG4gKiBBbGxvd3MgYW4gZWxlbWVudCB0byB0cmFwIGZvY3VzIGJ5IGFwcGx5aW5nIHRoZSBcImluZXJ0XCIgYXR0cmlidXRlIHRvIGFsbCBzaWJsaW5nLCBhdW50LCBhbmQgdW5jbGUgbm9kZXMuXG4gKiBcbiAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBjb25zZWN1dGl2ZSBjYWxscyB3aXRoIGEgbG9vc2VseSBhcHBsaWVkIHN0YWNrIG9wZXJhdGlvbiBcbiAqIChzcGVjaWZpY2FsbHkgdmlhIGBibG9ja2luZ0VsZW1lbnRzYCwgd2l0aCBhIHNtYWxsIHBvbHlmaWxsIGJlY2F1c2UgSSdtIG5vdCBzdXJlIGhvdyBsb25nXG4gKiBpdCdsbCB0YWtlIHRvIGZpbmQgaXRzIHdheSBpbnRvIHRoZSBzcGVjLCBpZiBldmVyKVxuICogQHBhcmFtIHRhcmdldCBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUJsb2NraW5nRWxlbWVudDxFIGV4dGVuZHMgRWxlbWVudD4oZW5hYmxlZDogYm9vbGVhbiwgZ2V0VGFyZ2V0OiAoKSA9PiAoRSB8IG51bGwpKSB7XG5cbiAgICBjb25zdCBzdGFibGVHZXRUYXJnZXQgPSB1c2VTdGFibGVDYWxsYmFjayhnZXRUYXJnZXQpO1xuXG4gICAgLyoqXG4gICAgICogUHVzaC9wb3AgdGhlIGVsZW1lbnQgZnJvbSB0aGUgYmxvY2tpbmdFbGVtZW50cyBzdGFjay5cbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBzdGFibGVHZXRUYXJnZXQoKTtcblxuICAgICAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gU29tZXRpbWVzIGJsb2NraW5nRWxlbWVudHMgd2lsbCBmYWlsIGlmLCBmb3IgZXhhbXBsZSxcbiAgICAgICAgICAgIC8vIHRoZSB0YXJnZXQgZWxlbWVudCBpc24ndCBjb25uZWN0ZWQgdG8gZG9jdW1lbnQuYm9keS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgcmFyZSwgYnV0IGl0J3MgYmV0dGVyIHRvIGZhaWwgc2lsZW50bHkgd2l0aCB3ZWlyZCB0YWJiaW5nIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyB0aGFuIHRvIGNyYXNoIHRoZSBlbnRpcmUgYXBwbGljYXRpb24uXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJsb2NraW5nRWxlbWVudHMoKS5wdXNoKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBibG9ja2luZ0VsZW1lbnRzKCkucmVtb3ZlKHRhcmdldCBhcyBFbGVtZW50IGFzIEhUTUxFbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gV2VsbCwgc2VtaS1zaWxlbnRseS5cbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtlbmFibGVkXSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRUb3BFbGVtZW50KCkge1xuICAgIHJldHVybiBibG9ja2luZ0VsZW1lbnRzKCkudG9wO1xufVxuXG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgaXNGb2N1c2FibGUgfSBmcm9tIFwidGFiYmFibGVcIjtcbmltcG9ydCB7IHVzZUFjdGl2ZUVsZW1lbnQgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcbmltcG9ydCB7IGdldFRvcEVsZW1lbnQsIHVzZUJsb2NraW5nRWxlbWVudCB9IGZyb20gXCIuL3VzZS1ibG9ja2luZy1lbGVtZW50XCI7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gXCIuL3VzZS1kb2N1bWVudC1jbGFzc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VSZWZFbGVtZW50LCBVc2VSZWZFbGVtZW50UmV0dXJuVHlwZSB9IGZyb20gXCIuL3VzZS1yZWYtZWxlbWVudFwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlRm9jdXNUcmFwUGFyYW1ldGVycyB7IHRyYXBBY3RpdmU6IGJvb2xlYW47IH1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VGb2N1c1RyYXBSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIFwicmVmRWxlbWVudFByb3BzXCI+IHtcbiAgICAvKiogKlVuc3RhYmxlKiAocmVsaWVzIG9uIHRoZSBgdHJhcEFjdGl2ZWAgcHJvcCkgKi9cbiAgICB1c2VGb2N1c1RyYXBQcm9wczogKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XG59XG5cbmNvbnN0IGVsZW1lbnRzVG9SZXN0b3JlRm9jdXNUbyA9IG5ldyBNYXA8RWxlbWVudCB8IG51bGwsIChOb2RlICYgSFRNTE9yU1ZHRWxlbWVudCk+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGb2N1c1RyYXA8RSBleHRlbmRzIEVsZW1lbnQ+KHsgdHJhcEFjdGl2ZSB9OiBVc2VGb2N1c1RyYXBQYXJhbWV0ZXJzKTogVXNlRm9jdXNUcmFwUmV0dXJuVHlwZTxFPiB7XG4gICAgXG4gICAgY29uc3QgaGFuZGxlQWN0aXZlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHRyYXBBY3RpdmU6IGJvb2xlYW4sIGVsZW1lbnQ6IEUgfCBudWxsKSA9PiB7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcblxuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBleHRyYSBxdWV1ZU1pY3JvdGFzayBpcyBuZWVkZWQgZm9yXG4gICAgICAgICAgICAgICAgLy8gLi4ucmVhc29ucz9cbiAgICAgICAgICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmRGaXJzdEZvY3VzYWJsZShlbGVtZW50KT8uZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmFmSGFuZGxlID0gMDtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlbGVtZW50KSB7XG5cbiAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIGZvY3VzIHRvIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAvLyB0aGF0IGhhcyByZXR1cm5lZCB0byB0aGUgdG9wIG9mIHRoZSBzdGFja1xuICAgICAgICAgICAgbGV0IHJhZkhhbmRsZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uZ2V0KGdldFRvcEVsZW1lbnQoKSk/LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJhZkhhbmRsZSA9IDA7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmFmSGFuZGxlKVxuICAgICAgICAgICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShyYWZIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICBcbiAgICBjb25zdCB7IGdldEVsZW1lbnQsIHJlZkVsZW1lbnRQcm9wcyB9ID0gdXNlUmVmRWxlbWVudDxFPih7IG9uRWxlbWVudENoYW5nZTogdXNlU3RhYmxlQ2FsbGJhY2soKGVsZW1lbnQ6IEUgfCBudWxsKSA9PiBoYW5kbGVBY3RpdmVDaGFuZ2UodHJhcEFjdGl2ZSwgZWxlbWVudCkpIH0pXG4gICAgY29uc3QgeyBnZXRMYXN0QWN0aXZlRWxlbWVudCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7IGdldERvY3VtZW50OiB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiBnZXRFbGVtZW50KCk/Lm93bmVyRG9jdW1lbnQgPz8gd2luZG93LmRvY3VtZW50ICkgfSk7XG5cblxuICAgIC8vIFdoZW4gdGhlIHRyYXAgYmVjb21lcyBhY3RpdmUsIGJlZm9yZSB3ZSBsZXQgdGhlIGJsb2NraW5nRWxlbWVudHMgaG9vayBydW4sXG4gICAgLy8ga2VlcCB0cmFjayBvZiB3aGF0ZXZlcidzIGN1cnJlbnRseSBmb2N1c2VkIGFuZCBzYXZlIGl0LlxuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XG4gICAgICAgIGlmICh0cmFwQWN0aXZlICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIHRvIHdoYXRldmVyJ3MgY3VycmVudGx5IGF0IHRoZSB0b3Agb2YgdGhlIHN0YWNrXG4gICAgICAgICAgICBlbGVtZW50c1RvUmVzdG9yZUZvY3VzVG8uc2V0KGdldFRvcEVsZW1lbnQoKSwgKGdldExhc3RBY3RpdmVFbGVtZW50KCkgYXMgKEVsZW1lbnQgJiBIVE1MT3JTVkdFbGVtZW50KSkgPz8gZG9jdW1lbnQuYm9keSk7XG4gICAgICAgIH1cbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgdXNlQmxvY2tpbmdFbGVtZW50KHRyYXBBY3RpdmUsIGdldEVsZW1lbnQpO1xuXG4gICAgLyoqXG4gICAgICogQW55IHRpbWUgd2UgYWN0aXZhdGUgb3IgZGVhY3RpdmF0ZSB0aGUgdHJhcCxcbiAgICAgKiBjaGFuZ2UgZm9jdXMgdG8gc29tZXRoaW5nIGVsc2UgKHNvbWV0aGluZyBpblxuICAgICAqIHRoZSB0cmFwIGlmIGl0J3MgYWN0aXZlLCBvciB3aGF0ZXZlciB3ZSd2ZVxuICAgICAqIHRyYWNrZWQgaW4gZWxlbWVudHNUb1Jlc3RvcmVGb2N1c1RvIGlmIG5vdClcbiAgICAgKi9cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBoYW5kbGVBY3RpdmVDaGFuZ2UodHJhcEFjdGl2ZSwgZ2V0RWxlbWVudCgpKTtcbiAgICB9LCBbdHJhcEFjdGl2ZV0pO1xuXG4gICAgY29uc3QgdXNlRm9jdXNUcmFwUHJvcHMgPSAoKHByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPikgPT4ge1xuICAgICAgICBjb25zdCBwMSA9IHVzZU1lcmdlZFByb3BzKHJlZkVsZW1lbnRQcm9wcywgcHJvcHMpO1xuICAgICAgICBjb25zdCBwMiA9IHsgXCJhcmlhLW1vZGFsXCI6IHRyYXBBY3RpdmUgPyBcInRydWVcIiA6IHVuZGVmaW5lZCB9IGFzIGguSlNYLkhUTUxBdHRyaWJ1dGVzPEU+O1xuICAgICAgICByZXR1cm4gdXNlTWVyZ2VkUHJvcHM8RT4ocDEsIHAyKTtcbiAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlRm9jdXNUcmFwUHJvcHMsXG4gICAgICAgIGdldEVsZW1lbnRcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IGNvbnRhaW5lZCB3aXRoaW4gdGhlIGdpdmVuIG5vZGUsIG9yIG51bGwgaWYgbm9uZSBhcmUgZm91bmQuXG4gKiBAcGFyYW0gZWxlbWVudCBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZpcnN0Rm9jdXNhYmxlKGVsZW1lbnQ6IE5vZGUpIHtcbiAgICBjb25zdCB0cmVlV2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihlbGVtZW50LCBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCwgeyBhY2NlcHROb2RlOiAobm9kZSkgPT4gKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIGlzRm9jdXNhYmxlKG5vZGUpID8gTm9kZUZpbHRlci5GSUxURVJfQUNDRVBUIDogTm9kZUZpbHRlci5GSUxURVJfU0tJUCkgfSlcbiAgICBjb25zdCBmaXJzdEZvY3VzYWJsZSA9IHRyZWVXYWxrZXIuZmlyc3RDaGlsZCgpIGFzIChFbGVtZW50ICYgSFRNTE9yU1ZHRWxlbWVudCkgfCBudWxsO1xuICAgIHJldHVybiBmaXJzdEZvY3VzYWJsZTtcbn1cblxuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsLCB3aGVuIGNhbGxlZCwgZm9yY2UgdGhlIGNvbXBvbmVudFxuICogdGhhdCB1c2VzIHRoaXMgaG9vayB0byByZS1yZW5kZXIgaXRzZWxmLlxuICogXG4gKiBJdCdzIGEgYml0IHNtZWxseSwgc28gYmVzdCB0byB1c2Ugc3BhcmluZ2x5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlRm9yY2VVcGRhdGUoKSB7XG4gICAgY29uc3QgWywgc2V0XSA9IHVzZVN0YXRlKDApO1xuICAgIHJldHVybiB1c2VSZWYoKCkgPT4gc2V0KGkgPT4gKytpKSkuY3VycmVudDtcbn0iLCJcclxuaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcclxuaW1wb3J0IHsgVXNlTWFuYWdlZENoaWxkUGFyYW1ldGVycywgdXNlTWFuYWdlZENoaWxkcmVuLCBVc2VNYW5hZ2VkQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XHJcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xyXG5pbXBvcnQgeyB1c2VBY3RpdmVFbGVtZW50LCBVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVycywgVXNlQWN0aXZlRWxlbWVudFJldHVyblR5cGUgfSBmcm9tIFwiLi91c2UtYWN0aXZlLWVsZW1lbnRcIjtcclxuaW1wb3J0IHsgcmV0dXJuRmFsc2UsIHVzZUVuc3VyZVN0YWJpbGl0eSwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcclxuaW1wb3J0IHsgdXNlUmVmRWxlbWVudCwgVXNlUmVmRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRSZXR1cm5UeXBlIH0gZnJvbSBcIi4vdXNlLXJlZi1lbGVtZW50XCI7XHJcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgVXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnMsIFVzZVJlZkVsZW1lbnRQYXJhbWV0ZXJzPFQ+IHtcclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgZWxlbWVudCBpdHNlbGYgY3VycmVudGx5IGhhcyBmb2N1cy5cclxuICAgICAqIFxyXG4gICAgICogYHByZXZGb2N1c2VkYCBpcyBnZW5lcmFsbHkgdGhlIG9wcG9zaXRlIG9mIGBmb2N1c2VkYCwgYnV0IG9uIG1vdW50IGl0J3MgYHVuZGVmaW5lZGAgd2hpbGUgYGZvY3VzZWRgIGlzIHByb2JhYmx5IGZhbHNlIChib3RoIGZhbHN5KVxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRDaGFuZ2VkPyhmb2N1c2VkOiBib29sZWFuLCBwcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCk6IHZvaWQ7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBMaWtlIGBvbkZvY3VzZWRDaGFuZ2VkYCwgYnV0IGFsc28gKmFkZGl0aW9uYWxseSogaWYgYW55IGNoaWxkIGVsZW1lbnRzIGFyZSBmb2N1c2VkLlxyXG4gICAgICogXHJcbiAgICAgKiBAc2VlIHRoaXMub25Gb2N1c2VkQ2hhbmdlZFxyXG4gICAgICovXHJcbiAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIFNpbWlsYXIgdG8gYG9uRm9jdXNlZENoYW5nZWRgLCBidXQgaWYgdGhlcmUgaXMgbm8gY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCwgaXMgYHRydWVgIGlmIHRoaXMgZWxlbWVudCB0aGF0ICpkaWQqIGhhdmUgZm9jdXMgbGFzdC5cclxuICAgICAqIFxyXG4gICAgICogVGhpcyBpcyBhbHdheXMgYHRydWVgIHdoaWxlIGBmb2N1c2VkYCBpcyBgdHJ1ZWAuIElmIGBmb2N1c2VkYCBpcyBgZmFsc2VgLCB0aGlzIG1heSBiZSBgdHJ1ZWAgb3IgYGZhbHNlYC5cclxuICAgICAqL1xyXG4gICAgb25MYXN0Rm9jdXNlZENoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxuXHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoZSBpbXBsaWNhdGlvbnMgb2YgYG9uRm9jdXNlZENoYW5nZWRgIGFuZCBgb25Gb2N1c2VkQ2hhbmdlZGAuXHJcbiAgICAgKi9cclxuICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/KGZvY3VzZWQ6IGJvb2xlYW4sIHByZXZGb2N1c2VkOiBib29sZWFuIHwgdW5kZWZpbmVkKTogdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VIYXNGb2N1c1JldHVyblR5cGU8VCBleHRlbmRzIE5vZGU+IGV4dGVuZHMgT21pdDxVc2VSZWZFbGVtZW50UmV0dXJuVHlwZTxUPiwgXCJyZWZFbGVtZW50UHJvcHNcIj4sIFVzZUFjdGl2ZUVsZW1lbnRSZXR1cm5UeXBlIHtcclxuXHJcbiAgICAvKipcclxuICAgICAqIE1vZGlmaWVzIHRoZSBlbGVtZW50IHRvIGJlIGFibGUgdG8gdHJhY2sgaXRzIG93biBmb2N1cyBzdGF0ZVxyXG4gICAgICogXHJcbiAgICAgKiAqKlNUQUJMRSoqXHJcbiAgICAgKi9cclxuICAgIGhhc0ZvY3VzUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFQ+O1xyXG5cclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldEZvY3VzZWRJbm5lcigpOiBib29sZWFuO1xyXG4gICAgLyoqIFNUQUJMRSAqL1xyXG4gICAgZ2V0TGFzdEZvY3VzZWQoKTogYm9vbGVhbjtcclxuICAgIC8qKiBTVEFCTEUgKi9cclxuICAgIGdldExhc3RGb2N1c2VkSW5uZXIoKTogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUhhc0ZvY3VzPFQgZXh0ZW5kcyBOb2RlPih7IG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlLCBnZXREb2N1bWVudCwgZ2V0V2luZG93LCBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCB9OiBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8VD4pOiBVc2VIYXNGb2N1c1JldHVyblR5cGU8VD4ge1xyXG5cclxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUhhc0ZvY3VzXCIsIG9uRm9jdXNlZENoYW5nZWQsIG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgb25MYXN0Rm9jdXNlZENoYW5nZWQsIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uQWN0aXZlRWxlbWVudENoYW5nZSwgb25XaW5kb3dGb2N1c2VkQ2hhbmdlKTtcclxuXHJcbiAgICBjb25zdCBbZ2V0Rm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25Gb2N1c2VkQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG4gICAgY29uc3QgW2dldEZvY3VzZWRJbm5lciwgc2V0Rm9jdXNlZElubmVyXSA9IHVzZVBhc3NpdmVTdGF0ZTxib29sZWFuPihvbkZvY3VzZWRJbm5lckNoYW5nZWQsIHJldHVybkZhbHNlKTtcclxuICAgIGNvbnN0IFtnZXRMYXN0Rm9jdXNlZCwgc2V0TGFzdEZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPGJvb2xlYW4+KG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCByZXR1cm5GYWxzZSk7XHJcbiAgICBjb25zdCBbZ2V0TGFzdEZvY3VzZWRJbm5lciwgc2V0TGFzdEZvY3VzZWRJbm5lcl0gPSB1c2VQYXNzaXZlU3RhdGU8Ym9vbGVhbj4ob25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgcmV0dXJuRmFsc2UpO1xyXG5cclxuICAgIGNvbnN0IHsgZ2V0RWxlbWVudCwgcmVmRWxlbWVudFByb3BzIH0gPSB1c2VSZWZFbGVtZW50PFQ+KHsgb25FbGVtZW50Q2hhbmdlLCBvbk1vdW50LCBvblVubW91bnQgfSk7XHJcblxyXG4gICAgY29uc3QgeyBnZXRBY3RpdmVFbGVtZW50LCBnZXRMYXN0QWN0aXZlRWxlbWVudCwgZ2V0V2luZG93Rm9jdXNlZCB9ID0gdXNlQWN0aXZlRWxlbWVudCh7XHJcbiAgICAgICAgZ2V0RG9jdW1lbnQsXHJcbiAgICAgICAgZ2V0V2luZG93LFxyXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8VXNlQWN0aXZlRWxlbWVudFBhcmFtZXRlcnNbXCJvbkFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigoYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc2VsZkVsZW1lbnQgPSBnZXRFbGVtZW50KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzZWQgPSAoc2VsZkVsZW1lbnQgIT0gbnVsbCAmJiAoc2VsZkVsZW1lbnQgPT0gYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMoYWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkKGZvY3VzZWQpO1xyXG4gICAgICAgICAgICBzZXRGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25BY3RpdmVFbGVtZW50Q2hhbmdlPy4oYWN0aXZlRWxlbWVudCwgcHJldkFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbkxhc3RBY3RpdmVFbGVtZW50Q2hhbmdlOiB1c2VDYWxsYmFjazxOb25OdWxsYWJsZTxVc2VBY3RpdmVFbGVtZW50UGFyYW1ldGVyc1tcIm9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2VcIl0+PigobGFzdEFjdGl2ZUVsZW1lbnQsIHByZXZMYXN0QWN0aXZlRWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzZWxmRWxlbWVudCA9IGdldEVsZW1lbnQoKTtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXNlZCA9IChzZWxmRWxlbWVudCAhPSBudWxsICYmIChzZWxmRWxlbWVudCA9PSBsYXN0QWN0aXZlRWxlbWVudCBhcyBOb2RlIHwgbnVsbCkpO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1c2VkSW5uZXIgPSAoISFzZWxmRWxlbWVudD8uY29udGFpbnMobGFzdEFjdGl2ZUVsZW1lbnQgYXMgTm9kZSB8IG51bGwpKTtcclxuICAgICAgICAgICAgc2V0TGFzdEZvY3VzZWQoZm9jdXNlZCk7XHJcbiAgICAgICAgICAgIHNldExhc3RGb2N1c2VkSW5uZXIoZm9jdXNlZElubmVyKTtcclxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZT8uKGxhc3RBY3RpdmVFbGVtZW50LCBwcmV2TGFzdEFjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgIH0sIFtdKSxcclxuICAgICAgICBvbldpbmRvd0ZvY3VzZWRDaGFuZ2VcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGhhc0ZvY3VzUHJvcHMgPSByZWZFbGVtZW50UHJvcHM7XHJcblxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgaGFzRm9jdXNQcm9wcyxcclxuICAgICAgICBnZXRFbGVtZW50LFxyXG4gICAgICAgIGdldEZvY3VzZWQsXHJcbiAgICAgICAgZ2V0Rm9jdXNlZElubmVyLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkLFxyXG4gICAgICAgIGdldExhc3RGb2N1c2VkSW5uZXIsXHJcbiAgICAgICAgZ2V0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRMYXN0QWN0aXZlRWxlbWVudCxcclxuICAgICAgICBnZXRXaW5kb3dGb2N1c2VkXHJcbiAgICB9O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVycyBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBuZXZlcj4ge1xyXG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IHtcclxuICAgICAgICBvbkFueUdhaW5lZEZvY3VzPygpOiB2b2lkO1xyXG4gICAgICAgIG9uQWxsTG9zdEZvY3VzPygpOiB2b2lkO1xyXG4gICAgfVxyXG59XHJcblxyXG5cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIFN1YmJlc3RJbmZvPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCBDLCBLLCBuZXZlciwgU3ViYmVzdEluZm8+LCBVc2VIYXNGb2N1c1BhcmFtZXRlcnM8RT4ge1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEUgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIE9taXQ8VXNlUmVmRWxlbWVudFJldHVyblR5cGU8RT4sIFwidXNlUmVmRWxlbWVudFByb3BzXCI+LCBPbWl0PFVzZUhhc0ZvY3VzUmV0dXJuVHlwZTxFPiwgXCJ1c2VIYXNGb2N1c1Byb3BzXCI+IHtcclxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8RT47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVXNlQ2hpbGRyZW5IYXZlRm9jdXNSZXR1cm5UeXBlSW5mbzxDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvPG51bWJlciwgQywgSz4ge1xyXG59XHJcblxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVXaXRoSG9va3M8QywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVJbmZvPEMsIEs+IHtcclxuICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGQ6IDxFIGV4dGVuZHMgRWxlbWVudD4ocGFyYW1ldGVyczogVXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZFBhcmFtZXRlcnM8RSwgQywgSywgQz4pID0+IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hpbGRyZW5IYXZlRm9jdXM8QywgSyBleHRlbmRzIHN0cmluZz4oeyBjaGlsZHJlbkhhdmVGb2N1czogeyBvbkFsbExvc3RGb2N1cywgb25BbnlHYWluZWRGb2N1cyB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMpOiBVc2VDaGlsZHJlbkhhdmVGb2N1c1JldHVyblR5cGVXaXRoSG9va3M8QywgSz4ge1xyXG4gICAgY29uc3QgeyBtYW5hZ2VkQ2hpbGRyZW4sIHVzZU1hbmFnZWRDaGlsZCB9ID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4oeyBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9KTtcclxuICAgIGNvbnN0IGFsbEVsZW1lbnRzUmVmID0gdXNlUmVmPFNldDxOb2RlPj4obmV3IFNldCgpKTtcclxuICAgIGNvbnN0IFtfZ2V0Rm9jdXNDb3VudCwgc2V0Rm9jdXNDb3VudF0gPSB1c2VQYXNzaXZlU3RhdGU8bnVtYmVyPih1c2VTdGFibGVDYWxsYmFjaygoYW55Rm9jdXNlZDogbnVtYmVyLCBhbnlQcmV2aW91c2x5Rm9jdXNlZDogbnVtYmVyIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgY29uc29sZS5hc3NlcnQoYW55Rm9jdXNlZCA+PSAwICYmIGFueUZvY3VzZWQgPD0gMSk7XHJcblxyXG4gICAgICAgIGlmIChhbnlGb2N1c2VkICYmICFhbnlQcmV2aW91c2x5Rm9jdXNlZClcclxuICAgICAgICAgICAgb25BbnlHYWluZWRGb2N1cz8uKCk7XHJcbiAgICAgICAgaWYgKCFhbnlGb2N1c2VkICYmIGFueVByZXZpb3VzbHlGb2N1c2VkKVxyXG4gICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XHJcbiAgICB9KSk7XHJcblxyXG4gICAgY29uc3QgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCA9IHVzZUNhbGxiYWNrKDxFIGV4dGVuZHMgRWxlbWVudD4oeyBvbkVsZW1lbnRDaGFuZ2UsIG9uTW91bnQsIG9uVW5tb3VudCwgZ2V0RG9jdW1lbnQsIGdldFdpbmRvdywgb25BY3RpdmVFbGVtZW50Q2hhbmdlLCBvbkZvY3VzZWRDaGFuZ2VkLCBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIG9uTGFzdEFjdGl2ZUVsZW1lbnRDaGFuZ2UsIG9uTGFzdEZvY3VzZWRDaGFuZ2VkLCBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkLCBvbldpbmRvd0ZvY3VzZWRDaGFuZ2UsIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgc3ViSW5mbyB9OiBVc2VDaGlsZHJlbkhhdmVGb2N1c0NoaWxkUGFyYW1ldGVyczxFLCBDLCBLLCBDPik6IFVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRSZXR1cm5UeXBlPEU+ID0+IHtcclxuICAgICAgICB1c2VNYW5hZ2VkQ2hpbGQoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIHN1YkluZm8gfSk7XHJcbiAgICAgICAgY29uc3QgeyBoYXNGb2N1c1Byb3BzLCAuLi5oYXNGb2N1cyB9ID0gdXNlSGFzRm9jdXM8RT4oe1xyXG4gICAgICAgICAgICBnZXREb2N1bWVudCxcclxuICAgICAgICAgICAgZ2V0V2luZG93LFxyXG4gICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2UsXHJcbiAgICAgICAgICAgIG9uRWxlbWVudENoYW5nZTogdXNlQ2FsbGJhY2soKGU6IEUgfCBudWxsLCBwcmV2OiBFIHwgbnVsbCB8IHVuZGVmaW5lZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgbGV0IHIgPSBvbkVsZW1lbnRDaGFuZ2U/LihlLCBwcmV2KTtcclxuICAgICAgICAgICAgICAgIGlmIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYWxsRWxlbWVudHNSZWYuY3VycmVudC5hZGQoZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcj8uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbEVsZW1lbnRzUmVmLmN1cnJlbnQuZGVsZXRlKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgW29uRWxlbWVudENoYW5nZV0pLFxyXG4gICAgICAgICAgICBvbk1vdW50LFxyXG4gICAgICAgICAgICBvblVubW91bnQsXHJcbiAgICAgICAgICAgIG9uRm9jdXNlZENoYW5nZWQsXHJcbiAgICAgICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZCxcclxuICAgICAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZSxcclxuICAgICAgICAgICAgb25MYXN0Rm9jdXNlZENoYW5nZWQsXHJcbiAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmb2N1c2VkOiBib29sZWFuLCBwcmV2OiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSArIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZvY3VzZWQgJiYgcHJldikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldEZvY3VzQ291bnQocCA9PiAocCA/PyAwKSAtIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcclxuICAgICAgICAgICAgfSksXHJcbiAgICAgICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjaGlsZHJlbkhhdmVGb2N1c0NoaWxkUHJvcHM6IGhhc0ZvY3VzUHJvcHMsXHJcbiAgICAgICAgICAgIC4uLmhhc0ZvY3VzXHJcbiAgICAgICAgfVxyXG4gICAgfSwgW10pO1xyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxyXG4gICAgICAgIHVzZUNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVGltZW91dFBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC4gIFxuICAgICAqIElmIGBudWxsYCwgY2FuY2VscyB0aGUgdGltZW91dCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICB0aW1lb3V0OiBudW1iZXIgfCBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQ2hhbmdlcyB0byB0aGlzIHByb3AgYmV0d2VlbiByZW5kZXJzIGNhbiBiZSB1c2VkIHRvIGNsZWFyIHRoZSBjdXJyZW50IHRpbWVvdXQgYW5kIGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgICovXG4gICAgdHJpZ2dlckluZGV4PzogdW5rbm93bjtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKiBcbiAgICAgKiBEb2VzICpub3QqIG5lZWQgdG8gYmUgc3RhYmxlLiBHbyBhaGVhZCBhbmQgcGFzcyBhbiBhbm9ueW1vdXMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgY2FsbGJhY2s6ICgpID0+IHZvaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VUaW1lb3V0KHsgdGltZW91dCwgY2FsbGJhY2ssIHRyaWdnZXJJbmRleCB9OiBVc2VUaW1lb3V0UGFyYW1ldGVycykge1xuICAgIGNvbnN0IHN0YWJsZUNhbGxiYWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4geyBzdGFydFRpbWVSZWYuY3VycmVudCA9IG51bGw7IGNhbGxiYWNrKCk7IH0pO1xuICAgIGNvbnN0IGdldFRpbWVvdXQgPSB1c2VTdGFibGVHZXR0ZXIodGltZW91dCk7XG5cbiAgICAvLyBTZXQgYW55IHRpbWUgd2Ugc3RhcnQgdGltZW91dC5cbiAgICAvLyBVbnNldCBhbnkgdGltZSB0aGUgdGltZW91dCBjb21wbGV0ZXNcbiAgICBjb25zdCBzdGFydFRpbWVSZWYgPSB1c2VSZWY8bnVtYmVyIHwgbnVsbD4obnVsbCk7XG5cbiAgICBjb25zdCB0aW1lb3V0SXNOdWxsID0gKHRpbWVvdXQgPT0gbnVsbCk7XG5cbiAgICAvLyBBbnkgdGltZSB0aGUgdHJpZ2dlckluZGV4IGNoYW5nZXMgKGluY2x1ZGluZyBvbiBtb3VudClcbiAgICAvLyByZXN0YXJ0IHRoZSB0aW1lb3V0LiAgVGhlIHRpbWVvdXQgZG9lcyBOT1QgcmVzZXRcbiAgICAvLyB3aGVuIHRoZSBkdXJhdGlvbiBvciBjYWxsYmFjayBjaGFuZ2VzLCBvbmx5IHRyaWdnZXJJbmRleC5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXRpbWVvdXRJc051bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVvdXQgPSBnZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydCh0aW1lb3V0SXNOdWxsID09ICh0aW1lb3V0ID09IG51bGwpKTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0aW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBzdGFydFRpbWVSZWYuY3VycmVudCA9ICsobmV3IERhdGUoKSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dChzdGFibGVDYWxsYmFjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFt0cmlnZ2VySW5kZXgsIHRpbWVvdXRJc051bGxdKVxuXG4gICAgY29uc3QgZ2V0RWxhcHNlZFRpbWUgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKyhuZXcgRGF0ZSgpKSkgLSAoKyhzdGFydFRpbWVSZWYuY3VycmVudCA/PyBuZXcgRGF0ZSgpKSk7XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3QgZ2V0UmVtYWluaW5nVGltZSA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IGdldFRpbWVvdXQoKTtcbiAgICAgICAgcmV0dXJuIHRpbWVvdXQgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1heCgwLCB0aW1lb3V0IC0gZ2V0RWxhcHNlZFRpbWUoKSlcbiAgICB9LCBbXSk7XG5cbiAgICByZXR1cm4geyBnZXRFbGFwc2VkVGltZSwgZ2V0UmVtYWluaW5nVGltZSB9O1xufVxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZUxheW91dEVmZmVjdCwgdXNlUmVmIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlVGltZW91dCB9IGZyb20gXCIuL3VzZS10aW1lb3V0XCI7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaW5lYXJOYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm8ge1xuICAgIC8qKiBcbiAgICAgKiBUaGVzZSBwcm9wcyBjYW4gYmUgYXR0YXRjaGVkIGVpdGhlciB0byB0aGUgcGFyZW50IG9yIHRvIGVhY2ggaW5kaXZpZHVhbCBjaGlsZC5cbiAgICAgKiBXaGljaGV2ZXIgd29ya3MgYmV0dGVyIGZvciB5b3VyIHNjZW5hcmlvLlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKiogXG4gICAgICogKi9cbiAgICBsaW5lYXJOYXZpZ2F0aW9uUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50Pjtcbn1cblxuaW50ZXJmYWNlIExOUCB7XG4gICAgbmF2aWdhdGVUb05leHQoKTogdm9pZDtcbiAgICBuYXZpZ2F0ZVRvUHJldigpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9GaXJzdCgpOiB2b2lkO1xuICAgIG5hdmlnYXRlVG9MYXN0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQ29udHJvbHMgd2hpY2ggYXJyb3cga2V5cyBhcmUgdXNlZCB0byBuYXZpZ2F0ZSB0aHJvdWdoIHRoZSBjb21wb25lbnQuXG4gICAgICogTm90IHJlbGF0aXZlIHRvIHRoZSB3cml0aW5nIG1vZGUgLS0gdGhlc2UgYXJlIHRoZSBsaXRlcmFsIGtleXMgdGhhdCBuZWVkIHRvIGJlIHByZXNzZWQuXG4gICAgICogXG4gICAgICogVXNlIFwiZWl0aGVyXCIgdG8gYWxsb3cgbmF2aWdhdGlvbiBpbiBlaXRoZXIgZGlyZWN0aW9uLlxuICAgICAqIFxuICAgICAqIFVzZSBcIm5vbmVcIiB0byBkaXNhbGxvdyBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgaW4gYW55IGRpcmVjdGlvbi5cbiAgICAgKi9cbiAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uPzogXCJob3Jpem9udGFsXCIgfCBcInZlcnRpY2FsXCIgfCBcImVpdGhlclwiIHwgXCJub25lXCI7XG5cbiAgICAvKipcbiAgICAgKiBJZiBzZXQgdG8gdHJ1ZSwgbmF2aWdhdGlvbiB3aXRoIHRoZSBhcnJvdyBrZXlzIHdpbGwgYmUgXG4gICAgICogZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgdW5hZmZlY3RlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlQXJyb3dLZXlzPzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIElmIHNldCB0byB0cnVlLCBuYXZpZ2F0aW9uIHdpdGggdGhlIGhvbWUgJiBlbmQga2V5cyB3aWxsXG4gICAgICogYmUgZGlzYWJsZWQsIGJ1dCBuYXZpZ2F0aW9uIHdpdGggdGhlIGFycm93IGtleXMgd2lsbCBiZVxuICAgICAqIHVuYWZmZWN0ZWQuXG4gICAgICovXG4gICAgZGlzYWJsZUhvbWVFbmRLZXlzPzogYm9vbGVhbjtcbn1cbmV4cG9ydCB0eXBlIExpbmVhck5hdmlnYXRpb25PbWl0cyA9IGtleW9mIExOUDtcblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIHBhcmVudCBgdXNlTGluZWFyTmF2aWdhdGlvbmAgKi9cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8T21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHM+IHtcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBPbWl0PExOUCwgT21pdHM+XG59XG5cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VMaW5lYXJOYXZpZ2F0aW9uQ2hpbGRgICovXG4vL2V4cG9ydCBpbnRlcmZhY2UgVXNlTGluZWFyTmF2aWdhdGlvbkNoaWxkSW5mbyB7IH1cblxuLyoqXG4gKiBXaGVuIHVzZWQgaW4gdGFuZGVtIHdpdGggYHVzZVJvdmluZ1RhYkluZGV4YCwgYWxsb3dzIGNvbnRyb2wgb2ZcbiAqIHRoZSB0YWJiYWJsZSBpbmRleCB3aXRoIHRoZSBhcnJvdyBrZXlzLlxuICogXG4gKiBAc2VlIHVzZUxpc3ROYXZpZ2F0aW9uLCB3aGljaCBwYWNrYWdlcyBldmVyeXRoaW5nIHVwIHRvZ2V0aGVyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+KHsgbGluZWFyTmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvRmlyc3Q6IG50ZiwgbmF2aWdhdGVUb0xhc3Q6IG50bCwgbmF2aWdhdGVUb05leHQ6IG50biwgbmF2aWdhdGVUb1ByZXY6IG50cCwgbmF2aWdhdGlvbkRpcmVjdGlvbjogbmQsIGRpc2FibGVBcnJvd0tleXM6IGRhaywgZGlzYWJsZUhvbWVFbmRLZXlzOiBkaGVrIH0gfTogVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXI+KTogVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQ+IHtcblxuICAgIG5kID8/PSBcImVpdGhlclwiO1xuXG4gICAgLy9jb25zdCB7IGdldExvZ2ljYWxEaXJlY3Rpb25JbmZvLCB1c2VMb2dpY2FsRGlyZWN0aW9uUHJvcHMgfSA9IHVzZUxvZ2ljYWxEaXJlY3Rpb248UGFyZW50T3JDaGlsZEVsZW1lbnQ+KHt9KTtcblxuICAgIGNvbnN0IG5hdmlnYXRlVG9GaXJzdCA9IHVzZVN0YWJsZUNhbGxiYWNrKG50Zik7XG4gICAgY29uc3QgbmF2aWdhdGVUb0xhc3QgPSB1c2VTdGFibGVDYWxsYmFjayhudGwpO1xuICAgIGNvbnN0IG5hdmlnYXRlVG9OZXh0ID0gdXNlU3RhYmxlQ2FsbGJhY2sobnRuKTtcbiAgICBjb25zdCBuYXZpZ2F0ZVRvUHJldiA9IHVzZVN0YWJsZUNhbGxiYWNrKG50cCk7XG4gICAgY29uc3QgZ2V0RGlzYWJsZUFycm93S2V5cyA9IHVzZVN0YWJsZUdldHRlcihkYWspO1xuICAgIGNvbnN0IGdldERpc2FibGVIb21lRW5kS2V5cyA9IHVzZVN0YWJsZUdldHRlcihkaGVrKTtcbiAgICBjb25zdCBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uID0gdXNlU3RhYmxlR2V0dGVyKG5kKTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb25Qcm9wczoge1xuICAgICAgICAgICAgb25LZXlEb3duOiAoZTogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICAvL2NvbnN0IGluZm8gPSBnZXRMb2dpY2FsRGlyZWN0aW9uSW5mbygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hdmlnYXRpb25EaXJlY3Rpb24gPSBnZXROYXZpZ2F0aW9uRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZUFycm93S2V5cyA9IGdldERpc2FibGVBcnJvd0tleXMoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlSG9tZUVuZEtleXMgPSBnZXREaXNhYmxlSG9tZUVuZEtleXMoKTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c1ZlcnRpY2FsTmF2aWdhdGlvbiA9IChuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwidmVydGljYWxcIiB8fCBuYXZpZ2F0aW9uRGlyZWN0aW9uID09IFwiZWl0aGVyXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbG93c0hvcml6b250YWxOYXZpZ2F0aW9uID0gKG5hdmlnYXRpb25EaXJlY3Rpb24gPT0gXCJob3Jpem9udGFsXCIgfHwgbmF2aWdhdGlvbkRpcmVjdGlvbiA9PSBcImVpdGhlclwiKTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5rZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93VXBcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zdCBwcm9wTmFtZSA9IChpbmZvPy5ibG9ja09yaWVudGF0aW9uID09PSBcInZlcnRpY2FsXCIgPyBcImJsb2NrRGlyZWN0aW9uXCIgOiBcImlubGluZURpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzVmVydGljYWxOYXZpZ2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb25BbGxvd2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb1ByZXYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJBcnJvd0Rvd25cIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NWZXJ0aWNhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvTmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQXJyb3dMZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbkFsbG93ZWQgPSAoIWRpc2FibGVBcnJvd0tleXMgJiYgYWxsb3dzSG9yaXpvbnRhbE5hdmlnYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbkFsbG93ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFycm93UmlnaHRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uQWxsb3dlZCA9ICghZGlzYWJsZUFycm93S2V5cyAmJiBhbGxvd3NIb3Jpem9udGFsTmF2aWdhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uQWxsb3dlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkhvbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZGlzYWJsZUhvbWVFbmRLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0ZpcnN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiRW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRpc2FibGVIb21lRW5kS2V5cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRlVG9MYXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIGN1cnJlbnRUeXBlYWhlYWQ6IHN0cmluZyB8IG51bGw7XG4gICAgICAgIGludmFsaWRUeXBlYWhlYWQ6IGJvb2xlYW4gfCBudWxsO1xuICAgIH1cbn1cblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB7XG4gICAgLyoqXG4gICAgICogQ2FuIGJlIHVzZWQgb24gZWl0aGVyIHRoZSBwYXJlbnQgb3IgZWFjaCBjaGlsZCBlbGVtZW50LlxuICAgICAqIFxuICAgICAqICoqU1RBQkxFKipcbiAgICAgKi9cbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUHJvcHM6IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudE9yQ2hpbGRFbGVtZW50PjtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQ7XG5cbn1cblxuZXhwb3J0IHR5cGUgVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZSA9IHZvaWQ7XG5cbmludGVyZmFjZSBUTlAge1xuICAgIC8qKlxuICAgICAqIEEgY29sbGF0b3IgdG8gdXNlIHdoZW4gY29tcGFyaW5nLiBJZiBub3QgcHJvdmlkZWQsIHNpbXBseSB1c2VzIGBsb2NhbGVDb21wYXJlYCBhZnRlciB0cmFuc2Zvcm1pbmcgZWFjaCB0byBsb3dlcmNhc2UsIHdoaWNoIHdpbGwsIGF0IGJlc3QsIHdvcmsgb2theSBpbiBFbmdsaXNoLlxuICAgICAqL1xuICAgIGNvbGxhdG9yPzogSW50bC5Db2xsYXRvcjtcblxuICAgIG5vVHlwZWFoZWFkPzogYm9vbGVhbjtcblxuICAgIHR5cGVhaGVhZFRpbWVvdXQ/OiBudW1iZXI7XG4gICAgZ2V0SW5kZXgoKTogbnVtYmVyIHwgbnVsbDtcbiAgICBzZXRJbmRleCh2YWx1ZTogbnVtYmVyIHwgbnVsbCB8ICgocHJldmlvdXNWYWx1ZTogbnVtYmVyIHwgbnVsbCkgPT4gKG51bWJlciB8IG51bGwpKSk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyA9IGtleW9mIFROUDtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxPbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cz4ge1xuICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IE9taXQ8VE5QLCBPbWl0cz5cbn1cblxuLyoqIEFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIGNoaWxkICd1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRgICovXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzIHtcbiAgICAvKipcbiAgICAgKiBJZiBwcm92aWRlZCwgYWxsb3dzIHRoaXMgY29tcG9uZW50IHRvIGJlIG5hdmlnYXRlZCB0byBieSB0eXBpbmcgdGhpcyBzdHJpbmcuIFxuICAgICAqIEl0IHNob3VsZCBiZSB0aGUgc2FtZSB0ZXh0IGNvbnRlbnQgYXMgd2hhdGV2ZXIncyBkaXNwbGF5ZWQsIGlkZWFsbHkuXG4gICAgICovXG4gICAgdGV4dDogc3RyaW5nIHwgbnVsbDtcblxuICAgIGluZGV4OiBudW1iZXI7XG59XG5cbi8qKiBUeXBlIG9mIHRoZSBjaGlsZCdzIHN1Yi1ob29rICovXG5leHBvcnQgdHlwZSBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQgPSAoYXJnczogVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycykgPT4gVXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZTtcblxuXG4vKipcbiAqIEFsbG93cyBmb3IgdGhlIHNlbGVjdGlvbiBvZiBhIG1hbmFnZWQgY2hpbGQgYnkgdHlwaW5nIHRoZSBnaXZlbiB0ZXh0IGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAqIFxuICogQHNlZSB1c2VMaXN0TmF2aWdhdGlvbiwgd2hpY2ggcGFja2FnZXMgZXZlcnl0aGluZyB1cCB0b2dldGhlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZVR5cGVhaGVhZE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50Pih7IHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY29sbGF0b3IsIGdldEluZGV4LCB0eXBlYWhlYWRUaW1lb3V0LCBzZXRJbmRleCwgbm9UeXBlYWhlYWQgfSB9OiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlcj4pOiBVc2VUeXBlYWhlYWROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudD4ge1xuXG5cbiAgICAvLyBGb3IgdHlwZWFoZWFkLCBrZWVwIHRyYWNrIG9mIHdoYXQgb3VyIGN1cnJlbnQgXCJzZWFyY2hcIiBzdHJpbmcgaXMgKGlmIHdlIGhhdmUgb25lKVxuICAgIC8vIGFuZCBhbHNvIGNsZWFyIGl0IGV2ZXJ5IDEwMDAgbXMgc2luY2UgdGhlIGxhc3QgdGltZSBpdCBjaGFuZ2VkLlxuICAgIC8vIE5leHQsIGtlZXAgYSBtYXBwaW5nIG9mIHR5cGVhaGVhZCB2YWx1ZXMgdG8gaW5kaWNlcyBmb3IgZmFzdGVyIHNlYXJjaGluZy5cbiAgICAvLyBBbmQsIGZvciB0aGUgdXNlcidzIHNha2UsIGxldCB0aGVtIGtub3cgd2hlbiB0aGVpciB0eXBlYWhlYWQgY2FuJ3QgbWF0Y2ggYW55dGhpbmcgYW55bW9yZVxuICAgIGNvbnN0IFtjdXJyZW50VHlwZWFoZWFkLCBzZXRDdXJyZW50VHlwZWFoZWFkLCBnZXRDdXJyZW50VHlwZWFoZWFkXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZVRpbWVvdXQoeyB0aW1lb3V0OiB0eXBlYWhlYWRUaW1lb3V0ID8/IDEwMDAsIGNhbGxiYWNrOiAoKSA9PiB7IHNldEN1cnJlbnRUeXBlYWhlYWQobnVsbCk7IHNldEludmFsaWRUeXBlYWhlYWQobnVsbCk7IH0sIHRyaWdnZXJJbmRleDogY3VycmVudFR5cGVhaGVhZCB9KTtcbiAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmZvID0gdXNlUmVmPHsgdGV4dDogc3RyaW5nLCB1bnNvcnRlZEluZGV4OiBudW1iZXIgfVtdPihbXSk7XG4gICAgY29uc3QgW2ludmFsaWRUeXBlYWhlYWQsIHNldEludmFsaWRUeXBlYWhlYWRdID0gdXNlU3RhdGU8Ym9vbGVhbiB8IG51bGw+KGZhbHNlKTtcblxuICAgIC8vIEhhbmRsZSB0eXBlYWhlYWQgZm9yIGlucHV0IG1ldGhvZCBlZGl0b3JzIGFzIHdlbGxcbiAgICAvLyBFc3NlbnRpYWxseSwgd2hlbiBhY3RpdmUsIGlnbm9yZSBmdXJ0aGVyIGtleXMgXG4gICAgLy8gYmVjYXVzZSB3ZSdyZSB3YWl0aW5nIGZvciBhIENvbXBvc2l0aW9uRW5kIGV2ZW50XG4gICAgY29uc3QgWywgc2V0SW1lQWN0aXZlLCBnZXRJbWVBY3RpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgLy8gQmVjYXVzZSBjb21wb3NpdGlvbiBldmVudHMgZmlyZSAqYWZ0ZXIqIGtleWRvd24gZXZlbnRzIFxuICAgIC8vIChidXQgd2l0aGluIHRoZSBzYW1lIHRhc2ssIHdoaWNoLCBUT0RPLCBjb3VsZCBiZSBicm93c2VyLWRlcGVuZGVudCksXG4gICAgLy8gd2UgY2FuIHVzZSB0aGlzIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnQgd2UncmUgbGlzdGVuaW5nIGZvciBvbiB0aGUgZmlyc3Qga2V5ZG93bi5cbiAgICBjb25zdCBbbmV4dFR5cGVhaGVhZENoYXIsIHNldE5leHRUeXBlYWhlYWRDaGFyXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChuZXh0VHlwZWFoZWFkQ2hhciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0Q3VycmVudFR5cGVhaGVhZCh0eXBlYWhlYWQgPT4gKCh0eXBlYWhlYWQgPz8gXCJcIikgKyBuZXh0VHlwZWFoZWFkQ2hhcikpO1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIobnVsbCk7XG4gICAgICAgIH1cbiAgICB9LCBbbmV4dFR5cGVhaGVhZENoYXJdKTtcblxuXG4gICAgY29uc3QgY29tcGFyYXRvclNoYXJlZCA9IHVzZVN0YWJsZUNhbGxiYWNrKChzYWZlTGhzOiBzdHJpbmcsIHNhZmVSaHM6IHN0cmluZykgPT4ge1xuICAgICAgICBsZXQgY29tcGFyZTogbnVtYmVyO1xuICAgICAgICAvLyBGb3IgdGhlIHB1cnBvc2VzIG9mIHR5cGVhaGVhZCwgb25seSBjb21wYXJlIGEgc3RyaW5nIG9mIHRoZSBzYW1lIHNpemUgYXMgb3VyIGN1cnJlbnRseSB0eXBlZCBzdHJpbmcuXG4gICAgICAgIC8vIEJ5IG5vcm1hbGl6aW5nIHRoZW0gZmlyc3QsIHdlIGVuc3VyZSB0aGlzIGJ5dGUtYnktYnl0ZSBoYW5kbGluZyBvZiByYXcgY2hhcmFjdGVyIGRhdGEgd29ya3Mgb3V0IG9rYXkuXG4gICAgICAgIHNhZmVMaHMgPSBzYWZlTGhzLm5vcm1hbGl6ZShcIk5GRFwiKTtcbiAgICAgICAgc2FmZVJocyA9IHNhZmVSaHMubm9ybWFsaXplKFwiTkZEXCIpXG5cbiAgICAgICAgaWYgKGNvbGxhdG9yKVxuICAgICAgICAgICAgY29tcGFyZSA9IGNvbGxhdG9yLmNvbXBhcmUoc2FmZUxocywgc2FmZVJocylcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29tcGFyZSA9IHNhZmVMaHMudG9Mb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKHNhZmVSaHMudG9Mb3dlckNhc2UoKSA/PyBcIlwiKTtcblxuICAgICAgICByZXR1cm4gY29tcGFyZTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGluc2VydGluZ0NvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcsIHJoczogeyB0ZXh0OiBzdHJpbmc7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfSkgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gKGxocyBhcyB1bmtub3duIGFzIG51bWJlcikgLSAocmhzIGFzIHVua25vd24gYXMgbnVtYmVyKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHR5cGVhaGVhZENvbXBhcmF0b3IgPSB1c2VTdGFibGVDYWxsYmFjaygobGhzOiBzdHJpbmcsIHJoczogeyB0ZXh0OiBzdHJpbmc7IHVuc29ydGVkSW5kZXg6IG51bWJlcjsgfSkgPT4ge1xuXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiByaHMudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gRHVyaW5nIHR5cGVhaGVhZCwgYWxsIHN0cmluZ3MgbG9uZ2VyIHRoYW4gb3VycyBzaG91bGQgYmUgdHJ1bmNhdGVkXG4gICAgICAgICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWxsIGNvbnNpZGVyZWQgZXF1YWxseSBieSB0aGF0IHBvaW50LlxuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3JTaGFyZWQobGhzLCByaHMudGV4dC5zdWJzdHJpbmcoMCwgbGhzLmxlbmd0aCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIChsaHMgYXMgdW5rbm93biBhcyBudW1iZXIpIC0gKHJocyBhcyB1bmtub3duIGFzIG51bWJlcik7XG4gICAgfSk7XG5cbiAgICBjb25zdCBpc0Rpc2FibGVkID0gdXNlU3RhYmxlR2V0dGVyKG5vVHlwZWFoZWFkKTtcblxuXG4gICAgY29uc3QgdHlwZWFoZWFkTmF2aWdhdGlvblByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD4gPSB7XG4gICAgICAgIG9uS2V5RG93bjogKGU6IEtleWJvYXJkRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBjb25zdCBpbWVBY3RpdmUgPSBnZXRJbWVBY3RpdmUoKTtcblxuICAgICAgICAgICAgY29uc3Qga2V5ID0gZS5rZXk7XG5cbiAgICAgICAgICAgIC8vIE5vdCBoYW5kbGVkIGJ5IHR5cGVhaGVhZCAoaS5lLiBhc3N1bWUgdGhpcyBpcyBhIGtleWJvYXJkIHNob3J0Y3V0KVxuICAgICAgICAgICAgaWYgKGUuY3RybEtleSB8fCBlLm1ldGFLZXkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICBpZiAoIWltZUFjdGl2ZSAmJiBlLmtleSA9PT0gXCJCYWNrc3BhY2VcIikge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgbGFzdCBjaGFyYWN0ZXIgaW4gYSB3YXkgdGhhdCBkb2Vzbid0IHNwbGl0IFVURi0xNiBzdXJyb2dhdGVzLlxuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRUeXBlYWhlYWQodCA9PiB0ID09PSBudWxsID8gbnVsbCA6IFsuLi50XS5yZXZlcnNlKCkuc2xpY2UoMSkucmV2ZXJzZSgpLmpvaW4oXCJcIikpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gVGhlIGtleSBwcm9wZXJ0eSByZXByZXNlbnRzIHRoZSB0eXBlZCBjaGFyYWN0ZXIgT1IgdGhlIFwibmFtZWQga2V5IGF0dHJpYnV0ZVwiIG9mIHRoZSBrZXkgcHJlc3NlZC5cbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gZGVmaW5pdGUgd2F5IHRvIHRlbGwgdGhlIGRpZmZlcmVuY2UsIGJ1dCBmb3IgYWxsIGludGVudHMgYW5kIHB1cnBvc2VzXG4gICAgICAgICAgICAvLyB0aGVyZSBhcmUgbm8gb25lLWNoYXJhY3RlciBuYW1lcywgYW5kIHRoZXJlIGFyZSBubyBub24tQVNDSUktYWxwaGEgbmFtZXMuXG4gICAgICAgICAgICAvLyBUaHVzLCBhbnkgb25lLWNoYXJhY3RlciBvciBub24tQVNDSUkgdmFsdWUgZm9yIGBrZXlgIGlzICphbG1vc3QgY2VydGFpbmx5KiBhIHR5cGVkIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIGNvbnN0IGlzQ2hhcmFjdGVyS2V5ID0gKGtleS5sZW5ndGggPT09IDEgfHwgIS9eW0EtWmEtel0vLnRlc3Qoa2V5KSk7XG4gICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXJLZXkpIHtcblxuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCIgXCIgJiYgKGdldEN1cnJlbnRUeXBlYWhlYWQoKSA/PyBcIlwiKS50cmltKCkubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgYmVjYXVzZSBhIHNwYWNlYmFyIGNhbid0IGV2ZXIgXG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXRpYXRlIGEgdHlwZWFoZWFkLCBvbmx5IGNvbnRpbnVlIG9uZS5cblxuICAgICAgICAgICAgICAgICAgICAvLyAoU3BlY2lmaWNhbGx5LCBsZXQgdGhlIGV2ZW50IGNvbnRpbnVlIHByb3BhZ2F0aW9uIGluIHRoaXMgY2FzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IFdvbid0IGJlIHRydWUgZm9yIHRoZSBmaXJzdCBrZXlkb3duXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCB3aWxsIGJlIG92ZXJ3cml0dGVuIGJlZm9yZSB1c2VMYXlvdXRFZmZlY3QgaXMgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFjdHVhbGx5IGFwcGx5IHRoZSBjaGFuZ2VcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpbWVBY3RpdmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXROZXh0VHlwZWFoZWFkQ2hhcihrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LCBcbiAgICAgICAgb25Db21wb3NpdGlvblN0YXJ0OiAoZTogQ29tcG9zaXRpb25FdmVudCkgPT4ge1xuICAgICAgICAgICAgc2V0TmV4dFR5cGVhaGVhZENoYXIoZS5kYXRhKTtcbiAgICAgICAgICAgIHNldEltZUFjdGl2ZShmYWxzZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcG9zaXRpb25FbmQ6IChfZTogQ29tcG9zaXRpb25FdmVudCkgPT4geyBzZXRJbWVBY3RpdmUodHJ1ZSkgfSxcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGNoYW5nZXMgaW4gdHlwZWFoZWFkIHRoYXQgY2F1c2UgY2hhbmdlcyB0byB0aGUgdGFiYmFibGUgaW5kZXhcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY3VycmVudFR5cGVhaGVhZCAmJiBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoKSB7XG5cblxuXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWRUeXBlYWhlYWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIGN1cnJlbnRUeXBlYWhlYWQsIHR5cGVhaGVhZENvbXBhcmF0b3IpO1xuXG4gICAgICAgICAgICBpZiAoc29ydGVkVHlwZWFoZWFkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHVzZXIgaGFzIHR5cGVkIGFuIGVudHJ5IHRoYXQgZG9lc24ndCBleGlzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIC8vIChvciBtb3JlIHNwZWNpZmljYWxseSBcImZvciB3aGljaCB0aGVyZSBpcyBubyBlbnRyeSB0aGF0IHN0YXJ0cyB3aXRoIHRoYXQgaW5wdXRcIilcbiAgICAgICAgICAgICAgICBzZXRJbnZhbGlkVHlwZWFoZWFkKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0SW52YWxpZFR5cGVhaGVhZChmYWxzZSk7XG5cbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgV2Uga25vdyByb3VnaGx5IHdoZXJlLCBpbiB0aGUgc29ydGVkIGFycmF5IG9mIHN0cmluZ3MsIG91ciBuZXh0IHR5cGVhaGVhZCBsb2NhdGlvbiBpcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCByb3VnaGx5IGlzbid0IGdvb2QgZW5vdWdoIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBtYXRjaGVzLlxuICAgICAgICAgICAgICAgICAgVG8gY29udmVydCBvdXIgc29ydGVkIGluZGV4IHRvIHRoZSB1bnNvcnRlZCBpbmRleCB3ZSBuZWVkLCB3ZSBoYXZlIHRvIGZpbmQgdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICBlbGVtZW50IHRoYXQgbWF0Y2hlcyB1cyAqYW5kKiAoaWYgYW55IHN1Y2ggZXhpc3QpIGlzICphZnRlciogb3VyIGN1cnJlbnQgc2VsZWN0aW9uLlxuXG4gICAgICAgICAgICAgICAgICBJbiBvdGhlciB3b3JkcywgdGhlIG9ubHkgd2F5IHR5cGVhaGVhZCBtb3ZlcyBiYWNrd2FyZHMgcmVsYXRpdmUgdG8gb3VyIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uIGlzIGlmIHRoZSBvbmx5IG90aGVyIG9wdGlvbiBpcyBiZWhpbmQgdXMuXG5cbiAgICAgICAgICAgICAgICAgIEl0J3Mgbm90IHNwZWNpZmllZCBpbiBXQUktQVJJQSB3aGF0IHRvIGRvIGluIHRoYXQgY2FzZS4gIEkgc3VwcG9zZSB3cmFwIGJhY2sgdG8gdGhlIHN0YXJ0P1xuICAgICAgICAgICAgICAgICAgVGhvdWdoIHRoZXJlJ3MgYWxzbyBhIGNhc2UgZm9yIGp1c3QgZ29pbmcgdXB3YXJkcyB0byB0aGUgbmVhcmVzdCB0byBwcmV2ZW50IGp1bXBpbmVzcy5cbiAgICAgICAgICAgICAgICAgIEJ1dCBpZiB5b3UncmUgYWxyZWFkeSBkb2luZyB0eXBlYWhlYWQgb24gYW4gdW5zb3J0ZWQgbGlzdCwgbGlrZSwganVtcGluZXNzIGNhbid0IGJlIGF2b2lkZWQuXG4gICAgICAgICAgICAgICAgICBJIGR1bm5vLiBHb2luZyBiYWNrIHRvIHRoZSBzdGFydCBpcyB0aGUgc2ltcGxpc3QgdGhvdWdoLlxuXG4gICAgICAgICAgICAgICAgICBCYXNpY2FsbHkgd2hhdCB0aGlzIGRvZXM6IFN0YXJ0aW5nIGZyb20gd2hlcmUgd2UgZm91bmQgb3Vyc2VsdmVzIGFmdGVyIG91ciBiaW5hcnkgc2VhcmNoLFxuICAgICAgICAgICAgICAgICAgc2NhbiBiYWNrd2FyZHMgYW5kIGZvcndhcmRzIHRocm91Z2ggYWxsIGFkamFjZW50IGVudHJpZXMgdGhhdCBhbHNvIGNvbXBhcmUgZXF1YWxseSBzbyB0aGF0XG4gICAgICAgICAgICAgICAgICB3ZSBjYW4gZmluZCB0aGUgb25lIHdob3NlIGB1bnNvcnRlZEluZGV4YCBpcyB0aGUgbG93ZXN0IGFtb25nc3QgYWxsIG90aGVyIGVxdWFsIHN0cmluZ3NcbiAgICAgICAgICAgICAgICAgIChhbmQgYWxzbyB0aGUgbG93ZXN0IGB1bnNvcnRlZEluZGV4YCB5YWRkYSB5YWRkYSBleGNlcHQgdGhhdCBpdCBjb21lcyBhZnRlciB1cykuXG5cbiAgICAgICAgICAgICAgICAgIFRPRE86IFRoZSBiaW5hcnkgc2VhcmNoIHN0YXJ0cyB0aGlzIG9mZiB3aXRoIGEgc29saWQgTyhsb2cgbiksIGJ1dCBvbmUtY2hhcmFjdGVyIFxuICAgICAgICAgICAgICAgICAgc2VhcmNoZXMgYXJlLCB0aGFua3MgdG8gcGlnZW9uaG9sZSBwcmluY2lwYWwsIGV2ZW50dWFsbHkgZ3VhcmFudGVlZCB0byBiZWNvbWUgXG4gICAgICAgICAgICAgICAgICBPKG4qbG9nIG4pLiBUaGlzIGlzIGFubm95aW5nIGJ1dCBwcm9iYWJseSBub3QgZWFzaWx5IHNvbHZhYmxlPyBUaGVyZSBjb3VsZCBiZSBhbiBcbiAgICAgICAgICAgICAgICAgIGV4Y2VwdGlvbiBmb3Igb25lLWNoYXJhY3RlciBzdHJpbmdzLCBidXQgdGhhdCdzIGp1c3Qga2lja2luZyB0aGUgY2FuIGRvd24gXG4gICAgICAgICAgICAgICAgICB0aGUgcm9hZC4gTWF5YmUgb25lIG9yIHR3byBjaGFyYWN0ZXJzIHdvdWxkIGJlIGdvb2QgZW5vdWdoIHRob3VnaC5cbiAgICAgICAgICAgICAgICAqL1xuXG5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBhcmUgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBjYW5kaWRhdGVzJyBwb3NpdGlvbnMgaW4gYm90aCBvdXIgc29ydGVkIGFycmF5IGFuZCB0aGUgdW5zb3J0ZWQgRE9NLlxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4QWxsOiBudW1iZXIgfCBudWxsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbG93ZXN0U29ydGVkSW5kZXhBbGwgPSBzb3J0ZWRUeXBlYWhlYWRJbmRleDtcblxuICAgICAgICAgICAgICAgIC8vIFRoZXNlIHR3byBhcmUgb25seSBzZXQgZm9yIGVsZW1lbnRzIHRoYXQgYXJlIGFoZWFkIG9mIHVzLCBidXQgdGhlIHByaW5jaXBsZSdzIHRoZSBzYW1lIG90aGVyd2lzZVxuICAgICAgICAgICAgICAgIGxldCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dDogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlQmVzdEZpdCA9ICh1OiBudW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhBbGwgPT0gbnVsbCB8fCB1IDwgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG93ZXN0VW5zb3J0ZWRJbmRleEFsbCA9IHU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb3dlc3RTb3J0ZWRJbmRleEFsbCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKChsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCA9PSBudWxsIHx8IHUgPCBsb3dlc3RVbnNvcnRlZEluZGV4TmV4dCkgJiYgdSA+IChnZXRJbmRleCgpID8/IC1JbmZpbml0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ID0gdTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvd2VzdFNvcnRlZEluZGV4TmV4dCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgaSA9IHNvcnRlZFR5cGVhaGVhZEluZGV4O1xuICAgICAgICAgICAgICAgIHdoaWxlIChpID49IDAgJiYgdHlwZWFoZWFkQ29tcGFyYXRvcihjdXJyZW50VHlwZWFoZWFkLCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0pID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQmVzdEZpdChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbaV0udW5zb3J0ZWRJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC0taTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpID0gc29ydGVkVHlwZWFoZWFkSW5kZXg7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQubGVuZ3RoICYmIHR5cGVhaGVhZENvbXBhcmF0b3IoY3VycmVudFR5cGVhaGVhZCwgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldKSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUJlc3RGaXQoc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50W2ldLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICArK2k7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxvd2VzdFVuc29ydGVkSW5kZXhOZXh0ICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhOZXh0XS51bnNvcnRlZEluZGV4KTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RVbnNvcnRlZEluZGV4QWxsICE9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICBzZXRJbmRleChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnRbbG93ZXN0U29ydGVkSW5kZXhBbGxdLnVuc29ydGVkSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2N1cnJlbnRUeXBlYWhlYWRdKTtcblxuICAgIGNvbnN0IHVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZCA9IHVzZUNhbGxiYWNrPFVzZVR5cGVhaGVhZE5hdmlnYXRpb25DaGlsZD4oKHsgaW5kZXgsIHRleHQgfSkgPT4ge1xuXG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGV4dCkge1xuXG4gICAgICAgICAgICAgICAgLy8gRmluZCB3aGVyZSB0byBpbnNlcnQgdGhpcyBpdGVtLlxuICAgICAgICAgICAgICAgIC8vIEJlY2F1c2UgYWxsIGluZGV4IHZhbHVlcyBzaG91bGQgYmUgdW5pcXVlLCB0aGUgcmV0dXJuZWQgc29ydGVkSW5kZXhcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYWx3YXlzIHJlZmVyIHRvIGEgbmV3IGxvY2F0aW9uIChpLmUuIGJlIG5lZ2F0aXZlKSAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjb25zdCBzb3J0ZWRJbmRleCA9IGJpbmFyeVNlYXJjaChzb3J0ZWRUeXBlYWhlYWRJbmZvLmN1cnJlbnQsIHRleHQsIGluc2VydGluZ0NvbXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2UoLXNvcnRlZEluZGV4IC0gMSwgMCwgeyB0ZXh0LCB1bnNvcnRlZEluZGV4OiBpbmRleCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudC5zcGxpY2Uoc29ydGVkSW5kZXgsIDAsIHsgdGV4dCwgdW5zb3J0ZWRJbmRleDogaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiB1bm1vdW50aW5nLCBmaW5kIHdoZXJlIHdlIHdlcmUgYW5kIHJlbW92ZSBvdXJzZWx2ZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFnYWluLCB3ZSBzaG91bGQgYWx3YXlzIGZpbmQgb3Vyc2VsdmVzIGJlY2F1c2UgdGhlcmUgc2hvdWxkIGJlIG5vIGR1cGxpY2F0ZSB2YWx1ZXMgaWYgZWFjaCBpbmRleCBpcyB1bmlxdWUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvcnRlZEluZGV4ID0gYmluYXJ5U2VhcmNoKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudCwgdGV4dCwgaW5zZXJ0aW5nQ29tcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KHNvcnRlZEluZGV4IDwgMCB8fCBpbnNlcnRpbmdDb21wYXJhdG9yKHNvcnRlZFR5cGVhaGVhZEluZm8uY3VycmVudFtzb3J0ZWRJbmRleF0udGV4dCwgeyB1bnNvcnRlZEluZGV4OiBpbmRleCwgdGV4dCB9KSA9PSAwKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydGVkSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc29ydGVkVHlwZWFoZWFkSW5mby5jdXJyZW50LnNwbGljZShzb3J0ZWRJbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0ZXh0XSk7XG5cbiAgICAgICAgcmV0dXJuO1xuXG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkLFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uUHJvcHMsXG5cbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWQsXG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuLyoqXG4gKiBZb3VyIHVzdWFsIGJpbmFyeSBzZWFyY2ggaW1wbGVtZW50YXRpb24uXG4gKiBcbiAqIEl0J3MgdXNlZCBoZXJlIHRvIHF1aWNrbHkgZmluZCBhIGdvb2Qgc3BvdCB0byBzdGFydCBzZWFyY2hpbmcgZm9yIG91ciBuZXh0IHR5cGVhaGVhZCBjYW5kaWRhdGUuXG4gKiBAcGFyYW0gYXJyYXkgVGhlIGFycmF5IHRvIHNlYXJjaCB0aHJvdWdoXG4gKiBAcGFyYW0gd2FudGVkIFRoZSB2YWx1ZSB5b3UnZCBsaWtlIHRvIGZpbmRcbiAqIEBwYXJhbSBjb21wYXJhdG9yIENvbXBhcmVzIGB3YW50ZWRgIHdpdGggdGhlIGN1cnJlbnQgdmFsdWUgaW4gYGFycmF5YFxuICogQHJldHVybnMgQSBub24tbmVnYXRpdmUgdmFsdWUgaWYgYHdhbnRlZGAgd2FzIGZvdW5kLCBhbmQgYSBuZWdhdGl2ZSBudW1iZXIgaWYgbm90LiBcbiAqIFRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIG51bWJlciwgbWludXMgb25lLCBpcyB3aGVyZSBgd2FudGVkYCAqd291bGQqIGJlIGZvdW5kIGlmIGl0ICp3YXMqIGluIGBhcnJheWBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeVNlYXJjaDxULCBVLCBGIGV4dGVuZHMgKGxoczogVSwgcmhzOiBUKSA9PiBudW1iZXI+KGFycmF5OiBUW10sIHdhbnRlZDogVSwgY29tcGFyYXRvcjogRik6IG51bWJlciB7XG4gICAgbGV0IGZpcnN0SW5kZXggPSAwO1xuICAgIGxldCBsYXN0SW5kZXggPSBhcnJheS5sZW5ndGggLSAxO1xuICAgIHdoaWxlIChmaXJzdEluZGV4IDw9IGxhc3RJbmRleCkge1xuICAgICAgICBjb25zdCB0ZXN0SW5kZXggPSAobGFzdEluZGV4ICsgZmlyc3RJbmRleCkgPj4gMTtcbiAgICAgICAgY29uc3QgY29tcGFyaXNvblJlc3VsdCA9IGNvbXBhcmF0b3Iod2FudGVkLCBhcnJheVt0ZXN0SW5kZXhdKTtcblxuICAgICAgICBpZiAoY29tcGFyaXNvblJlc3VsdCA+IDApIHtcbiAgICAgICAgICAgIGZpcnN0SW5kZXggPSB0ZXN0SW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBhcmlzb25SZXN1bHQgPCAwKSB7XG4gICAgICAgICAgICBsYXN0SW5kZXggPSB0ZXN0SW5kZXggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRlc3RJbmRleDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAtZmlyc3RJbmRleCAtIDE7XG59XG4iLCJpbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyBDaGlsZEZsYWdPcGVyYXRpb25zLCBNYW5hZ2VkQ2hpbGRPbWl0cywgTWFuYWdlZENoaWxkcmVuT21pdHMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzLCB1c2VNYW5hZ2VkQ2hpbGRyZW4sIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnMsIFVzZU1hbmFnZWRDaGlsZHJlblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUhhc0ZvY3VzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VQYXNzaXZlU3RhdGUgfSBmcm9tIFwiLi91c2UtcGFzc2l2ZS1zdGF0ZVwiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcblxuLy9leHBvcnQgdHlwZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkSW5mbzxLIGV4dGVuZHMgc3RyaW5nLCBJIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZEluZm9CYXNlPEs+PiA9IFJlcXVpcmVkPEk+ICYgRmxhZ2dhYmxlQ2hpbGRJbmZvPFwidGFiYmFibGVcIj4gJiB7XG4vL307XG5cbmV4cG9ydCB0eXBlIE9uVGFiYmFibGVJbmRleENoYW5nZSA9ICh0YWJiYWJsZUluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxFIGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbz4ge1xuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRhYmJpbmcgdGhyb3VnaCB0aGlzIGNvbXBvbmVudCB3aWxsIGNhdXNlIHRoZSByZWZlcmVuY2VkIGVsZW1lbnQgdG8gYmUgZm9jdXNlZC5cbiAgICAgKiBcbiAgICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgdG8gZG8gc29tZXRoaW5nIGRpZmZlcmVudCBpZiB5b3UnZCBsaWtlLlxuICAgICAqL1xuICAgIGZvY3VzU2VsZigpOiB2b2lkO1xuXG4gICAgZ2V0RWxlbWVudCgpOiBFIHwgbnVsbDtcblxuICAgIGhpZGRlbjogYm9vbGVhbjtcblxuICAgIHN1YkluZm86IFJ0aVN1YkluZm87XG59XG5cbmludGVyZmFjZSBSVElQIHtcbiAgICAvLyBDYWxsZWQgZHVyaW5nIGFuIGVmZmVjdCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyByZW5kZXJlZCBpdHNlbGYgaW4gYSB0YWJiYWJsZSBzdGF0ZVxuICAgIG9uVGFiYmFibGVSZW5kZXI/OiAoaW5kZXg6IG51bWJlcikgPT4gdm9pZDtcblxuICAgIG9uVGFiYmFibGVJbmRleENoYW5nZT86IE9uVGFiYmFibGVJbmRleENoYW5nZTtcblxuICAgIC8vb25UYWJiZWRJblRvPzogKCkgPT4gdm9pZDtcbiAgICAvL29uVGFiYmVkT3V0T2Y/OiAoKSA9PiB2b2lkO1xuXG4gICAgaW5pdGlhbEluZGV4PzogbnVtYmVyO1xufVxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgPSBrZXlvZiBSVElQO1xuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZU1hbmFnZWRDaGlsZHJlblBhcmFtZXRlcnM8bnVtYmVyLCBNY09taXRzPiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IE9taXQ8UlRJUCwgUnRpT21pdHM+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88UnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VNYW5hZ2VkQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxudW1iZXIsIFJ0aVN1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4OiAodXBkYXRlcjogUGFyYW1ldGVyczxTdGF0ZVVwZGF0ZXI8bnVtYmVyIHwgbnVsbD4+WzBdLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBnZXRUYWJiYWJsZUluZGV4OiAoKSA9PiBudW1iZXIgfCBudWxsO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBmb2N1c1NlbGY6ICgpID0+IHZvaWQ7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVJvdmluZ1RhYkluZGV4UmV0dXJuVHlwZUluZm88VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+IHtcbiAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ6IFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPjtcbn1cblxuZXhwb3J0IHR5cGUgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzID0ga2V5b2YgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PjtcblxuZXhwb3J0IGludGVyZmFjZSBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBSdGljT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHNcbiAgICBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCIsIE1jT21pdHMgfCBcInN1YkluZm9cIiwgU3ViYmVzdEluZm8+IHtcbiAgICByb3ZpbmdUYWJJbmRleDogT21pdDxQYXJ0aWFsPE9taXQ8VXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPGFueSwgYW55PiwgXCJnZXRFbGVtZW50XCIgfCBcInN1YkluZm9cIiB8IFwiZm9jdXNTZWxmXCI+PiwgUnRpY09taXRzPiAmIE9taXQ8eyBub01vZGlmeVRhYkluZGV4PzogYm9vbGVhbiwgZm9jdXNTZWxmKGU6IENoaWxkRWxlbWVudCk6IHZvaWQ7IH0sIFJ0aWNPbWl0cz47XG59XG5cbmV4cG9ydCB0eXBlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzLCBuZXZlciwgbmV2ZXIsIFJ0aVN1YkluZm8+KSA9PiBVc2VSb3ZpbmdUYWJJbmRleENoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxDaGlsZEVsZW1lbnQ+O1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50PiB7XG4gICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgdGFiYmFibGU6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldFRhYmJhYmxlKCk6IGJvb2xlYW47XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIGdldEVsZW1lbnQoKTogQ2hpbGRFbGVtZW50IHwgbnVsbDtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIC8qKiAqVW5zdGFibGUqICovXG4gICAgcm92aW5nVGFiSW5kZXhDaGlsZFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5cbi8qKlxuICogSW1wbGVtZW50cyBhIHJvdmluZyB0YWJpbmRleCBzeXN0ZW0gd2hlcmUgb25seSBvbmUgXCJmb2N1c2FibGVcIlxuICogY29tcG9uZW50IGluIGEgc2V0IGlzIGFibGUgdG8gcmVjZWl2ZSBhIHRhYiBmb2N1cy4gKldoaWNoKlxuICogb2YgdGhvc2UgZWxlbWVudHMgcmVjZWl2ZXMgZm9jdXMgaXMgZGV0ZXJtaW5lZCBieSB5b3UsIGJ1dCBpdCdzXG4gKiByZWNvbW1lbmRlZCB0byBvZmZsb2FkIHRoYXQgbG9naWMgdGhlbiB0byBhbm90aGVyIGhvb2ssIGxpa2VcbiAqIGB1c2VMaW5lYXJOYXZpZ2F0aW9uYCwgd2hpY2ggbGV0cyB5b3UgY2hhbmdlIHRoZSB0YWJiYWJsZVxuICogZWxlbWVudCB3aXRoIHRoZSBhcnJvdyBrZXlzLCBgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbmAsIHdoaWNoXG4gKiBsZXRzIHlvdSBjaGFuZ2UgdGhlIHRhYmJhYmxlIGluZGV4IHdpdGggdHlwZWFoZWFkLCBvclxuICogYHVzZUxpc3ROYXZpZ2F0aW9uYCBpZiB5b3UganVzdCB3YW50IGV2ZXJ5dGhpbmcgYnVuZGxlZCB0b2dldGhlci5cbiAqIFxuICogTm90ZSB0aGF0IHRoZSBjaGlsZCBob29rIHJldHVybmVkIGJ5IHRoaXMgZnVuY3Rpb24gbXVzdCBiZSB1c2VkXG4gKiBieSBldmVyeSBjaGlsZCB0aGF0IHVzZXMgdGhpcyByb3ZpbmcgdGFiaW5kZXggbG9naWMuICBUaGVcbiAqIHByb3AtbW9kaWZ5aW5nIGhvb2sgKnRoYXQqIGhvb2sgcmV0dXJucyBzaG91bGQgdGhlbiBiZSB1c2VkXG4gKiBvbiB0aGUgY2hpbGQncyBlbGVtZW50LCBhcyB3ZWxsIGFzIGFueSBvdGhlciBlbGVtZW50cyB5b3UnZCBsaWtlXG4gKiB0byBiZSBleHBsaWNpdGx5IG1hZGUgdW50YWJiYWJsZSB0b28uXG4gKiBcbiAqIGBzaG91bGRGb2N1c09uQ2hhbmdlYCBzaG91bGQgcmV0dXJuIHRydWUgaWYgZm9jdXMgaXMgXG4gKiBjb250YWluZWQgd2l0aGluIHdoYXRldmVyIGVsZW1lbnQgY29udGFpbnMgdGhlIHJvdmluZyB0YWIgaW5kZXguXG4gKiBHZW5lcmFsbHkgYXMgc2ltcGxlIGFzIHRoZSBmb2xsb3dpbmc6XG4gKiBgYGBcbiAqIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gKiBjb25zdCB7IHVzZUhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPFBhcmVudEVsZW1lbnQ+KHsgc2V0Rm9jdXNlZElubmVyIH0pO1xuICogY29uc3QgZm9jdXNPbkNoYW5nZSA9IChmb2N1c2VkSW5uZXIgIT0gZmFsc2UpO1xuICogYGBgXG4gKiBJdCdzIG5vdCBpbmNsdWRlZCBoZXJlIGJlY2F1c2UgYHVzZVJvdmluZ1RhYkluZGV4YCBkb2Vzbid0IGtub3cgXG4gKiBhbnl0aGluZyBhYm91dCB0aGUgY29udGFpbmVyIGVsZW1lbnQsIG9ubHkgY2hpbGRyZW4gZWxlbWVudHMuXG4gKiBBbmQganVzdCBhcyB3ZWxsISBDaGlsZHJlbiBzaG91bGQgYmUgYWxsb3dlZCBhdCB0aGUgcm9vdCwgXG4gKiByZWdhcmRsZXNzIG9mIGlmIGl0J3MgdGhlIHdob2xlIGFwcCBvciBqdXN0IGEgZ2l2ZW4gY29tcG9uZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4ocGFyZW50UGFyYW1ldGVyczogVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzPG5ldmVyLCBuZXZlcj4pOiBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50LCBSdGlTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiB7XG5cbiAgICBsZXQgeyByb3ZpbmdUYWJJbmRleDogeyBpbml0aWFsSW5kZXgsIG9uVGFiYmFibGVSZW5kZXIsIG9uVGFiYmFibGVJbmRleENoYW5nZSB9LCBtYW5hZ2VkQ2hpbGRyZW46IHsgb25BZnRlckNoaWxkTGF5b3V0RWZmZWN0LCBvbkNoaWxkcmVuTW91bnRDaGFuZ2UgfSB9ID0gcGFyZW50UGFyYW1ldGVycztcblxuICAgIGluaXRpYWxJbmRleCA/Pz0gMDtcbiAgICBjb25zdCBzdGFibGVPblRhYmJhYmxlUmVuZGVyID0gdXNlU3RhYmxlQ2FsbGJhY2sob25UYWJiYWJsZVJlbmRlciA/PyAoKCkgPT4geyB9KSk7XG4gICAgLypjb25zdCBbX2dldEFueUZvY3VzZWQsIHNldEFueUZvY3VzZWRdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlcj4odXNlU3RhYmxlQ2FsbGJhY2soKG5ld0NvdW50OiBudW1iZXIsIG9sZENvdW50OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgaWYgKG9sZENvdW50ID09IDAgJiYgbmV3Q291bnQgPiAwKSB7XG4gICAgICAgICAgICBvblRhYmJlZEluVG8/LigpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0NvdW50ID09IDAgJiYgKG9sZENvdW50ID8/IDApID4gMCkge1xuICAgICAgICAgICAgb25UYWJiZWRPdXRPZj8uKCk7XG4gICAgICAgIH1cbiAgICB9KSwgcmV0dXJuWmVybyk7Ki9cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhyZWUgdGhpbmdzIHJlbGF0ZWQgdG8gdGhlIGN1cnJlbnRseSB0YWJiYWJsZSBlbGVtZW50J3MgaW5kZXg6XG4gICAgLy8gV2hhdCBpdCBpcywgYW5kIHdoZXRoZXIsIHdoZW4gd2UgcmVuZGVyIHRoaXMgY29tcG9uZW50IGFuZCBpdCdzIGNoYW5nZWQsIHRvIGFsc28gZm9jdXMgdGhlIGVsZW1lbnQgdGhhdCB3YXMgbWFkZSB0YWJiYWJsZS5cbiAgICBjb25zdCBbZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleDJdID0gdXNlUGFzc2l2ZVN0YXRlPG51bWJlciB8IG51bGw+KG9uVGFiYmFibGVJbmRleENoYW5nZSwgdXNlQ2FsbGJhY2soKCkgPT4geyByZXR1cm4gaW5pdGlhbEluZGV4ID8/IDAgfSwgW10pKTtcbiAgICBjb25zdCBzZXRUYWJiYWJsZUluZGV4ID0gdXNlQ2FsbGJhY2soKHVwZGF0ZXI6IFBhcmFtZXRlcnM8U3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+PlswXSwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBzZXRUYWJiYWJsZUluZGV4MigocHJldkluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV4dEluZGV4ID0gcHJldkluZGV4O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZXIgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyKHByZXZJbmRleCA/PyBudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBuZXh0SW5kZXggPSB1cGRhdGVyO1xuXG4gICAgICAgICAgICBuZXh0SW5kZXggPSBjaGFuZ2VJbmRleChuZXh0SW5kZXgpO1xuXG4gICAgICAgICAgICBpZiAocHJldkluZGV4ICE9IG5leHRJbmRleCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRDaGlsZCA9IG5leHRJbmRleCA9PSBudWxsID8gbnVsbCA6IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KG5leHRJbmRleCk7XG4gICAgICAgICAgICAgICAgLy9jb25zdCBwcmV2Q2hpbGQgPSBwcmV2SW5kZXggPT0gbnVsbCA/IG51bGwgOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbi5jaGlsZHJlbi5nZXRBdChwcmV2SW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgLy9pZiAocHJldkNoaWxkICE9IG51bGwpXG4gICAgICAgICAgICAgICAgLy8gICAgcHJldkNoaWxkLnN1YkluZm8uYmx1clNlbGYoKTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0Q2hpbGQgIT0gbnVsbCAmJiBmcm9tVXNlckludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBuZXh0Q2hpbGQuc3ViSW5mby5nZXRFbGVtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8ICFlbGVtZW50LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRDaGlsZC5zdWJJbmZvLmZvY3VzU2VsZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXh0SW5kZXg7XG4gICAgICAgIH0pO1xuXG4gICAgfSwgW10pO1xuXG4gICAgLy8gQW55IHRpbWUgdGhlIHRhYmJhYmxlIGluZGV4IGNoYW5nZXMsXG4gICAgLy8gbm90aWZ5IHRoZSBwcmV2aW91cyBjaGlsZCB0aGF0IGl0J3Mgbm8gbG9uZ2VyIHRhYmJhYmxlLFxuICAgIC8vIGFuZCBub3RpZnkgdGhlIG5leHQgY2hpbGQgdGhhdCBpcyBhbGxvd2VkIHRvIGJlIHRhYmJlZCB0by5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTWFuYWdlZENoaWxkcmVuPG51bWJlciwgVXNlUm92aW5nVGFiSW5kZXhTdWJJbmZvPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMgfCBcInRhYmJhYmxlXCI+KHtcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3QsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZVN0YWJsZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobW91bnRlZCwgdW5tb3VudGVkKSA9PiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG1vdW50ZWQsIHVubW91bnRlZCk7IHJlZXZhbHVhdGVDbG9zZXN0Rml0KCk7IH0pLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyB1c2VNYW5hZ2VkQ2hpbGQgfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCB7IGNoYW5nZUluZGV4LCByZWV2YWx1YXRlQ2xvc2VzdEZpdCB9ID0gdXNlQ2hpbGRyZW5GbGFnPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFJ0aVN1YkluZm8+LCBFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiPih7IGluaXRpYWxJbmRleCwgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLCBjbG9zZXN0Rml0OiB0cnVlLCBrZXk6IFwidGFiYmFibGVcIiB9KTtcblxuICAgIGNvbnN0IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQgPSB1c2VDYWxsYmFjazxVc2VSb3ZpbmdUYWJJbmRleENoaWxkPENoaWxkRWxlbWVudCwgUnRpU3ViSW5mbywgRXh0cmFGbGFnS2V5cz4+KChjaGlsZFBhcmFtZXRlcnMpID0+IHtcblxuICAgICAgICBjb25zdCB7IHN1YkluZm8sIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBmb2N1c1NlbGY6IGZvY3VzU2VsZk92ZXJyaWRlLCBub01vZGlmeVRhYkluZGV4IH0gfSA9IGNoaWxkUGFyYW1ldGVycztcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgcmVldmFsdWF0ZUNsb3Nlc3RGaXQoKTtcbiAgICAgICAgfSwgWyEhaGlkZGVuXSlcblxuXG4gICAgICAgIGNvbnN0IHN0YWJsZUZvY3VzU2VsZiA9IHVzZVN0YWJsZUNhbGxiYWNrKGZvY3VzU2VsZk92ZXJyaWRlKTtcbiAgICAgICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGdldEVsZW1lbnQoKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCAhZWxlbWVudC5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSlcbiAgICAgICAgICAgICAgICAgICAgc3RhYmxlRm9jdXNTZWxmKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbXSk7XG5cbiAgICAgICAgY29uc3Qgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkID0gdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIF9wcmV2Rm9jdXNlZDogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGdldEVsZW1lbnQsIGhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENoaWxkRWxlbWVudD4oeyBvbkZvY3VzZWRJbm5lckNoYW5nZWQsIGdldERvY3VtZW50OiB1c2VDYWxsYmFjaygoKTogRG9jdW1lbnQgPT4geyByZXR1cm4gKGdldEVsZW1lbnQoKT8ub3duZXJEb2N1bWVudCkgPz8gKHdpbmRvdy5kb2N1bWVudCkgfSwgW10pIH0pO1xuXG4gICAgICAgIGNvbnN0IFt0YWJiYWJsZSwgc2V0VGFiYmFibGUsIGdldFRhYmJhYmxlXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICAgICAgY29uc3QgdGFiYmFibGVGbGFncyA9IHVzZVJlZjxDaGlsZEZsYWdPcGVyYXRpb25zPih7IGdldDogZ2V0VGFiYmFibGUsIHNldDogc2V0VGFiYmFibGUsIGlzVmFsaWQ6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+ICFoaWRkZW4pIH0pO1xuXG4gICAgICAgIGNvbnN0IF86IHZvaWQgPSB1c2VNYW5hZ2VkQ2hpbGQoe1xuICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgICAgICAgZmxhZ3M6IHsgLi4uZmxhZ3MsIHRhYmJhYmxlOiB0YWJiYWJsZUZsYWdzLmN1cnJlbnQgfSBhcyBQYXJ0aWFsPFJlY29yZDxFeHRyYUZsYWdLZXlzIHwgXCJ0YWJiYWJsZVwiLCBDaGlsZEZsYWdPcGVyYXRpb25zPj4sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc3ViSW5mbzoge1xuICAgICAgICAgICAgICAgIGZvY3VzU2VsZixcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGhpZGRlbjogISFoaWRkZW4sXG4gICAgICAgICAgICAgICAgc3ViSW5mb1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRhYmJhYmxlKVxuICAgICAgICAgICAgICAgIHN0YWJsZU9uVGFiYmFibGVSZW5kZXIoaW5kZXgpO1xuICAgICAgICB9LCBbdGFiYmFibGUsIGluZGV4XSk7XG5cbiAgICAgICAgY29uc3Qgcm92aW5nVGFiSW5kZXhDaGlsZFByb3BzID0gdXNlTWVyZ2VkUHJvcHMoaGFzRm9jdXNQcm9wcywgeyB0YWJJbmRleDogbm9Nb2RpZnlUYWJJbmRleCA/IHVuZGVmaW5lZCA6ICh0YWJiYWJsZSA/IDAgOiAtMSkgfSlcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXhDaGlsZFByb3BzLFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgICAgICBnZXRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbLyogTXVzdCByZW1haW4gc3RhYmxlICovXSk7XG5cbiAgICBjb25zdCBmb2N1c1NlbGYgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0VGFiYmFibGVJbmRleCgpO1xuICAgICAgICBpZiAoaW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgIHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLmdldEF0KGluZGV4KT8uc3ViSW5mby5mb2N1c1NlbGY/LigpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIHRydWUpO1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbjogcGFyZW50UmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4uY2hpbGRyZW4gfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgsXG4gICAgICAgICAgICBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgZm9jdXNTZWxmLFxuICAgICAgICB9XG4gICAgfTtcbn1cblxuLypmdW5jdGlvbiB0ZXN0KCkge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGZvY3VzU2VsZiwgZ2V0VGFiYmFibGVJbmRleCwgc2V0VGFiYmFibGVJbmRleCwgdXNlUm92aW5nVGFiSW5kZXhDaGlsZCwgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxEaXZFbGVtZW50LCB7IFwiZm9vXCI6IFwiYmFyXCIgfSwgXCJmbGFnMlwiPih7IG1hbmFnZWRDaGlsZHJlbjoge30sIHJvdmluZ1RhYkluZGV4OiB7fSB9KTtcbiAgICBjb25zdCB7IH0gPSB1c2VSb3ZpbmdUYWJJbmRleENoaWxkKHsgbWFuYWdlZENoaWxkcmVuOiB7IGluZGV4OiAwLCBmbGFnczoge30gfSwgcnRpOiB7IGluZm8zOiB7IGZvbzogXCJiYXJcIiB9IH0gfSk7XG59Ki9cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbiwgTWFuYWdlZENoaWxkcmVuT21pdHMsIE9uQ2hpbGRyZW5Nb3VudENoYW5nZSB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgdXNlTGluZWFyTmF2aWdhdGlvbiwgVXNlTGluZWFyTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZUxpbmVhck5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgdXNlVHlwZWFoZWFkTmF2aWdhdGlvbiwgVXNlVHlwZWFoZWFkTmF2aWdhdGlvblBhcmFtZXRlcnMsIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1rZXlib2FyZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IHVzZUVuc3VyZVN0YWJpbGl0eSB9IGZyb20gXCIuL3VzZS1wYXNzaXZlLXN0YXRlXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCB1c2VSb3ZpbmdUYWJJbmRleCwgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnMsIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRSZXR1cm5UeXBlSW5mbywgVXNlUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzLCBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8gfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cbi8qKlxuICogXG4gKiBUT0RPOiBUaGlzIHRhYmxlIHdhcyBzY3JhcHBlZCB3aGVuIHRoaXMgd2FzIGNoYW5nZWQgdG8ganVzdCBhY2NlcHQgYSBjb2xsYXRvciBkaXJlY3RseSxcbiAqIGJ1dCBpdCdzIG5vdCBiYWQgZm9yIGEgY29sbGF0aW9uIGNyYXNoIGNvdXJzZSBhbmQgSSBtaWdodCB1c2UgaXQgYWdhaW4uXG4gKiBFdmVuIGp1c3QgYXMgYSBcInRoaXMgaXMgd2h5IGl0J3MgaW1wb3J0YW50IGFuZCBnb29kIHRvIHVzZSB0aGVzZSB0aGluZ3NcIiB0aGluZy5cbiAqIFxuICogfExhbmcufFRhcmdldHxVc2VyIGlucHV0fGBiYXNlYHxgYWNjZW50YHxgY2FzZWB8YHZhcmlhbnRgfFxuICogfC0tLS18LS0tLXwtLS0tfC0tLS18LS0tLXwtLS0tfC0tLS18XG4gKiB8RU58SGl8QnllfOKdjHzinYx84p2MfOKdjHxcbiAqIHxFTnxIaXxIaXzinIV84pyFfOKchXzinIV8XG4gKiB8RU58SGl877yo772JfOKchXzinIV84pyFfOKdjHxcbiAqIHxFTnxIaXxoaXzinIV84pyFfOKdjHzinYx8XG4gKiB8RU58SGl8SMOvfOKchXzinYx84p2MfOKdjHxcbiAqIHxFTnzDpXxhYXzinYx84p2MfOKdjHzinYx8XG4gKiB8REF8w6V8YWF84pyFfOKchXzinIV84p2MfFxuICogfERBfMOlfEFBfOKchXzinIV84p2MfOKdjHxcbiAqIHxEQXzDpXxBYXzinIV84pyFfOKdjHzinYx8XG4gKiB8REF8w6V8YUF84p2MfOKdjHzinYx84p2MfFxuICogfEVOfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfERBfMOlfGF84pyFfOKchXzinYx84p2MfFxuICogfEpQfO+qqnznnYB84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zvvbZ84pyFfOKchXzinIV84pyFfFxuICogfEpQfOOCq3zjgYt84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zjg7V84pyFfOKchXzinIV84p2MfFxuICogfEpQfOOCq3zji5V84pyFfOKchXzinYx84p2MfFxuICogfEpQfOOCq3zjgqx84pyFfOKdjHzinYx84p2MfFxuICogfEpQfOOCq3zlipt84p2MfOKdjHzinYx84p2MfFxuICogfFpIfOe0hXznuqJ84p2MfOKdjHzinYx84p2MfFxuICogXG4gKiBcbiAqIChOb3RlIHRvIHNlbGY6IEF0IHNvbWUgcG9pbnQsIHRoaXMgZmlsZSB3aWxsIHByb2JhYmx5IGJlIG5vcm1hbGl6ZWRcbiAqIGJ5IHNvbWVib2R5IGFuZCDvqqogd2lsbCB0dXJuIGJhY2sgaW50byDnnYAuKVxuICogXG4gKi9cbmNvbnN0IF9kdW1teTogYW55ID0gbnVsbDtcblxuXG5mdW5jdGlvbiBpZGVudGl0eTxUPih0OiBUKSB7IHJldHVybiB0OyB9XG50eXBlIE9taXQ8VCwgSyBleHRlbmRzIGtleW9mIFQ+ID0gUGljazxULCBFeGNsdWRlPGtleW9mIFQsIEs+PjtcblxuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPEM+IHtcbiAgICB0ZXh0OiBzdHJpbmc7XG4gICAgc3ViSW5mbzogQztcbn1cblxuLyoqXG4gKiBAcGFyYW0gZnJvbVVzZXJJbnRlcmFjdGlvbiBXaGV0aGVyIHRoZSB1c2VyIGludGVyYWN0ZWQgd2l0aCB0aGlzIGNoaWxkIGFzIGEgbWVhbnMgb2YgbmF2aWdhdGluZyB0byBpdC4gIEluIHRoYXQgd2FzIHRoZSBjYXNlLCB0aGUgY2hpbGQgaXMgYWxzbyBmb2N1c2VkLiBPdGhlcndpc2UsIGZvY3VzIG1vdmVzIGFzIHRoZSBicm93c2VyIGRldGVybWluZXMuXG4gKi9cbmV4cG9ydCB0eXBlIE5hdmlnYXRlVG9JbmRleCA9IChpOiBudW1iZXIgfCBudWxsLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKSA9PiB2b2lkO1xuXG5cbmludGVyZmFjZSBMU1Age1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBhbmQgaW5kZXhEZW1hbmdsZXIgYXJlIHVzZWQgdG8gYWxsb3cgY2hpbGRyZW4gdG8gYmUgbmF2aWdhdGVkIGluIGFuIG9yZGVyXG4gICAgICogdGhhdCBkb2Vzbid0IG5lY2Vzc2FyaWx5IG1hdGNoIHRoZWlyIGNoaWxkIG9yZGVyLCBsaWtlIGlmIGEgbGlzdCBpcyBzb3J0ZWQuXG4gICAgICogXG4gICAgICogVXNlZCB0byB0dXJuIGFuIFwiYWJzb2x1dGVcIiBpbmRleCBpbnRvIGEgXCJzb3J0ZWQvZmlsdGVyZWQvbWFuZ2xlZFwiIG9uZS5cbiAgICAgKiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgbmF2aWdhdGVUb0ZpcnN0IG1hbmdsZXMgMCBhbmQgbmF2aWdhdGVzIHRvIHRoYXQgcmVzdWx0aW5nIHJvdy5cbiAgICAgKiBAcGFyYW0gcmF3SW5kZXggXG4gICAgICovXG4gICAgaW5kZXhNYW5nbGVyPyhyYXdJbmRleDogbnVtYmVyKTogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byB0dXJuIGEgXCJtYW5nbGVkXCIgaW5kZXggaW50byBpdCdzIFwidW5zb3J0ZWRcIiBvciBcInVubWFuZ2xlZFwiIGluZGV4LlxuICAgICAqIFxuICAgICAqIEZvciBleGFtcGxlLCB3aGVuIGluY3JlbWVudGluZyBvciBkZWNyZW1lbnRpbmcgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBpbmRleCxcbiAgICAgKiBpdCBuZWVkcyB0byBiZSBkZW1hbmdsZWQgdG8gZG8gXCJub3JtYWxcIiBtYXRoIG9uIGl0LCBhbmQgdGhlbiByZS1tYW5nbGVkIChhYm92ZSlcbiAgICAgKiB0byB0dXJuIHRoYXQgYWJzb2x1dGUgcm93IGluZGV4IGJhY2sgaW50byBhIG1hbmdsZWQgb25lLlxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1lZEluZGV4IFxuICAgICAqL1xuICAgIGluZGV4RGVtYW5nbGVyPyh0cmFuc2Zvcm1lZEluZGV4OiBudW1iZXIpOiBudW1iZXI7XG59XG5cbmV4cG9ydCB0eXBlIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzID0ga2V5b2YgTFNQO1xuXG4vLyAqKiogUGFyYW1ldGVycyAobGlzdCwgbGlzdC1zaW5nbGUsIGxpc3QtY2hpbGQsIGxpc3Qtc2luZ2xlLWNoaWxkKVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8THNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHNcbiAgICBVc2VSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnM8UnRpT21pdHMsIE1jT21pdHM+LFxuICAgIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25QYXJhbWV0ZXJzPFRuT21pdHMgfCBcImdldEluZGV4XCIgfCBcInNldEluZGV4XCI+LFxuICAgIFVzZUxpbmVhck5hdmlnYXRpb25QYXJhbWV0ZXJzPExuT21pdHMgfCBcIm5hdmlnYXRlVG9GaXJzdFwiIHwgXCJuYXZpZ2F0ZVRvTGFzdFwiIHwgXCJuYXZpZ2F0ZVRvTmV4dFwiIHwgXCJuYXZpZ2F0ZVRvUHJldlwiPiB7XG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8TFNQLCBMc09taXRzPjtcbn1cblxuXG5cblxuXG5leHBvcnQgdHlwZSBMaXN0TmF2aWdhdGlvbkNoaWxkT21pdHMgPSBrZXlvZiBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88YW55PjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLCBTdWJiZXN0SW5mbz4gZXh0ZW5kc1xuICAgIFVzZVJvdmluZ1RhYkluZGV4Q2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgVXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIFJ0aU9taXRzLCBNY09taXRzLCBTdWJiZXN0SW5mbz4ge1xuICAgIC8vcm92aW5nVGFiSW5kZXg6IE9taXQ8VXNlUm92aW5nVGFiSW5kZXhDaGlsZFBhcmFtZXRlcnM8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIEV4dHJhRmxhZ0tleXMsIG5ldmVyPltcInJvdmluZ1RhYkluZGV4XCJdLCBcInN1YkluZm9cIj47XG4gICAgbGlzdE5hdmlnYXRpb246IE9taXQ8VXNlTGlzdE5hdmlnYXRpb25TdWJJbmZvPExzU3ViSW5mbz4sIExzT21pdHMgfCBcInN1YkluZm9cIj47XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSb3ZpbmdUYWJJbmRleFJldHVyblR5cGVJbmZvPFVzZVJvdmluZ1RhYkluZGV4U3ViSW5mbzxDaGlsZEVsZW1lbnQsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbzxMc1N1YkluZm8+PiwgXCJ0YWJiYWJsZVwiIHwgRXh0cmFGbGFnS2V5cz4sIFVzZVR5cGVhaGVhZE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbywgVXNlTGluZWFyTmF2aWdhdGlvblJldHVyblR5cGVJbmZvIHtcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXg6IE5hdmlnYXRlVG9JbmRleCB9O1xufVxuXG4vLyAqKiogUmV0dXJuIHR5cGVzIChsaXN0LCBsaXN0LXNpbmdsZSwgbGlzdC1jaGlsZCwgbGlzdC1zaW5nbGUtY2hpbGQpXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcblxuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBsaXN0TmF2aWdhdGlvblByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRPckNoaWxkRWxlbWVudD47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlUm92aW5nVGFiSW5kZXhDaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudD4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50PiB7XG4gICAgbGlzdE5hdmlnYXRpb25DaGlsZFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+O1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgTHNTdWJJbmZvPikgPT4gVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIHByb3BlciBrZXlib2FyZCBuYXZpZ2F0aW9uIGZvciBjb21wb25lbnRzIGxpa2UgbGlzdGJveGVzLCBidXR0b24gZ3JvdXBzLCBtZW51cywgZXRjLlxuICogXG4gKiBJbiB0aGUgZG9jdW1lbnQgb3JkZXIsIHRoZXJlIHdpbGwgYmUgb25seSBvbmUgXCJmb2N1c2VkXCIgb3IgXCJ0YWJiYWJsZVwiIGVsZW1lbnQsIG1ha2luZyBpdCBhY3QgbW9yZSBsaWtlIG9uZSBjb21wbGV0ZSB1bml0IGluIGNvbXBhcmlzb24gdG8gZXZlcnl0aGluZyBhcm91bmQgaXQuXG4gKiBOYXZpZ2F0aW5nIGZvcndhcmRzL2JhY2t3YXJkcyBjYW4gYmUgZG9uZSB3aXRoIHRoZSBhcnJvdyBrZXlzLCBIb21lL0VuZCBrZXlzLCBvciBhbnkgYW55IHRleHQgZm9yIHR5cGVhaGVhZCB0byBmb2N1cyB0aGUgbmV4dCBpdGVtIHRoYXQgbWF0Y2hlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzIGV4dGVuZHMgc3RyaW5nPih7XG4gICAgbWFuYWdlZENoaWxkcmVuOiB7IG9uQ2hpbGRyZW5Nb3VudENoYW5nZSwgLi4ubWMgfSxcbiAgICByb3ZpbmdUYWJJbmRleCxcbiAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uXG59OiBVc2VMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8bmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXM+IHtcbiAgICBpbmRleE1hbmdsZXIgPz89IGlkZW50aXR5O1xuICAgIGluZGV4RGVtYW5nbGVyID8/PSBpZGVudGl0eTtcblxuICAgIHVzZUVuc3VyZVN0YWJpbGl0eShcInVzZUxpc3ROYXZpZ2F0aW9uXCIsIGluZGV4TWFuZ2xlciwgaW5kZXhEZW1hbmdsZXIpO1xuXG5cbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlUm92aW5nVGFiSW5kZXg8Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPiwgRXh0cmFGbGFnS2V5cz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHtcbiAgICAgICAgICAgIC4uLm1jLCBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IHVzZUNhbGxiYWNrPE9uQ2hpbGRyZW5Nb3VudENoYW5nZTxudW1iZXI+PigobSwgdSkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ2hpbGRyZW5Nb3VudENoYW5nZT8uKG0sIHUpO1xuICAgICAgICAgICAgfSwgW10pXG4gICAgICAgIH0sXG4gICAgICAgIHJvdmluZ1RhYkluZGV4XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LCByb3ZpbmdUYWJJbmRleDogeyBnZXRUYWJiYWJsZUluZGV4LCBzZXRUYWJiYWJsZUluZGV4IH0gfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICBjb25zdCBuYXZpZ2F0ZVRvSW5kZXggPSB1c2VDYWxsYmFjaygoaTogbnVtYmVyIHwgbnVsbCwgZnJvbVVzZXJJbnRlcmFjdGlvbjogYm9vbGVhbikgPT4ge1xuICAgICAgICBpZiAoaSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0SW5kZXggPSB0cnlOYXZpZ2F0ZVRvSW5kZXgoe1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgICAgIHRhcmdldDogaSxcbiAgICAgICAgICAgICAgICBzZWFyY2hEaXJlY3Rpb246IDEsXG4gICAgICAgICAgICAgICAgaW5kZXhNYW5nbGVyOiBpbmRleE1hbmdsZXIgPz8gaWRlbnRpdHksXG4gICAgICAgICAgICAgICAgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoaSA9PSBudWxsID8gbnVsbCA6IG5leHRJbmRleCwgZnJvbVVzZXJJbnRlcmFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRUYWJiYWJsZUluZGV4KG51bGwsIGZyb21Vc2VySW50ZXJhY3Rpb24pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge1xuICAgICAgICAgICAgY3VycmVudFR5cGVhaGVhZCxcbiAgICAgICAgICAgIGludmFsaWRUeXBlYWhlYWRcbiAgICAgICAgfVxuICAgIH0gPSB1c2VUeXBlYWhlYWROYXZpZ2F0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50Pih7XG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHtcbiAgICAgICAgICAgIGdldEluZGV4OiBnZXRUYWJiYWJsZUluZGV4LFxuICAgICAgICAgICAgc2V0SW5kZXg6IHVzZUNhbGxiYWNrKChpbmRleDogKG51bWJlciB8IG51bGwpIHwgKChwcmV2OiBudW1iZXIgfCBudWxsKSA9PiAobnVtYmVyIHwgbnVsbCkpKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChpbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBbXSksXG4gICAgICAgICAgICAuLi50eXBlYWhlYWROYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCB7IGxpbmVhck5hdmlnYXRpb25Qcm9wcyB9ID0gdXNlTGluZWFyTmF2aWdhdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudD4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBuYXZpZ2F0ZVRvUHJldjogdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFRhYmJhYmxlSW5kZXgoYyA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnlOYXZpZ2F0ZVRvSW5kZXgoeyBjaGlsZHJlbiwgZGVmYXVsdDogYyA/PyAwLCB0YXJnZXQ6IGluZGV4RGVtYW5nbGVyIShpbmRleE1hbmdsZXIhKChjID8/IDApKSAtIDEpLCBzZWFyY2hEaXJlY3Rpb246IC0xLCBpbmRleE1hbmdsZXI6IGluZGV4TWFuZ2xlciA/PyBpZGVudGl0eSwgaW5kZXhEZW1hbmdsZXI6IGluZGV4RGVtYW5nbGVyID8/IGlkZW50aXR5IH0pXG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9OZXh0OiB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChjID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRyeU5hdmlnYXRlVG9JbmRleCh7IGNoaWxkcmVuLCBkZWZhdWx0OiBjID8/IDAsIHRhcmdldDogaW5kZXhEZW1hbmdsZXIhKGluZGV4TWFuZ2xlciEoYyA/PyAwKSArIDEpLCBzZWFyY2hEaXJlY3Rpb246IDEsIGluZGV4TWFuZ2xlcjogaW5kZXhNYW5nbGVyID8/IGlkZW50aXR5LCBpbmRleERlbWFuZ2xlcjogaW5kZXhEZW1hbmdsZXIgPz8gaWRlbnRpdHkgfSk7XG4gICAgICAgICAgICAgICAgfSwgdHJ1ZSlcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgICAgIG5hdmlnYXRlVG9GaXJzdDogdXNlQ2FsbGJhY2soKCkgPT4geyBuYXZpZ2F0ZVRvSW5kZXgoaW5kZXhEZW1hbmdsZXIhKDApLCB0cnVlKTsgfSwgW10pLFxuICAgICAgICAgICAgbmF2aWdhdGVUb0xhc3Q6IHVzZUNhbGxiYWNrKCgpID0+IHsgbmF2aWdhdGVUb0luZGV4KGluZGV4RGVtYW5nbGVyIShjaGlsZHJlbi5nZXRIaWdoZXN0SW5kZXgoKSksIHRydWUpOyB9LCBbXSksXG4gICAgICAgICAgICAuLi5saW5lYXJOYXZpZ2F0aW9uXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IGxpc3ROYXZpZ2F0aW9uUHJvcHMgPSB1c2VNZXJnZWRQcm9wcyhsaW5lYXJOYXZpZ2F0aW9uUHJvcHMsIHR5cGVhaGVhZE5hdmlnYXRpb25Qcm9wcyk7XG5cblxuICAgIGNvbnN0IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQgPSB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPj4oKHsgbWFuYWdlZENoaWxkOiB7IGluZGV4LCBmbGFncyB9LCByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbiB9LCBsaXN0TmF2aWdhdGlvbjogeyB0ZXh0IH0sIHN1YkluZm8gfSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IF92OiB2b2lkID0gdXNlVHlwZWFoZWFkTmF2aWdhdGlvbkNoaWxkKHsgdGV4dCwgaW5kZXggfSk7XG4gICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcbiAgICAgICAgdXNlRWZmZWN0KCgpID0+IHtcblxuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0VGFiYmFibGVJbmRleCgpID09IGdldEluZGV4KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbmF2aWdhdGVUb0luZGV4KGluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcyxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7XG4gICAgICAgICAgICAgICAgdGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0VGFiYmFibGUsXG4gICAgICAgICAgICAgICAgZ2V0RWxlbWVudFxuICAgICAgICAgICAgfVxuICAgICAgICB9ID0gdXNlUm92aW5nVGFiSW5kZXhDaGlsZCh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGhpZGRlbjogISFoaWRkZW4gfSxcbiAgICAgICAgICAgIHN1YkluZm86IHsgdGV4dCwgc3ViSW5mbyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyA9IHVzZU1lcmdlZFByb3BzKHJvdmluZ1RhYkluZGV4Q2hpbGRQcm9wcywgKCh7IGluZXJ0OiBoaWRkZW4gfSBhcyBoLkpTWC5IVE1MQXR0cmlidXRlczxDaGlsZEVsZW1lbnQ+KSkpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsXG4gICAgICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgICAgIHRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldFRhYmJhYmxlLFxuICAgICAgICAgICAgICAgIGdldEVsZW1lbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFt1c2VUeXBlYWhlYWROYXZpZ2F0aW9uQ2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIG5hdmlnYXRlVG9JbmRleF0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgbGlzdE5hdmlnYXRpb25Qcm9wcyxcblxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBuYXZpZ2F0ZVRvSW5kZXggfSxcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuOiBwYXJlbnRSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHBhcmVudFJldHVyblR5cGUucm92aW5nVGFiSW5kZXgsXG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IHt9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQsIGludmFsaWRUeXBlYWhlYWQgfVxuICAgICAgICAvKmxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleCB9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBmb2N1c1NlbGYsIGdldFRhYmJhYmxlSW5kZXgsIHNldFRhYmJhYmxlSW5kZXggfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHsgY3VycmVudFR5cGVhaGVhZCwgaW52YWxpZFR5cGVhaGVhZCB9Ki9cbiAgICB9XG59XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFRyeU5hdmlnYXRlVG9JbmRleFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIGNoaWxkcmVuOiBNYW5hZ2VkQ2hpbGRyZW48bnVtYmVyLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBLPjtcbiAgICBkZWZhdWx0OiBudW1iZXI7XG4gICAgdGFyZ2V0OiBudW1iZXI7XG4gICAgc2VhcmNoRGlyZWN0aW9uOiAxIHwgLTE7XG4gICAgaW5kZXhNYW5nbGVyOiAobjogbnVtYmVyKSA9PiBudW1iZXI7XG4gICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeU5hdmlnYXRlVG9JbmRleDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGNoaWxkcmVuLCBzZWFyY2hEaXJlY3Rpb24sIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIHRhcmdldCB9OiBUcnlOYXZpZ2F0ZVRvSW5kZXhQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSz4pIHtcbiAgICBjb25zdCB1cHBlciA9IGNoaWxkcmVuLmdldEhpZ2hlc3RJbmRleCgpO1xuICAgIGNvbnN0IGxvd2VyID0gMDtcblxuICAgIGlmIChzZWFyY2hEaXJlY3Rpb24gPT09IC0xKSB7XG4gICAgICAgIHdoaWxlICgodGFyZ2V0ID49IGxvd2VyICYmIChjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwpIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uc3ViSW5mby5oaWRkZW4pKVxuICAgICAgICAgICAgdGFyZ2V0ID0gaW5kZXhEZW1hbmdsZXIoaW5kZXhNYW5nbGVyKHRhcmdldCkgLSAxKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0IDwgbG93ZXIgPyBpbmRleERlbWFuZ2xlcihsb3dlcikgOiB0YXJnZXQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlYXJjaERpcmVjdGlvbiA9PT0gMSkge1xuICAgICAgICB3aGlsZSAoKHRhcmdldCA8PSB1cHBlciAmJiBjaGlsZHJlbi5nZXRBdCh0YXJnZXQpID09IG51bGwpIHx8ICEhY2hpbGRyZW4uZ2V0QXQodGFyZ2V0KT8uc3ViSW5mby5oaWRkZW4pXG4gICAgICAgICAgICB0YXJnZXQgPSBpbmRleERlbWFuZ2xlcihpbmRleE1hbmdsZXIodGFyZ2V0KSArIDEpO1xuXG4gICAgICAgIHJldHVybiB0YXJnZXQgPiB1cHBlciA/IGluZGV4RGVtYW5nbGVyKHVwcGVyKSA6IHRhcmdldDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsb3dlcjtcbiAgICB9XG59XG5cbiIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgTWFuYWdlZENoaWxkT21pdHMsIE1hbmFnZWRDaGlsZHJlbk9taXRzIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMgfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgTGlzdE5hdmlnYXRpb25DaGlsZE9taXRzLCBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgdXNlTGlzdE5hdmlnYXRpb24sIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm8sIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlSW5mbyB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tIFwiLi91c2Utc3RhdGVcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuXG4vKipcbiAqIEdyaWRzIGFyZSBpbXBsZW1lbnRlZCB1c2luZyB0d28gc2V0cyBvZiBsaXN0IG5hdmlnYXRpb24uXG4gKiBcbiAqIFRoaXMgcmVzdWx0cyBpbiBhIGxvdCBvZiB0aGluZ3Mgd2l0aCB2ZXJ5IHNpbWlsYXIgbmFtZXMgYW5kIGp1c3QgY29uZnVzaW9uIGFsbCBhcm91bmQuIFBsZWFzZSB1c2UgY2F1dGlvbi5cbiAqL1xuXG4vLyBQYXJhbWV0ZXJzIChwYXJlbnQsIHJvdywgY2VsbClcbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cyB8IFwibmF2aWdhdGlvbkRpcmVjdGlvblwiLCBUbk9taXRzLCBSdGlPbWl0cywgTWNPbWl0cz4ge1xuICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgIHJvd0luZGV4TWFuZ2xlcj86IFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+W1wibGlzdE5hdmlnYXRpb25cIl1bXCJpbmRleE1hbmdsZXJcIl07XG4gICAgICAgIHJvd0luZGV4RGVtYW5nbGVyPzogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlcj5bXCJsaXN0TmF2aWdhdGlvblwiXVtcImluZGV4RGVtYW5nbGVyXCJdO1xuICAgIH1cbn1cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxDUj4ge1xuICAgIHN1YkluZm86IENSO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFN1YkluZm88Q0M+IHtcbiAgICBzdWJJbmZvOiBDQztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8XG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ1IsXG4gICAgS1IgZXh0ZW5kcyBzdHJpbmcsXG4gICAgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLFxuICAgIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsXG4gICAgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cyxcbiAgICBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLFxuICAgIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyxcblxuICAgIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cyxcbiAgICBSdGlDaGlsZE9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhDaGlsZE9taXRzLFxuICAgIE1jQ2hpbGRPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZE9taXRzLFxuXG4gICAgU3ViYmVzdEluZm9cbj4ge1xuICAgIGFzUGFyZW50Um93T2ZDZWxsczogVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzPExzT21pdHMsIExuT21pdHMgfCBcIm5hdmlnYXRpb25EaXJlY3Rpb25cIiwgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+O1xuICAgIGFzQ2hpbGRSb3dPZlNlY3Rpb246IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPFJvd0VsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxDUj4sIEtSLCBMc0NoaWxkT21pdHMsIFJ0aUNoaWxkT21pdHMgfCBcImZvY3VzU2VsZlwiLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPlxuXG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmcsIExzQ2hpbGRPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpQ2hpbGRPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4Q2hpbGRPbWl0cywgTWNDaGlsZE9taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiBleHRlbmRzXG4gICAgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2VsbEVsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFN1YkluZm88Q0M+LCBLQywgTHNDaGlsZE9taXRzLCBSdGlDaGlsZE9taXRzLCBNY0NoaWxkT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxDZWxsRWxlbWVudD47XG59XG5cblxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgUm93U3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgVXNlR3JpZE5hdmlnYXRpb25Sb3dTdWJJbmZvPFJvd1N1YkluZm8+LCBFeHRyYUZsYWdLZXlzPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xuICAgICAgICBjdXJyZW50Q29sdW1uOiBudW1iZXIgfCBudWxsO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIFJvd0VsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDZWxsRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Um93RWxlbWVudCwgQ1IsIEtSPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25Sb3c6IFVzZUdyaWROYXZpZ2F0aW9uUm93PFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDUiwgQ0MsIEtSLCBLQz47XG4gICAgZ3JpZE5hdmlnYXRpb25Qcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50T3JSb3dFbGVtZW50Pjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdyBleHRlbmRzIEVsZW1lbnQsIENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDZWxsU3ViSW5mbywgS0MgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBhc0NoaWxkUm93OiBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZUluZm88Um93PjtcbiAgICBhc1BhcmVudE9mQ2VsbHM6IFVzZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2VsbCwgVXNlR3JpZE5hdmlnYXRpb25DZWxsU3ViSW5mbzxDZWxsU3ViSW5mbz4sIEtDPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENlbGxTdWJJbmZvLCBLQyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVJbmZvPFJvdywgQ2VsbCwgQ2VsbFN1YkluZm8sIEtDPiB7XG4gICAgdXNlR3JpZE5hdmlnYXRpb25DZWxsOiBVc2VHcmlkTmF2aWdhdGlvbkNlbGw8Q2VsbCwgQ2VsbFN1YkluZm8sIEtDPjtcbiAgICBncmlkTmF2aWdhdGlvblJvd1Byb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxSb3c+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlSW5mbzxDZWxsPiB7XG4gICAgZ3JpZE5hdmlnYXRpb246IHtcbiAgICAgICAgLy9yb3dJc1RhYmJhYmxlOiBib29sZWFuO1xuICAgICAgICAvL2dldFJvd0lzVGFiYmFibGUoKTogYm9vbGVhbjtcbiAgICAgICAgZ2V0Q3VycmVudENvbHVtbigpOiBudW1iZXIgfCBudWxsO1xuICAgIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VHcmlkTmF2aWdhdGlvbkNlbGxSZXR1cm5UeXBlV2l0aEhvb2tzPENlbGwgZXh0ZW5kcyBFbGVtZW50PiBleHRlbmRzIFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVJbmZvPENlbGw+IHtcbiAgICBncmlkTmF2aWdhdGlvbkNlbGxQcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8Q2VsbD47XG59XG5cblxuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93IGV4dGVuZHMgRWxlbWVudCwgQ2VsbCBleHRlbmRzIEVsZW1lbnQsIENSLCBDQywgS1IgZXh0ZW5kcyBzdHJpbmcsIEtDIGV4dGVuZHMgc3RyaW5nPiA9IChhOiBVc2VHcmlkTmF2aWdhdGlvblJvd1BhcmFtZXRlcnM8Um93LCBDUiwgS1IsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQ1I+KSA9PiBVc2VHcmlkTmF2aWdhdGlvblJvd1JldHVyblR5cGVXaXRoSG9va3M8Um93LCBDZWxsLCBDQywgS0M+O1xuZXhwb3J0IHR5cGUgVXNlR3JpZE5hdmlnYXRpb25DZWxsPENlbGwgZXh0ZW5kcyBFbGVtZW50LCBDQywgS0MgZXh0ZW5kcyBzdHJpbmc+ID0gKHA6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFBhcmFtZXRlcnM8Q2VsbCwgQ0MsIEtDLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDQz4pID0+IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbD47XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUdyaWROYXZpZ2F0aW9uPFxuICAgIFBhcmVudE9yUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgUm93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsXG4gICAgQ2VsbEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LFxuICAgIFJvd1N1YkluZm8sXG4gICAgQ2VsbFN1YkluZm8sXG4gICAgUm93RXh0cmFGbGFncyBleHRlbmRzIHN0cmluZyxcbiAgICBDZWxsRXh0cmFGbGFncyBleHRlbmRzIHN0cmluZ1xuPih7XG4gICAgbWFuYWdlZENoaWxkcmVuOiBtYyxcbiAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICBsaW5lYXJOYXZpZ2F0aW9uOiBsbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB0bixcbiAgICBncmlkTmF2aWdhdGlvbjogeyByb3dJbmRleERlbWFuZ2xlciwgcm93SW5kZXhNYW5nbGVyIH1cbn06IFVzZUdyaWROYXZpZ2F0aW9uUGFyYW1ldGVyczxuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlR3JpZE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yUm93RWxlbWVudCwgUm93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4ge1xuICAgIGNvbnN0IFtjdXJyZW50Q29sdW1uLCBzZXRDdXJyZW50Q29sdW1uLCBnZXRDdXJyZW50Q29sdW1uXSA9IHVzZVN0YXRlPG51bWJlciB8IG51bGw+KHJ0aS5pbml0aWFsSW5kZXggPz8gMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ6IHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRBc0dyaWRSb3csXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQsXG4gICAgICAgIC4uLnBhcmVudExzUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VMaXN0TmF2aWdhdGlvbjxQYXJlbnRPclJvd0VsZW1lbnQsIFJvd0VsZW1lbnQsIFVzZUdyaWROYXZpZ2F0aW9uUm93U3ViSW5mbzxSb3dTdWJJbmZvPiwgUm93RXh0cmFGbGFncz4oe1xuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IG1jLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyBpbmRleERlbWFuZ2xlcjogcm93SW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlcjogcm93SW5kZXhNYW5nbGVyLCAuLi5scyB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7IG5hdmlnYXRpb25EaXJlY3Rpb246IFwidmVydGljYWxcIiwgLi4ubG4gfSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdG4sXG4gICAgfSk7XG5cblxuICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uUm93ID0gdXNlQ2FsbGJhY2s8VXNlR3JpZE5hdmlnYXRpb25Sb3c8Um93RWxlbWVudCwgQ2VsbEVsZW1lbnQsIFJvd1N1YkluZm8sIENlbGxTdWJJbmZvLCBSb3dFeHRyYUZsYWdzLCBDZWxsRXh0cmFGbGFncz4+KCh7IGFzQ2hpbGRSb3dPZlNlY3Rpb246IGFzQ2hpbGQsIGFzUGFyZW50Um93T2ZDZWxsczogYXNQYXJlbnQgfSkgPT4ge1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgZm9jdXNTZWxmIHRoYXQgcm92aW5nVGFiSW5kZXggZG9lcy5cbiAgICAgICAgLy8gSW5zdGVhZCBvZiBmb2N1c2luZyB0aGUgZW50aXJlIHJvdywgd2UgYXNrIHRoZSBjZWxsIHRoYXQgY29ycmVzcG9uZHNcbiAgICAgICAgLy8gdG8gb3VyIGN1cnJlbnQgY29sdW1uIHRvIGZvY3VzIGl0c2VsZi5cbiAgICAgICAgY29uc3QgZm9jdXNTZWxmUm93ID0gdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGdldEN1cnJlbnRDb2x1bW4oKTtcbiAgICAgICAgICAgIG5hdmlnYXRlVG9Db2x1bW4oYzIgPz8gMCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzQ2hpbGRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZEFzR3JpZFJvdyh7XG4gICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IGFzQ2hpbGQubWFuYWdlZENoaWxkLFxuICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgLi4uYXNDaGlsZC5saXN0TmF2aWdhdGlvbiB9LFxuICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgLi4uYXNDaGlsZC5yb3ZpbmdUYWJJbmRleCwgZm9jdXNTZWxmOiBmb2N1c1NlbGZSb3cgfSxcbiAgICAgICAgICAgIHN1YkluZm86IHsgc3ViSW5mbzogYXNDaGlsZC5zdWJJbmZvIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlIH0sIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyB9ID0gcm93THNDaGlsZFJldHVyblR5cGU7XG4gICAgICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRhYmJhYmxlKSB7XG4gICAgICAgICAgICAgICAgbmF2aWdhdGVUb0NvbHVtbihudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIFt0YWJiYWJsZV0pO1xuXG4gICAgICAgIGNvbnN0IHJvd0xzUmV0dXJuVHlwZSA9IHVzZUxpc3ROYXZpZ2F0aW9uPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBVc2VHcmlkTmF2aWdhdGlvbkNlbGxTdWJJbmZvPENlbGxTdWJJbmZvPiwgQ2VsbEV4dHJhRmxhZ3M+KHtcbiAgICAgICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyAuLi5hc1BhcmVudC5tYW5hZ2VkQ2hpbGRyZW4gfSxcbiAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLmFzUGFyZW50LnJvdmluZ1RhYkluZGV4IH0sXG4gICAgICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNQYXJlbnQubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBuYXZpZ2F0aW9uRGlyZWN0aW9uOiBcImhvcml6b250YWxcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IC4uLmFzUGFyZW50LnR5cGVhaGVhZE5hdmlnYXRpb24sIG5vVHlwZWFoZWFkOiB0cnVlIH0sXG4gICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5hc1BhcmVudC5saXN0TmF2aWdhdGlvbiB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHsgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LCB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkOiB1c2VHcmlkTmF2aWdhdGlvbkNvbHVtbjIsIGxpc3ROYXZpZ2F0aW9uUHJvcHM6IHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHMsIGxpc3ROYXZpZ2F0aW9uOiB7IG5hdmlnYXRlVG9JbmRleDogbmF2aWdhdGVUb0NvbHVtbiB9IH0gPSByb3dMc1JldHVyblR5cGU7XG5cbiAgICAgICAgLy9jb25zdCByb3dIaWRkZW4gPSAhIWFzQ2hpbGQucm92aW5nVGFiSW5kZXguaGlkZGVuO1xuXG4gICAgICAgIGNvbnN0IHVzZUdyaWROYXZpZ2F0aW9uQ2VsbCA9IHVzZUNhbGxiYWNrPFVzZUdyaWROYXZpZ2F0aW9uQ2VsbDxDZWxsRWxlbWVudCwgQ2VsbFN1YkluZm8sIENlbGxFeHRyYUZsYWdzPj4oKHsgc3ViSW5mbywgaGFzRm9jdXM6IHsgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSwgbWFuYWdlZENoaWxkLCBsaXN0TmF2aWdhdGlvbjogbHMsIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZjogZm9jdXNTZWxmQ2VsbCwgLi4ucnRpIH0gfSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wcyxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0XG4gICAgICAgICAgICB9ID0gdXNlR3JpZE5hdmlnYXRpb25Db2x1bW4yKHtcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGQ6IG1hbmFnZWRDaGlsZCxcbiAgICAgICAgICAgICAgICBsaXN0TmF2aWdhdGlvbjogeyAuLi5scyB9LFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IGZvY3VzU2VsZjogZm9jdXNTZWxmQ2VsbCwgLi4ucnRpIH0sXG4gICAgICAgICAgICAgICAgc3ViSW5mbzogeyBzdWJJbmZvIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7IGhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPENlbGxFbGVtZW50Pih7XG4gICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZDogdXNlU3RhYmxlQ2FsbGJhY2soKGZvY3VzZWQ6IGJvb2xlYW4sIHByZXY6IGJvb2xlYW4gfCB1bmRlZmluZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZD8uKGZvY3VzZWQsIHByZXYpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0Q3VycmVudENvbHVtbihtYW5hZ2VkQ2hpbGQuaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChtYW5hZ2VkQ2hpbGQuaW5kZXgsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmhhc0ZvY3VzXG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICBjb25zdCByZXQ6IFVzZUdyaWROYXZpZ2F0aW9uQ2VsbFJldHVyblR5cGVXaXRoSG9va3M8Q2VsbEVsZW1lbnQ+ID0ge1xuICAgICAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7IGdldEN1cnJlbnRDb2x1bW4gfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpX2NlbGxfcmV0LFxuICAgICAgICAgICAgICAgIGdyaWROYXZpZ2F0aW9uQ2VsbFByb3BzOiB1c2VNZXJnZWRQcm9wcyhsaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIGhhc0ZvY3VzUHJvcHMpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgfSwgW10pO1xuXG4gICAgICAgIGNvbnN0IHJldDogVXNlR3JpZE5hdmlnYXRpb25Sb3dSZXR1cm5UeXBlV2l0aEhvb2tzPFJvd0VsZW1lbnQsIENlbGxFbGVtZW50LCBDZWxsU3ViSW5mbywgQ2VsbEV4dHJhRmxhZ3M+ID0ge1xuICAgICAgICAgICAgYXNQYXJlbnRPZkNlbGxzOiB7XG4gICAgICAgICAgICAgICAgbGluZWFyTmF2aWdhdGlvbjogcm93THNSZXR1cm5UeXBlLmxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb246IHJvd0xzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHJvd0xzUmV0dXJuVHlwZS5tYW5hZ2VkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJvd0xzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiByb3dMc1JldHVyblR5cGUudHlwZWFoZWFkTmF2aWdhdGlvbixcblxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzQ2hpbGRSb3c6IHJvd0xzQ2hpbGRSZXR1cm5UeXBlLFxuXG4gICAgICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXG4gICAgICAgICAgICBncmlkTmF2aWdhdGlvblJvd1Byb3BzOiB1c2VNZXJnZWRQcm9wcyhsaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMsIHVzZUdyaWROYXZpZ2F0aW9uQ29sdW1uUHJvcHMpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH0sIFtdKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7XG4gICAgICAgICAgICBnZXRDdXJyZW50Q29sdW1uLFxuICAgICAgICAgICAgY3VycmVudENvbHVtblxuICAgICAgICB9LFxuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiBwYXJlbnRMc1JldHVyblR5cGUubGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHBhcmVudExzUmV0dXJuVHlwZS5saXN0TmF2aWdhdGlvbixcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHBhcmVudExzUmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogcGFyZW50THNSZXR1cm5UeXBlLnR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogcGFyZW50THNSZXR1cm5UeXBlLm1hbmFnZWRDaGlsZHJlbixcbiAgICAgICAgdXNlR3JpZE5hdmlnYXRpb25Sb3csXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uUHJvcHM6IHVzZUxpc3ROYXZpZ2F0aW9uUHJvcHNBc0dyaWRQYXJlbnQsXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlQ2FsbGJhY2sgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWNhbGxiYWNrXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVHZXR0ZXIgfSBmcm9tIFwiLi91c2Utc3RhYmxlLWdldHRlclwiO1xuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VJbnRlcnZhbFBhcmFtZXRlcnMge1xuICAgIC8qKlxuICAgICAqIFRoZSBudW1iZXIgb2YgbXMgdG8gd2FpdCBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBpbnRlcnZhbDogbnVtYmVyIHwgbnVsbDtcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBgdGltZW91dGAgbXMgYWZ0ZXIgbW91bnQsIG9yIHRoZSBsYXN0IGNoYW5nZSB0byBgdHJpZ2dlckluZGV4YC5cbiAgICAgKi9cbiAgICBjYWxsYmFjazogKCkgPT4gdm9pZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUludGVydmFsKHsgaW50ZXJ2YWwsIGNhbGxiYWNrIH06IFVzZUludGVydmFsUGFyYW1ldGVycykge1xuICAgIC8vIEdldCBhIHdyYXBwZXIgYXJvdW5kIHRoZSBnaXZlbiBjYWxsYmFjayB0aGF0J3Mgc3RhYmxlXG4gICAgY29uc3Qgc3RhYmxlQ2FsbGJhY2sgPSB1c2VTdGFibGVDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgY29uc3QgZ2V0SW50ZXJ2YWwgPSB1c2VTdGFibGVHZXR0ZXIoaW50ZXJ2YWwpO1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgaW50ZXJ2YWwgPSBnZXRJbnRlcnZhbCgpO1xuICAgICAgICBsZXQgbGFzdERlbGF5VXNlZCA9IGludGVydmFsO1xuXG4gICAgICAgIGlmIChpbnRlcnZhbCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuXG5cbiAgICAgICAgLy8gR2V0IGEgd3JhcHBlciBhcm91bmQgdGhlIHdyYXBwZXIgYXJvdW5kIHRoZSBjYWxsYmFja1xuICAgICAgICAvLyB0aGF0IGNsZWFycyBhbmQgcmVzZXRzIHRoZSBpbnRlcnZhbCBpZiBpdCBjaGFuZ2VzLlxuICAgICAgICBjb25zdCBhZGp1c3RhYmxlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBzdGFibGVDYWxsYmFjaygpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEludGVydmFsID0gZ2V0SW50ZXJ2YWwoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50SW50ZXJ2YWwgIT0gbGFzdERlbGF5VXNlZCkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEludGVydmFsICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZSA9IHNldEludGVydmFsKGFkanVzdGFibGVDYWxsYmFjaywgbGFzdERlbGF5VXNlZCA9IGN1cnJlbnRJbnRlcnZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhhbmRsZSA9IHNldEludGVydmFsKGFkanVzdGFibGVDYWxsYmFjaywgaW50ZXJ2YWwpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChoYW5kbGUpO1xuICAgIH0sIFtdKTtcbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZUdsb2JhbEhhbmRsZXIgfSBmcm9tIFwiLi91c2UtZXZlbnQtaGFuZGxlclwiO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tIFwiLi91c2UtZm9yY2UtdXBkYXRlXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cywgVXNlSGFzRm9jdXNQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWhhcy1mb2N1c1wiO1xuaW1wb3J0IHsgdXNlTWVyZ2VkUHJvcHMgfSBmcm9tIFwiLi91c2UtbWVyZ2VkLXByb3BzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXN0YXRlXCI7XG5cbmludGVyZmFjZSBVc2VQcmVzc1BhcmFtZXRlcnM8RSBleHRlbmRzIE5vZGU+IHtcbiAgICBvbkNsaWNrU3luYzogKChlOiBoLkpTWC5UYXJnZXRlZEV2ZW50PEU+KSA9PiB2b2lkKSB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH07XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbiAgICBmb2N1c1NlbGYoZWxlbWVudDogRSk6IHZvaWQ7XG59XG5cbi8qKlxuICogQWRkcyB0aGUgbmVjZXNzYXJ5IGV2ZW50IGhhbmRsZXJzIHRvIGNyZWF0ZSBhIFwicHJlc3NcIi1saWtlIGV2ZW50IGZvclxuICogYW55IGVsZW1lbnQsIHdoZXRoZXIgaXQncyBhIG5hdGl2ZSA8QlVUVE9OPiBvciByZWd1bGFyIDxESVY+LlxuICogXG4gKiBOb3RhYmx5LCB0aGUgZm9sbG93aW5nIGNhc2VzIGFyZSBjb3ZlcmVkOlxuICogKiBUaGUgdGFyZ2V0IGVsZW1lbnQgaXMgcHJvcGVybHkgZm9jdXNlZCwgZXZlbiBvbiBpT1MgU2FmYXJpICgqZXNwZWNpYWxseSogb24gaU9TIFNhZmFyaSlcbiAqICogRG91YmxlLWNsaWNrcyB3b24ndCBzZWxlY3QgdGV4dC4gXG4gKiAqIENvbnZlcnNlbHksIG1hbnVhbGx5IHNlbGVjdGluZyB0ZXh0IHdvbid0IGludm9rZSBhIHByZXNzLlxuICogKiBLZXlib2FyZCBldmVudHMgJm1kYXNoOyBgZW50ZXJgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGhhbmRsZXIsIHdoaWxlIGBzcGFjZWAgaW52b2tlcyBpdCBvbiBrZXl1cC5cbiAqICogSGFwdGljIGZlZWRiYWNrIChvbiwgbGlrZSwgdGhlIG9uZSBicm93c2VyIGNvbWJpbmF0aW9uIHRoYXQgc3VwcG9ydHMgaXQgJm1kYXNoOyB0aGlzIGNhbiBiZSBkaXNhYmxlZCBhcHAtd2lkZSB3aXRoIGBzZXRCdXR0b25WaWJyYXRlYClcbiAqIFxuICogSW4gYWRkaXRpb24sIHdoZW4gdGhlIENTUyBgOmFjdGl2ZWAgcHNldWRvLWNsYXNzIHdvdWxkIGFwcGx5IHRvIGEgbm9ybWFsIGJ1dHRvblxuICogKGkuZS4gd2hlbiBob2xkaW5nIHRoZSBzcGFjZWJhciBvciBkdXJpbmcgbW91c2Vkb3duKSwgYHsgXCJkYXRhLXBzZXVkby1hY3RpdmVcIjogXCJ0cnVlXCIgfWBcbiAqIGlzIGFkZGVkIHRvIHRoZSBwcm9wcy4gIFlvdSBjYW4gZWl0aGVyIGxldCBpdCBwYXNzIHRocm91Z2ggYW5kIHN0eWxlIGl0IHRocm91Z2ggbmV3IENTUyxcbiAqIG9yIGluc3BlY3QgdGhlIHJldHVybmVkIHByb3BzIGZvciBpdCBhbmQgYWRkIGUuZy4gYW4gYC5hY3RpdmVgIGNsYXNzIGZvciBleGlzdGluZyBDU1NcbiAqIFxuICogQHBhcmFtIG9uQ2xpY2tTeW5jIFxuICogQHBhcmFtIGV4Y2x1ZGUgV2hldGhlciB0aGUgcG9seWZpbGwgc2hvdWxkbid0IGFwcGx5IChjYW4gc3BlY2lmeSBmb3Igc3BlY2lmaWMgaW50ZXJhY3Rpb25zKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc3M8RSBleHRlbmRzIE5vZGU+KHsgZXhjbHVkZSwgaGFzRm9jdXM6IHsgb25MYXN0Rm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSwgb25DbGlja1N5bmMsIGZvY3VzU2VsZiB9OiBVc2VQcmVzc1BhcmFtZXRlcnM8RT4pIHtcblxuICAgIC8vIEEgYnV0dG9uIGNhbiBiZSBhY3RpdmF0ZWQgaW4gbXVsdGlwbGUgd2F5cywgc28gb24gdGhlIG9mZiBjaGFuY2VcbiAgICAvLyB0aGF0IG11bHRpcGxlIGFyZSB0cmlnZ2VyZWQgYXQgb25jZSwgd2Ugb25seSAqYWN0dWFsbHkqIHJlZ2lzdGVyXG4gICAgLy8gYSBwcmVzcyBvbmNlIGFsbCBvZiBvdXIgXCJvblwiIHNpZ25hbHMgaGF2ZSB0dXJuZWQgYmFjayB0byBcIm9mZlwiLlxuICAgIC8vIFdlIGFwcHJveGltYXRlIHRoaXMgYnkganVzdCBpbmNyZW1lbnRpbmcgd2hlbiBhY3RpdmUsIGFuZFxuICAgIC8vIGRlY3JlbWVudGluZyB3aGVuIGRlYWN0aXZhdGVkLlxuICAgIC8vXG4gICAgLy8gQXMgYW4gZW1lcmdlbmN5IGZhaWxzYWZlLCB3aGVuIHRoZSBlbGVtZW50IGxvc2VzIGZvY3VzLFxuICAgIC8vIHRoaXMgaXMgcmVzZXQgYmFjayB0byAwLlxuICAgIGNvbnN0IFthY3RpdmVEdXJpbmdSZW5kZXIsIHNldEFjdGl2ZSwgZ2V0QWN0aXZlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IGZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGUoKTtcbiAgICBjb25zdCB7IGhhc0ZvY3VzUHJvcHMsIGdldEVsZW1lbnQgfSA9IHVzZUhhc0ZvY3VzKHtcbiAgICAgICAgLi4uaGFzRm9jdXMsXG4gICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHVzZVN0YWJsZUNhbGxiYWNrKChmOiBib29sZWFuLCBwOiBib29sZWFuIHwgdW5kZWZpbmVkKSA9PiB7XG4gICAgICAgICAgICBvbkxhc3RGb2N1c2VkSW5uZXJDaGFuZ2VkPy4oZiwgcCk7XG4gICAgICAgICAgICBpZiAoIWYpIHtcbiAgICAgICAgICAgICAgICBzZXRBY3RpdmUoMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSlcbiAgICB9KTtcblxuICAgIC8vIElmIHdlIHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIGNoYW5nZXMgdG8gaW5jbHVkZSB0aGlzIGVsZW1lbnRcbiAgICAvLyBEVVJJTkcgZS5nLiBhIG1vdXNlZG93biwgdGhlbiB3ZSBkb24ndCB3YW50IHRoZSBtb3VzZXVwIHRvIFwiY291bnRcIiwgYXMgaXQgd2VyZSxcbiAgICAvLyBiZWNhdXNlIGl0cyBvbmx5IHB1cnBvc2Ugd2FzIHNlbGVjdGluZyB0ZXh0LCBub3QgY2xpY2tpbmcgYnV0dG9ucy5cbiAgICAvL1xuICAgIC8vIFRvIGNhdGNoIHRoaXMsIGFueSB0aW1lIHRoZSB0ZXh0IHNlbGVjdGlvbiBpbmNsdWRlcyB1cyB3aGlsZSBpbiB0aGUgbWlkZGxlXG4gICAgLy8gb2YgYSBjbGljaywgdGhpcyBmbGFnIGlzIHNldCwgd2hpY2ggY2FuY2VscyB0aGUgYWN0aXZhdGlvbiBvZiBhIHByZXNzLlxuICAgIC8vIFRoZSBmbGFnIGlzIHJlc2V0IGFueSB0aW1lIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgb3IgdGhlIGJ1dHRvbiBpc1xuICAgIC8vIG5vIGxvbmdlciBhY3RpdmUuXG4gICAgY29uc3QgW3RleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUsIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpO1xuICAgIGNvbnN0IHBzZXVkb0FjdGl2ZSA9IChhY3RpdmVEdXJpbmdSZW5kZXIgJiYgKHRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUgPT0gbnVsbCkpO1xuXG4gICAgdXNlR2xvYmFsSGFuZGxlcihkb2N1bWVudCwgXCJzZWxlY3Rpb25jaGFuZ2VcIiwgXyA9PiB7XG4gICAgICAgIHNldFRleHRTZWxlY3RlZER1cmluZ0FjdGl2YXRpb25TdGFydFRpbWUocHJldiA9PiBub2RlU2VsZWN0ZWRUZXh0TGVuZ3RoKGdldEVsZW1lbnQoKSkgPT0gMCA/IG51bGwgOiBwcmV2ICE9IG51bGwgPyBwcmV2IDogbmV3IERhdGUoKSk7XG4gICAgfSk7XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlRHVyaW5nUmVuZGVyID09IDApXG4gICAgICAgICAgICBzZXRUZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKG51bGwpO1xuXG4gICAgfSwgW2FjdGl2ZUR1cmluZ1JlbmRlciA9PSAwXSk7XG5cbiAgICBjb25zdCBvbkFjdGl2ZVN0YXJ0ID0gdXNlU3RhYmxlQ2FsbGJhY2s8Tm9uTnVsbGFibGU8dHlwZW9mIG9uQ2xpY2tTeW5jPj4oKF8pID0+IHtcbiAgICAgICAgc2V0QWN0aXZlKGEgPT4gKythKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IG9uQWN0aXZlU3RvcCA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XG4gICAgICAgIHNldEFjdGl2ZShhID0+IE1hdGgubWF4KDAsIC0tYSkpO1xuXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gbmV3IERhdGUoKTtcbiAgICAgICAgY29uc3QgdGltZURpZmZlcmVuY2UgPSAodGV4dFNlbGVjdGVkRHVyaW5nQWN0aXZhdGlvblN0YXJ0VGltZSA9PSBudWxsID8gbnVsbCA6ICtjdXJyZW50VGltZSAtICt0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lKTtcbiAgICAgICAgY29uc3QgY2hhcmFjdGVyc1NlbGVjdGVkID0gbm9kZVNlbGVjdGVkVGV4dExlbmd0aChnZXRFbGVtZW50KCkpXG5cbiAgICAgICAgLy8gSWYgd2UncmUgc2VsZWN0aW5nIHRleHQgKGhldXJpc3RpY2FsbHkgZGV0ZXJtaW5lZCBieSBzZWxlY3RpbmcgZm9yIGxvbmdlciB0aGFuIDEvNCBhIHNlY29uZCwgb3IgbW9yZSB0aGFuIDIgY2hhcmFjdGVycylcbiAgICAgICAgLy8gdGhlbiB0aGlzIGlzbid0IGEgcHJlc3MgZXZlbnQuXG4gICAgICAgIC8vIFRPRE86IFRoaXMgc2hvdWxkIG1lYXN1cmUgZ2x5cGhzIGluc3RlYWQgb2YgY2hhcmFjdGVycy5cbiAgICAgICAgaWYgKGNoYXJhY3RlcnNTZWxlY3RlZCA+IDEgfHwgKCh0aW1lRGlmZmVyZW5jZSA/PyAwKSA+IDI1MCAmJiBjaGFyYWN0ZXJzU2VsZWN0ZWQgPj0gMSkpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBhY3RpdmUgPSBnZXRBY3RpdmUoKTsgICAvLyBXZSBxdWVyeSBpZiB3ZSdyZSBhY3RpdmUgKmFmdGVyKiBjYWxsaW5nIHNldFN0YXRlIGJlY2F1c2Ugd2UgY291bnQgYSBwcmVzcyBpZmYgd2UncmUgbm93IGF0IDAuXG4gICAgICAgIGlmIChhY3RpdmUgPD0gMCkge1xuICAgICAgICAgICAgaGFuZGxlUHJlc3MoZSk7XG4gICAgICAgICAgICBmb3JjZVVwZGF0ZSgpOyAgLy8gVE9ETzogUmVtb3ZlIHdoZW4gaXNzdWUgcmVzb2x2ZWQgaHR0cHM6Ly9naXRodWIuY29tL3ByZWFjdGpzL3ByZWFjdC9pc3N1ZXMvMzczMVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBoYW5kbGVQcmVzcyA9IHVzZVN0YWJsZUNhbGxiYWNrPE5vbk51bGxhYmxlPHR5cGVvZiBvbkNsaWNrU3luYz4+KChlKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU3luYykge1xuXG4gICAgICAgICAgICAvLyBOb3RlOiBUaGUgZWxlbWVudCBpcyBmb2N1c2VkIGhlcmUgYmVjYXVzZSBvZiBpT1MgU2FmYXJpLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEl0J3MgYWx3YXlzIGlPUyBTYWZhcmkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gaU9TIFNhZmFyaSAodGVzdGVkIG9uIDEyKSBkb3ducmlnaHQgcmVmdXNlcyB0byBhbGxvdyBcbiAgICAgICAgICAgIC8vIGVsZW1lbnRzIHRvIGJlIG1hbnVhbGx5IGZvY3VzZWQgVU5MRVNTIGl0IGhhcHBlbnMgd2l0aGluXG4gICAgICAgICAgICAvLyBhbiBldmVudCBoYW5kbGVyIGxpa2UgdGhpcy4gIEl0IGFsc28gZG9lc24ndCBmb2N1c1xuICAgICAgICAgICAgLy8gYnV0dG9ucyBieSBkZWZhdWx0IHdoZW4gY2xpY2tlZCwgdGFwcGVkLCBldGMuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSWYgaXQgYmVjb21lcyBwcm9ibGVtYXRpYyB0aGF0IGJ1dHRvbi1saWtlcyBleHBsaWNpdGx5IGJlY29tZVxuICAgICAgICAgICAgLy8gZm9jdXNlZCB3aGVuIHRoZXkgYXJlIHByZXNzZWQsIHRoZW4gYW4gYWx0ZXJuYXRpdmUgc29sdXRpb24gZm9yXG4gICAgICAgICAgICAvLyB0aGUgcXVlc3Rpb24gb2YgXCJob3cgZG8gbWVudSBidXR0b25zIGtlZXAgdGhlaXIgbWVudXMgb3BlblwiXG4gICAgICAgICAgICAvLyBhbmQgb3RoZXIgZm9jdXMtcmVsYXRlZCBub25zZW5zZSBuZWVkcyB0byBiZSBmaWd1cmVkIG91dC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBGb3IgaU9TIFNhZmFyaS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZ2V0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgXCJmb2N1c1wiIGluIChlbGVtZW50IGFzIEV2ZW50VGFyZ2V0IGFzIEhUTUxFbGVtZW50KSlcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGYoZWxlbWVudCBhcyBFdmVudFRhcmdldCBhcyBFKTtcbiAgICAgICAgICAgIC8vKGVsZW1lbnQgYXMgRXZlbnRUYXJnZXQgYXMgSFRNTEVsZW1lbnQgfCBudWxsKT8uZm9jdXMoKTtcblxuICAgICAgICAgICAgLy8gV2hhdGV2ZXIgdGhlIGJyb3dzZXIgd2FzIGdvaW5nIHRvIGRvIHdpdGggdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIGZvcmdldCBpdC4gV2UncmUgdHVybmluZyBpdCBpbnRvIGEgXCJwcmVzc1wiIGV2ZW50LlxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICAvLyBBbHNvIHN0b3AgYW55b25lIGVsc2UgZnJvbSBsaXN0ZW5pbmcgdG8gdGhpcyBldmVudCxcbiAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGV4cGxpY2l0bHkgaGFuZGxpbmcgaXQuXG4gICAgICAgICAgICAvLyAoTm90YWJseSwgdGhpcyBhbGxvd3MgbGFiZWxzIHRvIHdyYXAgaW5wdXRzLCB3aXRoIHRoZW1cbiAgICAgICAgICAgIC8vIGJvdGggaGF2aW5nIHByZXNzIGV2ZW50IGhhbmRsZXJzLCB3aXRob3V0IGRvdWJsZS1maXJpbmcpXG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBIYXB0aWMgZmVlZGJhY2sgZm9yIHRoaXMgcHJlc3MgZXZlbnRcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB0aHJvdyxcbiAgICAgICAgICAgICAgICAvLyBidXQgd2Ugc2hvdWxkIGd1YXJkIGFnYWluc3QgdXNlciBpbXBsZW1lbnRhdGlvbnMgdGhhdCBjb3VsZC5cbiAgICAgICAgICAgICAgICBwdWxzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHkgY2FsbCBvdXIgaGFuZGxlci5cbiAgICAgICAgICAgICAgICBvbkNsaWNrU3luYyhlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbk1vdXNlRG93biA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZE1vdXNlRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jICYmICFleGNsdWRlcyhcImNsaWNrXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICAvLyBTdG9wIGRvdWJsZSBjbGlja3MgZnJvbSBzZWxlY3RpbmcgdGV4dCBpbiBhbiBjb21wb25lbnQgdGhhdCdzICpzdXBwb3NlZCogdG8gYmUgYWN0aW5nIGxpa2UgYSBidXR0b24sXG4gICAgICAgICAgICAvLyBidXQgYWxzbyBkb24ndCBwcmV2ZW50IHRoZSB1c2VyIGZyb20gc2VsZWN0aW5nIHRoYXQgdGV4dCBtYW51YWxseSBpZiB0aGV5IHJlYWxseSB3YW50IHRvXG4gICAgICAgICAgICAvLyAod2hpY2ggdXNlci1zZWxlY3Q6IG5vbmUgd291bGQgZG8sIGJ1dCBjYW5jZWxsaW5nIGEgZG91YmxlIGNsaWNrIG9uIG1vdXNlRG93biBkb2Vzbid0KVxuICAgICAgICAgICAgaWYgKGUuZGV0YWlsID4gMSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0YXJ0KGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSlcbiAgICBjb25zdCBvbk1vdXNlVXAgPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU3luYyAmJiAhZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIGdldEFjdGl2ZSgpID4gMCkge1xuICAgICAgICAgICAgICAgIG9uQWN0aXZlU3RvcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBjb25zdCBvbk1vdXNlTGVhdmUgPSB1c2VTdGFibGVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU3luYyAmJiAhZXhjbHVkZXMoXCJjbGlja1wiLCBleGNsdWRlKSkge1xuICAgICAgICAgICAgc2V0QWN0aXZlKDApO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCBvbktleURvd24gPSB1c2VTdGFibGVDYWxsYmFjaygoZTogaC5KU1guVGFyZ2V0ZWRLZXlib2FyZEV2ZW50PEU+KSA9PiB7XG4gICAgICAgIGlmIChvbkNsaWNrU3luYykge1xuICAgICAgICAgICAgaWYgKGUua2V5ID09IFwiIFwiICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgYWN0aXZhdGUgaXQgb24gYSBzcGFjZSBrZXlkb3duXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGRvIHByZXZlbnREZWZhdWx0IHRvIHN0b3AgdGhlIHBhZ2UgZnJvbSBzY3JvbGxpbmcuXG4gICAgICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmtleSA9PSBcIkVudGVyXCIgJiYgIWV4Y2x1ZGVzKFwiZW50ZXJcIiwgZXhjbHVkZSkpIHtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgb25BY3RpdmVTdGFydChlKTtcbiAgICAgICAgICAgICAgICBvbkFjdGl2ZVN0b3AoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3Qgb25LZXlVcCA9IHVzZVN0YWJsZUNhbGxiYWNrKChlOiBoLkpTWC5UYXJnZXRlZEtleWJvYXJkRXZlbnQ8RT4pID0+IHtcbiAgICAgICAgaWYgKG9uQ2xpY2tTeW5jICYmIGUua2V5ID09IFwiIFwiICYmICFleGNsdWRlcyhcInNwYWNlXCIsIGV4Y2x1ZGUpKVxuICAgICAgICAgICAgb25BY3RpdmVTdG9wKGUpO1xuICAgIH0pXG5cbiAgICBjb25zdCBvbkNsaWNrID0gdXNlU3RhYmxlQ2FsbGJhY2soKGU6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxFPikgPT4ge1xuICAgICAgICBpZiAob25DbGlja1N5bmMpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLmRldGFpbCA+IDEpIHtcbiAgICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIHVzZU1lcmdlZFByb3BzKFxuICAgICAgICBoYXNGb2N1c1Byb3BzLFxuICAgICAgICB7XG4gICAgICAgICAgICBvbktleURvd24sXG4gICAgICAgICAgICBvbktleVVwLFxuICAgICAgICAgICAgb25Nb3VzZURvd24sXG4gICAgICAgICAgICBvbk1vdXNlVXAsXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUsXG4gICAgICAgICAgICBvbkNsaWNrLFxuICAgICAgICAgICAgc3R5bGU6ICh0ZXh0U2VsZWN0ZWREdXJpbmdBY3RpdmF0aW9uU3RhcnRUaW1lICE9IG51bGwpID8geyBjdXJzb3I6IFwidGV4dFwiIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAuLi57IFwiZGF0YS1wc2V1ZG8tYWN0aXZlXCI6IHBzZXVkb0FjdGl2ZSA/IFwidHJ1ZVwiIDogdW5kZWZpbmVkIH0gYXMge31cbiAgICAgICAgfSk7XG59XG5cblxuXG5cbi8qKlxuICogc2VsZWN0aW9uLmNvbnRhaW5zTm9kZSBkb2Vzbid0IGFjY291bnQgZm9yIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCxcbiAqIHNvIGhlcmUncyBhIHdvcmthcm91bmQgZm9yIHRoYXQuXG4gKiBcbiAqIFdlIGFsc28gb25seSBsb29rIGZvciB0aGUgc2VsZWN0aW9uIGVuZCB0byBvbmx5IGNhdGNoIHRoZSBcbiAqIGVzc2Vuc2Ugb2YgYSBub24tZXhpc3RhbnQgXCJzZWxlY3Rpb25zdG9wXCIgZXZlbnQuXG4gKiBcbiAqIEBwYXJhbSBlbGVtZW50IFxuICogQHJldHVybnMgXG4gKi9cbmZ1bmN0aW9uIG5vZGVTZWxlY3RlZFRleHRMZW5ndGgoZWxlbWVudDogRXZlbnRUYXJnZXQgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudCBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKHNlbGVjdGlvbj8ucmFuZ2VDb3VudCA/PyAwKTsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbiEuZ2V0UmFuZ2VBdChpKSE7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC5jb250YWlucyhyYW5nZS5lbmRDb250YWluZXIpICYmICFzZWxlY3Rpb24/LmlzQ29sbGFwc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbiEudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gMDtcbn1cblxuXG5sZXQgcHVsc2UgPSAoKFwidmlicmF0ZVwiIGluIG5hdmlnYXRvcikgJiYgKG5hdmlnYXRvci52aWJyYXRlIGluc3RhbmNlb2YgRnVuY3Rpb24pKSA/ICgoKSA9PiBuYXZpZ2F0b3IudmlicmF0ZSgxMCkpIDogKCgpID0+IHsgfSk7XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgdXNlZCB0byBlbmFibGUvZGlzYWJsZSBidXR0b24gdmlicmF0aW9uIHB1bHNlcyBvbiBhbiBhcHAtd2lkZSBzY2FsZS5cbiAqIFxuICogXG4gKiBAcGFyYW0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcnVuIHdoZW4gYSBidXR0b24gaXMgdGFwcGVkLlxuICogKERlZmF1bHQgaXMgYCgpID0+IG5hdmlnYXRvci52aWJyYXRlKDEwKWAgaW4gYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0LCBhIG5vb3Agb3RoZXJ3aXNlKVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJlc3NWaWJyYXRlKGZ1bmM6ICgpID0+IHZvaWQpIHtcbiAgICBwdWxzZSA9IGZ1bmM7XG59XG5cblxuXG5mdW5jdGlvbiBleGNsdWRlcyh0YXJnZXQ6IFwiY2xpY2tcIiB8IFwic3BhY2VcIiB8IFwiZW50ZXJcIiwgZXhjbHVkZTogdW5kZWZpbmVkIHwgeyBjbGljaz86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBzcGFjZT86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkLCBlbnRlcj86IFwiZXhjbHVkZVwiIHwgdW5kZWZpbmVkIH0pIHtcbiAgICBpZiAoZXhjbHVkZT8uW3RhcmdldF0pXG4gICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiXG5pbXBvcnQgeyBoIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgU3RhdGVVcGRhdGVyLCB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZHJlbiwgdXNlQ2hpbGRyZW5GbGFnLCBVc2VNYW5hZ2VkQ2hpbGRQYXJhbWV0ZXJzIH0gZnJvbSBcIi4vdXNlLWNoaWxkLW1hbmFnZXJcIjtcbmltcG9ydCB7IHVzZUNoaWxkcmVuSGF2ZUZvY3VzLCBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IHVzZVByZXNzIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5pbXBvcnQgeyB1c2VTdGFibGVDYWxsYmFjayB9IGZyb20gXCIuL3VzZS1zdGFibGUtY2FsbGJhY2tcIjtcbmltcG9ydCB7IHVzZVN0YWJsZUdldHRlciB9IGZyb20gXCIuL3VzZS1zdGFibGUtZ2V0dGVyXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCIuL3VzZS1zdGF0ZVwiO1xuXG5cblxuaW50ZXJmYWNlIFNTUDxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4ge1xuICAgIHNlbGVjdGVkSW5kZXg6IG51bWJlciB8IG51bGw7XG4gICAgc2V0U2VsZWN0ZWRJbmRleDogKG5ld0luZGV4OiBudW1iZXIsIGV2ZW50OiB7IHRhcmdldDogRSwgY3VycmVudFRhcmdldDogRSB9IHwgaC5KU1guVGFyZ2V0ZWRFdmVudDxFPikgPT4gdm9pZDtcbiAgICBzZWxlY3Rpb25Nb2RlOiBcImZvY3VzXCIgfCBcImFjdGl2YXRpb25cIiB8IFwiZGlzYWJsZWRcIjtcblxuICAgIHNldFRhYmJhYmxlSW5kZXgodGFiYmFibGVJbmRleDogbnVtYmVyLCBmcm9tVXNlckludGVyYWN0aW9uOiBib29sZWFuKTogdm9pZDtcbiAgICBjaGlsZHJlbjogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSyB8IFwic2VsZWN0ZWRcIj47XG59XG5pbnRlcmZhY2UgU1NDUDxFIGV4dGVuZHMgRWxlbWVudD4ge1xuICAgIHVuc2VsZWN0YWJsZTogYm9vbGVhbjtcbiAgICBhcmlhUHJvcE5hbWU6IGBhcmlhLSR7XCJwcmVzc2VkXCIgfCBcInNlbGVjdGVkXCIgfCBcImNoZWNrZWRcIn1gIHwgbnVsbDtcbiAgICBmb2N1c1NlbGYoZTogRSk6IHZvaWQ7XG59XG5cbmV4cG9ydCB0eXBlIFNpbmdsZVNlbGVjdGlvbkNoaWxkT21pdHMgPSBrZXlvZiBTU0NQPGFueT47XG5cbmV4cG9ydCB0eXBlIFNpbmdsZVNlbGVjdGlvbk9taXRzID0ga2V5b2YgU1NQPGFueSwgYW55LCBhbnk+O1xuXG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHM+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IE9taXQ8U1NQPENoaWxkRWxlbWVudCwgQywgSz4sIFNTT21pdHM+O1xuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiBQYXJ0aWFsPFVzZUNoaWxkcmVuSGF2ZUZvY3VzUGFyYW1ldGVyc1tcImNoaWxkcmVuSGF2ZUZvY3VzXCJdPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8RSBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIE9taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uQ2hpbGRPbWl0cz4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjogT21pdDxTU0NQPEU+LCBPbWl0cz47XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbiAgICBtYW5hZ2VkQ2hpbGQ6IFVzZU1hbmFnZWRDaGlsZFBhcmFtZXRlcnM8bnVtYmVyLCBDLCBLIHwgXCJzZWxlY3RlZFwiLCBuZXZlciwgYW55PltcIm1hbmFnZWRDaGlsZFwiXTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPEUgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiB7XG4gICAgZmxhZ3M6IHsgc2VsZWN0ZWQ6IENoaWxkRmxhZ09wZXJhdGlvbnMgfVxuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZDogYm9vbGVhbiwgZ2V0U2VsZWN0ZWQoKTogYm9vbGVhbjsgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rczxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPEUsIEMsIEs+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiBoLkpTWC5IVE1MQXR0cmlidXRlczxFPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlSW5mbzxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBMc1N1YkluZm8sIEV4dHJhRmxhZ0tleXMgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICBzaW5nbGVTZWxlY3Rpb246IHtcbiAgICAgICAgY2hhbmdlU2VsZWN0ZWRJbmRleDogU3RhdGVVcGRhdGVyPG51bWJlciB8IG51bGw+O1xuICAgICAgICBnZXRTZWxlY3RlZEluZGV4KCk6IG51bWJlciB8IG51bGw7XG4gICAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzXG4gICAgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZDogVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLIHwgXCJzZWxlY3RlZFwiPjtcbn1cblxuXG5leHBvcnQgdHlwZSBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZDxFIGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gPSAoYTogVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUsIEMsIEssIG5ldmVyPikgPT4gVXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPEUsIEMsIEs+O1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU2luZ2xlU2VsZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oe1xuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCBzZXRTZWxlY3RlZEluZGV4LCBjaGlsZHJlbiwgc2V0VGFiYmFibGVJbmRleCB9LFxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cbn06IFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlcj4pOiBVc2VTaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+IHtcblxuICAgIGNvbnN0IHsgdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCB9ID0gdXNlQ2hpbGRyZW5IYXZlRm9jdXM8dW5kZWZpbmVkLCBuZXZlcj4oe1xuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czoge1xuICAgICAgICAgICAgb25BbGxMb3N0Rm9jdXM6IHVzZVN0YWJsZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBvbkFsbExvc3RGb2N1cz8uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkSW5kZXggIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleChzZWxlY3RlZEluZGV4LCBmYWxzZSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQW55R2FpbmVkRm9jdXNcbiAgICAgICAgfSwgbWFuYWdlZENoaWxkcmVuOiB7XG4gICAgICAgICAgICBvbkFmdGVyQ2hpbGRMYXlvdXRFZmZlY3Q6IG51bGwsXG4gICAgICAgICAgICBvbkNoaWxkcmVuTW91bnRDaGFuZ2U6IG51bGxcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3Qgc3RhYmxlT25DaGFuZ2UgPSB1c2VTdGFibGVDYWxsYmFjayhzZXRTZWxlY3RlZEluZGV4KTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgY2hhbmdlSW5kZXg6IGNoYW5nZVNlbGVjdGVkSW5kZXgsXG4gICAgICAgIGdldEN1cnJlbnRJbmRleDogZ2V0U2VsZWN0ZWRJbmRleFxuICAgIH0gPSB1c2VDaGlsZHJlbkZsYWc8QywgSyB8IFwic2VsZWN0ZWRcIj4oe1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGluaXRpYWxJbmRleDogc2VsZWN0ZWRJbmRleCxcbiAgICAgICAga2V5OiBcInNlbGVjdGVkXCIsXG4gICAgICAgIGNsb3Nlc3RGaXQ6IGZhbHNlXG4gICAgfSk7XG5cbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjaGFuZ2VTZWxlY3RlZEluZGV4KHNlbGVjdGVkSW5kZXgpO1xuICAgIH0sIFtzZWxlY3RlZEluZGV4XSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHtcbiAgICAgICAgICAgIGdldFNlbGVjdGVkSW5kZXgsXG4gICAgICAgICAgICBjaGFuZ2VTZWxlY3RlZEluZGV4XG4gICAgICAgIH0sXG4gICAgICAgIHVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkOiB1c2VDYWxsYmFjazxVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQsIEMsIEsgfCBcInNlbGVjdGVkXCI+PigoeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXgsIGZsYWdzIH0sIGhhc0ZvY3VzOiB7IG9uRm9jdXNlZElubmVyQ2hhbmdlZCwgLi4uaGFzRm9jdXMgfSwgc2luZ2xlU2VsZWN0aW9uOiB7IHVuc2VsZWN0YWJsZSwgYXJpYVByb3BOYW1lLCBmb2N1c1NlbGYgfSB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBbaXNTZWxlY3RlZCwgc2V0SXNTZWxlY3RlZCwgZ2V0SXNTZWxlY3RlZF0gPSB1c2VTdGF0ZShnZXRTZWxlY3RlZEluZGV4KCkgPT0gaW5kZXgpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRSZWYgPSB1c2VSZWY8Q2hpbGRGbGFnT3BlcmF0aW9ucz4oeyBnZXQ6IGdldElzU2VsZWN0ZWQsIHNldDogc2V0SXNTZWxlY3RlZCwgaXNWYWxpZDogdXNlU3RhYmxlQ2FsbGJhY2soKCkgPT4gIXVuc2VsZWN0YWJsZSkgfSk7XG4gICAgICAgICAgICBjb25zdCB7IGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wcywgZ2V0RWxlbWVudCB9ID0gdXNlQ2hpbGRyZW5IYXZlRm9jdXNDaGlsZCh7XG4gICAgICAgICAgICAgICAgb25Gb2N1c2VkSW5uZXJDaGFuZ2VkOiB1c2VTdGFibGVDYWxsYmFjaygoZm9jdXNlZDogYm9vbGVhbiwgcHJldjogYm9vbGVhbiB8IHVuZGVmaW5lZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9jdXNlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnZ2VyO1xuICAgICAgICAgICAgICAgICAgICBvbkZvY3VzZWRJbm5lckNoYW5nZWQ/Lihmb2N1c2VkLCBwcmV2KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbk1vZGUgPT0gJ2ZvY3VzJyAmJiBmb2N1c2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFibGVPbkNoYW5nZShnZXRJbmRleCgpLCB7IHRhcmdldDogZ2V0RWxlbWVudCgpISwgY3VycmVudFRhcmdldDogZ2V0RWxlbWVudCgpISB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmhhc0ZvY3VzLFxuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCB9LFxuICAgICAgICAgICAgICAgIHN1YkluZm86IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGdldEluZGV4ID0gdXNlU3RhYmxlR2V0dGVyKGluZGV4KTtcblxuICAgICAgICAgICAgY29uc3QgdXNlUHJlc3NQcm9wcyA9IHVzZVByZXNzPENoaWxkRWxlbWVudD4oe1xuICAgICAgICAgICAgICAgIG9uQ2xpY2tTeW5jOiB1bnNlbGVjdGFibGUgPyBudWxsIDogKChlKSA9PiB7IHN0YWJsZU9uQ2hhbmdlKGdldEluZGV4KCksIGUpOyB9KSxcbiAgICAgICAgICAgICAgICBleGNsdWRlOiB7fSxcbiAgICAgICAgICAgICAgICBoYXNGb2N1cyxcbiAgICAgICAgICAgICAgICBmb2N1c1NlbGZcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZsYWdzOiB7IC4uLmZsYWdzLCBzZWxlY3RlZDogc2VsZWN0ZWRSZWYuY3VycmVudCB9LFxuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHM6IHVzZU1lcmdlZFByb3BzKHVzZU1lcmdlZFByb3BzKHVzZVByZXNzUHJvcHMsIGNoaWxkcmVuSGF2ZUZvY3VzQ2hpbGRQcm9wcyksIHsgW2FyaWFQcm9wTmFtZSBhcyBrZXlvZiBoLkpTWC5IVE1MQXR0cmlidXRlczxhbnk+XTogKGlzU2VsZWN0ZWQgPz8gZmFsc2UpLnRvU3RyaW5nKCkgfSksXG4gICAgICAgICAgICAgICAgc2luZ2xlU2VsZWN0aW9uOiB7IHNlbGVjdGVkOiBpc1NlbGVjdGVkLCBnZXRTZWxlY3RlZDogZ2V0SXNTZWxlY3RlZCB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbc2VsZWN0aW9uTW9kZV0pLFxuICAgIH1cbn1cblxuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNvcHlBcnJheTtcbiIsIi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVGbG9vciA9IE1hdGguZmxvb3IsXG4gICAgbmF0aXZlUmFuZG9tID0gTWF0aC5yYW5kb207XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZG9tYCB3aXRob3V0IHN1cHBvcnQgZm9yIHJldHVybmluZ1xuICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSB1cHBlciBUaGUgdXBwZXIgYm91bmQuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSByYW5kb20gbnVtYmVyLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZG9tKGxvd2VyLCB1cHBlcikge1xuICByZXR1cm4gbG93ZXIgKyBuYXRpdmVGbG9vcihuYXRpdmVSYW5kb20oKSAqICh1cHBlciAtIGxvd2VyICsgMSkpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlUmFuZG9tO1xuIiwiaW1wb3J0IGJhc2VSYW5kb20gZnJvbSAnLi9fYmFzZVJhbmRvbS5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIHdoaWNoIG11dGF0ZXMgYW5kIHNldHMgdGhlIHNpemUgb2YgYGFycmF5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICBzaXplID0gc2l6ZSA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogc2l6ZTtcbiAgd2hpbGUgKCsraW5kZXggPCBzaXplKSB7XG4gICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICB2YWx1ZSA9IGFycmF5W3JhbmRdO1xuXG4gICAgYXJyYXlbcmFuZF0gPSBhcnJheVtpbmRleF07XG4gICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gIH1cbiAgYXJyYXkubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGFycmF5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlU2VsZjtcbiIsImltcG9ydCBjb3B5QXJyYXkgZnJvbSAnLi9fY29weUFycmF5LmpzJztcbmltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNodWZmbGVgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzaHVmZmxlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U2h1ZmZsZShhcnJheSkge1xuICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5U2h1ZmZsZTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5TWFwO1xuIiwiaW1wb3J0IGFycmF5TWFwIGZyb20gJy4vX2FycmF5TWFwLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VWYWx1ZXM7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRpbWVzYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHNcbiAqIG9yIG1heCBhcnJheSBsZW5ndGggY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgcmVzdWx0W2luZGV4XSA9IGl0ZXJhdGVlKGluZGV4KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVGltZXM7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNBcmd1bWVudHM7XG4iLCJpbXBvcnQgYmFzZUlzQXJndW1lbnRzIGZyb20gJy4vX2Jhc2VJc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzQXJndW1lbnRzID0gYmFzZUlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID8gYmFzZUlzQXJndW1lbnRzIDogZnVuY3Rpb24odmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgIXByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodmFsdWUsICdjYWxsZWUnKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXk7XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICogLy8gPT4gW2ZhbHNlLCBmYWxzZV1cbiAqL1xuZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0dWJGYWxzZTtcbiIsImltcG9ydCByb290IGZyb20gJy4vX3Jvb3QuanMnO1xuaW1wb3J0IHN0dWJGYWxzZSBmcm9tICcuL3N0dWJGYWxzZS5qcyc7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxuZXhwb3J0IGRlZmF1bHQgaXNCdWZmZXI7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IHVuc2lnbmVkIGludGVnZXIgdmFsdWVzLiAqL1xudmFyIHJlSXNVaW50ID0gL14oPzowfFsxLTldXFxkKikkLztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHBhcmFtIHtudW1iZXJ9IFtsZW5ndGg9TUFYX1NBRkVfSU5URUdFUl0gVGhlIHVwcGVyIGJvdW5kcyBvZiBhIHZhbGlkIGluZGV4LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBpbmRleCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0luZGV4KHZhbHVlLCBsZW5ndGgpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICByZXR1cm4gISFsZW5ndGggJiZcbiAgICAodHlwZSA9PSAnbnVtYmVyJyB8fFxuICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAodmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8IGxlbmd0aCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzSW5kZXg7XG4iLCIvKiogVXNlZCBhcyByZWZlcmVuY2VzIGZvciB2YXJpb3VzIGBOdW1iZXJgIGNvbnN0YW50cy4gKi9cbnZhciBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgbGVuZ3RoLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNMZW5ndGgoMyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0xlbmd0aChOdW1iZXIuTUlOX1ZBTFVFKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0xlbmd0aChJbmZpbml0eSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoJzMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiZcbiAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzTGVuZ3RoO1xuIiwiaW1wb3J0IGJhc2VHZXRUYWcgZnJvbSAnLi9fYmFzZUdldFRhZy5qcyc7XG5pbXBvcnQgaXNMZW5ndGggZnJvbSAnLi9pc0xlbmd0aC5qcyc7XG5pbXBvcnQgaXNPYmplY3RMaWtlIGZyb20gJy4vaXNPYmplY3RMaWtlLmpzJztcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlSXNUeXBlZEFycmF5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bmFyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBzdG9yaW5nIG1ldGFkYXRhLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZVVuYXJ5KGZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIGZ1bmModmFsdWUpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlVW5hcnk7XG4iLCJpbXBvcnQgZnJlZUdsb2JhbCBmcm9tICcuL19mcmVlR2xvYmFsLmpzJztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbnZhciBmcmVlUHJvY2VzcyA9IG1vZHVsZUV4cG9ydHMgJiYgZnJlZUdsb2JhbC5wcm9jZXNzO1xuXG4vKiogVXNlZCB0byBhY2Nlc3MgZmFzdGVyIE5vZGUuanMgaGVscGVycy4gKi9cbnZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICAvLyBVc2UgYHV0aWwudHlwZXNgIGZvciBOb2RlLmpzIDEwKy5cbiAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgIGlmICh0eXBlcykge1xuICAgICAgcmV0dXJuIHR5cGVzO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBgcHJvY2Vzcy5iaW5kaW5nKCd1dGlsJylgIGZvciBOb2RlLmpzIDwgMTAuXG4gICAgcmV0dXJuIGZyZWVQcm9jZXNzICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcgJiYgZnJlZVByb2Nlc3MuYmluZGluZygndXRpbCcpO1xuICB9IGNhdGNoIChlKSB7fVxufSgpKTtcblxuZXhwb3J0IGRlZmF1bHQgbm9kZVV0aWw7XG4iLCJpbXBvcnQgYmFzZUlzVHlwZWRBcnJheSBmcm9tICcuL19iYXNlSXNUeXBlZEFycmF5LmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzVHlwZWRBcnJheShuZXcgVWludDhBcnJheSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkoW10pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzVHlwZWRBcnJheSA9IG5vZGVJc1R5cGVkQXJyYXkgPyBiYXNlVW5hcnkobm9kZUlzVHlwZWRBcnJheSkgOiBiYXNlSXNUeXBlZEFycmF5O1xuXG5leHBvcnQgZGVmYXVsdCBpc1R5cGVkQXJyYXk7XG4iLCJpbXBvcnQgYmFzZVRpbWVzIGZyb20gJy4vX2Jhc2VUaW1lcy5qcyc7XG5pbXBvcnQgaXNBcmd1bWVudHMgZnJvbSAnLi9pc0FyZ3VtZW50cy5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuaW1wb3J0IGlzQnVmZmVyIGZyb20gJy4vaXNCdWZmZXIuanMnO1xuaW1wb3J0IGlzSW5kZXggZnJvbSAnLi9faXNJbmRleC5qcyc7XG5pbXBvcnQgaXNUeXBlZEFycmF5IGZyb20gJy4vaXNUeXBlZEFycmF5LmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtib29sZWFufSBpbmhlcml0ZWQgU3BlY2lmeSByZXR1cm5pbmcgaW5oZXJpdGVkIHByb3BlcnR5IG5hbWVzLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYXJyYXlMaWtlS2V5cyh2YWx1ZSwgaW5oZXJpdGVkKSB7XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpLFxuICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgaXNCdWZmID0gIWlzQXJyICYmICFpc0FyZyAmJiBpc0J1ZmZlcih2YWx1ZSksXG4gICAgICBpc1R5cGUgPSAhaXNBcnIgJiYgIWlzQXJnICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHZhbHVlKSxcbiAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgIHJlc3VsdCA9IHNraXBJbmRleGVzID8gYmFzZVRpbWVzKHZhbHVlLmxlbmd0aCwgU3RyaW5nKSA6IFtdLFxuICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICBpZiAoKGluaGVyaXRlZCB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSAmJlxuICAgICAgICAhKHNraXBJbmRleGVzICYmIChcbiAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICBrZXkgPT0gJ2xlbmd0aCcgfHxcbiAgICAgICAgICAgLy8gTm9kZS5qcyAwLjEwIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIGJ1ZmZlcnMuXG4gICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAvLyBQaGFudG9tSlMgMiBoYXMgZW51bWVyYWJsZSBub24taW5kZXggcHJvcGVydGllcyBvbiB0eXBlZCBhcnJheXMuXG4gICAgICAgICAgIChpc1R5cGUgJiYgKGtleSA9PSAnYnVmZmVyJyB8fCBrZXkgPT0gJ2J5dGVMZW5ndGgnIHx8IGtleSA9PSAnYnl0ZU9mZnNldCcpKSB8fFxuICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgIGlzSW5kZXgoa2V5LCBsZW5ndGgpXG4gICAgICAgICkpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBhcnJheUxpa2VLZXlzO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc1Byb3RvdHlwZTtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICByZXR1cm4gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBvdmVyQXJnO1xuIiwiaW1wb3J0IG92ZXJBcmcgZnJvbSAnLi9fb3ZlckFyZy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVLZXlzID0gb3ZlckFyZyhPYmplY3Qua2V5cywgT2JqZWN0KTtcblxuZXhwb3J0IGRlZmF1bHQgbmF0aXZlS2V5cztcbiIsImltcG9ydCBpc1Byb3RvdHlwZSBmcm9tICcuL19pc1Byb3RvdHlwZS5qcyc7XG5pbXBvcnQgbmF0aXZlS2V5cyBmcm9tICcuL19uYXRpdmVLZXlzLmpzJztcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlS2V5cztcbiIsImltcG9ydCBiYXNlR2V0VGFnIGZyb20gJy4vX2Jhc2VHZXRUYWcuanMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXNPYmplY3QuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XSc7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24sIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0Z1bmN0aW9uKF8pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNGdW5jdGlvbigvYWJjLyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIFRoZSB1c2Ugb2YgYE9iamVjdCN0b1N0cmluZ2AgYXZvaWRzIGlzc3VlcyB3aXRoIHRoZSBgdHlwZW9mYCBvcGVyYXRvclxuICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgdmFyIHRhZyA9IGJhc2VHZXRUYWcodmFsdWUpO1xuICByZXR1cm4gdGFnID09IGZ1bmNUYWcgfHwgdGFnID09IGdlblRhZyB8fCB0YWcgPT0gYXN5bmNUYWcgfHwgdGFnID09IHByb3h5VGFnO1xufVxuXG5leHBvcnQgZGVmYXVsdCBpc0Z1bmN0aW9uO1xuIiwiaW1wb3J0IGlzRnVuY3Rpb24gZnJvbSAnLi9pc0Z1bmN0aW9uLmpzJztcbmltcG9ydCBpc0xlbmd0aCBmcm9tICcuL2lzTGVuZ3RoLmpzJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLiBBIHZhbHVlIGlzIGNvbnNpZGVyZWQgYXJyYXktbGlrZSBpZiBpdCdzXG4gKiBub3QgYSBmdW5jdGlvbiBhbmQgaGFzIGEgYHZhbHVlLmxlbmd0aGAgdGhhdCdzIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIG9yXG4gKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFycmF5LWxpa2UsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZSgnYWJjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgaXNMZW5ndGgodmFsdWUubGVuZ3RoKSAmJiAhaXNGdW5jdGlvbih2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGlzQXJyYXlMaWtlO1xuIiwiaW1wb3J0IGFycmF5TGlrZUtleXMgZnJvbSAnLi9fYXJyYXlMaWtlS2V5cy5qcyc7XG5pbXBvcnQgYmFzZUtleXMgZnJvbSAnLi9fYmFzZUtleXMuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLiBTZWUgdGhlXG4gKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8ua2V5cyhuZXcgRm9vKTtcbiAqIC8vID0+IFsnYScsICdiJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLmtleXMoJ2hpJyk7XG4gKiAvLyA9PiBbJzAnLCAnMSddXG4gKi9cbmZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5TGlrZShvYmplY3QpID8gYXJyYXlMaWtlS2V5cyhvYmplY3QpIDogYmFzZUtleXMob2JqZWN0KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQga2V5cztcbiIsImltcG9ydCBiYXNlVmFsdWVzIGZyb20gJy4vX2Jhc2VWYWx1ZXMuanMnO1xuaW1wb3J0IGtleXMgZnJvbSAnLi9rZXlzLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydHkgdmFsdWVzIG9mIGBvYmplY3RgLlxuICpcbiAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiAgIHRoaXMuYiA9IDI7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAqXG4gKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAqIC8vID0+IFsxLCAyXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8udmFsdWVzKCdoaScpO1xuICogLy8gPT4gWydoJywgJ2knXVxuICovXG5mdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXMob2JqZWN0KSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbHVlcztcbiIsImltcG9ydCBzaHVmZmxlU2VsZiBmcm9tICcuL19zaHVmZmxlU2VsZi5qcyc7XG5pbXBvcnQgdmFsdWVzIGZyb20gJy4vdmFsdWVzLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zaHVmZmxlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlU2h1ZmZsZShjb2xsZWN0aW9uKSB7XG4gIHJldHVybiBzaHVmZmxlU2VsZih2YWx1ZXMoY29sbGVjdGlvbikpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlU2h1ZmZsZTtcbiIsImltcG9ydCBhcnJheVNodWZmbGUgZnJvbSAnLi9fYXJyYXlTaHVmZmxlLmpzJztcbmltcG9ydCBiYXNlU2h1ZmZsZSBmcm9tICcuL19iYXNlU2h1ZmZsZS5qcyc7XG5pbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzQXJyYXkuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gKiBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlci1ZYXRlc19zaHVmZmxlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2h1ZmZsZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNodWZmbGVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnNodWZmbGUoWzEsIDIsIDMsIDRdKTtcbiAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICovXG5mdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaHVmZmxlO1xuIiwiaW1wb3J0ICogYXMgXyBmcm9tIFwibG9kYXNoXCI7XG5pbXBvcnQgeyBoLCBWTm9kZSB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IE11dGFibGVSZWYsIHVzZUNhbGxiYWNrLCB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IE1hbmFnZWRDaGlsZEluZm8sIE1hbmFnZWRDaGlsZHJlbiB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyB1c2VGb3JjZVVwZGF0ZSB9IGZyb20gXCIuL3VzZS1mb3JjZS11cGRhdGVcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzIH0gZnJvbSBcIi4vdXNlLW1lcmdlZC1wcm9wc1wiO1xuaW1wb3J0IHsgcmV0dXJuTnVsbCwgdXNlUGFzc2l2ZVN0YXRlIH0gZnJvbSBcIi4vdXNlLXBhc3NpdmUtc3RhdGVcIjtcbmltcG9ydCBsb2Rhc2hTaHVmZmxlIGZyb20gXCJsb2Rhc2gtZXMvc2h1ZmZsZVwiO1xuXG5leHBvcnQgdHlwZSBHZXRJbmRleDxDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChyb3c6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPikgPT4gKG51bWJlciB8IG51bGwgfCB1bmRlZmluZWQpO1xuZXhwb3J0IHR5cGUgQ29tcGFyZTxWPiA9IChsaHM6IFYsIHJoczogVikgPT4gbnVtYmVyO1xuXG4vKipcbiAqIEFsbCBvZiB0aGVzZSBmdW5jdGlvbnMgKipNVVNUKiogYmUgc3RhYmxlIGFjcm9zcyByZW5kZXJzLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSyBleHRlbmRzIHN0cmluZz4ge1xuXG4gICAgLyoqXG4gICAgICogTXVzdCByZXR1cm4sIGUuZy4sIHRoZSByb3cgaW5kZXggb2YgdGhpcyBjaGlsZFxuICAgICAqIChVc3VhbGx5IGp1c3QgYW4gYGluZGV4YCBwcm9wKVxuICAgICAqL1xuICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleDogR2V0SW5kZXg8QywgSz47IH1cbn1cblxuLyoqXG4gKiBBbGwgb2YgdGhlc2UgZnVuY3Rpb25zICoqTVVTVCoqIGJlIHN0YWJsZSBhY3Jvc3MgcmVuZGVycy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUNoaWxkcmVuUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nPiBleHRlbmRzIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11c3QgcmV0dXJuIHRoZSB2YWx1ZSB0aGlzIGNoaWxkIHVzZXMgUkU6IHNvcnRpbmcuXG4gICAgICAgICAqIElmIHlvdSBkb24ndCBjYXJlIGFib3V0IHNvcnRpbmcgKHlvdSBqdXN0IHVzZSBcbiAgICAgICAgICogeW91ciBvd25hcmJpdHJhcnkgcmVvcmRlcmluZyksIHRoaXMgd2lsbCBuZXZlclxuICAgICAgICAgKiBiZSB1c2VkLCBzbyBpdCBjYW4gcmV0dXJuIGFueXRoaW5nLlxuICAgICAgICAgKiBAcGFyYW0gcm93IFxuICAgICAgICAgKiBAcGFyYW0gYXJncyBcbiAgICAgICAgICovXG4gICAgICAgIC8vZ2V0VmFsdWU6IEdldFZhbHVlPEMsIEssIEcsIFY+O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb250cm9scyBob3cgdmFsdWVzIGNvbXBhcmUgYWdhaW5zdCBlYWNoIG90aGVyLlxuICAgICAgICAgKiBAcGFyYW0gbGhzIFxuICAgICAgICAgKiBAcGFyYW0gcmhzIFxuICAgICAgICAgKi9cbiAgICAgICAgY29tcGFyZTogQ29tcGFyZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+O1xuICAgIH1cbn1cblxuXG5cbi8qKlxuICogSG9vayB0aGF0IGFsbG93cyBmb3IgdGhlICoqZGlyZWN0IGRlc2NlbmRhbnQqKiBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCB0byBiZSByZS1vcmRlcmVkIGFuZCBzb3J0ZWQuXG4gKiBcbiAqICpUaGlzIGlzICoqc2VwYXJhdGUqKiBmcm9tIFwibWFuYWdlZFwiIGNoaWxkcmVuLCB3aGljaCBjYW4gYmUgYW55IGxldmVsIG9mIGNoaWxkIG5lZWRlZCEgU29ydGFibGUvcmVhcnJhbmdlYWJsZSBjaGlsZHJlbiBtdXN0IGJlICoqZGlyZWN0IGRlc2NlbmRhbnRzKiogb2YgdGhlIHBhcmVudCB0aGF0IHVzZXMgdGhpcyBob29rISpcbiAqIFxuICogSXQncyByZWNvbW1lbmRlZCB0byB1c2UgdGhpcyBpbiBjb25qdW5jdGlvbiB3aXRoIGB1c2VMaXN0TmF2aWdhdGlvbmA7IGl0IHRha2VzIHRoZSBzYW1lIGBpbmRleE1hbmdsZXJgIGFuZCBgaW5kZXhEZW1hbmdsZXJgIFxuICogZnVuY3Rpb25zIHRoYXQgdGhpcyBob29rIHJldHVybnMuIGB1c2VMaXN0TmF2aWdhdGlvbmAgZG9lcyBub3QgZGlyZWN0bHkgdXNlIHRoaXMgaG9vayBiZWNhdXNlLCBhcyBtZW50aW9uZWQsIFxuICogdGhpcyBob29rIGltcG9zZXMgc2VyaW91cyByZXN0cmljdGlvbnMgb24gY2hpbGQgc3RydWN0dXJlLCB3aGlsZSBgdXNlTGlzdE5hdmlnYXRpb25gIGFsbG93cyBhbnl0aGluZy5cbiAqIFxuICogQmVzaWRlcyB0aGUgcHJvcC1tb2RpZnlpbmcgaG9vayB0aGF0J3MgcmV0dXJuZWQsIHRoZSBgc29ydGAgZnVuY3Rpb24gdGhhdCdzIHJldHVybmVkIHdpbGxcbiAqIHNvcnQgYWxsIGNoaWxkcmVuIGFjY29yZGluZyB0byB0aGVpciB2YWx1ZSBmcm9tIHRoZSBgZ2V0VmFsdWVgIGFyZ3VtZW50IHlvdSBwYXNzIGluLlxuICogXG4gKiBJZiB5b3Ugd2FudCB0byBwZXJmb3JtIHNvbWUgcmUtb3JkZXJpbmcgb3BlcmF0aW9uIHRoYXQncyAqbm90KiBhIHNvcnQsIHlvdSBjYW4gbWFudWFsbHlcbiAqIHJlLW1hcCBlYWNoIGNoaWxkJ3MgcG9zaXRpb24gdXNpbmcgYG1hbmdsZU1hcGAgYW5kIGBkZW1hbmdsZU1hcGAsIHdoaWNoIGNvbnZlcnQgYmV0d2VlblxuICogc29ydGVkIGFuZCB1bnNvcnRlZCBpbmRleCBwb3NpdGlvbnMuXG4gKiBcbiAqIEFnYWluLCB1bmxpa2Ugc29tZSBvdGhlciBob29rcywgKip0aGVzZSBjaGlsZHJlbiBtdXN0IGJlIGRpcmVjdCBkZXNjZW5kYW50cyoqLiBUaGlzIGlzIGJlY2F1c2VcbiAqIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIGluc3BlY3RzIHRoZSBnaXZlbiBjaGlsZHJlbiwgdGhlbiByZS1jcmVhdGVzIHRoZW0gd2l0aCBuZXcgYGtleWBzLlxuICogQmVjYXVzZSBrZXlzIGFyZSBnaXZlbiBzcGVjaWFsIHRyZWF0bWVudCBhbmQgYSBjaGlsZCBoYXMgbm8gd2F5IG9mIG1vZGlmeWluZyBpdHMgb3duIGtleVxuICogdGhlcmUncyBubyBvdGhlciB0aW1lIG9yIHBsYWNlIHRoaXMgY2FuIGhhcHBlbiBvdGhlciB0aGFuIGV4YWN0bHkgd2l0aGluIHRoZSBwYXJlbnQgY29tcG9uZW50J3MgcmVuZGVyIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9IH06IFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4pOiBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIEMsIEs+IHtcblxuICAgIC8vIFRoZXNlIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgYSBtYXBwaW5nIGJldHdlZW4gdW5zb3J0ZWQgaW5kZXggPC0tLT4gc29ydGVkIGluZGV4LlxuICAgIC8vIFRoZXNlIGFyZSBuZWVkZWQgZm9yIG5hdmlnYXRpb24gd2l0aCB0aGUgYXJyb3cga2V5cy5cbiAgICBjb25zdCBtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgZGVtYW5nbGVNYXAgPSB1c2VSZWYobmV3IE1hcDxudW1iZXIsIG51bWJlcj4oKSk7XG4gICAgY29uc3QgaW5kZXhNYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKG1hbmdsZU1hcC5jdXJyZW50LmdldChuKSA/PyBuKSwgW10pO1xuICAgIGNvbnN0IGluZGV4RGVtYW5nbGVyID0gdXNlQ2FsbGJhY2soKG46IG51bWJlcikgPT4gKGRlbWFuZ2xlTWFwLmN1cnJlbnQuZ2V0KG4pID8/IG4pLCBbXSk7XG5cbiAgICAvLyBUaGUgc29ydCBmdW5jdGlvbiBuZWVkcyB0byBiZSBhYmxlIHRvIHVwZGF0ZSB3aG9ldmVyIGhhcyBhbGwgdGhlIHNvcnRhYmxlIGNoaWxkcmVuLlxuICAgIC8vIEJlY2F1c2UgdGhhdCBtaWdodCBub3QgYmUgdGhlIGNvbnN1bWVyIG9mICp0aGlzKiBob29rIGRpcmVjdGx5IChlLmcuIGEgdGFibGUgdXNlc1xuICAgIC8vIHRoaXMgaG9vaywgYnV0IGl0J3MgdGJvZHkgdGhhdCBhY3R1YWxseSBuZWVkcyB1cGRhdGluZyksIHdlIG5lZWQgdG8gcmVtb3RlbHlcbiAgICAvLyBnZXQgYW5kIHNldCBhIGZvcmNlVXBkYXRlIGZ1bmN0aW9uLlxuICAgIC8vY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG4gICAgY29uc3QgW2dldEZvcmNlVXBkYXRlLCBzZXRGb3JjZVVwZGF0ZV0gPSB1c2VQYXNzaXZlU3RhdGU8bnVsbCB8ICgoKSA9PiB2b2lkKT4obnVsbCwgcmV0dXJuTnVsbCk7XG5cbiAgICBjb25zdCByZWFycmFuZ2UgPSB1c2VDYWxsYmFjaygoc29ydGVkUm93czogTWFuYWdlZENoaWxkSW5mbzxudW1iZXIsIEMsIEs+W10pID0+IHtcblxuICAgICAgICAvLyBVcGRhdGUgb3VyIHNvcnRlZCA8LS0+IHVuc29ydGVkIGluZGljZXMgbWFwIFxuICAgICAgICAvLyBhbmQgcmVyZW5kZXIgdGhlIHdob2xlIHRhYmxlLCBiYXNpY2FsbHlcbiAgICAgICAgZm9yIChsZXQgaW5kZXhBc1NvcnRlZCA9IDA7IGluZGV4QXNTb3J0ZWQgPCBzb3J0ZWRSb3dzLmxlbmd0aDsgKytpbmRleEFzU29ydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleEFzVW5zb3J0ZWQgPSBzb3J0ZWRSb3dzW2luZGV4QXNTb3J0ZWRdLmluZGV4O1xuXG4gICAgICAgICAgICBtYW5nbGVNYXAuY3VycmVudC5zZXQoaW5kZXhBc1Vuc29ydGVkLCBpbmRleEFzU29ydGVkKTtcbiAgICAgICAgICAgIGRlbWFuZ2xlTWFwLmN1cnJlbnQuc2V0KGluZGV4QXNTb3J0ZWQsIGluZGV4QXNVbnNvcnRlZCk7XG4gICAgICAgIH1cblxuXG4gICAgICAgIGdldEZvcmNlVXBkYXRlKCk/LigpO1xuICAgIH0sIFtdKTtcblxuICAgIGNvbnN0IHVzZVJlYXJyYW5nZWFibGVQcm9wcyA9IHVzZUNhbGxiYWNrKCh7IGNoaWxkcmVuLCAuLi5wcm9wcyB9OiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB9KSA9PiB7XG4gICAgICAgIGNvbnNvbGUuYXNzZXJ0KEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKTtcblxuICAgICAgICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7IHNldEZvcmNlVXBkYXRlKF9wcmV2ID0+IGZvcmNlVXBkYXRlKTsgfSwgW2ZvcmNlVXBkYXRlXSlcblxuICAgICAgICByZXR1cm4gKHVzZU1lcmdlZFByb3BzPFBhcmVudEVsZW1lbnQ+KHtcbiAgICAgICAgICAgIGNoaWxkcmVuOlxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiBhcyBWTm9kZTxNYW5hZ2VkQ2hpbGRJbmZvPG51bWJlciwgQywgSz4+W10pXG4gICAgICAgICAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoY2hpbGQgPT4gKHsgY2hpbGQsIG1hbmdsZWRJbmRleDogaW5kZXhNYW5nbGVyKGdldEluZGV4KGNoaWxkLnByb3BzISkhKSwgZGVtYW5nbGVkSW5kZXg6IGdldEluZGV4KGNoaWxkLnByb3BzKSB9KSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKGxocywgcmhzKSA9PiB7IHJldHVybiBsaHMubWFuZ2xlZEluZGV4IC0gcmhzLm1hbmdsZWRJbmRleCB9KVxuICAgICAgICAgICAgICAgICAgICAubWFwKCh7IGNoaWxkLCBtYW5nbGVkSW5kZXgsIGRlbWFuZ2xlZEluZGV4IH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoKGNoaWxkLnR5cGUgYXMgYW55LCB7IC4uLmNoaWxkLnByb3BzLCBrZXk6IGRlbWFuZ2xlZEluZGV4LCBcImRhdGEtbWFuZ2xlZC1pbmRleFwiOiBtYW5nbGVkSW5kZXgsIFwiZGF0YS11bm1hbmdsZWQtaW5kZXhcIjogZGVtYW5nbGVkSW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sIHByb3BzKSk7XG4gICAgfSwgW10pO1xuXG4gICAgcmV0dXJuIHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhNYW5nbGVyLCBpbmRleERlbWFuZ2xlciwgbWFuZ2xlTWFwLCBkZW1hbmdsZU1hcCwgcmVhcnJhbmdlIH0gfTtcbn1cblxuXG4vKipcbiAqIEhvb2sgdGhhdCBhbGxvd3MgZm9yIHRoZSAqKmRpcmVjdCBkZXNjZW5kYW50KiogY2hpbGRyZW4gb2YgdGhpcyBjb21wb25lbnQgdG8gYmUgcmUtb3JkZXJlZCBhbmQgc29ydGVkLlxuICogXG4gKiAqVGhpcyBpcyAqKnNlcGFyYXRlKiogZnJvbSBcIm1hbmFnZWRcIiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlIGFueSBsZXZlbCBvZiBjaGlsZCBuZWVkZWQhIFNvcnRhYmxlL3JlYXJyYW5nZWFibGUgY2hpbGRyZW4gbXVzdCBiZSAqKmRpcmVjdCBkZXNjZW5kYW50cyoqIG9mIHRoZSBwYXJlbnQgdGhhdCB1c2VzIHRoaXMgaG9vayEqIFxuICogXG4gKiBJdCdzIHJlY29tbWVuZGVkIHRvIHVzZSB0aGlzIGluIGNvbmp1bmN0aW9uIHdpdGggYHVzZUxpc3ROYXZpZ2F0aW9uYDsgaXQgdGFrZXMgdGhlIHNhbWUgYGluZGV4TWFuZ2xlcmAgYW5kIGBpbmRleERlbWFuZ2xlcmAgXG4gKiBmdW5jdGlvbnMgdGhhdCB0aGlzIGhvb2sgcmV0dXJucy4gYHVzZUxpc3ROYXZpZ2F0aW9uYCBkb2VzIG5vdCBkaXJlY3RseSB1c2UgdGhpcyBob29rIGJlY2F1c2UsIGFzIG1lbnRpb25lZCwgXG4gKiB0aGlzIGhvb2sgaW1wb3NlcyBzZXJpb3VzIHJlc3RyaWN0aW9ucyBvbiBjaGlsZCBzdHJ1Y3R1cmUsIHdoaWxlIGB1c2VMaXN0TmF2aWdhdGlvbmAgYWxsb3dzIGFueXRoaW5nLlxuICogXG4gKiBCZXNpZGVzIHRoZSBwcm9wLW1vZGlmeWluZyBob29rIHRoYXQncyByZXR1cm5lZCwgdGhlIGBzb3J0YCBmdW5jdGlvbiB0aGF0J3MgcmV0dXJuZWQgd2lsbFxuICogc29ydCBhbGwgY2hpbGRyZW4gYWNjb3JkaW5nIHRvIHRoZWlyIHZhbHVlIGZyb20gdGhlIGBnZXRWYWx1ZWAgYXJndW1lbnQgeW91IHBhc3MgaW4uXG4gKiBcbiAqIElmIHlvdSB3YW50IHRvIHBlcmZvcm0gc29tZSByZS1vcmRlcmluZyBvcGVyYXRpb24gdGhhdCdzICpub3QqIGEgc29ydCwgeW91IGNhbiBtYW51YWxseVxuICogcmUtbWFwIGVhY2ggY2hpbGQncyBwb3NpdGlvbiB1c2luZyBgbWFuZ2xlTWFwYCBhbmQgYGRlbWFuZ2xlTWFwYCwgd2hpY2ggY29udmVydCBiZXR3ZWVuXG4gKiBzb3J0ZWQgYW5kIHVuc29ydGVkIGluZGV4IHBvc2l0aW9ucy5cbiAqIFxuICogQWdhaW4sIHVubGlrZSBzb21lIG90aGVyIGhvb2tzLCAqKnRoZXNlIGNoaWxkcmVuIG11c3QgYmUgZGlyZWN0IGRlc2NlbmRhbnRzKiouIFRoaXMgaXMgYmVjYXVzZVxuICogdGhlIHByb3AtbW9kaWZ5aW5nIGhvb2sgaW5zcGVjdHMgdGhlIGdpdmVuIGNoaWxkcmVuLCB0aGVuIHJlLWNyZWF0ZXMgdGhlbSB3aXRoIG5ldyBga2V5YHMuXG4gKiBCZWNhdXNlIGtleXMgYXJlIGdpdmVuIHNwZWNpYWwgdHJlYXRtZW50IGFuZCBhIGNoaWxkIGhhcyBubyB3YXkgb2YgbW9kaWZ5aW5nIGl0cyBvd24ga2V5XG4gKiB0aGVyZSdzIG5vIG90aGVyIHRpbWUgb3IgcGxhY2UgdGhpcyBjYW4gaGFwcGVuIG90aGVyIHRoYW4gZXhhY3RseSB3aXRoaW4gdGhlIHBhcmVudCBjb21wb25lbnQncyByZW5kZXIgZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBnZXRJbmRleCB9LCBzb3J0YWJsZUNoaWxkcmVuOiB7IGNvbXBhcmU6IHVzZXJDb21wYXJlIH0gfTogVXNlU29ydGFibGVDaGlsZHJlblBhcmFtZXRlcnM8QywgSz4pOiBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50LCBDLCBLPiB7XG5cbiAgICBjb25zdCBjb21wYXJlID0gKHVzZXJDb21wYXJlID8/IGRlZmF1bHRDb21wYXJlKTtcblxuICAgIGNvbnN0IHsgdXNlUmVhcnJhbmdlYWJsZVByb3BzOiB1c2VTb3J0YWJsZVByb3BzLCAuLi5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlIH0gPSB1c2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW48UGFyZW50RWxlbWVudCwgQywgSz4oeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgZ2V0SW5kZXggfSB9KTtcbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyByZWFycmFuZ2UgfSB9ID0gcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcbiAgICAvLyBUaGUgYWN0dWFsIHNvcnQgZnVuY3Rpb24uXG4gICAgY29uc3Qgc29ydCA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4sIGRpcmVjdGlvbjogXCJhc2NlbmRpbmdcIiB8IFwiZGVzY2VuZGluZ1wiKTogUHJvbWlzZTx2b2lkPiB8IHZvaWQgPT4ge1xuXG4gICAgICAgIGNvbnN0IHNvcnRlZFJvd3MgPSBtYW5hZ2VkUm93cy5hcnJheVNsaWNlKCkuc29ydCgobGhzUm93LCByaHNSb3cpID0+IHtcblxuICAgICAgICAgICAgY29uc3QgbGhzVmFsdWUgPSBsaHNSb3c7XG4gICAgICAgICAgICBjb25zdCByaHNWYWx1ZSA9IHJoc1JvdztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbXBhcmUobGhzVmFsdWUsIHJoc1ZhbHVlKTtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25bMF0gPT0gXCJkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC1yZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZWFycmFuZ2Uoc29ydGVkUm93cyk7XG5cbiAgICB9LCBbIC8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgY29uc3Qgc2h1ZmZsZSA9IHVzZUNhbGxiYWNrKChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pOiBQcm9taXNlPHZvaWQ+IHwgdm9pZCA9PiB7XG4gICAgICAgIGNvbnN0IHNodWZmbGVkUm93cyA9IGxvZGFzaFNodWZmbGUobWFuYWdlZFJvd3MuYXJyYXlTbGljZSgpKVxuICAgICAgICByZXR1cm4gcmVhcnJhbmdlKHNodWZmbGVkUm93cyk7XG4gICAgfSwgWy8qIE11c3QgcmVtYWluIHN0YWJsZSAqL10pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXNlU29ydGFibGVQcm9wcyxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzb3J0LCBzaHVmZmxlIH0sXG4gICAgICAgIHJlYXJyYW5nZWFibGVDaGlsZHJlbjogcmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZS5yZWFycmFuZ2VhYmxlQ2hpbGRyZW5cbiAgICB9O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFVzZVJlYXJyYW5nZWFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IHtcbiAgICByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgYW4gYXJyYXkgb2Ygbm90LXNvcnRlZCBjaGlsZCBpbmZvcm1hdGlvbiB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAqIGFuZCB0aGUgY2hpbGRyZW4gd2lsbCByZS1hcnJhbmdlIHRoZW1zZWx2ZXMgdG8gbWF0Y2guXG4gICAgICAgICAqICBcbiAgICAgICAgICogKipTVEFCTEUqKlxuICAgICAgICAgKiAgXG4gICAgICAgICAqIFxuICAgICAgICAgKi9cbiAgICAgICAgcmVhcnJhbmdlOiAocm93c0luT3JkZXI6IE1hbmFnZWRDaGlsZEluZm88bnVtYmVyLCBDLCBLPltdKSA9PiB2b2lkO1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBpbmRleE1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgaW5kZXhEZW1hbmdsZXI6IChuOiBudW1iZXIpID0+IG51bWJlcjtcbiAgICAgICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICAgICAgbWFuZ2xlTWFwOiBNdXRhYmxlUmVmPE1hcDxudW1iZXIsIG51bWJlcj4+O1xuICAgICAgICAvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBkZW1hbmdsZU1hcDogTXV0YWJsZVJlZjxNYXA8bnVtYmVyLCBudW1iZXI+PjtcbiAgICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZVdpdGhIb29rczxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VSZWFycmFuZ2VhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlSW5mbzxDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VSZWFycmFuZ2VhYmxlUHJvcHM6IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW4/OiBWTm9kZTxhbnk+W10gfCB1bmRlZmluZWQ7IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+O1xuXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlUmVhcnJhbmdlYWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xuICAgIHNvcnRhYmxlQ2hpbGRyZW46IHsvKiogKipTVEFCTEUqKiAqL1xuICAgICAgICBzb3J0OiAobWFuYWdlZFJvd3M6IE1hbmFnZWRDaGlsZHJlbjxudW1iZXIsIEMsIEs+LCBkaXJlY3Rpb246IFwiYXNjZW5kaW5nXCIgfCBcImRlc2NlbmRpbmdcIikgPT4gUHJvbWlzZTx2b2lkPiB8IHZvaWQ7XG4gICAgICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgICAgIHNodWZmbGU6IChtYW5hZ2VkUm93czogTWFuYWdlZENoaWxkcmVuPG51bWJlciwgQywgSz4pID0+IFByb21pc2U8dm9pZD4gfCB2b2lkO1xuICAgIH1cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm88QywgSz4ge1xuICAgIC8qKiAqKlNUQUJMRSoqICovXG4gICAgdXNlU29ydGFibGVQcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbj86IFZOb2RlPGFueT5bXSB8IHVuZGVmaW5lZDsgfSkgPT4gaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD47XG59XG5cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUobGhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQsIHJoczogc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IERhdGUgfCBudWxsIHwgdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUxKGxocywgcmhzKTtcblxuICAgIGZ1bmN0aW9uIGNvbXBhcmUzKGxoczogc3RyaW5nIHwgbnVtYmVyLCByaHM6IHN0cmluZyB8IG51bWJlcikge1xuXG4gICAgICAgIC8vIENvZXJjZSBzdHJpbmdzIHRvIG51bWJlcnMgaWYgdGhleSBzZWVtIHRvIHN0YXkgdGhlIHNhbWUgd2hlbiBzZXJpYWxpemVkXG4gICAgICAgIGlmIChgJHsrbGhzfWAgPT09IGxocylcbiAgICAgICAgICAgIGxocyA9ICtsaHM7XG4gICAgICAgIGlmIChgJHsrcmhzfWAgPT09IHJocylcbiAgICAgICAgICAgIHJocyA9ICtyaHM7XG5cbiAgICAgICAgLy8gQXQgdGhpcyBwb2ludCwgaWYgZWl0aGVyIGFyZ3VtZW50IGlzIGEgc3RyaW5nLCB0dXJuIHRoZSBvdGhlciBvbmUgaW50byBvbmUgdG9vXG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmhzID0gYCR7cmhzfWA7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgbGhzID0gYCR7bGhzfWA7XG5cbiAgICAgICAgY29uc29sZS5hc3NlcnQodHlwZW9mIGxocyA9PT0gdHlwZW9mIHJocyk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBsaHMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gbGhzLmxvY2FsZUNvbXBhcmUocmhzIGFzIHN0cmluZyk7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgcmV0dXJuICtsaHMgLSArcmhzO1xuXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlMihsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlLCByaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbGhzID09PSBcImJvb2xlYW5cIiB8fCBsaHMgaW5zdGFuY2VvZiBEYXRlKVxuICAgICAgICAgICAgbGhzID0gK2xocztcbiAgICAgICAgaWYgKHR5cGVvZiByaHMgPT09IFwiYm9vbGVhblwiIHx8IHJocyBpbnN0YW5jZW9mIERhdGUpXG4gICAgICAgICAgICByaHMgPSArcmhzO1xuICAgICAgICByZXR1cm4gY29tcGFyZTMobGhzLCByaHMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wYXJlMShsaHM6IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBEYXRlIHwgbnVsbCB8IHVuZGVmaW5lZCwgcmhzOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgRGF0ZSB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGxocyA9PSBudWxsICYmIHJocyA9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGV5J3JlIGJvdGggbnVsbFxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGhzID09IG51bGwgfHwgcmhzID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE9uZSBvZiB0aGUgdHdvIGlzIG51bGwgLS0gZWFzeSBjYXNlXG4gICAgICAgICAgICByZXR1cm4gbGhzICE9IG51bGwgPyAxIDogLTFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGFyZTIobGhzLCByaHMpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IGgsIFZOb2RlIH0gZnJvbSBcInByZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VNZXJnZWRQcm9wcyB9IGZyb20gXCIuL3VzZS1tZXJnZWQtcHJvcHNcIjtcbmltcG9ydCB7IENoaWxkRmxhZ09wZXJhdGlvbnMsIE1hbmFnZWRDaGlsZE9taXRzLCBNYW5hZ2VkQ2hpbGRyZW5PbWl0cyB9IGZyb20gXCIuL3VzZS1jaGlsZC1tYW5hZ2VyXCI7XG5pbXBvcnQgeyBVc2VDaGlsZHJlbkhhdmVGb2N1c1BhcmFtZXRlcnMsIFVzZUhhc0ZvY3VzUGFyYW1ldGVycyB9IGZyb20gXCIuL3VzZS1oYXMtZm9jdXNcIjtcbmltcG9ydCB7IExpbmVhck5hdmlnYXRpb25PbWl0cywgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzIH0gZnJvbSBcIi4vdXNlLWtleWJvYXJkLW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIHVzZUxpc3ROYXZpZ2F0aW9uLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVycywgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUmV0dXJuVHlwZVdpdGhIb29rcywgVXNlTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvLCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3MsIFVzZUxpc3ROYXZpZ2F0aW9uU3ViSW5mbyB9IGZyb20gXCIuL3VzZS1saXN0LW5hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZVByZXNzIH0gZnJvbSBcIi4vdXNlLXByZXNzXCI7XG5pbXBvcnQgeyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm8gfSBmcm9tIFwiLi91c2Utcm92aW5nLXRhYmluZGV4XCI7XG5pbXBvcnQgeyBTaW5nbGVTZWxlY3Rpb25DaGlsZE9taXRzLCBTaW5nbGVTZWxlY3Rpb25PbWl0cywgdXNlU2luZ2xlU2VsZWN0aW9uLCBVc2VTaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblBhcmFtZXRlcnMsIFVzZVNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvIH0gZnJvbSBcIi4vdXNlLXNpbmdsZS1zZWxlY3Rpb25cIjtcbmltcG9ydCB7IHVzZVNvcnRhYmxlQ2hpbGRyZW4sIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzLCBVc2VTb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZUluZm8gfSBmcm9tIFwiLi91c2Utc29ydGFibGUtY2hpbGRyZW5cIjtcbmltcG9ydCB7IHVzZVN0YWJsZUNhbGxiYWNrIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1jYWxsYmFja1wiO1xuaW1wb3J0IHsgdXNlU3RhYmxlR2V0dGVyIH0gZnJvbSBcIi4vdXNlLXN0YWJsZS1nZXR0ZXJcIjtcblxuLyoqXG4gKiBUaGVzZSBhcmUgYWxsIHZhcmlhdGlvbnMgb24gdXNlTGlzdE5hdmlnYXRpb24gdGhhdCBhbHNvIGluY29ycG9yYXRlIHNvcnRpbmcsIHNlbGVjdGlvbiwgb3IgYm90aC5cbiAqIFxuICogVGhlcmUgYXJlbid0IGdyaWQtbmF2IHZlcnNpb25zIG9mIHRoZXNlIGJlY2F1c2UsIGdlZXosIGxvb2sgYXQgYWxsIHRoaXMgYm9pbGVycGxhdGUganVzdCBmb3IgbGlzdHMuXG4gKiBMaWtlIDMgc2NyZWVucyB3b3J0aCBvZiBpbnRlcmZhY2UgdHlwZXMgYW5kIDYgc2NyZWVucyBvZiBmdW5jdGlvbnMgdGhhdCBqdXN0IG1vdmUgdmFyaWFibGVzIGFyb3VuZC5cbiAqIFVoLi4ud2hlbiB5b3UgaW5ldml0YWJseSBuZWVkIHRvIGRvIGl0IHlvdXJzZWxmIGltcGxlbWVudCBpdCBoZXJlIGxhdGVyIGxvbCAoQG1lLCBteXNlbGYgaW4gdGhlIGZ1dHVyZSlcbiAqL1xuXG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBTU09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uT21pdHMsIExzT21pdHMgZXh0ZW5kcyBMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnNPbWl0cywgTG5PbWl0cyBleHRlbmRzIExpbmVhck5hdmlnYXRpb25PbWl0cywgVG5PbWl0cyBleHRlbmRzIFR5cGVhaGVhZE5hdmlnYXRpb25PbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleFBhcmFtZXRlcnNPbWl0cywgTWNPbWl0cyBleHRlbmRzIE1hbmFnZWRDaGlsZHJlbk9taXRzPiBleHRlbmRzIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzLCBMbk9taXRzLCBUbk9taXRzLCBSdGlPbWl0cyB8IFwiaW5pdGlhbEluZGV4XCIsIE1jT21pdHM+LCBVc2VTaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgU1NPbWl0cyB8IFwiY2hpbGRyZW5cIiB8IFwic2V0VGFiYmFibGVJbmRleFwiPiB7XG4gICAgY2hpbGRyZW5IYXZlRm9jdXM6IFBhcnRpYWw8VXNlQ2hpbGRyZW5IYXZlRm9jdXNQYXJhbWV0ZXJzW1wiY2hpbGRyZW5IYXZlRm9jdXNcIl0+O1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIExzU3ViSW5mbywgRXh0cmFGbGFnS2V5cyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgTHNTdWJJbmZvLCBFeHRyYUZsYWdLZXlzPiwgVXNlU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88THNTdWJJbmZvPj4sIFwidGFiYmFibGVcIiB8IFwic2VsZWN0ZWRcIiB8IEV4dHJhRmxhZ0tleXM+IHtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG4gICAgLyoqICoqU1RBQkxFKiogKi9cbiAgICBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz5bXCJsaXN0TmF2aWdhdGlvblByb3BzXCJdO1xufVxuXG5cbmV4cG9ydCB0eXBlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgTHNTdWJJbmZvLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIExzU3ViSW5mbywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIExzU3ViSW5mbz4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQYXJhbWV0ZXJzPEUgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nLCBTc09taXRzIGV4dGVuZHMgU2luZ2xlU2VsZWN0aW9uQ2hpbGRPbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cywgU3ViYmVzdEluZm8+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8RSwgQywgSyB8IFwic2VsZWN0ZWRcIiwgTHNPbWl0cywgUnRpT21pdHMsIE1jT21pdHMsIFN1YmJlc3RJbmZvPiB7XG4gICAgaGFzRm9jdXM6IFVzZUhhc0ZvY3VzUGFyYW1ldGVyczxFPjtcbiAgICBzaW5nbGVTZWxlY3Rpb246IFVzZVNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxFLCBDLCBLLCBTc09taXRzPltcInNpbmdsZVNlbGVjdGlvblwiXTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIHNpbmdsZVNlbGVjdGlvbjoge1xuICAgICAgICBzZWxlY3RlZDogYm9vbGVhbjtcbiAgICAgICAgZ2V0U2VsZWN0ZWQoKTogYm9vbGVhbjtcbiAgICB9XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQ+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudD4ge1xuICAgIGxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRQcm9wczogVXNlTGlzdE5hdmlnYXRpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PltcImxpc3ROYXZpZ2F0aW9uQ2hpbGRQcm9wc1wiXTtcbn1cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uQ2hpbGRPbWl0cywgUnRpT21pdHMgZXh0ZW5kcyBSb3ZpbmdUYWJJbmRleENoaWxkT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRPbWl0cz4gPSBVc2VMaXN0TmF2aWdhdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIExzT21pdHMsIFJ0aU9taXRzLCBNY09taXRzLCBDPjtcbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChwOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGRQYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlcj4pID0+IFVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGRSZXR1cm5UeXBlV2l0aEhvb2tzPENoaWxkRWxlbWVudD47XG5cblxuXG5cblxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4gZXh0ZW5kcyBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4sXG4gICAgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEs+IHtcbn1cbmV4cG9ydCB0eXBlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZDxDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPiA9IChhcmdzOiBVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBDPikgPT4gVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFJldHVyblR5cGVXaXRoSG9va3M8Q2hpbGRFbGVtZW50PjtcbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlU29ydGFibGVDaGlsZHJlblJldHVyblR5cGVJbmZvPEMsIEs+LCBVc2VMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xufVxuZXhwb3J0IGludGVyZmFjZSBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxDLCBLIGV4dGVuZHMgc3RyaW5nLCBMc09taXRzIGV4dGVuZHMgTGlzdE5hdmlnYXRpb25QYXJhbWV0ZXJzT21pdHMsIExuT21pdHMgZXh0ZW5kcyBMaW5lYXJOYXZpZ2F0aW9uT21pdHMsIFRuT21pdHMgZXh0ZW5kcyBUeXBlYWhlYWROYXZpZ2F0aW9uT21pdHMsIFJ0aU9taXRzIGV4dGVuZHMgUm92aW5nVGFiSW5kZXhQYXJhbWV0ZXJzT21pdHMsIE1jT21pdHMgZXh0ZW5kcyBNYW5hZ2VkQ2hpbGRyZW5PbWl0cz4gZXh0ZW5kc1xuICAgIFVzZUxpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyczxMc09taXRzIHwgXCJpbmRleE1hbmdsZXJcIiB8IFwiaW5kZXhEZW1hbmdsZXJcIiwgTG5PbWl0cywgVG5PbWl0cywgUnRpT21pdHMsIE1jT21pdHM+LFxuICAgIFVzZVNvcnRhYmxlQ2hpbGRyZW5QYXJhbWV0ZXJzPEMsIEs+IHtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHMgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblJldHVyblR5cGVJbmZvPENoaWxkRWxlbWVudCwgQywgSz4ge1xuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wczogKHByb3BzOiBPbWl0PGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+LCBcImNoaWxkcmVuXCI+ICYgeyBjaGlsZHJlbjogVk5vZGU8YW55PltdOyB9KSA9PiBoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PlxuICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZDogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSz47XG59XG5leHBvcnQgaW50ZXJmYWNlIFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmcsIFNTT21pdHMgZXh0ZW5kcyBTaW5nbGVTZWxlY3Rpb25PbWl0cywgTHNPbWl0cyBleHRlbmRzIExpc3ROYXZpZ2F0aW9uUGFyYW1ldGVyc09taXRzLCBMbk9taXRzIGV4dGVuZHMgTGluZWFyTmF2aWdhdGlvbk9taXRzLCBUbk9taXRzIGV4dGVuZHMgVHlwZWFoZWFkTmF2aWdhdGlvbk9taXRzLCBSdGlPbWl0cyBleHRlbmRzIFJvdmluZ1RhYkluZGV4UGFyYW1ldGVyc09taXRzLCBNY09taXRzIGV4dGVuZHMgTWFuYWdlZENoaWxkcmVuT21pdHM+IGV4dGVuZHMgVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25QYXJhbWV0ZXJzPENoaWxkRWxlbWVudCwgQywgSywgU1NPbWl0cywgTHNPbWl0cyB8IFwiaW5kZXhNYW5nbGVyXCIgfCBcImluZGV4RGVtYW5nbGVyXCIsIExuT21pdHMsIFRuT21pdHMsIFJ0aU9taXRzLCBNY09taXRzPiB7XG5cbn1cbmV4cG9ydCBpbnRlcmZhY2UgVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIENoaWxkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQsIEMsIEsgZXh0ZW5kcyBzdHJpbmc+IGV4dGVuZHNcbiAgICBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUmV0dXJuVHlwZUluZm88Q2hpbGRFbGVtZW50LCBDLCBLPiB7XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiAocHJvcHM6IE9taXQ8aC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4sIFwiY2hpbGRyZW5cIj4gJiB7IGNoaWxkcmVuOiBWTm9kZTxhbnk+W107IH0pID0+IGguSlNYLkhUTUxBdHRyaWJ1dGVzPFBhcmVudEVsZW1lbnQ+XG4gICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPjtcbn1cblxuXG4vKipcbiAqIEl0J3MgdmVyeSBjb21tb24gdG8gY29tYmluZSBhIHRhYmJhYmxlIGxpc3Qgb2YgdGhpbmdzIGFuZCBcInNlbGVjdGlvblwiIG9mIG9uZSBvZiB0aG9zZSB0aGluZ3MuXG4gKiBcbiAqIExpc3RzLCByYWRpbyBidXR0b25zLCB0YWJzLCBldGMuIGV0Yy5cbiAqIFxuICogVGhpcyBpcyBhIHNob3J0Y3V0IHRoYXQgY29tYmluZXMgdGhlIHR3byB3aXRoIHRoZSBjb3JyZWN0IHR5cGluZy5cbiAqIEBwYXJhbSBwYXJhbTAgXG4gKiBAcmV0dXJucyBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uPFBhcmVudE9yQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oe1xuICAgIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZEluZGV4LCBzZWxlY3Rpb25Nb2RlLCBzZXRTZWxlY3RlZEluZGV4IH0sXG4gICAgbGlzdE5hdmlnYXRpb24sXG4gICAgbWFuYWdlZENoaWxkcmVuLFxuICAgIHJvdmluZ1RhYkluZGV4OiB7IC4uLnJvdmluZ1RhYkluZGV4IH0sXG4gICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICB0eXBlYWhlYWROYXZpZ2F0aW9uLFxuICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cbn06IFVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudE9yQ2hpbGRFbGVtZW50LCBDaGlsZEVsZW1lbnQsIEMsIEs+IHtcbiAgICBjb25zdCBwYXJlbnRSZXR1cm5UeXBlID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50T3JDaGlsZEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4oe1xuICAgICAgICBsaXN0TmF2aWdhdGlvbixcbiAgICAgICAgbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDoge1xuICAgICAgICAgICAgaW5pdGlhbEluZGV4OiAoc2VsZWN0ZWRJbmRleCA/PyB1bmRlZmluZWQpLFxuICAgICAgICAgICAgLi4ucm92aW5nVGFiSW5kZXhcbiAgICAgICAgfSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbixcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3QgZ2V0U2VsZWN0aW9uTW9kZSA9IHVzZVN0YWJsZUdldHRlcihzZWxlY3Rpb25Nb2RlKTtcblxuICAgIGNvbnN0IHsgdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQsIC4uLnNpbmdsZVNlbGVjdGlvbkluZm8gfSA9IHVzZVNpbmdsZVNlbGVjdGlvbjxQYXJlbnRPckNoaWxkRWxlbWVudCwgQ2hpbGRFbGVtZW50LCBVc2VSb3ZpbmdUYWJJbmRleFN1YkluZm88Q2hpbGRFbGVtZW50LCBVc2VMaXN0TmF2aWdhdGlvblN1YkluZm88Qz4+LCBcInRhYmJhYmxlXCIgfCBcInNlbGVjdGVkXCIgfCBLPih7XG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjoge1xuICAgICAgICAgICAgY2hpbGRyZW46IHBhcmVudFJldHVyblR5cGUubWFuYWdlZENoaWxkcmVuLmNoaWxkcmVuLFxuICAgICAgICAgICAgc2VsZWN0ZWRJbmRleCxcbiAgICAgICAgICAgIHNlbGVjdGlvbk1vZGUsXG4gICAgICAgICAgICBzZXRTZWxlY3RlZEluZGV4LFxuICAgICAgICAgICAgc2V0VGFiYmFibGVJbmRleDogcGFyZW50UmV0dXJuVHlwZS5yb3ZpbmdUYWJJbmRleC5zZXRUYWJiYWJsZUluZGV4XG4gICAgICAgIH0sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7IG9uQWxsTG9zdEZvY3VzLCBvbkFueUdhaW5lZEZvY3VzIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IHN0YWJsZU9uQ2hhbmdlID0gdXNlU3RhYmxlQ2FsbGJhY2soc2V0U2VsZWN0ZWRJbmRleCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZUxpc3ROYXZpZ2F0aW9uQ2hpbGQsXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIC4uLmxpc3RSZXN0XG4gICAgfSA9IHBhcmVudFJldHVyblR5cGU7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkOiB1c2VDYWxsYmFjazxVc2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkPENoaWxkRWxlbWVudCwgQywgSyB8IFwic2VsZWN0ZWRcIj4+KCh7IG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSwgcm92aW5nVGFiSW5kZXg6IHJ0aSwgbGlzdE5hdmlnYXRpb246IGxzLCBoYXNGb2N1cywgc2luZ2xlU2VsZWN0aW9uOiB7IGZvY3VzU2VsZiwgdW5zZWxlY3RhYmxlLCAuLi5zcyB9LCBzdWJJbmZvIH0pID0+IHtcbiAgICAgICAgICAgIHVuc2VsZWN0YWJsZSB8fD0gKHJ0aS5oaWRkZW4gPz8gZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgeyBzaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzLCBmbGFnczogc3NmbGFncywgLi4uc2luZ2xlU2VsZWN0aW9uSW5mbyB9ID0gdXNlU2luZ2xlU2VsZWN0aW9uQ2hpbGQoe1xuICAgICAgICAgICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCwgZmxhZ3MgfSxcbiAgICAgICAgICAgICAgICBoYXNGb2N1cyxcbiAgICAgICAgICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgLi4uc3MsIGZvY3VzU2VsZiwgdW5zZWxlY3RhYmxlIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgcm92aW5nVGFiSW5kZXg6IHJ0aV9yZXQsXG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb25DaGlsZFByb3BzXG4gICAgICAgICAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25DaGlsZCh7XG4gICAgICAgICAgICAgICAgbWFuYWdlZENoaWxkOiB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmbGFnczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3NmbGFncyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZsYWdzXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgUGFydGlhbDxSZWNvcmQ8SyB8IFwic2VsZWN0ZWRcIiB8IFwidGFiYmFibGVcIiwgQ2hpbGRGbGFnT3BlcmF0aW9ucz4+XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICByb3ZpbmdUYWJJbmRleDogcnRpLFxuICAgICAgICAgICAgICAgIGxpc3ROYXZpZ2F0aW9uOiBscyxcbiAgICAgICAgICAgICAgICBzdWJJbmZvLFxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzOiB1c2VNZXJnZWRQcm9wcyhzaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzLCBsaXN0TmF2aWdhdGlvbkNoaWxkUHJvcHMpLFxuICAgICAgICAgICAgICAgIHJvdmluZ1RhYkluZGV4OiBydGlfcmV0LFxuICAgICAgICAgICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc2luZ2xlU2VsZWN0aW9uSW5mby5zaW5nbGVTZWxlY3Rpb25cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFt1c2VTaW5nbGVTZWxlY3Rpb25DaGlsZF0pLFxuICAgICAgICBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzOiAgbGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdFJlc3QsXG4gICAgICAgIC4uLnNpbmdsZVNlbGVjdGlvbkluZm9cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uPFBhcmVudEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDaGlsZEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50LCBDLCBLIGV4dGVuZHMgc3RyaW5nPih7IGxpbmVhck5hdmlnYXRpb24sIGxpc3ROYXZpZ2F0aW9uLCBtYW5hZ2VkQ2hpbGRyZW4sIHJvdmluZ1RhYkluZGV4LCB0eXBlYWhlYWROYXZpZ2F0aW9uLCByZWFycmFuZ2VhYmxlQ2hpbGRyZW4sIHNvcnRhYmxlQ2hpbGRyZW4gfTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblBhcmFtZXRlcnM8QywgSywgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyPik6IFVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25SZXR1cm5UeXBlV2l0aEhvb2tzPFBhcmVudEVsZW1lbnQsIENoaWxkRWxlbWVudCwgQywgSz4ge1xuXG4gICAgY29uc3Qge1xuICAgICAgICB1c2VTb3J0YWJsZVByb3BzLFxuICAgICAgICAuLi5zb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEs+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuLFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuLFxuICAgIH0pO1xuXG4gICAgY29uc3QgeyByZWFycmFuZ2VhYmxlQ2hpbGRyZW46IHsgaW5kZXhEZW1hbmdsZXIsIGluZGV4TWFuZ2xlciB9IH0gPSBzb3J0YWJsZUNoaWxkcmVuUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgbGlzdE5hdmlnYXRpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleCxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjogdHlwZWFoZWFkTmF2aWdhdGlvbixcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25Qcm9wcyA9IChwcm9wczogaC5KU1guSFRNTEF0dHJpYnV0ZXM8UGFyZW50RWxlbWVudD4pID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZVNvcnRhYmxlUHJvcHModXNlTWVyZ2VkUHJvcHM8UGFyZW50RWxlbWVudD4obGlzdE5hdmlnYXRpb25Qcm9wcywgcHJvcHMpKTtcbiAgICB9XG4gICAgY29uc3QgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvbkNoaWxkOiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uQ2hpbGQ8Q2hpbGRFbGVtZW50LCBDLCBLPiA9IChwKSA9PiB7XG4gICAgICAgIHJldHVybiB1c2VMaXN0TmF2aWdhdGlvbkNoaWxkKHApO1xuICAgIH1cblxuICAgIHJldHVybiAoe1xuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uUHJvcHMsXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25DaGlsZCxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGUsXG4gICAgICAgIC4uLnNvcnRhYmxlQ2hpbGRyZW5SZXR1cm5UeXBlXG4gICAgfSk7XG5cbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbjxQYXJlbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQ2hpbGRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCwgQywgSyBleHRlbmRzIHN0cmluZz4oeyBsaW5lYXJOYXZpZ2F0aW9uLCBsaXN0TmF2aWdhdGlvbiwgbWFuYWdlZENoaWxkcmVuLCByb3ZpbmdUYWJJbmRleCwgc2luZ2xlU2VsZWN0aW9uLCB0eXBlYWhlYWROYXZpZ2F0aW9uLCBjaGlsZHJlbkhhdmVGb2N1cyB9OiBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uUGFyYW1ldGVyczxDaGlsZEVsZW1lbnQsIEMsIEssIG5ldmVyLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgbmV2ZXI+KTogVXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblJldHVyblR5cGVXaXRoSG9va3M8UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPiB7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIHVzZVNvcnRhYmxlUHJvcHMsXG4gICAgICAgIC4uLnNvcnRhYmxlUmV0dXJuVHlwZVxuICAgIH0gPSB1c2VTb3J0YWJsZUNoaWxkcmVuPFBhcmVudEVsZW1lbnQsIEMsIEs+KHtcbiAgICAgICAgcmVhcnJhbmdlYWJsZUNoaWxkcmVuOiB7IGdldEluZGV4OiB1c2VDYWxsYmFjaygocm93KSA9PiByb3cuaW5kZXgsIFtdKSB9LFxuICAgICAgICBzb3J0YWJsZUNoaWxkcmVuOiB7XG4gICAgICAgICAgICBjb21wYXJlOiB1c2VDYWxsYmFjaygobGhzLCByaHMpID0+IHsgcmV0dXJuIGxocy5pbmRleCAtIHJocy5pbmRleDsgfSwgW10pLFxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBjb25zdCB7IHJlYXJyYW5nZWFibGVDaGlsZHJlbjogeyBpbmRleERlbWFuZ2xlciwgaW5kZXhNYW5nbGVyIH0gfSA9IHNvcnRhYmxlUmV0dXJuVHlwZTtcblxuICAgIGNvbnN0IHtcbiAgICAgICAgdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgbGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcbiAgICAgICAgLi4ubGlzdE5hdlJldHVyblR5cGVcbiAgICB9ID0gdXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248UGFyZW50RWxlbWVudCwgQ2hpbGRFbGVtZW50LCBDLCBLPih7XG4gICAgICAgIGxpbmVhck5hdmlnYXRpb246IGxpbmVhck5hdmlnYXRpb24sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7IGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIC4uLmxpc3ROYXZpZ2F0aW9uIH0sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogbWFuYWdlZENoaWxkcmVuLFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogcm92aW5nVGFiSW5kZXgsXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHR5cGVhaGVhZE5hdmlnYXRpb24sXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogc2luZ2xlU2VsZWN0aW9uLFxuICAgICAgICBjaGlsZHJlbkhhdmVGb2N1czogY2hpbGRyZW5IYXZlRm9jdXNcbiAgICB9KTtcblxuICAgIGNvbnN0IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyA9IChwcm9wczogT21pdDxoLkpTWC5IVE1MQXR0cmlidXRlczxQYXJlbnRFbGVtZW50PiwgXCJjaGlsZHJlblwiPiAmIHsgY2hpbGRyZW46IFZOb2RlPGFueT5bXTsgfSkgPT4ge1xuICAgICAgICByZXR1cm4gdXNlU29ydGFibGVQcm9wcyh1c2VNZXJnZWRQcm9wcyhsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLCBwcm9wcykpO1xuICAgIH1cbiAgICBjb25zdCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgPSAocDogVXNlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFBhcmFtZXRlcnM8Q2hpbGRFbGVtZW50LCBDLCBLLCBuZXZlciwgbmV2ZXIsIG5ldmVyLCBuZXZlciwgQz4pID0+IHtcbiAgICAgICAgcmV0dXJuIHVzZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQocCk7XG4gICAgfVxuXG4gICAgcmV0dXJuICh7XG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZCxcbiAgICAgICAgdXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzLFxuICAgICAgICAvL3NvcnRhYmxlOiB7IHNvcnQsIHNodWZmbGUsIHJlYXJyYW5nZSwgZGVtYW5nbGVNYXAsIGluZGV4RGVtYW5nbGVyLCBpbmRleE1hbmdsZXIsIG1hbmdsZU1hcCB9LFxuICAgICAgICAuLi5zb3J0YWJsZVJldHVyblR5cGUsXG4gICAgICAgIC4uLmxpc3ROYXZSZXR1cm5UeXBlXG4gICAgfSk7XG5cbn1cblxuIiwiaW1wb3J0IHsgaCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcInByZWFjdC9ob29rc1wiO1xuaW1wb3J0IHsgdXNlSW50ZXJ2YWwgfSBmcm9tIFwiLi4vLi5cIjtcblxuXG5leHBvcnQgY29uc3QgRGVtb1VzZUludGVydmFsID0gKCkgPT4ge1xuICAgIGNvbnN0IFtpbnRlcnZhbCwgc2V0SW50ZXJ2YWxdID0gdXNlU3RhdGUoMTAwMCk7XG5cbiAgICBjb25zdCBbZmlyZUNvdW50LCBzZXRGaXJlQ291bnRdID0gdXNlU3RhdGUoMCk7XG5cbiAgICB1c2VJbnRlcnZhbCh7IGludGVydmFsLCBjYWxsYmFjazogKCkgPT4gc2V0RmlyZUNvdW50KGkgPT4gKytpKSB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+SW50ZXJ2YWwgZHVyYXRpb246IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e2ludGVydmFsfSBvbklucHV0PXtlID0+IHNldEludGVydmFsKGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGRpdj5UaGUgY2FsbGJhY2sgaGFzIGJlZW4gY2FsbGVkIHtmaXJlQ291bnR9IHRpbWV7ZmlyZUNvdW50ID09PSAxID8gXCJcIiA6IFwic1wifS48L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgKVxufVxuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gXCJwcmVhY3RcIjtcbmltcG9ydCB7IG1lbW8sIHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0IH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZU1lcmdlZFByb3BzLCB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uLCBVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQgfSBmcm9tIFwiLi4vLi4vaW5kZXhcIjtcbmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSBcIi4uLy4uL3VzZS1zdGF0ZVwiO1xuXG5cbmNvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xuXG5mdW5jdGlvbiBnZXREb2N1bWVudCgpIHtcbiAgICByZXR1cm4gd2luZG93LmRvY3VtZW50O1xufVxuXG5cbmNvbnN0IExpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQ8SFRNTExJRWxlbWVudCwge30sIHN0cmluZz4+KG51bGwhKVxuZXhwb3J0IGNvbnN0IERlbW9Vc2VSb3ZpbmdUYWJJbmRleCA9IG1lbW8oKCkgPT4ge1xuXG4gICAgY29uc3QgW3NlbGVjdGlvbk1vZGUsIHNldFNlbGVjdGlvbk1vZGVdID0gdXNlU3RhdGUoXCJhY3RpdmF0aW9uXCIgYXMgXCJmb2N1c1wiIHwgXCJhY3RpdmF0aW9uXCIpO1xuICAgIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoMTApO1xuICAgIGNvbnN0IFtzZWxlY3RlZEluZGV4LCBzZXRTZWxlY3RlZEluZGV4XSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFt0YWJiYWJsZUluZGV4LCBzZXRMb2NhbFRhYmJhYmxlSW5kZXhdID0gdXNlU3RhdGUoMCk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjogeyBjaGlsZHJlbiB9LFxuICAgICAgICB1c2VTb3J0YWJsZUxpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGQsXG4gICAgICAgIHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25Qcm9wcyxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgc2V0VGFiYmFibGVJbmRleCB9LFxuICAgICAgICB0eXBlYWhlYWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRUeXBlYWhlYWQgfSxcbiAgICAgICAgc29ydGFibGVDaGlsZHJlbjogeyBzaHVmZmxlIH0sXG4gICAgfSA9IHVzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb248SFRNTFVMaXN0RWxlbWVudCwgSFRNTExJRWxlbWVudCwge30sIHN0cmluZz4oe1xuICAgICAgICBsaW5lYXJOYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHt9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGRyZW46IHt9LFxuICAgICAgICByb3ZpbmdUYWJJbmRleDogeyBvblRhYmJhYmxlSW5kZXhDaGFuZ2U6IHVzZUNhbGxiYWNrKChpbmRleDogbnVtYmVyIHwgbnVsbCkgPT4geyBpZiAoaW5kZXggIT0gbnVsbCkgc2V0TG9jYWxUYWJiYWJsZUluZGV4KGluZGV4KTsgfSwgW10pIH0sXG4gICAgICAgIHR5cGVhaGVhZE5hdmlnYXRpb246IHt9LFxuICAgICAgICBzaW5nbGVTZWxlY3Rpb246IHsgc2VsZWN0ZWRJbmRleCwgc2VsZWN0aW9uTW9kZSwgc2V0U2VsZWN0ZWRJbmRleDogKGksIF9lKSA9PiBzZXRTZWxlY3RlZEluZGV4KGkpIH0sXG4gICAgICAgIGNoaWxkcmVuSGF2ZUZvY3VzOiB7ICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImRlbW9cIj5cbiAgICAgICAgICAgIDxoMj5LZXlib2FyZCAmYW1wOyBMaXN0IE5hdmlnYXRpb248L2gyPlxuICAgICAgICAgICAgPGgzPjxjb2RlPnVzZVJvdmluZ1RhYkluZGV4PC9jb2RlPjwvaDM+XG5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIE5hdGl2ZSBIVE1MIGVsZW1lbnRzIG9mZmVyIGZhbnRhc3RpYyBrZXlib2FyZCBhY2Nlc3NhYmlsaXR5LCBidXQgY292ZXIgYSByZWxhdGl2ZWx5IGxpbWl0ZWQgbnVtYmVyIG9mIHVzZSBjYXNlcy5cbiAgICAgICAgICAgICAgICBUaGVyZSBpcyBubyBuYXRpdmUgSFRNTCB0cmVlIGVsZW1lbnQsIGZvciBleGFtcGxlLCB0aGF0IGFsbG93cyBrZXlib2FyZCBuYXZpZ2F0aW9uIG9mIGl0cyBpdGVtcyxcbiAgICAgICAgICAgICAgICBub3IgaXMgaXQgcG9zc2libGUgdG8gY29tYmluZSB0aGUga2V5Ym9hcmQgbmF2aWdhdGlvbiBiZWhhdmlvciBvZiBhIDxjb2RlPntcIjxzZWxlY3Q+XCJ9PC9jb2RlPiBtZW51IHdpdGggdGhlIG1lbnUgaW4gYSBkcmF3ZXIgY29tcG9uZW50LjwvcD5cblxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgV2hlbiBjb21pbmcgYWNyb3NzIGEgTGlzdCBvciBhIE1lbnUgb3IgYSBSYWRpb0dyb3VwIG9yIGEgVG9nZ2xlQnV0dG9uR3JvdXAgb3IgYW55IG90aGVyIFwib25lIGNvbXBvbmVudCBtYWRlIHVwIG9mIGNoaWxkIGNvbXBvbmVudHNcIiwgdGhlIHVzdWFsIGV4cGVjdGVkIGJlaGF2aW9yLFxuICAgICAgICAgICAgICAgIGF0IGxlYXN0IG5hdGl2ZWx5LCBpcyB0aGF0IHRhYmJpbmcgaW50byB0aGUgY29tcG9uZW50IGlzIG9uZSBhY3Rpb24sIGFuZCB0YWJiaW5nIG91dCBpcyBhbm90aGVyLiAgTmF2aWdhdGluZyA8ZW0+d2l0aGluPC9lbT4gdGhlIGNvbXBvbmVudCBpcyBkb25lIHdpdGggdGhlIGFycm93IGtleXMgb3Igb3RoZXIgbWV0aG9kcy5cbiAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIFRoaXMgaXMgaW1wb3J0YW50IGJvdGggZm9yIGFjY2Vzc2FiaWxpdHksIGJ1dCBhbHNvIGp1c3QgZm9yIGdlbmVyYWwgdXNhYmlsaXR5LiAgV2hlbiB0YWJiaW5nIGJhY2sgYW5kIGZvcnRoLCB0aGUgYWJpbGl0eSB0byBza2lwIGEgbG9uZyBsaXN0IHdpdGhvdXQgbmVlZGluZyB0byB0cnVkZ2UgdGhyb3VnaCA8ZW0+ZXZlcnkgb25lPC9lbT4gb2YgaXRzIGNoaWxkIGVsZW1lbnRzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQuXG4gICAgICAgICAgICA8L3A+XG5cbiAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgIDxjb2RlPnVzZUxpc3ROYXZpZ2F0aW9uPC9jb2RlPiB3cmFwcyB1cCB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhIGZldyBob29rcyAoPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+LCA8Y29kZT51c2VMaW5lYXJOYXZpZ2F0aW9uPC9jb2RlPiwgPGNvZGU+dXNlVHlwZWFoZWFkTmF2aWdhdGlvbjwvY29kZT4pXG4gICAgICAgICAgICAgICAgdG8gYWxsb3cgZm9yIEFSSUEtY29tcGxpYW50IG5hdmlnYXRpb24gb2YgbGlzdHMgYW5kIG90aGVyIHNpbWlsYXIgY29tcG9uZW50cy4gIEZvciBtb3JlIGFkdmFuY2VkIHVzZSBjYXNlcywgeW91IGNhbiB1c2UgdGhlIG90aGVyIGhvb2tzIGluZGl2aWR1YWxseS5cbiAgICAgICAgICAgIDwvcD5cblxuICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb248L2NvZGU+IChhbmQgPGNvZGU+dXNlUm92aW5nVGFiSW5kZXg8L2NvZGU+KSBpbnRlcm5hbGx5IHVzZSA8Y29kZT51c2VDaGlsZE1hbmFnZXI8L2NvZGU+LCB3aGljaCBpcyBob3cgdGhlIGNoaWxkIGVsZW1lbnRzIGFuZCB0aGUgcGFyZW50IGNvbW11bmljYXRlIHdpdGggZWFjaCBvdGhlci5cbiAgICAgICAgICAgICAgICBUaGlzIG1lYW5zIHRoZXJlIGFyZSB2aXJ0dWFsbHkgbm8gcmVzdHJpY3Rpb25zIG9uIGhvdyB0aGUgRE9NIGlzIHNldCB1cCBhcyBsb25nIGFzIHlvdSBjYW4gcHJvdmlkZSB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgPGNvZGU+dXNlTGlzdE5hdmlnYXRpb25DaGlsZDwvY29kZT4gaG9vayB0aGF0J3MgcmV0dXJuZWQsIHVzdWFsbHkgd2l0aCBhIHNpbXBsZSA8Y29kZT5Db250ZXh0PC9jb2RlPi5cbiAgICAgICAgICAgICAgICBJZiB0aGUgY2hpbGQgZWxlbWVudCBpdHNlbGYgaGFzIGEgZm9jdXNhYmxlIGVsZW1lbnQsIGxpa2UgYSBidXR0b24sIGl0IGNhbiBhbHNvIGJlIHdpcmVkIHVwIHRvIGRpc2FibGUgaXRzZWxmXG4gICAgICAgICAgICAgICAgRmVlbCBmcmVlIHRvIG5lc3QgdGhlbSB0b28sIGFzIGxvbmcgYXMgeW91IGFyZSBhd2FyZSBvZiB5b3VyIDxjb2RlPkNvbnRleHQ8L2NvZGU+IG1hbmFnZW1lbnQgKGkuZS4gcmVtZW1iZXIgdGhhdCB5b3UgbmVlZCB0byBjcmVhdGUgYSBuZXcgPGNvZGU+Q29udGV4dDwvY29kZT4gZm9yIGVhY2ggdXNlIGNhc2UpLlxuICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgPGxhYmVsPiMgb2YgaXRlbXM8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtjb3VudH0gbWluPXswfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRDb3VudChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcikgfX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXsoKSA9PiBzaHVmZmxlKGNoaWxkcmVuKX0+U2h1ZmZsZTwvYnV0dG9uPlxuICAgICAgICAgICAgPGxhYmVsPlRhYmJhYmxlIGluZGV4OiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXt0YWJiYWJsZUluZGV4ID8/IHVuZGVmaW5lZH0gb25JbnB1dD17ZSA9PiB7IGUucHJldmVudERlZmF1bHQoKTsgc2V0VGFiYmFibGVJbmRleChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlciwgZmFsc2UpOyB9fSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+U2VsZWN0ZWQgaW5kZXg6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3NlbGVjdGVkSW5kZXggPz8gdW5kZWZpbmVkfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3RlZEluZGV4KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKTsgfX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPlNlbGVjdGlvbiBtb2RlOlxuICAgICAgICAgICAgICAgIDxsYWJlbD48aW5wdXQgbmFtZT1cInJ0aS1kZW1vLXNlbGVjdGlvbi1tb2RlXCIgdHlwZT1cInJhZGlvXCIgY2hlY2tlZD17c2VsZWN0aW9uTW9kZSA9PSAnZm9jdXMnfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3Rpb25Nb2RlKFwiZm9jdXNcIik7IH19IC8+IE9uIGZvY3VzPC9sYWJlbD5cbiAgICAgICAgICAgICAgICA8bGFiZWw+PGlucHV0IG5hbWU9XCJydGktZGVtby1zZWxlY3Rpb24tbW9kZVwiIHR5cGU9XCJyYWRpb1wiIGNoZWNrZWQ9e3NlbGVjdGlvbk1vZGUgPT0gJ2FjdGl2YXRpb24nfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRTZWxlY3Rpb25Nb2RlKFwiYWN0aXZhdGlvblwiKTsgfX0gLz4gT24gYWN0aXZhdGlvbiAoY2xpY2ssIHRhcCwgRW50ZXIsIFNwYWNlLCBldGMuKTwvbGFiZWw+XG4gICAgICAgICAgICA8L2xhYmVsPlxuXG4gICAgICAgICAgICA8TGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZVNvcnRhYmxlTGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZH0+XG4gICAgICAgICAgICAgICAgPHVsIHsuLi4odXNlU29ydGFibGVMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvblByb3BzKHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IEFycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZVJvdmluZ1RhYkluZGV4Q2hpbGQgaW5kZXg9e2l9IGtleT17aX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKSlcbiAgICAgICAgICAgICAgICB9KSl9PjwvdWw+XG4gICAgICAgICAgICA8L0xpc3ROYXZpZ2F0aW9uU2luZ2xlU2VsZWN0aW9uQ2hpbGRDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgICAge2N1cnJlbnRUeXBlYWhlYWQgJiYgPGRpdj5UeXBlYWhlYWQ6IHtjdXJyZW50VHlwZWFoZWFkfTwvZGl2Pn1cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0pXG5cbmNvbnN0IF9QcmVmaXggPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5jb25zdCBEZW1vVXNlUm92aW5nVGFiSW5kZXhDaGlsZCA9IG1lbW8oKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XG4gICAgY29uc3QgaGlkZGVuID0gKGluZGV4ID09IDcpO1xuICAgIGNvbnN0IFtyYW5kb21Xb3JkXSA9IHVzZVN0YXRlKCgpID0+IFJhbmRvbVdvcmRzW2luZGV4LypNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoUmFuZG9tV29yZHMubGVuZ3RoIC0gMSkpKi9dKTtcbiAgICBjb25zdCB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkID0gdXNlQ29udGV4dChMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkQ29udGV4dCk7XG4gICAgY29uc3QgdGV4dCA9IGAke3JhbmRvbVdvcmR9IFRoaXMgaXMgaXRlbSAjJHtpbmRleH0ke2hpZGRlbiA/IFwiIChoaWRkZW4pXCIgOiBcIlwifWA7XG4gICAgY29uc3QgZm9jdXNTZWxmID0gdXNlQ2FsbGJhY2soKGU6IEhUTUxFbGVtZW50KSA9PiB7IGUuZm9jdXMoKSB9LCBbXSk7XG4gICAgY29uc3QgeyBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMsIHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlIH0sIHNpbmdsZVNlbGVjdGlvbjogeyBzZWxlY3RlZCB9IH0gPSB1c2VMaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkKHsgXG4gICAgICAgIG1hbmFnZWRDaGlsZDogeyBpbmRleCB9LCBcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dCB9LCBcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuLCBmb2N1c1NlbGYgfSwgXG4gICAgICAgIHN1YkluZm86IHt9LCBcbiAgICAgICAgaGFzRm9jdXM6IHsgZ2V0RG9jdW1lbnQgfSAsXG4gICAgICAgIHNpbmdsZVNlbGVjdGlvbjogeyBhcmlhUHJvcE5hbWU6IFwiYXJpYS1zZWxlY3RlZFwiLCB1bnNlbGVjdGFibGU6IGhpZGRlbiwgZm9jdXNTZWxmOiBlID0+IGUuZm9jdXMoKSB9XG4gICAgfSk7IFxuXG4gICAgY29uc3QgcHJvcHMgPSBsaXN0TmF2aWdhdGlvblNpbmdsZVNlbGVjdGlvbkNoaWxkUHJvcHMgYXMgYW55O1xuICAgIHJldHVybiAoXG4gICAgICAgIDxsaSB7Li4ucHJvcHN9Pnt0ZXh0fSAoe3RhYmJhYmxlID8gXCJUYWJiYWJsZVwiIDogXCJOb3QgdGFiYmFibGVcIn0sIHtzZWxlY3RlZCA/IFwiU2VsZWN0ZWRcIiA6IFwiTm90IHNlbGVjdGVkXCJ9KTxpbnB1dCB7Li4udXNlTWVyZ2VkUHJvcHMobGlzdE5hdmlnYXRpb25TaW5nbGVTZWxlY3Rpb25DaGlsZFByb3BzLCB7IHR5cGU6IFwibnVtYmVyXCIgfSkgYXMgYW55fSBzdHlsZT17eyB3aWR0aDogXCI1Y2hcIiB9fSAvPjwvbGk+XG4gICAgKVxufSkpOyIsImltcG9ydCB7IGggfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gXCJwcmVhY3QvaG9va3NcIjtcbmltcG9ydCB7IHVzZVRpbWVvdXQgfSBmcm9tIFwiLi4vLi5cIjtcblxuXG5leHBvcnQgY29uc3QgRGVtb1VzZVRpbWVvdXQgPSAoKSA9PiB7XG4gICAgY29uc3QgW3RpbWVvdXQsIHNldFRpbWVvdXRdID0gdXNlU3RhdGUoMTAwMCk7XG4gICAgY29uc3QgW3RyaWdnZXJJbmRleCwgc2V0VHJpZ2dlckluZGV4XSA9IHVzZVN0YXRlKFwiXCIpO1xuXG4gICAgY29uc3QgW2ZpcmVDb3VudCwgc2V0RmlyZUNvdW50XSA9IHVzZVN0YXRlKDApO1xuXG4gICAgdXNlVGltZW91dCh7IHRpbWVvdXQsIHRyaWdnZXJJbmRleCwgY2FsbGJhY2s6ICgpID0+IHNldEZpcmVDb3VudChpID0+ICsraSkgfSlcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+VGltZW91dCBkdXJhdGlvbjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGltZW91dH0gb25JbnB1dD17ZSA9PiBzZXRUaW1lb3V0KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPlJlZnJlc2gga2V5OiA8aW5wdXQgdHlwZT1cInRleHRcIiB2YWx1ZT17dHJpZ2dlckluZGV4fSBvbklucHV0PXtlID0+IHNldFRyaWdnZXJJbmRleChlLmN1cnJlbnRUYXJnZXQudmFsdWUpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2PlRoZSBjYWxsYmFjayBoYXMgYmVlbiBjYWxsZWQge2ZpcmVDb3VudH0gdGltZXtmaXJlQ291bnQgPT09IDEgPyBcIlwiIDogXCJzXCJ9LjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0LCBoLCByZW5kZXIgfSBmcm9tIFwicHJlYWN0XCI7XG5pbXBvcnQgeyBtZW1vIH0gZnJvbSBcInByZWFjdC9jb21wYXRcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VDb250ZXh0LCB1c2VSZWYgfSBmcm9tIFwicHJlYWN0L2hvb2tzXCI7XG5pbXBvcnQgeyB1c2VBbmltYXRpb25GcmFtZSwgdXNlQXN5bmNIYW5kbGVyLCB1c2VEcmFnZ2FibGUsIHVzZURyb3BwYWJsZSwgdXNlRWxlbWVudFNpemUsIHVzZUZvY3VzVHJhcCwgdXNlTWVyZ2VkUHJvcHMsIHVzZVN0YXRlIH0gZnJvbSBcIi4uXCI7XG5pbXBvcnQgeyBFbGVtZW50U2l6ZSB9IGZyb20gXCIuLi91c2UtZWxlbWVudC1zaXplXCI7XG5pbXBvcnQgeyB1c2VHcmlkTmF2aWdhdGlvbiwgVXNlR3JpZE5hdmlnYXRpb25DZWxsLCBVc2VHcmlkTmF2aWdhdGlvblJvdyB9IGZyb20gXCIuLi91c2UtZ3JpZC1uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VIYXNGb2N1cyB9IGZyb20gXCIuLi91c2UtaGFzLWZvY3VzXCI7XG5pbXBvcnQgeyBEZW1vVXNlSW50ZXJ2YWwgfSBmcm9tIFwiLi9kZW1vcy91c2UtaW50ZXJ2YWxcIjtcbmltcG9ydCB7IERlbW9Vc2VSb3ZpbmdUYWJJbmRleCB9IGZyb20gXCIuL2RlbW9zL3VzZS1yb3ZpbmctdGFiLWluZGV4XCI7XG5pbXBvcnQgeyBEZW1vVXNlVGltZW91dCB9IGZyb20gXCIuL2RlbW9zL3VzZS10aW1lb3V0XCI7XG5cbmNvbnN0IFJhbmRvbVdvcmRzID0gXCJMb3JlbSBpcHN1bSBkb2xvciBzaXQgYW1ldCwgY29uc2VjdGV0dXIgYWRpcGlzY2luZyBlbGl0LCBzZWQgZG8gZWl1c21vZCB0ZW1wb3IgaW5jaWRpZHVudCB1dCBsYWJvcmUgZXQgZG9sb3JlIG1hZ25hIGFsaXF1YS4gVXQgZW5pbSBhZCBtaW5pbSB2ZW5pYW0sIHF1aXMgbm9zdHJ1ZCBleGVyY2l0YXRpb24gdWxsYW1jbyBsYWJvcmlzIG5pc2kgdXQgYWxpcXVpcCBleCBlYSBjb21tb2RvIGNvbnNlcXVhdC4gRHVpcyBhdXRlIGlydXJlIGRvbG9yIGluIHJlcHJlaGVuZGVyaXQgaW4gdm9sdXB0YXRlIHZlbGl0IGVzc2UgY2lsbHVtIGRvbG9yZSBldSBmdWdpYXQgbnVsbGEgcGFyaWF0dXIuIEV4Y2VwdGV1ciBzaW50IG9jY2FlY2F0IGN1cGlkYXRhdCBub24gcHJvaWRlbnQsIHN1bnQgaW4gY3VscGEgcXVpIG9mZmljaWEgZGVzZXJ1bnQgbW9sbGl0IGFuaW0gaWQgZXN0IGxhYm9ydW0uXCIuc3BsaXQoXCIgXCIpO1xuXG5cblxuY29uc3QgRGVtb1VzZURyb3BwYWJsZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IGRyb3BwZWRGaWxlcywgZHJvcHBlZFN0cmluZ3MsIGZpbGVzRm9yQ29uc2lkZXJhdGlvbiwgc3RyaW5nc0ZvckNvbnNpZGVyYXRpb24sIHVzZURyb3BwYWJsZVByb3BzLCBkcm9wRXJyb3IgfSA9IHVzZURyb3BwYWJsZTxIVE1MRGl2RWxlbWVudD4oeyBlZmZlY3Q6IFwiY29weVwiIH0pO1xuXG4gICAgY29uc3QgeyByZWY6IF9yZWYgfSA9IHVzZU1lcmdlZFByb3BzPEhUTUxJbnB1dEVsZW1lbnQ+KHt9LCB7IHJlZjogdXNlUmVmPEhUTUxJbnB1dEVsZW1lbnQ+KG51bGwhKSB9KVxuXG4gICAgY29uc3QgcCA9IHVzZURyb3BwYWJsZVByb3BzKHsgY2xhc3NOYW1lOiBcImRlbW8gZHJvcHBhYmxlXCIgfSk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IHsuLi5wfT5cblxuICAgICAgICAgICAge2Ryb3BwZWRTdHJpbmdzICE9IG51bGwgJiYgPGRpdj5EYXRhIGRyb3BwZWQ6IDx1bD57KE9iamVjdC5lbnRyaWVzKGRyb3BwZWRTdHJpbmdzKSBhcyBba2V5b2YgdHlwZW9mIHN0cmluZ3NGb3JDb25zaWRlcmF0aW9uLCBzdHJpbmddW10pLm1hcCgoW3R5cGUsIHZhbHVlXSkgPT4gPGxpPnt0eXBlfToge3ZhbHVlfTwvbGk+KX08L3VsPjwvZGl2Pn1cbiAgICAgICAgICAgIHtkcm9wcGVkRmlsZXMgIT0gbnVsbCAmJiA8ZGl2PkZpbGVzIGRyb3BwZWQ6IDx0YWJsZT5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+PHRyPjx0aD5OYW1lPC90aD48dGg+U2l6ZTwvdGg+PHRoPlR5cGU8L3RoPjx0aD5MYXN0IG1vZGlmaWVkPC90aD48L3RyPjwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5Pntkcm9wcGVkRmlsZXMubWFwKGYgPT4gPHRyPjx0ZD57Zi5uYW1lfTwvdGQ+e2YuZGF0YS5ieXRlTGVuZ3RofTx0ZD57Zi50eXBlfTwvdGQ+PHRkPntuZXcgRGF0ZShmLmxhc3RNb2RpZmllZCA/PyAwKX08L3RkPjwvdHI+KX08L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT48L2Rpdj59XG4gICAgICAgICAgICA8aHIgLz5cblxuICAgICAgICAgICAge3N0cmluZ3NGb3JDb25zaWRlcmF0aW9uICE9IG51bGwgJiYgPGRpdj5EYXRhIGJlaW5nIGNvbnNpZGVyZWQ6IDx1bD57QXJyYXkuZnJvbShzdHJpbmdzRm9yQ29uc2lkZXJhdGlvbikubWFwKHR5cGUgPT4gPGxpPnt0eXBlfTwvbGk+KX08L3VsPjwvZGl2Pn1cbiAgICAgICAgICAgIHtmaWxlc0ZvckNvbnNpZGVyYXRpb24gIT0gbnVsbCAmJiA8ZGl2PkZpbGVzIGJlaW5nIGNvbnNpZGVyZWQ6IDx1bD57ZmlsZXNGb3JDb25zaWRlcmF0aW9uLm1hcChmID0+IDxsaT57SlNPTi5zdHJpbmdpZnkoZil9PC9saT4pfTwvdWw+PC9kaXY+fVxuXG4gICAgICAgICAgICA8aHIgLz5cbiAgICAgICAgICAgIHtkcm9wRXJyb3IgJiYgPGRpdj57ZHJvcEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBkcm9wRXJyb3IubWVzc2FnZSA6IEpTT04uc3RyaW5naWZ5KGRyb3BFcnJvcil9PC9kaXY+fVxuICAgICAgICA8L2Rpdj5cbiAgICApXG59XG5cbmNvbnN0IERlbW9Vc2VEcmFnZ2FibGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyB1c2VEcmFnZ2FibGVQcm9wcyB9ID0gdXNlRHJhZ2dhYmxlPEhUTUxEaXZFbGVtZW50Pih7IGRhdGE6IHsgXCJ0ZXh0L3BsYWluXCI6IFwiVGhpcyBpcyBjdXN0b20gZHJhZ2dhYmxlIGNvbnRlbnQgb2YgdHlwZSB0ZXh0L3BsYWluLlwiIH0gfSk7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgey4uLnVzZURyYWdnYWJsZVByb3BzKHsgY2xhc3NOYW1lOiBcImRlbW9cIiB9KX0+XG4gICAgICAgICAgICBEcmFnZ2FibGUgY29udGVudFxuICAgICAgICA8L2Rpdj4pXG59XG5cbmNvbnN0IERlbW9Vc2VFbGVtZW50U2l6ZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICBjb25zdCBbaGVpZ2h0LCBzZXRIZWlnaHRdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW2FuZ2xlLCBzZXRBbmdsZV0gPSB1c2VTdGF0ZSgwKTtcbiAgICB1c2VBbmltYXRpb25GcmFtZSh7XG4gICAgICAgIGNhbGxiYWNrOiAoX21zKSA9PiB7XG4gICAgICAgICAgICBzZXRBbmdsZShhID0+IGEgKyAwLjAxKVxuICAgICAgICAgICAgc2V0SGVpZ2h0KChNYXRoLnNpbihhbmdsZSkgKyAxKSAvIDAuNSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNvbnN0IFtlbGVtZW50U2l6ZSwgc2V0RWxlbWVudFNpemVdID0gdXNlU3RhdGU8RWxlbWVudFNpemUgfCBudWxsPihudWxsKTtcblxuICAgIGNvbnN0IHsgdXNlRWxlbWVudFNpemVQcm9wcyB9ID0gdXNlRWxlbWVudFNpemU8SFRNTERpdkVsZW1lbnQ+KHsgb25TaXplQ2hhbmdlOiBzZXRFbGVtZW50U2l6ZSB9KTtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgey4uLnVzZU1lcmdlZFByb3BzKHVzZUVsZW1lbnRTaXplUHJvcHMsIHsgcmVmOiB1bmRlZmluZWQsIGNsYXNzTmFtZTogXCJkZW1vXCIsIHN0eWxlOiB7IGhlaWdodDogYCR7KGhlaWdodCAqIDEwMCkgKyAxMDB9cHhgIH0gfSl9PlxuICAgICAgICAgICAgPHByZT57SlNPTi5zdHJpbmdpZnkoZWxlbWVudFNpemUsIG51bGwsIDIpfTwvcHJlPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufVxuXG5cbmNvbnN0IERlbW9Vc2VGb2N1c1RyYXAgPSBtZW1vKCh7IGRlcHRoIH06IHsgZGVwdGg/OiBudW1iZXIgfSkgPT4ge1xuXG4gICAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IHVzZVN0YXRlKGZhbHNlKTtcblxuICAgIGNvbnN0IHsgdXNlRm9jdXNUcmFwUHJvcHMgfSA9IHVzZUZvY3VzVHJhcDxIVE1MRGl2RWxlbWVudD4oeyB0cmFwQWN0aXZlOiBhY3RpdmUgfSk7XG4gICAgLy9jb25zdCB7IHVzZVJvdmluZ1RhYkluZGV4Q2hpbGQsIHVzZVJvdmluZ1RhYkluZGV4UHJvcHMgfSA9IHVzZVJvdmluZ1RhYkluZGV4PEhUTUxVTGlzdEVsZW1lbnQsIFJvdmluZ1RhYkluZGV4Q2hpbGRJbmZvPih7IHRhYmJhYmxlSW5kZXgsIGZvY3VzT25DaGFuZ2U6IGZhbHNlIH0pO1xuXG4gICAgY29uc3QgZGl2UHJvcHMgPSB1c2VGb2N1c1RyYXBQcm9wcyh7IHJlZjogdW5kZWZpbmVkLCBjbGFzc05hbWU6IFwiZm9jdXMtdHJhcC1kZW1vXCIgfSk7XG4gICAgaWYgKGRlcHRoID09IDIpXG4gICAgICAgIHJldHVybiA8ZGl2IC8+O1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJkZW1vXCI+XG4gICAgICAgICAgICA8bGFiZWw+QWN0aXZlOiA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17YWN0aXZlfSBvbklucHV0PXtlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyBzZXRBY3RpdmUoZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpOyB9fSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8ZGl2IHsuLi5kaXZQcm9wc30gPlxuICAgICAgICAgICAgICAgIDxEZW1vVXNlRm9jdXNUcmFwQ2hpbGQgYWN0aXZlPXthY3RpdmV9IHNldEFjdGl2ZT17c2V0QWN0aXZlfSBkZXB0aD17ZGVwdGggPz8gMH0gLz5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG5cblxuY29uc3QgRGVtb1VzZUZvY3VzVHJhcENoaWxkID0gbWVtbygoeyBzZXRBY3RpdmUsIGFjdGl2ZSB9OiB7IGFjdGl2ZTogYm9vbGVhbiwgc2V0QWN0aXZlOiAoYWN0aXZlOiBib29sZWFuKSA9PiB2b2lkLCBkZXB0aDogbnVtYmVyIH0pID0+IHtcblxuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPD5cbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDE8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDI8L2J1dHRvbj5cbiAgICAgICAgICAgIDxidXR0b24+QnV0dG9uIDM8L2J1dHRvbj5cbiAgICAgICAgICAgIDxsYWJlbD5BY3RpdmU6IDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXthY3RpdmV9IG9uSW5wdXQ9e2UgPT4geyBlLnByZXZlbnREZWZhdWx0KCk7IHNldEFjdGl2ZShlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCk7IH19IC8+PC9sYWJlbD5cblxuICAgICAgICA8Lz5cbiAgICApO1xufSk7XG5cbmNvbnN0IERlbW9Vc2VBc3luY0hhbmRsZXIxID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbZGVib3VuY2UsIHNldERlYm91bmNlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtzaG91bGRUaHJvdywgc2V0U2hvdWxkVGhyb3csIGdldFNob3VsZFRocm93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgYXN5bmNPbkNsaWNrID0gKChfdjogdm9pZCwgX2U6IGguSlNYLlRhcmdldGVkTW91c2VFdmVudDxIVE1MQnV0dG9uRWxlbWVudD4pID0+IG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpID0+IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IGdldFNob3VsZFRocm93KCkgPyByZWplY3QoKSA6IHJlc29sdmUoKSwgdGltZW91dCkpKTtcbiAgICBjb25zdCB7XG4gICAgICAgIGNhbGxDb3VudCxcbiAgICAgICAgc2V0dGxlQ291bnQsXG4gICAgICAgIGhhc0NhcHR1cmUsXG4gICAgICAgIHN5bmNIYW5kbGVyLFxuICAgICAgICBwZW5kaW5nLFxuICAgICAgICBoYXNFcnJvcixcbiAgICAgICAgcmVqZWN0Q291bnQsXG4gICAgICAgIHJlc29sdmVDb3VudFxuICAgIH0gPSB1c2VBc3luY0hhbmRsZXI8aC5KU1guVGFyZ2V0ZWRNb3VzZUV2ZW50PEhUTUxCdXR0b25FbGVtZW50Piwgdm9pZD4oeyBhc3luY0hhbmRsZXI6IGFzeW5jT25DbGljaywgY2FwdHVyZTogKCkgPT4geyB9LCBkZWJvdW5jZTogZGVib3VuY2UgPT0gMCA/IHVuZGVmaW5lZCA6IGRlYm91bmNlIH0pO1xuXG4gICAgY29uc3Qgb25DbGljayA9IHBlbmRpbmcgPyB1bmRlZmluZWQgOiBzeW5jSGFuZGxlcjtcblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGJ1dHRvbiBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uQ2xpY2s9e29uQ2xpY2t9PkNsaWNrIG1lITwvYnV0dG9uPlxuICAgICAgICAgICAgPGxhYmVsPlNsZWVwIGZvcjogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17dGltZW91dH0gb25JbnB1dD17ZSA9PiBzZXRUaW1lb3V0KGUuY3VycmVudFRhcmdldC52YWx1ZUFzTnVtYmVyKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPlRocm93IGFuIGVycm9yIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtzaG91bGRUaHJvd30gb25JbnB1dD17ZSA9PiBzZXRTaG91bGRUaHJvdyhlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5EaXNhYmxlZCB3aGlsZSBwZW5kaW5nIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjaGVja2VkPXtkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e2UgPT4gc2V0RGlzYWJsZUNvbnNlY3V0aXZlKGUuY3VycmVudFRhcmdldC5jaGVja2VkKX0gLz48L2xhYmVsPlxuICAgICAgICAgICAgPGxhYmVsPkRlYm91bmNlOiA8aW5wdXQgdHlwZT1cIm51bWJlclwiIHZhbHVlPXtkZWJvdW5jZX0gb25JbnB1dD17ZSA9PiBzZXREZWJvdW5jZShlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgICAgICA8dGhlYWQ+XG4gICAgICAgICAgICAgICAgICAgIDx0cj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aD5GaWVsZDwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+VmFsdWU8L3RoPlxuICAgICAgICAgICAgICAgICAgICA8L3RyPlxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XG4gICAgICAgICAgICAgICAgPHRib2R5PlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmNhbGxDb3VudDwvdGQ+PHRkPntjYWxsQ291bnR9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPnNldHRsZUNvdW50PC90ZD48dGQ+e3NldHRsZUNvdW50fTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZXNvbHZlQ291bnQ8L3RkPjx0ZD57cmVzb2x2ZUNvdW50fTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5yZWplY3RDb3VudDwvdGQ+PHRkPntyZWplY3RDb3VudH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzRXJyb3I8L3RkPjx0ZD57aGFzRXJyb3IudG9TdHJpbmcoKX08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+aGFzQ2FwdHVyZTwvdGQ+PHRkPntoYXNDYXB0dXJlLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XG4gICAgICAgICAgICA8L3RhYmxlPlxuICAgICAgICA8L2Rpdj5cbiAgICApO1xufSk7XG5cbmNvbnN0IERlbW9Vc2VBc3luY0hhbmRsZXIyID0gbWVtbygoKSA9PiB7XG5cbiAgICBjb25zdCBbdGltZW91dCwgc2V0VGltZW91dF0gPSB1c2VTdGF0ZSgxMDAwKTtcbiAgICBjb25zdCBbZGVib3VuY2UsIHNldERlYm91bmNlXSA9IHVzZVN0YXRlKDApO1xuICAgIGNvbnN0IFtzaG91bGRUaHJvdywgc2V0U2hvdWxkVGhyb3csIGdldFNob3VsZFRocm93XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbZGlzYWJsZUNvbnNlY3V0aXZlLCBzZXREaXNhYmxlQ29uc2VjdXRpdmVdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gICAgY29uc3QgW3RleHQsIHNldFRleHRdID0gdXNlU3RhdGUoXCJcIik7XG5cbiAgICBjb25zdCBvbklucHV0QXN5bmMgPSBhc3luYyAodjogc3RyaW5nLCBfZTogYW55KSA9PiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChnZXRTaG91bGRUaHJvdygpKSB7XG4gICAgICAgICAgICByZWplY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldFRleHQodik7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICB9LCB0aW1lb3V0KSk7XG5cbiAgICBjb25zdCB7XG4gICAgICAgIGNhbGxDb3VudCxcbiAgICAgICAgc2V0dGxlQ291bnQsXG4gICAgICAgIGhhc0NhcHR1cmUsXG4gICAgICAgIHN5bmNIYW5kbGVyLFxuICAgICAgICBjdXJyZW50Q2FwdHVyZSxcbiAgICAgICAgcGVuZGluZyxcbiAgICAgICAgaGFzRXJyb3IsXG4gICAgICAgIHJlamVjdENvdW50LFxuICAgICAgICByZXNvbHZlQ291bnRcbiAgICB9ID0gdXNlQXN5bmNIYW5kbGVyPGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4sIHN0cmluZz4oeyBhc3luY0hhbmRsZXI6IG9uSW5wdXRBc3luYywgY2FwdHVyZTogKGU6IGguSlNYLlRhcmdldGVkRXZlbnQ8SFRNTElucHV0RWxlbWVudD4pID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpOyByZXR1cm4gZS5jdXJyZW50VGFyZ2V0LnZhbHVlIH0sIGRlYm91bmNlOiBkZWJvdW5jZSA9PSAwID8gdW5kZWZpbmVkIDogZGVib3VuY2UgfSk7XG5cblxuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZGVtb1wiPlxuICAgICAgICAgICAgPGxhYmVsPkRlbW8gdGV4dDogPGlucHV0IHZhbHVlPXtoYXNDYXB0dXJlID8gY3VycmVudENhcHR1cmUgOiB0ZXh0fSBkaXNhYmxlZD17cGVuZGluZyAmJiBkaXNhYmxlQ29uc2VjdXRpdmV9IG9uSW5wdXQ9e3N5bmNIYW5kbGVyfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8aHIgLz5cbiAgICAgICAgICAgIDxsYWJlbD5TbGVlcCBmb3I6IDxpbnB1dCB0eXBlPVwibnVtYmVyXCIgdmFsdWU9e3RpbWVvdXR9IG9uSW5wdXQ9e2UgPT4gc2V0VGltZW91dChlLmN1cnJlbnRUYXJnZXQudmFsdWVBc051bWJlcil9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5UaHJvdyBhbiBlcnJvciA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17c2hvdWxkVGhyb3d9IG9uSW5wdXQ9e2UgPT4gc2V0U2hvdWxkVGhyb3coZS5jdXJyZW50VGFyZ2V0LmNoZWNrZWQpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8bGFiZWw+RGlzYWJsZWQgd2hpbGUgcGVuZGluZyA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgY2hlY2tlZD17ZGlzYWJsZUNvbnNlY3V0aXZlfSBvbklucHV0PXtlID0+IHNldERpc2FibGVDb25zZWN1dGl2ZShlLmN1cnJlbnRUYXJnZXQuY2hlY2tlZCl9IC8+PC9sYWJlbD5cbiAgICAgICAgICAgIDxsYWJlbD5EZWJvdW5jZTogPGlucHV0IHR5cGU9XCJudW1iZXJcIiB2YWx1ZT17ZGVib3VuY2V9IG9uSW5wdXQ9e2UgPT4gc2V0RGVib3VuY2UoZS5jdXJyZW50VGFyZ2V0LnZhbHVlQXNOdW1iZXIpfSAvPjwvbGFiZWw+XG4gICAgICAgICAgICA8dGFibGU+XG4gICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+RmllbGQ8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPlZhbHVlPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keT5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5jYWxsQ291bnQ8L3RkPjx0ZD57Y2FsbENvdW50fTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5zZXR0bGVDb3VudDwvdGQ+PHRkPntzZXR0bGVDb3VudH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVzb2x2ZUNvdW50PC90ZD48dGQ+e3Jlc29sdmVDb3VudH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgICAgIDx0cj48dGQ+cmVqZWN0Q291bnQ8L3RkPjx0ZD57cmVqZWN0Q291bnR9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmhhc0Vycm9yPC90ZD48dGQ+e2hhc0Vycm9yLnRvU3RyaW5nKCl9PC90ZD48L3RyPlxuICAgICAgICAgICAgICAgICAgICA8dHI+PHRkPmN1cnJlbnRDYXB0dXJlPC90ZD48dGQ+e2N1cnJlbnRDYXB0dXJlfTwvdGQ+PC90cj5cbiAgICAgICAgICAgICAgICAgICAgPHRyPjx0ZD5cIlNhdmVkXCIgaW5wdXQ8L3RkPjx0ZD57dGV4dH08L3RkPjwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG4gICAgICAgIDwvZGl2PlxuICAgICk7XG59KTtcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5kb2N1bWVudDtcbn1cblxuY29uc3QgRGVtb0ZvY3VzID0gbWVtbygoKSA9PiB7XG4gICAgY29uc3QgW2xhc3RBY3RpdmVFbGVtZW50LCBzZXRMYXN0QWN0aXZlRWxlbWVudF0gPSB1c2VTdGF0ZTwoRWxlbWVudCkgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbYWN0aXZlRWxlbWVudCwgc2V0QWN0aXZlRWxlbWVudF0gPSB1c2VTdGF0ZTwoRWxlbWVudCkgfCBudWxsPihudWxsKTtcbiAgICBjb25zdCBbd2luZG93Rm9jdXNlZCwgc2V0V2luZG93Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2ZvY3VzZWQsIHNldEZvY3VzZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtmb2N1c2VkSW5uZXIsIHNldEZvY3VzZWRJbm5lcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2xhc3RGb2N1c2VkLCBzZXRMYXN0Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW2xhc3RGb2N1c2VkSW5uZXIsIHNldExhc3RGb2N1c2VkSW5uZXJdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHsgaGFzRm9jdXNQcm9wcyB9ID0gdXNlSGFzRm9jdXM8SFRNTERpdkVsZW1lbnQ+KHtcbiAgICAgICAgZ2V0RG9jdW1lbnQsXG4gICAgICAgIG9uRm9jdXNlZENoYW5nZWQ6IHNldEZvY3VzZWQsXG4gICAgICAgIG9uRm9jdXNlZElubmVyQ2hhbmdlZDogc2V0Rm9jdXNlZElubmVyLFxuICAgICAgICBvbkxhc3RGb2N1c2VkQ2hhbmdlZDogc2V0TGFzdEZvY3VzZWQsXG4gICAgICAgIG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldExhc3RGb2N1c2VkSW5uZXIsXG4gICAgICAgIG9uQWN0aXZlRWxlbWVudENoYW5nZTogc2V0QWN0aXZlRWxlbWVudCxcbiAgICAgICAgb25MYXN0QWN0aXZlRWxlbWVudENoYW5nZTogc2V0TGFzdEFjdGl2ZUVsZW1lbnQsXG4gICAgICAgIG9uV2luZG93Rm9jdXNlZENoYW5nZTogc2V0V2luZG93Rm9jdXNlZFxuICAgIH0pO1xuICAgIHJldHVybiAoXG4gICAgICAgIDxkaXYgY2xhc3M9XCJkZW1vXCI+XG4gICAgICAgICAgICA8aDI+dXNlSGFzRm9jdXM8L2gyPlxuICAgICAgICAgICAgPGRpdiB7Li4udXNlTWVyZ2VkUHJvcHMoaGFzRm9jdXNQcm9wcywgeyBzdHlsZTogeyBib3JkZXI6IFwiMXB4IHNvbGlkIGJsYWNrXCIgfSwgdGFiSW5kZXg6IDAgfSl9Pk91dGVyIDxkaXYgdGFiSW5kZXg9ezB9IHN0eWxlPXt7IGJvcmRlcjogXCIxcHggc29saWQgYmxhY2tcIiB9fT5Jbm5lciBlbGVtZW50PC9kaXY+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2PlxuICAgICAgICAgICAgICAgIDx1bD5cbiAgICAgICAgICAgICAgICAgICAgPGxpPlN0cmljdGx5IGZvY3VzZWQ6IHtmb2N1c2VkLnRvU3RyaW5nKCl9LCB7bGFzdEZvY3VzZWQudG9TdHJpbmcoKX08L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+SW5uZXIgZm9jdXNlZDoge2ZvY3VzZWRJbm5lci50b1N0cmluZygpfSwge2xhc3RGb2N1c2VkSW5uZXIudG9TdHJpbmcoKX08L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+V2luZG93IGZvY3VzZWQ6IHt3aW5kb3dGb2N1c2VkLnRvU3RyaW5nKCl9PC9saT5cbiAgICAgICAgICAgICAgICAgICAgPGxpPmFjdGl2ZUVsZW1lbnQ6IHthY3RpdmVFbGVtZW50Py50ZXh0Q29udGVudH08L2xpPlxuICAgICAgICAgICAgICAgICAgICA8bGk+bGFzdEFjdGl2ZUVsZW1lbnQ6IHtsYXN0QWN0aXZlRWxlbWVudD8udGV4dENvbnRlbnR9PC9saT5cbiAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgIClcbn0pXG5cblxuY29uc3QgR3JpZFJvd0NvbnRleHQgPSBjcmVhdGVDb250ZXh0PFVzZUdyaWROYXZpZ2F0aW9uUm93PEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwge30sIHN0cmluZywgc3RyaW5nPj4obnVsbCEpO1xuY29uc3QgR3JpZENlbGxDb250ZXh0ID0gY3JlYXRlQ29udGV4dDxVc2VHcmlkTmF2aWdhdGlvbkNlbGw8SFRNTFRhYmxlQ2VsbEVsZW1lbnQsIHt9LCBzdHJpbmc+PihudWxsISk7XG5leHBvcnQgY29uc3QgRGVtb1VzZUdyaWQgPSBtZW1vKCgpID0+IHtcblxuICAgIGNvbnN0IFssIHNldExhc3RGb2N1c2VkSW5uZXIsIF9nZXRMYXN0Rm9jdXNlZElubmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB7IGhhc0ZvY3VzUHJvcHMgfSA9IHVzZUhhc0ZvY3VzPEhUTUxUYWJsZVNlY3Rpb25FbGVtZW50Pih7IG9uTGFzdEZvY3VzZWRJbm5lckNoYW5nZWQ6IHNldExhc3RGb2N1c2VkSW5uZXIsIGdldERvY3VtZW50IH0pO1xuICAgIGNvbnN0IHsgdXNlR3JpZE5hdmlnYXRpb25Sb3csIGdyaWROYXZpZ2F0aW9uUHJvcHMsIGdyaWROYXZpZ2F0aW9uOiB7IGN1cnJlbnRDb2x1bW4gfSB9ID0gdXNlR3JpZE5hdmlnYXRpb248SFRNTFRhYmxlU2VjdGlvbkVsZW1lbnQsIEhUTUxUYWJsZVJvd0VsZW1lbnQsIEhUTUxUYWJsZUNlbGxFbGVtZW50LCB7fSwge30sIHN0cmluZywgc3RyaW5nPih7XG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7fSxcbiAgICAgICAgbGluZWFyTmF2aWdhdGlvbjoge30sXG4gICAgICAgIGxpc3ROYXZpZ2F0aW9uOiB7fSxcbiAgICAgICAgdHlwZWFoZWFkTmF2aWdhdGlvbjoge30sXG4gICAgICAgIG1hbmFnZWRDaGlsZHJlbjoge30sXG4gICAgICAgIGdyaWROYXZpZ2F0aW9uOiB7fVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIChcbiAgICAgICAgPGRpdiBjbGFzcz1cImRlbW9cIj5cbiAgICAgICAgICAgIHs8ZGl2PkN1cnJlbnQgY29sdW1uOiB7Y3VycmVudENvbHVtbn08L2Rpdj59XG4gICAgICAgICAgICA8dGFibGUgey4uLnsgYm9yZGVyOiBcIjJcIiB9IGFzIHt9fSBzdHlsZT17eyB3aGl0ZVNwYWNlOiBcIm5vd3JhcFwiIH19PlxuXG4gICAgICAgICAgICAgICAgPHRoZWFkPlxuICAgICAgICAgICAgICAgICAgICA8dHI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Um93IGlzIHRhYmJhYmxlPzwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGg+Q29sdW1uIDE8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoPkNvbHVtbiAyPC90aD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cbiAgICAgICAgICAgICAgICA8L3RoZWFkPlxuICAgICAgICAgICAgICAgIDx0Ym9keSB7Li4udXNlTWVyZ2VkUHJvcHMoaGFzRm9jdXNQcm9wcywgZ3JpZE5hdmlnYXRpb25Qcm9wcyl9PlxuICAgICAgICAgICAgICAgICAgICA8R3JpZFJvd0NvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUdyaWROYXZpZ2F0aW9uUm93fT5cbiAgICAgICAgICAgICAgICAgICAgICAgIHtBcnJheS5mcm9tKChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZUdyaWRSb3cgaW5kZXg9e2l9IGtleT17aX0gLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSgpKX1cbiAgICAgICAgICAgICAgICAgICAgPC9HcmlkUm93Q29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgICAgICAgICA8L3Rib2R5PlxuICAgICAgICAgICAgPC90YWJsZT5cbiAgICAgICAgPC9kaXY+XG4gICAgKTtcbn0pXG5cbmNvbnN0IF9QcmVmaXggPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaXCI7XG5jb25zdCBEZW1vVXNlR3JpZFJvdyA9IG1lbW8oKCh7IGluZGV4IH06IHsgaW5kZXg6IG51bWJlciB9KSA9PiB7XG4gICAgY29uc3QgW19yYW5kb21Xb3JkXSA9IHVzZVN0YXRlKCgpID0+IFJhbmRvbVdvcmRzW2luZGV4LypNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAoUmFuZG9tV29yZHMubGVuZ3RoIC0gMSkpKi9dKTtcbiAgICBjb25zdCB1c2VHcmlkUm93ID0gdXNlQ29udGV4dChHcmlkUm93Q29udGV4dCk7XG4gICAgY29uc3Qge1xuICAgICAgICBncmlkTmF2aWdhdGlvblJvd1Byb3BzLFxuICAgICAgICB1c2VHcmlkTmF2aWdhdGlvbkNlbGwsXG4gICAgICAgIGFzQ2hpbGRSb3c6IHsgcm92aW5nVGFiSW5kZXg6IHsgdGFiYmFibGUgfSB9LFxuICAgIH0gPSB1c2VHcmlkUm93KHtcbiAgICAgICAgYXNDaGlsZFJvd09mU2VjdGlvbjogeyBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSwgbGlzdE5hdmlnYXRpb246IHsgdGV4dDogXCJcIiB9LCByb3ZpbmdUYWJJbmRleDogeyBoaWRkZW46IGluZGV4ID09IDMgfSwgc3ViSW5mbzoge30gfSxcbiAgICAgICAgYXNQYXJlbnRSb3dPZkNlbGxzOiB7IGxpbmVhck5hdmlnYXRpb246IHt9LCBsaXN0TmF2aWdhdGlvbjoge30sIHJvdmluZ1RhYkluZGV4OiB7fSwgdHlwZWFoZWFkTmF2aWdhdGlvbjoge30sIG1hbmFnZWRDaGlsZHJlbjoge30gfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHByb3BzID0gZ3JpZE5hdmlnYXRpb25Sb3dQcm9wcztcbiAgICByZXR1cm4gKFxuICAgICAgICA8dHIgey4uLnByb3BzfT5cbiAgICAgICAgICAgIDxHcmlkQ2VsbENvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3VzZUdyaWROYXZpZ2F0aW9uQ2VsbH0+XG4gICAgICAgICAgICAgICAge0FycmF5LmZyb20oKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMzsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCA8RGVtb1VzZUdyaWRDZWxsIGluZGV4PXtpfSBrZXk9e2l9IHJvdz17aW5kZXh9IHJvd0lzVGFiYmFibGU9e3RhYmJhYmxlfSAvPlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkoKSl9XG4gICAgICAgICAgICA8L0dyaWRDZWxsQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC90cj5cbiAgICApXG59KSk7XG5cbmNvbnN0IERlbW9Vc2VHcmlkQ2VsbCA9ICgoeyBpbmRleCwgcm93LCByb3dJc1RhYmJhYmxlIH06IHsgaW5kZXg6IG51bWJlciwgcm93OiBudW1iZXIsIHJvd0lzVGFiYmFibGU6IGJvb2xlYW4gfSkgPT4ge1xuICAgIGlmIChyb3cgPj0gNiAmJiByb3cgJSAyID09IDAgJiYgaW5kZXggPiAxKVxuICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgIGxldCBoaWRkZW5UZXh0ID0gKHJvdyA9PT0gMykgPyBcIiAocm93IGhpZGRlbilcIiA6IFwiXCJcblxuICAgIGNvbnN0IHVzZUdyaWRDZWxsID0gdXNlQ29udGV4dChHcmlkQ2VsbENvbnRleHQpO1xuICAgIGNvbnN0IHtcbiAgICAgICAgZ3JpZE5hdmlnYXRpb25DZWxsUHJvcHMsXG4gICAgICAgIHJvdmluZ1RhYkluZGV4OiB7IHRhYmJhYmxlOiBjZWxsSXNUYWJiYWJsZSB9XG4gICAgfSA9IHVzZUdyaWRDZWxsKHtcbiAgICAgICAgbGlzdE5hdmlnYXRpb246IHsgdGV4dDogXCJcIiB9LFxuICAgICAgICBtYW5hZ2VkQ2hpbGQ6IHsgaW5kZXggfSxcbiAgICAgICAgcm92aW5nVGFiSW5kZXg6IHsgaGlkZGVuOiBmYWxzZSwgZm9jdXNTZWxmOiB1c2VDYWxsYmFjayhlID0+IGUuZm9jdXMoKSwgW10pIH0sXG4gICAgICAgIGhhc0ZvY3VzOiB7IGdldERvY3VtZW50IH0sXG4gICAgICAgIHN1YkluZm86IHt9LFxuICAgIH0pO1xuXG4gICAgY29uc3QgcHJvcHMgPSBncmlkTmF2aWdhdGlvbkNlbGxQcm9wcyBhcyBhbnk7XG5cbiAgICBjb25zdCB0ID0gKGNlbGxJc1RhYmJhYmxlID8gXCIoVGFiYmFibGUpXCIgOiBcIihOb3QgdGFiYmFibGUpXCIpXG5cbiAgICBpZiAoaW5kZXggPT09IDApXG4gICAgICAgIHJldHVybiA8dGQgey4uLnByb3BzfT57cm93SXNUYWJiYWJsZS50b1N0cmluZygpfTwvdGQ+XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChyb3cgPCA2IHx8IHJvdyAlIDIgIT0gMCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiA8dGQgey4uLnByb3BzfT5HcmlkIGNlbGwgI3tpbmRleCArIDF9IHt0fXtoaWRkZW5UZXh0fTwvdGQ+XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIDx0ZD48bGFiZWw+PGlucHV0ICB7Li4ucHJvcHN9IHR5cGU9XCJjaGVja2JveFwiIC8+IFRlc3QgaW5wdXQge3R9e2hpZGRlblRleHR9PC9sYWJlbD48L3RkPlxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAxKVxuICAgICAgICAgICAgICAgIHJldHVybiA8dGQgey4uLnByb3BzfSBjb2xTcGFuPXsyfT5HcmlkIGNlbGwgI3tpbmRleCArIDF9LCBzcGFuIDIge3R9e2hpZGRlblRleHR9PC90ZD5cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICB9XG4gICAgfVxufSlcblxuY29uc3QgQ29tcG9uZW50ID0gKCkgPT4ge1xuICAgIHJldHVybiA8ZGl2IGNsYXNzPVwiZmxleFwiIHN0eWxlPXt7IGZsZXhXcmFwOiBcIndyYXBcIiB9fT5cbiAgICAgICAgPERlbW9Gb2N1cyAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPERlbW9Vc2VHcmlkIC8+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8RGVtb1VzZVRpbWVvdXQgLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxEZW1vVXNlSW50ZXJ2YWwgLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxEZW1vVXNlUm92aW5nVGFiSW5kZXggLz5cbiAgICAgICAgPGhyIC8+XG5cblxuICAgICAgICA8RGVtb1VzZUZvY3VzVHJhcCAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPERlbW9Vc2VBc3luY0hhbmRsZXIxIC8+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8RGVtb1VzZUFzeW5jSGFuZGxlcjIgLz5cbiAgICAgICAgPGhyIC8+XG4gICAgICAgIDxEZW1vVXNlRHJvcHBhYmxlIC8+XG4gICAgICAgIDxociAvPlxuICAgICAgICA8RGVtb1VzZURyYWdnYWJsZSAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPERlbW9Vc2VFbGVtZW50U2l6ZUFuaW1hdGlvbiAvPlxuICAgICAgICA8aHIgLz5cbiAgICAgICAgPGlucHV0IC8+XG4gICAgPC9kaXY+XG59XG5cbnJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgcmVuZGVyKDxDb21wb25lbnQgLz4sIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicm9vdFwiKSEpO1xufSlcbiJdLCJuYW1lcyI6WyJzbGljZSIsIm9wdGlvbnMiLCJ2bm9kZUlkIiwicmVyZW5kZXJRdWV1ZSIsInByZXZEZWJvdW5jZSIsImkiLCJFTVBUWV9PQkoiLCJFTVBUWV9BUlIiLCJJU19OT05fRElNRU5TSU9OQUwiLCJhc3NpZ24iLCJvYmoiLCJwcm9wcyIsInJlbW92ZU5vZGUiLCJub2RlIiwicGFyZW50Tm9kZSIsInJlbW92ZUNoaWxkIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJjaGlsZHJlbiIsImtleSIsInJlZiIsIm5vcm1hbGl6ZWRQcm9wcyIsImFyZ3VtZW50cyIsImxlbmd0aCIsImNhbGwiLCJkZWZhdWx0UHJvcHMiLCJ1bmRlZmluZWQiLCJjcmVhdGVWTm9kZSIsIm9yaWdpbmFsIiwidm5vZGUiLCJfX2siLCJfXyIsIl9fYiIsIl9fZSIsIl9fZCIsIl9fYyIsIl9faCIsImNvbnN0cnVjdG9yIiwiX192IiwiRnJhZ21lbnQiLCJDb21wb25lbnQiLCJjb250ZXh0IiwidGhpcyIsImdldERvbVNpYmxpbmciLCJjaGlsZEluZGV4IiwiaW5kZXhPZiIsInNpYmxpbmciLCJ1cGRhdGVQYXJlbnREb21Qb2ludGVycyIsImNoaWxkIiwiYmFzZSIsImVucXVldWVSZW5kZXIiLCJjIiwicHVzaCIsInByb2Nlc3MiLCJkZWJvdW5jZVJlbmRlcmluZyIsInNldFRpbWVvdXQiLCJxdWV1ZSIsIl9fciIsInNvcnQiLCJhIiwiYiIsInNvbWUiLCJjb21wb25lbnQiLCJjb21taXRRdWV1ZSIsIm9sZFZOb2RlIiwib2xkRG9tIiwicGFyZW50RG9tIiwiX19QIiwiZGlmZiIsIm93bmVyU1ZHRWxlbWVudCIsImNvbW1pdFJvb3QiLCJkaWZmQ2hpbGRyZW4iLCJyZW5kZXJSZXN1bHQiLCJuZXdQYXJlbnRWTm9kZSIsIm9sZFBhcmVudFZOb2RlIiwiZ2xvYmFsQ29udGV4dCIsImlzU3ZnIiwiZXhjZXNzRG9tQ2hpbGRyZW4iLCJpc0h5ZHJhdGluZyIsImoiLCJjaGlsZFZOb2RlIiwibmV3RG9tIiwiZmlyc3RDaGlsZERvbSIsInJlZnMiLCJvbGRDaGlsZHJlbiIsIm9sZENoaWxkcmVuTGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwicmVvcmRlckNoaWxkcmVuIiwicGxhY2VDaGlsZCIsInVubW91bnQiLCJhcHBseVJlZiIsInRtcCIsInRvQ2hpbGRBcnJheSIsIm91dCIsIm5leHREb20iLCJzaWJEb20iLCJvdXRlciIsImFwcGVuZENoaWxkIiwibmV4dFNpYmxpbmciLCJpbnNlcnRCZWZvcmUiLCJkaWZmUHJvcHMiLCJkb20iLCJuZXdQcm9wcyIsIm9sZFByb3BzIiwiaHlkcmF0ZSIsInNldFByb3BlcnR5Iiwic2V0U3R5bGUiLCJzdHlsZSIsInZhbHVlIiwidGVzdCIsIm5hbWUiLCJvbGRWYWx1ZSIsInVzZUNhcHR1cmUiLCJvIiwiY3NzVGV4dCIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsImwiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnRQcm94eUNhcHR1cmUiLCJldmVudFByb3h5IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJldmVudCIsIm5ld1ZOb2RlIiwiaXNOZXciLCJvbGRTdGF0ZSIsInNuYXBzaG90IiwiY2xlYXJQcm9jZXNzaW5nRXhjZXB0aW9uIiwicHJvdmlkZXIiLCJjb21wb25lbnRDb250ZXh0IiwicmVuZGVySG9vayIsImNvdW50IiwibmV3VHlwZSIsImNvbnRleHRUeXBlIiwiX19FIiwicHJvdG90eXBlIiwicmVuZGVyIiwiZG9SZW5kZXIiLCJzdWIiLCJzdGF0ZSIsIl9fbiIsIl9zYiIsIl9fcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImZvckVhY2giLCJjb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0Q2hpbGRDb250ZXh0IiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJkaWZmRWxlbWVudE5vZGVzIiwiZGlmZmVkIiwicm9vdCIsImNiIiwib2xkSHRtbCIsIm5ld0h0bWwiLCJub2RlVHlwZSIsImxvY2FsTmFtZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJjcmVhdGVFbGVtZW50TlMiLCJpcyIsImRhdGEiLCJjaGlsZE5vZGVzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJhdHRyaWJ1dGVzIiwiX19odG1sIiwiaW5uZXJIVE1MIiwiY2hlY2tlZCIsImN1cnJlbnQiLCJwYXJlbnRWTm9kZSIsInNraXBSZW1vdmUiLCJyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJyZXBsYWNlTm9kZSIsImZpcnN0Q2hpbGQiLCJjcmVhdGVDb250ZXh0IiwiZGVmYXVsdFZhbHVlIiwiY29udGV4dElkIiwiQ29uc3VtZXIiLCJjb250ZXh0VmFsdWUiLCJQcm92aWRlciIsInN1YnMiLCJjdHgiLCJfcHJvcHMiLCJvbGQiLCJzcGxpY2UiLCJlcnJvciIsImVycm9ySW5mbyIsImN0b3IiLCJoYW5kbGVkIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwic2V0U3RhdGUiLCJjb21wb25lbnREaWRDYXRjaCIsImlzVmFsaWRFbGVtZW50IiwidXBkYXRlIiwiY2FsbGJhY2siLCJzIiwiZm9yY2VVcGRhdGUiLCJfX3NlbGYiLCJfX3NvdXJjZSIsImN1cnJlbnRJbmRleCIsImN1cnJlbnRDb21wb25lbnQiLCJwcmV2aW91c0NvbXBvbmVudCIsInByZXZSYWYiLCJjdXJyZW50SG9vayIsImFmdGVyUGFpbnRFZmZlY3RzIiwiRU1QVFkiLCJvbGRCZWZvcmVEaWZmIiwib2xkQmVmb3JlUmVuZGVyIiwib2xkQWZ0ZXJEaWZmIiwib2xkQ29tbWl0Iiwib2xkQmVmb3JlVW5tb3VudCIsImdldEhvb2tTdGF0ZSIsImluZGV4IiwiaG9va3MiLCJfX0giLCJfX1YiLCJ1c2VTdGF0ZSIsImluaXRpYWxTdGF0ZSIsInVzZVJlZHVjZXIiLCJpbnZva2VPclJldHVybiIsInJlZHVjZXIiLCJpbml0IiwiaG9va1N0YXRlIiwiX3JlZHVjZXIiLCJhY3Rpb24iLCJjdXJyZW50VmFsdWUiLCJfX04iLCJuZXh0VmFsdWUiLCJfaGFzU2N1RnJvbUhvb2tzIiwicHJldlNjdSIsInAiLCJzdGF0ZUhvb2tzIiwiZmlsdGVyIiwieCIsImV2ZXJ5Iiwic2hvdWxkVXBkYXRlIiwiaG9va0l0ZW0iLCJ1c2VFZmZlY3QiLCJhcmdzIiwiYXJnc0NoYW5nZWQiLCJfcGVuZGluZ0FyZ3MiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VSZWYiLCJpbml0aWFsVmFsdWUiLCJ1c2VNZW1vIiwiZmFjdG9yeSIsInVzZUNhbGxiYWNrIiwidXNlQ29udGV4dCIsImZsdXNoQWZ0ZXJQYWludEVmZmVjdHMiLCJzaGlmdCIsImludm9rZUNsZWFudXAiLCJpbnZva2VFZmZlY3QiLCJfX20iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJhZnRlck5leHRGcmFtZSIsImhhc0Vycm9yZWQiLCJIQVNfUkFGIiwicmFmIiwiZG9uZSIsImNsZWFyVGltZW91dCIsInRpbWVvdXQiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImhvb2siLCJjb21wIiwiY2xlYW51cCIsIm9sZEFyZ3MiLCJuZXdBcmdzIiwiYXJnIiwiZiIsInNoYWxsb3dEaWZmZXJzIiwiUHVyZUNvbXBvbmVudCIsIm1lbW8iLCJjb21wYXJlciIsIm5leHRQcm9wcyIsInVwZGF0ZVJlZiIsIk1lbW9lZCIsImRpc3BsYXlOYW1lIiwiaXNSZWFjdENvbXBvbmVudCIsImlzUHVyZVJlYWN0Q29tcG9uZW50Iiwib2xkRGlmZkhvb2siLCJfX2YiLCJtYXBGbiIsIm9sZENhdGNoRXJyb3IiLCJ0aGVuIiwib2xkVW5tb3VudCIsImRldGFjaGVkQ2xvbmUiLCJkZXRhY2hlZFBhcmVudCIsImVmZmVjdCIsIm1hcCIsInJlbW92ZU9yaWdpbmFsIiwib3JpZ2luYWxQYXJlbnQiLCJTdXNwZW5zZSIsIl9fdSIsIl9zdXNwZW5kZXJzIiwic3VzcGVuZGVkIiwiX19hIiwiU3VzcGVuc2VMaXN0IiwiX25leHQiLCJfbWFwIiwiX19SIiwicHJvbWlzZSIsInN1c3BlbmRpbmdWTm9kZSIsInN1c3BlbmRpbmdDb21wb25lbnQiLCJyZXNvbHZlIiwicmVzb2x2ZWQiLCJvblJlc29sdmVkIiwib25TdXNwZW5zaW9uQ29tcGxldGUiLCJzdXNwZW5kZWRWTm9kZSIsInBvcCIsIndhc0h5ZHJhdGluZyIsImRldGFjaGVkQ29tcG9uZW50IiwiX19PIiwiZmFsbGJhY2siLCJsaXN0IiwiZGVsZXRlIiwicmV2ZWFsT3JkZXIiLCJzaXplIiwiZGVsZWdhdGVkIiwiZ2V0IiwidW5zdXNwZW5kIiwid3JhcHBlZFVuc3VzcGVuZCIsIk1hcCIsInJldmVyc2UiLCJzZXQiLCJfdGhpcyIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIkNBTUVMX1BST1BTIiwiSVNfRE9NIiwib25DaGFuZ2VJbnB1dFR5cGUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsInYiLCJ3cml0YWJsZSIsIm9sZEV2ZW50SG9vayIsImVtcHR5IiwiaXNQcm9wYWdhdGlvblN0b3BwZWQiLCJjYW5jZWxCdWJibGUiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJkZWZhdWx0UHJldmVudGVkIiwicGVyc2lzdCIsIm5hdGl2ZUV2ZW50IiwiY2xhc3NOYW1lRGVzY3JpcHRvciIsImNsYXNzIiwib2xkVk5vZGVIb29rIiwibm9uQ3VzdG9tRWxlbWVudCIsIm11bHRpcGxlIiwic2VsZWN0ZWQiLCJjbGFzc05hbWUiLCJlbnVtZXJhYmxlIiwiJCR0eXBlb2YiLCJVbnNldCIsIm9iamVjdFByb3RvIiwiaGFzT3duUHJvcGVydHkiLCJuYXRpdmVPYmplY3RUb1N0cmluZyIsInN5bVRvU3RyaW5nVGFnIiwiRlVOQ19FUlJPUl9URVhUIiwidXNlU3RhdGVQIiwiaWRlbnRpdHkiLCJnZXREb2N1bWVudCIsImNhbmRpZGF0ZVNlbGVjdG9ycyIsIk5vRWxlbWVudCIsIkVsZW1lbnQiLCJtYXRjaGVzIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJnZXRSb290Tm9kZSIsImVsZW1lbnQiLCJvd25lckRvY3VtZW50IiwiaXNJbnB1dCIsInRhZ05hbWUiLCJpc0hpZGRlbklucHV0IiwiaXNEZXRhaWxzV2l0aFN1bW1hcnkiLCJhcHBseSIsImlzTm9kZUF0dGFjaGVkIiwibm9kZVJvb3RIb3N0IiwiaG9zdCIsImF0dGFjaGVkIiwiY29udGFpbnMiLCJpc1plcm9BcmVhIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwid2lkdGgiLCJoZWlnaHQiLCJpc0hpZGRlbiIsImRpc3BsYXlDaGVjayIsImdldFNoYWRvd1Jvb3QiLCJnZXRDb21wdXRlZFN0eWxlIiwidmlzaWJpbGl0eSIsImlzRGlyZWN0U3VtbWFyeSIsIm5vZGVVbmRlckRldGFpbHMiLCJwYXJlbnRFbGVtZW50Iiwib3JpZ2luYWxOb2RlIiwicm9vdE5vZGUiLCJzaGFkb3dSb290IiwiYXNzaWduZWRTbG90IiwiZ2V0Q2xpZW50UmVjdHMiLCJpc0Rpc2FibGVkRnJvbUZpZWxkc2V0IiwiZGlzYWJsZWQiLCJpdGVtIiwiaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZSIsImZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yIiwiY29uY2F0Iiwiam9pbiIsImlzRm9jdXNhYmxlIiwiRXJyb3IiLCJhcmdzVGFnIiwiZnJlZUV4cG9ydHMiLCJmcmVlTW9kdWxlIiwibW9kdWxlRXhwb3J0cyIsIk1BWF9TQUZFX0lOVEVHRVIiLCJmdW5jVGFnIiwiaCIsInNodWZmbGUiLCJsb2Rhc2hTaHVmZmxlIiwiX2pzeHMiLCJfanN4IiwiUmFuZG9tV29yZHMiXSwibWFwcGluZ3MiOiI7OztBQTBCYUEsUUFBQUEsQ0FBQUEsQ0NmUEMsR0NSRkMsQ0FBQUEsR0FBQUEsQ0N5S0FDLENBQUFBLENBV0FDLElDckxPQyxHQ0ZFQyxDQUFBQSxHQUFBQSxDQUFZLEVBQWxCLENBQ01DLEdBQVksQ0FBQSxFQUFBLENBQ1pDLEdBQXFCLENBQUEsb0VMT2xCQyxTQUFBQSxHQUFPQyxDQUFBQSxDQUFBQSxDQUFLQyxDQUUzQixDQUFBLENBQUEsSUFBSyxJQUFJTixDQUFBQSxJQUFLTSxDQUFPRCxDQUFBQSxDQUFBQSxDQUFJTCxHQUFLTSxDQUFNTixDQUFBQSxDQUFBQSxDQUFBQSxDQUNwQyxPQUE2QkssQ0FDN0IsQ0FRTSxTQUFTRSxHQUFBQSxDQUFXQyxDQUMxQixDQUFBLENBQUEsSUFBSUMsRUFBYUQsQ0FBS0MsQ0FBQUEsVUFBQUEsQ0FDbEJBLENBQVlBLEVBQUFBLENBQUFBLENBQVdDLFdBQVlGLENBQUFBLENBQUFBLEVBQ3ZDLENFWE0sU0FBU0csSUFBY0MsQ0FBTU4sQ0FBQUEsQ0FBQUEsQ0FBT08sQ0FDMUMsQ0FBQSxDQUFBLElBQ0NDLENBQ0FDLENBQUFBLENBQUFBLENBQ0FmLENBSEdnQixDQUFBQSxDQUFBQSxDQUFrQixFQUl0QixDQUFBLElBQUtoQixDQUFLTSxJQUFBQSxDQUFBQSxDQUNBLEtBQUxOLEVBQUFBLENBQUFBLENBQVljLENBQU1SLENBQUFBLENBQUFBLENBQU1OLEdBQ2QsS0FBTEEsRUFBQUEsQ0FBQUEsQ0FBWWUsQ0FBTVQsQ0FBQUEsQ0FBQUEsQ0FBTU4sR0FDNUJnQixDQUFnQmhCLENBQUFBLENBQUFBLENBQUFBLENBQUtNLENBQU1OLENBQUFBLENBQUFBLENBQUFBLENBVWpDLEdBUElpQixTQUFVQyxDQUFBQSxNQUFBQSxDQUFTLENBQ3RCRixHQUFBQSxDQUFBQSxDQUFnQkgsUUFDZkksQ0FB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QyxLQUFLLENBQUMsWUFBWSxDQUFDLEVBQUUsS0FBSyxHQUFHLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUM3RCxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBRU4sSUFBQSxPQUFPLEVBQUUsV0FBVyxFQUFFLG9CQUFvQixFQUFFLGVBQWUsRUFBRSxDQUFDO0lBQ2xFOztJQzNkQSxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLFFBQVEsRUFBRSxPQUFPLENBQUMsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxLQUFLLEdBQUcsUUFBUSxFQUFFLE9BQU8sQ0FBQyxDQUFDLEdBQUcsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQVEsU0FBUyxJQUFJLEVBQUUsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLElB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QSxRQUFBLEVBQUEsZUFBQSxFQUFBLENBQXNCLElBQUssRUFBUSxDQUFBLEVBQ3JGQSx5QkFBUSxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSUQsdUJBQUlDLEdBQUssQ0FBQSxJQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQyxDQUFDLElBQUksR0FBTSxFQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsVUFBVSxFQUFDQSxHQUFBLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFLLENBQUMsQ0FBQyxJQUFJLEdBQU0sRUFBQUEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLFFBQUEsRUFBSyxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsQ0FBQyxFQUFNLENBQUEsQ0FBQSxFQUFBLENBQUssQ0FBQyxFQUFTLENBQUEsQ0FBQSxFQUFBLENBQzFJLElBQU0sRUFDZEEsR0FBQSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQU0sRUFFTCx1QkFBdUIsSUFBSSxJQUFJLElBQUlELEdBQUEsQ0FBQSxLQUFBLEVBQUEsRUFBQSxRQUFBLEVBQUEsQ0FBQSx5QkFBQSxFQUE0QkMsc0JBQUssS0FBSyxDQUFDLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLElBQUlBLHNCQUFLLElBQUksRUFBQSxDQUFNLENBQUMsRUFBTSxDQUFBLENBQUEsRUFBQSxDQUFNLEVBQ2hKLHFCQUFxQixJQUFJLElBQUksSUFBSUQsR0FBQSxDQUFBLEtBQUEsRUFBQSxFQUFBLFFBQUEsRUFBQSxDQUFBLDBCQUFBLEVBQTZCQyxzQkFBSyxxQkFBcUIsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJQSxHQUFLLENBQUEsSUFBQSxFQUFBLEVBQUEsUUFBQSxFQUFBLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEVBQUEsQ0FBTSxDQUFDLEVBQU0sQ0FBQSxDQUFBLEVBQUEsQ0FBTSxFQUU1SUEsR0FBTSxDQUFBLElBQUEsRUFBQSxFQUFBLENBQUEsRUFDTCxTQUFTLElBQUlBLEdB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
